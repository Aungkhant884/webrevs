{"files":[{"patch":"@@ -0,0 +1,1 @@\n+*\t-text\n","filename":".gitattributes","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -664,0 +664,1 @@\n+36b29df125dc88f11657ce93b4998aa9ff5f5d41 jdk-16+14\n","filename":".hgtags","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/$(HOTSPOT_TARGET_CPU_ARCH)_sve.ad \\\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,43 @@\n+class SVEVectorRegister(FloatRegister):\n+    def __str__(self):\n+        return self.astr(\"z\")\n+\n+class SVEPRegister(Register):\n+    def __str__(self):\n+        return self.astr(\"p\")\n+\n+    def generate(self):\n+        self.number = random.randint(0, 15)\n+        return self\n+\n+class SVEGoverningPRegister(Register):\n+    def __str__(self):\n+        return self.astr(\"p\")\n+    def generate(self):\n+        self.number = random.randint(0, 7)\n+        return self\n+\n+class RegVariant(object):\n+    def __init__(self, low, high):\n+        self.number = random.randint(low, high)\n+\n+    def astr(self):\n+        nameMap = {\n+             0: \".b\",\n+             1: \".h\",\n+             2: \".s\",\n+             3: \".d\",\n+             4: \".q\"\n+        }\n+        return nameMap.get(self.number)\n+\n+    def cstr(self):\n+        nameMap = {\n+             0: \"__ B\",\n+             1: \"__ H\",\n+             2: \"__ S\",\n+             3: \"__ D\",\n+             4: \"__ Q\"\n+        }\n+        return nameMap.get(self.number)\n+\n@@ -90,1 +133,4 @@\n-              'z' : FloatZero}\n+              'z' : FloatZero,\n+              'p' : SVEPRegister,\n+              'P' : SVEGoverningPRegister,\n+              'Z' : SVEVectorRegister}\n@@ -848,0 +894,94 @@\n+class SVEVectorOp(Instruction):\n+    def __init__(self, args):\n+        name = args[0]\n+        regTypes = args[1]\n+        regs = []\n+        for c in regTypes:\n+            regs.append(OperandFactory.create(c).generate())\n+        self.reg = regs\n+        self.numRegs = len(regs)\n+        if regTypes[0] != \"p\" and regTypes[1] == 'P':\n+           self._isPredicated = True\n+           self._merge = \"\/m\"\n+        else:\n+           self._isPredicated = False\n+           self._merge =\"\"\n+\n+        self._bitwiseop = False\n+        if name[0] == 'f':\n+            self._width = RegVariant(2, 3)\n+        elif not self._isPredicated and (name == \"and\" or name == \"eor\" or name == \"orr\"):\n+            self._width = RegVariant(3, 3)\n+            self._bitwiseop = True\n+        else:\n+            self._width = RegVariant(0, 3)\n+        if len(args) > 2:\n+            self._dnm = args[2]\n+        else:\n+            self._dnm = None\n+        Instruction.__init__(self, name)\n+\n+    def cstr(self):\n+        formatStr = \"%s%s\" + ''.join([\", %s\" for i in range(0, self.numRegs)] + [\");\"])\n+        if self._bitwiseop:\n+            width = []\n+            formatStr = \"%s%s\" + ''.join([\", %s\" for i in range(1, self.numRegs)] + [\");\"])\n+        else:\n+            width = [self._width.cstr()]\n+        return (formatStr\n+                % tuple([\"__ sve_\" + self._name + \"(\"] +\n+                        [str(self.reg[0])] +\n+                        width +\n+                        [str(self.reg[i]) for i in range(1, self.numRegs)]))\n+    def astr(self):\n+        formatStr = \"%s%s\" + ''.join([\", %s\" for i in range(1, self.numRegs)])\n+        if self._dnm == 'dn':\n+            formatStr += \", %s\"\n+            dnReg = [str(self.reg[0]) + self._width.astr()]\n+        else:\n+            dnReg = []\n+\n+        if self._isPredicated:\n+            restRegs = [str(self.reg[1]) + self._merge] + dnReg + [str(self.reg[i]) + self._width.astr() for i in range(2, self.numRegs)]\n+        else:\n+            restRegs = dnReg + [str(self.reg[i]) + self._width.astr() for i in range(1, self.numRegs)]\n+        return (formatStr\n+                % tuple([Instruction.astr(self)] +\n+                        [str(self.reg[0]) + self._width.astr()] +\n+                        restRegs))\n+    def generate(self):\n+        return self\n+\n+class SVEReductionOp(Instruction):\n+    def __init__(self, args):\n+        name = args[0]\n+        lowRegType = args[1]\n+        self.reg = []\n+        Instruction.__init__(self, name)\n+        self.reg.append(OperandFactory.create('s').generate())\n+        self.reg.append(OperandFactory.create('P').generate())\n+        self.reg.append(OperandFactory.create('Z').generate())\n+        self._width = RegVariant(lowRegType, 3)\n+    def cstr(self):\n+        return \"__ sve_%s(%s, %s, %s, %s);\" % (self.name(),\n+                                              str(self.reg[0]),\n+                                              self._width.cstr(),\n+                                              str(self.reg[1]),\n+                                              str(self.reg[2]))\n+    def astr(self):\n+        if self.name() == \"uaddv\":\n+            dstRegName = \"d\" + str(self.reg[0].number)\n+        else:\n+            dstRegName = self._width.astr()[1] + str(self.reg[0].number)\n+        formatStr = \"%s %s, %s, %s\"\n+        if self.name() == \"fadda\":\n+            formatStr += \", %s\"\n+            moreReg = [dstRegName]\n+        else:\n+            moreReg = []\n+        return formatStr % tuple([self.name()] +\n+                                 [dstRegName] +\n+                                 [str(self.reg[1])] +\n+                                 moreReg +\n+                                 [str(self.reg[2]) + self._width.astr()])\n+\n@@ -1314,1 +1454,36 @@\n-                        [\"ld1\",    \"__ ld1(v31, v0, __ T2D, Address(__ post(r1, r0)));\", \"ld1\\t{v31.2d, v0.2d}, [x1], x0\"]])\n+                        [\"ld1\",    \"__ ld1(v31, v0, __ T2D, Address(__ post(r1, r0)));\", \"ld1\\t{v31.2d, v0.2d}, [x1], x0\"],\n+                        # SVE instructions\n+                        [\"cpy\",    \"__ sve_cpy(z0, __ S, p0, v1);\",                      \"mov\\tz0.s, p0\/m, s1\"],\n+                        [\"inc\",    \"__ sve_inc(r0, __ S);\",                              \"incw\\tx0\"],\n+                        [\"dec\",    \"__ sve_dec(r1, __ H);\",                              \"dech\\tx1\"],\n+                        [\"lsl\",    \"__ sve_lsl(z0, __ B, z1, 7);\",                       \"lsl\\tz0.b, z1.b, #7\"],\n+                        [\"lsl\",    \"__ sve_lsl(z21, __ H, z1, 15);\",                     \"lsl\\tz21.h, z1.h, #15\"],\n+                        [\"lsl\",    \"__ sve_lsl(z0, __ S, z1, 31);\",                      \"lsl\\tz0.s, z1.s, #31\"],\n+                        [\"lsl\",    \"__ sve_lsl(z0, __ D, z1, 63);\",                      \"lsl\\tz0.d, z1.d, #63\"],\n+                        [\"lsr\",    \"__ sve_lsr(z0, __ B, z1, 7);\",                       \"lsr\\tz0.b, z1.b, #7\"],\n+                        [\"asr\",    \"__ sve_asr(z0, __ H, z11, 15);\",                     \"asr\\tz0.h, z11.h, #15\"],\n+                        [\"lsr\",    \"__ sve_lsr(z30, __ S, z1, 31);\",                     \"lsr\\tz30.s, z1.s, #31\"],\n+                        [\"asr\",    \"__ sve_asr(z0, __ D, z1, 63);\",                      \"asr\\tz0.d, z1.d, #63\"],\n+                        [\"addvl\",  \"__ sve_addvl(sp, r0, 31);\",                          \"addvl\\tsp, x0, #31\"],\n+                        [\"addpl\",  \"__ sve_addpl(r1, sp, -32);\",                         \"addpl\\tx1, sp, -32\"],\n+                        [\"cntp\",   \"__ sve_cntp(r8, __ B, p0, p1);\",                     \"cntp\\tx8, p0, p1.b\"],\n+                        [\"dup\",    \"__ sve_dup(z0, __ B, 127);\",                         \"dup\\tz0.b, 127\"],\n+                        [\"dup\",    \"__ sve_dup(z1, __ H, -128);\",                        \"dup\\tz1.h, -128\"],\n+                        [\"dup\",    \"__ sve_dup(z2, __ S, 32512);\",                       \"dup\\tz2.s, 32512\"],\n+                        [\"dup\",    \"__ sve_dup(z7, __ D, -32768);\",                      \"dup\\tz7.d, -32768\"],\n+                        [\"ld1b\",   \"__ sve_ld1b(z0, __ B, p0, Address(sp));\",            \"ld1b\\t{z0.b}, p0\/z, [sp]\"],\n+                        [\"ld1h\",   \"__ sve_ld1h(z10, __ H, p1, Address(sp, -8));\",       \"ld1h\\t{z10.h}, p1\/z, [sp, #-8, MUL VL]\"],\n+                        [\"ld1w\",   \"__ sve_ld1w(z20, __ S, p2, Address(r0, 7));\",        \"ld1w\\t{z20.s}, p2\/z, [x0, #7, MUL VL]\"],\n+                        [\"ld1b\",   \"__ sve_ld1b(z30, __ B, p3, Address(sp, r8));\",       \"ld1b\\t{z30.b}, p3\/z, [sp, x8]\"],\n+                        [\"ld1w\",   \"__ sve_ld1w(z0, __ S, p4, Address(sp, r28));\",       \"ld1w\\t{z0.s}, p4\/z, [sp, x28, LSL #2]\"],\n+                        [\"ld1d\",   \"__ sve_ld1d(z11, __ D, p5, Address(r0, r1));\",       \"ld1d\\t{z11.d}, p5\/z, [x0, x1, LSL #3]\"],\n+                        [\"st1b\",   \"__ sve_st1b(z22, __ B, p6, Address(sp));\",           \"st1b\\t{z22.b}, p6, [sp]\"],\n+                        [\"st1b\",   \"__ sve_st1b(z31, __ B, p7, Address(sp, -8));\",       \"st1b\\t{z31.b}, p7, [sp, #-8, MUL VL]\"],\n+                        [\"st1w\",   \"__ sve_st1w(z0, __ S, p1, Address(r0, 7));\",         \"st1w\\t{z0.s}, p1, [x0, #7, MUL VL]\"],\n+                        [\"st1b\",   \"__ sve_st1b(z0, __ B, p2, Address(sp, r1));\",        \"st1b\\t{z0.b}, p2, [sp, x1]\"],\n+                        [\"st1h\",   \"__ sve_st1h(z0, __ H, p3, Address(sp, r8));\",        \"st1h\\t{z0.h}, p3, [sp, x8, LSL #1]\"],\n+                        [\"st1d\",   \"__ sve_st1d(z0, __ D, p4, Address(r0, r18));\",       \"st1d\\t{z0.d}, p4, [x0, x18, LSL #3]\"],\n+                        [\"ldr\",    \"__ sve_ldr(z0, Address(sp));\",                       \"ldr\\tz0, [sp]\"],\n+                        [\"ldr\",    \"__ sve_ldr(z31, Address(sp, -256));\",                \"ldr\\tz31, [sp, #-256, MUL VL]\"],\n+                        [\"str\",    \"__ sve_str(z8, Address(r8, 255));\",                  \"str\\tz8, [x8, #255, MUL VL]\"],\n+])\n@@ -1339,0 +1514,43 @@\n+generate(SVEVectorOp, [[\"add\", \"ZZZ\"],\n+                       [\"sub\", \"ZZZ\"],\n+                       [\"fadd\", \"ZZZ\"],\n+                       [\"fmul\", \"ZZZ\"],\n+                       [\"fsub\", \"ZZZ\"],\n+                       [\"abs\", \"ZPZ\"],\n+                       [\"add\", \"ZPZ\", \"dn\"],\n+                       [\"asr\", \"ZPZ\", \"dn\"],\n+                       [\"cnt\", \"ZPZ\"],\n+                       [\"lsl\", \"ZPZ\", \"dn\"],\n+                       [\"lsr\", \"ZPZ\", \"dn\"],\n+                       [\"mul\", \"ZPZ\", \"dn\"],\n+                       [\"neg\", \"ZPZ\"],\n+                       [\"not\", \"ZPZ\"],\n+                       [\"smax\", \"ZPZ\", \"dn\"],\n+                       [\"smin\", \"ZPZ\", \"dn\"],\n+                       [\"sub\", \"ZPZ\", \"dn\"],\n+                       [\"fabs\", \"ZPZ\"],\n+                       [\"fadd\", \"ZPZ\", \"dn\"],\n+                       [\"fdiv\", \"ZPZ\", \"dn\"],\n+                       [\"fmax\", \"ZPZ\", \"dn\"],\n+                       [\"fmin\", \"ZPZ\", \"dn\"],\n+                       [\"fmul\", \"ZPZ\", \"dn\"],\n+                       [\"fneg\", \"ZPZ\"],\n+                       [\"frintm\", \"ZPZ\"],\n+                       [\"frintn\", \"ZPZ\"],\n+                       [\"frintp\", \"ZPZ\"],\n+                       [\"fsqrt\", \"ZPZ\"],\n+                       [\"fsub\", \"ZPZ\", \"dn\"],\n+                       [\"fmla\", \"ZPZZ\"],\n+                       [\"fmls\", \"ZPZZ\"],\n+                       [\"fnmla\", \"ZPZZ\"],\n+                       [\"fnmls\", \"ZPZZ\"],\n+                       [\"mla\", \"ZPZZ\"],\n+                       [\"mls\", \"ZPZZ\"],\n+                       [\"and\", \"ZZZ\"],\n+                       [\"eor\", \"ZZZ\"],\n+                       [\"orr\", \"ZZZ\"],\n+                      ])\n+\n+generate(SVEReductionOp, [[\"andv\", 0], [\"orv\", 0], [\"eorv\", 0], [\"smaxv\", 0], [\"sminv\", 0],\n+                          [\"fminv\", 2], [\"fmaxv\", 2], [\"fadda\", 2], [\"uaddv\", 0]])\n+\n@@ -1344,3 +1562,2 @@\n-# compile for 8.1 and sha2 because of lse atomics and sha512 crypto extension.\n-subprocess.check_call([AARCH64_AS, \"-march=armv8.1-a+sha2\", \"aarch64ops.s\", \"-o\", \"aarch64ops.o\"])\n-output = subprocess.check_output([AARCH64_OBJDUMP, \"-d\", \"aarch64ops.o\"])\n+# compile for sve with 8.1 and sha2 because of lse atomics and sha512 crypto extension.\n+subprocess.check_call([AARCH64_AS, \"-march=armv8.1-a+sha2+sve\", \"aarch64ops.s\", \"-o\", \"aarch64ops.o\"])\n@@ -1350,1 +1567,0 @@\n-print output\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64-asmtest.py","additions":222,"deletions":6,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-\/\/   r8-r9 invisible to the allocator (so we can use them as scratch regs)\n+\/\/   r8-r9 non-allocatable (so we can use them as scratch regs)\n@@ -97,0 +97,4 @@\n+reg_def R8      ( NS,  SOC, Op_RegI,  8, r8->as_VMReg()         ); \/\/ rscratch1, non-allocatable\n+reg_def R8_H    ( NS,  SOC, Op_RegI,  8, r8->as_VMReg()->next() );\n+reg_def R9      ( NS,  SOC, Op_RegI,  9, r9->as_VMReg()         ); \/\/ rscratch2, non-allocatable\n+reg_def R9_H    ( NS,  SOC, Op_RegI,  9, r9->as_VMReg()->next() );\n@@ -143,1 +147,1 @@\n-\/\/ Float\/Double Registers\n+\/\/ Float\/Double\/Vector Registers\n@@ -164,159 +168,318 @@\n-  reg_def V0   ( SOC, SOC, Op_RegF,  0, v0->as_VMReg()          );\n-  reg_def V0_H ( SOC, SOC, Op_RegF,  0, v0->as_VMReg()->next()  );\n-  reg_def V0_J ( SOC, SOC, Op_RegF,  0, v0->as_VMReg()->next(2) );\n-  reg_def V0_K ( SOC, SOC, Op_RegF,  0, v0->as_VMReg()->next(3) );\n-\n-  reg_def V1   ( SOC, SOC, Op_RegF,  1, v1->as_VMReg()          );\n-  reg_def V1_H ( SOC, SOC, Op_RegF,  1, v1->as_VMReg()->next()  );\n-  reg_def V1_J ( SOC, SOC, Op_RegF,  1, v1->as_VMReg()->next(2) );\n-  reg_def V1_K ( SOC, SOC, Op_RegF,  1, v1->as_VMReg()->next(3) );\n-\n-  reg_def V2   ( SOC, SOC, Op_RegF,  2, v2->as_VMReg()          );\n-  reg_def V2_H ( SOC, SOC, Op_RegF,  2, v2->as_VMReg()->next()  );\n-  reg_def V2_J ( SOC, SOC, Op_RegF,  2, v2->as_VMReg()->next(2) );\n-  reg_def V2_K ( SOC, SOC, Op_RegF,  2, v2->as_VMReg()->next(3) );\n-\n-  reg_def V3   ( SOC, SOC, Op_RegF,  3, v3->as_VMReg()          );\n-  reg_def V3_H ( SOC, SOC, Op_RegF,  3, v3->as_VMReg()->next()  );\n-  reg_def V3_J ( SOC, SOC, Op_RegF,  3, v3->as_VMReg()->next(2) );\n-  reg_def V3_K ( SOC, SOC, Op_RegF,  3, v3->as_VMReg()->next(3) );\n-\n-  reg_def V4   ( SOC, SOC, Op_RegF,  4, v4->as_VMReg()          );\n-  reg_def V4_H ( SOC, SOC, Op_RegF,  4, v4->as_VMReg()->next()  );\n-  reg_def V4_J ( SOC, SOC, Op_RegF,  4, v4->as_VMReg()->next(2) );\n-  reg_def V4_K ( SOC, SOC, Op_RegF,  4, v4->as_VMReg()->next(3) );\n-\n-  reg_def V5   ( SOC, SOC, Op_RegF,  5, v5->as_VMReg()          );\n-  reg_def V5_H ( SOC, SOC, Op_RegF,  5, v5->as_VMReg()->next()  );\n-  reg_def V5_J ( SOC, SOC, Op_RegF,  5, v5->as_VMReg()->next(2) );\n-  reg_def V5_K ( SOC, SOC, Op_RegF,  5, v5->as_VMReg()->next(3) );\n-\n-  reg_def V6   ( SOC, SOC, Op_RegF,  6, v6->as_VMReg()          );\n-  reg_def V6_H ( SOC, SOC, Op_RegF,  6, v6->as_VMReg()->next()  );\n-  reg_def V6_J ( SOC, SOC, Op_RegF,  6, v6->as_VMReg()->next(2) );\n-  reg_def V6_K ( SOC, SOC, Op_RegF,  6, v6->as_VMReg()->next(3) );\n-\n-  reg_def V7   ( SOC, SOC, Op_RegF,  7, v7->as_VMReg()          );\n-  reg_def V7_H ( SOC, SOC, Op_RegF,  7, v7->as_VMReg()->next()  );\n-  reg_def V7_J ( SOC, SOC, Op_RegF,  7, v7->as_VMReg()->next(2) );\n-  reg_def V7_K ( SOC, SOC, Op_RegF,  7, v7->as_VMReg()->next(3) );\n-\n-  reg_def V8   ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()          );\n-  reg_def V8_H ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()->next()  );\n-  reg_def V8_J ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()->next(2) );\n-  reg_def V8_K ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()->next(3) );\n-\n-  reg_def V9   ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()          );\n-  reg_def V9_H ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()->next()  );\n-  reg_def V9_J ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()->next(2) );\n-  reg_def V9_K ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()->next(3) );\n-\n-  reg_def V10  ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()         );\n-  reg_def V10_H( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next() );\n-  reg_def V10_J( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(2));\n-  reg_def V10_K( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(3));\n-\n-  reg_def V11  ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()         );\n-  reg_def V11_H( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next() );\n-  reg_def V11_J( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(2));\n-  reg_def V11_K( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(3));\n-\n-  reg_def V12  ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()         );\n-  reg_def V12_H( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next() );\n-  reg_def V12_J( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(2));\n-  reg_def V12_K( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(3));\n-\n-  reg_def V13  ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()         );\n-  reg_def V13_H( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next() );\n-  reg_def V13_J( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(2));\n-  reg_def V13_K( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(3));\n-\n-  reg_def V14  ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()         );\n-  reg_def V14_H( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next() );\n-  reg_def V14_J( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(2));\n-  reg_def V14_K( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(3));\n-\n-  reg_def V15  ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()         );\n-  reg_def V15_H( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next() );\n-  reg_def V15_J( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(2));\n-  reg_def V15_K( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(3));\n-\n-  reg_def V16  ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()         );\n-  reg_def V16_H( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next() );\n-  reg_def V16_J( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(2));\n-  reg_def V16_K( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(3));\n-\n-  reg_def V17  ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()         );\n-  reg_def V17_H( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next() );\n-  reg_def V17_J( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(2));\n-  reg_def V17_K( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(3));\n-\n-  reg_def V18  ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()         );\n-  reg_def V18_H( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next() );\n-  reg_def V18_J( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(2));\n-  reg_def V18_K( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(3));\n-\n-  reg_def V19  ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()         );\n-  reg_def V19_H( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next() );\n-  reg_def V19_J( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(2));\n-  reg_def V19_K( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(3));\n-\n-  reg_def V20  ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()         );\n-  reg_def V20_H( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next() );\n-  reg_def V20_J( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(2));\n-  reg_def V20_K( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(3));\n-\n-  reg_def V21  ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()         );\n-  reg_def V21_H( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next() );\n-  reg_def V21_J( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(2));\n-  reg_def V21_K( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(3));\n-\n-  reg_def V22  ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()         );\n-  reg_def V22_H( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next() );\n-  reg_def V22_J( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(2));\n-  reg_def V22_K( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(3));\n-\n-  reg_def V23  ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()         );\n-  reg_def V23_H( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next() );\n-  reg_def V23_J( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(2));\n-  reg_def V23_K( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(3));\n-\n-  reg_def V24  ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()         );\n-  reg_def V24_H( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next() );\n-  reg_def V24_J( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(2));\n-  reg_def V24_K( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(3));\n-\n-  reg_def V25  ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()         );\n-  reg_def V25_H( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next() );\n-  reg_def V25_J( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(2));\n-  reg_def V25_K( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(3));\n-\n-  reg_def V26  ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()         );\n-  reg_def V26_H( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next() );\n-  reg_def V26_J( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(2));\n-  reg_def V26_K( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(3));\n-\n-  reg_def V27  ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()         );\n-  reg_def V27_H( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next() );\n-  reg_def V27_J( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(2));\n-  reg_def V27_K( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(3));\n-\n-  reg_def V28  ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()         );\n-  reg_def V28_H( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next() );\n-  reg_def V28_J( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(2));\n-  reg_def V28_K( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(3));\n-\n-  reg_def V29  ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()         );\n-  reg_def V29_H( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next() );\n-  reg_def V29_J( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(2));\n-  reg_def V29_K( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(3));\n-\n-  reg_def V30  ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()         );\n-  reg_def V30_H( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next() );\n-  reg_def V30_J( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(2));\n-  reg_def V30_K( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(3));\n-\n-  reg_def V31  ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()         );\n-  reg_def V31_H( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next() );\n-  reg_def V31_J( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(2));\n-  reg_def V31_K( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(3));\n+\/\/ For SVE vector registers, we simply extend vector register size to 8\n+\/\/ 'logical' slots. This is nominally 256 bits but it actually covers\n+\/\/ all possible 'physical' SVE vector register lengths from 128 ~ 2048\n+\/\/ bits. The 'physical' SVE vector register length is detected during\n+\/\/ startup, so the register allocator is able to identify the correct\n+\/\/ number of bytes needed for an SVE spill\/unspill.\n+\/\/ Note that a vector register with 4 slots denotes a 128-bit NEON\n+\/\/ register allowing it to be distinguished from the corresponding SVE\n+\/\/ vector register when the SVE vector length is 128 bits.\n+\n+  reg_def V0   ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()          );\n+  reg_def V0_H ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next()  );\n+  reg_def V0_J ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(2) );\n+  reg_def V0_K ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(3) );\n+  reg_def V0_L ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(4) );\n+  reg_def V0_M ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(5) );\n+  reg_def V0_N ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(6) );\n+  reg_def V0_O ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(7) );\n+\n+  reg_def V1   ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()          );\n+  reg_def V1_H ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next()  );\n+  reg_def V1_J ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(2) );\n+  reg_def V1_K ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(3) );\n+  reg_def V1_L ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(4) );\n+  reg_def V1_M ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(5) );\n+  reg_def V1_N ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(6) );\n+  reg_def V1_O ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(7) );\n+\n+  reg_def V2   ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()          );\n+  reg_def V2_H ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next()  );\n+  reg_def V2_J ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(2) );\n+  reg_def V2_K ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(3) );\n+  reg_def V2_L ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(4) );\n+  reg_def V2_M ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(5) );\n+  reg_def V2_N ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(6) );\n+  reg_def V2_O ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(7) );\n+\n+  reg_def V3   ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()          );\n+  reg_def V3_H ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next()  );\n+  reg_def V3_J ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(2) );\n+  reg_def V3_K ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(3) );\n+  reg_def V3_L ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(4) );\n+  reg_def V3_M ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(5) );\n+  reg_def V3_N ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(6) );\n+  reg_def V3_O ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(7) );\n+\n+  reg_def V4   ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()          );\n+  reg_def V4_H ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next()  );\n+  reg_def V4_J ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(2) );\n+  reg_def V4_K ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(3) );\n+  reg_def V4_L ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(4) );\n+  reg_def V4_M ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(5) );\n+  reg_def V4_N ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(6) );\n+  reg_def V4_O ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(7) );\n+\n+  reg_def V5   ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()          );\n+  reg_def V5_H ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next()  );\n+  reg_def V5_J ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(2) );\n+  reg_def V5_K ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(3) );\n+  reg_def V5_L ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(4) );\n+  reg_def V5_M ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(5) );\n+  reg_def V5_N ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(6) );\n+  reg_def V5_O ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(7) );\n+\n+  reg_def V6   ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()          );\n+  reg_def V6_H ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next()  );\n+  reg_def V6_J ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(2) );\n+  reg_def V6_K ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(3) );\n+  reg_def V6_L ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(4) );\n+  reg_def V6_M ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(5) );\n+  reg_def V6_N ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(6) );\n+  reg_def V6_O ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(7) );\n+\n+  reg_def V7   ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()          );\n+  reg_def V7_H ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next()  );\n+  reg_def V7_J ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(2) );\n+  reg_def V7_K ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(3) );\n+  reg_def V7_L ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(4) );\n+  reg_def V7_M ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(5) );\n+  reg_def V7_N ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(6) );\n+  reg_def V7_O ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(7) );\n+\n+  reg_def V8   ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()          );\n+  reg_def V8_H ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next()  );\n+  reg_def V8_J ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(2) );\n+  reg_def V8_K ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(3) );\n+  reg_def V8_L ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(4) );\n+  reg_def V8_M ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(5) );\n+  reg_def V8_N ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(6) );\n+  reg_def V8_O ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(7) );\n+\n+  reg_def V9   ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()          );\n+  reg_def V9_H ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next()  );\n+  reg_def V9_J ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(2) );\n+  reg_def V9_K ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(3) );\n+  reg_def V9_L ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(4) );\n+  reg_def V9_M ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(5) );\n+  reg_def V9_N ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(6) );\n+  reg_def V9_O ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(7) );\n+\n+  reg_def V10   ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()          );\n+  reg_def V10_H ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next()  );\n+  reg_def V10_J ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(2) );\n+  reg_def V10_K ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(3) );\n+  reg_def V10_L ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(4) );\n+  reg_def V10_M ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(5) );\n+  reg_def V10_N ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(6) );\n+  reg_def V10_O ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(7) );\n+\n+  reg_def V11   ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()          );\n+  reg_def V11_H ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next()  );\n+  reg_def V11_J ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(2) );\n+  reg_def V11_K ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(3) );\n+  reg_def V11_L ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(4) );\n+  reg_def V11_M ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(5) );\n+  reg_def V11_N ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(6) );\n+  reg_def V11_O ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(7) );\n+\n+  reg_def V12   ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()          );\n+  reg_def V12_H ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next()  );\n+  reg_def V12_J ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(2) );\n+  reg_def V12_K ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(3) );\n+  reg_def V12_L ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(4) );\n+  reg_def V12_M ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(5) );\n+  reg_def V12_N ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(6) );\n+  reg_def V12_O ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(7) );\n+\n+  reg_def V13   ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()          );\n+  reg_def V13_H ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next()  );\n+  reg_def V13_J ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(2) );\n+  reg_def V13_K ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(3) );\n+  reg_def V13_L ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(4) );\n+  reg_def V13_M ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(5) );\n+  reg_def V13_N ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(6) );\n+  reg_def V13_O ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(7) );\n+\n+  reg_def V14   ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()          );\n+  reg_def V14_H ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next()  );\n+  reg_def V14_J ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(2) );\n+  reg_def V14_K ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(3) );\n+  reg_def V14_L ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(4) );\n+  reg_def V14_M ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(5) );\n+  reg_def V14_N ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(6) );\n+  reg_def V14_O ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(7) );\n+\n+  reg_def V15   ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()          );\n+  reg_def V15_H ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next()  );\n+  reg_def V15_J ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(2) );\n+  reg_def V15_K ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(3) );\n+  reg_def V15_L ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(4) );\n+  reg_def V15_M ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(5) );\n+  reg_def V15_N ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(6) );\n+  reg_def V15_O ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(7) );\n+\n+  reg_def V16   ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()          );\n+  reg_def V16_H ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next()  );\n+  reg_def V16_J ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(2) );\n+  reg_def V16_K ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(3) );\n+  reg_def V16_L ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(4) );\n+  reg_def V16_M ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(5) );\n+  reg_def V16_N ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(6) );\n+  reg_def V16_O ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(7) );\n+\n+  reg_def V17   ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()          );\n+  reg_def V17_H ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next()  );\n+  reg_def V17_J ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(2) );\n+  reg_def V17_K ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(3) );\n+  reg_def V17_L ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(4) );\n+  reg_def V17_M ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(5) );\n+  reg_def V17_N ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(6) );\n+  reg_def V17_O ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(7) );\n+\n+  reg_def V18   ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()          );\n+  reg_def V18_H ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next()  );\n+  reg_def V18_J ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(2) );\n+  reg_def V18_K ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(3) );\n+  reg_def V18_L ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(4) );\n+  reg_def V18_M ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(5) );\n+  reg_def V18_N ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(6) );\n+  reg_def V18_O ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(7) );\n+\n+  reg_def V19   ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()          );\n+  reg_def V19_H ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next()  );\n+  reg_def V19_J ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(2) );\n+  reg_def V19_K ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(3) );\n+  reg_def V19_L ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(4) );\n+  reg_def V19_M ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(5) );\n+  reg_def V19_N ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(6) );\n+  reg_def V19_O ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(7) );\n+\n+  reg_def V20   ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()          );\n+  reg_def V20_H ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next()  );\n+  reg_def V20_J ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(2) );\n+  reg_def V20_K ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(3) );\n+  reg_def V20_L ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(4) );\n+  reg_def V20_M ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(5) );\n+  reg_def V20_N ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(6) );\n+  reg_def V20_O ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(7) );\n+\n+  reg_def V21   ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()          );\n+  reg_def V21_H ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next()  );\n+  reg_def V21_J ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(2) );\n+  reg_def V21_K ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(3) );\n+  reg_def V21_L ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(4) );\n+  reg_def V21_M ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(5) );\n+  reg_def V21_N ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(6) );\n+  reg_def V21_O ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(7) );\n+\n+  reg_def V22   ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()          );\n+  reg_def V22_H ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next()  );\n+  reg_def V22_J ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(2) );\n+  reg_def V22_K ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(3) );\n+  reg_def V22_L ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(4) );\n+  reg_def V22_M ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(5) );\n+  reg_def V22_N ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(6) );\n+  reg_def V22_O ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(7) );\n+\n+  reg_def V23   ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()          );\n+  reg_def V23_H ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next()  );\n+  reg_def V23_J ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(2) );\n+  reg_def V23_K ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(3) );\n+  reg_def V23_L ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(4) );\n+  reg_def V23_M ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(5) );\n+  reg_def V23_N ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(6) );\n+  reg_def V23_O ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(7) );\n+\n+  reg_def V24   ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()          );\n+  reg_def V24_H ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next()  );\n+  reg_def V24_J ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(2) );\n+  reg_def V24_K ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(3) );\n+  reg_def V24_L ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(4) );\n+  reg_def V24_M ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(5) );\n+  reg_def V24_N ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(6) );\n+  reg_def V24_O ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(7) );\n+\n+  reg_def V25   ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()          );\n+  reg_def V25_H ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next()  );\n+  reg_def V25_J ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(2) );\n+  reg_def V25_K ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(3) );\n+  reg_def V25_L ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(4) );\n+  reg_def V25_M ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(5) );\n+  reg_def V25_N ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(6) );\n+  reg_def V25_O ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(7) );\n+\n+  reg_def V26   ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()          );\n+  reg_def V26_H ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next()  );\n+  reg_def V26_J ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(2) );\n+  reg_def V26_K ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(3) );\n+  reg_def V26_L ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(4) );\n+  reg_def V26_M ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(5) );\n+  reg_def V26_N ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(6) );\n+  reg_def V26_O ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(7) );\n+\n+  reg_def V27   ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()          );\n+  reg_def V27_H ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next()  );\n+  reg_def V27_J ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(2) );\n+  reg_def V27_K ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(3) );\n+  reg_def V27_L ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(4) );\n+  reg_def V27_M ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(5) );\n+  reg_def V27_N ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(6) );\n+  reg_def V27_O ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(7) );\n+\n+  reg_def V28   ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()          );\n+  reg_def V28_H ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next()  );\n+  reg_def V28_J ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(2) );\n+  reg_def V28_K ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(3) );\n+  reg_def V28_L ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(4) );\n+  reg_def V28_M ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(5) );\n+  reg_def V28_N ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(6) );\n+  reg_def V28_O ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(7) );\n+\n+  reg_def V29   ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()          );\n+  reg_def V29_H ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next()  );\n+  reg_def V29_J ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(2) );\n+  reg_def V29_K ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(3) );\n+  reg_def V29_L ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(4) );\n+  reg_def V29_M ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(5) );\n+  reg_def V29_N ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(6) );\n+  reg_def V29_O ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(7) );\n+\n+  reg_def V30   ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()          );\n+  reg_def V30_H ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next()  );\n+  reg_def V30_J ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(2) );\n+  reg_def V30_K ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(3) );\n+  reg_def V30_L ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(4) );\n+  reg_def V30_M ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(5) );\n+  reg_def V30_N ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(6) );\n+  reg_def V30_O ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(7) );\n+\n+  reg_def V31   ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()          );\n+  reg_def V31_H ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next()  );\n+  reg_def V31_J ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(2) );\n+  reg_def V31_K ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(3) );\n+  reg_def V31_L ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(4) );\n+  reg_def V31_M ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(5) );\n+  reg_def V31_N ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(6) );\n+  reg_def V31_O ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(7) );\n+\n+\n+\/\/ ----------------------------\n+\/\/ SVE Predicate Registers\n+\/\/ ----------------------------\n+  reg_def P0 (SOC, SOC, Op_RegVMask, 0, p0->as_VMReg());\n+  reg_def P1 (SOC, SOC, Op_RegVMask, 1, p1->as_VMReg());\n+  reg_def P2 (SOC, SOC, Op_RegVMask, 2, p2->as_VMReg());\n+  reg_def P3 (SOC, SOC, Op_RegVMask, 3, p3->as_VMReg());\n+  reg_def P4 (SOC, SOC, Op_RegVMask, 4, p4->as_VMReg());\n+  reg_def P5 (SOC, SOC, Op_RegVMask, 5, p5->as_VMReg());\n+  reg_def P6 (SOC, SOC, Op_RegVMask, 6, p6->as_VMReg());\n+  reg_def P7 (SOC, SOC, Op_RegVMask, 7, p7->as_VMReg());\n+  reg_def P8 (SOC, SOC, Op_RegVMask, 8, p8->as_VMReg());\n+  reg_def P9 (SOC, SOC, Op_RegVMask, 9, p9->as_VMReg());\n+  reg_def P10 (SOC, SOC, Op_RegVMask, 10, p10->as_VMReg());\n+  reg_def P11 (SOC, SOC, Op_RegVMask, 11, p11->as_VMReg());\n+  reg_def P12 (SOC, SOC, Op_RegVMask, 12, p12->as_VMReg());\n+  reg_def P13 (SOC, SOC, Op_RegVMask, 13, p13->as_VMReg());\n+  reg_def P14 (SOC, SOC, Op_RegVMask, 14, p14->as_VMReg());\n+  reg_def P15 (SOC, SOC, Op_RegVMask, 15, p15->as_VMReg());\n@@ -336,1 +499,0 @@\n-\n@@ -384,0 +546,2 @@\n+    R8, R8_H,   \/\/ rscratch1\n+    R9, R9_H,   \/\/ rscratch2\n@@ -389,16 +553,16 @@\n-    V16, V16_H, V16_J, V16_K,\n-    V17, V17_H, V17_J, V17_K,\n-    V18, V18_H, V18_J, V18_K,\n-    V19, V19_H, V19_J, V19_K,\n-    V20, V20_H, V20_J, V20_K,\n-    V21, V21_H, V21_J, V21_K,\n-    V22, V22_H, V22_J, V22_K,\n-    V23, V23_H, V23_J, V23_K,\n-    V24, V24_H, V24_J, V24_K,\n-    V25, V25_H, V25_J, V25_K,\n-    V26, V26_H, V26_J, V26_K,\n-    V27, V27_H, V27_J, V27_K,\n-    V28, V28_H, V28_J, V28_K,\n-    V29, V29_H, V29_J, V29_K,\n-    V30, V30_H, V30_J, V30_K,\n-    V31, V31_H, V31_J, V31_K,\n+    V16, V16_H, V16_J, V16_K, V16_L, V16_M, V16_N, V16_O,\n+    V17, V17_H, V17_J, V17_K, V17_L, V17_M, V17_N, V17_O,\n+    V18, V18_H, V18_J, V18_K, V18_L, V18_M, V18_N, V18_O,\n+    V19, V19_H, V19_J, V19_K, V19_L, V19_M, V19_N, V19_O,\n+    V20, V20_H, V20_J, V20_K, V20_L, V20_M, V20_N, V20_O,\n+    V21, V21_H, V21_J, V21_K, V21_L, V21_M, V21_N, V21_O,\n+    V22, V22_H, V22_J, V22_K, V22_L, V22_M, V22_N, V22_O,\n+    V23, V23_H, V23_J, V23_K, V23_L, V23_M, V23_N, V23_O,\n+    V24, V24_H, V24_J, V24_K, V24_L, V24_M, V24_N, V24_O,\n+    V25, V25_H, V25_J, V25_K, V25_L, V25_M, V25_N, V25_O,\n+    V26, V26_H, V26_J, V26_K, V26_L, V26_M, V26_N, V26_O,\n+    V27, V27_H, V27_J, V27_K, V27_L, V27_M, V27_N, V27_O,\n+    V28, V28_H, V28_J, V28_K, V28_L, V28_M, V28_N, V28_O,\n+    V29, V29_H, V29_J, V29_K, V29_L, V29_M, V29_N, V29_O,\n+    V30, V30_H, V30_J, V30_K, V30_L, V30_M, V30_N, V30_O,\n+    V31, V31_H, V31_J, V31_K, V31_L, V31_M, V31_N, V31_O,\n@@ -407,8 +571,8 @@\n-    V0, V0_H, V0_J, V0_K,\n-    V1, V1_H, V1_J, V1_K,\n-    V2, V2_H, V2_J, V2_K,\n-    V3, V3_H, V3_J, V3_K,\n-    V4, V4_H, V4_J, V4_K,\n-    V5, V5_H, V5_J, V5_K,\n-    V6, V6_H, V6_J, V6_K,\n-    V7, V7_H, V7_J, V7_K,\n+    V0, V0_H, V0_J, V0_K, V0_L, V0_M, V0_N, V0_O,\n+    V1, V1_H, V1_J, V1_K, V1_L, V1_M, V1_N, V1_O,\n+    V2, V2_H, V2_J, V2_K, V2_L, V2_M, V2_N, V2_O,\n+    V3, V3_H, V3_J, V3_K, V3_L, V3_M, V3_N, V3_O,\n+    V4, V4_H, V4_J, V4_K, V4_L, V4_M, V4_N, V4_O,\n+    V5, V5_H, V5_J, V5_K, V5_L, V5_M, V5_N, V5_O,\n+    V6, V6_H, V6_J, V6_K, V6_L, V6_M, V6_N, V6_O,\n+    V7, V7_H, V7_J, V7_K, V7_L, V7_M, V7_N, V7_O,\n@@ -417,8 +581,8 @@\n-    V8, V8_H, V8_J, V8_K,\n-    V9, V9_H, V9_J, V9_K,\n-    V10, V10_H, V10_J, V10_K,\n-    V11, V11_H, V11_J, V11_K,\n-    V12, V12_H, V12_J, V12_K,\n-    V13, V13_H, V13_J, V13_K,\n-    V14, V14_H, V14_J, V14_K,\n-    V15, V15_H, V15_J, V15_K,\n+    V8, V8_H, V8_J, V8_K, V8_L, V8_M, V8_N, V8_O,\n+    V9, V9_H, V9_J, V9_K, V9_L, V9_M, V9_N, V9_O,\n+    V10, V10_H, V10_J, V10_K, V10_L, V10_M, V10_N, V10_O,\n+    V11, V11_H, V11_J, V11_K, V11_L, V11_M, V11_N, V11_O,\n+    V12, V12_H, V12_J, V12_K, V12_L, V12_M, V12_N, V12_O,\n+    V13, V13_H, V13_J, V13_K, V13_L, V13_M, V13_N, V13_O,\n+    V14, V14_H, V14_J, V14_K, V14_L, V14_M, V14_N, V14_O,\n+    V15, V15_H, V15_J, V15_K, V15_L, V15_M, V15_N, V15_O,\n@@ -427,1 +591,21 @@\n-alloc_class chunk2(RFLAGS);\n+alloc_class chunk2 (\n+    P0,\n+    P1,\n+    P2,\n+    P3,\n+    P4,\n+    P5,\n+    P6,\n+    P7,\n+\n+    P8,\n+    P9,\n+    P10,\n+    P11,\n+    P12,\n+    P13,\n+    P14,\n+    P15,\n+);\n+\n+alloc_class chunk3(RFLAGS);\n@@ -711,0 +895,36 @@\n+\/\/ Class for all SVE vector registers.\n+reg_class vectora_reg (\n+    V0, V0_H, V0_J, V0_K, V0_L, V0_M, V0_N, V0_O,\n+    V1, V1_H, V1_J, V1_K, V1_L, V1_M, V1_N, V1_O,\n+    V2, V2_H, V2_J, V2_K, V2_L, V2_M, V2_N, V2_O,\n+    V3, V3_H, V3_J, V3_K, V3_L, V3_M, V3_N, V3_O,\n+    V4, V4_H, V4_J, V4_K, V4_L, V4_M, V4_N, V4_O,\n+    V5, V5_H, V5_J, V5_K, V5_L, V5_M, V5_N, V5_O,\n+    V6, V6_H, V6_J, V6_K, V6_L, V6_M, V6_N, V6_O,\n+    V7, V7_H, V7_J, V7_K, V7_L, V7_M, V7_N, V7_O,\n+    V8, V8_H, V8_J, V8_K, V8_L, V8_M, V8_N, V8_O,\n+    V9, V9_H, V9_J, V9_K, V9_L, V9_M, V9_N, V9_O,\n+    V10, V10_H, V10_J, V10_K, V10_L, V10_M, V10_N, V10_O,\n+    V11, V11_H, V11_J, V11_K, V11_L, V11_M, V11_N, V11_O,\n+    V12, V12_H, V12_J, V12_K, V12_L, V12_M, V12_N, V12_O,\n+    V13, V13_H, V13_J, V13_K, V13_L, V13_M, V13_N, V13_O,\n+    V14, V14_H, V14_J, V14_K, V14_L, V14_M, V14_N, V14_O,\n+    V15, V15_H, V15_J, V15_K, V15_L, V15_M, V15_N, V15_O,\n+    V16, V16_H, V16_J, V16_K, V16_L, V16_M, V16_N, V16_O,\n+    V17, V17_H, V17_J, V17_K, V17_L, V17_M, V17_N, V17_O,\n+    V18, V18_H, V18_J, V18_K, V18_L, V18_M, V18_N, V18_O,\n+    V19, V19_H, V19_J, V19_K, V19_L, V19_M, V19_N, V19_O,\n+    V20, V20_H, V20_J, V20_K, V20_L, V20_M, V20_N, V20_O,\n+    V21, V21_H, V21_J, V21_K, V21_L, V21_M, V21_N, V21_O,\n+    V22, V22_H, V22_J, V22_K, V22_L, V22_M, V22_N, V22_O,\n+    V23, V23_H, V23_J, V23_K, V23_L, V23_M, V23_N, V23_O,\n+    V24, V24_H, V24_J, V24_K, V24_L, V24_M, V24_N, V24_O,\n+    V25, V25_H, V25_J, V25_K, V25_L, V25_M, V25_N, V25_O,\n+    V26, V26_H, V26_J, V26_K, V26_L, V26_M, V26_N, V26_O,\n+    V27, V27_H, V27_J, V27_K, V27_L, V27_M, V27_N, V27_O,\n+    V28, V28_H, V28_J, V28_K, V28_L, V28_M, V28_N, V28_O,\n+    V29, V29_H, V29_J, V29_K, V29_L, V29_M, V29_N, V29_O,\n+    V30, V30_H, V30_J, V30_K, V30_L, V30_M, V30_N, V30_O,\n+    V31, V31_H, V31_J, V31_K, V31_L, V31_M, V31_N, V31_O,\n+);\n+\n@@ -943,0 +1163,33 @@\n+\/\/ Class for all SVE predicate registers.\n+reg_class pr_reg (\n+    P0,\n+    P1,\n+    P2,\n+    P3,\n+    P4,\n+    P5,\n+    P6,\n+    \/\/ P7, non-allocatable, preserved with all elements preset to TRUE.\n+    P8,\n+    P9,\n+    P10,\n+    P11,\n+    P12,\n+    P13,\n+    P14,\n+    P15\n+);\n+\n+\/\/ Class for SVE governing predicate registers, which are used\n+\/\/ to determine the active elements of a predicated instruction.\n+reg_class gov_pr (\n+    P0,\n+    P1,\n+    P2,\n+    P3,\n+    P4,\n+    P5,\n+    P6,\n+    \/\/ P7, non-allocatable, preserved with all elements preset to TRUE.\n+);\n+\n@@ -1647,0 +1900,4 @@\n+  if (UseSVE > 0 && C->max_vector_size() >= 16) {\n+    __ reinitialize_ptrue();\n+  }\n+\n@@ -1745,1 +2002,1 @@\n-enum RC { rc_bad, rc_int, rc_float, rc_stack };\n+enum RC { rc_bad, rc_int, rc_float, rc_predicate, rc_stack };\n@@ -1753,3 +2010,2 @@\n-  \/\/ we have 30 int registers * 2 halves\n-  \/\/ (rscratch1 and rscratch2 are omitted)\n-  int slots_of_int_registers = RegisterImpl::max_slots_per_register * (RegisterImpl::number_of_registers - 2);\n+  \/\/ we have 32 int registers * 2 halves\n+  int slots_of_int_registers = RegisterImpl::max_slots_per_register * RegisterImpl::number_of_registers;\n@@ -1761,2 +2017,3 @@\n-  \/\/ we have 32 float register * 4 halves\n-  if (reg < slots_of_int_registers + FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers) {\n+  \/\/ we have 32 float register * 8 halves\n+  int slots_of_float_registers = FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers;\n+  if (reg < slots_of_int_registers + slots_of_float_registers) {\n@@ -1766,1 +2023,6 @@\n-  \/\/ Between float regs & stack is the flags regs.\n+  int slots_of_predicate_registers = PRegisterImpl::max_slots_per_register * PRegisterImpl::number_of_registers;\n+  if (reg < slots_of_int_registers + slots_of_float_registers + slots_of_predicate_registers) {\n+    return rc_predicate;\n+  }\n+\n+  \/\/ Between predicate regs & stack is the flags.\n@@ -1805,2 +2067,22 @@\n-    assert(ireg == Op_VecD || ireg == Op_VecX, \"must be 64 bit or 128 bit vector\");\n-    if (cbuf) {\n+    if (ireg == Op_VecA && cbuf) {\n+      C2_MacroAssembler _masm(cbuf);\n+      int sve_vector_reg_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);\n+      if (src_lo_rc == rc_stack && dst_lo_rc == rc_stack) {\n+        \/\/ stack->stack\n+        __ spill_copy_sve_vector_stack_to_stack(src_offset, dst_offset,\n+                                                sve_vector_reg_size_in_bytes);\n+      } else if (src_lo_rc == rc_float && dst_lo_rc == rc_stack) {\n+        __ spill_sve_vector(as_FloatRegister(Matcher::_regEncode[src_lo]), ra_->reg2offset(dst_lo),\n+                            sve_vector_reg_size_in_bytes);\n+      } else if (src_lo_rc == rc_stack && dst_lo_rc == rc_float) {\n+        __ unspill_sve_vector(as_FloatRegister(Matcher::_regEncode[dst_lo]), ra_->reg2offset(src_lo),\n+                              sve_vector_reg_size_in_bytes);\n+      } else if (src_lo_rc == rc_float && dst_lo_rc == rc_float) {\n+        __ sve_orr(as_FloatRegister(Matcher::_regEncode[dst_lo]),\n+                   as_FloatRegister(Matcher::_regEncode[src_lo]),\n+                   as_FloatRegister(Matcher::_regEncode[src_lo]));\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    } else if (cbuf) {\n+      assert(ireg == Op_VecD || ireg == Op_VecX, \"must be 64 bit or 128 bit vector\");\n@@ -1824,2 +2106,2 @@\n-                       ireg == Op_VecD ? __ D : __ Q,\n-                       ra_->reg2offset(dst_lo));\n+                 ireg == Op_VecD ? __ D : __ Q,\n+                 ra_->reg2offset(dst_lo));\n@@ -1828,2 +2110,2 @@\n-                       ireg == Op_VecD ? __ D : __ Q,\n-                       ra_->reg2offset(src_lo));\n+                   ireg == Op_VecD ? __ D : __ Q,\n+                   ra_->reg2offset(src_lo));\n@@ -1914,1 +2196,16 @@\n-      st->print(\"\\t# vector spill size = %d\", ideal_reg()==Op_VecD ? 64:128);\n+      int vsize = 0;\n+      switch (ideal_reg()) {\n+      case Op_VecD:\n+        vsize = 64;\n+        break;\n+      case Op_VecX:\n+        vsize = 128;\n+        break;\n+      case Op_VecA:\n+        vsize = Matcher::scalable_vector_reg_size(T_BYTE) * 8;\n+        break;\n+      default:\n+        assert(false, \"bad register type for spill\");\n+        ShouldNotReachHere();\n+      }\n+      st->print(\"\\t# vector spill size = %d\", vsize);\n@@ -1916,1 +2213,1 @@\n-      st->print(\"\\t# spill size = %d\", is64 ? 64:32);\n+      st->print(\"\\t# spill size = %d\", is64 ? 64 : 32);\n@@ -2085,5 +2382,11 @@\n-\n-  \/\/ Special cases which require vector length\n-  switch (opcode) {\n-    case Op_MulAddVS2VI: {\n-      if (vlen != 4) {\n+  int bit_size = vlen * type2aelembytes(bt) * 8;\n+  if (UseSVE == 0 && bit_size > 128) {\n+    return false;\n+  }\n+  if (UseSVE > 0) {\n+    return op_sve_supported(opcode);\n+  } else { \/\/ NEON\n+    \/\/ Special cases\n+    switch (opcode) {\n+    case Op_MulAddVS2VI:\n+      if (bit_size < 128) {\n@@ -2093,1 +2396,2 @@\n-    }\n+    case Op_MulVL:\n+      return false;\n@@ -2100,0 +2404,3 @@\n+    default:\n+      break;\n+    }\n@@ -2101,1 +2408,0 @@\n-\n@@ -2106,1 +2412,1 @@\n-  return false;\n+  return UseSVE > 0;\n@@ -2160,1 +2466,2 @@\n-  int size = MIN2(16,(int)MaxVectorSize);\n+  \/\/ The MaxVectorSize should have been set by detecting SVE max vector register size.\n+  int size = MIN2((UseSVE > 0) ? 256 : 16, (int)MaxVectorSize);\n@@ -2174,8 +2481,15 @@\n-  \/\/ Limit the vector size to 8 bytes\n-  int size = 8 \/ type2aelembytes(bt);\n-  if (bt == T_BYTE) {\n-    \/\/ To support vector api shuffle\/rearrange.\n-    size = 4;\n-  } else if (bt == T_BOOLEAN) {\n-    \/\/ To support vector api load\/store mask.\n-    size = 2;\n+  if ((UseSVE > 0) && (MaxVectorSize >= 16)) {\n+    \/\/ Currently vector length less than SVE vector register size is not supported.\n+    return max_size;\n+  } else { \/\/ NEON\n+    \/\/ Limit the vector size to 8 bytes\n+    int size = 8 \/ type2aelembytes(bt);\n+    if (bt == T_BYTE) {\n+      \/\/ To support vector api shuffle\/rearrange.\n+      size = 4;\n+    } else if (bt == T_BOOLEAN) {\n+      \/\/ To support vector api load\/store mask.\n+      size = 2;\n+    }\n+    if (size < 2) size = 2;\n+    return MIN2(size,max_size);\n@@ -2183,2 +2497,9 @@\n-  if (size < 2) size = 2;\n-  return MIN2(size,max_size);\n+}\n+\n+const bool Matcher::supports_scalable_vector() {\n+  return UseSVE > 0;\n+}\n+\n+\/\/ Actual max scalable vector register length.\n+const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+  return Matcher::max_vector_size(bt);\n@@ -2189,0 +2510,3 @@\n+  if (UseSVE > 0 && 16 <= len && len <= 256) {\n+    return Op_VecA;\n+  }\n@@ -3472,0 +3796,5 @@\n+    } else if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+      \/\/ Only non uncommon_trap calls need to reinitialize ptrue.\n+      if (uncommon_trap_request() == 0) {\n+        __ reinitialize_ptrue();\n+      }\n@@ -3482,0 +3811,2 @@\n+    } else if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+      __ reinitialize_ptrue();\n@@ -3518,0 +3849,3 @@\n+    if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+      __ reinitialize_ptrue();\n+    }\n@@ -3527,0 +3861,5 @@\n+#ifdef ASSERT\n+    if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+      __ verify_ptrue();\n+    }\n+#endif\n@@ -4317,0 +4656,35 @@\n+\/\/ 8 bit signed value.\n+operand immI8()\n+%{\n+  predicate(n->get_int() <= 127 && n->get_int() >= -128);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ 8 bit signed value (simm8), or #simm8 LSL 8.\n+operand immI8_shift8()\n+%{\n+  predicate((n->get_int() <= 127 && n->get_int() >= -128) ||\n+            (n->get_int() <= 32512 && n->get_int() >= -32768 && (n->get_int() & 0xff) == 0));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ 8 bit signed value (simm8), or #simm8 LSL 8.\n+operand immL8_shift8()\n+%{\n+  predicate((n->get_long() <= 127 && n->get_long() >= -128) ||\n+            (n->get_long() <= 32512 && n->get_long() >= -32768 && (n->get_long() & 0xff) == 0));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4935,0 +5309,12 @@\n+\/\/ Generic vector class. This will be used for\n+\/\/ all vector operands, including NEON and SVE,\n+\/\/ but currently only used for SVE VecA.\n+operand vReg()\n+%{\n+  constraint(ALLOC_IN_RC(vectora_reg));\n+  match(VecA);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -5243,0 +5629,9 @@\n+operand pRegGov()\n+%{\n+  constraint(ALLOC_IN_RC(gov_pr));\n+  match(RegVMask);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -13656,0 +14051,71 @@\n+instruct copySignD_reg(vRegD dst, vRegD src1, vRegD src2, vRegD zero) %{\n+  match(Set dst (CopySignD src1 (Binary src2 zero)));\n+  effect(TEMP_DEF dst, USE src1, USE src2, USE zero);\n+  format %{ \"CopySignD  $dst $src1 $src2\" %}\n+  ins_encode %{\n+    FloatRegister dst = as_FloatRegister($dst$$reg),\n+                  src1 = as_FloatRegister($src1$$reg),\n+                  src2 = as_FloatRegister($src2$$reg),\n+                  zero = as_FloatRegister($zero$$reg);\n+    __ fnegd(dst, zero);\n+    __ bsl(dst, __ T8B, src2, src1);\n+  %}\n+  ins_pipe(fp_uop_d);\n+%}\n+\n+instruct copySignF_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (CopySignF src1 src2));\n+  effect(TEMP_DEF dst, USE src1, USE src2);\n+  format %{ \"CopySignF  $dst $src1 $src2\" %}\n+  ins_encode %{\n+    FloatRegister dst = as_FloatRegister($dst$$reg),\n+                  src1 = as_FloatRegister($src1$$reg),\n+                  src2 = as_FloatRegister($src2$$reg);\n+    __ movi(dst, __ T2S, 0x80, 24);\n+    __ bsl(dst, __ T8B, src2, src1);\n+  %}\n+  ins_pipe(fp_uop_d);\n+%}\n+\n+instruct signumD_reg(vRegD dst, vRegD src, vRegD zero, vRegD one) %{\n+  match(Set dst (SignumD src (Binary zero one)));\n+  effect(TEMP_DEF dst, USE src, USE zero, USE one);\n+  format %{ \"signumD  $dst, $src\" %}\n+  ins_encode %{\n+    FloatRegister src = as_FloatRegister($src$$reg),\n+                  dst = as_FloatRegister($dst$$reg),\n+                  zero = as_FloatRegister($zero$$reg),\n+                  one = as_FloatRegister($one$$reg);\n+    __ facgtd(dst, src, zero); \/\/ dst=0 for +-0.0 and NaN. 0xFFF..F otherwise\n+    __ ushrd(dst, dst, 1);     \/\/ dst=0 for +-0.0 and NaN. 0x7FF..F otherwise\n+    \/\/ Bit selection instruction gets bit from \"one\" for each enabled bit in\n+    \/\/ \"dst\", otherwise gets a bit from \"src\". For \"src\" that contains +-0.0 or\n+    \/\/ NaN the whole \"src\" will be copied because \"dst\" is zero. For all other\n+    \/\/ \"src\" values dst is 0x7FF..F, which means only the sign bit is copied\n+    \/\/ from \"src\", and all other bits are copied from 1.0.\n+    __ bsl(dst, __ T8B, one, src);\n+  %}\n+  ins_pipe(fp_uop_d);\n+%}\n+\n+instruct signumF_reg(vRegF dst, vRegF src, vRegF zero, vRegF one) %{\n+  match(Set dst (SignumF src (Binary zero one)));\n+  effect(TEMP_DEF dst, USE src, USE zero, USE one);\n+  format %{ \"signumF  $dst, $src\" %}\n+  ins_encode %{\n+    FloatRegister src = as_FloatRegister($src$$reg),\n+                  dst = as_FloatRegister($dst$$reg),\n+                  zero = as_FloatRegister($zero$$reg),\n+                  one = as_FloatRegister($one$$reg);\n+    __ facgts(dst, src, zero);    \/\/ dst=0 for +-0.0 and NaN. 0xFFF..F otherwise\n+    __ ushr(dst, __ T2S, dst, 1); \/\/ dst=0 for +-0.0 and NaN. 0x7FF..F otherwise\n+    \/\/ Bit selection instruction gets bit from \"one\" for each enabled bit in\n+    \/\/ \"dst\", otherwise gets a bit from \"src\". For \"src\" that contains +-0.0 or\n+    \/\/ NaN the whole \"src\" will be copied because \"dst\" is zero. For all other\n+    \/\/ \"src\" values dst is 0x7FF..F, which means only the sign bit is copied\n+    \/\/ from \"src\", and all other bits are copied from 1.0.\n+    __ bsl(dst, __ T8B, one, src);\n+  %}\n+  ins_pipe(fp_uop_d);\n+%}\n+\n@@ -16168,1 +16634,1 @@\n-  predicate(n->as_LoadVector()->memory_size() == 16);\n+  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 16);\n@@ -16224,1 +16690,1 @@\n-  predicate(n->as_Vector()->length() == 16);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 16);\n@@ -16249,1 +16715,1 @@\n-  predicate(n->as_Vector()->length() == 16);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 16);\n@@ -16274,1 +16740,1 @@\n-  predicate(n->as_Vector()->length() == 8);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 8);\n@@ -16299,1 +16765,1 @@\n-  predicate(n->as_Vector()->length() == 8);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 8);\n@@ -16323,1 +16789,1 @@\n-  predicate(n->as_Vector()->length() == 4);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n@@ -16347,1 +16813,1 @@\n-  predicate(n->as_Vector()->length() == 4);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n@@ -16359,1 +16825,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n@@ -16371,1 +16837,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n@@ -16398,1 +16864,1 @@\n-  predicate(n->as_Vector()->length() == 4);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n@@ -16411,1 +16877,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":706,"deletions":240,"binary":false,"changes":946,"status":"modified"},{"patch":"@@ -0,0 +1,1637 @@\n+\/\/\n+\/\/ Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+\n+\/\/ This file is automatically generated by running \"m4 aarch64_sve_ad.m4\". Do not edit ----\n+\n+\/\/ AArch64 SVE Architecture Description File\n+\n+\n+\/\/ 4 bit signed offset -- for predicated load\/store\n+\n+operand vmemA_immIOffset4()\n+%{\n+  predicate(Address::offset_ok_for_sve_immed(n->get_int(), 4,\n+            Matcher::scalable_vector_reg_size(T_BYTE)));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand vmemA_immLOffset4()\n+%{\n+  predicate(Address::offset_ok_for_sve_immed(n->get_long(), 4,\n+            Matcher::scalable_vector_reg_size(T_BYTE)));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\n+operand vmemA_indOffI4(iRegP reg, vmemA_immIOffset4 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off, MUL VL]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand vmemA_indOffL4(iRegP reg, vmemA_immLOffset4 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off, MUL VL]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);\n+\n+source_hpp %{\n+  bool op_sve_supported(int opcode);\n+%}\n+\n+source %{\n+\n+  static inline BasicType vector_element_basic_type(const MachNode* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n+    int def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,\n+                                                             PRegister Pg, const Address &adr);\n+\n+  \/\/ Predicated load\/store, with optional ptrue to all elements of given predicate register.\n+  static void loadStoreA_predicate(C2_MacroAssembler masm, bool is_store,\n+                                   FloatRegister reg, PRegister pg, BasicType bt,\n+                                   int opcode, Register base, int index, int size, int disp) {\n+    sve_mem_insn_predicate insn;\n+    Assembler::SIMD_RegVariant type;\n+    int esize = type2aelembytes(bt);\n+    if (index == -1) {\n+      assert(size == 0, \"unsupported address mode: scale size = %d\", size);\n+      switch(esize) {\n+      case 1:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;\n+        type = Assembler::B;\n+        break;\n+      case 2:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;\n+        type = Assembler::H;\n+        break;\n+      case 4:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;\n+        type = Assembler::S;\n+        break;\n+      case 8:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;\n+        type = Assembler::D;\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+      }\n+      (masm.*insn)(reg, type, pg, Address(base, disp \/ Matcher::scalable_vector_reg_size(T_BYTE)));\n+    } else {\n+      assert(false, \"unimplemented\");\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  bool op_sve_supported(int opcode) {\n+    switch (opcode) {\n+      case Op_MulAddVS2VI:\n+        \/\/ No multiply reduction instructions\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        \/\/ Others\n+      case Op_Extract:\n+      case Op_ExtractB:\n+      case Op_ExtractC:\n+      case Op_ExtractD:\n+      case Op_ExtractF:\n+      case Op_ExtractI:\n+      case Op_ExtractL:\n+      case Op_ExtractS:\n+      case Op_ExtractUB:\n+        return false;\n+      default:\n+        return true;\n+    }\n+  }\n+\n+%}\n+\n+definitions %{\n+  int_def SVE_COST             (200, 200);\n+%}\n+\n+\n+\n+\n+\/\/ All SVE instructions\n+\n+\/\/ vector load\/store\n+\n+\/\/ Use predicated vector load\/store\n+instruct loadV(vReg dst, vmemA mem) %{\n+  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() >= 16);\n+  match(Set dst (LoadVector mem));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_ldr $dst, $mem\\t # vector (sve)\" %}\n+  ins_encode %{\n+    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n+    loadStoreA_predicate(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n+                         vector_element_basic_type(this), $mem->opcode(),\n+                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct storeV(vReg src, vmemA mem) %{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() >= 16);\n+  match(Set mem (StoreVector mem src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_str $mem, $src\\t # vector (sve)\" %}\n+  ins_encode %{\n+    FloatRegister src_reg = as_FloatRegister($src$$reg);\n+    loadStoreA_predicate(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,\n+                         vector_element_basic_type(this, $src), $mem->opcode(),\n+                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+\/\/ vector abs\n+\n+instruct vabsB(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (AbsVB src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_abs $dst, $src\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_abs(as_FloatRegister($dst$$reg), __ B,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsS(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (AbsVS src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_abs $dst, $src\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_abs(as_FloatRegister($dst$$reg), __ H,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsI(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (AbsVI src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_abs $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_abs(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsL(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (AbsVL src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_abs $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_abs(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsF(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (AbsVF src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fabs $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fabs(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vabsD(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (AbsVD src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fabs $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fabs(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector add\n+\n+instruct vaddB(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (AddVB src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_add(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddS(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (AddVS src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_add(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddI(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (AddVI src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_add(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddL(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (AddVL src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_add(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddF(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (AddVF src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fadd $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fadd(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddD(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (AddVD src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fadd $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fadd(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector and\n+\n+instruct vand(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (AndV src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and  $dst, $src1, $src2\\t# vector (sve)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst$$reg),\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector or\n+\n+instruct vor(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (OrV src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr  $dst, $src1, $src2\\t# vector (sve)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst$$reg),\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector xor\n+\n+instruct vxor(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (XorV src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor  $dst, $src1, $src2\\t# vector (sve)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst$$reg),\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector float div\n+\n+instruct vdivF(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (DivVF dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fdiv  $dst_src1, $dst_src1, $src2\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vdivD(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (DivVD dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fdiv  $dst_src1, $dst_src1, $src2\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector max\n+\n+instruct vmaxF(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst_src1 (MaxV dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmax $dst_src1, $dst_src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fmax(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaxD(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst_src1 (MaxV dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmax $dst_src1, $dst_src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fmax(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vminF(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst_src1 (MinV dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmin $dst_src1, $dst_src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fmin(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vminD(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst_src1 (MinV dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmin $dst_src1, $dst_src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fmin(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmla\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vfmlaF(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmla $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vfmlaD(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmla $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fmls\n+\n+\/\/ dst_src1 = dst_src1 + -src2 * src3\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+instruct vfmlsF(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary (NegVF src2) src3)));\n+  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 (NegVF src3))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + -src2 * src3\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+instruct vfmlsD(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary (NegVD src2) src3)));\n+  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 (NegVD src3))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmla\n+\n+\/\/ dst_src1 = -dst_src1 + -src2 * src3\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+instruct vfnmlaF(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary (NegVF src2) src3)));\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 (NegVF src3))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = -dst_src1 + -src2 * src3\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+instruct vfnmlaD(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary (NegVD src2) src3)));\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 (NegVD src3))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fnmls\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * src3\n+instruct vfnmlsF(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmls $dst_src1, $src2, $src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = -dst_src1 + src2 * src3\n+instruct vfnmlsD(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmls $dst_src1, $src2, $src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mla\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmlaB(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst_src1 (AddVB dst_src1 (MulVB src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ B,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmlaS(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst_src1 (AddVS dst_src1 (MulVS src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ H,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmlaI(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (AddVI dst_src1 (MulVI src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ S,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmlaL(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ D,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector mls\n+\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmlsB(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst_src1 (SubVB dst_src1 (MulVB src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ B,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmlsS(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst_src1 (SubVS dst_src1 (MulVS src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ H,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmlsI(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (SubVI dst_src1 (MulVI src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ S,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmlsL(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ D,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+\/\/ vector mul\n+\n+instruct vmulB(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst_src1 (MulVB dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ B,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulS(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst_src1 (MulVS dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ H,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulI(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst_src1 (MulVI dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulL(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst_src1 (MulVL dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mul $dst_src1, $dst_src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulF(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (MulVF src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmul $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fmul(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmulD(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (MulVD src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmul $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fmul(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector fneg\n+\n+instruct vnegF(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (NegVF src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fneg $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fneg(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vnegD(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (NegVD src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fneg $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fneg(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ popcount vector\n+\n+instruct vpopcountI(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (PopCountVI src));\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\"  %}\n+  ins_encode %{\n+     __ sve_cnt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector add reduction\n+\n+instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) (S)\\n\\t\"\n+            \"umov  $dst, $tmp, S, 0\\n\\t\"\n+            \"addw  $dst, $dst, $src1\\t # add reduction S\" %}\n+  ins_encode %{\n+    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) (D)\\n\\t\"\n+            \"umov  $dst, $tmp, D, 0\\n\\t\"\n+            \"add  $dst, $dst, $src1\\t # add reduction D\" %}\n+  ins_encode %{\n+    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n+    __ add($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addF(vRegF src1_dst, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set src1_dst (AddReductionVF src1_dst src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_addD(vRegD src1_dst, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set src1_dst (AddReductionVD src1_dst src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector max reduction\n+\n+instruct reduce_maxF(vRegF dst, vRegF src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set dst (MaxReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fmaxv $dst, $src2 # vector (sve) (S)\\n\\t\"\n+            \"fmaxs $dst, $dst, $src1\\t # max reduction F\" %}\n+  ins_encode %{\n+    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_maxD(vRegD dst, vRegD src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set dst (MaxReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fmaxv $dst, $src2 # vector (sve) (S)\\n\\t\"\n+            \"fmaxs $dst, $dst, $src1\\t # max reduction D\" %}\n+  ins_encode %{\n+    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector min reduction\n+\n+instruct reduce_minF(vRegF dst, vRegF src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set dst (MinReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fminv $dst, $src2 # vector (sve) (S)\\n\\t\"\n+            \"fmins $dst, $dst, $src1\\t # min reduction F\" %}\n+  ins_encode %{\n+    __ sve_fminv(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reduce_minD(vRegD dst, vRegD src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set dst (MinReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fminv $dst, $src2 # vector (sve) (S)\\n\\t\"\n+            \"fmins $dst, $dst, $src1\\t # min reduction D\" %}\n+  ins_encode %{\n+    __ sve_fminv(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector Math.rint, floor, ceil\n+\n+instruct vroundD(vReg dst, vReg src, immI rmode) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  format %{ \"sve_frint $dst, $src, $rmode\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    switch ($rmode$$constant) {\n+      case RoundDoubleModeNode::rmode_rint:\n+        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+      case RoundDoubleModeNode::rmode_floor:\n+        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+      case RoundDoubleModeNode::rmode_ceil:\n+        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector replicate\n+\n+instruct replicateB(vReg dst, iRegIorL2I src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (ReplicateB src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateS(vReg dst, iRegIorL2I src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (ReplicateS src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateI(vReg dst, iRegIorL2I src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (ReplicateI src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateL(vReg dst, iRegL src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (ReplicateL src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct replicateB_imm8(vReg dst, immI8 con) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (ReplicateB con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ B, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateS_imm8(vReg dst, immI8_shift8 con) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (ReplicateS con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ H, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateI_imm8(vReg dst, immI8_shift8 con) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (ReplicateI con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ S, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateL_imm8(vReg dst, immL8_shift8 con) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (ReplicateL con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ D, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct replicateF(vReg dst, vRegF src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (ReplicateF src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct replicateD(vReg dst, vRegD src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (ReplicateD src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector shift\n+\n+instruct vasrB(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (RShiftVB dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ B,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrS(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (RShiftVS dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ H,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrI(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (RShiftVI dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrL(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (RShiftVL dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslB(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (LShiftVB dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslS(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (LShiftVS dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslI(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (LShiftVI dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslL(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (LShiftVL dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrB(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (URShiftVB dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrS(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (URShiftVS dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrI(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (URShiftVI dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrL(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (URShiftVL dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $dst, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrB_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (RShiftVB src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    if (con >= 8) con = 7;\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrS_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (RShiftVS src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    if (con >= 16) con = 15;\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrI_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (RShiftVI src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vasrL_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (RShiftVL src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_asr $dst, $src, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_asr(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrB_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (URShiftVB src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    if (con >= 8) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrS_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (URShiftVS src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    if (con >= 8) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrI_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (URShiftVI src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlsrL_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (URShiftVL src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsr $dst, $src, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslB_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (LShiftVB src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (B)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con >= 8) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslS_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (LShiftVS src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (H)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    if (con >= 8) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslI_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (LShiftVI src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vlslL_imm(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (LShiftVL src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_lsl $dst, $src, $shift\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;\n+    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntB(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntS(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_CHAR)));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntI(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vshiftcntL(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector sqrt\n+\n+instruct vsqrtF(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (SqrtVF src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fsqrt $dst, $src\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ S,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsqrtD(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  match(Set dst (SqrtVD src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fsqrt $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector sub\n+\n+instruct vsubB(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 16);\n+  match(Set dst (SubVB src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_sub(as_FloatRegister($dst$$reg), __ B,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubS(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 8);\n+  match(Set dst (SubVS src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_sub(as_FloatRegister($dst$$reg), __ H,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubI(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (SubVI src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_sub(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubL(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (SubVL src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sub $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_sub(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubF(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (SubVF src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fsub $dst, $src1, $src2\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_fsub(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vsubD(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2);\n+  match(Set dst (SubVD src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fsub $dst, $src1, $src2\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_fsub(as_FloatRegister($dst$$reg), __ D,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":1637,"deletions":0,"binary":false,"changes":1637,"status":"added"},{"patch":"@@ -0,0 +1,767 @@\n+\/\/\n+\/\/ Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+\n+dnl Generate the warning\n+\/\/ This file is automatically generated by running \"m4 aarch64_sve_ad.m4\". Do not edit ----\n+dnl\n+\n+\/\/ AArch64 SVE Architecture Description File\n+\n+dnl\n+dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET($1,            $2,       $3     )\n+dnl OPERAND_VMEMORYA_IMMEDIATE_OFFSET(imm_type_abbr, imm_type, imm_len)\n+define(`OPERAND_VMEMORYA_IMMEDIATE_OFFSET', `\n+operand vmemA_imm$1Offset$3()\n+%{\n+  predicate(Address::offset_ok_for_sve_immed(n->get_$2(), $3,\n+            Matcher::scalable_vector_reg_size(T_BYTE)));\n+  match(Con$1);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}')\n+dnl\n+\/\/ 4 bit signed offset -- for predicated load\/store\n+OPERAND_VMEMORYA_IMMEDIATE_OFFSET(I, int,  4)\n+OPERAND_VMEMORYA_IMMEDIATE_OFFSET(L, long, 4)\n+dnl\n+dnl OPERAND_VMEMORYA_INDIRECT_OFFSET($1,            $2     )\n+dnl OPERAND_VMEMORYA_INDIRECT_OFFSET(imm_type_abbr, imm_len)\n+define(`OPERAND_VMEMORYA_INDIRECT_OFFSET', `\n+operand vmemA_indOff$1$2(iRegP reg, vmemA_imm$1Offset$2 off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP reg off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off, MUL VL]\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    `index'(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}')\n+dnl\n+OPERAND_VMEMORYA_INDIRECT_OFFSET(I, 4)\n+OPERAND_VMEMORYA_INDIRECT_OFFSET(L, 4)\n+\n+opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);\n+\n+source_hpp %{\n+  bool op_sve_supported(int opcode);\n+%}\n+\n+source %{\n+\n+  static inline BasicType vector_element_basic_type(const MachNode* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n+    int def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,\n+                                                             PRegister Pg, const Address &adr);\n+\n+  \/\/ Predicated load\/store, with optional ptrue to all elements of given predicate register.\n+  static void loadStoreA_predicate(C2_MacroAssembler masm, bool is_store,\n+                                   FloatRegister reg, PRegister pg, BasicType bt,\n+                                   int opcode, Register base, int index, int size, int disp) {\n+    sve_mem_insn_predicate insn;\n+    Assembler::SIMD_RegVariant type;\n+    int esize = type2aelembytes(bt);\n+    if (index == -1) {\n+      assert(size == 0, \"unsupported address mode: scale size = %d\", size);\n+      switch(esize) {\n+      case 1:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;\n+        type = Assembler::B;\n+        break;\n+      case 2:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;\n+        type = Assembler::H;\n+        break;\n+      case 4:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;\n+        type = Assembler::S;\n+        break;\n+      case 8:\n+        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;\n+        type = Assembler::D;\n+        break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+      }\n+      (masm.*insn)(reg, type, pg, Address(base, disp \/ Matcher::scalable_vector_reg_size(T_BYTE)));\n+    } else {\n+      assert(false, \"unimplemented\");\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  bool op_sve_supported(int opcode) {\n+    switch (opcode) {\n+      case Op_MulAddVS2VI:\n+        \/\/ No multiply reduction instructions\n+      case Op_MulReductionVD:\n+      case Op_MulReductionVF:\n+      case Op_MulReductionVI:\n+      case Op_MulReductionVL:\n+        \/\/ Others\n+      case Op_Extract:\n+      case Op_ExtractB:\n+      case Op_ExtractC:\n+      case Op_ExtractD:\n+      case Op_ExtractF:\n+      case Op_ExtractI:\n+      case Op_ExtractL:\n+      case Op_ExtractS:\n+      case Op_ExtractUB:\n+        return false;\n+      default:\n+        return true;\n+    }\n+  }\n+\n+%}\n+\n+definitions %{\n+  int_def SVE_COST             (200, 200);\n+%}\n+\n+\n+dnl\n+dnl ELEMENT_SHORT_CHART($1, $2)\n+dnl ELEMENT_SHORT_CHART(etype, node)\n+define(`ELEMENT_SHORT_CHAR',`ifelse(`$1', `T_SHORT',\n+  `($2->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+            ($2->bottom_type()->is_vect()->element_basic_type() == T_CHAR))',\n+   `($2->bottom_type()->is_vect()->element_basic_type() == $1)')')\n+dnl\n+\n+\/\/ All SVE instructions\n+\n+\/\/ vector load\/store\n+\n+\/\/ Use predicated vector load\/store\n+instruct loadV(vReg dst, vmemA mem) %{\n+  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() >= 16);\n+  match(Set dst (LoadVector mem));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_ldr $dst, $mem\\t # vector (sve)\" %}\n+  ins_encode %{\n+    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n+    loadStoreA_predicate(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,\n+                         vector_element_basic_type(this), $mem->opcode(),\n+                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct storeV(vReg src, vmemA mem) %{\n+  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() >= 16);\n+  match(Set mem (StoreVector mem src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_str $mem, $src\\t # vector (sve)\" %}\n+  ins_encode %{\n+    FloatRegister src_reg = as_FloatRegister($src$$reg);\n+    loadStoreA_predicate(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,\n+                         vector_element_basic_type(this, $src), $mem->opcode(),\n+                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl UNARY_OP_TRUE_PREDICATE_ETYPE($1,        $2,      $3,           $4,   $5,          %6  )\n+dnl UNARY_OP_TRUE_PREDICATE_ETYPE(insn_name, op_name, element_type, size, min_vec_len, insn)\n+define(`UNARY_OP_TRUE_PREDICATE_ETYPE', `\n+instruct $1(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == $3);\n+  match(Set dst ($2 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"$6 $dst, $src\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ $6(as_FloatRegister($dst$$reg), __ $4,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector abs\n+UNARY_OP_TRUE_PREDICATE_ETYPE(vabsB, AbsVB, T_BYTE,   B, 16, sve_abs)\n+UNARY_OP_TRUE_PREDICATE_ETYPE(vabsS, AbsVS, T_SHORT,  H, 8,  sve_abs)\n+UNARY_OP_TRUE_PREDICATE_ETYPE(vabsI, AbsVI, T_INT,    S, 4,  sve_abs)\n+UNARY_OP_TRUE_PREDICATE_ETYPE(vabsL, AbsVL, T_LONG,   D, 2,  sve_abs)\n+UNARY_OP_TRUE_PREDICATE_ETYPE(vabsF, AbsVF, T_FLOAT,  S, 4,  sve_fabs)\n+UNARY_OP_TRUE_PREDICATE_ETYPE(vabsD, AbsVD, T_DOUBLE, D, 2,  sve_fabs)\n+dnl\n+dnl BINARY_OP_UNPREDICATED($1,        $2       $3,   $4           $5  )\n+dnl BINARY_OP_UNPREDICATED(insn_name, op_name, size, min_vec_len, insn)\n+define(`BINARY_OP_UNPREDICATED', `\n+instruct $1(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n+  match(Set dst ($2 src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst, $src1, $src2\\t # vector (sve) ($3)\" %}\n+  ins_encode %{\n+    __ $5(as_FloatRegister($dst$$reg), __ $3,\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector add\n+BINARY_OP_UNPREDICATED(vaddB, AddVB, B, 16, sve_add)\n+BINARY_OP_UNPREDICATED(vaddS, AddVS, H, 8,  sve_add)\n+BINARY_OP_UNPREDICATED(vaddI, AddVI, S, 4,  sve_add)\n+BINARY_OP_UNPREDICATED(vaddL, AddVL, D, 2,  sve_add)\n+BINARY_OP_UNPREDICATED(vaddF, AddVF, S, 4,  sve_fadd)\n+BINARY_OP_UNPREDICATED(vaddD, AddVD, D, 2,  sve_fadd)\n+dnl\n+dnl BINARY_OP_UNSIZED($1,        $2,      $3,          $4  )\n+dnl BINARY_OP_UNSIZED(insn_name, op_name, min_vec_len, insn)\n+define(`BINARY_OP_UNSIZED', `\n+instruct $1(vReg dst, vReg src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= $3);\n+  match(Set dst ($2 src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"$4  $dst, $src1, $src2\\t# vector (sve)\" %}\n+  ins_encode %{\n+    __ $4(as_FloatRegister($dst$$reg),\n+         as_FloatRegister($src1$$reg),\n+         as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector and\n+BINARY_OP_UNSIZED(vand, AndV, 16, sve_and)\n+\n+\/\/ vector or\n+BINARY_OP_UNSIZED(vor, OrV, 16, sve_orr)\n+\n+\/\/ vector xor\n+BINARY_OP_UNSIZED(vxor, XorV, 16, sve_eor)\n+dnl\n+dnl VDIVF($1,          $2  , $3         )\n+dnl VDIVF(name_suffix, size, min_vec_len)\n+define(`VDIVF', `\n+instruct vdiv$1(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (DivV$1 dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fdiv  $dst_src1, $dst_src1, $src2\\t# vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ $2,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector float div\n+VDIVF(F, S, 4)\n+VDIVF(D, D, 2)\n+\n+dnl\n+dnl BINARY_OP_TRUE_PREDICATE_ETYPE($1,        $2,      $3,           $4,   $5,          $6  )\n+dnl BINARY_OP_TRUE_PREDICATE_ETYPE(insn_name, op_name, element_type, size, min_vec_len, insn)\n+define(`BINARY_OP_TRUE_PREDICATE_ETYPE', `\n+instruct $1(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == $3);\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"$6 $dst_src1, $dst_src1, $src2\\t # vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ $6(as_FloatRegister($dst_src1$$reg), __ $4,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector max\n+BINARY_OP_TRUE_PREDICATE_ETYPE(vmaxF, MaxV, T_FLOAT,  S, 4,  sve_fmax)\n+BINARY_OP_TRUE_PREDICATE_ETYPE(vmaxD, MaxV, T_DOUBLE, D, 2,  sve_fmax)\n+BINARY_OP_TRUE_PREDICATE_ETYPE(vminF, MinV, T_FLOAT,  S, 4,  sve_fmin)\n+BINARY_OP_TRUE_PREDICATE_ETYPE(vminD, MinV, T_DOUBLE, D, 2,  sve_fmin)\n+\n+dnl\n+dnl VFMLA($1           $2    $3         )\n+dnl VFMLA(name_suffix, size, min_vec_len)\n+define(`VFMLA', `\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vfmla$1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (FmaV$1 dst_src1 (Binary src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmla $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ $2,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fmla\n+VFMLA(F, S, 4)\n+VFMLA(D, D, 2)\n+\n+dnl\n+dnl VFMLS($1           $2    $3         )\n+dnl VFMLS(name_suffix, size, min_vec_len)\n+define(`VFMLS', `\n+\/\/ dst_src1 = dst_src1 + -src2 * src3\n+\/\/ dst_src1 = dst_src1 + src2 * -src3\n+instruct vfmls$1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (FmaV$1 dst_src1 (Binary (NegV$1 src2) src3)));\n+  match(Set dst_src1 (FmaV$1 dst_src1 (Binary src2 (NegV$1 src3))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fmls $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ $2,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fmls\n+VFMLS(F, S, 4)\n+VFMLS(D, D, 2)\n+\n+dnl\n+dnl VFNMLA($1           $2    $3         )\n+dnl VFNMLA(name_suffix, size, min_vec_len)\n+define(`VFNMLA', `\n+\/\/ dst_src1 = -dst_src1 + -src2 * src3\n+\/\/ dst_src1 = -dst_src1 + src2 * -src3\n+instruct vfnmla$1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (FmaV$1 (NegV$1 dst_src1) (Binary (NegV$1 src2) src3)));\n+  match(Set dst_src1 (FmaV$1 (NegV$1 dst_src1) (Binary src2 (NegV$1 src3))));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmla $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ $2,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fnmla\n+VFNMLA(F, S, 4)\n+VFNMLA(D, D, 2)\n+\n+dnl\n+dnl VFNMLS($1           $2    $3         )\n+dnl VFNMLS(name_suffix, size, min_vec_len)\n+define(`VFNMLS', `\n+\/\/ dst_src1 = -dst_src1 + src2 * src3\n+instruct vfnmls$1(vReg dst_src1, vReg src2, vReg src3) %{\n+  predicate(UseFMA && UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (FmaV$1 (NegV$1 dst_src1) (Binary src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fnmls $dst_src1, $src2, $src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ $2,\n+         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fnmls\n+VFNMLS(F, S, 4)\n+VFNMLS(D, D, 2)\n+\n+dnl\n+dnl VMLA($1           $2    $3         )\n+dnl VMLA(name_suffix, size, min_vec_len)\n+define(`VMLA', `\n+\/\/ dst_src1 = dst_src1 + src2 * src3\n+instruct vmla$1(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (AddV$1 dst_src1 (MulV$1 src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mla $dst_src1, src2, src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ $2,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector mla\n+VMLA(B, B, 16)\n+VMLA(S, H, 8)\n+VMLA(I, S, 4)\n+VMLA(L, D, 2)\n+\n+dnl\n+dnl VMLS($1           $2    $3         )\n+dnl VMLS(name_suffix, size, min_vec_len)\n+define(`VMLS', `\n+\/\/ dst_src1 = dst_src1 - src2 * src3\n+instruct vmls$1(vReg dst_src1, vReg src2, vReg src3)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $3);\n+  match(Set dst_src1 (SubV$1 dst_src1 (MulV$1 src2 src3)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_mls $dst_src1, src2, src3\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ $2,\n+      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector mls\n+VMLS(B, B, 16)\n+VMLS(S, H, 8)\n+VMLS(I, S, 4)\n+VMLS(L, D, 2)\n+\n+dnl\n+dnl BINARY_OP_TRUE_PREDICATE($1,        $2,      $3,   $4,          $5  )\n+dnl BINARY_OP_TRUE_PREDICATE(insn_name, op_name, size, min_vec_len, insn)\n+define(`BINARY_OP_TRUE_PREDICATE', `\n+instruct $1(vReg dst_src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n+  match(Set dst_src1 ($2 dst_src1 src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst_src1, $dst_src1, $src2\\t # vector (sve) ($3)\" %}\n+  ins_encode %{\n+    __ $5(as_FloatRegister($dst_src1$$reg), __ $3,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector mul\n+BINARY_OP_TRUE_PREDICATE(vmulB, MulVB, B, 16, sve_mul)\n+BINARY_OP_TRUE_PREDICATE(vmulS, MulVS, H, 8,  sve_mul)\n+BINARY_OP_TRUE_PREDICATE(vmulI, MulVI, S, 4,  sve_mul)\n+BINARY_OP_TRUE_PREDICATE(vmulL, MulVL, D, 2,  sve_mul)\n+BINARY_OP_UNPREDICATED(vmulF, MulVF, S, 4, sve_fmul)\n+BINARY_OP_UNPREDICATED(vmulD, MulVD, D, 2, sve_fmul)\n+\n+dnl\n+dnl UNARY_OP_TRUE_PREDICATE($1,        $2,      $3,   $4,            $5  )\n+dnl UNARY_OP_TRUE_PREDICATE(insn_name, op_name, size, min_vec_bytes, insn)\n+define(`UNARY_OP_TRUE_PREDICATE', `\n+instruct $1(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= $4);\n+  match(Set dst ($2 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst, $src\\t# vector (sve) ($3)\" %}\n+  ins_encode %{\n+    __ $5(as_FloatRegister($dst$$reg), __ $3,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector fneg\n+UNARY_OP_TRUE_PREDICATE(vnegF, NegVF, S, 16, sve_fneg)\n+UNARY_OP_TRUE_PREDICATE(vnegD, NegVD, D, 16, sve_fneg)\n+\n+\/\/ popcount vector\n+\n+instruct vpopcountI(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 4);\n+  match(Set dst (PopCountVI src));\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\"  %}\n+  ins_encode %{\n+     __ sve_cnt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+dnl\n+dnl REDUCE_ADD($1,        $2,      $3,      $4,      $5,   $6,        $7   )\n+dnl REDUCE_ADD(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1)\n+define(`REDUCE_ADD', `\n+instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            ELEMENT_SHORT_CHAR($6, n->in(2)));\n+  match(Set dst ($2 src1 src2));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n+            \"umov  $dst, $tmp, $5, 0\\n\\t\"\n+            \"$7  $dst, $dst, $src1\\t # add reduction $5\" %}\n+  ins_encode %{\n+    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ $5,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n+    __ $7($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_ADDF($1,        $2,      $3,      $4  )\n+dnl REDUCE_ADDF(insn_name, op_name, reg_dst, size)\n+define(`REDUCE_ADDF', `\n+instruct $1($3 src1_dst, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set src1_dst ($2 src1_dst src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ $4,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector add reduction\n+REDUCE_ADD(reduce_addI, AddReductionVI, iRegINoSp, iRegIorL2I, S, T_INT, addw)\n+REDUCE_ADD(reduce_addL, AddReductionVL, iRegLNoSp, iRegL, D, T_LONG, add)\n+REDUCE_ADDF(reduce_addF, AddReductionVF, vRegF, S)\n+REDUCE_ADDF(reduce_addD, AddReductionVD, vRegD, D)\n+\n+dnl\n+dnl REDUCE_FMINMAX($1,      $2,          $3,           $4,   $5         )\n+dnl REDUCE_FMINMAX(min_max, name_suffix, element_type, size, reg_src_dst)\n+define(`REDUCE_FMINMAX', `\n+instruct reduce_$1$2($5 dst, $5 src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == $3 &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() >= 16);\n+  match(Set dst (translit($1, `m', `M')ReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_f$1v $dst, $src2 # vector (sve) (S)\\n\\t\"\n+            \"f$1s $dst, $dst, $src1\\t # $1 reduction $2\" %}\n+  ins_encode %{\n+    __ sve_f$1v(as_FloatRegister($dst$$reg), __ $4,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ f`$1'translit($4, `SD', `sd')(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\/\/ vector max reduction\n+REDUCE_FMINMAX(max, F, T_FLOAT,  S, vRegF)\n+REDUCE_FMINMAX(max, D, T_DOUBLE, D, vRegD)\n+\n+\/\/ vector min reduction\n+REDUCE_FMINMAX(min, F, T_FLOAT,  S, vRegF)\n+REDUCE_FMINMAX(min, D, T_DOUBLE, D, vRegD)\n+\n+\/\/ vector Math.rint, floor, ceil\n+\n+instruct vroundD(vReg dst, vReg src, immI rmode) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= 2 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (RoundDoubleModeV src rmode));\n+  format %{ \"sve_frint $dst, $src, $rmode\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    switch ($rmode$$constant) {\n+      case RoundDoubleModeNode::rmode_rint:\n+        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+      case RoundDoubleModeNode::rmode_floor:\n+        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+      case RoundDoubleModeNode::rmode_ceil:\n+        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,\n+             ptrue, as_FloatRegister($src$$reg));\n+        break;\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n+dnl REPLICATE($1,        $2,      $3,      $4,   $5         )\n+dnl REPLICATE(insn_name, op_name, reg_src, size, min_vec_len)\n+define(`REPLICATE', `\n+instruct $1(vReg dst, $3 src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5);\n+  match(Set dst ($2 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $src\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ $4, as_Register($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REPLICATE_IMM8($1,        $2,      $3,       $4,   $5         )\n+dnl REPLICATE_IMM8(insn_name, op_name, imm_type, size, min_vec_len)\n+define(`REPLICATE_IMM8', `\n+instruct $1(vReg dst, $3 con) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5);\n+  match(Set dst ($2 con));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_dup  $dst, $con\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ $4, $con$$constant);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl FREPLICATE($1,        $2,      $3,      $4,   $5         )\n+dnl FREPLICATE(insn_name, op_name, reg_src, size, min_vec_len)\n+define(`FREPLICATE', `\n+instruct $1(vReg dst, $3 src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5);\n+  match(Set dst ($2 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cpy  $dst, $src\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ $4,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector replicate\n+REPLICATE(replicateB, ReplicateB, iRegIorL2I, B, 16)\n+REPLICATE(replicateS, ReplicateS, iRegIorL2I, H, 8)\n+REPLICATE(replicateI, ReplicateI, iRegIorL2I, S, 4)\n+REPLICATE(replicateL, ReplicateL, iRegL,      D, 2)\n+\n+REPLICATE_IMM8(replicateB_imm8, ReplicateB, immI8,        B, 16)\n+REPLICATE_IMM8(replicateS_imm8, ReplicateS, immI8_shift8, H, 8)\n+REPLICATE_IMM8(replicateI_imm8, ReplicateI, immI8_shift8, S, 4)\n+REPLICATE_IMM8(replicateL_imm8, ReplicateL, immL8_shift8, D, 2)\n+\n+FREPLICATE(replicateF, ReplicateF, vRegF, S, 4)\n+FREPLICATE(replicateD, ReplicateD, vRegD, D, 2)\n+dnl\n+dnl VSHIFT_TRUE_PREDICATE($1,        $2,      $3,   $4,          $5  )\n+dnl VSHIFT_TRUE_PREDICATE(insn_name, op_name, size, min_vec_len, insn)\n+define(`VSHIFT_TRUE_PREDICATE', `\n+instruct $1(vReg dst, vReg shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n+  match(Set dst ($2 dst shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst, $dst, $shift\\t# vector (sve) ($3)\" %}\n+  ins_encode %{\n+    __ $5(as_FloatRegister($dst$$reg), __ $3,\n+         ptrue, as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VSHIFT_IMM_UNPREDICATE($1,        $2,      $3,   $4,          $5  )\n+dnl VSHIFT_IMM_UNPREDICATE(insn_name, op_name, size, min_vec_len, insn)\n+define(`VSHIFT_IMM_UNPREDICATE', `\n+instruct $1(vReg dst, vReg src, immI shift) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n+  match(Set dst ($2 src shift));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst, $src, $shift\\t# vector (sve) ($3)\" %}\n+  ins_encode %{\n+    int con = (int)$shift$$constant;dnl\n+ifelse(eval(index(`$1', `vasr') == 0 || index(`$1', `vlsr') == 0), 1, `\n+    if (con == 0) {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }')dnl\n+ifelse(eval(index(`$1', `vasr') == 0), 1, `ifelse(eval(index(`$3', `B') == 0), 1, `\n+    if (con >= 8) con = 7;')ifelse(eval(index(`$3', `H') == 0), 1, `\n+    if (con >= 16) con = 15;')')dnl\n+ifelse(eval((index(`$1', `vlsl') == 0 || index(`$1', `vlsr') == 0) && (index(`$3', `B') == 0 || index(`$3', `H') == 0)), 1, `\n+    if (con >= 8) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }')\n+    __ $5(as_FloatRegister($dst$$reg), __ $3,\n+         as_FloatRegister($src$$reg), con);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl VSHIFT_COUNT($1,        $2,   $3,          $4  )\n+dnl VSHIFT_COUNT(insn_name, size, min_vec_len, type)\n+define(`VSHIFT_COUNT', `\n+instruct $1(vReg dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $3 &&\n+            ELEMENT_SHORT_CHAR($4, n));\n+  match(Set dst (LShiftCntV cnt));\n+  match(Set dst (RShiftCntV cnt));\n+  format %{ \"sve_dup $dst, $cnt\\t# vector shift count (sve) ($2)\" %}\n+  ins_encode %{\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ $2, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector shift\n+VSHIFT_TRUE_PREDICATE(vasrB, RShiftVB,  B, 16, sve_asr)\n+VSHIFT_TRUE_PREDICATE(vasrS, RShiftVS,  H,  8, sve_asr)\n+VSHIFT_TRUE_PREDICATE(vasrI, RShiftVI,  S,  4, sve_asr)\n+VSHIFT_TRUE_PREDICATE(vasrL, RShiftVL,  D,  2, sve_asr)\n+VSHIFT_TRUE_PREDICATE(vlslB, LShiftVB,  B, 16, sve_lsl)\n+VSHIFT_TRUE_PREDICATE(vlslS, LShiftVS,  H,  8, sve_lsl)\n+VSHIFT_TRUE_PREDICATE(vlslI, LShiftVI,  S,  4, sve_lsl)\n+VSHIFT_TRUE_PREDICATE(vlslL, LShiftVL,  D,  2, sve_lsl)\n+VSHIFT_TRUE_PREDICATE(vlsrB, URShiftVB, B, 16, sve_lsr)\n+VSHIFT_TRUE_PREDICATE(vlsrS, URShiftVS, H,  8, sve_lsr)\n+VSHIFT_TRUE_PREDICATE(vlsrI, URShiftVI, S,  4, sve_lsr)\n+VSHIFT_TRUE_PREDICATE(vlsrL, URShiftVL, D,  2, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vasrB_imm, RShiftVB,  B, 16, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vasrS_imm, RShiftVS,  H,  8, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vasrI_imm, RShiftVI,  S,  4, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vasrL_imm, RShiftVL,  D,  2, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vlsrB_imm, URShiftVB, B, 16, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlsrS_imm, URShiftVS, H,  8, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlsrI_imm, URShiftVI, S,  4, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlsrL_imm, URShiftVL, D,  2, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlslB_imm, LShiftVB,  B, 16, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vlslS_imm, LShiftVS,  H,  8, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vlslI_imm, LShiftVI,  S,  4, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vlslL_imm, LShiftVL,  D,  2, sve_lsl)\n+VSHIFT_COUNT(vshiftcntB, B, 16, T_BYTE)\n+VSHIFT_COUNT(vshiftcntS, H,  8, T_SHORT)\n+VSHIFT_COUNT(vshiftcntI, S,  4, T_INT)\n+VSHIFT_COUNT(vshiftcntL, D,  2, T_LONG)\n+\n+\/\/ vector sqrt\n+UNARY_OP_TRUE_PREDICATE(vsqrtF, SqrtVF, S, 16, sve_fsqrt)\n+UNARY_OP_TRUE_PREDICATE(vsqrtD, SqrtVD, D, 16, sve_fsqrt)\n+\n+\/\/ vector sub\n+BINARY_OP_UNPREDICATED(vsubB, SubVB, B, 16, sve_sub)\n+BINARY_OP_UNPREDICATED(vsubS, SubVS, H, 8, sve_sub)\n+BINARY_OP_UNPREDICATED(vsubI, SubVI, S, 4, sve_sub)\n+BINARY_OP_UNPREDICATED(vsubL, SubVL, D, 2, sve_sub)\n+BINARY_OP_UNPREDICATED(vsubF, SubVF, S, 4, sve_fsub)\n+BINARY_OP_UNPREDICATED(vsubD, SubVD, D, 2, sve_fsub)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":767,"deletions":0,"binary":false,"changes":767,"status":"added"},{"patch":"@@ -759,1 +759,1 @@\n-    __ sha512h(v13, __ T2D, v4, v28);                  \/\/       sha512h                 q13, q4, v28.2D\n+    __ sha512h(v13, __ T2D, v4, v28);                  \/\/       sha512h         q13, q4, v28.2D\n@@ -780,0 +780,33 @@\n+    __ sve_cpy(z0, __ S, p0, v1);                      \/\/       mov     z0.s, p0\/m, s1\n+    __ sve_inc(r0, __ S);                              \/\/       incw    x0\n+    __ sve_dec(r1, __ H);                              \/\/       dech    x1\n+    __ sve_lsl(z0, __ B, z1, 7);                       \/\/       lsl     z0.b, z1.b, #7\n+    __ sve_lsl(z21, __ H, z1, 15);                     \/\/       lsl     z21.h, z1.h, #15\n+    __ sve_lsl(z0, __ S, z1, 31);                      \/\/       lsl     z0.s, z1.s, #31\n+    __ sve_lsl(z0, __ D, z1, 63);                      \/\/       lsl     z0.d, z1.d, #63\n+    __ sve_lsr(z0, __ B, z1, 7);                       \/\/       lsr     z0.b, z1.b, #7\n+    __ sve_asr(z0, __ H, z11, 15);                     \/\/       asr     z0.h, z11.h, #15\n+    __ sve_lsr(z30, __ S, z1, 31);                     \/\/       lsr     z30.s, z1.s, #31\n+    __ sve_asr(z0, __ D, z1, 63);                      \/\/       asr     z0.d, z1.d, #63\n+    __ sve_addvl(sp, r0, 31);                          \/\/       addvl   sp, x0, #31\n+    __ sve_addpl(r1, sp, -32);                         \/\/       addpl   x1, sp, -32\n+    __ sve_cntp(r8, __ B, p0, p1);                     \/\/       cntp    x8, p0, p1.b\n+    __ sve_dup(z0, __ B, 127);                         \/\/       dup     z0.b, 127\n+    __ sve_dup(z1, __ H, -128);                        \/\/       dup     z1.h, -128\n+    __ sve_dup(z2, __ S, 32512);                       \/\/       dup     z2.s, 32512\n+    __ sve_dup(z7, __ D, -32768);                      \/\/       dup     z7.d, -32768\n+    __ sve_ld1b(z0, __ B, p0, Address(sp));            \/\/       ld1b    {z0.b}, p0\/z, [sp]\n+    __ sve_ld1h(z10, __ H, p1, Address(sp, -8));       \/\/       ld1h    {z10.h}, p1\/z, [sp, #-8, MUL VL]\n+    __ sve_ld1w(z20, __ S, p2, Address(r0, 7));        \/\/       ld1w    {z20.s}, p2\/z, [x0, #7, MUL VL]\n+    __ sve_ld1b(z30, __ B, p3, Address(sp, r8));       \/\/       ld1b    {z30.b}, p3\/z, [sp, x8]\n+    __ sve_ld1w(z0, __ S, p4, Address(sp, r28));       \/\/       ld1w    {z0.s}, p4\/z, [sp, x28, LSL #2]\n+    __ sve_ld1d(z11, __ D, p5, Address(r0, r1));       \/\/       ld1d    {z11.d}, p5\/z, [x0, x1, LSL #3]\n+    __ sve_st1b(z22, __ B, p6, Address(sp));           \/\/       st1b    {z22.b}, p6, [sp]\n+    __ sve_st1b(z31, __ B, p7, Address(sp, -8));       \/\/       st1b    {z31.b}, p7, [sp, #-8, MUL VL]\n+    __ sve_st1w(z0, __ S, p1, Address(r0, 7));         \/\/       st1w    {z0.s}, p1, [x0, #7, MUL VL]\n+    __ sve_st1b(z0, __ B, p2, Address(sp, r1));        \/\/       st1b    {z0.b}, p2, [sp, x1]\n+    __ sve_st1h(z0, __ H, p3, Address(sp, r8));        \/\/       st1h    {z0.h}, p3, [sp, x8, LSL #1]\n+    __ sve_st1d(z0, __ D, p4, Address(r0, r18));       \/\/       st1d    {z0.d}, p4, [x0, x18, LSL #3]\n+    __ sve_ldr(z0, Address(sp));                       \/\/       ldr     z0, [sp]\n+    __ sve_ldr(z31, Address(sp, -256));                \/\/       ldr     z31, [sp, #-256, MUL VL]\n+    __ sve_str(z8, Address(r8, 255));                  \/\/       str     z8, [x8, #255, MUL VL]\n@@ -832,4 +865,4 @@\n-    __ ldsmina(Assembler::xword, r6, r30, r26);        \/\/       ldsmina         x6, x30, [x26]\n-    __ ldsmaxa(Assembler::xword, r18, r9, r8);         \/\/       ldsmaxa         x18, x9, [x8]\n-    __ ldumina(Assembler::xword, r12, r0, r20);        \/\/       ldumina         x12, x0, [x20]\n-    __ ldumaxa(Assembler::xword, r1, r24, r2);         \/\/       ldumaxa         x1, x24, [x2]\n+    __ ldsmina(Assembler::xword, r6, r30, r26);        \/\/       ldsmina x6, x30, [x26]\n+    __ ldsmaxa(Assembler::xword, r18, r9, r8);         \/\/       ldsmaxa x18, x9, [x8]\n+    __ ldumina(Assembler::xword, r12, r0, r20);        \/\/       ldumina x12, x0, [x20]\n+    __ ldumaxa(Assembler::xword, r1, r24, r2);         \/\/       ldumaxa x1, x24, [x2]\n@@ -839,4 +872,4 @@\n-    __ ldaddal(Assembler::xword, r26, r16, r30);       \/\/       ldaddal         x26, x16, [x30]\n-    __ ldbical(Assembler::xword, r3, r10, r23);        \/\/       ldclral         x3, x10, [x23]\n-    __ ldeoral(Assembler::xword, r10, r4, r18);        \/\/       ldeoral         x10, x4, [x18]\n-    __ ldorral(Assembler::xword, r2, r11, r8);         \/\/       ldsetal         x2, x11, [x8]\n+    __ ldaddal(Assembler::xword, r26, r16, r30);       \/\/       ldaddal x26, x16, [x30]\n+    __ ldbical(Assembler::xword, r3, r10, r23);        \/\/       ldclral x3, x10, [x23]\n+    __ ldeoral(Assembler::xword, r10, r4, r18);        \/\/       ldeoral x10, x4, [x18]\n+    __ ldorral(Assembler::xword, r2, r11, r8);         \/\/       ldsetal x2, x11, [x8]\n@@ -854,4 +887,4 @@\n-    __ ldsminl(Assembler::xword, r23, r28, r14);       \/\/       ldsminl         x23, x28, [x14]\n-    __ ldsmaxl(Assembler::xword, r11, r24, r1);        \/\/       ldsmaxl         x11, x24, [x1]\n-    __ lduminl(Assembler::xword, r12, zr, r10);        \/\/       lduminl         x12, xzr, [x10]\n-    __ ldumaxl(Assembler::xword, r16, r7, r2);         \/\/       ldumaxl         x16, x7, [x2]\n+    __ ldsminl(Assembler::xword, r23, r28, r14);       \/\/       ldsminl x23, x28, [x14]\n+    __ ldsmaxl(Assembler::xword, r11, r24, r1);        \/\/       ldsmaxl x11, x24, [x1]\n+    __ lduminl(Assembler::xword, r12, zr, r10);        \/\/       lduminl x12, xzr, [x10]\n+    __ ldumaxl(Assembler::xword, r16, r7, r2);         \/\/       ldumaxl x16, x7, [x2]\n@@ -876,4 +909,4 @@\n-    __ ldsmina(Assembler::word, r18, r27, r20);        \/\/       ldsmina         w18, w27, [x20]\n-    __ ldsmaxa(Assembler::word, r16, r12, r11);        \/\/       ldsmaxa         w16, w12, [x11]\n-    __ ldumina(Assembler::word, r9, r6, r30);          \/\/       ldumina         w9, w6, [x30]\n-    __ ldumaxa(Assembler::word, r17, r27, r28);        \/\/       ldumaxa         w17, w27, [x28]\n+    __ ldsmina(Assembler::word, r18, r27, r20);        \/\/       ldsmina w18, w27, [x20]\n+    __ ldsmaxa(Assembler::word, r16, r12, r11);        \/\/       ldsmaxa w16, w12, [x11]\n+    __ ldumina(Assembler::word, r9, r6, r30);          \/\/       ldumina w9, w6, [x30]\n+    __ ldumaxa(Assembler::word, r17, r27, r28);        \/\/       ldumaxa w17, w27, [x28]\n@@ -883,4 +916,4 @@\n-    __ ldaddal(Assembler::word, r20, r10, r4);         \/\/       ldaddal         w20, w10, [x4]\n-    __ ldbical(Assembler::word, r24, r17, r17);        \/\/       ldclral         w24, w17, [x17]\n-    __ ldeoral(Assembler::word, r22, r3, r29);         \/\/       ldeoral         w22, w3, [x29]\n-    __ ldorral(Assembler::word, r15, r22, r19);        \/\/       ldsetal         w15, w22, [x19]\n+    __ ldaddal(Assembler::word, r20, r10, r4);         \/\/       ldaddal w20, w10, [x4]\n+    __ ldbical(Assembler::word, r24, r17, r17);        \/\/       ldclral w24, w17, [x17]\n+    __ ldeoral(Assembler::word, r22, r3, r29);         \/\/       ldeoral w22, w3, [x29]\n+    __ ldorral(Assembler::word, r15, r22, r19);        \/\/       ldsetal w15, w22, [x19]\n@@ -898,4 +931,55 @@\n-    __ ldsminl(Assembler::word, zr, r24, r19);         \/\/       ldsminl         wzr, w24, [x19]\n-    __ ldsmaxl(Assembler::word, r17, r9, r28);         \/\/       ldsmaxl         w17, w9, [x28]\n-    __ lduminl(Assembler::word, r27, r15, r7);         \/\/       lduminl         w27, w15, [x7]\n-    __ ldumaxl(Assembler::word, r21, r23, sp);         \/\/       ldumaxl         w21, w23, [sp]\n+    __ ldsminl(Assembler::word, zr, r24, r19);         \/\/       ldsminl wzr, w24, [x19]\n+    __ ldsmaxl(Assembler::word, r17, r9, r28);         \/\/       ldsmaxl w17, w9, [x28]\n+    __ lduminl(Assembler::word, r27, r15, r7);         \/\/       lduminl w27, w15, [x7]\n+    __ ldumaxl(Assembler::word, r21, r23, sp);         \/\/       ldumaxl w21, w23, [sp]\n+\n+\/\/ SVEVectorOp\n+    __ sve_add(z24, __ D, z2, z30);                    \/\/       add     z24.d, z2.d, z30.d\n+    __ sve_sub(z18, __ S, z10, z22);                   \/\/       sub     z18.s, z10.s, z22.s\n+    __ sve_fadd(z2, __ D, z17, z0);                    \/\/       fadd    z2.d, z17.d, z0.d\n+    __ sve_fmul(z25, __ D, z22, z2);                   \/\/       fmul    z25.d, z22.d, z2.d\n+    __ sve_fsub(z12, __ D, z3, z27);                   \/\/       fsub    z12.d, z3.d, z27.d\n+    __ sve_abs(z28, __ B, p4, z26);                    \/\/       abs     z28.b, p4\/m, z26.b\n+    __ sve_add(z9, __ B, p7, z18);                     \/\/       add     z9.b, p7\/m, z9.b, z18.b\n+    __ sve_asr(z4, __ H, p1, z15);                     \/\/       asr     z4.h, p1\/m, z4.h, z15.h\n+    __ sve_cnt(z22, __ D, p2, z2);                     \/\/       cnt     z22.d, p2\/m, z2.d\n+    __ sve_lsl(z20, __ D, p7, z5);                     \/\/       lsl     z20.d, p7\/m, z20.d, z5.d\n+    __ sve_lsr(z0, __ B, p4, z14);                     \/\/       lsr     z0.b, p4\/m, z0.b, z14.b\n+    __ sve_mul(z25, __ S, p2, z27);                    \/\/       mul     z25.s, p2\/m, z25.s, z27.s\n+    __ sve_neg(z26, __ S, p6, z24);                    \/\/       neg     z26.s, p6\/m, z24.s\n+    __ sve_not(z0, __ S, p1, z6);                      \/\/       not     z0.s, p1\/m, z6.s\n+    __ sve_smax(z0, __ B, p1, z15);                    \/\/       smax    z0.b, p1\/m, z0.b, z15.b\n+    __ sve_smin(z9, __ H, p1, z5);                     \/\/       smin    z9.h, p1\/m, z9.h, z5.h\n+    __ sve_sub(z27, __ S, p1, z20);                    \/\/       sub     z27.s, p1\/m, z27.s, z20.s\n+    __ sve_fabs(z20, __ S, p1, z10);                   \/\/       fabs    z20.s, p1\/m, z10.s\n+    __ sve_fadd(z16, __ D, p7, z6);                    \/\/       fadd    z16.d, p7\/m, z16.d, z6.d\n+    __ sve_fdiv(z2, __ D, p3, z29);                    \/\/       fdiv    z2.d, p3\/m, z2.d, z29.d\n+    __ sve_fmax(z2, __ D, p6, z22);                    \/\/       fmax    z2.d, p6\/m, z2.d, z22.d\n+    __ sve_fmin(z14, __ D, p3, z27);                   \/\/       fmin    z14.d, p3\/m, z14.d, z27.d\n+    __ sve_fmul(z23, __ S, p1, z2);                    \/\/       fmul    z23.s, p1\/m, z23.s, z2.s\n+    __ sve_fneg(z10, __ D, p4, z10);                   \/\/       fneg    z10.d, p4\/m, z10.d\n+    __ sve_frintm(z22, __ D, p3, z3);                  \/\/       frintm  z22.d, p3\/m, z3.d\n+    __ sve_frintn(z16, __ D, p1, z1);                  \/\/       frintn  z16.d, p1\/m, z1.d\n+    __ sve_frintp(z16, __ S, p4, z12);                 \/\/       frintp  z16.s, p4\/m, z12.s\n+    __ sve_fsqrt(z12, __ S, p0, z16);                  \/\/       fsqrt   z12.s, p0\/m, z16.s\n+    __ sve_fsub(z20, __ S, p5, z5);                    \/\/       fsub    z20.s, p5\/m, z20.s, z5.s\n+    __ sve_fmla(z7, __ D, p4, z12, z27);               \/\/       fmla    z7.d, p4\/m, z12.d, z27.d\n+    __ sve_fmls(z16, __ S, p1, z2, z28);               \/\/       fmls    z16.s, p1\/m, z2.s, z28.s\n+    __ sve_fnmla(z4, __ S, p1, z17, z19);              \/\/       fnmla   z4.s, p1\/m, z17.s, z19.s\n+    __ sve_fnmls(z12, __ D, p5, z8, z24);              \/\/       fnmls   z12.d, p5\/m, z8.d, z24.d\n+    __ sve_mla(z18, __ B, p0, z10, z23);               \/\/       mla     z18.b, p0\/m, z10.b, z23.b\n+    __ sve_mls(z19, __ B, p7, z13, z16);               \/\/       mls     z19.b, p7\/m, z13.b, z16.b\n+    __ sve_and(z0, z7, z14);                           \/\/       and     z0.d, z7.d, z14.d\n+    __ sve_eor(z25, z8, z10);                          \/\/       eor     z25.d, z8.d, z10.d\n+    __ sve_orr(z20, z22, z27);                         \/\/       orr     z20.d, z22.d, z27.d\n+\n+\/\/ SVEReductionOp\n+    __ sve_andv(v3, __ S, p3, z18);                    \/\/       andv s3, p3, z18.s\n+    __ sve_orv(v7, __ B, p1, z28);                     \/\/       orv b7, p1, z28.b\n+    __ sve_eorv(v0, __ S, p2, z16);                    \/\/       eorv s0, p2, z16.s\n+    __ sve_smaxv(v22, __ H, p1, z15);                  \/\/       smaxv h22, p1, z15.h\n+    __ sve_sminv(v22, __ B, p2, z25);                  \/\/       sminv b22, p2, z25.b\n+    __ sve_fminv(v30, __ D, p4, z13);                  \/\/       fminv d30, p4, z13.d\n+    __ sve_fmaxv(v11, __ S, p0, z13);                  \/\/       fmaxv s11, p0, z13.s\n+    __ sve_fadda(v20, __ S, p4, z25);                  \/\/       fadda s20, p4, s20, z25.s\n+    __ sve_uaddv(v4, __ H, p1, z17);                   \/\/       uaddv d4, p1, z17.h\n@@ -906,683 +990,0 @@\n-\n-aarch64ops.o:     file format elf64-littleaarch64\n-\n-\n-Disassembly of section .text:\n-\n-0000000000000000 <back>:\n-   0:   8b0d82fa        add     x26, x23, x13, lsl #32\n-   4:   cb49970c        sub     x12, x24, x9, lsr #37\n-   8:   ab889dfc        adds    x28, x15, x8, asr #39\n-   c:   eb9ee787        subs    x7, x28, x30, asr #57\n-  10:   0b9b3ec9        add     w9, w22, w27, asr #15\n-  14:   4b9279a3        sub     w3, w13, w18, asr #30\n-  18:   2b88474e        adds    w14, w26, w8, asr #17\n-  1c:   6b8c56c0        subs    w0, w22, w12, asr #21\n-  20:   8a1a51e0        and     x0, x15, x26, lsl #20\n-  24:   aa11f4ba        orr     x26, x5, x17, lsl #61\n-  28:   ca0281b8        eor     x24, x13, x2, lsl #32\n-  2c:   ea918c7c        ands    x28, x3, x17, asr #35\n-  30:   0a5d4a19        and     w25, w16, w29, lsr #18\n-  34:   2a4b264d        orr     w13, w18, w11, lsr #9\n-  38:   4a523ca5        eor     w5, w5, w18, lsr #15\n-  3c:   6a9b6ae2        ands    w2, w23, w27, asr #26\n-  40:   8a70b79b        bic     x27, x28, x16, lsr #45\n-  44:   aaba9728        orn     x8, x25, x26, asr #37\n-  48:   ca6dfe3d        eon     x29, x17, x13, lsr #63\n-  4c:   ea627f1c        bics    x28, x24, x2, lsr #31\n-  50:   0aa70f53        bic     w19, w26, w7, asr #3\n-  54:   2aaa0f06        orn     w6, w24, w10, asr #3\n-  58:   4a6176a4        eon     w4, w21, w1, lsr #29\n-  5c:   6a604eb0        bics    w16, w21, w0, lsr #19\n-  60:   1105ed91        add     w17, w12, #0x17b\n-  64:   3100583e        adds    w30, w1, #0x16\n-  68:   5101f8bd        sub     w29, w5, #0x7e\n-  6c:   710f0306        subs    w6, w24, #0x3c0\n-  70:   9101a1a0        add     x0, x13, #0x68\n-  74:   b10a5cc8        adds    x8, x6, #0x297\n-  78:   d10810aa        sub     x10, x5, #0x204\n-  7c:   f10fd061        subs    x1, x3, #0x3f4\n-  80:   120cb166        and     w6, w11, #0xfff1fff1\n-  84:   321764bc        orr     w28, w5, #0xfffffe07\n-  88:   52174681        eor     w1, w20, #0x7fffe00\n-  8c:   720c0247        ands    w7, w18, #0x100000\n-  90:   9241018e        and     x14, x12, #0x8000000000000000\n-  94:   b25a2969        orr     x9, x11, #0x1ffc000000000\n-  98:   d278b411        eor     x17, x0, #0x3fffffffffff00\n-  9c:   f26aad01        ands    x1, x8, #0xffffffffffc00003\n-  a0:   14000000        b       a0 <back+0xa0>\n-  a4:   17ffffd7        b       0 <back>\n-  a8:   14000279        b       a8c <forth>\n-  ac:   94000000        bl      ac <back+0xac>\n-  b0:   97ffffd4        bl      0 <back>\n-  b4:   94000276        bl      a8c <forth>\n-  b8:   3400000a        cbz     w10, b8 <back+0xb8>\n-  bc:   34fffa2a        cbz     w10, 0 <back>\n-  c0:   34004e6a        cbz     w10, a8c <forth>\n-  c4:   35000008        cbnz    w8, c4 <back+0xc4>\n-  c8:   35fff9c8        cbnz    w8, 0 <back>\n-  cc:   35004e08        cbnz    w8, a8c <forth>\n-  d0:   b400000b        cbz     x11, d0 <back+0xd0>\n-  d4:   b4fff96b        cbz     x11, 0 <back>\n-  d8:   b4004dab        cbz     x11, a8c <forth>\n-  dc:   b500001d        cbnz    x29, dc <back+0xdc>\n-  e0:   b5fff91d        cbnz    x29, 0 <back>\n-  e4:   b5004d5d        cbnz    x29, a8c <forth>\n-  e8:   10000013        adr     x19, e8 <back+0xe8>\n-  ec:   10fff8b3        adr     x19, 0 <back>\n-  f0:   10004cf3        adr     x19, a8c <forth>\n-  f4:   90000013        adrp    x19, 0 <back>\n-  f8:   36300016        tbz     w22, #6, f8 <back+0xf8>\n-  fc:   3637f836        tbz     w22, #6, 0 <back>\n- 100:   36304c76        tbz     w22, #6, a8c <forth>\n- 104:   3758000c        tbnz    w12, #11, 104 <back+0x104>\n- 108:   375ff7cc        tbnz    w12, #11, 0 <back>\n- 10c:   37584c0c        tbnz    w12, #11, a8c <forth>\n- 110:   128313a0        mov     w0, #0xffffe762                 \/\/ #-6302\n- 114:   528a32c7        mov     w7, #0x5196                     \/\/ #20886\n- 118:   7289173b        movk    w27, #0x48b9\n- 11c:   92ab3acc        mov     x12, #0xffffffffa629ffff        \/\/ #-1507196929\n- 120:   d2a0bf94        mov     x20, #0x5fc0000                 \/\/ #100401152\n- 124:   f2c285e8        movk    x8, #0x142f, lsl #32\n- 128:   9358722f        sbfx    x15, x17, #24, #5\n- 12c:   330e652f        bfxil   w15, w9, #14, #12\n- 130:   53067f3b        lsr     w27, w25, #6\n- 134:   93577c53        sbfx    x19, x2, #23, #9\n- 138:   b34a1aac        bfi     x12, x21, #54, #7\n- 13c:   d35a4016        ubfiz   x22, x0, #38, #17\n- 140:   13946c63        extr    w3, w3, w20, #27\n- 144:   93c3dbc8        extr    x8, x30, x3, #54\n- 148:   54000000        b.eq    148 <back+0x148>  \/\/ b.none\n- 14c:   54fff5a0        b.eq    0 <back>  \/\/ b.none\n- 150:   540049e0        b.eq    a8c <forth>  \/\/ b.none\n- 154:   54000001        b.ne    154 <back+0x154>  \/\/ b.any\n- 158:   54fff541        b.ne    0 <back>  \/\/ b.any\n- 15c:   54004981        b.ne    a8c <forth>  \/\/ b.any\n- 160:   54000002        b.cs    160 <back+0x160>  \/\/ b.hs, b.nlast\n- 164:   54fff4e2        b.cs    0 <back>  \/\/ b.hs, b.nlast\n- 168:   54004922        b.cs    a8c <forth>  \/\/ b.hs, b.nlast\n- 16c:   54000002        b.cs    16c <back+0x16c>  \/\/ b.hs, b.nlast\n- 170:   54fff482        b.cs    0 <back>  \/\/ b.hs, b.nlast\n- 174:   540048c2        b.cs    a8c <forth>  \/\/ b.hs, b.nlast\n- 178:   54000003        b.cc    178 <back+0x178>  \/\/ b.lo, b.ul, b.last\n- 17c:   54fff423        b.cc    0 <back>  \/\/ b.lo, b.ul, b.last\n- 180:   54004863        b.cc    a8c <forth>  \/\/ b.lo, b.ul, b.last\n- 184:   54000003        b.cc    184 <back+0x184>  \/\/ b.lo, b.ul, b.last\n- 188:   54fff3c3        b.cc    0 <back>  \/\/ b.lo, b.ul, b.last\n- 18c:   54004803        b.cc    a8c <forth>  \/\/ b.lo, b.ul, b.last\n- 190:   54000004        b.mi    190 <back+0x190>  \/\/ b.first\n- 194:   54fff364        b.mi    0 <back>  \/\/ b.first\n- 198:   540047a4        b.mi    a8c <forth>  \/\/ b.first\n- 19c:   54000005        b.pl    19c <back+0x19c>  \/\/ b.nfrst\n- 1a0:   54fff305        b.pl    0 <back>  \/\/ b.nfrst\n- 1a4:   54004745        b.pl    a8c <forth>  \/\/ b.nfrst\n- 1a8:   54000006        b.vs    1a8 <back+0x1a8>\n- 1ac:   54fff2a6        b.vs    0 <back>\n- 1b0:   540046e6        b.vs    a8c <forth>\n- 1b4:   54000007        b.vc    1b4 <back+0x1b4>\n- 1b8:   54fff247        b.vc    0 <back>\n- 1bc:   54004687        b.vc    a8c <forth>\n- 1c0:   54000008        b.hi    1c0 <back+0x1c0>  \/\/ b.pmore\n- 1c4:   54fff1e8        b.hi    0 <back>  \/\/ b.pmore\n- 1c8:   54004628        b.hi    a8c <forth>  \/\/ b.pmore\n- 1cc:   54000009        b.ls    1cc <back+0x1cc>  \/\/ b.plast\n- 1d0:   54fff189        b.ls    0 <back>  \/\/ b.plast\n- 1d4:   540045c9        b.ls    a8c <forth>  \/\/ b.plast\n- 1d8:   5400000a        b.ge    1d8 <back+0x1d8>  \/\/ b.tcont\n- 1dc:   54fff12a        b.ge    0 <back>  \/\/ b.tcont\n- 1e0:   5400456a        b.ge    a8c <forth>  \/\/ b.tcont\n- 1e4:   5400000b        b.lt    1e4 <back+0x1e4>  \/\/ b.tstop\n- 1e8:   54fff0cb        b.lt    0 <back>  \/\/ b.tstop\n- 1ec:   5400450b        b.lt    a8c <forth>  \/\/ b.tstop\n- 1f0:   5400000c        b.gt    1f0 <back+0x1f0>\n- 1f4:   54fff06c        b.gt    0 <back>\n- 1f8:   540044ac        b.gt    a8c <forth>\n- 1fc:   5400000d        b.le    1fc <back+0x1fc>\n- 200:   54fff00d        b.le    0 <back>\n- 204:   5400444d        b.le    a8c <forth>\n- 208:   5400000e        b.al    208 <back+0x208>\n- 20c:   54ffefae        b.al    0 <back>\n- 210:   540043ee        b.al    a8c <forth>\n- 214:   5400000f        b.nv    214 <back+0x214>\n- 218:   54ffef4f        b.nv    0 <back>\n- 21c:   5400438f        b.nv    a8c <forth>\n- 220:   d40658e1        svc     #0x32c7\n- 224:   d4014d22        hvc     #0xa69\n- 228:   d4046543        smc     #0x232a\n- 22c:   d4273f60        brk     #0x39fb\n- 230:   d44cad80        hlt     #0x656c\n- 234:   d503201f        nop\n- 238:   d69f03e0        eret\n- 23c:   d6bf03e0        drps\n- 240:   d5033fdf        isb\n- 244:   d5033e9f        dsb     st\n- 248:   d50332bf        dmb     oshst\n- 24c:   d61f0200        br      x16\n- 250:   d63f0280        blr     x20\n- 254:   c80a7d1b        stxr    w10, x27, [x8]\n- 258:   c800fea1        stlxr   w0, x1, [x21]\n- 25c:   c85f7fb1        ldxr    x17, [x29]\n- 260:   c85fff9d        ldaxr   x29, [x28]\n- 264:   c89ffee1        stlr    x1, [x23]\n- 268:   c8dffe95        ldar    x21, [x20]\n- 26c:   88167e7b        stxr    w22, w27, [x19]\n- 270:   880bfcd0        stlxr   w11, w16, [x6]\n- 274:   885f7c12        ldxr    w18, [x0]\n- 278:   885ffd44        ldaxr   w4, [x10]\n- 27c:   889ffed8        stlr    w24, [x22]\n- 280:   88dffe6a        ldar    w10, [x19]\n- 284:   48017fc5        stxrh   w1, w5, [x30]\n- 288:   4808fe2c        stlxrh  w8, w12, [x17]\n- 28c:   485f7dc9        ldxrh   w9, [x14]\n- 290:   485ffc27        ldaxrh  w7, [x1]\n- 294:   489ffe05        stlrh   w5, [x16]\n- 298:   48dffd82        ldarh   w2, [x12]\n- 29c:   080a7c6c        stxrb   w10, w12, [x3]\n- 2a0:   081cff4e        stlxrb  w28, w14, [x26]\n- 2a4:   085f7d5e        ldxrb   w30, [x10]\n- 2a8:   085ffeae        ldaxrb  w14, [x21]\n- 2ac:   089ffd2d        stlrb   w13, [x9]\n- 2b0:   08dfff76        ldarb   w22, [x27]\n- 2b4:   c87f4d7c        ldxp    x28, x19, [x11]\n- 2b8:   c87fcc5e        ldaxp   x30, x19, [x2]\n- 2bc:   c8220417        stxp    w2, x23, x1, [x0]\n- 2c0:   c82cb5f0        stlxp   w12, x16, x13, [x15]\n- 2c4:   887f55b2        ldxp    w18, w21, [x13]\n- 2c8:   887ff90b        ldaxp   w11, w30, [x8]\n- 2cc:   88382c2d        stxp    w24, w13, w11, [x1]\n- 2d0:   883aedb5        stlxp   w26, w21, w27, [x13]\n- 2d4:   f819928b        stur    x11, [x20, #-103]\n- 2d8:   b803e21c        stur    w28, [x16, #62]\n- 2dc:   381f713b        sturb   w27, [x9, #-9]\n- 2e0:   781ce322        sturh   w2, [x25, #-50]\n- 2e4:   f850f044        ldur    x4, [x2, #-241]\n- 2e8:   b85e129e        ldur    w30, [x20, #-31]\n- 2ec:   385e92f2        ldurb   w18, [x23, #-23]\n- 2f0:   785ff35d        ldurh   w29, [x26, #-1]\n- 2f4:   39801921        ldrsb   x1, [x9, #6]\n- 2f8:   7881318b        ldursh  x11, [x12, #19]\n- 2fc:   78dce02b        ldursh  w11, [x1, #-50]\n- 300:   b8829313        ldursw  x19, [x24, #41]\n- 304:   fc45f318        ldur    d24, [x24, #95]\n- 308:   bc5d50af        ldur    s15, [x5, #-43]\n- 30c:   fc001375        stur    d21, [x27, #1]\n- 310:   bc1951b7        stur    s23, [x13, #-107]\n- 314:   f8008c0b        str     x11, [x0, #8]!\n- 318:   b801dc03        str     w3, [x0, #29]!\n- 31c:   38009dcb        strb    w11, [x14, #9]!\n- 320:   781fdf1d        strh    w29, [x24, #-3]!\n- 324:   f8570e2d        ldr     x13, [x17, #-144]!\n- 328:   b85faecc        ldr     w12, [x22, #-6]!\n- 32c:   385f6d8d        ldrb    w13, [x12, #-10]!\n- 330:   785ebea0        ldrh    w0, [x21, #-21]!\n- 334:   38804cf7        ldrsb   x23, [x7, #4]!\n- 338:   789cbce3        ldrsh   x3, [x7, #-53]!\n- 33c:   78df9cbc        ldrsh   w28, [x5, #-7]!\n- 340:   b89eed38        ldrsw   x24, [x9, #-18]!\n- 344:   fc40cd6e        ldr     d14, [x11, #12]!\n- 348:   bc5bdd93        ldr     s19, [x12, #-67]!\n- 34c:   fc103c14        str     d20, [x0, #-253]!\n- 350:   bc040c08        str     s8, [x0, #64]!\n- 354:   f81a2784        str     x4, [x28], #-94\n- 358:   b81ca4ec        str     w12, [x7], #-54\n- 35c:   381e855b        strb    w27, [x10], #-24\n- 360:   7801b506        strh    w6, [x8], #27\n- 364:   f853654e        ldr     x14, [x10], #-202\n- 368:   b85d74b0        ldr     w16, [x5], #-41\n- 36c:   384095c2        ldrb    w2, [x14], #9\n- 370:   785ec5bc        ldrh    w28, [x13], #-20\n- 374:   389e15a9        ldrsb   x9, [x13], #-31\n- 378:   789dc703        ldrsh   x3, [x24], #-36\n- 37c:   78c06474        ldrsh   w20, [x3], #6\n- 380:   b89ff667        ldrsw   x7, [x19], #-1\n- 384:   fc57e51e        ldr     d30, [x8], #-130\n- 388:   bc4155f9        ldr     s25, [x15], #21\n- 38c:   fc05a6ee        str     d14, [x23], #90\n- 390:   bc1df408        str     s8, [x0], #-33\n- 394:   f835da4a        str     x10, [x18, w21, sxtw #3]\n- 398:   b836d9a4        str     w4, [x13, w22, sxtw #2]\n- 39c:   3833580d        strb    w13, [x0, w19, uxtw #0]\n- 3a0:   7826cb6c        strh    w12, [x27, w6, sxtw]\n- 3a4:   f8706900        ldr     x0, [x8, x16]\n- 3a8:   b87ae880        ldr     w0, [x4, x26, sxtx]\n- 3ac:   3865db2e        ldrb    w14, [x25, w5, sxtw #0]\n- 3b0:   78724889        ldrh    w9, [x4, w18, uxtw]\n- 3b4:   38a7789b        ldrsb   x27, [x4, x7, lsl #0]\n- 3b8:   78beca2f        ldrsh   x15, [x17, w30, sxtw]\n- 3bc:   78f6c810        ldrsh   w16, [x0, w22, sxtw]\n- 3c0:   b8bef956        ldrsw   x22, [x10, x30, sxtx #2]\n- 3c4:   fc6afabd        ldr     d29, [x21, x10, sxtx #3]\n- 3c8:   bc734963        ldr     s3, [x11, w19, uxtw]\n- 3cc:   fc3d5b8d        str     d13, [x28, w29, uxtw #3]\n- 3d0:   bc25fbb7        str     s23, [x29, x5, sxtx #2]\n- 3d4:   f9189d05        str     x5, [x8, #12600]\n- 3d8:   b91ecb1d        str     w29, [x24, #7880]\n- 3dc:   39187a33        strb    w19, [x17, #1566]\n- 3e0:   791f226d        strh    w13, [x19, #3984]\n- 3e4:   f95aa2f3        ldr     x19, [x23, #13632]\n- 3e8:   b9587bb7        ldr     w23, [x29, #6264]\n- 3ec:   395f7176        ldrb    w22, [x11, #2012]\n- 3f0:   795d9143        ldrh    w3, [x10, #3784]\n- 3f4:   399e7e08        ldrsb   x8, [x16, #1951]\n- 3f8:   799a2697        ldrsh   x23, [x20, #3346]\n- 3fc:   79df3422        ldrsh   w2, [x1, #3994]\n- 400:   b99c2624        ldrsw   x4, [x17, #7204]\n- 404:   fd5c2374        ldr     d20, [x27, #14400]\n- 408:   bd5fa1d9        ldr     s25, [x14, #8096]\n- 40c:   fd1d595a        str     d26, [x10, #15024]\n- 410:   bd1b1869        str     s9, [x3, #6936]\n- 414:   580033db        ldr     x27, a8c <forth>\n- 418:   1800000b        ldr     w11, 418 <back+0x418>\n- 41c:   f8945060        prfum   pldl1keep, [x3, #-187]\n- 420:   d8000000        prfm    pldl1keep, 420 <back+0x420>\n- 424:   f8ae6ba0        prfm    pldl1keep, [x29, x14]\n- 428:   f99a0080        prfm    pldl1keep, [x4, #13312]\n- 42c:   1a070035        adc     w21, w1, w7\n- 430:   3a0700a8        adcs    w8, w5, w7\n- 434:   5a0e0367        sbc     w7, w27, w14\n- 438:   7a11009b        sbcs    w27, w4, w17\n- 43c:   9a000380        adc     x0, x28, x0\n- 440:   ba1e030c        adcs    x12, x24, x30\n- 444:   da0f0320        sbc     x0, x25, x15\n- 448:   fa030301        sbcs    x1, x24, x3\n- 44c:   0b340b12        add     w18, w24, w20, uxtb #2\n- 450:   2b2a278d        adds    w13, w28, w10, uxth #1\n- 454:   cb22aa0f        sub     x15, x16, w2, sxth #2\n- 458:   6b2d29bd        subs    w29, w13, w13, uxth #2\n- 45c:   8b2cce8c        add     x12, x20, w12, sxtw #3\n- 460:   ab2b877e        adds    x30, x27, w11, sxtb #1\n- 464:   cb21c8ee        sub     x14, x7, w1, sxtw #2\n- 468:   eb3ba47d        subs    x29, x3, w27, sxth #1\n- 46c:   3a4d400e        ccmn    w0, w13, #0xe, mi  \/\/ mi = first\n- 470:   7a5232c6        ccmp    w22, w18, #0x6, cc  \/\/ cc = lo, ul, last\n- 474:   ba5e624e        ccmn    x18, x30, #0xe, vs\n- 478:   fa53814c        ccmp    x10, x19, #0xc, hi  \/\/ hi = pmore\n- 47c:   3a52d8c2        ccmn    w6, #0x12, #0x2, le\n- 480:   7a4d8924        ccmp    w9, #0xd, #0x4, hi  \/\/ hi = pmore\n- 484:   ba4b3aab        ccmn    x21, #0xb, #0xb, cc  \/\/ cc = lo, ul, last\n- 488:   fa4d7882        ccmp    x4, #0xd, #0x2, vc\n- 48c:   1a96804c        csel    w12, w2, w22, hi  \/\/ hi = pmore\n- 490:   1a912618        csinc   w24, w16, w17, cs  \/\/ cs = hs, nlast\n- 494:   5a90b0e6        csinv   w6, w7, w16, lt  \/\/ lt = tstop\n- 498:   5a96976b        csneg   w11, w27, w22, ls  \/\/ ls = plast\n- 49c:   9a9db06a        csel    x10, x3, x29, lt  \/\/ lt = tstop\n- 4a0:   9a9b374c        csinc   x12, x26, x27, cc  \/\/ cc = lo, ul, last\n- 4a4:   da95c14f        csinv   x15, x10, x21, gt\n- 4a8:   da89c6fe        csneg   x30, x23, x9, gt\n- 4ac:   5ac0015e        rbit    w30, w10\n- 4b0:   5ac005fd        rev16   w29, w15\n- 4b4:   5ac00bdd        rev     w29, w30\n- 4b8:   5ac012b9        clz     w25, w21\n- 4bc:   5ac01404        cls     w4, w0\n- 4c0:   dac002b2        rbit    x18, x21\n- 4c4:   dac0061d        rev16   x29, x16\n- 4c8:   dac00a95        rev32   x21, x20\n- 4cc:   dac00e66        rev     x6, x19\n- 4d0:   dac0107e        clz     x30, x3\n- 4d4:   dac01675        cls     x21, x19\n- 4d8:   1ac00b0b        udiv    w11, w24, w0\n- 4dc:   1ace0f3b        sdiv    w27, w25, w14\n- 4e0:   1ad221c3        lsl     w3, w14, w18\n- 4e4:   1ad825e7        lsr     w7, w15, w24\n- 4e8:   1ad92a3c        asr     w28, w17, w25\n- 4ec:   1adc2f42        ror     w2, w26, w28\n- 4f0:   9ada0b25        udiv    x5, x25, x26\n- 4f4:   9ad20e1b        sdiv    x27, x16, x18\n- 4f8:   9acc22a6        lsl     x6, x21, x12\n- 4fc:   9acc2480        lsr     x0, x4, x12\n- 500:   9adc2a3b        asr     x27, x17, x28\n- 504:   9ad22c5c        ror     x28, x2, x18\n- 508:   9bce7dea        umulh   x10, x15, x14\n- 50c:   9b597c6e        smulh   x14, x3, x25\n- 510:   1b0e166f        madd    w15, w19, w14, w5\n- 514:   1b1ae490        msub    w16, w4, w26, w25\n- 518:   9b023044        madd    x4, x2, x2, x12\n- 51c:   9b089e3d        msub    x29, x17, x8, x7\n- 520:   9b391083        smaddl  x3, w4, w25, x4\n- 524:   9b24c73a        smsubl  x26, w25, w4, x17\n- 528:   9bb15f40        umaddl  x0, w26, w17, x23\n- 52c:   9bbcc6af        umsubl  x15, w21, w28, x17\n- 530:   1e23095b        fmul    s27, s10, s3\n- 534:   1e3918e0        fdiv    s0, s7, s25\n- 538:   1e2f28c9        fadd    s9, s6, s15\n- 53c:   1e2a39fd        fsub    s29, s15, s10\n- 540:   1e270a22        fmul    s2, s17, s7\n- 544:   1e77096b        fmul    d11, d11, d23\n- 548:   1e771ba7        fdiv    d7, d29, d23\n- 54c:   1e6b2b6e        fadd    d14, d27, d11\n- 550:   1e78388b        fsub    d11, d4, d24\n- 554:   1e6e09ec        fmul    d12, d15, d14\n- 558:   1f1c3574        fmadd   s20, s11, s28, s13\n- 55c:   1f17f98b        fmsub   s11, s12, s23, s30\n- 560:   1f2935da        fnmadd  s26, s14, s9, s13\n- 564:   1f2574ea        fnmadd  s10, s7, s5, s29\n- 568:   1f4b306f        fmadd   d15, d3, d11, d12\n- 56c:   1f5ec7cf        fmsub   d15, d30, d30, d17\n- 570:   1f6f3e93        fnmadd  d19, d20, d15, d15\n- 574:   1f6226a9        fnmadd  d9, d21, d2, d9\n- 578:   1e2040fb        fmov    s27, s7\n- 57c:   1e20c3dd        fabs    s29, s30\n- 580:   1e214031        fneg    s17, s1\n- 584:   1e21c0c2        fsqrt   s2, s6\n- 588:   1e22c06a        fcvt    d10, s3\n- 58c:   1e604178        fmov    d24, d11\n- 590:   1e60c027        fabs    d7, d1\n- 594:   1e61400b        fneg    d11, d0\n- 598:   1e61c243        fsqrt   d3, d18\n- 59c:   1e6240dc        fcvt    s28, d6\n- 5a0:   1e3800d6        fcvtzs  w22, s6\n- 5a4:   9e380360        fcvtzs  x0, s27\n- 5a8:   1e78005a        fcvtzs  w26, d2\n- 5ac:   9e7800e5        fcvtzs  x5, d7\n- 5b0:   1e22017c        scvtf   s28, w11\n- 5b4:   9e2201b9        scvtf   s25, x13\n- 5b8:   1e6202eb        scvtf   d11, w23\n- 5bc:   9e620113        scvtf   d19, x8\n- 5c0:   1e2602b2        fmov    w18, s21\n- 5c4:   9e660299        fmov    x25, d20\n- 5c8:   1e270253        fmov    s19, w18\n- 5cc:   9e6703a2        fmov    d2, x29\n- 5d0:   1e2822c0        fcmp    s22, s8\n- 5d4:   1e7322a0        fcmp    d21, d19\n- 5d8:   1e202288        fcmp    s20, #0.0\n- 5dc:   1e602168        fcmp    d11, #0.0\n- 5e0:   293c19f4        stp     w20, w6, [x15, #-32]\n- 5e4:   2966387b        ldp     w27, w14, [x3, #-208]\n- 5e8:   69762971        ldpsw   x17, x10, [x11, #-80]\n- 5ec:   a9041dc7        stp     x7, x7, [x14, #64]\n- 5f0:   a9475c0c        ldp     x12, x23, [x0, #112]\n- 5f4:   29b61ccd        stp     w13, w7, [x6, #-80]!\n- 5f8:   29ee405e        ldp     w30, w16, [x2, #-144]!\n- 5fc:   69ee0744        ldpsw   x4, x1, [x26, #-144]!\n- 600:   a9843977        stp     x23, x14, [x11, #64]!\n- 604:   a9f46ebd        ldp     x29, x27, [x21, #-192]!\n- 608:   28ba16b6        stp     w22, w5, [x21], #-48\n- 60c:   28fc44db        ldp     w27, w17, [x6], #-32\n- 610:   68f61831        ldpsw   x17, x6, [x1], #-80\n- 614:   a8b352ad        stp     x13, x20, [x21], #-208\n- 618:   a8c56d5e        ldp     x30, x27, [x10], #80\n- 61c:   28024565        stnp    w5, w17, [x11, #16]\n- 620:   2874134e        ldnp    w14, w4, [x26, #-96]\n- 624:   a8027597        stnp    x23, x29, [x12, #32]\n- 628:   a87b1aa0        ldnp    x0, x6, [x21, #-80]\n- 62c:   0c40734f        ld1     {v15.8b}, [x26]\n- 630:   4cdfa177        ld1     {v23.16b, v24.16b}, [x11], #32\n- 634:   0cc76ee8        ld1     {v8.1d-v10.1d}, [x23], x7\n- 638:   4cdf2733        ld1     {v19.8h-v22.8h}, [x25], #64\n- 63c:   0d40c23d        ld1r    {v29.8b}, [x17]\n- 640:   4ddfcaf8        ld1r    {v24.4s}, [x23], #4\n- 644:   0dd9ccaa        ld1r    {v10.1d}, [x5], x25\n- 648:   4c408d52        ld2     {v18.2d, v19.2d}, [x10]\n- 64c:   0cdf85ec        ld2     {v12.4h, v13.4h}, [x15], #16\n- 650:   4d60c259        ld2r    {v25.16b, v26.16b}, [x18]\n- 654:   0dffcbc1        ld2r    {v1.2s, v2.2s}, [x30], #8\n- 658:   4de9ce50        ld2r    {v16.2d, v17.2d}, [x18], x9\n- 65c:   4cc24999        ld3     {v25.4s-v27.4s}, [x12], x2\n- 660:   0c404a7a        ld3     {v26.2s-v28.2s}, [x19]\n- 664:   4d40e6af        ld3r    {v15.8h-v17.8h}, [x21]\n- 668:   4ddfe9b9        ld3r    {v25.4s-v27.4s}, [x13], #12\n- 66c:   0dddef8e        ld3r    {v14.1d-v16.1d}, [x28], x29\n- 670:   4cdf07b1        ld4     {v17.8h-v20.8h}, [x29], #64\n- 674:   0cc000fb        ld4     {v27.8b-v30.8b}, [x7], x0\n- 678:   0d60e258        ld4r    {v24.8b-v27.8b}, [x18]\n- 67c:   0dffe740        ld4r    {v0.4h-v3.4h}, [x26], #8\n- 680:   0de2eb2c        ld4r    {v12.2s-v15.2s}, [x25], x2\n- 684:   0e31baf6        addv    b22, v23.8b\n- 688:   4e31bb9b        addv    b27, v28.16b\n- 68c:   0e71b8a4        addv    h4, v5.4h\n- 690:   4e71b907        addv    h7, v8.8h\n- 694:   4eb1b8e6        addv    s6, v7.4s\n- 698:   0e30a841        smaxv   b1, v2.8b\n- 69c:   4e30ab7a        smaxv   b26, v27.16b\n- 6a0:   0e70aa0f        smaxv   h15, v16.4h\n- 6a4:   4e70a862        smaxv   h2, v3.8h\n- 6a8:   4eb0a9cd        smaxv   s13, v14.4s\n- 6ac:   6e30f9cd        fmaxv   s13, v14.4s\n- 6b0:   0e31ab38        sminv   b24, v25.8b\n- 6b4:   4e31ab17        sminv   b23, v24.16b\n- 6b8:   0e71a8a4        sminv   h4, v5.4h\n- 6bc:   4e71aa93        sminv   h19, v20.8h\n- 6c0:   4eb1aa0f        sminv   s15, v16.4s\n- 6c4:   6eb0f820        fminv   s0, v1.4s\n- 6c8:   0e20b8a4        abs     v4.8b, v5.8b\n- 6cc:   4e20bab4        abs     v20.16b, v21.16b\n- 6d0:   0e60b98b        abs     v11.4h, v12.4h\n- 6d4:   4e60bbdd        abs     v29.8h, v30.8h\n- 6d8:   0ea0ba0f        abs     v15.2s, v16.2s\n- 6dc:   4ea0bad5        abs     v21.4s, v22.4s\n- 6e0:   4ee0b8a4        abs     v4.2d, v5.2d\n- 6e4:   0ea0f9ee        fabs    v14.2s, v15.2s\n- 6e8:   4ea0faf6        fabs    v22.4s, v23.4s\n- 6ec:   4ee0fb59        fabs    v25.2d, v26.2d\n- 6f0:   2ea0f8e6        fneg    v6.2s, v7.2s\n- 6f4:   6ea0f9ac        fneg    v12.4s, v13.4s\n- 6f8:   6ee0f9ee        fneg    v14.2d, v15.2d\n- 6fc:   2ea1f9cd        fsqrt   v13.2s, v14.2s\n- 700:   6ea1f9ee        fsqrt   v14.4s, v15.4s\n- 704:   6ee1f949        fsqrt   v9.2d, v10.2d\n- 708:   2e205b59        mvn     v25.8b, v26.8b\n- 70c:   6e205bbc        mvn     v28.16b, v29.16b\n- 710:   0e2c1d6a        and     v10.8b, v11.8b, v12.8b\n- 714:   4e351e93        and     v19.16b, v20.16b, v21.16b\n- 718:   0ead1d8b        orr     v11.8b, v12.8b, v13.8b\n- 71c:   4eb31e51        orr     v17.16b, v18.16b, v19.16b\n- 720:   2e371ed5        eor     v21.8b, v22.8b, v23.8b\n- 724:   6e311e0f        eor     v15.16b, v16.16b, v17.16b\n- 728:   0e3686b4        add     v20.8b, v21.8b, v22.8b\n- 72c:   4e398717        add     v23.16b, v24.16b, v25.16b\n- 730:   0e7c877a        add     v26.4h, v27.4h, v28.4h\n- 734:   4e6784c5        add     v5.8h, v6.8h, v7.8h\n- 738:   0ea884e6        add     v6.2s, v7.2s, v8.2s\n- 73c:   4eb1860f        add     v15.4s, v16.4s, v17.4s\n- 740:   4ef1860f        add     v15.2d, v16.2d, v17.2d\n- 744:   0e3bd759        fadd    v25.2s, v26.2s, v27.2s\n- 748:   4e32d630        fadd    v16.4s, v17.4s, v18.4s\n- 74c:   4e7dd79b        fadd    v27.2d, v28.2d, v29.2d\n- 750:   2e3a8738        sub     v24.8b, v25.8b, v26.8b\n- 754:   6e31860f        sub     v15.16b, v16.16b, v17.16b\n- 758:   2e7b8759        sub     v25.4h, v26.4h, v27.4h\n- 75c:   6e7085ee        sub     v14.8h, v15.8h, v16.8h\n- 760:   2eac856a        sub     v10.2s, v11.2s, v12.2s\n- 764:   6eaf85cd        sub     v13.4s, v14.4s, v15.4s\n- 768:   6ef085ee        sub     v14.2d, v15.2d, v16.2d\n- 76c:   0eb6d6b4        fsub    v20.2s, v21.2s, v22.2s\n- 770:   4ea3d441        fsub    v1.4s, v2.4s, v3.4s\n- 774:   4ef8d6f6        fsub    v22.2d, v23.2d, v24.2d\n- 778:   0e209ffe        mul     v30.8b, v31.8b, v0.8b\n- 77c:   4e309dee        mul     v14.16b, v15.16b, v16.16b\n- 780:   0e649c62        mul     v2.4h, v3.4h, v4.4h\n- 784:   4e689ce6        mul     v6.8h, v7.8h, v8.8h\n- 788:   0ea59c83        mul     v3.2s, v4.2s, v5.2s\n- 78c:   4ea99d07        mul     v7.4s, v8.4s, v9.4s\n- 790:   2e3adf38        fmul    v24.2s, v25.2s, v26.2s\n- 794:   6e22dc20        fmul    v0.4s, v1.4s, v2.4s\n- 798:   6e7ddf9b        fmul    v27.2d, v28.2d, v29.2d\n- 79c:   0e7f97dd        mla     v29.4h, v30.4h, v31.4h\n- 7a0:   4e6794c5        mla     v5.8h, v6.8h, v7.8h\n- 7a4:   0ea794c5        mla     v5.2s, v6.2s, v7.2s\n- 7a8:   4ebf97dd        mla     v29.4s, v30.4s, v31.4s\n- 7ac:   0e2dcd8b        fmla    v11.2s, v12.2s, v13.2s\n- 7b0:   4e3bcf59        fmla    v25.4s, v26.4s, v27.4s\n- 7b4:   4e62cc20        fmla    v0.2d, v1.2d, v2.2d\n- 7b8:   2e6097fe        mls     v30.4h, v31.4h, v0.4h\n- 7bc:   6e629420        mls     v0.8h, v1.8h, v2.8h\n- 7c0:   2eb49672        mls     v18.2s, v19.2s, v20.2s\n- 7c4:   6ebe97bc        mls     v28.4s, v29.4s, v30.4s\n- 7c8:   0ebbcf59        fmls    v25.2s, v26.2s, v27.2s\n- 7cc:   4eabcd49        fmls    v9.4s, v10.4s, v11.4s\n- 7d0:   4efbcf59        fmls    v25.2d, v26.2d, v27.2d\n- 7d4:   2e2efdac        fdiv    v12.2s, v13.2s, v14.2s\n- 7d8:   6e31fe0f        fdiv    v15.4s, v16.4s, v17.4s\n- 7dc:   6e6dfd8b        fdiv    v11.2d, v12.2d, v13.2d\n- 7e0:   0e2c656a        smax    v10.8b, v11.8b, v12.8b\n- 7e4:   4e346672        smax    v18.16b, v19.16b, v20.16b\n- 7e8:   0e7a6738        smax    v24.4h, v25.4h, v26.4h\n- 7ec:   4e7766d5        smax    v21.8h, v22.8h, v23.8h\n- 7f0:   0eb96717        smax    v23.2s, v24.2s, v25.2s\n- 7f4:   4ea26420        smax    v0.4s, v1.4s, v2.4s\n- 7f8:   0e32f630        fmax    v16.2s, v17.2s, v18.2s\n- 7fc:   4e2cf56a        fmax    v10.4s, v11.4s, v12.4s\n- 800:   4e68f4e6        fmax    v6.2d, v7.2d, v8.2d\n- 804:   0e3e6fbc        smin    v28.8b, v29.8b, v30.8b\n- 808:   4e286ce6        smin    v6.16b, v7.16b, v8.16b\n- 80c:   0e676cc5        smin    v5.4h, v6.4h, v7.4h\n- 810:   4e676cc5        smin    v5.8h, v6.8h, v7.8h\n- 814:   0eb66eb4        smin    v20.2s, v21.2s, v22.2s\n- 818:   4eb46e72        smin    v18.4s, v19.4s, v20.4s\n- 81c:   0eb1f60f        fmin    v15.2s, v16.2s, v17.2s\n- 820:   4eb4f672        fmin    v18.4s, v19.4s, v20.4s\n- 824:   4efff7dd        fmin    v29.2d, v30.2d, v31.2d\n- 828:   2e3c8f7a        cmeq    v26.8b, v27.8b, v28.8b\n- 82c:   6e3e8fbc        cmeq    v28.16b, v29.16b, v30.16b\n- 830:   2e638c41        cmeq    v1.4h, v2.4h, v3.4h\n- 834:   6e7d8f9b        cmeq    v27.8h, v28.8h, v29.8h\n- 838:   2ea28c20        cmeq    v0.2s, v1.2s, v2.2s\n- 83c:   6eb68eb4        cmeq    v20.4s, v21.4s, v22.4s\n- 840:   6efe8fbc        cmeq    v28.2d, v29.2d, v30.2d\n- 844:   0e31e60f        fcmeq   v15.2s, v16.2s, v17.2s\n- 848:   4e2ee5ac        fcmeq   v12.4s, v13.4s, v14.4s\n- 84c:   4e6ce56a        fcmeq   v10.2d, v11.2d, v12.2d\n- 850:   0e3e37bc        cmgt    v28.8b, v29.8b, v30.8b\n- 854:   4e3e37bc        cmgt    v28.16b, v29.16b, v30.16b\n- 858:   0e753693        cmgt    v19.4h, v20.4h, v21.4h\n- 85c:   4e7836f6        cmgt    v22.8h, v23.8h, v24.8h\n- 860:   0eac356a        cmgt    v10.2s, v11.2s, v12.2s\n- 864:   4ea634a4        cmgt    v4.4s, v5.4s, v6.4s\n- 868:   4ee037fe        cmgt    v30.2d, v31.2d, v0.2d\n- 86c:   2eb6e6b4        fcmgt   v20.2s, v21.2s, v22.2s\n- 870:   6eaae528        fcmgt   v8.4s, v9.4s, v10.4s\n- 874:   6ee0e7fe        fcmgt   v30.2d, v31.2d, v0.2d\n- 878:   0e343e72        cmge    v18.8b, v19.8b, v20.8b\n- 87c:   4e2c3d6a        cmge    v10.16b, v11.16b, v12.16b\n- 880:   0e7d3f9b        cmge    v27.4h, v28.4h, v29.4h\n- 884:   4e643c62        cmge    v2.8h, v3.8h, v4.8h\n- 888:   0eba3f38        cmge    v24.2s, v25.2s, v26.2s\n- 88c:   4ea63ca4        cmge    v4.4s, v5.4s, v6.4s\n- 890:   4ee53c83        cmge    v3.2d, v4.2d, v5.2d\n- 894:   2e2ae528        fcmge   v8.2s, v9.2s, v10.2s\n- 898:   6e38e6f6        fcmge   v22.4s, v23.4s, v24.4s\n- 89c:   6e74e672        fcmge   v18.2d, v19.2d, v20.2d\n- 8a0:   ce7c808d        sha512h         q13, q4, v28.2d\n- 8a4:   ce7986b7        sha512h2        q23, q21, v25.2d\n- 8a8:   cec08078        sha512su0       v24.2d, v3.2d\n- 8ac:   ce778b57        sha512su1       v23.2d, v26.2d, v23.2d\n- 8b0:   ba5fd3e3        ccmn    xzr, xzr, #0x3, le\n- 8b4:   3a5f03e5        ccmn    wzr, wzr, #0x5, eq  \/\/ eq = none\n- 8b8:   fa411be4        ccmp    xzr, #0x1, #0x4, ne  \/\/ ne = any\n- 8bc:   7a42cbe2        ccmp    wzr, #0x2, #0x2, gt\n- 8c0:   93df03ff        ror     xzr, xzr, #0\n- 8c4:   c820ffff        stlxp   w0, xzr, xzr, [sp]\n- 8c8:   8822fc7f        stlxp   w2, wzr, wzr, [x3]\n- 8cc:   c8247cbf        stxp    w4, xzr, xzr, [x5]\n- 8d0:   88267fff        stxp    w6, wzr, wzr, [sp]\n- 8d4:   4e010fe0        dup     v0.16b, wzr\n- 8d8:   4e081fe1        mov     v1.d[0], xzr\n- 8dc:   4e0c1fe1        mov     v1.s[1], wzr\n- 8e0:   4e0a1fe1        mov     v1.h[2], wzr\n- 8e4:   4e071fe1        mov     v1.b[3], wzr\n- 8e8:   4cc0ac3f        ld1     {v31.2d, v0.2d}, [x1], x0\n- 8ec:   1e601000        fmov    d0, #2.000000000000000000e+00\n- 8f0:   1e603000        fmov    d0, #2.125000000000000000e+00\n- 8f4:   1e621000        fmov    d0, #4.000000000000000000e+00\n- 8f8:   1e623000        fmov    d0, #4.250000000000000000e+00\n- 8fc:   1e641000        fmov    d0, #8.000000000000000000e+00\n- 900:   1e643000        fmov    d0, #8.500000000000000000e+00\n- 904:   1e661000        fmov    d0, #1.600000000000000000e+01\n- 908:   1e663000        fmov    d0, #1.700000000000000000e+01\n- 90c:   1e681000        fmov    d0, #1.250000000000000000e-01\n- 910:   1e683000        fmov    d0, #1.328125000000000000e-01\n- 914:   1e6a1000        fmov    d0, #2.500000000000000000e-01\n- 918:   1e6a3000        fmov    d0, #2.656250000000000000e-01\n- 91c:   1e6c1000        fmov    d0, #5.000000000000000000e-01\n- 920:   1e6c3000        fmov    d0, #5.312500000000000000e-01\n- 924:   1e6e1000        fmov    d0, #1.000000000000000000e+00\n- 928:   1e6e3000        fmov    d0, #1.062500000000000000e+00\n- 92c:   1e701000        fmov    d0, #-2.000000000000000000e+00\n- 930:   1e703000        fmov    d0, #-2.125000000000000000e+00\n- 934:   1e721000        fmov    d0, #-4.000000000000000000e+00\n- 938:   1e723000        fmov    d0, #-4.250000000000000000e+00\n- 93c:   1e741000        fmov    d0, #-8.000000000000000000e+00\n- 940:   1e743000        fmov    d0, #-8.500000000000000000e+00\n- 944:   1e761000        fmov    d0, #-1.600000000000000000e+01\n- 948:   1e763000        fmov    d0, #-1.700000000000000000e+01\n- 94c:   1e781000        fmov    d0, #-1.250000000000000000e-01\n- 950:   1e783000        fmov    d0, #-1.328125000000000000e-01\n- 954:   1e7a1000        fmov    d0, #-2.500000000000000000e-01\n- 958:   1e7a3000        fmov    d0, #-2.656250000000000000e-01\n- 95c:   1e7c1000        fmov    d0, #-5.000000000000000000e-01\n- 960:   1e7c3000        fmov    d0, #-5.312500000000000000e-01\n- 964:   1e7e1000        fmov    d0, #-1.000000000000000000e+00\n- 968:   1e7e3000        fmov    d0, #-1.062500000000000000e+00\n- 96c:   f82f8075        swp     x15, x21, [x3]\n- 970:   f8380328        ldadd   x24, x8, [x25]\n- 974:   f8341230        ldclr   x20, x16, [x17]\n- 978:   f8222001        ldeor   x2, x1, [x0]\n- 97c:   f8383064        ldset   x24, x4, [x3]\n- 980:   f82c539f        stsmin  x12, [x28]\n- 984:   f82a405a        ldsmax  x10, x26, [x2]\n- 988:   f82c73f2        ldumin  x12, x18, [sp]\n- 98c:   f82163ad        ldumax  x1, x13, [x29]\n- 990:   f8a08193        swpa    x0, x19, [x12]\n- 994:   f8b101b6        ldadda  x17, x22, [x13]\n- 998:   f8bc13fe        ldclra  x28, x30, [sp]\n- 99c:   f8a1239a        ldeora  x1, x26, [x28]\n- 9a0:   f8a4309e        ldseta  x4, x30, [x4]\n- 9a4:   f8a6535e        ldsmina         x6, x30, [x26]\n- 9a8:   f8b24109        ldsmaxa         x18, x9, [x8]\n- 9ac:   f8ac7280        ldumina         x12, x0, [x20]\n- 9b0:   f8a16058        ldumaxa         x1, x24, [x2]\n- 9b4:   f8e08309        swpal   x0, x9, [x24]\n- 9b8:   f8fa03d0        ldaddal         x26, x16, [x30]\n- 9bc:   f8e312ea        ldclral         x3, x10, [x23]\n- 9c0:   f8ea2244        ldeoral         x10, x4, [x18]\n- 9c4:   f8e2310b        ldsetal         x2, x11, [x8]\n- 9c8:   f8ea522f        ldsminal        x10, x15, [x17]\n- 9cc:   f8e2418a        ldsmaxal        x2, x10, [x12]\n- 9d0:   f8ec71af        lduminal        x12, x15, [x13]\n- 9d4:   f8e26287        ldumaxal        x2, x7, [x20]\n- 9d8:   f87a8090        swpl    x26, x16, [x4]\n- 9dc:   f8620184        ldaddl  x2, x4, [x12]\n- 9e0:   f8721215        ldclrl  x18, x21, [x16]\n- 9e4:   f87222ab        ldeorl  x18, x11, [x21]\n- 9e8:   f877334c        ldsetl  x23, x12, [x26]\n- 9ec:   f87751dc        ldsminl         x23, x28, [x14]\n- 9f0:   f86b4038        ldsmaxl         x11, x24, [x1]\n- 9f4:   f86c715f        stuminl         x12, [x10]\n- 9f8:   f8706047        ldumaxl         x16, x7, [x2]\n- 9fc:   b823826d        swp     w3, w13, [x19]\n- a00:   b8310070        ldadd   w17, w16, [x3]\n- a04:   b82113cb        ldclr   w1, w11, [x30]\n- a08:   b82521e8        ldeor   w5, w8, [x15]\n- a0c:   b83d301e        ldset   w29, w30, [x0]\n- a10:   b8345287        ldsmin  w20, w7, [x20]\n- a14:   b83742bc        ldsmax  w23, w28, [x21]\n- a18:   b83b70b9        ldumin  w27, w25, [x5]\n- a1c:   b8216217        ldumax  w1, w23, [x16]\n- a20:   b8bf8185        swpa    wzr, w5, [x12]\n- a24:   b8a901fc        ldadda  w9, w28, [x15]\n- a28:   b8bd13f6        ldclra  w29, w22, [sp]\n- a2c:   b8b320bf        ldeora  w19, wzr, [x5]\n- a30:   b8ae33f2        ldseta  w14, w18, [sp]\n- a34:   b8b2529b        ldsmina         w18, w27, [x20]\n- a38:   b8b0416c        ldsmaxa         w16, w12, [x11]\n- a3c:   b8a973c6        ldumina         w9, w6, [x30]\n- a40:   b8b1639b        ldumaxa         w17, w27, [x28]\n- a44:   b8fe8147        swpal   w30, w7, [x10]\n- a48:   b8f4008a        ldaddal         w20, w10, [x4]\n- a4c:   b8f81231        ldclral         w24, w17, [x17]\n- a50:   b8f623a3        ldeoral         w22, w3, [x29]\n- a54:   b8ef3276        ldsetal         w15, w22, [x19]\n- a58:   b8f35056        ldsminal        w19, w22, [x2]\n- a5c:   b8ef4186        ldsmaxal        w15, w6, [x12]\n- a60:   b8f071ab        lduminal        w16, w11, [x13]\n- a64:   b8f763c1        ldumaxal        w23, w1, [x30]\n- a68:   b8738225        swpl    w19, w5, [x17]\n- a6c:   b86202d0        ldaddl  w2, w16, [x22]\n- a70:   b86d12aa        ldclrl  w13, w10, [x21]\n- a74:   b87d219b        ldeorl  w29, w27, [x12]\n- a78:   b87b3023        ldsetl  w27, w3, [x1]\n- a7c:   b87f5278        ldsminl         wzr, w24, [x19]\n- a80:   b8714389        ldsmaxl         w17, w9, [x28]\n- a84:   b87b70ef        lduminl         w27, w15, [x7]\n- a88:   b87563f7        ldumaxl         w21, w23, [sp]\n-\n@@ -1603,7 +1004,7 @@\n-    0x14000000,     0x17ffffd7,     0x14000279,     0x94000000,\n-    0x97ffffd4,     0x94000276,     0x3400000a,     0x34fffa2a,\n-    0x34004e6a,     0x35000008,     0x35fff9c8,     0x35004e08,\n-    0xb400000b,     0xb4fff96b,     0xb4004dab,     0xb500001d,\n-    0xb5fff91d,     0xb5004d5d,     0x10000013,     0x10fff8b3,\n-    0x10004cf3,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36304c76,     0x3758000c,     0x375ff7cc,     0x37584c0c,\n+    0x14000000,     0x17ffffd7,     0x140002c9,     0x94000000,\n+    0x97ffffd4,     0x940002c6,     0x3400000a,     0x34fffa2a,\n+    0x3400586a,     0x35000008,     0x35fff9c8,     0x35005808,\n+    0xb400000b,     0xb4fff96b,     0xb40057ab,     0xb500001d,\n+    0xb5fff91d,     0xb500575d,     0x10000013,     0x10fff8b3,\n+    0x100056f3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36305676,     0x3758000c,     0x375ff7cc,     0x3758560c,\n@@ -1614,13 +1015,13 @@\n-    0x540049e0,     0x54000001,     0x54fff541,     0x54004981,\n-    0x54000002,     0x54fff4e2,     0x54004922,     0x54000002,\n-    0x54fff482,     0x540048c2,     0x54000003,     0x54fff423,\n-    0x54004863,     0x54000003,     0x54fff3c3,     0x54004803,\n-    0x54000004,     0x54fff364,     0x540047a4,     0x54000005,\n-    0x54fff305,     0x54004745,     0x54000006,     0x54fff2a6,\n-    0x540046e6,     0x54000007,     0x54fff247,     0x54004687,\n-    0x54000008,     0x54fff1e8,     0x54004628,     0x54000009,\n-    0x54fff189,     0x540045c9,     0x5400000a,     0x54fff12a,\n-    0x5400456a,     0x5400000b,     0x54fff0cb,     0x5400450b,\n-    0x5400000c,     0x54fff06c,     0x540044ac,     0x5400000d,\n-    0x54fff00d,     0x5400444d,     0x5400000e,     0x54ffefae,\n-    0x540043ee,     0x5400000f,     0x54ffef4f,     0x5400438f,\n+    0x540053e0,     0x54000001,     0x54fff541,     0x54005381,\n+    0x54000002,     0x54fff4e2,     0x54005322,     0x54000002,\n+    0x54fff482,     0x540052c2,     0x54000003,     0x54fff423,\n+    0x54005263,     0x54000003,     0x54fff3c3,     0x54005203,\n+    0x54000004,     0x54fff364,     0x540051a4,     0x54000005,\n+    0x54fff305,     0x54005145,     0x54000006,     0x54fff2a6,\n+    0x540050e6,     0x54000007,     0x54fff247,     0x54005087,\n+    0x54000008,     0x54fff1e8,     0x54005028,     0x54000009,\n+    0x54fff189,     0x54004fc9,     0x5400000a,     0x54fff12a,\n+    0x54004f6a,     0x5400000b,     0x54fff0cb,     0x54004f0b,\n+    0x5400000c,     0x54fff06c,     0x54004eac,     0x5400000d,\n+    0x54fff00d,     0x54004e4d,     0x5400000e,     0x54ffefae,\n+    0x54004dee,     0x5400000f,     0x54ffef4f,     0x54004d8f,\n@@ -1658,1 +1059,1 @@\n-    0xbd1b1869,     0x580033db,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x58003ddb,     0x1800000b,     0xf8945060,\n@@ -1735,27 +1136,47 @@\n-    0x4e0a1fe1,     0x4e071fe1,     0x4cc0ac3f,     0x1e601000,\n-    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n-    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n-    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n-    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n-    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n-    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n-    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n-    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf82f8075,\n-    0xf8380328,     0xf8341230,     0xf8222001,     0xf8383064,\n-    0xf82c539f,     0xf82a405a,     0xf82c73f2,     0xf82163ad,\n-    0xf8a08193,     0xf8b101b6,     0xf8bc13fe,     0xf8a1239a,\n-    0xf8a4309e,     0xf8a6535e,     0xf8b24109,     0xf8ac7280,\n-    0xf8a16058,     0xf8e08309,     0xf8fa03d0,     0xf8e312ea,\n-    0xf8ea2244,     0xf8e2310b,     0xf8ea522f,     0xf8e2418a,\n-    0xf8ec71af,     0xf8e26287,     0xf87a8090,     0xf8620184,\n-    0xf8721215,     0xf87222ab,     0xf877334c,     0xf87751dc,\n-    0xf86b4038,     0xf86c715f,     0xf8706047,     0xb823826d,\n-    0xb8310070,     0xb82113cb,     0xb82521e8,     0xb83d301e,\n-    0xb8345287,     0xb83742bc,     0xb83b70b9,     0xb8216217,\n-    0xb8bf8185,     0xb8a901fc,     0xb8bd13f6,     0xb8b320bf,\n-    0xb8ae33f2,     0xb8b2529b,     0xb8b0416c,     0xb8a973c6,\n-    0xb8b1639b,     0xb8fe8147,     0xb8f4008a,     0xb8f81231,\n-    0xb8f623a3,     0xb8ef3276,     0xb8f35056,     0xb8ef4186,\n-    0xb8f071ab,     0xb8f763c1,     0xb8738225,     0xb86202d0,\n-    0xb86d12aa,     0xb87d219b,     0xb87b3023,     0xb87f5278,\n-    0xb8714389,     0xb87b70ef,     0xb87563f7,\n+    0x4e0a1fe1,     0x4e071fe1,     0x4cc0ac3f,     0x05a08020,\n+    0x04b0e3e0,     0x0470e7e1,     0x042f9c20,     0x043f9c35,\n+    0x047f9c20,     0x04ff9c20,     0x04299420,     0x04319160,\n+    0x0461943e,     0x04a19020,     0x042053ff,     0x047f5401,\n+    0x25208028,     0x2538cfe0,     0x2578d001,     0x25b8efe2,\n+    0x25f8f007,     0xa400a3e0,     0xa4a8a7ea,     0xa547a814,\n+    0xa4084ffe,     0xa55c53e0,     0xa5e1540b,     0xe400fbf6,\n+    0xe408ffff,     0xe547e400,     0xe4014be0,     0xe4a84fe0,\n+    0xe5f25000,     0x858043e0,     0x85a043ff,     0xe59f5d08,\n+    0x1e601000,     0x1e603000,     0x1e621000,     0x1e623000,\n+    0x1e641000,     0x1e643000,     0x1e661000,     0x1e663000,\n+    0x1e681000,     0x1e683000,     0x1e6a1000,     0x1e6a3000,\n+    0x1e6c1000,     0x1e6c3000,     0x1e6e1000,     0x1e6e3000,\n+    0x1e701000,     0x1e703000,     0x1e721000,     0x1e723000,\n+    0x1e741000,     0x1e743000,     0x1e761000,     0x1e763000,\n+    0x1e781000,     0x1e783000,     0x1e7a1000,     0x1e7a3000,\n+    0x1e7c1000,     0x1e7c3000,     0x1e7e1000,     0x1e7e3000,\n+    0xf82f8075,     0xf8380328,     0xf8341230,     0xf8222001,\n+    0xf8383064,     0xf82c539f,     0xf82a405a,     0xf82c73f2,\n+    0xf82163ad,     0xf8a08193,     0xf8b101b6,     0xf8bc13fe,\n+    0xf8a1239a,     0xf8a4309e,     0xf8a6535e,     0xf8b24109,\n+    0xf8ac7280,     0xf8a16058,     0xf8e08309,     0xf8fa03d0,\n+    0xf8e312ea,     0xf8ea2244,     0xf8e2310b,     0xf8ea522f,\n+    0xf8e2418a,     0xf8ec71af,     0xf8e26287,     0xf87a8090,\n+    0xf8620184,     0xf8721215,     0xf87222ab,     0xf877334c,\n+    0xf87751dc,     0xf86b4038,     0xf86c715f,     0xf8706047,\n+    0xb823826d,     0xb8310070,     0xb82113cb,     0xb82521e8,\n+    0xb83d301e,     0xb8345287,     0xb83742bc,     0xb83b70b9,\n+    0xb8216217,     0xb8bf8185,     0xb8a901fc,     0xb8bd13f6,\n+    0xb8b320bf,     0xb8ae33f2,     0xb8b2529b,     0xb8b0416c,\n+    0xb8a973c6,     0xb8b1639b,     0xb8fe8147,     0xb8f4008a,\n+    0xb8f81231,     0xb8f623a3,     0xb8ef3276,     0xb8f35056,\n+    0xb8ef4186,     0xb8f071ab,     0xb8f763c1,     0xb8738225,\n+    0xb86202d0,     0xb86d12aa,     0xb87d219b,     0xb87b3023,\n+    0xb87f5278,     0xb8714389,     0xb87b70ef,     0xb87563f7,\n+    0x04fe0058,     0x04b60552,     0x65c00222,     0x65c20ad9,\n+    0x65db046c,     0x0416b35c,     0x04001e49,     0x045085e4,\n+    0x04daa856,     0x04d39cb4,     0x041191c0,     0x04900b79,\n+    0x0497bb1a,     0x049ea4c0,     0x040805e0,     0x044a04a9,\n+    0x0481069b,     0x049ca554,     0x65c09cd0,     0x65cd8fa2,\n+    0x65c69ac2,     0x65c78f6e,     0x65828457,     0x04ddb14a,\n+    0x65c2ac76,     0x65c0a430,     0x6581b190,     0x658da20c,\n+    0x658194b4,     0x65fb1187,     0x65bc2450,     0x65b34624,\n+    0x65f8750c,     0x04174152,     0x04107db3,     0x042e30e0,\n+    0x04aa3119,     0x047b32d4,     0x049a2e43,     0x04182787,\n+    0x04992a00,     0x044825f6,     0x040a2b36,     0x65c731be,\n+    0x658621ab,     0x65983334,     0x04412624,\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":177,"deletions":756,"binary":false,"changes":933,"status":"modified"},{"patch":"@@ -142,0 +142,3 @@\n+\/\/ Preserved predicate register with all elements set TRUE.\n+REGISTER_DECLARATION(PRegister, ptrue, p7);\n+\n@@ -276,0 +279,8 @@\n+  void prf(PRegister r, int lsb) {\n+    f(r->encoding_nocheck(), lsb + 3, lsb);\n+  }\n+\n+  void pgrf(PRegister r, int lsb) {\n+    f(r->encoding_nocheck(), lsb + 2, lsb);\n+  }\n+\n@@ -564,0 +575,12 @@\n+\n+  static bool offset_ok_for_sve_immed(long offset, int shift, int vl \/* sve vector length *\/) {\n+    if (offset % vl == 0) {\n+      \/\/ Convert address offset into sve imm offset (MUL VL).\n+      int sve_offset = offset \/ vl;\n+      if (((-(1 << (shift - 1))) <= sve_offset) && (sve_offset < (1 << (shift - 1)))) {\n+        \/\/ sve_offset can be encoded\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n@@ -687,0 +710,6 @@\n+  void prf(PRegister reg, int lsb) {\n+    current->prf(reg, lsb);\n+  }\n+  void pgrf(PRegister reg, int lsb) {\n+    current->pgrf(reg, lsb);\n+  }\n@@ -2107,0 +2136,15 @@\n+\/\/ Floating-point compare. 3-registers versions (scalar).\n+#define INSN(NAME, sz, e)                                             \\\n+  void NAME(FloatRegister Vd, FloatRegister Vn, FloatRegister Vm) {   \\\n+    starti;                                                           \\\n+    f(0b01111110, 31, 24), f(e, 23), f(sz, 22), f(1, 21), rf(Vm, 16); \\\n+    f(0b111011, 15, 10), rf(Vn, 5), rf(Vd, 0);                        \\\n+  }                                                                   \\\n+\n+  INSN(facged, 1, 0); \/\/ facge-double\n+  INSN(facges, 0, 0); \/\/ facge-single\n+  INSN(facgtd, 1, 1); \/\/ facgt-double\n+  INSN(facgts, 0, 1); \/\/ facgt-single\n+\n+#undef INSN\n+\n@@ -2557,12 +2601,6 @@\n-  void umov(Register Rd, FloatRegister Vn, SIMD_RegVariant T, int idx) {\n-    starti;\n-    f(0, 31), f(T==D ? 1:0, 30), f(0b001110000, 29, 21);\n-    f(((idx<<1)|1)<<(int)T, 20, 16), f(0b001111, 15, 10);\n-    rf(Vn, 5), rf(Rd, 0);\n-  }\n-\n-  void smov(Register Rd, FloatRegister Vn, SIMD_RegVariant T, int idx) {\n-    starti;\n-    f(0, 31), f(T==D ? 1:0, 30), f(0b001110000, 29, 21);\n-    f(((idx<<1)|1)<<(int)T, 20, 16), f(0b001011, 15, 10);\n-    rf(Vn, 5), rf(Rd, 0);\n+#define INSN(NAME, op)                                                     \\\n+  void NAME(Register Rd, FloatRegister Vn, SIMD_RegVariant T, int idx) {   \\\n+    starti;                                                                \\\n+    f(0, 31), f(T==D ? 1:0, 30), f(0b001110000, 29, 21);                   \\\n+    f(((idx<<1)|1)<<(int)T, 20, 16), f(op, 15, 10);                        \\\n+    rf(Vn, 5), rf(Rd, 0);                                                  \\\n@@ -2571,0 +2609,3 @@\n+  INSN(umov, 0b001111);\n+  INSN(smov, 0b001011);\n+#undef INSN\n@@ -2601,0 +2642,14 @@\n+#define INSN(NAME, opc, opc2, isSHR)                                    \\\n+  void NAME(FloatRegister Vd, FloatRegister Vn, int shift){             \\\n+    starti;                                                             \\\n+    int encodedShift = isSHR ? 128 - shift : 64 + shift;                \\\n+    f(0b01, 31, 30), f(opc, 29), f(0b111110, 28, 23),                   \\\n+    f(encodedShift, 22, 16); f(opc2, 15, 10), rf(Vn, 5), rf(Vd, 0);     \\\n+  }\n+\n+  INSN(shld,  0, 0b010101, \/* isSHR = *\/ false);\n+  INSN(sshrd, 0, 0b000001, \/* isSHR = *\/ true);\n+  INSN(ushrd, 1, 0b000001, \/* isSHR = *\/ true);\n+\n+#undef INSN\n+\n@@ -2817,1 +2872,1 @@\n-void ext(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm, int index)\n+  void ext(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, FloatRegister Vm, int index)\n@@ -2827,0 +2882,286 @@\n+\/\/ SVE arithmetics - unpredicated\n+#define INSN(NAME, opcode)                                                             \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) { \\\n+    starti;                                                                            \\\n+    assert(T != Q, \"invalid register variant\");                                        \\\n+    f(0b00000100, 31, 24), f(T, 23, 22), f(1, 21),                                     \\\n+    rf(Zm, 16), f(0, 15, 13), f(opcode, 12, 10), rf(Zn, 5), rf(Zd, 0);                 \\\n+  }\n+  INSN(sve_add, 0b000);\n+  INSN(sve_sub, 0b001);\n+#undef INSN\n+\n+\/\/ SVE floating-point arithmetic - unpredicated\n+#define INSN(NAME, opcode)                                                             \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) { \\\n+    starti;                                                                            \\\n+    assert(T == S || T == D, \"invalid register variant\");                              \\\n+    f(0b01100101, 31, 24), f(T, 23, 22), f(0, 21),                                     \\\n+    rf(Zm, 16), f(0, 15, 13), f(opcode, 12, 10), rf(Zn, 5), rf(Zd, 0);                 \\\n+  }\n+\n+  INSN(sve_fadd, 0b000);\n+  INSN(sve_fmul, 0b010);\n+  INSN(sve_fsub, 0b001);\n+#undef INSN\n+\n+private:\n+  void sve_predicate_reg_insn(unsigned op24, unsigned op13,\n+                              FloatRegister Zd_or_Vd, SIMD_RegVariant T,\n+                              PRegister Pg, FloatRegister Zn_or_Vn) {\n+    starti;\n+    f(op24, 31, 24), f(T, 23, 22), f(op13, 21, 13);\n+    pgrf(Pg, 10), rf(Zn_or_Vn, 5), rf(Zd_or_Vd, 0);\n+  }\n+\n+public:\n+\n+\/\/ SVE integer arithmetics - predicate\n+#define INSN(NAME, op1, op2)                                                                            \\\n+  void NAME(FloatRegister Zdn_or_Zd_or_Vd, SIMD_RegVariant T, PRegister Pg, FloatRegister Znm_or_Vn) {  \\\n+    assert(T != Q, \"invalid register variant\");                                                         \\\n+    sve_predicate_reg_insn(op1, op2, Zdn_or_Zd_or_Vd, T, Pg, Znm_or_Vn);                                \\\n+  }\n+\n+  INSN(sve_abs,  0b00000100, 0b010110101); \/\/ vector abs, unary\n+  INSN(sve_add,  0b00000100, 0b000000000); \/\/ vector add\n+  INSN(sve_andv, 0b00000100, 0b011010001); \/\/ bitwise and reduction to scalar\n+  INSN(sve_asr,  0b00000100, 0b010000100); \/\/ vector arithmetic shift right\n+  INSN(sve_cnt,  0b00000100, 0b011010101)  \/\/ count non-zero bits\n+  INSN(sve_cpy,  0b00000101, 0b100000100); \/\/ copy scalar to each active vector element\n+  INSN(sve_eorv, 0b00000100, 0b011001001); \/\/ bitwise xor reduction to scalar\n+  INSN(sve_lsl,  0b00000100, 0b010011100); \/\/ vector logical shift left\n+  INSN(sve_lsr,  0b00000100, 0b010001100); \/\/ vector logical shift right\n+  INSN(sve_mul,  0b00000100, 0b010000000); \/\/ vector mul\n+  INSN(sve_neg,  0b00000100, 0b010111101); \/\/ vector neg, unary\n+  INSN(sve_not,  0b00000100, 0b011110101); \/\/ bitwise invert vector, unary\n+  INSN(sve_orv,  0b00000100, 0b011000001); \/\/ bitwise or reduction to scalar\n+  INSN(sve_smax, 0b00000100, 0b001000000); \/\/ signed maximum vectors\n+  INSN(sve_smaxv, 0b00000100, 0b001000001); \/\/ signed maximum reduction to scalar\n+  INSN(sve_smin,  0b00000100, 0b001010000); \/\/ signed minimum vectors\n+  INSN(sve_sminv, 0b00000100, 0b001010001); \/\/ signed minimum reduction to scalar\n+  INSN(sve_sub,   0b00000100, 0b000001000); \/\/ vector sub\n+  INSN(sve_uaddv, 0b00000100, 0b000001001); \/\/ unsigned add reduction to scalar\n+#undef INSN\n+\n+\/\/ SVE floating-point arithmetics - predicate\n+#define INSN(NAME, op1, op2)                                                                          \\\n+  void NAME(FloatRegister Zd_or_Zdn_or_Vd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn_or_Zm) { \\\n+    assert(T == S || T == D, \"invalid register variant\");                                             \\\n+    sve_predicate_reg_insn(op1, op2, Zd_or_Zdn_or_Vd, T, Pg, Zn_or_Zm);                               \\\n+  }\n+\n+  INSN(sve_fabs,    0b00000100, 0b011100101);\n+  INSN(sve_fadd,    0b01100101, 0b000000100);\n+  INSN(sve_fadda,   0b01100101, 0b011000001); \/\/ add strictly-ordered reduction to scalar Vd\n+  INSN(sve_fdiv,    0b01100101, 0b001101100);\n+  INSN(sve_fmax,    0b01100101, 0b000110100); \/\/ floating-point maximum\n+  INSN(sve_fmaxv,   0b01100101, 0b000110001); \/\/ floating-point maximum recursive reduction to scalar\n+  INSN(sve_fmin,    0b01100101, 0b000111100); \/\/ floating-point minimum\n+  INSN(sve_fminv,   0b01100101, 0b000111001); \/\/ floating-point minimum recursive reduction to scalar\n+  INSN(sve_fmul,    0b01100101, 0b000010100);\n+  INSN(sve_fneg,    0b00000100, 0b011101101);\n+  INSN(sve_frintm,  0b01100101, 0b000010101); \/\/ floating-point round to integral value, toward minus infinity\n+  INSN(sve_frintn,  0b01100101, 0b000000101); \/\/ floating-point round to integral value, nearest with ties to even\n+  INSN(sve_frintp,  0b01100101, 0b000001101); \/\/ floating-point round to integral value, toward plus infinity\n+  INSN(sve_fsqrt,   0b01100101, 0b001101101);\n+  INSN(sve_fsub,    0b01100101, 0b000001100);\n+#undef INSN\n+\n+  \/\/ SVE multiple-add\/sub - predicated\n+#define INSN(NAME, op0, op1, op2)                                                                     \\\n+  void NAME(FloatRegister Zda, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, FloatRegister Zm) { \\\n+    starti;                                                                                           \\\n+    assert(T != Q, \"invalid size\");                                                                   \\\n+    f(op0, 31, 24), f(T, 23, 22), f(op1, 21), rf(Zm, 16);                                             \\\n+    f(op2, 15, 13), pgrf(Pg, 10), rf(Zn, 5), rf(Zda, 0);                                              \\\n+  }\n+\n+  INSN(sve_fmla,  0b01100101, 1, 0b000); \/\/ floating-point fused multiply-add: Zda = Zda + Zn * Zm\n+  INSN(sve_fmls,  0b01100101, 1, 0b001); \/\/ floating-point fused multiply-subtract: Zda = Zda + -Zn * Zm\n+  INSN(sve_fnmla, 0b01100101, 1, 0b010); \/\/ floating-point negated fused multiply-add: Zda = -Zda + -Zn * Zm\n+  INSN(sve_fnmls, 0b01100101, 1, 0b011); \/\/ floating-point negated fused multiply-subtract: Zda = -Zda + Zn * Zm\n+  INSN(sve_mla,   0b00000100, 0, 0b010); \/\/ multiply-add: Zda = Zda + Zn*Zm\n+  INSN(sve_mls,   0b00000100, 0, 0b011); \/\/ multiply-subtract: Zda = Zda + -Zn*Zm\n+#undef INSN\n+\n+\/\/ SVE bitwise logical - unpredicated\n+#define INSN(NAME, opc)                                              \\\n+  void NAME(FloatRegister Zd, FloatRegister Zn, FloatRegister Zm) {  \\\n+    starti;                                                          \\\n+    f(0b00000100, 31, 24), f(opc, 23, 22), f(1, 21),                 \\\n+    rf(Zm, 16), f(0b001100, 15, 10), rf(Zn, 5), rf(Zd, 0);           \\\n+  }\n+  INSN(sve_and, 0b00);\n+  INSN(sve_eor, 0b10);\n+  INSN(sve_orr, 0b01);\n+#undef INSN\n+\n+\/\/ SVE shift immediate - unpredicated\n+#define INSN(NAME, opc, isSHR)                                                  \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, int shift) { \\\n+    starti;                                                                     \\\n+    \/* The encodings for the tszh:tszl:imm3 fields (bits 23:22 20:19 18:16)     \\\n+     * for shift right is calculated as:                                        \\\n+     *   0001 xxx       B, shift = 16  - UInt(tszh:tszl:imm3)                   \\\n+     *   001x xxx       H, shift = 32  - UInt(tszh:tszl:imm3)                   \\\n+     *   01xx xxx       S, shift = 64  - UInt(tszh:tszl:imm3)                   \\\n+     *   1xxx xxx       D, shift = 128 - UInt(tszh:tszl:imm3)                   \\\n+     * for shift left is calculated as:                                         \\\n+     *   0001 xxx       B, shift = UInt(tszh:tszl:imm3) - 8                     \\\n+     *   001x xxx       H, shift = UInt(tszh:tszl:imm3) - 16                    \\\n+     *   01xx xxx       S, shift = UInt(tszh:tszl:imm3) - 32                    \\\n+     *   1xxx xxx       D, shift = UInt(tszh:tszl:imm3) - 64                    \\\n+     *\/                                                                         \\\n+    assert(T != Q, \"Invalid register variant\");                                 \\\n+    if (isSHR) {                                                                \\\n+      assert(((1 << (T + 3)) >= shift) && (shift > 0) , \"Invalid shift value\"); \\\n+    } else {                                                                    \\\n+      assert(((1 << (T + 3)) > shift) && (shift >= 0) , \"Invalid shift value\"); \\\n+    }                                                                           \\\n+    int cVal = (1 << ((T + 3) + (isSHR ? 1 : 0)));                              \\\n+    int encodedShift = isSHR ? cVal - shift : cVal + shift;                     \\\n+    int tszh = encodedShift >> 5;                                               \\\n+    int tszl_imm = encodedShift & 0x1f;                                         \\\n+    f(0b00000100, 31, 24);                                                      \\\n+    f(tszh, 23, 22), f(1,21), f(tszl_imm, 20, 16);                              \\\n+    f(0b100, 15, 13), f(opc, 12, 10), rf(Zn, 5), rf(Zd, 0);                     \\\n+  }\n+\n+  INSN(sve_asr, 0b100, \/* isSHR = *\/ true);\n+  INSN(sve_lsl, 0b111, \/* isSHR = *\/ false);\n+  INSN(sve_lsr, 0b101, \/* isSHR = *\/ true);\n+#undef INSN\n+\n+private:\n+\n+  \/\/ Scalar base + immediate index\n+  void sve_ld_st1(FloatRegister Zt, Register Xn, int imm, PRegister Pg,\n+              SIMD_RegVariant T, int op1, int type, int op2) {\n+    starti;\n+    assert_cond(T >= type);\n+    f(op1, 31, 25), f(type, 24, 23), f(T, 22, 21);\n+    f(0, 20), sf(imm, 19, 16), f(op2, 15, 13);\n+    pgrf(Pg, 10), srf(Xn, 5), rf(Zt, 0);\n+  }\n+\n+  \/\/ Scalar base + scalar index\n+  void sve_ld_st1(FloatRegister Zt, Register Xn, Register Xm, PRegister Pg,\n+              SIMD_RegVariant T, int op1, int type, int op2) {\n+    starti;\n+    assert_cond(T >= type);\n+    f(op1, 31, 25), f(type, 24, 23), f(T, 22, 21);\n+    rf(Xm, 16), f(op2, 15, 13);\n+    pgrf(Pg, 10), srf(Xn, 5), rf(Zt, 0);\n+  }\n+\n+  void sve_ld_st1(FloatRegister Zt, PRegister Pg,\n+              SIMD_RegVariant T, const Address &a,\n+              int op1, int type, int imm_op2, int scalar_op2) {\n+    switch (a.getMode()) {\n+    case Address::base_plus_offset:\n+      sve_ld_st1(Zt, a.base(), a.offset(), Pg, T, op1, type, imm_op2);\n+      break;\n+    case Address::base_plus_offset_reg:\n+      sve_ld_st1(Zt, a.base(), a.index(), Pg, T, op1, type, scalar_op2);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+public:\n+\n+\/\/ SVE load\/store - predicated\n+#define INSN(NAME, op1, type, imm_op2, scalar_op2)                                   \\\n+  void NAME(FloatRegister Zt, SIMD_RegVariant T, PRegister Pg, const Address &a) {   \\\n+    assert(T != Q, \"invalid register variant\");                                      \\\n+    sve_ld_st1(Zt, Pg, T, a, op1, type, imm_op2, scalar_op2);                        \\\n+  }\n+\n+  INSN(sve_ld1b, 0b1010010, 0b00, 0b101, 0b010);\n+  INSN(sve_st1b, 0b1110010, 0b00, 0b111, 0b010);\n+  INSN(sve_ld1h, 0b1010010, 0b01, 0b101, 0b010);\n+  INSN(sve_st1h, 0b1110010, 0b01, 0b111, 0b010);\n+  INSN(sve_ld1w, 0b1010010, 0b10, 0b101, 0b010);\n+  INSN(sve_st1w, 0b1110010, 0b10, 0b111, 0b010);\n+  INSN(sve_ld1d, 0b1010010, 0b11, 0b101, 0b010);\n+  INSN(sve_st1d, 0b1110010, 0b11, 0b111, 0b010);\n+#undef INSN\n+\n+\/\/ SVE load\/store - unpredicated\n+#define INSN(NAME, op1)                                                         \\\n+  void NAME(FloatRegister Zt, const Address &a)  {                              \\\n+    starti;                                                                     \\\n+    assert(a.index() == noreg, \"invalid address variant\");                      \\\n+    f(op1, 31, 29), f(0b0010110, 28, 22), sf(a.offset() >> 3, 21, 16),          \\\n+    f(0b010, 15, 13), f(a.offset() & 0x7, 12, 10), srf(a.base(), 5), rf(Zt, 0); \\\n+  }\n+\n+  INSN(sve_ldr, 0b100); \/\/ LDR (vector)\n+  INSN(sve_str, 0b111); \/\/ STR (vector)\n+#undef INSN\n+\n+#define INSN(NAME, op) \\\n+  void NAME(Register Xd, Register Xn, int imm6) {                 \\\n+    starti;                                                       \\\n+    f(0b000001000, 31, 23), f(op, 22, 21);                        \\\n+    srf(Xn, 16), f(0b01010, 15, 11), sf(imm6, 10, 5), srf(Xd, 0); \\\n+  }\n+\n+  INSN(sve_addvl, 0b01);\n+  INSN(sve_addpl, 0b11);\n+#undef INSN\n+\n+\/\/ SVE inc\/dec register by element count\n+#define INSN(NAME, op) \\\n+  void NAME(Register Xdn, SIMD_RegVariant T, unsigned imm4 = 1, int pattern = 0b11111) { \\\n+    starti;                                                                              \\\n+    assert(T != Q, \"invalid size\");                                                      \\\n+    f(0b00000100,31, 24), f(T, 23, 22), f(0b11, 21, 20);                                 \\\n+    f(imm4 - 1, 19, 16), f(0b11100, 15, 11), f(op, 10), f(pattern, 9, 5), rf(Xdn, 0);    \\\n+  }\n+\n+  INSN(sve_inc, 0);\n+  INSN(sve_dec, 1);\n+#undef INSN\n+\n+  \/\/ SVE predicate count\n+  void sve_cntp(Register Xd, SIMD_RegVariant T, PRegister Pg, PRegister Pn) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b10000010, 21, 14);\n+    prf(Pg, 10), f(0, 9), prf(Pn, 5), rf(Xd, 0);\n+  }\n+\n+  \/\/ SVE dup scalar\n+  void sve_dup(FloatRegister Zd, SIMD_RegVariant T, Register Rn) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b100000001110, 21, 10);\n+    srf(Rn, 5), rf(Zd, 0);\n+  }\n+\n+  \/\/ SVE dup imm\n+  void sve_dup(FloatRegister Zd, SIMD_RegVariant T, int imm8) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    int sh = 0;\n+    if (imm8 <= 127 && imm8 >= -128) {\n+      sh = 0;\n+    } else if (T != B && imm8 <= 32512 && imm8 >= -32768 && (imm8 & 0xff) == 0) {\n+      sh = 1;\n+      imm8 = (imm8 >> 8);\n+    } else {\n+      guarantee(false, \"invalid immediate\");\n+    }\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b11100011, 21, 14);\n+    f(sh, 13), sf(imm8, 12, 5), rf(Zd, 0);\n+  }\n+\n+  void sve_ptrue(PRegister pd, SIMD_RegVariant esize, int pattern = 0b11111) {\n+    starti;\n+    f(0b00100101, 31, 24), f(esize, 23, 22), f(0b011000111000, 21, 10);\n+    f(pattern, 9, 5), f(0b0, 4), prf(pd, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":354,"deletions":13,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -434,0 +434,5 @@\n+    if (UseSVE > 0) {\n+      \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+      \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+      __ reinitialize_ptrue();\n+    }\n@@ -435,1 +440,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,0 +102,3 @@\n+  product(uint, UseSVE, 0,                                              \\\n+          \"Highest supported SVE instruction set version\")              \\\n+          range(0, 2)                                                   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2120,1 +2120,1 @@\n-\/\/ Return the number of words pushed\n+\/\/ Return the number of dwords pushed\n@@ -2123,0 +2123,7 @@\n+  bool use_sve = false;\n+  int sve_vector_size_in_bytes = 0;\n+\n+#ifdef COMPILER2\n+  use_sve = Matcher::supports_scalable_vector();\n+  sve_vector_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);\n+#endif\n@@ -2137,0 +2144,10 @@\n+  \/\/ SVE\n+  if (use_sve && sve_vector_size_in_bytes > 16) {\n+    sub(stack, stack, sve_vector_size_in_bytes * count);\n+    for (int i = 0; i < count; i++) {\n+      sve_str(as_FloatRegister(regs[i]), Address(stack, i));\n+    }\n+    return count * sve_vector_size_in_bytes \/ 8;\n+  }\n+\n+  \/\/ NEON\n@@ -2139,1 +2156,1 @@\n-    return 1;\n+    return 2;\n@@ -2160,1 +2177,1 @@\n-  return count;\n+  return count * 2;\n@@ -2163,0 +2180,1 @@\n+\/\/ Return the number of dwords poped\n@@ -2165,0 +2183,2 @@\n+  bool use_sve = false;\n+  int sve_vector_size_in_bytes = 0;\n@@ -2166,0 +2186,4 @@\n+#ifdef COMPILER2\n+  use_sve = Matcher::supports_scalable_vector();\n+  sve_vector_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);\n+#endif\n@@ -2179,0 +2203,10 @@\n+  \/\/ SVE\n+  if (use_sve && sve_vector_size_in_bytes > 16) {\n+    for (int i = count - 1; i >= 0; i--) {\n+      sve_ldr(as_FloatRegister(regs[i]), Address(stack, i));\n+    }\n+    add(stack, stack, sve_vector_size_in_bytes * count);\n+    return count * sve_vector_size_in_bytes \/ 8;\n+  }\n+\n+  \/\/ NEON\n@@ -2181,1 +2215,1 @@\n-    return 1;\n+    return 2;\n@@ -2202,1 +2236,1 @@\n-  return count;\n+  return count * 2;\n@@ -2650,2 +2684,2 @@\n-void MacroAssembler::push_CPU_state(bool save_vectors) {\n-  int step = (save_vectors ? 8 : 4) * wordSize;\n+void MacroAssembler::push_CPU_state(bool save_vectors, bool use_sve,\n+                                    int sve_vector_size_in_bytes) {\n@@ -2653,5 +2687,14 @@\n-  mov(rscratch1, -step);\n-  sub(sp, sp, step);\n-  for (int i = 28; i >= 4; i -= 4) {\n-    st1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n-        as_FloatRegister(i+3), save_vectors ? T2D : T1D, Address(post(sp, rscratch1)));\n+  if (save_vectors && use_sve && sve_vector_size_in_bytes > 16) {\n+    sub(sp, sp, sve_vector_size_in_bytes * FloatRegisterImpl::number_of_registers);\n+    for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+      sve_str(as_FloatRegister(i), Address(sp, i));\n+    }\n+  } else {\n+    int step = (save_vectors ? 8 : 4) * wordSize;\n+    mov(rscratch1, -step);\n+    sub(sp, sp, step);\n+    for (int i = 28; i >= 4; i -= 4) {\n+      st1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n+          as_FloatRegister(i+3), save_vectors ? T2D : T1D, Address(post(sp, rscratch1)));\n+    }\n+    st1(v0, v1, v2, v3, save_vectors ? T2D : T1D, sp);\n@@ -2659,1 +2702,0 @@\n-  st1(v0, v1, v2, v3, save_vectors ? T2D : T1D, sp);\n@@ -2662,5 +2704,13 @@\n-void MacroAssembler::pop_CPU_state(bool restore_vectors) {\n-  int step = (restore_vectors ? 8 : 4) * wordSize;\n-  for (int i = 0; i <= 28; i += 4)\n-    ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n-        as_FloatRegister(i+3), restore_vectors ? T2D : T1D, Address(post(sp, step)));\n+void MacroAssembler::pop_CPU_state(bool restore_vectors, bool use_sve,\n+                                   int sve_vector_size_in_bytes) {\n+  if (restore_vectors && use_sve && sve_vector_size_in_bytes > 16) {\n+    for (int i = FloatRegisterImpl::number_of_registers - 1; i >= 0; i--) {\n+      sve_ldr(as_FloatRegister(i), Address(sp, i));\n+    }\n+    add(sp, sp, sve_vector_size_in_bytes * FloatRegisterImpl::number_of_registers);\n+  } else {\n+    int step = (restore_vectors ? 8 : 4) * wordSize;\n+    for (int i = 0; i <= 28; i += 4)\n+      ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n+          as_FloatRegister(i+3), restore_vectors ? T2D : T1D, Address(post(sp, step)));\n+  }\n@@ -2715,0 +2765,15 @@\n+Address MacroAssembler::sve_spill_address(int sve_reg_size_in_bytes, int offset, Register tmp) {\n+  assert(offset >= 0, \"spill to negative address?\");\n+\n+  Register base = sp;\n+\n+  \/\/ An immediate offset in the range 0 to 255 which is multiplied\n+  \/\/ by the current vector or predicate register size in bytes.\n+  if (offset % sve_reg_size_in_bytes == 0 && offset < ((1<<8)*sve_reg_size_in_bytes)) {\n+    return Address(base, offset \/ sve_reg_size_in_bytes);\n+  }\n+\n+  add(tmp, base, offset);\n+  return Address(tmp);\n+}\n+\n@@ -5224,0 +5289,21 @@\n+\n+void MacroAssembler::verify_sve_vector_length() {\n+  Label verify_ok;\n+  assert(UseSVE > 0, \"should only be used for SVE\");\n+  movw(rscratch1, zr);\n+  sve_inc(rscratch1, B);\n+  subsw(zr, rscratch1, VM_Version::get_initial_sve_vector_length());\n+  br(EQ, verify_ok);\n+  stop(\"Error: SVE vector length has changed since jvm startup\");\n+  bind(verify_ok);\n+}\n+\n+void MacroAssembler::verify_ptrue() {\n+  Label verify_ok;\n+  assert(UseSVE > 0, \"should only be used for SVE\");\n+  sve_cntp(rscratch1, B, ptrue, ptrue); \/\/ get true elements count.\n+  sve_dec(rscratch1, B);\n+  cbz(rscratch1, verify_ok);\n+  stop(\"Error: the preserved predicate register (p7) elements are not all true\");\n+  bind(verify_ok);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":104,"deletions":18,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -876,2 +876,4 @@\n-  void push_CPU_state(bool save_vectors = false);\n-  void pop_CPU_state(bool restore_vectors = false) ;\n+  void push_CPU_state(bool save_vectors = false, bool use_sve = false,\n+                      int sve_vector_size_in_bytes = 0);\n+  void pop_CPU_state(bool restore_vectors = false, bool use_sve = false,\n+                      int sve_vector_size_in_bytes = 0);\n@@ -957,0 +959,5 @@\n+  void verify_sve_vector_length();\n+  void reinitialize_ptrue() {\n+    sve_ptrue(ptrue, B);\n+  }\n+  void verify_ptrue();\n@@ -1306,0 +1313,1 @@\n+  Address sve_spill_address(int sve_reg_size_in_bytes, int offset, Register tmp=rscratch2);\n@@ -1329,0 +1337,3 @@\n+  void spill_sve_vector(FloatRegister Zx, int offset, int vector_reg_size_in_bytes) {\n+    sve_str(Zx, sve_spill_address(vector_reg_size_in_bytes, offset));\n+  }\n@@ -1339,0 +1350,3 @@\n+  void unspill_sve_vector(FloatRegister Zx, int offset, int vector_reg_size_in_bytes) {\n+    sve_ldr(Zx, sve_spill_address(vector_reg_size_in_bytes, offset));\n+  }\n@@ -1352,1 +1366,9 @@\n-\n+  void spill_copy_sve_vector_stack_to_stack(int src_offset, int dst_offset,\n+                                            int sve_vec_reg_size_in_bytes) {\n+    assert(sve_vec_reg_size_in_bytes % 16 == 0, \"unexpected sve vector reg size\");\n+    for (int i = 0; i < sve_vec_reg_size_in_bytes \/ 16; i++) {\n+      spill_copy128(src_offset, dst_offset);\n+      src_offset += 16;\n+      dst_offset += 16;\n+    }\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2010, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.\n@@ -36,0 +36,3 @@\n+const int ConcreteRegisterImpl::max_pr\n+  = ConcreteRegisterImpl::max_fpr + PRegisterImpl::number_of_registers;\n+\n@@ -57,0 +60,8 @@\n+\n+const char* PRegisterImpl::name() const {\n+  const char* names[number_of_registers] = {\n+    \"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\",\n+    \"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\"\n+  };\n+  return is_valid() ? names[encoding()] : \"noreg\";\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,1 @@\n-    max_slots_per_register = 4,\n+    max_slots_per_register = 8,\n@@ -134,1 +134,2 @@\n-    extra_save_slots_per_register = max_slots_per_register - save_slots_per_register\n+    slots_per_neon_register = 4,\n+    extra_save_slots_per_neon_register = slots_per_neon_register - save_slots_per_register\n@@ -190,0 +191,82 @@\n+\/\/ SVE vector registers, shared with the SIMD&FP v0-v31. Vn maps to Zn[127:0].\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z0     , ( 0));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z1     , ( 1));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z2     , ( 2));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z3     , ( 3));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z4     , ( 4));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z5     , ( 5));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z6     , ( 6));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z7     , ( 7));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z8     , ( 8));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z9     , ( 9));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z10    , (10));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z11    , (11));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z12    , (12));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z13    , (13));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z14    , (14));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z15    , (15));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z16    , (16));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z17    , (17));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z18    , (18));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z19    , (19));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z20    , (20));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z21    , (21));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z22    , (22));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z23    , (23));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z24    , (24));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z25    , (25));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z26    , (26));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z27    , (27));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z28    , (28));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z29    , (29));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z30    , (30));\n+CONSTANT_REGISTER_DECLARATION(FloatRegister, z31    , (31));\n+\n+\n+class PRegisterImpl;\n+typedef PRegisterImpl* PRegister;\n+inline PRegister as_PRegister(int encoding) {\n+  return (PRegister)(intptr_t)encoding;\n+}\n+\n+\/\/ The implementation of predicate registers for the architecture\n+class PRegisterImpl: public AbstractRegisterImpl {\n+ public:\n+  enum {\n+    number_of_registers = 16,\n+    max_slots_per_register = 1\n+  };\n+\n+  \/\/ construction\n+  inline friend PRegister as_PRegister(int encoding);\n+\n+  VMReg as_VMReg();\n+\n+  \/\/ derived registers, offsets, and addresses\n+  PRegister successor() const     { return as_PRegister(encoding() + 1); }\n+\n+  \/\/ accessors\n+  int   encoding() const          { assert(is_valid(), \"invalid register\"); return (intptr_t)this; }\n+  int   encoding_nocheck() const  { return (intptr_t)this; }\n+  bool  is_valid() const          { return 0 <= (intptr_t)this && (intptr_t)this < number_of_registers; }\n+  const char* name() const;\n+};\n+\n+\/\/ The predicate registers of SVE.\n+CONSTANT_REGISTER_DECLARATION(PRegister, p0,  ( 0));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p1,  ( 1));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p2,  ( 2));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p3,  ( 3));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p4,  ( 4));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p5,  ( 5));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p6,  ( 6));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p7,  ( 7));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p8,  ( 8));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p9,  ( 9));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p10, (10));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p11, (11));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p12, (12));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p13, (13));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p14, (14));\n+CONSTANT_REGISTER_DECLARATION(PRegister, p15, (15));\n+\n@@ -202,0 +285,1 @@\n+                           PRegisterImpl::max_slots_per_register * PRegisterImpl::number_of_registers +\n@@ -208,0 +292,1 @@\n+  static const int max_pr;\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":88,"deletions":3,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,52 @@\n+\n+REGISTER_DEFINITION(FloatRegister, z0);\n+REGISTER_DEFINITION(FloatRegister, z1);\n+REGISTER_DEFINITION(FloatRegister, z2);\n+REGISTER_DEFINITION(FloatRegister, z3);\n+REGISTER_DEFINITION(FloatRegister, z4);\n+REGISTER_DEFINITION(FloatRegister, z5);\n+REGISTER_DEFINITION(FloatRegister, z6);\n+REGISTER_DEFINITION(FloatRegister, z7);\n+REGISTER_DEFINITION(FloatRegister, z8);\n+REGISTER_DEFINITION(FloatRegister, z9);\n+REGISTER_DEFINITION(FloatRegister, z10);\n+REGISTER_DEFINITION(FloatRegister, z11);\n+REGISTER_DEFINITION(FloatRegister, z12);\n+REGISTER_DEFINITION(FloatRegister, z13);\n+REGISTER_DEFINITION(FloatRegister, z14);\n+REGISTER_DEFINITION(FloatRegister, z15);\n+REGISTER_DEFINITION(FloatRegister, z16);\n+REGISTER_DEFINITION(FloatRegister, z17);\n+REGISTER_DEFINITION(FloatRegister, z18);\n+REGISTER_DEFINITION(FloatRegister, z19);\n+REGISTER_DEFINITION(FloatRegister, z20);\n+REGISTER_DEFINITION(FloatRegister, z21);\n+REGISTER_DEFINITION(FloatRegister, z22);\n+REGISTER_DEFINITION(FloatRegister, z23);\n+REGISTER_DEFINITION(FloatRegister, z24);\n+REGISTER_DEFINITION(FloatRegister, z25);\n+REGISTER_DEFINITION(FloatRegister, z26);\n+REGISTER_DEFINITION(FloatRegister, z27);\n+REGISTER_DEFINITION(FloatRegister, z28);\n+REGISTER_DEFINITION(FloatRegister, z29);\n+REGISTER_DEFINITION(FloatRegister, z30);\n+REGISTER_DEFINITION(FloatRegister, z31);\n+\n+REGISTER_DEFINITION(PRegister, p0);\n+REGISTER_DEFINITION(PRegister, p1);\n+REGISTER_DEFINITION(PRegister, p2);\n+REGISTER_DEFINITION(PRegister, p3);\n+REGISTER_DEFINITION(PRegister, p4);\n+REGISTER_DEFINITION(PRegister, p5);\n+REGISTER_DEFINITION(PRegister, p6);\n+REGISTER_DEFINITION(PRegister, p7);\n+REGISTER_DEFINITION(PRegister, p8);\n+REGISTER_DEFINITION(PRegister, p9);\n+REGISTER_DEFINITION(PRegister, p10);\n+REGISTER_DEFINITION(PRegister, p11);\n+REGISTER_DEFINITION(PRegister, p12);\n+REGISTER_DEFINITION(PRegister, p13);\n+REGISTER_DEFINITION(PRegister, p14);\n+REGISTER_DEFINITION(PRegister, p15);\n+\n+REGISTER_DEFINITION(PRegister, ptrue);\n","filename":"src\/hotspot\/cpu\/aarch64\/register_definitions_aarch64.cpp","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -118,0 +118,10 @@\n+  bool use_sve = false;\n+  int sve_vector_size_in_bytes = 0;\n+  int sve_vector_size_in_slots = 0;\n+\n+#ifdef COMPILER2\n+  use_sve = Matcher::supports_scalable_vector();\n+  sve_vector_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);\n+  sve_vector_size_in_slots = Matcher::scalable_vector_reg_size(T_FLOAT);\n+#endif\n+\n@@ -120,0 +130,2 @@\n+    int vect_words = 0;\n+    int extra_save_slots_per_register = 0;\n@@ -121,2 +133,7 @@\n-    int vect_words = FloatRegisterImpl::number_of_registers * FloatRegisterImpl::extra_save_slots_per_register \/\n-                     VMRegImpl::slots_per_word;\n+    if (use_sve) {\n+      extra_save_slots_per_register = sve_vector_size_in_slots - FloatRegisterImpl::save_slots_per_register;\n+    } else {\n+      extra_save_slots_per_register = FloatRegisterImpl::extra_save_slots_per_neon_register;\n+    }\n+    vect_words = FloatRegisterImpl::number_of_registers * extra_save_slots_per_register \/\n+                 VMRegImpl::slots_per_word;\n@@ -141,1 +158,1 @@\n-  __ push_CPU_state(save_vectors);\n+  __ push_CPU_state(save_vectors, use_sve, sve_vector_size_in_bytes);\n@@ -165,2 +182,7 @@\n-    int sp_offset = save_vectors ? (FloatRegisterImpl::max_slots_per_register * i) :\n-                                   (FloatRegisterImpl::save_slots_per_register * i);\n+    int sp_offset = 0;\n+    if (save_vectors) {\n+      sp_offset = use_sve ? (sve_vector_size_in_slots * i) :\n+                            (FloatRegisterImpl::slots_per_neon_register * i);\n+    } else {\n+      sp_offset = FloatRegisterImpl::save_slots_per_register * i;\n+    }\n@@ -175,1 +197,5 @@\n-#if !COMPILER2_OR_JVMCI\n+#ifdef COMPILER2\n+  __ pop_CPU_state(restore_vectors, Matcher::supports_scalable_vector(),\n+                   Matcher::scalable_vector_reg_size(T_BYTE));\n+#else\n+#if !INCLUDE_JVMCI\n@@ -179,0 +205,1 @@\n+#endif\n@@ -1853,0 +1880,5 @@\n+  if (UseSVE > 0) {\n+    \/\/ Make sure that jni code does not change SVE vector length.\n+    __ verify_sve_vector_length();\n+  }\n+\n@@ -2785,0 +2817,6 @@\n+  if (UseSVE > 0 && save_vectors) {\n+    \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+    \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+    __ reinitialize_ptrue();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":44,"deletions":6,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -491,0 +491,5 @@\n+    if (UseSVE > 0 ) {\n+      \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+      \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+      __ reinitialize_ptrue();\n+    }\n@@ -5031,0 +5036,6 @@\n+    if (UseSVE > 0) {\n+      \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+      \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+      __ reinitialize_ptrue();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1375,0 +1375,5 @@\n+  if (UseSVE > 0) {\n+    \/\/ Make sure that jni code does not change SVE vector length.\n+    __ verify_sve_vector_length();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -39,1 +40,0 @@\n-#include <sys\/auxv.h>\n@@ -41,0 +41,2 @@\n+#include <sys\/auxv.h>\n+#include <sys\/prctl.h>\n@@ -70,0 +72,14 @@\n+#ifndef HWCAP_SVE\n+#define HWCAP_SVE (1 << 22)\n+#endif\n+\n+#ifndef HWCAP2_SVE2\n+#define HWCAP2_SVE2 (1 << 1)\n+#endif\n+\n+#ifndef PR_SVE_GET_VL\n+\/\/ For old toolchains which do not have SVE related macros defined.\n+#define PR_SVE_SET_VL   50\n+#define PR_SVE_GET_VL   51\n+#endif\n+\n@@ -77,0 +93,1 @@\n+int VM_Version::_initial_sve_vector_length;\n@@ -119,1 +136,0 @@\n-\n@@ -170,0 +186,1 @@\n+  uint64_t auxv2 = getauxval(AT_HWCAP2);\n@@ -280,0 +297,6 @@\n+  if (_cpu == CPU_ARM) {\n+    if (FLAG_IS_DEFAULT(UseSignumIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseSignumIntrinsic, true);\n+    }\n+  }\n+\n@@ -295,0 +318,2 @@\n+  if (auxv & HWCAP_SVE) strcat(buf, \", sve\");\n+  if (auxv2 & HWCAP2_SVE2) strcat(buf, \", sve2\");\n@@ -434,0 +459,12 @@\n+  if (auxv & HWCAP_SVE) {\n+    if (FLAG_IS_DEFAULT(UseSVE)) {\n+      FLAG_SET_DEFAULT(UseSVE, (auxv2 & HWCAP2_SVE2) ? 2 : 1);\n+    }\n+    if (UseSVE > 0) {\n+      _initial_sve_vector_length = prctl(PR_SVE_GET_VL);\n+    }\n+  } else if (UseSVE > 0) {\n+    warning(\"UseSVE specified, but not supported on current CPU. Disabling SVE.\");\n+    FLAG_SET_DEFAULT(UseSVE, 0);\n+  }\n+\n@@ -468,1 +505,25 @@\n-  int min_vector_size = 8;\n+  if (UseSVE > 0) {\n+    if (FLAG_IS_DEFAULT(MaxVectorSize)) {\n+      MaxVectorSize = _initial_sve_vector_length;\n+    } else if (MaxVectorSize < 16) {\n+      warning(\"SVE does not support vector length less than 16 bytes. Disabling SVE.\");\n+      UseSVE = 0;\n+    } else if ((MaxVectorSize % 16) == 0 && is_power_of_2(MaxVectorSize)) {\n+      int new_vl = prctl(PR_SVE_SET_VL, MaxVectorSize);\n+      _initial_sve_vector_length = new_vl;\n+      \/\/ If MaxVectorSize is larger than system largest supported SVE vector length, above prctl()\n+      \/\/ call will set task vector length to the system largest supported value. So, we also update\n+      \/\/ MaxVectorSize to that largest supported value.\n+      if (new_vl < 0) {\n+        vm_exit_during_initialization(\n+          err_msg(\"Current system does not support SVE vector length for MaxVectorSize: %d\",\n+                  (int)MaxVectorSize));\n+      } else if (new_vl != MaxVectorSize) {\n+        warning(\"Current system only supports max SVE vector length %d. Set MaxVectorSize to %d\",\n+                new_vl, new_vl);\n+      }\n+      MaxVectorSize = new_vl;\n+    } else {\n+      vm_exit_during_initialization(err_msg(\"Unsupported MaxVectorSize: %d\", (int)MaxVectorSize));\n+    }\n+  }\n@@ -470,4 +531,15 @@\n-  if (!FLAG_IS_DEFAULT(MaxVectorSize)) {\n-    if (MaxVectorSize < min_vector_size) {\n-      warning(\"MaxVectorSize must be at least %i on this platform\", min_vector_size);\n-      FLAG_SET_DEFAULT(MaxVectorSize, min_vector_size);\n+  if (UseSVE == 0) {  \/\/ NEON\n+    int min_vector_size = 8;\n+    int max_vector_size = 16;\n+    if (!FLAG_IS_DEFAULT(MaxVectorSize)) {\n+      if (!is_power_of_2(MaxVectorSize)) {\n+        vm_exit_during_initialization(err_msg(\"Unsupported MaxVectorSize: %d\", (int)MaxVectorSize));\n+      } else if (MaxVectorSize < min_vector_size) {\n+        warning(\"MaxVectorSize must be at least %i on this platform\", min_vector_size);\n+        FLAG_SET_DEFAULT(MaxVectorSize, min_vector_size);\n+      } else if (MaxVectorSize > max_vector_size) {\n+        warning(\"MaxVectorSize must be at most %i on this platform\", max_vector_size);\n+        FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);\n+      }\n+    } else {\n+      FLAG_SET_DEFAULT(MaxVectorSize, 16);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":79,"deletions":7,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+  static int _initial_sve_vector_length;\n+\n@@ -109,0 +111,1 @@\n+  static int get_initial_sve_vector_length()  { return _initial_sve_vector_length; };\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.\n@@ -39,0 +39,4 @@\n+inline VMReg PRegisterImpl::as_VMReg() {\n+  return VMRegImpl::as_VMReg(encoding() + ConcreteRegisterImpl::max_fpr);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1027,0 +1027,8 @@\n+const bool Matcher::supports_scalable_vector() {\n+  return false;\n+}\n+\n+const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+  return -1;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2400,0 +2400,8 @@\n+const bool Matcher::supports_scalable_vector() {\n+  return false;\n+}\n+\n+const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+  return -1;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1631,0 +1631,8 @@\n+const bool Matcher::supports_scalable_vector() {\n+  return false;\n+}\n+\n+const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+  return -1;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1880,0 +1880,8 @@\n+const bool Matcher::supports_scalable_vector() {\n+  return false;\n+}\n+\n+const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+  return -1;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2854,1 +2854,1 @@\n-    assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, \"missing type\");\n+    assert(ARRAY_SIZE(hi) == _last_machine_leaf - 8, \"missing type\");\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-    if (is_cgroupsV2 && sscanf(p, \"%*d %*d %*d:%*d %*s %s %*[^-]- %s cgroup2 %*s\", tmp_mount_point, tmp_fs_type) == 2) {\n+    if (is_cgroupsV2 && sscanf(p, \"%*d %*d %*d:%*d %*s %s %*[^-]- %s %*s %*s\", tmp_mount_point, tmp_fs_type) == 2) {\n@@ -292,1 +292,1 @@\n-    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s cgroup %s\", tmproot, tmpmount, tmp_fs_type, tmpcgroups) == 4) {\n+    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s %*s %s\", tmproot, tmpmount, tmp_fs_type, tmpcgroups) == 4) {\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -937,0 +937,1 @@\n+    case 'A':  return \"TypeVect::VECTA\";\n@@ -947,0 +948,4 @@\n+  if (strncmp(idealOp, \"RegVMask\", 8) == 0) {\n+    return \"Type::BOTTOM\";\n+  }\n+\n","filename":"src\/hotspot\/share\/adlc\/archDesc.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3948,0 +3948,2 @@\n+         strcmp(opType,\"RegVMask\")==0 ||\n+         strcmp(opType,\"VecA\")==0 ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -764,1 +764,1 @@\n-  LinkInfo link_info(holder_klass, name, sig, accessor_klass, LinkInfo::AccessCheck::required, tag);\n+  LinkInfo link_info(holder_klass, name, sig, accessor_klass, LinkInfo::AccessCheck::required, LinkInfo::LoaderConstraintCheck::required, tag);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -812,1 +812,2 @@\n-                      check_access ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip);\n+                      check_access ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip,\n+                      check_access ? LinkInfo::LoaderConstraintCheck::required : LinkInfo::LoaderConstraintCheck::skip);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1138,1 +1138,5 @@\n-    MN_ACCESS_VM_ANNOTATIONS = 0x00000008\n+    MN_ACCESS_VM_ANNOTATIONS = 0x00000008,\n+    \/\/ Lookup modes\n+    MN_MODULE_MODE           = 0x00000010,\n+    MN_UNCONDITIONAL_MODE    = 0x00000020,\n+    MN_TRUSTED_MODE          = -1\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2833,1 +2833,1 @@\n-    MethodHandles::resolve_MemberName(mname, caller, \/*speculative_resolve*\/false, CHECK_(empty));\n+    MethodHandles::resolve_MemberName(mname, caller, 0, false \/*speculative_resolve*\/, CHECK_(empty));\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -818,0 +818,8 @@\n+  case vmIntrinsics::_dcopySign:\n+  case vmIntrinsics::_fcopySign:\n+    if (!InlineMathNatives || !UseCopySignIntrinsic) return true;\n+    break;\n+  case vmIntrinsics::_dsignum:\n+  case vmIntrinsics::_fsignum:\n+    if (!InlineMathNatives || !UseSignumIntrinsic) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -792,0 +792,2 @@\n+  do_name(copySign_name, \"copySign\")                                                                                    \\\n+  do_name(signum_name,\"signum\")                                                                                         \\\n@@ -830,0 +832,4 @@\n+  do_intrinsic(_dcopySign,                java_lang_Math,         copySign_name,      double2_double_signature,  F_S)   \\\n+  do_intrinsic(_fcopySign,                java_lang_Math,         copySign_name,      float2_float_signature,    F_S)   \\\n+  do_intrinsic(_dsignum,                  java_lang_Math,         signum_name,        double_double_signature,   F_S)   \\\n+  do_intrinsic(_fsignum,                  java_lang_Math,         signum_name,        float_float_signature,     F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -244,0 +244,1 @@\n+  _check_loader_constraints = true;\n@@ -259,0 +260,1 @@\n+  _check_loader_constraints = true;\n@@ -264,1 +266,1 @@\n-  tty->print_cr(\"Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s\",\n+  tty->print_cr(\"Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s check_loader_constraints=%s\",\n@@ -269,1 +271,3 @@\n-                _check_access ? \"true\" : \"false\");\n+                _check_access ? \"true\" : \"false\",\n+                _check_loader_constraints ? \"true\" : \"false\");\n+\n@@ -798,1 +802,2 @@\n-\n+  }\n+  if (link_info.check_loader_constraints()) {\n@@ -894,1 +899,2 @@\n-\n+  }\n+  if (link_info.check_loader_constraints()) {\n@@ -1058,1 +1064,1 @@\n-  if ((sel_klass != current_klass) && (current_klass != NULL)) {\n+  if (link_info.check_loader_constraints() && (sel_klass != current_klass) && (current_klass != NULL)) {\n@@ -1092,1 +1098,2 @@\n-                      link_info.check_access() ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip);\n+                      link_info.check_access() ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip,\n+                      link_info.check_loader_constraints() ? LinkInfo::LoaderConstraintCheck::required : LinkInfo::LoaderConstraintCheck::skip);\n@@ -1253,1 +1260,1 @@\n-      } else if (sel_method() != resolved_method()) {\n+      } else if (link_info.check_loader_constraints() && sel_method() != resolved_method()) {\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+  bool        _check_loader_constraints;\n@@ -148,0 +149,1 @@\n+  enum class LoaderConstraintCheck { required, skip };\n@@ -155,0 +157,1 @@\n+           LoaderConstraintCheck check_loader_constraints = LoaderConstraintCheck::required,\n@@ -158,1 +161,2 @@\n-    _check_access(check_access == AccessCheck::required), _tag(tag) {}\n+    _check_access(check_access == AccessCheck::required),\n+    _check_loader_constraints(check_loader_constraints == LoaderConstraintCheck::required), _tag(tag) {}\n@@ -162,0 +166,1 @@\n+           LoaderConstraintCheck check_loader_constraints = LoaderConstraintCheck::required,\n@@ -165,1 +170,3 @@\n-    _check_access(check_access == AccessCheck::required), _tag(tag) {}\n+    _check_access(check_access == AccessCheck::required),\n+    _check_loader_constraints(check_loader_constraints == LoaderConstraintCheck::required), _tag(tag) {}\n+\n@@ -171,1 +178,1 @@\n-    _check_access(false), _tag(JVM_CONSTANT_Invalid) {}\n+    _check_access(false), _check_loader_constraints(false), _tag(JVM_CONSTANT_Invalid) {}\n@@ -174,8 +181,8 @@\n-  Symbol* name() const               { return _name; }\n-  Symbol* signature() const          { return _signature; }\n-  Klass* resolved_klass() const      { return _resolved_klass; }\n-  Klass* current_klass() const       { return _current_klass; }\n-  Method* current_method() const     { return _current_method(); }\n-  constantTag tag() const            { return _tag; }\n-  bool check_access() const          { return _check_access; }\n-\n+  Symbol* name() const                  { return _name; }\n+  Symbol* signature() const             { return _signature; }\n+  Klass* resolved_klass() const         { return _resolved_klass; }\n+  Klass* current_klass() const          { return _current_klass; }\n+  Method* current_method() const        { return _current_method(); }\n+  constantTag tag() const               { return _tag; }\n+  bool check_access() const             { return _check_access; }\n+  bool check_loader_constraints() const { return _check_loader_constraints; }\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+  _hash = 1;\n@@ -204,1 +205,3 @@\n-    _hash = (_hash << 2) + (unsigned int)(((size_t)mid >> 2) + (bci << 4) + type);\n+    _hash = (_hash * 31) + mid;\n+    _hash = (_hash * 31) + bci;\n+    _hash = (_hash * 31) + type;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  LinkInfo link_info(resolved_klass, method_name, method_signature, NULL, LinkInfo::AccessCheck::skip);\n+  LinkInfo link_info(resolved_klass, method_name, method_signature, NULL, LinkInfo::AccessCheck::skip, LinkInfo::LoaderConstraintCheck::skip);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1330,1 +1330,1 @@\n-  LinkInfo link_info(holder, name, sig, accessor, LinkInfo::AccessCheck::required, tag);\n+  LinkInfo link_info(holder, name, sig, accessor, LinkInfo::AccessCheck::required, LinkInfo::LoaderConstraintCheck::required, tag);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -461,0 +461,12 @@\n+  case vmIntrinsics::_dcopySign:\n+    if (!Matcher::match_rule_supported(Op_CopySignD)) return false;\n+    break;\n+  case vmIntrinsics::_fcopySign:\n+    if (!Matcher::match_rule_supported(Op_CopySignF)) return false;\n+    break;\n+  case vmIntrinsics::_dsignum:\n+    if (!Matcher::match_rule_supported(Op_SignumD)) return false;\n+    break;\n+  case vmIntrinsics::_fsignum:\n+    if (!Matcher::match_rule_supported(Op_SignumF)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  if( _is_scalable ) tty->print(\"Scalable \");\n@@ -647,1 +648,9 @@\n-          OptoReg::Name lo = OptoReg::add(hi, (1-lrg.num_regs())); \/\/ Find lo\n+          int num_regs = lrg.num_regs();\n+          if (lrg.is_scalable() && OptoReg::is_stack(hi)) {\n+            \/\/ For scalable vector registers, when they are allocated in physical\n+            \/\/ registers, num_regs is RegMask::SlotsPerVecA for reg mask of scalable\n+            \/\/ vector. If they are allocated on stack, we need to get the actual\n+            \/\/ num_regs, which reflects the physical length of scalable registers.\n+            num_regs = lrg.scalable_reg_slots();\n+          }\n+          OptoReg::Name lo = OptoReg::add(hi, (1-num_regs)); \/\/ Find lo\n@@ -805,1 +814,1 @@\n-        if (RegMask::is_vector(ireg))\n+        if (RegMask::is_vector(ireg)) {\n@@ -807,0 +816,11 @@\n+          if (ireg == Op_VecA) {\n+            assert(Matcher::supports_scalable_vector(), \"scalable vector should be supported\");\n+            lrg._is_scalable = 1;\n+            \/\/ For scalable vector, when it is allocated in physical register,\n+            \/\/ num_regs is RegMask::SlotsPerVecA for reg mask,\n+            \/\/ which may not be the actual physical register size.\n+            \/\/ If it is allocated in stack, we need to get the actual\n+            \/\/ physical length of scalable vector register.\n+            lrg.set_scalable_reg_slots(Matcher::scalable_vector_reg_size(T_FLOAT));\n+          }\n+        }\n@@ -908,0 +928,7 @@\n+        case Op_VecA:\n+          assert(Matcher::supports_scalable_vector(), \"does not support scalable vector\");\n+          assert(RegMask::num_registers(Op_VecA) == RegMask::SlotsPerVecA, \"sanity\");\n+          assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecA), \"vector should be aligned\");\n+          lrg.set_num_regs(RegMask::SlotsPerVecA);\n+          lrg.set_reg_pressure(1);\n+          break;\n@@ -1308,0 +1335,40 @@\n+static OptoReg::Name find_first_set(LRG &lrg, RegMask mask, int chunk) {\n+  int num_regs = lrg.num_regs();\n+  OptoReg::Name assigned = mask.find_first_set(lrg, num_regs);\n+\n+  if (lrg.is_scalable()) {\n+    \/\/ a physical register is found\n+    if (chunk == 0 && OptoReg::is_reg(assigned)) {\n+      return assigned;\n+    }\n+\n+    \/\/ find available stack slots for scalable register\n+    if (lrg._is_vector) {\n+      num_regs = lrg.scalable_reg_slots();\n+      \/\/ if actual scalable vector register is exactly SlotsPerVecA * 32 bits\n+      if (num_regs == RegMask::SlotsPerVecA) {\n+        return assigned;\n+      }\n+\n+      \/\/ mask has been cleared out by clear_to_sets(SlotsPerVecA) before choose_color, but it\n+      \/\/ does not work for scalable size. We have to find adjacent scalable_reg_slots() bits\n+      \/\/ instead of SlotsPerVecA bits.\n+      assigned = mask.find_first_set(lrg, num_regs); \/\/ find highest valid reg\n+      while (OptoReg::is_valid(assigned) && RegMask::can_represent(assigned)) {\n+        \/\/ Verify the found reg has scalable_reg_slots() bits set.\n+        if (mask.is_valid_reg(assigned, num_regs)) {\n+          return assigned;\n+        } else {\n+          \/\/ Remove more for each iteration\n+          mask.Remove(assigned - num_regs + 1); \/\/ Unmask the lowest reg\n+          mask.clear_to_sets(RegMask::SlotsPerVecA); \/\/ Align by SlotsPerVecA bits\n+          assigned = mask.find_first_set(lrg, num_regs);\n+        }\n+      }\n+      return OptoReg::Bad; \/\/ will cause chunk change, and retry next chunk\n+    }\n+  }\n+\n+  return assigned;\n+}\n+\n@@ -1341,1 +1408,1 @@\n-      OptoReg::Name reg = tempmask.find_first_set(lrg.num_regs());\n+      OptoReg::Name reg = find_first_set(lrg, tempmask, chunk);\n@@ -1350,1 +1417,1 @@\n-    return OptoReg::add(lrg.mask().find_first_set(lrg.num_regs()),chunk);\n+    return OptoReg::add(find_first_set(lrg, lrg.mask(), chunk), chunk);\n@@ -1405,1 +1472,0 @@\n-\n@@ -1487,1 +1553,0 @@\n-\n@@ -1512,1 +1577,5 @@\n-        assert(!lrg->_is_vector || n_regs <= RegMask::SlotsPerVecZ, \"sanity\");\n+        if (Matcher::supports_scalable_vector()) {\n+          assert(!lrg->_is_vector || n_regs <= RegMask::SlotsPerVecA, \"sanity\");\n+        } else {\n+          assert(!lrg->_is_vector || n_regs <= RegMask::SlotsPerVecZ, \"sanity\");\n+        }\n@@ -1516,1 +1585,5 @@\n-        for (int i = 1; i < n_regs; i++)\n+        \/\/ We always choose the high bit, then mask the low bits by register size\n+        if (lrg->is_scalable() && OptoReg::is_stack(lrg->reg())) { \/\/ stack\n+          n_regs = lrg->scalable_reg_slots();\n+        }\n+        for (int i = 1; i < n_regs; i++) {\n@@ -1518,0 +1591,1 @@\n+        }\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":82,"deletions":8,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,3 @@\n-      assert(_mask.is_aligned_sets(_num_regs), \"mask is not aligned, adjacent sets\");\n+      if (!(_is_scalable && OptoReg::is_stack(_reg))) {\n+        assert(_mask.is_aligned_sets(_num_regs), \"mask is not aligned, adjacent sets\");\n+      }\n@@ -140,1 +142,0 @@\n-  \/\/ Number of registers this live range uses when it colors\n@@ -142,0 +143,1 @@\n+  \/\/ Number of registers this live range uses when it colors\n@@ -144,0 +146,6 @@\n+\n+  \/\/ For scalable register, num_regs may not be the actual physical register size.\n+  \/\/ We need to get the actual physical length of scalable register when scalable\n+  \/\/ register is spilled. The size of one slot is 32-bit.\n+  uint _scalable_reg_slots;     \/\/ Actual scalable register length of slots.\n+                                \/\/ Meaningful only when _is_scalable is true.\n@@ -148,0 +156,17 @@\n+  uint scalable_reg_slots() { return _scalable_reg_slots; }\n+  void set_scalable_reg_slots(uint slots) {\n+    assert(_is_scalable, \"scalable register\");\n+    assert(slots > 0, \"slots of scalable register is not valid\");\n+    _scalable_reg_slots = slots;\n+  }\n+\n+  bool is_scalable() {\n+#ifdef ASSERT\n+    if (_is_scalable) {\n+      \/\/ Should only be a vector for now, but it could also be a RegVMask in future.\n+      assert(_is_vector && (_num_regs == RegMask::SlotsPerVecA), \"unexpected scalable reg\");\n+    }\n+#endif\n+    return _is_scalable;\n+  }\n+\n@@ -173,0 +198,2 @@\n+         _is_scalable:1,        \/\/ True if register size is scalable\n+                                \/\/      e.g. Arm SVE vector\/predicate registers.\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -296,0 +296,4 @@\n+macro(CopySignD)\n+macro(CopySignF)\n+macro(SignumD)\n+macro(SignumF)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,14 @@\n+\/\/------------------------------CopySign-----------------------------------------\n+CopySignDNode* CopySignDNode::make(PhaseGVN& gvn, Node* in1, Node* in2) {\n+  return new CopySignDNode(in1, in2, gvn.makecon(TypeD::ZERO));\n+}\n+\n+\/\/------------------------------Signum-------------------------------------------\n+SignumDNode* SignumDNode::make(PhaseGVN& gvn, Node* in) {\n+  return new SignumDNode(in, gvn.makecon(TypeD::ZERO), gvn.makecon(TypeD::ONE));\n+}\n+\n+SignumFNode* SignumFNode::make(PhaseGVN& gvn, Node* in) {\n+  return new SignumFNode(in, gvn.makecon(TypeF::ZERO), gvn.makecon(TypeF::ONE));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"opto\/connode.hpp\"\n@@ -219,0 +220,40 @@\n+\/\/------------------------------CopySign-----------------------------------------\n+class CopySignDNode : public Node {\n+ protected:\n+  CopySignDNode(Node* in1, Node* in2, Node* in3) : Node(0, in1, in2, in3) {}\n+ public:\n+  static CopySignDNode* make(PhaseGVN& gvn, Node* in1, Node* in2);\n+  virtual int Opcode() const;\n+  const Type* bottom_type() const { return TypeLong::DOUBLE; }\n+  virtual uint ideal_reg() const { return Op_RegD; }\n+};\n+\n+class CopySignFNode : public Node {\n+ public:\n+  CopySignFNode(Node* in1, Node* in2) : Node(0, in1, in2) {}\n+  virtual int Opcode() const;\n+  const Type* bottom_type() const { return TypeLong::FLOAT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+};\n+\n+\/\/------------------------------Signum-------------------------------------------\n+class SignumDNode : public Node {\n+ protected:\n+  SignumDNode(Node* in1, Node* in2, Node* in3) : Node(0, in1, in2, in3) {}\n+ public:\n+  static SignumDNode* make(PhaseGVN& gvn, Node* in);\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return Type::DOUBLE; }\n+  virtual uint ideal_reg() const { return Op_RegD; }\n+};\n+\n+class SignumFNode : public Node {\n+ protected:\n+  SignumFNode(Node* in1, Node* in2, Node* in3) : Node(0, in1, in2, in3) {}\n+ public:\n+  static SignumFNode* make(PhaseGVN& gvn, Node* in);\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return Type::FLOAT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -267,1 +267,5 @@\n-  case vmIntrinsics::_dpow:                     return inline_math_native(intrinsic_id());\n+  case vmIntrinsics::_dpow:\n+  case vmIntrinsics::_dcopySign:\n+  case vmIntrinsics::_fcopySign:\n+  case vmIntrinsics::_dsignum:\n+  case vmIntrinsics::_fsignum:                  return inline_math_native(intrinsic_id());\n@@ -1570,0 +1574,2 @@\n+  case vmIntrinsics::_dcopySign: n = CopySignDNode::make(_gvn, arg, round_double_node(argument(2))); break;\n+  case vmIntrinsics::_dsignum: n = SignumDNode::make(_gvn, arg); break;\n@@ -1587,0 +1593,2 @@\n+  case vmIntrinsics::_fcopySign: n = new CopySignFNode(arg, argument(1)); break;\n+  case vmIntrinsics::_fsignum: n = SignumFNode::make(_gvn, arg); break;\n@@ -1671,0 +1679,5 @@\n+  case vmIntrinsics::_dcopySign: return inline_double_math(id);\n+  case vmIntrinsics::_fcopySign: return inline_math(id);\n+  case vmIntrinsics::_dsignum: return inline_double_math(id);\n+  case vmIntrinsics::_fsignum: return inline_math(id);\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  idealreg2spillmask  [Op_VecA] = NULL;\n@@ -104,0 +105,1 @@\n+  idealreg2debugmask  [Op_VecA] = NULL;\n@@ -117,0 +119,1 @@\n+  idealreg2mhdebugmask[Op_VecA] = NULL;\n@@ -430,1 +433,1 @@\n-#define NOF_STACK_MASKS (3*11)\n+#define NOF_STACK_MASKS (3*12)\n@@ -466,17 +469,20 @@\n-  idealreg2spillmask  [Op_VecS] = &rms[18];\n-  idealreg2spillmask  [Op_VecD] = &rms[19];\n-  idealreg2spillmask  [Op_VecX] = &rms[20];\n-  idealreg2spillmask  [Op_VecY] = &rms[21];\n-  idealreg2spillmask  [Op_VecZ] = &rms[22];\n-\n-  idealreg2debugmask  [Op_VecS] = &rms[23];\n-  idealreg2debugmask  [Op_VecD] = &rms[24];\n-  idealreg2debugmask  [Op_VecX] = &rms[25];\n-  idealreg2debugmask  [Op_VecY] = &rms[26];\n-  idealreg2debugmask  [Op_VecZ] = &rms[27];\n-\n-  idealreg2mhdebugmask[Op_VecS] = &rms[28];\n-  idealreg2mhdebugmask[Op_VecD] = &rms[29];\n-  idealreg2mhdebugmask[Op_VecX] = &rms[30];\n-  idealreg2mhdebugmask[Op_VecY] = &rms[31];\n-  idealreg2mhdebugmask[Op_VecZ] = &rms[32];\n+  idealreg2spillmask  [Op_VecA] = &rms[18];\n+  idealreg2spillmask  [Op_VecS] = &rms[19];\n+  idealreg2spillmask  [Op_VecD] = &rms[20];\n+  idealreg2spillmask  [Op_VecX] = &rms[21];\n+  idealreg2spillmask  [Op_VecY] = &rms[22];\n+  idealreg2spillmask  [Op_VecZ] = &rms[23];\n+\n+  idealreg2debugmask  [Op_VecA] = &rms[24];\n+  idealreg2debugmask  [Op_VecS] = &rms[25];\n+  idealreg2debugmask  [Op_VecD] = &rms[26];\n+  idealreg2debugmask  [Op_VecX] = &rms[27];\n+  idealreg2debugmask  [Op_VecY] = &rms[28];\n+  idealreg2debugmask  [Op_VecZ] = &rms[29];\n+\n+  idealreg2mhdebugmask[Op_VecA] = &rms[30];\n+  idealreg2mhdebugmask[Op_VecS] = &rms[31];\n+  idealreg2mhdebugmask[Op_VecD] = &rms[32];\n+  idealreg2mhdebugmask[Op_VecX] = &rms[33];\n+  idealreg2mhdebugmask[Op_VecY] = &rms[34];\n+  idealreg2mhdebugmask[Op_VecZ] = &rms[35];\n@@ -509,0 +515,1 @@\n+  RegMask scalable_stack_mask = aligned_stack_mask;\n@@ -594,7 +601,26 @@\n-   if (UseFPUForSpilling) {\n-     \/\/ This mask logic assumes that the spill operations are\n-     \/\/ symmetric and that the registers involved are the same size.\n-     \/\/ On sparc for instance we may have to use 64 bit moves will\n-     \/\/ kill 2 registers when used with F0-F31.\n-     idealreg2spillmask[Op_RegI]->OR(*idealreg2regmask[Op_RegF]);\n-     idealreg2spillmask[Op_RegF]->OR(*idealreg2regmask[Op_RegI]);\n+  if (Matcher::supports_scalable_vector()) {\n+    int k = 1;\n+    OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);\n+    \/\/ Exclude last input arg stack slots to avoid spilling vector register there,\n+    \/\/ otherwise vector spills could stomp over stack slots in caller frame.\n+    for (; (in >= init_in) && (k < scalable_vector_reg_size(T_FLOAT)); k++) {\n+      scalable_stack_mask.Remove(in);\n+      in = OptoReg::add(in, -1);\n+    }\n+\n+    \/\/ For VecA\n+     scalable_stack_mask.clear_to_sets(RegMask::SlotsPerVecA);\n+     assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+    *idealreg2spillmask[Op_VecA] = *idealreg2regmask[Op_VecA];\n+     idealreg2spillmask[Op_VecA]->OR(scalable_stack_mask);\n+  } else {\n+    *idealreg2spillmask[Op_VecA] = RegMask::Empty;\n+  }\n+\n+  if (UseFPUForSpilling) {\n+    \/\/ This mask logic assumes that the spill operations are\n+    \/\/ symmetric and that the registers involved are the same size.\n+    \/\/ On sparc for instance we may have to use 64 bit moves will\n+    \/\/ kill 2 registers when used with F0-F31.\n+    idealreg2spillmask[Op_RegI]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegF]->OR(*idealreg2regmask[Op_RegI]);\n@@ -602,4 +628,4 @@\n-     idealreg2spillmask[Op_RegN]->OR(*idealreg2regmask[Op_RegF]);\n-     idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n-     idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n-     idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegN]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n+    idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegD]);\n@@ -607,1 +633,1 @@\n-     idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegF]);\n@@ -609,4 +635,4 @@\n-     \/\/ ARM has support for moving 64bit values between a pair of\n-     \/\/ integer registers and a double register\n-     idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n-     idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n+    \/\/ ARM has support for moving 64bit values between a pair of\n+    \/\/ integer registers and a double register\n+    idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n@@ -615,1 +641,1 @@\n-   }\n+  }\n@@ -627,0 +653,1 @@\n+  *idealreg2debugmask  [Op_VecA] = *idealreg2spillmask[Op_VecA];\n@@ -640,0 +667,1 @@\n+  *idealreg2mhdebugmask[Op_VecA] = *idealreg2spillmask[Op_VecA];\n@@ -659,0 +687,1 @@\n+  idealreg2debugmask[Op_VecA]->SUBTRACT(*caller_save_mask);\n@@ -672,0 +701,1 @@\n+  idealreg2mhdebugmask[Op_VecA]->SUBTRACT(*mh_caller_save_mask);\n@@ -932,0 +962,1 @@\n+  idealreg2regmask[Op_VecA] = regmask_for_ideal_register(Op_VecA, ret);\n@@ -1628,1 +1659,0 @@\n-\n@@ -2337,0 +2367,17 @@\n+    case Op_MulAddS2I: {\n+      Node* pair1 = new BinaryNode(n->in(1), n->in(2));\n+      Node* pair2 = new BinaryNode(n->in(3), n->in(4));\n+      n->set_req(1, pair1);\n+      n->set_req(2, pair2);\n+      n->del_req(4);\n+      n->del_req(3);\n+      break;\n+    }\n+    case Op_CopySignD:\n+    case Op_SignumF:\n+    case Op_SignumD: {\n+      Node* pair = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair);\n+      n->del_req(3);\n+      break;\n+    }\n@@ -2351,9 +2398,0 @@\n-    case Op_MulAddS2I: {\n-      Node* pair1 = new BinaryNode(n->in(1), n->in(2));\n-      Node* pair2 = new BinaryNode(n->in(3), n->in(4));\n-      n->set_req(1, pair1);\n-      n->set_req(2, pair2);\n-      n->del_req(4);\n-      n->del_req(3);\n-      break;\n-    }\n@@ -2365,1 +2403,0 @@\n-    }\n@@ -2368,0 +2405,1 @@\n+    }\n@@ -2497,1 +2535,1 @@\n-    assert(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ, \"not a vector: %d\", ideal_reg);\n+    assert(ideal_reg >= Op_VecA && ideal_reg <= Op_VecZ, \"not a vector: %d\", ideal_reg);\n@@ -2514,0 +2552,1 @@\n+    case Op_VecA: \/\/ fall-through\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":86,"deletions":47,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -341,0 +341,4 @@\n+  static const bool supports_scalable_vector();\n+  \/\/ Actual max scalable vector register length.\n+  static const int scalable_vector_reg_size(const BasicType bt);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  \"RegFlags\",\n+  \"VecA\",\n@@ -47,0 +47,2 @@\n+  \"RegVMask\",\n+  \"RegFlags\",\n","filename":"src\/hotspot\/share\/opto\/opcodes.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+  macro(VecA)                   \/\/ Machine vectora register\n@@ -45,0 +46,1 @@\n+  macro(RegVMask)               \/\/ Vector mask\/predicate register\n","filename":"src\/hotspot\/share\/opto\/opcodes.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,1 +269,0 @@\n-  int n_regs = RegMask::num_registers(val->ideal_reg());\n@@ -272,0 +271,1 @@\n+  int n_regs = RegMask::num_registers(val->ideal_reg(), lrgs(val_idx));\n@@ -308,0 +308,11 @@\n+    \/\/ For scalable register, number of registers may be inconsistent between\n+    \/\/ \"val_reg\" and \"reg\". For example, when \"val\" resides in register\n+    \/\/ but \"reg\" is located in stack.\n+    if (lrgs(val_idx).is_scalable()) {\n+      assert(val->ideal_reg() == Op_VecA, \"scalable vector register\");\n+      if (OptoReg::is_stack(reg)) {\n+        n_regs = lrgs(val_idx).scalable_reg_slots();\n+      } else {\n+        n_regs = RegMask::SlotsPerVecA;\n+      }\n+    }\n@@ -309,1 +320,8 @@\n-      uint last = (n_regs-1); \/\/ Looking for the last part of a set\n+      uint last;\n+      if (lrgs(val_idx).is_scalable()) {\n+        assert(val->ideal_reg() == Op_VecA, \"scalable vector register\");\n+        \/\/ For scalable vector register, regmask is always SlotsPerVecA bits aligned\n+        last = RegMask::SlotsPerVecA - 1;\n+      } else {\n+        last = (n_regs-1); \/\/ Looking for the last part of a set\n+      }\n@@ -594,1 +612,1 @@\n-      OptoReg::Name preg = lrgs(_lrg_map.live_range_id(phi)).reg();\n+      OptoReg::Name preg = lrgs(pidx).reg();\n@@ -622,1 +640,1 @@\n-        int n_regs = RegMask::num_registers(phi->ideal_reg());\n+        int n_regs = RegMask::num_registers(phi->ideal_reg(), lrgs(pidx));\n@@ -666,1 +684,1 @@\n-            int n_regs = RegMask::num_registers(def_ideal_reg);\n+            int n_regs = RegMask::num_registers(def_ideal_reg, lrgs(_lrg_map.live_range_id(def)));\n@@ -710,1 +728,1 @@\n-      int n_regs = RegMask::num_registers(n_ideal_reg);\n+      int n_regs = RegMask::num_registers(n_ideal_reg, lrgs(lidx));\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"opto\/chaitin.hpp\"\n@@ -62,1 +63,1 @@\n-  return (ireg == Op_VecS || ireg == Op_VecD ||\n+  return (ireg == Op_VecA || ireg == Op_VecS || ireg == Op_VecD ||\n@@ -69,1 +70,1 @@\n-        return 16;\n+        return SlotsPerVecZ;\n@@ -71,1 +72,1 @@\n-        return 8;\n+        return SlotsPerVecY;\n@@ -73,1 +74,1 @@\n-        return 4;\n+        return SlotsPerVecX;\n@@ -75,0 +76,1 @@\n+        return SlotsPerVecD;\n@@ -81,0 +83,3 @@\n+      case Op_VecA:\n+        assert(Matcher::supports_scalable_vector(), \"does not support scalable vector\");\n+        return SlotsPerVecA;\n@@ -86,0 +91,13 @@\n+int RegMask::num_registers(uint ireg, LRG &lrg) {\n+  int n_regs = num_registers(ireg);\n+\n+  \/\/ assigned is OptoReg which is selected by register allocator\n+  OptoReg::Name assigned = lrg.reg();\n+  assert(OptoReg::is_valid(assigned), \"should be valid opto register\");\n+\n+  if (lrg.is_scalable() && OptoReg::is_stack(assigned)) {\n+    n_regs = lrg.scalable_reg_slots();\n+  }\n+  return n_regs;\n+}\n+\n@@ -160,0 +178,10 @@\n+\/\/ Check that whether given reg number with size is valid\n+\/\/ for current regmask, where reg is the highest number.\n+bool RegMask::is_valid_reg(OptoReg::Name reg, const int size) const {\n+  for (int i = 0; i < size; i++) {\n+    if (!Member(reg - i)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n@@ -167,2 +195,7 @@\n-OptoReg::Name RegMask::find_first_set(const int size) const {\n-  assert(is_aligned_sets(size), \"mask is not aligned, adjacent sets\");\n+OptoReg::Name RegMask::find_first_set(LRG &lrg, const int size) const {\n+  if (lrg.is_scalable()) {\n+    \/\/ For scalable vector register, regmask is SlotsPerVecA bits aligned.\n+    assert(is_aligned_sets(SlotsPerVecA), \"mask is not aligned, adjacent sets\");\n+  } else {\n+    assert(is_aligned_sets(size), \"mask is not aligned, adjacent sets\");\n+  }\n@@ -248,1 +281,3 @@\n-      if ((bit & low_bits_mask) == 0) return false;\n+      if ((bit & low_bits_mask) == 0) {\n+        return false;\n+      }\n@@ -253,1 +288,3 @@\n-      if ((bits & set) != set) return false;\n+      if ((bits & set) != set) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":46,"deletions":9,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+class LRG;\n+\n@@ -94,0 +96,1 @@\n+         SlotsPerVecA = 8,\n@@ -98,1 +101,2 @@\n-         SlotsPerVecZ = 16 };\n+         SlotsPerVecZ = 16,\n+         };\n@@ -222,0 +226,4 @@\n+  \/\/ Check that whether given reg number with size is valid\n+  \/\/ for current regmask, where reg is the highest number.\n+  bool is_valid_reg(OptoReg::Name reg, const int size) const;\n+\n@@ -225,1 +233,1 @@\n-  OptoReg::Name find_first_set(const int size) const;\n+  OptoReg::Name find_first_set(LRG &lrg, const int size) const;\n@@ -239,0 +247,1 @@\n+  static int num_registers(uint ireg, LRG &lrg);\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -97,2 +97,5 @@\n-  \/\/ Do vectors exist on this architecture?\n-  if (Matcher::vector_width_in_bytes(T_BYTE) < 2) return;\n+  \/\/ SuperWord only works with power of two vector sizes.\n+  int vector_width = Matcher::vector_width_in_bytes(T_BYTE);\n+  if (vector_width < 2 || !is_power_of_2(vector_width)) {\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectora:\",      false, Op_VecA,              relocInfo::none          },  \/\/ VectorA.\n@@ -657,0 +658,4 @@\n+  if (Matcher::supports_scalable_vector()) {\n+    TypeVect::VECTA = TypeVect::make(T_BYTE, Matcher::scalable_vector_reg_size(T_BYTE));\n+  }\n+\n@@ -673,0 +678,2 @@\n+\n+  mreg2type[Op_VecA] = TypeVect::VECTA;\n@@ -992,0 +999,1 @@\n+  Bad,          \/\/ VectorA - handled in v-call\n@@ -1900,1 +1908,0 @@\n-\n@@ -2271,0 +2278,1 @@\n+const TypeVect *TypeVect::VECTA = NULL; \/\/ vector length agnostic\n@@ -2281,1 +2289,0 @@\n-  assert(length > 1 && is_power_of_2(length), \"vector length is power of 2\");\n@@ -2285,0 +2292,2 @@\n+  case Op_VecA:\n+    return (TypeVect*)(new TypeVectA(elem, length))->hashcons();\n@@ -2316,1 +2325,1 @@\n-\n+  case VectorA:\n@@ -2371,0 +2380,2 @@\n+  case VectorA:\n+    st->print(\"vectora[\"); break;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+class     TypeVectA;\n@@ -90,0 +91,1 @@\n+    VectorA,                    \/\/ (Scalable) Vector types for vector length agnostic\n@@ -768,0 +770,1 @@\n+  static const TypeVect *VECTA;\n@@ -779,0 +782,5 @@\n+class TypeVectA : public TypeVect {\n+  friend class TypeVect;\n+  TypeVectA(const Type* elem, uint length) : TypeVect(VectorA, elem, length) {}\n+};\n+\n@@ -1633,1 +1641,1 @@\n-  assert( _base >= VectorS && _base <= VectorZ, \"Not a Vector\" );\n+  assert( _base >= VectorA && _base <= VectorZ, \"Not a Vector\" );\n@@ -1638,1 +1646,1 @@\n-  return (_base >= VectorS && _base <= VectorZ) ? (TypeVect*)this : NULL;\n+  return (_base >= VectorA && _base <= VectorZ) ? (TypeVect*)this : NULL;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1088,1 +1088,1 @@\n-    return vopc != opc && Matcher::match_rule_supported(vopc);\n+    return vopc != opc && Matcher::match_rule_supported_vector(vopc, vlen, bt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1717,9 +1717,12 @@\n-    \/\/ thread. All other usage needs to use a vm-safepoint-op for safety.\n-    if (java_thread == JavaThread::current()) {\n-      state->update_for_pop_top_frame();\n-    } else {\n-      VM_UpdateForPopTopFrame op(state);\n-      VMThread::execute(&op);\n-      jvmtiError err = op.result();\n-      if (err != JVMTI_ERROR_NONE) {\n-        return err;\n+    \/\/ thread. All other usage needs to use a handshake for safety.\n+    {\n+      MutexLocker mu(JvmtiThreadState_lock);\n+      if (java_thread == JavaThread::current()) {\n+        state->update_for_pop_top_frame();\n+      } else {\n+        UpdateForPopTopFrameClosure op(state);\n+        bool executed = Handshake::execute_direct(&op, java_thread);\n+        jvmtiError err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+        if (err != JVMTI_ERROR_NONE) {\n+          return err;\n+        }\n@@ -1799,0 +1802,1 @@\n+  MutexLocker mu(JvmtiThreadState_lock);\n@@ -1803,3 +1807,3 @@\n-    VM_SetFramePop op(this, state, depth);\n-    VMThread::execute(&op);\n-    err = op.result();\n+    SetFramePopClosure op(this, state, depth);\n+    bool executed = Handshake::execute_direct(&op, java_thread);\n+    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1507,1 +1507,1 @@\n-VM_UpdateForPopTopFrame::doit() {\n+UpdateForPopTopFrameClosure::do_thread(Thread *target) {\n@@ -1509,2 +1509,2 @@\n-  ThreadsListHandle tlh;\n-  if (jt != NULL && tlh.includes(jt) && !jt->is_exiting() && jt->threadObj() != NULL) {\n+  assert(jt == target, \"just checking\");\n+  if (!jt->is_exiting() && jt->threadObj() != NULL) {\n@@ -1512,2 +1512,1 @@\n-  } else {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    _result = JVMTI_ERROR_NONE;\n@@ -1518,1 +1517,1 @@\n-VM_SetFramePop::doit() {\n+SetFramePopClosure::do_thread(Thread *target) {\n@@ -1520,2 +1519,2 @@\n-  ThreadsListHandle tlh;\n-  if (jt != NULL && tlh.includes(jt) && !jt->is_exiting() && jt->threadObj() != NULL) {\n+  assert(jt == target, \"just checking\");\n+  if (!jt->is_exiting() && jt->threadObj() != NULL) {\n@@ -1524,2 +1523,1 @@\n-  } else {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    _result = JVMTI_ERROR_NONE;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -339,2 +339,2 @@\n-\/\/ VM operation to update for pop top frame.\n-class VM_UpdateForPopTopFrame : public VM_Operation {\n+\/\/ HandshakeClosure to update for pop top frame.\n+class UpdateForPopTopFrameClosure : public HandshakeClosure {\n@@ -346,5 +346,4 @@\n-  VM_UpdateForPopTopFrame(JvmtiThreadState* state) {\n-    _state = state;\n-    _result = JVMTI_ERROR_NONE;\n-  }\n-  VMOp_Type type() const { return VMOp_UpdateForPopTopFrame; }\n+  UpdateForPopTopFrameClosure(JvmtiThreadState* state)\n+    : HandshakeClosure(\"UpdateForPopTopFrame\"),\n+      _state(state),\n+      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n@@ -352,1 +351,1 @@\n-  void doit();\n+  void do_thread(Thread *target);\n@@ -355,2 +354,2 @@\n-\/\/ VM operation to set frame pop.\n-class VM_SetFramePop : public VM_Operation {\n+\/\/ HandshakeClosure to set frame pop.\n+class SetFramePopClosure : public HandshakeClosure {\n@@ -364,7 +363,6 @@\n-  VM_SetFramePop(JvmtiEnv *env, JvmtiThreadState* state, jint depth) {\n-    _env = env;\n-    _state = state;\n-    _depth = depth;\n-    _result = JVMTI_ERROR_NONE;\n-  }\n-  VMOp_Type type() const { return VMOp_SetFramePop; }\n+  SetFramePopClosure(JvmtiEnv *env, JvmtiThreadState* state, jint depth)\n+    : HandshakeClosure(\"SetFramePop\"),\n+      _env(env),\n+      _state(state),\n+      _depth(depth),\n+      _result(JVMTI_ERROR_THREAD_NOT_ALIVE) {}\n@@ -372,1 +370,1 @@\n-  void doit();\n+  void do_thread(Thread *target);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,2 +194,5 @@\n-  assert(get_thread() == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n-         \"frame pop data only accessible from same thread or at safepoint\");\n+#ifdef ASSERT\n+  Thread *current = Thread::current();\n+#endif\n+  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+         \"frame pop data only accessible from same thread or direct handshake\");\n@@ -209,2 +212,5 @@\n-  assert(get_thread() == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n-         \"frame pop data only accessible from same thread or at safepoint\");\n+#ifdef ASSERT\n+  Thread *current = Thread::current();\n+#endif\n+  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+         \"frame pop data only accessible from same thread or direct handshake\");\n@@ -217,2 +223,5 @@\n-  assert(get_thread() == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n-         \"frame pop data only accessible from same thread or at safepoint\");\n+#ifdef ASSERT\n+  Thread *current = Thread::current();\n+#endif\n+  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+         \"frame pop data only accessible from same thread or direct handshake\");\n@@ -225,2 +234,5 @@\n-  assert(get_thread() == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n-         \"frame pop data only accessible from same thread or at safepoint\");\n+#ifdef ASSERT\n+  Thread *current = Thread::current();\n+#endif\n+  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+         \"frame pop data only accessible from same thread or direct handshake\");\n@@ -233,2 +245,5 @@\n-  assert(get_thread() == Thread::current() || SafepointSynchronize::is_at_safepoint(),\n-         \"frame pop data only accessible from same thread or at safepoint\");\n+#ifdef ASSERT\n+  Thread *current = Thread::current();\n+#endif\n+  assert(get_thread() == current || current == get_thread()->active_handshaker(),\n+         \"frame pop data only accessible from same thread or direct handshake\");\n@@ -243,1 +258,1 @@\n-class VM_GetCurrentLocation : public VM_Operation {\n+class GetCurrentLocationClosure : public HandshakeClosure {\n@@ -245,1 +260,0 @@\n-   JavaThread *_thread;\n@@ -250,7 +264,8 @@\n-  VM_GetCurrentLocation(JavaThread *thread) {\n-     _thread = thread;\n-   }\n-  VMOp_Type type() const { return VMOp_GetCurrentLocation; }\n-  void doit() {\n-    ResourceMark rmark; \/\/ _thread != Thread::current()\n-    RegisterMap rm(_thread, false);\n+  GetCurrentLocationClosure()\n+    : HandshakeClosure(\"GetCurrentLocation\"),\n+      _method_id(NULL),\n+      _bci(0) {}\n+  void do_thread(Thread *target) {\n+    JavaThread *jt = (JavaThread *)target;\n+    ResourceMark rmark; \/\/ jt != Thread::current()\n+    RegisterMap rm(jt, false);\n@@ -260,2 +275,2 @@\n-    if (!_thread->is_exiting() && _thread->has_last_Java_frame()) {\n-      javaVFrame* vf = _thread->last_java_vframe(&rm);\n+    if (!jt->is_exiting() && jt->has_last_Java_frame()) {\n+      javaVFrame* vf = jt->last_java_vframe(&rm);\n@@ -310,3 +325,9 @@\n-      \/\/ so get current location at safepoint.\n-      VM_GetCurrentLocation op(_thread);\n-      VMThread::execute(&op);\n+      \/\/ so get current location with direct handshake.\n+      GetCurrentLocationClosure op;\n+      Thread *current = Thread::current();\n+      if (current == _thread || _thread->active_handshaker() == current) {\n+        op.do_thread(_thread);\n+      } else {\n+        bool executed = Handshake::execute_direct(&op, _thread);\n+        guarantee(executed, \"Direct handshake failed. Target thread is not alive?\");\n+      }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":46,"deletions":25,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -334,2 +334,5 @@\n-  if (SafepointSynchronize::is_at_safepoint()) {\n-    hs.do_thread(state->get_thread());\n+  assert(state->get_thread()->is_Java_thread(), \"just checking\");\n+  JavaThread *target = (JavaThread *)state->get_thread();\n+  Thread *current = Thread::current();\n+  if (target == current || target->active_handshaker() == current) {\n+    hs.do_thread(target);\n@@ -337,1 +340,2 @@\n-    Handshake::execute_direct(&hs, state->get_thread());\n+    bool executed = Handshake::execute_direct(&hs, target);\n+    guarantee(executed, \"Direct handshake failed. Target thread is not alive?\");\n@@ -983,1 +987,1 @@\n-  MutexLocker mu(SafepointSynchronize::is_at_safepoint() ? NULL : JvmtiThreadState_lock);\n+  assert_lock_strong(JvmtiThreadState_lock);\n@@ -990,1 +994,1 @@\n-  MutexLocker mu(SafepointSynchronize::is_at_safepoint() ? NULL : JvmtiThreadState_lock);\n+  assert_lock_strong(JvmtiThreadState_lock);\n@@ -997,1 +1001,1 @@\n-  MutexLocker mu(SafepointSynchronize::is_at_safepoint() ? NULL : JvmtiThreadState_lock);\n+  assert_lock_strong(JvmtiThreadState_lock);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1648,1 +1648,4 @@\n-        ets->clear_frame_pop(cur_frame_number);\n+        {\n+          MutexLocker mu(JvmtiThreadState_lock);\n+          ets->clear_frame_pop(cur_frame_number);\n+        }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -275,3 +275,3 @@\n-  guarantee(SafepointSynchronize::is_at_safepoint() ||\n-    (JavaThread *)Thread::current() == get_thread(),\n-    \"must be current thread or at safepoint\");\n+  Thread *current = Thread::current();\n+  guarantee(current == get_thread() || current == get_thread()->active_handshaker(),\n+            \"must be current thread or direct handshake\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -135,0 +135,3 @@\n+  LM_UNCONDITIONAL     = java_lang_invoke_MemberName::MN_UNCONDITIONAL_MODE,\n+  LM_MODULE            = java_lang_invoke_MemberName::MN_MODULE_MODE,\n+  LM_TRUSTED           = java_lang_invoke_MemberName::MN_TRUSTED_MODE,\n@@ -675,1 +678,0 @@\n-\n@@ -679,1 +681,1 @@\n-Handle MethodHandles::resolve_MemberName(Handle mname, Klass* caller,\n+Handle MethodHandles::resolve_MemberName(Handle mname, Klass* caller, int lookup_mode,\n@@ -748,0 +750,1 @@\n+  \/\/ skip access check if it's trusted lookup\n@@ -751,0 +754,4 @@\n+  \/\/ skip loader constraints if it's trusted lookup or a public lookup\n+  LinkInfo::LoaderConstraintCheck loader_constraint_check = (caller != NULL && (lookup_mode & LM_UNCONDITIONAL) == 0) ?\n+                                              LinkInfo::LoaderConstraintCheck::required :\n+                                              LinkInfo::LoaderConstraintCheck::skip;\n@@ -757,1 +764,1 @@\n-      LinkInfo link_info(defc, name, type, caller, access_check);\n+      LinkInfo link_info(defc, name, type, caller, access_check, loader_constraint_check);\n@@ -798,1 +805,1 @@\n-      LinkInfo link_info(defc, name, type, caller, access_check);\n+      LinkInfo link_info(defc, name, type, caller, access_check, loader_constraint_check);\n@@ -823,1 +830,1 @@\n-        LinkInfo link_info(defc, name, type, caller, LinkInfo::AccessCheck::skip);\n+        LinkInfo link_info(defc, name, type, caller, LinkInfo::AccessCheck::skip, loader_constraint_check);\n@@ -1120,0 +1127,3 @@\n+    template(java_lang_invoke_MemberName,MN_MODULE_MODE) \\\n+    template(java_lang_invoke_MemberName,MN_UNCONDITIONAL_MODE) \\\n+    template(java_lang_invoke_MemberName,MN_TRUSTED_MODE) \\\n@@ -1193,1 +1203,1 @@\n-    jboolean speculative_resolve)) {\n+    jint lookup_mode, jboolean speculative_resolve)) {\n@@ -1199,1 +1209,5 @@\n-  if (VerifyMethodHandles && caller_jh != NULL &&\n+  \/\/ This only verifies from the context of the lookup class.  It does not\n+  \/\/ verify the lookup context for a Lookup object teleported from one module\n+  \/\/ to another. Such Lookup object can only access the intersection of the set\n+  \/\/ of accessible classes from both lookup class and previous lookup class.\n+  if (VerifyMethodHandles && (lookup_mode & LM_TRUSTED) == LM_TRUSTED && caller_jh != NULL &&\n@@ -1210,1 +1224,3 @@\n-      if (caller != SystemDictionary::Object_klass()\n+      \/\/ access check on behalf of the caller if this is not a public lookup\n+      \/\/ i.e. lookup mode is not UNCONDITIONAL\n+      if ((lookup_mode & LM_UNCONDITIONAL) == 0\n@@ -1214,1 +1230,5 @@\n-        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), reference_klass->external_name());\n+        ResourceMark rm(THREAD);\n+        stringStream ss;\n+        ss.print(\"caller %s tried to access %s\", caller->class_in_module_of_loader(),\n+                 reference_klass->class_in_module_of_loader());\n+        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), ss.as_string());\n@@ -1221,1 +1241,2 @@\n-  Handle resolved = MethodHandles::resolve_MemberName(mname, caller, speculative_resolve == JNI_TRUE,\n+  Handle resolved = MethodHandles::resolve_MemberName(mname, caller, lookup_mode,\n+                                                      speculative_resolve == JNI_TRUE,\n@@ -1521,1 +1542,1 @@\n-  {CC \"resolve\",                   CC \"(\" MEM \"\" CLS \"Z)\" MEM,               FN_PTR(MHN_resolve_Mem)},\n+  {CC \"resolve\",                   CC \"(\" MEM \"\" CLS \"IZ)\" MEM,              FN_PTR(MHN_resolve_Mem)},\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  static Handle resolve_MemberName(Handle mname, Klass* caller,\n+  static Handle resolve_MemberName(Handle mname, Klass* caller, int lookup_mode,\n","filename":"src\/hotspot\/share\/prims\/methodHandles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -350,0 +350,6 @@\n+  diagnostic(bool, UseCopySignIntrinsic, false,                             \\\n+          \"Enables intrinsification of Math.copySign\")                      \\\n+                                                                            \\\n+  diagnostic(bool, UseSignumIntrinsic, false,                               \\\n+          \"Enables intrinsification of Math.signum\")                        \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -386,1 +386,2 @@\n-  _thread_in_process_handshake(false)\n+  _thread_in_process_handshake(false),\n+  _active_handshaker(NULL)\n@@ -388,1 +389,0 @@\n-  DEBUG_ONLY(_active_handshaker = NULL;)\n@@ -513,1 +513,1 @@\n-    DEBUG_ONLY(_active_handshaker = Thread::current();)\n+    _active_handshaker = Thread::current();\n@@ -515,1 +515,1 @@\n-    DEBUG_ONLY(_active_handshaker = NULL;)\n+    _active_handshaker = NULL;\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-#ifdef ASSERT\n@@ -112,2 +111,0 @@\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2616,3 +2616,11 @@\n-  set_thread_state(_thread_blocked);\n-  java_suspend_self();\n-  set_thread_state_fence(state);\n+\n+  do {\n+    set_thread_state(_thread_blocked);\n+    java_suspend_self();\n+    \/\/ The current thread could have been suspended again. We have to check for\n+    \/\/ suspend after restoring the saved state. Without this the current thread\n+    \/\/ might return to _thread_in_Java and execute bytecodes for an arbitrary\n+    \/\/ long time.\n+    set_thread_state_fence(state);\n+  } while (is_external_suspend());\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1368,1 +1368,0 @@\n-#ifdef ASSERT\n@@ -1372,1 +1371,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,2 +79,0 @@\n-  template(UpdateForPopTopFrame)                  \\\n-  template(SetFramePop)                           \\\n@@ -86,1 +84,0 @@\n-  template(GetCurrentLocation)                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1853,0 +1853,4 @@\n+  declare_c2_type(CopySignDNode, Node)                                    \\\n+  declare_c2_type(CopySignFNode, Node)                                    \\\n+  declare_c2_type(SignumDNode, Node)                                      \\\n+  declare_c2_type(SignumFNode, Node)                                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1980,0 +1980,1 @@\n+    @HotSpotIntrinsicCandidate\n@@ -2001,0 +2002,1 @@\n+    @HotSpotIntrinsicCandidate\n@@ -2221,0 +2223,1 @@\n+    @HotSpotIntrinsicCandidate\n@@ -2244,0 +2247,1 @@\n+    @HotSpotIntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import static java.lang.invoke.GenerateJLIClassesHelper.traceSpeciesType;\n@@ -478,5 +479,1 @@\n-                if (TRACE_RESOLVE && salvage != null) {\n-                    \/\/ Used by jlink species pregeneration plugin, see\n-                    \/\/ jdk.tools.jlink.internal.plugins.GenerateJLIClassesPlugin\n-                    System.out.println(\"[SPECIES_RESOLVE] \" + className + \" (salvaged)\");\n-                }\n+                traceSpeciesType(className, salvage);\n@@ -484,3 +481,0 @@\n-                if (TRACE_RESOLVE) {\n-                    System.out.println(\"[SPECIES_FRESOLVE] \" + className + \" (Error) \" + ex.getMessage());\n-                }\n@@ -497,5 +491,1 @@\n-                    if (TRACE_RESOLVE) {\n-                        \/\/ Used by jlink species pregeneration plugin, see\n-                        \/\/ jdk.tools.jlink.internal.plugins.GenerateJLIClassesPlugin\n-                        System.out.println(\"[SPECIES_RESOLVE] \" + className + \" (generated)\");\n-                    }\n+                    traceSpeciesType(className, salvage);\n@@ -507,3 +497,0 @@\n-                    if (TRACE_RESOLVE) {\n-                        System.out.println(\"[SPECIES_RESOLVE] \" + className + \" (Error #2)\" );\n-                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import static java.lang.invoke.MethodHandleNatives.Constants.REF_invokeVirtual;\n+import static java.lang.invoke.MethodHandleNatives.Constants.*;\n@@ -180,1 +180,1 @@\n-                            .resolveOrFail(REF_invokeVirtual, member, DelegatingMethodHandle.class, NoSuchMethodException.class));\n+                            .resolveOrFail(REF_invokeVirtual, member, DelegatingMethodHandle.class, LM_TRUSTED, NoSuchMethodException.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DelegatingMethodHandle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-            m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);\n+            m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null, LM_TRUSTED);\n@@ -263,1 +263,2 @@\n-            linker = IMPL_NAMES.resolveOrFail(REF_invokeStatic, linker, null, NoSuchMethodException.class);\n+            linker = IMPL_NAMES.resolveOrFail(REF_invokeStatic, linker, null, LM_TRUSTED,\n+                                              NoSuchMethodException.class);\n@@ -774,1 +775,2 @@\n-            linker = IMPL_NAMES.resolveOrFail(REF_invokeVirtual, linker, null, NoSuchMethodException.class);\n+            linker = IMPL_NAMES.resolveOrFail(REF_invokeVirtual, linker, null, LM_TRUSTED,\n+                                              NoSuchMethodException.class);\n@@ -917,2 +919,3 @@\n-                            MemberName.getFactory()\n-                                    .resolveOrFail(REF_getField, member, DirectMethodHandle.class, NoSuchMethodException.class));\n+                            MemberName.getFactory().resolveOrFail(REF_getField, member,\n+                                                                  DirectMethodHandle.class, LM_TRUSTED,\n+                                                                  NoSuchMethodException.class));\n@@ -922,2 +925,3 @@\n-                        MemberName.getFactory()\n-                            .resolveOrFail(REF_invokeVirtual, member, DirectMethodHandle.class, NoSuchMethodException.class));\n+                            MemberName.getFactory().resolveOrFail(REF_invokeVirtual, member,\n+                                                                  DirectMethodHandle.class, LM_TRUSTED,\n+                                                                  NoSuchMethodException.class));\n@@ -937,2 +941,3 @@\n-            MemberName.getFactory()\n-                .resolveOrFail(REF_invokeStatic, member, DirectMethodHandle.class, NoSuchMethodException.class));\n+                MemberName.getFactory().resolveOrFail(REF_invokeStatic, member,\n+                                                      DirectMethodHandle.class, LM_TRUSTED,\n+                                                      NoSuchMethodException.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,4 @@\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.stream.Stream;\n@@ -36,2 +40,6 @@\n-import static java.lang.invoke.MethodTypeForm.LF_INVINTERFACE;\n-import static java.lang.invoke.MethodTypeForm.LF_INVVIRTUAL;\n+import static java.lang.invoke.LambdaForm.basicTypeSignature;\n+import static java.lang.invoke.LambdaForm.shortenSignature;\n+import static java.lang.invoke.LambdaForm.BasicType.*;\n+import static java.lang.invoke.MethodHandleStatics.TRACE_RESOLVE;\n+import static java.lang.invoke.MethodTypeForm.*;\n+import static java.lang.invoke.LambdaForm.Kind.*;\n@@ -44,0 +52,2 @@\n+    private static final String LF_RESOLVE = \"[LF_RESOLVE]\";\n+    private static final String SPECIES_RESOLVE = \"[SPECIES_RESOLVE]\";\n@@ -45,0 +55,302 @@\n+    static void traceLambdaForm(String name, MethodType type, Class<?> holder, MemberName resolvedMember) {\n+        if (TRACE_RESOLVE) {\n+            System.out.println(LF_RESOLVE + \" \" + holder.getName() + \" \" + name + \" \" +\n+                    shortenSignature(basicTypeSignature(type)) +\n+                    (resolvedMember != null ? \" (success)\" : \" (fail)\"));\n+        }\n+    }\n+\n+    static void traceSpeciesType(String cn, Class<?> salvage) {\n+        if (TRACE_RESOLVE) {\n+            System.out.println(SPECIES_RESOLVE + \" \" + cn + (salvage != null ? \" (salvaged)\" : \" (generated)\"));\n+        }\n+    }\n+\n+    \/\/ Map from DirectMethodHandle method type name to index to LambdForms\n+    static final Map<String, Integer> DMH_METHOD_TYPE_MAP =\n+            Map.of(\n+                    DIRECT_INVOKE_VIRTUAL.methodName,     LF_INVVIRTUAL,\n+                    DIRECT_INVOKE_STATIC.methodName,      LF_INVSTATIC,\n+                    DIRECT_INVOKE_SPECIAL.methodName,     LF_INVSPECIAL,\n+                    DIRECT_NEW_INVOKE_SPECIAL.methodName, LF_NEWINVSPECIAL,\n+                    DIRECT_INVOKE_INTERFACE.methodName,   LF_INVINTERFACE,\n+                    DIRECT_INVOKE_STATIC_INIT.methodName, LF_INVSTATIC_INIT,\n+                    DIRECT_INVOKE_SPECIAL_IFC.methodName, LF_INVSPECIAL_IFC\n+            );\n+\n+    static final String DIRECT_HOLDER = \"java\/lang\/invoke\/DirectMethodHandle$Holder\";\n+    static final String DELEGATING_HOLDER = \"java\/lang\/invoke\/DelegatingMethodHandle$Holder\";\n+    static final String BASIC_FORMS_HOLDER = \"java\/lang\/invoke\/LambdaForm$Holder\";\n+    static final String INVOKERS_HOLDER = \"java\/lang\/invoke\/Invokers$Holder\";\n+    static final String INVOKERS_HOLDER_CLASS_NAME = INVOKERS_HOLDER.replace('\/', '.');\n+    static final String BMH_SPECIES_PREFIX = \"java.lang.invoke.BoundMethodHandle$Species_\";\n+\n+    static class HolderClassBuilder {\n+\n+\n+        private final TreeSet<String> speciesTypes = new TreeSet<>();\n+        private final TreeSet<String> invokerTypes = new TreeSet<>();\n+        private final TreeSet<String> callSiteTypes = new TreeSet<>();\n+        private final Map<String, Set<String>> dmhMethods = new TreeMap<>();\n+\n+        HolderClassBuilder addSpeciesType(String type) {\n+            speciesTypes.add(expandSignature(type));\n+            return this;\n+        }\n+\n+        HolderClassBuilder addInvokerType(String methodType) {\n+            validateMethodType(methodType);\n+            invokerTypes.add(methodType);\n+            return this;\n+        }\n+\n+        HolderClassBuilder addCallSiteType(String csType) {\n+            validateMethodType(csType);\n+            callSiteTypes.add(csType);\n+            return this;\n+        }\n+\n+        Map<String, byte[]> build() {\n+            int count = 0;\n+            for (Set<String> entry : dmhMethods.values()) {\n+                count += entry.size();\n+            }\n+            MethodType[] directMethodTypes = new MethodType[count];\n+            int[] dmhTypes = new int[count];\n+            int index = 0;\n+            for (Map.Entry<String, Set<String>> entry : dmhMethods.entrySet()) {\n+                String dmhType = entry.getKey();\n+                for (String type : entry.getValue()) {\n+                    \/\/ The DMH type to actually ask for is retrieved by removing\n+                    \/\/ the first argument, which needs to be of Object.class\n+                    MethodType mt = asMethodType(type);\n+                    if (mt.parameterCount() < 1 ||\n+                            mt.parameterType(0) != Object.class) {\n+                        throw new RuntimeException(\n+                                \"DMH type parameter must start with L: \" + dmhType + \" \" + type);\n+                    }\n+\n+                    \/\/ Adapt the method type of the LF to retrieve\n+                    directMethodTypes[index] = mt.dropParameterTypes(0, 1);\n+\n+                    \/\/ invokeVirtual and invokeInterface must have a leading Object\n+                    \/\/ parameter, i.e., the receiver\n+                    dmhTypes[index] = DMH_METHOD_TYPE_MAP.get(dmhType);\n+                    if (dmhTypes[index] == LF_INVINTERFACE || dmhTypes[index] == LF_INVVIRTUAL) {\n+                        if (mt.parameterCount() < 2 ||\n+                                mt.parameterType(1) != Object.class) {\n+                            throw new RuntimeException(\n+                                    \"DMH type parameter must start with LL: \" + dmhType + \" \" + type);\n+                        }\n+                    }\n+                    index++;\n+                }\n+            }\n+\n+            \/\/ The invoker type to ask for is retrieved by removing the first\n+            \/\/ and the last argument, which needs to be of Object.class\n+            MethodType[] invokerMethodTypes = new MethodType[invokerTypes.size()];\n+            index = 0;\n+            for (String invokerType : invokerTypes) {\n+                MethodType mt = asMethodType(invokerType);\n+                final int lastParam = mt.parameterCount() - 1;\n+                if (mt.parameterCount() < 2 ||\n+                        mt.parameterType(0) != Object.class ||\n+                        mt.parameterType(lastParam) != Object.class) {\n+                    throw new RuntimeException(\n+                            \"Invoker type parameter must start and end with Object: \" + invokerType);\n+                }\n+                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                invokerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n+                index++;\n+            }\n+\n+            \/\/ The callSite type to ask for is retrieved by removing the last\n+            \/\/ argument, which needs to be of Object.class\n+            MethodType[] callSiteMethodTypes = new MethodType[callSiteTypes.size()];\n+            index = 0;\n+            for (String callSiteType : callSiteTypes) {\n+                MethodType mt = asMethodType(callSiteType);\n+                final int lastParam = mt.parameterCount() - 1;\n+                if (mt.parameterCount() < 1 ||\n+                        mt.parameterType(lastParam) != Object.class) {\n+                    throw new RuntimeException(\n+                            \"CallSite type parameter must end with Object: \" + callSiteType);\n+                }\n+                callSiteMethodTypes[index] = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                index++;\n+            }\n+\n+            Map<String, byte[]> result = new TreeMap<>();\n+            result.put(DIRECT_HOLDER,\n+                       generateDirectMethodHandleHolderClassBytes(\n+                            DIRECT_HOLDER, directMethodTypes, dmhTypes));\n+            result.put(DELEGATING_HOLDER,\n+                       generateDelegatingMethodHandleHolderClassBytes(\n+                            DELEGATING_HOLDER, directMethodTypes));\n+            result.put(INVOKERS_HOLDER,\n+                       generateInvokersHolderClassBytes(INVOKERS_HOLDER,\n+                            invokerMethodTypes, callSiteMethodTypes));\n+            result.put(BASIC_FORMS_HOLDER,\n+                       generateBasicFormsClassBytes(BASIC_FORMS_HOLDER));\n+\n+            speciesTypes.forEach(types -> {\n+                Map.Entry<String, byte[]> entry = generateConcreteBMHClassBytes(types);\n+                result.put(entry.getKey(), entry.getValue());\n+            });\n+\n+            \/\/ clear builder\n+            speciesTypes.clear();\n+            invokerTypes.clear();\n+            callSiteTypes.clear();\n+            dmhMethods.clear();\n+\n+            return result;\n+        }\n+\n+        private static MethodType asMethodType(String basicSignatureString) {\n+            String[] parts = basicSignatureString.split(\"_\");\n+            assert (parts.length == 2);\n+            assert (parts[1].length() == 1);\n+            String parameters = expandSignature(parts[0]);\n+            Class<?> rtype = simpleType(parts[1].charAt(0));\n+            if (parameters.isEmpty()) {\n+                return MethodType.methodType(rtype);\n+            } else {\n+                Class<?>[] ptypes = new Class<?>[parameters.length()];\n+                for (int i = 0; i < ptypes.length; i++) {\n+                    ptypes[i] = simpleType(parameters.charAt(i));\n+                }\n+                return MethodType.methodType(rtype, ptypes);\n+            }\n+        }\n+\n+        private void addDMHMethodType(String dmh, String methodType) {\n+            validateMethodType(methodType);\n+            Set<String> methodTypes = dmhMethods.get(dmh);\n+            if (methodTypes == null) {\n+                methodTypes = new TreeSet<>();\n+                dmhMethods.put(dmh, methodTypes);\n+            }\n+            methodTypes.add(methodType);\n+        }\n+\n+        private static void validateMethodType(String type) {\n+            String[] typeParts = type.split(\"_\");\n+            \/\/ check return type (second part)\n+            if (typeParts.length != 2 || typeParts[1].length() != 1\n+                    || !isBasicTypeChar(typeParts[1].charAt(0))) {\n+                throw new RuntimeException(\n+                        \"Method type signature must be of form [LJIFD]*_[LJIFDV]\");\n+            }\n+            \/\/ expand and check arguments (first part)\n+            expandSignature(typeParts[0]);\n+        }\n+\n+        \/\/ Convert LL -> LL, L3 -> LLL\n+        private static String expandSignature(String signature) {\n+            StringBuilder sb = new StringBuilder();\n+            char last = 'X';\n+            int count = 0;\n+            for (int i = 0; i < signature.length(); i++) {\n+                char c = signature.charAt(i);\n+                if (c >= '0' && c <= '9') {\n+                    count *= 10;\n+                    count += (c - '0');\n+                } else {\n+                    requireBasicType(c);\n+                    for (int j = 1; j < count; j++) {\n+                        sb.append(last);\n+                    }\n+                    sb.append(c);\n+                    last = c;\n+                    count = 0;\n+                }\n+            }\n+\n+            \/\/ ended with a number, e.g., \"L2\": append last char count - 1 times\n+            if (count > 1) {\n+                requireBasicType(last);\n+                for (int j = 1; j < count; j++) {\n+                    sb.append(last);\n+                }\n+            }\n+            return sb.toString();\n+        }\n+\n+        private static void requireBasicType(char c) {\n+            if (!isArgBasicTypeChar(c)) {\n+                throw new RuntimeException(\n+                        \"Character \" + c + \" must correspond to a basic field type: LIJFD\");\n+            }\n+        }\n+\n+        private static Class<?> simpleType(char c) {\n+            if (isBasicTypeChar(c)) {\n+                return LambdaForm.BasicType.basicType(c).basicTypeClass();\n+            }\n+            switch (c) {\n+                case 'Z':\n+                case 'B':\n+                case 'S':\n+                case 'C':\n+                    throw new IllegalArgumentException(\"Not a valid primitive: \" + c +\n+                            \" (use I instead)\");\n+                default:\n+                    throw new IllegalArgumentException(\"Not a primitive: \" + c);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Returns a map of class name in internal form to the corresponding class bytes\n+     * per the given stream of SPECIES_RESOLVE and LF_RESOLVE trace logs.\n+     *\n+     * Used by GenerateJLIClassesPlugin to pre-generate holder classes during\n+     * jlink phase.\n+     *\/\n+    static Map<String, byte[]> generateHolderClasses(Stream<String> traces)  {\n+        HolderClassBuilder builder = new HolderClassBuilder();\n+        traces.map(line -> line.split(\" \"))\n+                .forEach(parts -> {\n+                    switch (parts[0]) {\n+                        case SPECIES_RESOLVE:\n+                            \/\/ Allow for new types of species data classes being resolved here\n+                            assert parts.length == 3;\n+                            if (parts[1].startsWith(BMH_SPECIES_PREFIX)) {\n+                                String species = parts[1].substring(BMH_SPECIES_PREFIX.length());\n+                                if (!\"L\".equals(species)) {\n+                                    builder.addSpeciesType(species);\n+                                }\n+                            }\n+                            break;\n+                        case LF_RESOLVE:\n+                            assert parts.length > 3;\n+                            String methodType = parts[3];\n+                            if (parts[1].equals(INVOKERS_HOLDER_CLASS_NAME)) {\n+                                if (\"linkToTargetMethod\".equals(parts[2]) ||\n+                                        \"linkToCallSite\".equals(parts[2])) {\n+                                    builder.addCallSiteType(methodType);\n+                                } else {\n+                                    builder.addInvokerType(methodType);\n+                                }\n+                            } else if (parts[1].contains(\"DirectMethodHandle\")) {\n+                                String dmh = parts[2];\n+                                \/\/ ignore getObject etc for now (generated by default)\n+                                if (DMH_METHOD_TYPE_MAP.containsKey(dmh)) {\n+                                    builder.addDMHMethodType(dmh, methodType);\n+                                }\n+                            }\n+                            break;\n+                        default:\n+                            break; \/\/ ignore\n+                    }\n+                });\n+\n+        return builder.build();\n+    }\n+\n+    \/**\n+     * Returns a {@code byte[]} representation of a class implementing\n+     * the zero and identity forms of all {@code LambdaForm.BasicType}s.\n+     *\/\n@@ -71,0 +383,5 @@\n+    \/**\n+     * Returns a {@code byte[]} representation of a class implementing\n+     * DirectMethodHandle of each pairwise combination of {@code MethodType} and\n+     * an {@code int} representing method type.\n+     *\/\n@@ -118,0 +435,5 @@\n+    \/**\n+     * Returns a {@code byte[]} representation of a class implementing\n+     * DelegatingMethodHandles of each {@code MethodType} kind in the\n+     * {@code methodTypes} argument.\n+     *\/\n@@ -148,0 +470,5 @@\n+    \/**\n+     * Returns a {@code byte[]} representation of a class implementing\n+     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n+     * and {@code callSiteMethodTypes}.\n+     *\/\n@@ -196,4 +523,1 @@\n-    private static byte[] generateCodeBytesForLFs(String className,\n-            String[] names, LambdaForm[] forms) {\n-\n-\n+    private static byte[] generateCodeBytesForLFs(String className, String[] names, LambdaForm[] forms) {\n@@ -232,0 +556,4 @@\n+    \/**\n+     * Returns a {@code byte[]} representation of {@code BoundMethodHandle}\n+     * species class implementing the signature defined by {@code types}.\n+     *\/\n@@ -235,1 +563,1 @@\n-            if (\"LIJFD\".indexOf(c) < 0) {\n+            if (!isArgBasicTypeChar(c)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":336,"deletions":8,"binary":false,"changes":344,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import static java.lang.invoke.GenerateJLIClassesHelper.traceLambdaForm;\n@@ -325,1 +326,3 @@\n-            member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member, HOST_CLASS, ReflectiveOperationException.class);\n+            member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member,\n+                                                      HOST_CLASS, LM_TRUSTED,\n+                                                      ReflectiveOperationException.class);\n@@ -696,5 +699,2 @@\n-        MemberName resolvedMember = MemberName.getFactory().resolveOrNull(REF_invokeStatic, member, holder);\n-        if (TRACE_RESOLVE) {\n-            System.out.println(\"[LF_RESOLVE] \" + holder.getName() + \" \" + name + \" \" +\n-                    shortenSignature(basicTypeSignature(type)) + (resolvedMember != null ? \" (success)\" : \" (fail)\") );\n-        }\n+        MemberName resolvedMember = MemberName.getFactory().resolveOrNull(REF_invokeStatic, member, holder, LM_TRUSTED);\n+        traceLambdaForm(name, type, holder, resolvedMember);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -664,1 +664,1 @@\n-                        .resolveOrFail(REF_invokeStatic, member, Invokers.class, NoSuchMethodException.class));\n+                        .resolveOrFail(REF_invokeStatic, member, Invokers.class, LM_TRUSTED, NoSuchMethodException.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static java.lang.invoke.MethodHandleNatives.Constants.REF_invokeStatic;\n+import static java.lang.invoke.MethodHandleNatives.Constants.*;\n@@ -1761,1 +1761,1 @@\n-                idMem = IMPL_NAMES.resolveOrFail(REF_invokeStatic, idMem, null, NoSuchMethodException.class);\n+                idMem = IMPL_NAMES.resolveOrFail(REF_invokeStatic, idMem, null, LM_TRUSTED, NoSuchMethodException.class);\n@@ -1764,1 +1764,1 @@\n-                    zeMem = IMPL_NAMES.resolveOrFail(REF_invokeStatic, zeMem, null, NoSuchMethodException.class);\n+                    zeMem = IMPL_NAMES.resolveOrFail(REF_invokeStatic, zeMem, null, LM_TRUSTED, NoSuchMethodException.class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1067,1 +1067,1 @@\n-        private MemberName resolve(byte refKind, MemberName ref, Class<?> lookupClass,\n+        private MemberName resolve(byte refKind, MemberName ref, Class<?> lookupClass, int allowedModes,\n@@ -1087,1 +1087,1 @@\n-                m = MethodHandleNatives.resolve(m, lookupClass, speculativeResolve);\n+                m = MethodHandleNatives.resolve(m, lookupClass, allowedModes, speculativeResolve);\n@@ -1111,2 +1111,3 @@\n-                MemberName resolveOrFail(byte refKind, MemberName m, Class<?> lookupClass,\n-                                 Class<NoSuchMemberException> nsmClass)\n+                MemberName resolveOrFail(byte refKind, MemberName m,\n+                                         Class<?> lookupClass, int allowedModes,\n+                                         Class<NoSuchMemberException> nsmClass)\n@@ -1114,1 +1115,2 @@\n-            MemberName result = resolve(refKind, m, lookupClass, false);\n+            assert lookupClass != null || allowedModes == LM_TRUSTED;\n+            MemberName result = resolve(refKind, m, lookupClass, allowedModes, false);\n@@ -1127,2 +1129,3 @@\n-        public MemberName resolveOrNull(byte refKind, MemberName m, Class<?> lookupClass) {\n-            MemberName result = resolve(refKind, m, lookupClass, true);\n+        public MemberName resolveOrNull(byte refKind, MemberName m, Class<?> lookupClass, int allowedModes) {\n+            assert lookupClass != null || allowedModes == LM_TRUSTED;\n+            MemberName result = resolve(refKind, m, lookupClass, allowedModes, true);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1767,35 +1767,2 @@\n-            public byte[] generateDirectMethodHandleHolderClassBytes(\n-                    String className, MethodType[] methodTypes, int[] types) {\n-                return GenerateJLIClassesHelper\n-                        .generateDirectMethodHandleHolderClassBytes(\n-                                className, methodTypes, types);\n-            }\n-\n-            @Override\n-            public byte[] generateDelegatingMethodHandleHolderClassBytes(\n-                    String className, MethodType[] methodTypes) {\n-                return GenerateJLIClassesHelper\n-                        .generateDelegatingMethodHandleHolderClassBytes(\n-                                className, methodTypes);\n-            }\n-\n-            @Override\n-            public Map.Entry<String, byte[]> generateConcreteBMHClassBytes(\n-                    final String types) {\n-                return GenerateJLIClassesHelper\n-                        .generateConcreteBMHClassBytes(types);\n-            }\n-\n-            @Override\n-            public byte[] generateBasicFormsClassBytes(final String className) {\n-                return GenerateJLIClassesHelper\n-                        .generateBasicFormsClassBytes(className);\n-            }\n-\n-            @Override\n-            public byte[] generateInvokersHolderClassBytes(final String className,\n-                    MethodType[] invokerMethodTypes,\n-                    MethodType[] callSiteMethodTypes) {\n-                return GenerateJLIClassesHelper\n-                        .generateInvokersHolderClassBytes(className,\n-                                invokerMethodTypes, callSiteMethodTypes);\n+            public Map<String, byte[]> generateHolderClasses(Stream<String> traces) {\n+                return GenerateJLIClassesHelper.generateHolderClasses(traces);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":2,"deletions":35,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    static native MemberName resolve(MemberName self, Class<?> caller,\n+    static native MemberName resolve(MemberName self, Class<?> caller, int lookupMode,\n@@ -152,0 +152,9 @@\n+\n+        \/**\n+         * Lookup modes\n+         *\/\n+        static final int\n+            LM_MODULE        = Lookup.MODULE,\n+            LM_UNCONDITIONAL = Lookup.UNCONDITIONAL,\n+            LM_TRUSTED       = -1;\n+\n@@ -564,1 +573,1 @@\n-                                                           VarHandleGuards.class);\n+                                                           VarHandleGuards.class, LM_TRUSTED);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1412,8 +1412,1 @@\n-            if (allowedModes == TRUSTED) {\n-                return null;\n-            }\n-            if (allowedModes == UNCONDITIONAL) {\n-                \/\/ use Object as the caller to pass to VM doing resolution\n-                return Object.class;\n-            }\n-            return lookupClass;\n+            return (allowedModes == TRUSTED) ? null : lookupClass;\n@@ -3445,1 +3438,1 @@\n-            return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(),\n+            return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(), allowedModes,\n@@ -3454,1 +3447,1 @@\n-            return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(),\n+            return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(), allowedModes,\n@@ -3462,1 +3455,1 @@\n-            return IMPL_NAMES.resolveOrFail(refKind, member, lookupClassOrNull(),\n+            return IMPL_NAMES.resolveOrFail(refKind, member, lookupClassOrNull(), allowedModes,\n@@ -3473,1 +3466,1 @@\n-            return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());\n+            return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull(), allowedModes);\n@@ -3777,1 +3770,1 @@\n-                    m2 = IMPL_NAMES.resolveOrNull(refKind, m2, lookupClassOrNull());\n+                    m2 = IMPL_NAMES.resolveOrNull(refKind, m2, lookupClassOrNull(), allowedModes);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.stream.Stream;\n@@ -71,4 +72,4 @@\n-     * Returns a {@code byte[]} representation of a class implementing\n-     * DirectMethodHandle of each pairwise combination of {@code MethodType} and\n-     * an {@code int} representing method type.  Used by\n-     * GenerateJLIClassesPlugin to generate such a class during the jlink phase.\n+     * Returns a map of class name in internal forms to its corresponding\n+     * class bytes per the given stream of LF_RESOLVE and SPECIES_RESOLVE\n+     * trace logs. Used by GenerateJLIClassesPlugin to enable generation\n+     * of such classes during the jlink phase.\n@@ -76,36 +77,1 @@\n-    byte[] generateDirectMethodHandleHolderClassBytes(String className,\n-            MethodType[] methodTypes, int[] types);\n-\n-    \/**\n-     * Returns a {@code byte[]} representation of a class implementing\n-     * DelegatingMethodHandles of each {@code MethodType} kind in the\n-     * {@code methodTypes} argument.  Used by GenerateJLIClassesPlugin to\n-     * generate such a class during the jlink phase.\n-     *\/\n-    byte[] generateDelegatingMethodHandleHolderClassBytes(String className,\n-            MethodType[] methodTypes);\n-\n-    \/**\n-     * Returns a {@code byte[]} representation of {@code BoundMethodHandle}\n-     * species class implementing the signature defined by {@code types}. Used\n-     * by GenerateJLIClassesPlugin to enable generation of such classes during\n-     * the jlink phase. Should do some added validation since this string may be\n-     * user provided.\n-     *\/\n-    Map.Entry<String, byte[]> generateConcreteBMHClassBytes(\n-            final String types);\n-\n-    \/**\n-     * Returns a {@code byte[]} representation of a class implementing\n-     * the zero and identity forms of all {@code LambdaForm.BasicType}s.\n-     *\/\n-    byte[] generateBasicFormsClassBytes(final String className);\n-\n-    \/**\n-     * Returns a {@code byte[]} representation of a class implementing\n-     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n-     * and {@code callSiteMethodTypes}.\n-     *\/\n-    byte[] generateInvokersHolderClassBytes(String className,\n-            MethodType[] invokerMethodTypes,\n-            MethodType[] callSiteMethodTypes);\n+    Map<String, byte[]> generateHolderClasses(Stream<String> traces);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":6,"deletions":40,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,3 @@\n+                    } else {\n+                        throw new ClassCastException(\n+                                \"Keys and values in Properties must be Strings\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/xml\/PropertiesDefaultHandler.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,3 +110,3 @@\n-     * @exception IOException if an <code>IOException<\/code> occurs; an\n-     * <code>IOException<\/code> may occur if <code>obj<\/code> is not\n-     * serializable.\n+     * @throws IOException if an <code>IOException<\/code> occurs; an\n+     *         <code>IOException<\/code> may occur if <code>obj<\/code> is not\n+     *         serializable.\n@@ -164,6 +164,6 @@\n-     * @exception IOException if an <code>IOException<\/code> occurs while\n-     * deserializing the object from its internal representation.\n-     * @exception ClassNotFoundException if a\n-     * <code>ClassNotFoundException<\/code> occurs while deserializing the\n-     * object from its internal representation.\n-     * could not be found\n+     * @throws IOException if an <code>IOException<\/code> occurs while\n+     *         deserializing the object from its internal representation.\n+     * @throws ClassNotFoundException if a\n+     *         <code>ClassNotFoundException<\/code> occurs while deserializing\n+     *         the object from its internal representation.\n+     *         could not be found\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/MarshalledObject.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,4 +84,4 @@\n-     * @exception NotBoundException if name is not currently bound\n-     * @exception RemoteException if registry could not be contacted\n-     * @exception AccessException if this operation is not permitted\n-     * @exception MalformedURLException if the name is not an appropriately\n+     * @throws NotBoundException if name is not currently bound\n+     * @throws RemoteException if registry could not be contacted\n+     * @throws AccessException if this operation is not permitted\n+     * @throws MalformedURLException if the name is not an appropriately\n@@ -109,6 +109,6 @@\n-     * @exception AlreadyBoundException if name is already bound\n-     * @exception MalformedURLException if the name is not an appropriately\n-     *  formatted URL\n-     * @exception RemoteException if registry could not be contacted\n-     * @exception AccessException if this operation is not permitted (if\n-     * originating from a non-local host, for example)\n+     * @throws AlreadyBoundException if name is already bound\n+     * @throws MalformedURLException if the name is not an appropriately\n+     *         formatted URL\n+     * @throws RemoteException if registry could not be contacted\n+     * @throws AccessException if this operation is not permitted (if\n+     *         originating from a non-local host, for example)\n@@ -136,6 +136,6 @@\n-     * @exception NotBoundException if name is not currently bound\n-     * @exception MalformedURLException if the name is not an appropriately\n-     *  formatted URL\n-     * @exception RemoteException if registry could not be contacted\n-     * @exception AccessException if this operation is not permitted (if\n-     * originating from a non-local host, for example)\n+     * @throws NotBoundException if name is not currently bound\n+     * @throws MalformedURLException if the name is not an appropriately\n+     *         formatted URL\n+     * @throws RemoteException if registry could not be contacted\n+     * @throws AccessException if this operation is not permitted (if\n+     *         originating from a non-local host, for example)\n@@ -161,5 +161,5 @@\n-     * @exception MalformedURLException if the name is not an appropriately\n-     *  formatted URL\n-     * @exception RemoteException if registry could not be contacted\n-     * @exception AccessException if this operation is not permitted (if\n-     * originating from a non-local host, for example)\n+     * @throws MalformedURLException if the name is not an appropriately\n+     *         formatted URL\n+     * @throws RemoteException if registry could not be contacted\n+     * @throws AccessException if this operation is not permitted (if\n+     *         originating from a non-local host, for example)\n@@ -190,3 +190,3 @@\n-     * @exception MalformedURLException if the name is not an appropriately\n-     *  formatted URL\n-     * @exception RemoteException if registry could not be contacted.\n+     * @throws MalformedURLException if the name is not an appropriately\n+     *         formatted URL\n+     * @throws RemoteException if registry could not be contacted.\n@@ -231,1 +231,1 @@\n-     * @exception MalformedURLException if given url string is malformed\n+     * @throws MalformedURLException if given url string is malformed\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/Naming.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1078,1 +1078,1 @@\n-                            log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);\n+                            log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor(env.enclClass.sym));\n@@ -5055,1 +5055,1 @@\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));\n+                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n@@ -5068,1 +5068,3 @@\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));\n+                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                    Errors.ClassInUnnamedModuleCantExtendSealedInDiffPackage(c)\n+                            );\n@@ -5071,1 +5073,3 @@\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));\n+                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                Errors.ClassInModuleCantExtendSealedInDiffModule(c, c.packge().modle)\n+                        );\n@@ -5110,1 +5114,1 @@\n-                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed);\n+                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed(c.isAnonymous() ? Fragments.Anonymous : Fragments.Local));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3390,0 +3390,3 @@\n+            } else if (target == names.MODULE) {\n+                if (s.kind == MDL)\n+                    applicableTargets.add(names.MODULE);\n@@ -3518,1 +3521,2 @@\n-                && (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)) {\n+                && (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)\n+                && s.kind != Kind.PCK) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3492,1 +3492,1 @@\n-                checkNoMods(mods.flags);\n+                checkNoMods(mods.flags & ~Flags.DEPRECATED);\n@@ -3803,1 +3803,2 @@\n-                                .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags & Flags.VARARGS, param.mods.annotations),\n+                                .VarDef(F.Modifiers(Flags.PARAMETER | Flags.GENERATED_MEMBER | param.mods.flags & Flags.VARARGS,\n+                                        param.mods.annotations),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3492,1 +3492,10 @@\n-    class is not allowed to extend sealed class: {0}\n+    class is not allowed to extend sealed class: {0} \\\n+    (as it is not listed in its 'permits' clause)\n+\n+# 0: symbol\n+compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package=\\\n+    class {0} in unnamed module cannot extend a sealed class in a different package\n+\n+# 0: symbol, 1: symbol\n+compiler.err.class.in.module.cant.extend.sealed.in.diff.module=\\\n+    class {0} in module {1} cannot extend a sealed class in a different module\n@@ -3508,0 +3517,1 @@\n+# 0: fragment\n@@ -3509,1 +3519,7 @@\n-    local classes must not extend sealed classes\n+    {0} classes must not extend sealed classes\\\n+\n+compiler.misc.anonymous=\\\n+    anonymous\n+\n+compiler.misc.local=\\\n+    local\n@@ -3591,0 +3607,1 @@\n+# 0: symbol\n@@ -3592,1 +3609,1 @@\n-    constructor is not canonical, so its first statement must invoke another constructor\n+    constructor is not canonical, so its first statement must invoke another constructor of class {0}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -428,0 +428,4 @@\n+                            \"java\/lang\/Math.copySign(DD)D\",\n+                            \"java\/lang\/Math.copySign(FF)F\",\n+                            \"java\/lang\/Math.signum(D)D\",\n+                            \"java\/lang\/Math.signum(F)F\",\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot.test\/src\/org\/graalvm\/compiler\/hotspot\/test\/CheckGraalIntrinsics.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.invoke.MethodType;\n@@ -37,2 +36,0 @@\n-import java.util.TreeMap;\n-import java.util.TreeSet;\n@@ -75,15 +72,0 @@\n-    private static final String DIRECT_HOLDER = \"java\/lang\/invoke\/DirectMethodHandle$Holder\";\n-    private static final String DMH_INVOKE_VIRTUAL = \"invokeVirtual\";\n-    private static final String DMH_INVOKE_STATIC = \"invokeStatic\";\n-    private static final String DMH_INVOKE_SPECIAL = \"invokeSpecial\";\n-    private static final String DMH_NEW_INVOKE_SPECIAL = \"newInvokeSpecial\";\n-    private static final String DMH_INVOKE_INTERFACE = \"invokeInterface\";\n-    private static final String DMH_INVOKE_STATIC_INIT = \"invokeStaticInit\";\n-    private static final String DMH_INVOKE_SPECIAL_IFC = \"invokeSpecialIFC\";\n-\n-    private static final String DELEGATING_HOLDER = \"java\/lang\/invoke\/DelegatingMethodHandle$Holder\";\n-    private static final String BASIC_FORMS_HOLDER = \"java\/lang\/invoke\/LambdaForm$Holder\";\n-\n-    private static final String INVOKERS_HOLDER_NAME = \"java.lang.invoke.Invokers$Holder\";\n-    private static final String INVOKERS_HOLDER_INTERNAL_NAME = INVOKERS_HOLDER_NAME.replace('.', '\/');\n-\n@@ -93,9 +75,2 @@\n-    private final TreeSet<String> speciesTypes = new TreeSet<>();\n-\n-    private final TreeSet<String> invokerTypes = new TreeSet<>();\n-\n-    private final TreeSet<String> callSiteTypes = new TreeSet<>();\n-\n-    private final Map<String, Set<String>> dmhMethods = new TreeMap<>();\n-\n-    String mainArgument;\n+    private String mainArgument;\n+    private Stream<String> traceFileStream;\n@@ -131,16 +106,0 @@\n-    private static int DMH_INVOKE_VIRTUAL_TYPE = 0;\n-    private static int DMH_INVOKE_INTERFACE_TYPE = 4;\n-\n-    \/\/ Map from DirectMethodHandle method type to internal ID, matching values\n-    \/\/ of the corresponding constants in java.lang.invoke.MethodTypeForm\n-    private static final Map<String, Integer> DMH_METHOD_TYPE_MAP =\n-            Map.of(\n-                DMH_INVOKE_VIRTUAL,     DMH_INVOKE_VIRTUAL_TYPE,\n-                DMH_INVOKE_STATIC,      1,\n-                DMH_INVOKE_SPECIAL,     2,\n-                DMH_NEW_INVOKE_SPECIAL, 3,\n-                DMH_INVOKE_INTERFACE,   DMH_INVOKE_INTERFACE_TYPE,\n-                DMH_INVOKE_STATIC_INIT, 5,\n-                DMH_INVOKE_SPECIAL_IFC, 20\n-            );\n-\n@@ -152,14 +111,0 @@\n-    private void addSpeciesType(String type) {\n-        speciesTypes.add(expandSignature(type));\n-    }\n-\n-    private void addInvokerType(String methodType) {\n-        validateMethodType(methodType);\n-        invokerTypes.add(methodType);\n-    }\n-\n-    private void addCallSiteType(String csType) {\n-        validateMethodType(csType);\n-        callSiteTypes.add(csType);\n-    }\n-\n@@ -173,3 +118,1 @@\n-                    readTraceConfig(\n-                        new BufferedReader(\n-                            new InputStreamReader(traceFile)).lines());\n+                    traceFileStream = new BufferedReader(new InputStreamReader(traceFile)).lines();\n@@ -183,1 +126,1 @@\n-                readTraceConfig(fileLines(file));\n+                traceFileStream = fileLines(file);\n@@ -188,46 +131,0 @@\n-    private void readTraceConfig(Stream<String> lines) {\n-        lines.map(line -> line.split(\" \"))\n-             .forEach(parts -> {\n-                switch (parts[0]) {\n-                    case \"[SPECIES_RESOLVE]\":\n-                        \/\/ Allow for new types of species data classes being resolved here\n-                        if (parts.length == 3 && parts[1].startsWith(\"java.lang.invoke.BoundMethodHandle$Species_\")) {\n-                            String species = parts[1].substring(\"java.lang.invoke.BoundMethodHandle$Species_\".length());\n-                            if (!\"L\".equals(species)) {\n-                                addSpeciesType(species);\n-                            }\n-                        }\n-                        break;\n-                    case \"[LF_RESOLVE]\":\n-                        String methodType = parts[3];\n-                        if (parts[1].equals(INVOKERS_HOLDER_NAME)) {\n-                            if (\"linkToTargetMethod\".equals(parts[2]) ||\n-                                    \"linkToCallSite\".equals(parts[2])) {\n-                                addCallSiteType(methodType);\n-                            } else {\n-                                addInvokerType(methodType);\n-                            }\n-                        } else if (parts[1].contains(\"DirectMethodHandle\")) {\n-                            String dmh = parts[2];\n-                            \/\/ ignore getObject etc for now (generated\n-                            \/\/ by default)\n-                            if (DMH_METHOD_TYPE_MAP.containsKey(dmh)) {\n-                                addDMHMethodType(dmh, methodType);\n-                            }\n-                        }\n-                        break;\n-                    default: break; \/\/ ignore\n-                }\n-            });\n-    }\n-\n-    private void addDMHMethodType(String dmh, String methodType) {\n-        validateMethodType(methodType);\n-        Set<String> methodTypes = dmhMethods.get(dmh);\n-        if (methodTypes == null) {\n-            methodTypes = new TreeSet<>();\n-            dmhMethods.put(dmh, methodTypes);\n-        }\n-        methodTypes.add(methodType);\n-    }\n-\n@@ -242,19 +139,0 @@\n-    private void validateMethodType(String type) {\n-        String[] typeParts = type.split(\"_\");\n-        \/\/ check return type (second part)\n-        if (typeParts.length != 2 || typeParts[1].length() != 1\n-                || \"LJIFDV\".indexOf(typeParts[1].charAt(0)) == -1) {\n-            throw new PluginException(\n-                    \"Method type signature must be of form [LJIFD]*_[LJIFDV]\");\n-        }\n-        \/\/ expand and check arguments (first part)\n-        expandSignature(typeParts[0]);\n-    }\n-\n-    private static void requireBasicType(char c) {\n-        if (\"LIJFD\".indexOf(c) < 0) {\n-            throw new PluginException(\n-                    \"Character \" + c + \" must correspond to a basic field type: LIJFD\");\n-        }\n-    }\n-\n@@ -278,83 +156,11 @@\n-        \/\/ Generate BMH Species classes\n-        speciesTypes.forEach(types -> generateBMHClass(types, out));\n-\n-        \/\/ Generate LambdaForm Holder classes\n-        generateHolderClasses(out);\n-\n-        \/\/ Let it go\n-        speciesTypes.clear();\n-        invokerTypes.clear();\n-        callSiteTypes.clear();\n-        dmhMethods.clear();\n-\n-        return out.build();\n-    }\n-\n-    private void generateBMHClass(String types, ResourcePoolBuilder out) {\n-        try {\n-            \/\/ Generate class\n-            Map.Entry<String, byte[]> result =\n-                    JLIA.generateConcreteBMHClassBytes(types);\n-            String className = result.getKey();\n-            byte[] bytes = result.getValue();\n-\n-            \/\/ Add class to pool\n-            ResourcePoolEntry ndata = ResourcePoolEntry.create(\n-                    \"\/java.base\/\" + className + \".class\",\n-                    bytes);\n-            out.add(ndata);\n-        } catch (Exception ex) {\n-            throw new PluginException(ex);\n-        }\n-    }\n-\n-    private void generateHolderClasses(ResourcePoolBuilder out) {\n-        int count = 0;\n-        for (Set<String> entry : dmhMethods.values()) {\n-            count += entry.size();\n-        }\n-        MethodType[] directMethodTypes = new MethodType[count];\n-        int[] dmhTypes = new int[count];\n-        int index = 0;\n-        for (Map.Entry<String, Set<String>> entry : dmhMethods.entrySet()) {\n-            String dmhType = entry.getKey();\n-            for (String type : entry.getValue()) {\n-                \/\/ The DMH type to actually ask for is retrieved by removing\n-                \/\/ the first argument, which needs to be of Object.class\n-                MethodType mt = asMethodType(type);\n-                if (mt.parameterCount() < 1 ||\n-                    mt.parameterType(0) != Object.class) {\n-                    throw new PluginException(\n-                            \"DMH type parameter must start with L: \" + dmhType + \" \" + type);\n-                }\n-\n-                \/\/ Adapt the method type of the LF to retrieve\n-                directMethodTypes[index] = mt.dropParameterTypes(0, 1);\n-\n-                \/\/ invokeVirtual and invokeInterface must have a leading Object\n-                \/\/ parameter, i.e., the receiver\n-                dmhTypes[index] = DMH_METHOD_TYPE_MAP.get(dmhType);\n-                if (dmhTypes[index] == DMH_INVOKE_INTERFACE_TYPE ||\n-                    dmhTypes[index] == DMH_INVOKE_VIRTUAL_TYPE) {\n-                    if (mt.parameterCount() < 2 ||\n-                        mt.parameterType(1) != Object.class) {\n-                        throw new PluginException(\n-                                \"DMH type parameter must start with LL: \" + dmhType + \" \" + type);\n-                    }\n-                }\n-                index++;\n-            }\n-        }\n-\n-        \/\/ The invoker type to ask for is retrieved by removing the first\n-        \/\/ and the last argument, which needs to be of Object.class\n-        MethodType[] invokerMethodTypes = new MethodType[this.invokerTypes.size()];\n-        int i = 0;\n-        for (String invokerType : invokerTypes) {\n-            MethodType mt = asMethodType(invokerType);\n-            final int lastParam = mt.parameterCount() - 1;\n-            if (mt.parameterCount() < 2 ||\n-                    mt.parameterType(0) != Object.class ||\n-                    mt.parameterType(lastParam) != Object.class) {\n-                throw new PluginException(\n-                        \"Invoker type parameter must start and end with Object: \" + invokerType);\n+        \/\/ Generate Holder classes\n+        if (traceFileStream != null) {\n+            try {\n+                JLIA.generateHolderClasses(traceFileStream)\n+                    .forEach((cn, bytes) -> {\n+                        String entryName = \"\/java.base\/\" + cn + \".class\";\n+                        ResourcePoolEntry ndata = ResourcePoolEntry.create(entryName, bytes);\n+                        out.add(ndata);\n+                    });\n+            } catch (Exception ex) {\n+                throw new PluginException(ex);\n@@ -362,42 +168,0 @@\n-            mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n-            invokerMethodTypes[i] = mt.dropParameterTypes(0, 1);\n-            i++;\n-        }\n-\n-        \/\/ The callSite type to ask for is retrieved by removing the last\n-        \/\/ argument, which needs to be of Object.class\n-        MethodType[] callSiteMethodTypes = new MethodType[this.callSiteTypes.size()];\n-        i = 0;\n-        for (String callSiteType : callSiteTypes) {\n-            MethodType mt = asMethodType(callSiteType);\n-            final int lastParam = mt.parameterCount() - 1;\n-            if (mt.parameterCount() < 1 ||\n-                    mt.parameterType(lastParam) != Object.class) {\n-                throw new PluginException(\n-                        \"CallSite type parameter must end with Object: \" + callSiteType);\n-            }\n-            callSiteMethodTypes[i] = mt.dropParameterTypes(lastParam, lastParam + 1);\n-            i++;\n-        }\n-        try {\n-            byte[] bytes = JLIA.generateDirectMethodHandleHolderClassBytes(\n-                    DIRECT_HOLDER, directMethodTypes, dmhTypes);\n-            ResourcePoolEntry ndata = ResourcePoolEntry\n-                    .create(DIRECT_METHOD_HOLDER_ENTRY, bytes);\n-            out.add(ndata);\n-\n-            bytes = JLIA.generateDelegatingMethodHandleHolderClassBytes(\n-                    DELEGATING_HOLDER, directMethodTypes);\n-            ndata = ResourcePoolEntry.create(DELEGATING_METHOD_HOLDER_ENTRY, bytes);\n-            out.add(ndata);\n-\n-            bytes = JLIA.generateInvokersHolderClassBytes(INVOKERS_HOLDER_INTERNAL_NAME,\n-                    invokerMethodTypes, callSiteMethodTypes);\n-            ndata = ResourcePoolEntry.create(INVOKERS_HOLDER_ENTRY, bytes);\n-            out.add(ndata);\n-\n-            bytes = JLIA.generateBasicFormsClassBytes(BASIC_FORMS_HOLDER);\n-            ndata = ResourcePoolEntry.create(BASIC_FORMS_HOLDER_ENTRY, bytes);\n-            out.add(ndata);\n-        } catch (Exception ex) {\n-            throw new PluginException(ex);\n@@ -405,0 +169,1 @@\n+        return out.build();\n@@ -406,0 +171,1 @@\n+\n@@ -407,1 +173,1 @@\n-            \"\/java.base\/\" + DIRECT_HOLDER + \".class\";\n+            \"\/java.base\/java\/lang\/invoke\/DirectMethodHandle$Holder.class\";\n@@ -409,1 +175,1 @@\n-            \"\/java.base\/\" + DELEGATING_HOLDER + \".class\";\n+            \"\/java.base\/java\/lang\/invoke\/DelegatingMethodHandle$Holder.class\";\n@@ -411,1 +177,1 @@\n-            \"\/java.base\/\" + BASIC_FORMS_HOLDER + \".class\";\n+            \"\/java.base\/java\/lang\/invoke\/LambdaForm$Holder.class\";\n@@ -413,74 +179,1 @@\n-            \"\/java.base\/\" + INVOKERS_HOLDER_INTERNAL_NAME + \".class\";\n-\n-    \/\/ Convert LL -> LL, L3 -> LLL\n-    public static String expandSignature(String signature) {\n-        StringBuilder sb = new StringBuilder();\n-        char last = 'X';\n-        int count = 0;\n-        for (int i = 0; i < signature.length(); i++) {\n-            char c = signature.charAt(i);\n-            if (c >= '0' && c <= '9') {\n-                count *= 10;\n-                count += (c - '0');\n-            } else {\n-                requireBasicType(c);\n-                for (int j = 1; j < count; j++) {\n-                    sb.append(last);\n-                }\n-                sb.append(c);\n-                last = c;\n-                count = 0;\n-            }\n-        }\n-\n-        \/\/ ended with a number, e.g., \"L2\": append last char count - 1 times\n-        if (count > 1) {\n-            requireBasicType(last);\n-            for (int j = 1; j < count; j++) {\n-                sb.append(last);\n-            }\n-        }\n-        return sb.toString();\n-    }\n-\n-    private static MethodType asMethodType(String basicSignatureString) {\n-        String[] parts = basicSignatureString.split(\"_\");\n-        assert(parts.length == 2);\n-        assert(parts[1].length() == 1);\n-        String parameters = expandSignature(parts[0]);\n-        Class<?> rtype = simpleType(parts[1].charAt(0));\n-        if (parameters.isEmpty()) {\n-            return MethodType.methodType(rtype);\n-        } else {\n-            Class<?>[] ptypes = new Class<?>[parameters.length()];\n-            for (int i = 0; i < ptypes.length; i++) {\n-                ptypes[i] = simpleType(parameters.charAt(i));\n-            }\n-            return MethodType.methodType(rtype, ptypes);\n-        }\n-    }\n-\n-    private static Class<?> simpleType(char c) {\n-        switch (c) {\n-            case 'F':\n-                return float.class;\n-            case 'D':\n-                return double.class;\n-            case 'I':\n-                return int.class;\n-            case 'L':\n-                return Object.class;\n-            case 'J':\n-                return long.class;\n-            case 'V':\n-                return void.class;\n-            case 'Z':\n-            case 'B':\n-            case 'S':\n-            case 'C':\n-                throw new IllegalArgumentException(\"Not a valid primitive: \" + c +\n-                        \" (use I instead)\");\n-            default:\n-                throw new IllegalArgumentException(\"Not a primitive: \" + c);\n-        }\n-    }\n+            \"\/java.base\/java\/lang\/invoke\/Invokers$Holder.class\";\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/GenerateJLIClassesPlugin.java","additions":21,"deletions":328,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+* Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2020, Arm Limited. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+\/**\n+ * @test\n+ *\n+ * @requires os.arch == \"aarch64\" & vm.compiler2.enabled\n+ * @summary Verify VM SVE checking behavior\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native compiler.c2.aarch64.TestSVEWithJNI\n+ *\n+ *\/\n+\n+package compiler.c2.aarch64;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestSVEWithJNI {\n+    static {\n+        System.loadLibrary(\"TestSVEWithJNI\");\n+    }\n+\n+    static final int EXIT_CODE = 99;\n+    \/\/ Returns a nonnegative on success, or a negative value on error.\n+    public static native int setVectorLength(int arg);\n+    \/\/ Returns a nonnegative value on success, or a negative value on error.\n+    public static native int getVectorLength();\n+\n+    public static final String MSG = \"Current Vector Size: \";\n+    public static void testNormal() {\n+        int vlen = getVectorLength();\n+        System.out.println(MSG + vlen);\n+        \/\/ Should be fine if no vector length changed.\n+        if (setVectorLength(vlen) < 0) {\n+            throw new Error(\"Error in setting vector length.\");\n+        }\n+    }\n+\n+    public static void testAbort() {\n+        int vlen = getVectorLength();\n+        if (vlen <= 16) {\n+            throw new Error(\"Error: unsupported vector length.\");\n+        }\n+        if (setVectorLength(16) < 0) {\n+            throw new Error(\"Error: setting vector length failed.\");\n+        }\n+    }\n+\n+    public static ProcessBuilder createProcessBuilder(String [] args, String mode) {\n+        List<String> vmopts = new ArrayList<>();\n+        String testjdkPath = System.getProperty(\"test.jdk\");\n+        Collections.addAll(vmopts, \"-Dtest.jdk=\" + testjdkPath);\n+        Collections.addAll(vmopts, args);\n+        Collections.addAll(vmopts, TestSVEWithJNI.class.getName(), mode);\n+        return ProcessTools.createJavaProcessBuilder(vmopts.toArray(new String[vmopts.size()]));\n+    }\n+\n+    public static void main(String [] args) throws Exception {\n+        if (args.length == 0) {\n+            int vlen = getVectorLength();\n+            if (vlen < 0) {\n+                return;\n+            }\n+            String [][] testOpts = {\n+                {\"-Xint\", \"-XX:UseSVE=1\"},\n+                {\"-Xcomp\", \"-XX:UseSVE=1\"},\n+            };\n+            ProcessBuilder pb;\n+            OutputAnalyzer output;\n+            for (String [] opts : testOpts) {\n+                pb = createProcessBuilder(opts, \"normal\");\n+                output = new OutputAnalyzer(pb.start());\n+                output.shouldHaveExitValue(EXIT_CODE);\n+\n+                pb = createProcessBuilder(opts, \"abort\");\n+                output = new OutputAnalyzer(pb.start());\n+                output.shouldNotHaveExitValue(EXIT_CODE);\n+                output.shouldMatch(\"(error|Error|ERROR)\");\n+            }\n+\n+            \/\/ Verify MaxVectorSize\n+\n+            \/\/ Any SVE architecture should support 128-bit vector size.\n+            pb = createProcessBuilder(new String []{\"-XX:UseSVE=1\", \"-XX:MaxVectorSize=16\"}, \"normal\");\n+            output = new OutputAnalyzer(pb.start());\n+            output.shouldHaveExitValue(EXIT_CODE);\n+            output.shouldContain(MSG + 16);\n+\n+            \/\/ An unsupported large vector size value.\n+            pb = createProcessBuilder(new String []{\"-XX:UseSVE=1\", \"-XX:MaxVectorSize=512\"}, \"normal\");\n+            output = new OutputAnalyzer(pb.start());\n+            output.shouldHaveExitValue(EXIT_CODE);\n+            output.shouldContain(\"warning\");\n+        } else if (args[0].equals(\"normal\")) {\n+            testNormal();\n+            System.exit(EXIT_CODE);\n+        } else if (args[0].equals(\"abort\")) {\n+            testAbort();\n+            System.exit(EXIT_CODE);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestSVEWithJNI.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+* Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2020, Arm Limited. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifdef __aarch64__\n+\n+#include <jni.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <sys\/prctl.h>\n+#include <unistd.h>\n+\n+#ifndef PR_SVE_GET_VL\n+\/\/ For old toolchains which do not have SVE related macros defined.\n+#define PR_SVE_SET_VL   50\n+#define PR_SVE_GET_VL   51\n+#endif\n+\n+int get_current_thread_vl() {\n+  return prctl(PR_SVE_GET_VL);\n+}\n+\n+int set_current_thread_vl(unsigned long arg) {\n+  return prctl(PR_SVE_SET_VL, arg);\n+}\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+JNIEXPORT jint JNICALL Java_compiler_c2_aarch64_TestSVEWithJNI_setVectorLength\n+(JNIEnv * env, jclass clz, jint length) {\n+  return set_current_thread_vl(length);\n+}\n+\n+JNIEXPORT jint JNICALL Java_compiler_c2_aarch64_TestSVEWithJNI_getVectorLength\n+(JNIEnv *env, jclass clz) {\n+  return get_current_thread_vl();\n+}\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/libTestSVEWithJNI.c","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test compiler intrinsics for signum\n+ * @requires os.arch==\"aarch64\"\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+UseSignumIntrinsic\n+ *      compiler.intrinsics.math.TestSignumIntrinsic\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:-UseSignumIntrinsic -XX:+UseCopySignIntrinsic\n+ *      compiler.intrinsics.math.TestSignumIntrinsic\n+ *\/\n+\n+package compiler.intrinsics.math;\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestSignumIntrinsic {\n+\n+    private static final float[][] float_cases = {\n+        {123.4f,                       1.0f},\n+        {-56.7f,                      -1.0f},\n+        {7e30f,                        1.0f},\n+        {-0.3e30f,                    -1.0f},\n+        {Float.MAX_VALUE,              1.0f},\n+        {-Float.MAX_VALUE,            -1.0f},\n+        {Float.MIN_VALUE,              1.0f},\n+        {-Float.MIN_VALUE,            -1.0f},\n+        {0.0f,                         0.0f},\n+        {-0.0f,                       -0.0f},\n+        {Float.POSITIVE_INFINITY,      1.0f},\n+        {Float.NEGATIVE_INFINITY,     -1.0f},\n+        {Float.NaN,               Float.NaN},\n+        {Float.MIN_NORMAL,             1.0f},\n+        {-Float.MIN_NORMAL,           -1.0f},\n+        {0x0.0002P-126f,               1.0f},\n+        {-0x0.0002P-126f,             -1.0f}\n+    };\n+\n+    private static final double[][] double_cases = {\n+        {123.4d,                         1.0d},\n+        {-56.7d,                        -1.0d},\n+        {7e30d,                          1.0d},\n+        {-0.3e30d,                      -1.0d},\n+        {Double.MAX_VALUE,               1.0d},\n+        {-Double.MAX_VALUE,             -1.0d},\n+        {Double.MIN_VALUE,               1.0d},\n+        {-Double.MIN_VALUE,             -1.0d},\n+        {0.0d,                           0.0d},\n+        {-0.0d,                         -0.0d},\n+        {Double.POSITIVE_INFINITY,       1.0d},\n+        {Double.NEGATIVE_INFINITY,      -1.0d},\n+        {Double.NaN,               Double.NaN},\n+        {Double.MIN_NORMAL,              1.0d},\n+        {-Double.MIN_NORMAL,            -1.0d},\n+        {0x0.00000001P-1022,             1.0d},\n+        {-0x0.00000001P-1022,           -1.0d}\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        float fAccum = 0.0f;\n+        double dAccum = 0.0d;\n+        for (int i = 0; i < 100_000; i++) {\n+            fAccum += floatTest();\n+            dAccum += doubleTest();\n+        }\n+        System.out.println(\"SUCCESS. Accum values: \" + fAccum + \" and \" + dAccum);\n+    }\n+\n+    private static float floatTest() {\n+        float accum = 0.0f;\n+        for (float[] fcase : float_cases) {\n+            float arg = fcase[0];\n+            float expected = fcase[1];\n+            float calculated = Math.signum(arg);\n+            Asserts.assertEQ(expected, calculated, \"Unexpected float result\");\n+            accum += calculated;\n+        }\n+        return accum;\n+    }\n+\n+    private static double doubleTest() {\n+        double accum = 0.0d;\n+        for (double[] dcase : double_cases) {\n+            double arg = dcase[0];\n+            double expected = dcase[1];\n+            double calculated = Math.signum(arg);\n+            Asserts.assertEQ(expected, calculated, \"Unexpected double result\");\n+            accum += calculated;\n+        }\n+        return accum;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestSignumIntrinsic.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -92,2 +92,2 @@\n-    private String cgroupV2LineHybrid = \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 cgroup2 rw,seclabel,nsdelegate\\n\";\n-    private String cgroupv1MountInfoLineMemory = \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup cgroup rw,seclabel,memory\\n\";\n+    private String cgroupV2LineHybrid = \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 none rw,seclabel,nsdelegate\\n\";\n+    private String cgroupv1MountInfoLineMemory = \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup none rw,seclabel,memory\\n\";\n@@ -96,10 +96,10 @@\n-            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup cgroup rw,seclabel,xattr,name=systemd\\n\" +\n-            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup cgroup rw,seclabel,pids\\n\" +\n-            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup cgroup rw,seclabel,perf_event\\n\" +\n-            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup cgroup rw,seclabel,net_cls,net_prio\\n\" +\n-            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,seclabel,hugetlb\\n\" +\n-            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\\n\" +\n-            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup cgroup rw,seclabel,devices\\n\" +\n-            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup cgroup rw,seclabel,cpuset\\n\" +\n-            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,seclabel,blkio\\n\" +\n-            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,freezer\";\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup none rw,seclabel,xattr,name=systemd\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup none rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup none rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup none rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup none rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup none rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup none rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup none rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup none rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup none rw,seclabel,freezer\";\n@@ -125,1 +125,1 @@\n-            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 cgroup2 rw,seclabel,nsdelegate\";\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 none rw,seclabel,nsdelegate\";\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-# disabled till JDK-8252004 is fixed\n-allowSmartActionArgs=false\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/TEST.properties","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -49,1 +49,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree001\/btree001.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree002\/btree002.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree003\/btree003.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree004\/btree004.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree005\/btree005.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree006\/btree006.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree007\/btree007.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree008\/btree008.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree009\/btree009.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree010\/btree010.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree011\/btree011.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree012\/btree012.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain001\/chain001.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain002\/chain002.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain003\/chain003.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain004\/chain004.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain005\/chain005.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain006\/chain006.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain007\/chain007.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n- *      PropertyResolvingWrapper\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/chain\/chain008\/chain008.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n- * @run driver jdk.test.lib.FileInstaller . .\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/optimizations\/partialpeel\/Do\/TestDescription.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n- * @run driver jdk.test.lib.FileInstaller . .\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/optimizations\/partialpeel\/ForWhile\/TestDescription.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n- * @run driver jdk.test.lib.FileInstaller . .\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/optimizations\/partialpeel\/While\/TestDescription.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n- * @run driver jdk.test.lib.FileInstaller . .\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/compiler\/optimizations\/partialpeel\/WhileWhile\/TestDescription.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-# disabled till JDK-8251997 is fixed\n-allowSmartActionArgs=false\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/TEST.properties","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -24,1 +24,0 @@\n-\n@@ -46,1 +45,1 @@\n- * @run main\/othervm PropertyResolvingWrapper\n+ * @run main\/othervm\n@@ -78,0 +77,1 @@\n+\n@@ -81,1 +81,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/indy\/func\/jdi\/breakpoint\/Test.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-\n@@ -52,1 +51,1 @@\n- * @run main\/othervm PropertyResolvingWrapper\n+ * @run main\/othervm\n@@ -74,1 +73,0 @@\n-\n@@ -103,0 +101,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/indy\/func\/jdi\/breakpointOtherStratum\/Test.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-\n@@ -32,1 +31,2 @@\n- *     Execute an invokedynamic instruction 10000 times to trigger Hotspot compilation. Set a debugger breakpoint to invokedynamic instruction.\n+ *     Execute an invokedynamic instruction 10000 times to trigger Hotspot compilation.\n+ *     Set a debugger breakpoint to invokedynamic instruction.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm PropertyResolvingWrapper\n+ * @run main\/othervm\n@@ -67,1 +67,1 @@\n-    \/\/  bootstrap,runDebuggee=>(indyWrapper:S5000,~target,stop)\n+    \/\/ bootstrap,runDebuggee=>(indyWrapper:S5000,~target,stop)\n@@ -69,1 +69,1 @@\n-    protected List<BreakpointInfo> getBreakpoints(String debuggeeClassName)  {\n+    protected List<BreakpointInfo> getBreakpoints(String debuggeeClassName) {\n@@ -91,0 +91,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/indy\/stress\/jdi\/breakpointInCompiledCode\/Test.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-\n@@ -46,1 +45,1 @@\n- * @run main\/othervm PropertyResolvingWrapper\n+ * @run main\/othervm\n@@ -61,1 +60,0 @@\n-import vm.mlvm.share.jpda.StratumInfo;\n@@ -88,1 +86,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/func\/jdi\/breakpoint\/Test.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-\n@@ -52,1 +51,1 @@\n- * @run main\/othervm PropertyResolvingWrapper\n+ * @run main\/othervm\n@@ -73,1 +72,1 @@\n-public class Test  extends JDIBreakpointTest {\n+public class Test extends JDIBreakpointTest {\n@@ -109,0 +108,1 @@\n+\n@@ -112,1 +112,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/func\/jdi\/breakpointOtherStratum\/Test.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * @run main\/othervm PropertyResolvingWrapper\n+ * @run main\/othervm\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/jdi\/breakpointInCompiledCode\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires os.maxMemory >= 6G\n+ * @requires (sun.arch.data.model == \"64\" & os.maxMemory >= 6G)\n@@ -31,1 +31,0 @@\n- * @ignore This test has huge memory requirements\n","filename":"test\/jdk\/java\/lang\/StringBuffer\/HugeCapacity.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires os.maxMemory >= 6G\n+ * @requires (sun.arch.data.model == \"64\" & os.maxMemory >= 6G)\n@@ -31,1 +31,0 @@\n- * @ignore This test has huge memory requirements\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/HugeCapacity.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244090\n+ * @build m1\/* m2\/*\n+ * @run main\/othervm m1\/p.Main\n+ * @summary Tests public lookups produced from MethodHandles.publicLookup()::in\n+ *\/\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/publicLookup\/Driver.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module m1 {\n+    requires m2;\n+    exports p;\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/publicLookup\/m1\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+\n+import static java.lang.invoke.MethodHandles.Lookup.*;\n+\n+public class Main {\n+    \/*\n+     * Each Test object loads q.EndPoint and q.T with a custom loader.\n+     * These types are used to look up a method handle \"EndPoint::test(T)\".\n+     *\/\n+    static class Test {\n+        final ClassLoader loader;\n+        final Class<?> target;\n+        final Class<?> param;\n+        Test(String name) throws Exception {\n+            URL url = Paths.get(System.getProperty(\"test.classes\"), \"modules\", \"m2\")\n+                           .toUri().toURL();\n+            this.loader = new URLClassLoader(name, new URL[]{url}, null);\n+            this.target = Class.forName(\"q.EndPoint\", true, loader);\n+            this.param = Class.forName(\"q.T\", true, loader);\n+            assertTrue(target != q.EndPoint.class);\n+            assertTrue(param != q.T.class);\n+        }\n+\n+        \/*\n+         *\n+         *\/\n+        public void verifyAccess(Lookup... publicLookups) throws Throwable {\n+            System.err.println(loader.getName() + \": verify access for \" + Arrays.toString(publicLookups));\n+            for (Lookup lookup : publicLookups) {\n+                assertTrue((lookup.lookupModes() & UNCONDITIONAL) == UNCONDITIONAL);\n+                assertTrue((lookup.lookupModes() & PUBLIC) == 0);\n+                MethodHandle mh = lookup.findVirtual(target, \"test\", MethodType.methodType(void.class, param));\n+                mh.invoke(target.newInstance(), param.newInstance());\n+                checkTypeConsistency(mh);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Verify that publicLookup can teleport to:\n+     * 1) q.EndPoint defined in m2\n+     * 2) q.EndPoint defined by a custom loader CL1 in one unnamed module\n+     * 3) q.EndPoint defined by a custom loader CL2 in another unnamed module\n+     *\n+     * All the resulting Lookup objects are public lookups and can find\n+     * any public accessible member.\n+     *\/\n+    public static void main(String... args) throws Throwable {\n+        Test test1 = new Test(\"CL1\");\n+        Test test2 = new Test(\"CL2\");\n+\n+        Lookup lookup1 = MethodHandles.publicLookup();\n+        Lookup lookup2 = MethodHandles.publicLookup().in(test1.target);\n+        Lookup lookup3 = MethodHandles.publicLookup().in(test2.target);\n+        assertTrue(lookup2.lookupClass().getClassLoader() != lookup3.lookupClass().getClassLoader());\n+\n+        test1.verifyAccess(lookup1, lookup2, lookup3);\n+        test2.verifyAccess(lookup1, lookup2, lookup3);\n+    }\n+\n+    static void checkTypeConsistency(MethodHandle mh) throws Throwable {\n+        try {\n+            mh.invoke(new q.EndPoint(), new q.T());\n+            throw new Error(\"expect fail to invoke due to type inconsistency\");\n+        } catch (ClassCastException e) {\n+            assertTrue(e.getMessage().startsWith(\"Cannot cast q.\"));\n+        }\n+    }\n+\n+    static void assertTrue(boolean v) {\n+        if (!v) {\n+            throw new AssertionError(\"unexpected result\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/publicLookup\/m1\/p\/Main.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module m2 {\n+    exports q;\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/publicLookup\/m2\/module-info.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package q;\n+\n+public class EndPoint {\n+    public void test(T t) {\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/publicLookup\/m2\/q\/EndPoint.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package q;\n+\n+public class T {\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/publicLookup\/m2\/q\/T.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Properties;\n+import org.testng.Assert;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8252354\n+ * @run testng CompatibilityTest\n+ * @summary Verify compatibility.\n+ *\/\n+public class CompatibilityTest {\n+    @DataProvider(name = \"entries\")\n+    public Object[][] getEntries() throws IOException {\n+        return new Object[][]{\n+            {8, 238923},\n+            {1.1, 1.1},\n+            {new Object(), \"Value\"},\n+            {\"Key\", new Object()},\n+        };\n+    }\n+\n+    \/**\n+     * Verifies that a ClassCastException is thrown as specified by the\n+     * {@code storeToXML} method.\n+     * @param key the key\n+     * @param value the value\n+     * @throws IOException\n+     *\/\n+    @Test(dataProvider = \"entries\")\n+    void testThrows(Object key, Object value) throws IOException {\n+        Assert.assertThrows(ClassCastException.class, () -> storeToXML(key, value));\n+    }\n+\n+    void storeToXML(Object key, Object value) throws IOException {\n+        ByteArrayOutputStream os = new ByteArrayOutputStream();\n+        Properties pr = new Properties();\n+        pr.put(key, value);\n+        pr.storeToXML(os, \"Test\", \"UTF-8\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Properties\/CompatibilityTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -73,22 +73,0 @@\n-\n-        \/\/ Now check that properties whose keys or values are objects\n-        \/\/ are skipped.\n-\n-        P1.put(\"p1.object.prop\", Objects.OBJ1);\n-        P1.put(Objects.OBJ1, \"p1.object.prop\");\n-        P1.put(\"p2.object.prop\", \"p2.object.prop\");\n-        P2.put(\"p2.object.prop\", Objects.OBJ2);\n-        P2.put(Objects.OBJ2, \"p2.object.prop\");\n-        P3.put(\"p3.object.prop\", Objects.OBJ3);\n-        P3.put(Objects.OBJ3, \"p3.object.prop\");\n-\n-        Properties PP1 = loadFromXML(writeToXML(P1), null);\n-        Properties PP2 = loadFromXML(writeToXML(P2), PP1);\n-        Properties PP3 = loadFromXML(writeToXML(P3), PP2);\n-\n-        p1.setProperty(\"p2.object.prop\", \"p2.object.prop\");\n-        try {\n-            testResults(p1, PP1, p2, PP2, p3, PP3);\n-        } finally {\n-            p1.remove(\"p2.object.prop\");\n-        }\n","filename":"test\/jdk\/java\/util\/Properties\/LoadAndStoreXMLWithDefaults.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3,1 +3,2 @@\n-2 errors\n+Buggy.java:24:1: compiler.err.annotation.type.not.applicable\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/T8171332\/Processor.out","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8160601\n+ * @summary Verify deprecated javadoc tag in package-info does not crash javac.\n+ * @library \/tools\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main JavadocDeprecatedInPackageTest\n+ *\/\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class JavadocDeprecatedInPackageTest extends TestRunner {\n+\n+    protected ToolBox tb;\n+\n+    JavadocDeprecatedInPackageTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        JavadocDeprecatedInPackageTest t = new JavadocDeprecatedInPackageTest();\n+        t.runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void javadocDeprecatedTag(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\/** @deprecated message *\/ @Deprecated package p1;\",\n+                          \"\/** @deprecated message *\/ package p2;\");\n+\n+        List<String> actual =\n+                new JavacTask(tb, Task.Mode.CMDLINE)\n+                    .options(\"-Xlint:deprecation\",\n+                             \"-XDrawDiagnostics\")\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.SUCCESS)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\"package-info.java:1:48: compiler.warn.deprecated.annotation.has.no.effect: kindname.package\",\n+                                        \"1 warning\");\n+\n+        if (!Objects.equals(actual, expected)) {\n+            throw new AssertionError(\"Unexpected log output: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/depDocComment\/JavadocDeprecatedInPackageTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.local.classes.cant.extend.sealed\n+\/\/ key: compiler.err.sealed.class.must.have.subclasses\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ key: compiler.misc.anonymous\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class Main {\n+    void m() {\n+        Shape shape = new Shape() {};\n+    }\n+}\n+\n+sealed interface Shape {}\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AnonymousCantInheritFromSealed.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.class.in.module.cant.extend.sealed.in.diff.module\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --add-reads mSealed=mSub --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherModule\/CantExtendSealedInAnotherModule.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package a;\n+\n+public sealed class Base permits b.Impl {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherModule\/modulesourcepath\/mSealed\/a\/Base.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module mSealed { exports a; }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherModule\/modulesourcepath\/mSealed\/module-info.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package b;\n+\n+public final class Impl extends a.Base {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherModule\/modulesourcepath\/mSub\/b\/Impl.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module mSub { exports b; requires mSealed; }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherModule\/modulesourcepath\/mSub\/module-info.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherPkg\/CantExtendSealedInAnotherPkg.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p1;\n+\n+import p2.*;\n+\n+public sealed class Sealed permits p2.Sub {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherPkg\/p1\/Sealed.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p2;\n+\n+import p1.*;\n+\n+public final class Sub extends p1.Sealed {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantExtendSealedInAnotherPkg\/p2\/Sub.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+\/\/ key: compiler.misc.local\n@@ -35,0 +36,1 @@\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/LocalCantInheritFromSealed.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8245664\n+ * @summary Verify deprecation message is not reported for deprecated packages.\n+ * @library \/tools\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main DeprecationTest\n+ *\/\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DeprecationTest extends TestRunner {\n+\n+    protected ToolBox tb;\n+\n+    DeprecationTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        DeprecationTest t = new DeprecationTest();\n+        t.runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void deprecatedPackage(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"@Deprecated package p;\",\n+                          \"package p; public class Test { use.DeprecatedClass d1; }\",\n+                          \"package use; public class Use1 { p.Test t; Class<?> c = p.Test.class; }\",\n+                          \"package use; import p.Test; public class Use2 { Test t; Class<?> c = Test.class; }\",\n+                          \"package use; @Deprecated public class DeprecatedClass { }\");\n+\n+        List<String> actual =\n+                new JavacTask(tb, Task.Mode.CMDLINE)\n+                    .options(\"-Xlint:deprecation\",\n+                             \"-XDrawDiagnostics\")\n+                    .files(tb.findJavaFiles(src))\n+                    .run(Task.Expect.SUCCESS)\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\"package-info.java:1:21: compiler.warn.deprecated.annotation.has.no.effect: kindname.package\",\n+                                        \"Test.java:1:35: compiler.warn.has.been.deprecated: use.DeprecatedClass, use\",\n+                                        \"2 warnings\");\n+\n+        if (!Objects.equals(actual, expected)) {\n+            throw new AssertionError(\"Unexpected log output: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/DeprecationTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n- * @test 8250629\n+ * @test 8250629 8252307 8247352\n@@ -397,0 +397,3 @@\n+        assertFail(\"compiler.err.first.statement.must.be.call.to.another.constructor\",\n+                \"record R(int x, int y) { public R(int y, int x, int z) { super(); this.x = this.y = 0; } }\");\n+\n@@ -1045,0 +1048,6 @@\n+                \"ElementType.FIELD,ElementType.CONSTRUCTOR\",\n+                \"ElementType.FIELD,ElementType.LOCAL_VARIABLE\",\n+                \"ElementType.FIELD,ElementType.ANNOTATION_TYPE\",\n+                \"ElementType.FIELD,ElementType.PACKAGE\",\n+                \"ElementType.FIELD,ElementType.TYPE_PARAMETER\",\n+                \"ElementType.FIELD,ElementType.MODULE\",\n@@ -1076,1 +1085,1 @@\n-            if (target.contains(\"FIELD\")) {\n+            if (target.contains(\"ElementType.FIELD\")) {\n@@ -1087,1 +1096,1 @@\n-            if (target.contains(\"TYPE_USE\")) {\n+            if (target.contains(\"ElementType.TYPE_USE\")) {\n@@ -1102,1 +1111,1 @@\n-            if (target.contains(\"PARAMETER\")) {\n+            if (target.contains(\"ElementType.PARAMETER\")) {\n@@ -1112,1 +1121,1 @@\n-            if (target.contains(\"TYPE_USE\")) {\n+            if (target.contains(\"ElementType.TYPE_USE\")) {\n@@ -1126,1 +1135,1 @@\n-            if (target.contains(\"METHOD\")) {\n+            if (target.contains(\"ElementType.METHOD\")) {\n@@ -1136,1 +1145,1 @@\n-            if (target.contains(\"TYPE_USE\")) {\n+            if (target.contains(\"ElementType.TYPE_USE\")) {\n@@ -1151,1 +1160,1 @@\n-            if (target.contains(\"RECORD_COMPONENT\")) {\n+            if (target.contains(\"ElementType.RECORD_COMPONENT\")) {\n@@ -1161,1 +1170,1 @@\n-            if (target.contains(\"TYPE_USE\")) {\n+            if (target.contains(\"ElementType.TYPE_USE\")) {\n@@ -1297,1 +1306,0 @@\n-            Assert.check(targetSet.isEmpty(), targetSet.toString());\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test 8247352\n@@ -376,1 +376,1 @@\n-                        \"public class Sub1 extends pkg1.Sealed {\\n\" +\n+                        \"public final class Sub1 extends pkg1.Sealed {\\n\" +\n@@ -387,3 +387,2 @@\n-                \"Sub1.java:3:8: compiler.err.non.sealed.sealed.or.final.expected\",\n-                \"Sealed.java:3:40: compiler.err.cant.inherit.from.sealed: pkg1.Sealed\",\n-                \"2 errors\");\n+                \"Sealed.java:3:40: compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package: pkg1.Sealed\",\n+                \"1 error\");\n@@ -464,1 +463,1 @@\n-                \"Sealed.java:3:40: compiler.err.cant.inherit.from.sealed: pkg1.Sealed\",\n+                \"Sealed.java:3:40: compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package: pkg1.Sealed\",\n@@ -604,3 +603,1 @@\n-            \"Base.java:1:46: compiler.err.cant.inherit.from.sealed: a.Base\",\n-            \"- compiler.note.preview.filename: Base.java\",\n-            \"- compiler.note.preview.recompile\",\n+            \"Base.java:1:46: compiler.err.class.in.module.cant.extend.sealed.in.diff.module: a.Base, mSealed\",\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedDiffConfigurationsTest.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"}]}