{"files":[{"patch":"@@ -2464,0 +2464,1 @@\n+    case Op_CompressM:\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,2 +152,0 @@\n-      case Op_CompressV:\n-        return (bt == T_INT || bt == T_LONG);\n@@ -5792,1 +5790,1 @@\n-instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+instruct mcompress(pReg dst, pReg mask, rFlagsReg cr) %{\n@@ -5794,0 +5792,20 @@\n+  match(Set dst (CompressM mask));\n+  effect(KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cntp rscratch1, $mask\\n\\t\"\n+            \"sve_whilelo $dst, zr, rscratch1\\t# mask compress (B\/H\/S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp(rscratch1, size, ptrue, as_PRegister($mask$$reg));\n+    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n@@ -5796,1 +5814,1 @@\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (sve)\" %}\n+  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (S\/D)\" %}\n@@ -5805,0 +5823,29 @@\n+instruct vcompressB(vReg dst, vReg src, pReg mask, vReg vtmp1, vReg vtmp2, vReg vtmp3, vReg vtmp4,\n+                    pReg ptmp, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP ptmp, TEMP pgtmp);\n+  match(Set dst (CompressV src mask));\n+  ins_cost(13 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $mask\\t# vector compress (B)\" %}\n+  ins_encode %{\n+    __ sve_compress_byte(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($mask$$reg),\n+                         as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg),\n+                         as_FloatRegister($vtmp3$$reg),as_FloatRegister($vtmp4$$reg),\n+                         as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressS(vReg dst, vReg src, pReg mask, vReg vtmp1, vReg vtmp2, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp);\n+  match(Set dst (CompressV src mask));\n+  ins_cost(38 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $mask\\t# vector compress (H)\" %}\n+  ins_encode %{\n+    __ sve_compress_short(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($mask$$reg),\n+                          as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":51,"deletions":4,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -147,2 +147,0 @@\n-      case Op_CompressV:\n-        return (bt == T_INT || bt == T_LONG);\n@@ -3210,1 +3208,1 @@\n-instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+instruct mcompress(pReg dst, pReg mask, rFlagsReg cr) %{\n@@ -3212,0 +3210,20 @@\n+  match(Set dst (CompressM mask));\n+  effect(KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cntp rscratch1, $mask\\n\\t\"\n+            \"sve_whilelo $dst, zr, rscratch1\\t# mask compress (B\/H\/S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp(rscratch1, size, ptrue, as_PRegister($mask$$reg));\n+    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n@@ -3214,1 +3232,1 @@\n-  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (sve)\" %}\n+  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (S\/D)\" %}\n@@ -3223,0 +3241,29 @@\n+instruct vcompressB(vReg dst, vReg src, pReg mask, vReg vtmp1, vReg vtmp2, vReg vtmp3, vReg vtmp4,\n+                    pReg ptmp, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP ptmp, TEMP pgtmp);\n+  match(Set dst (CompressV src mask));\n+  ins_cost(13 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $mask\\t# vector compress (B)\" %}\n+  ins_encode %{\n+    __ sve_compress_byte(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($mask$$reg),\n+                         as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg),\n+                         as_FloatRegister($vtmp3$$reg),as_FloatRegister($vtmp4$$reg),\n+                         as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressS(vReg dst, vReg src, pReg mask, vReg vtmp1, vReg vtmp2, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp);\n+  match(Set dst (CompressV src mask));\n+  ins_cost(38 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $mask\\t# vector compress (H)\" %}\n+  ins_encode %{\n+    __ sve_compress_short(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($mask$$reg),\n+                          as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":51,"deletions":4,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -3662,1 +3662,2 @@\n-  \/\/ SVE create index starting from and incremented by immediate\n+  \/\/ SVE Index Generation:\n+  \/\/ Create index starting from and incremented by immediate\n@@ -3665,0 +3666,1 @@\n+    assert(T != Q, \"invalid size\");\n@@ -3670,0 +3672,10 @@\n+  \/\/ SVE Index Generation:\n+  \/\/ Create index starting from general-purpose register and incremented by immediate\n+  void sve_index(FloatRegister Zd, SIMD_RegVariant T, Register Rn, int imm) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000100, 31, 24), f(T, 23, 22), f(0b1, 21);\n+    sf(imm, 20, 16), f(0b010001, 15, 10);\n+    zrf(Rn, 5), rf(Zd, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1271,0 +1271,113 @@\n+\n+\/\/ Pack active elements of src, under the control of mask, into the lowest-numbered elements of dst.\n+\/\/ Any remaining elements of dst will be filled with zero.\n+\/\/ Clobbers: rscratch1\n+\/\/ Preserves: src, mask\n+void C2_MacroAssembler::sve_compress_short(FloatRegister dst, FloatRegister src, PRegister mask,\n+                                           FloatRegister vtmp1, FloatRegister vtmp2,\n+                                           PRegister pgtmp) {\n+  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register\");\n+  assert_different_registers(dst, src, vtmp1, vtmp2);\n+  assert_different_registers(mask, pgtmp);\n+\n+  \/\/ Example input:   src   = 8888 7777 6666 5555 4444 3333 2222 1111\n+  \/\/                  mask  = 0001 0000 0000 0001 0001 0000 0001 0001\n+  \/\/ Expected result: dst   = 0000 0000 0000 8888 5555 4444 2222 1111\n+  sve_dup(vtmp2, H, 0);\n+\n+  \/\/ Extend lowest half to type INT.\n+  \/\/ dst = 00004444 00003333 00002222 00001111\n+  sve_uunpklo(dst, S, src);\n+  \/\/ pgtmp = 00000001 00000000 00000001 00000001\n+  sve_punpklo(pgtmp, mask);\n+  \/\/ Pack the active elements in size of type INT to the right,\n+  \/\/ and fill the remainings with zero.\n+  \/\/ dst = 00000000 00004444 00002222 00001111\n+  sve_compact(dst, S, dst, pgtmp);\n+  \/\/ Narrow the result back to type SHORT.\n+  \/\/ dst = 0000 0000 0000 0000 0000 4444 2222 1111\n+  sve_uzp1(dst, H, dst, vtmp2);\n+  \/\/ Count the active elements of lowest half.\n+  \/\/ rscratch1 = 3\n+  sve_cntp(rscratch1, S, ptrue, pgtmp);\n+\n+  \/\/ Repeat to the highest half.\n+  \/\/ pgtmp = 00000001 00000000 00000000 00000001\n+  sve_punpkhi(pgtmp, mask);\n+  \/\/ vtmp1 = 00008888 00007777 00006666 00005555\n+  sve_uunpkhi(vtmp1, S, src);\n+  \/\/ vtmp1 = 00000000 00000000 00008888 00005555\n+  sve_compact(vtmp1, S, vtmp1, pgtmp);\n+  \/\/ vtmp1 = 0000 0000 0000 0000 0000 0000 8888 5555\n+  sve_uzp1(vtmp1, H, vtmp1, vtmp2);\n+\n+  \/\/ Compressed low:   dst   = 0000 0000 0000 0000 0000 4444 2222 1111\n+  \/\/ Compressed high:  vtmp1 = 0000 0000 0000 0000 0000 0000 8888  5555\n+  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n+  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n+  neg(rscratch1, rscratch1);\n+  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n+  sve_index(vtmp2, H, rscratch1, 1);\n+  \/\/ vtmp1 = 0000 0000 0000 8888 5555 0000 0000 0000\n+  sve_tbl(vtmp1, H, vtmp1, vtmp2);\n+\n+  \/\/ Combine the compressed high(after shifted) with the compressed low.\n+  \/\/ dst = 0000 0000 0000 8888 5555 4444 2222 1111\n+  sve_orr(dst, dst, vtmp1);\n+}\n+\n+\/\/ Clobbers: rscratch1, rscratch2\n+\/\/ Preserves: src, mask\n+void C2_MacroAssembler::sve_compress_byte(FloatRegister dst, FloatRegister src, PRegister mask,\n+                                          FloatRegister vtmp1, FloatRegister vtmp2,\n+                                          FloatRegister vtmp3, FloatRegister vtmp4,\n+                                          PRegister ptmp, PRegister pgtmp) {\n+  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register\");\n+  assert_different_registers(dst, src, vtmp1, vtmp2, vtmp3, vtmp4);\n+  assert_different_registers(mask, ptmp, pgtmp);\n+  \/\/ Example input:   src   = 88 77 66 45 44 33 22 11\n+  \/\/                  mask  = 01 00 00 01 01 00 01 01\n+  \/\/ Expected result: dst   = 00 00 00 88 55 44 22 11\n+\n+  sve_dup(vtmp4, B, 0);\n+  \/\/ Extend lowest half to type SHORT.\n+  \/\/ vtmp1 = 0044 0033 0022 0011\n+  sve_uunpklo(vtmp1, H, src);\n+  \/\/ ptmp = 0001 0000 0001 0001\n+  sve_punpklo(ptmp, mask);\n+  \/\/ Count the active elements of lowest half.\n+  \/\/ rscratch2 = 3\n+  sve_cntp(rscratch2, H, ptrue, ptmp);\n+  \/\/ Pack the active elements in size of type SHORT to the right,\n+  \/\/ and fill the remainings with zero.\n+  \/\/ dst = 0000 0044 0022 0011\n+  sve_compress_short(dst, vtmp1, ptmp, vtmp2, vtmp3, pgtmp);\n+  \/\/ Narrow the result back to type BYTE.\n+  \/\/ dst = 00 00 00 00 00 44 22 11\n+  sve_uzp1(dst, B, dst, vtmp4);\n+\n+  \/\/ Repeat to the highest half.\n+  \/\/ ptmp = 0001 0000 0000 0001\n+  sve_punpkhi(ptmp, mask);\n+  \/\/ vtmp1 = 0088 0077 0066 0055\n+  sve_uunpkhi(vtmp2, H, src);\n+  \/\/ vtmp1 = 0000 0000 0088 0055\n+  sve_compress_short(vtmp1, vtmp2, ptmp, vtmp3, vtmp4, pgtmp);\n+\n+  sve_dup(vtmp4, B, 0);\n+  \/\/ vtmp1 = 00 00 00 00 00 00 88 55\n+  sve_uzp1(vtmp1, B, vtmp1, vtmp4);\n+\n+  \/\/ Compressed low:   dst   = 00 00 00 00 00 44 22 11\n+  \/\/ Compressed high:  vtmp1 = 00 00 00 00 00 00 88 55\n+  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n+  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n+  neg(rscratch2, rscratch2);\n+  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n+  sve_index(vtmp2, B, rscratch2, 1);\n+  \/\/ vtmp1 = 00 00 00 88 55 00 00 00\n+  sve_tbl(vtmp1, B, vtmp1, vtmp2);\n+  \/\/ Combine the compressed high(after shifted) with the compressed low.\n+  \/\/ dst = 00 00 00 88 55 44 22 11\n+  sve_orr(dst, dst, vtmp1);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -115,0 +115,12 @@\n+  \/\/ Pack active elements of src, under the control of mask, into the\n+  \/\/ lowest-numbered elements of dst. Any remaining elements of dst will\n+  \/\/ be filled with zero.\n+  void sve_compress_byte(FloatRegister dst, FloatRegister src, PRegister mask,\n+                         FloatRegister vtmp1, FloatRegister vtmp2,\n+                         FloatRegister vtmp3, FloatRegister vtmp4,\n+                         PRegister ptmp, PRegister pgtmp);\n+\n+  void sve_compress_short(FloatRegister dst, FloatRegister src, PRegister mask,\n+                          FloatRegister vtmp1, FloatRegister vtmp2,\n+                          PRegister pgtmp);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1711,0 +1711,4 @@\n+                        [\"index\",   \"__ sve_index(z6, __ B, r5, 2);\",                     \"index\\tz6.b, w5, #2\"],\n+                        [\"index\",   \"__ sve_index(z6, __ H, r5, 3);\",                     \"index\\tz6.h, w5, #3\"],\n+                        [\"index\",   \"__ sve_index(z6, __ S, r5, 4);\",                     \"index\\tz6.s, w5, #4\"],\n+                        [\"index\",   \"__ sve_index(z7, __ D, r5, 5);\",                     \"index\\tz7.d, x5, #5\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -852,0 +852,4 @@\n+    __ sve_index(z6, __ B, r5, 2);                     \/\/       index   z6.b, w5, #2\n+    __ sve_index(z6, __ H, r5, 3);                     \/\/       index   z6.h, w5, #3\n+    __ sve_index(z6, __ S, r5, 4);                     \/\/       index   z6.s, w5, #4\n+    __ sve_index(z7, __ D, r5, 5);                     \/\/       index   z7.d, x5, #5\n@@ -1148,7 +1152,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003a7,     0x94000000,\n-    0x97ffffd4,     0x940003a4,     0x3400000a,     0x34fffa2a,\n-    0x3400742a,     0x35000008,     0x35fff9c8,     0x350073c8,\n-    0xb400000b,     0xb4fff96b,     0xb400736b,     0xb500001d,\n-    0xb5fff91d,     0xb500731d,     0x10000013,     0x10fff8b3,\n-    0x100072b3,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36307236,     0x3758000c,     0x375ff7cc,     0x375871cc,\n+    0x14000000,     0x17ffffd7,     0x140003ab,     0x94000000,\n+    0x97ffffd4,     0x940003a8,     0x3400000a,     0x34fffa2a,\n+    0x340074aa,     0x35000008,     0x35fff9c8,     0x35007448,\n+    0xb400000b,     0xb4fff96b,     0xb40073eb,     0xb500001d,\n+    0xb5fff91d,     0xb500739d,     0x10000013,     0x10fff8b3,\n+    0x10007333,     0x90000013,     0x36300016,     0x3637f836,\n+    0x363072b6,     0x3758000c,     0x375ff7cc,     0x3758724c,\n@@ -1159,13 +1163,13 @@\n-    0x54006fa0,     0x54000001,     0x54fff541,     0x54006f41,\n-    0x54000002,     0x54fff4e2,     0x54006ee2,     0x54000002,\n-    0x54fff482,     0x54006e82,     0x54000003,     0x54fff423,\n-    0x54006e23,     0x54000003,     0x54fff3c3,     0x54006dc3,\n-    0x54000004,     0x54fff364,     0x54006d64,     0x54000005,\n-    0x54fff305,     0x54006d05,     0x54000006,     0x54fff2a6,\n-    0x54006ca6,     0x54000007,     0x54fff247,     0x54006c47,\n-    0x54000008,     0x54fff1e8,     0x54006be8,     0x54000009,\n-    0x54fff189,     0x54006b89,     0x5400000a,     0x54fff12a,\n-    0x54006b2a,     0x5400000b,     0x54fff0cb,     0x54006acb,\n-    0x5400000c,     0x54fff06c,     0x54006a6c,     0x5400000d,\n-    0x54fff00d,     0x54006a0d,     0x5400000e,     0x54ffefae,\n-    0x540069ae,     0x5400000f,     0x54ffef4f,     0x5400694f,\n+    0x54007020,     0x54000001,     0x54fff541,     0x54006fc1,\n+    0x54000002,     0x54fff4e2,     0x54006f62,     0x54000002,\n+    0x54fff482,     0x54006f02,     0x54000003,     0x54fff423,\n+    0x54006ea3,     0x54000003,     0x54fff3c3,     0x54006e43,\n+    0x54000004,     0x54fff364,     0x54006de4,     0x54000005,\n+    0x54fff305,     0x54006d85,     0x54000006,     0x54fff2a6,\n+    0x54006d26,     0x54000007,     0x54fff247,     0x54006cc7,\n+    0x54000008,     0x54fff1e8,     0x54006c68,     0x54000009,\n+    0x54fff189,     0x54006c09,     0x5400000a,     0x54fff12a,\n+    0x54006baa,     0x5400000b,     0x54fff0cb,     0x54006b4b,\n+    0x5400000c,     0x54fff06c,     0x54006aec,     0x5400000d,\n+    0x54fff00d,     0x54006a8d,     0x5400000e,     0x54ffefae,\n+    0x54006a2e,     0x5400000f,     0x54ffef4f,     0x540069cf,\n@@ -1203,1 +1207,1 @@\n-    0xbd1b1869,     0x5800599b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x58005a1b,     0x1800000b,     0xf8945060,\n@@ -1322,1 +1326,2 @@\n-    0x04a14026,     0x0568aca7,     0x05b23230,     0x853040af,\n+    0x04a14026,     0x042244a6,     0x046344a6,     0x04a444a6,\n+    0x04e544a7,     0x0568aca7,     0x05b23230,     0x853040af,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"}]}