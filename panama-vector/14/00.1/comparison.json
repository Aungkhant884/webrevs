{"files":[{"patch":"@@ -2434,0 +2434,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -853,0 +853,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -365,0 +365,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2168,0 +2168,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -928,0 +928,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -862,0 +862,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1032,0 +1032,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1123,0 +1123,25 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(num_bits == 64 || num_bits == 128 || num_bits == 256 || num_bits == 512,\n+         \"only certain vector sizes are supported for now\");\n+\n+  static const XMMRegister VEC_ArgReg[32] = {\n+     xmm0,  xmm1,  xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,\n+     xmm8,  xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,\n+    xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,\n+    xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31\n+  };\n+\n+  uint stk_args = 0;\n+  uint fp_args = 0;\n+\n+  for (uint i = 0; i < total_args_passed; i++) {\n+    VMReg vmreg = VEC_ArgReg[fp_args++]->as_VMReg();\n+    int next_val = num_bits == 64 ? 1 : (num_bits == 128 ? 3 : (num_bits  == 256 ? 7 : 15));\n+    regs[i].set_pair(vmreg->next(next_val), vmreg);\n+  }\n+\n+  return stk_args;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -53,0 +53,277 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+\/\/ Vector API SVML routines written in assembly\n+extern \"C\"\n+{\n+   float __svml_expf4_ha_ex(float a);\n+   double __svml_exp1_ha_ex(double a);\n+   double __svml_exp2_ha_ex(double a);\n+   float __svml_expf4_ha_l9(float a);\n+   float __svml_expf8_ha_l9(float a);\n+   float __svml_expf4_ha_e9(float a);\n+   float __svml_expf8_ha_e9(float a);\n+   float __svml_expf16_ha_z0(float a);\n+   double __svml_exp1_ha_l9(double a);\n+   double __svml_exp2_ha_l9(double a);\n+   double __svml_exp4_ha_l9(double a);\n+   double __svml_exp1_ha_e9(double a);\n+   double __svml_exp2_ha_e9(double a);\n+   double __svml_exp4_ha_e9(double a);\n+   double __svml_exp8_ha_z0(double a);\n+   float  __svml_expm1f4_ha_ex(float a);\n+   double __svml_expm11_ha_ex(double a);\n+   double __svml_expm12_ha_ex(double a);\n+   float  __svml_expm1f4_ha_l9(float a);\n+   float  __svml_expm1f8_ha_l9(float a);\n+   float  __svml_expm1f4_ha_e9(float a);\n+   float  __svml_expm1f8_ha_e9(float a);\n+   float __svml_expm1f16_ha_z0(float a);\n+   double __svml_expm11_ha_l9(double a);\n+   double __svml_expm12_ha_l9(double a);\n+   double __svml_expm14_ha_l9(double a);\n+   double __svml_expm11_ha_e9(double a);\n+   double __svml_expm12_ha_e9(double a);\n+   double __svml_expm14_ha_e9(double a);\n+   double __svml_expm18_ha_z0(double a);\n+   float __svml_log1pf4_ha_l9(float a);\n+   float __svml_log1pf8_ha_l9(float a);\n+   float __svml_log1pf4_ha_e9(float a);\n+   float __svml_log1pf8_ha_e9(float a);\n+   float __svml_log1pf16_ha_z0(float a);\n+   double __svml_log1p1_ha_l9(double a);\n+   double __svml_log1p2_ha_l9(double a);\n+   double __svml_log1p4_ha_l9(double a);\n+   double __svml_log1p1_ha_e9(double a);\n+   double __svml_log1p2_ha_e9(double a);\n+   double __svml_log1p4_ha_e9(double a);\n+   double __svml_log1p8_ha_z0(double a);\n+   float __svml_logf4_ha_l9(float a);\n+   float __svml_logf8_ha_l9(float a);\n+   float __svml_logf4_ha_e9(float a);\n+   float __svml_logf8_ha_e9(float a);\n+   float __svml_logf16_ha_z0(float a);\n+   double __svml_log1_ha_l9(double a);\n+   double __svml_log2_ha_l9(double a);\n+   double __svml_log4_ha_l9(double a);\n+   double __svml_log1_ha_e9(double a);\n+   double __svml_log2_ha_e9(double a);\n+   double __svml_log4_ha_e9(double a);\n+   double __svml_log8_ha_z0(double a);\n+   float __svml_log10f4_ha_l9(float a);\n+   float __svml_log10f8_ha_l9(float a);\n+   float __svml_log10f4_ha_e9(float a);\n+   float __svml_log10f8_ha_e9(float a);\n+   float __svml_log10f16_ha_z0(float a);\n+   double __svml_log101_ha_l9(double a);\n+   double __svml_log102_ha_l9(double a);\n+   double __svml_log104_ha_l9(double a);\n+   double __svml_log101_ha_e9(double a);\n+   double __svml_log102_ha_e9(double a);\n+   double __svml_log104_ha_e9(double a);\n+   double __svml_log108_ha_z0(double a);\n+   float __svml_sinf4_ha_l9(float a);\n+   float __svml_sinf8_ha_l9(float a);\n+   float __svml_sinf4_ha_e9(float a);\n+   float __svml_sinf8_ha_e9(float a);\n+   float __svml_sinf16_ha_z0(float a);\n+   double __svml_sin1_ha_l9(double a);\n+   double __svml_sin2_ha_l9(double a);\n+   double __svml_sin4_ha_l9(double a);\n+   double __svml_sin1_ha_e9(double a);\n+   double __svml_sin2_ha_e9(double a);\n+   double __svml_sin4_ha_e9(double a);\n+   double __svml_sin8_ha_z0(double a);\n+   float __svml_cosf4_ha_l9(float a);\n+   float __svml_cosf8_ha_l9(float a);\n+   float __svml_cosf4_ha_e9(float a);\n+   float __svml_cosf8_ha_e9(float a);\n+   float __svml_cosf16_ha_z0(float a);\n+   double  __svml_cos1_ha_l9(double a);\n+   double  __svml_cos2_ha_l9(double a);\n+   double __svml_cos4_ha_l9(double a);\n+   double  __svml_cos1_ha_e9(double a);\n+   double  __svml_cos2_ha_e9(double a);\n+   double __svml_cos4_ha_e9(double a);\n+   double  __svml_cos8_ha_z0(double a);\n+   float __svml_tanf4_ha_l9(float a);\n+   float __svml_tanf8_ha_l9(float a);\n+   float __svml_tanf4_ha_e9(float a);\n+   float __svml_tanf8_ha_e9(float a);\n+   float __svml_tanf16_ha_z0(float a);\n+   double __svml_tan1_ha_l9(double a);\n+   double __svml_tan2_ha_l9(double a);\n+   double __svml_tan4_ha_l9(double a);\n+   double __svml_tan1_ha_e9(double a);\n+   double __svml_tan2_ha_e9(double a);\n+   double __svml_tan4_ha_e9(double a);\n+   double __svml_tan8_ha_z0(double a);\n+   double __svml_sinh1_ha_l9(double a);\n+   double __svml_sinh2_ha_l9(double a);\n+   double __svml_sinh4_ha_l9(double a);\n+   double __svml_sinh1_ha_e9(double a);\n+   double __svml_sinh2_ha_e9(double a);\n+   double __svml_sinh4_ha_e9(double a);\n+   double __svml_sinh8_ha_z0(double a);\n+   float __svml_sinhf4_ha_l9(float a);\n+   float __svml_sinhf8_ha_l9(float a);\n+   float __svml_sinhf4_ha_e9(float a);\n+   float __svml_sinhf8_ha_e9(float a);\n+   float __svml_sinhf16_ha_z0(float a);\n+   double __svml_cosh1_ha_l9(double a);\n+   double __svml_cosh2_ha_l9(double a);\n+   double __svml_cosh4_ha_l9(double a);\n+   double __svml_cosh1_ha_e9(double a);\n+   double __svml_cosh2_ha_e9(double a);\n+   double __svml_cosh4_ha_e9(double a);\n+   double __svml_cosh8_ha_z0(double a);\n+   float __svml_coshf4_ha_l9(float a);\n+   float __svml_coshf8_ha_l9(float a);\n+   float __svml_coshf4_ha_e9(float a);\n+   float __svml_coshf8_ha_e9(float a);\n+   float __svml_coshf16_ha_z0(float a);\n+   double __svml_tanh1_ha_l9(double a);\n+   double __svml_tanh2_ha_l9(double a);\n+   double __svml_tanh4_ha_l9(double a);\n+   double __svml_tanh1_ha_e9(double a);\n+   double __svml_tanh2_ha_e9(double a);\n+   double __svml_tanh4_ha_e9(double a);\n+   double __svml_tanh8_ha_z0(double a);\n+   float __svml_tanhf4_ha_l9(float a);\n+   float __svml_tanhf8_ha_l9(float a);\n+   float __svml_tanhf4_ha_e9(float a);\n+   float __svml_tanhf8_ha_e9(float a);\n+   float __svml_tanhf16_ha_z0(float a);\n+   float __svml_acosf4_ha_ex(float a);\n+   float __svml_acosf4_ha_l9(float a);\n+   float __svml_acosf8_ha_l9(float a);\n+   float __svml_acosf4_ha_e9(float a);\n+   float __svml_acosf8_ha_e9(float a);\n+   float __svml_acosf16_ha_z0(float a);\n+   double __svml_acos1_ha_ex(double a);\n+   double __svml_acos2_ha_ex(double a);\n+   double __svml_acos1_ha_l9(double a);\n+   double __svml_acos2_ha_l9(double a);\n+   double __svml_acos4_ha_l9(double a);\n+   double __svml_acos1_ha_e9(double a);\n+   double __svml_acos2_ha_e9(double a);\n+   double __svml_acos4_ha_e9(double a);\n+   double __svml_acos8_ha_z0(double a);\n+   float __svml_asinf4_ha_ex(float a);\n+   double __svml_asin1_ha_ex(double a);\n+   double __svml_asin2_ha_ex(double a);\n+   double __svml_asin1_ha_l9(double a);\n+   double __svml_asin2_ha_l9(double a);\n+   double __svml_asin4_ha_l9(double a);\n+   double __svml_asin1_ha_e9(double a);\n+   double __svml_asin2_ha_e9(double a);\n+   double __svml_asin4_ha_e9(double a);\n+   double __svml_asin8_ha_z0(double a);\n+   float __svml_asinf4_ha_l9(float a);\n+   float __svml_asinf8_ha_l9(float a);\n+   float __svml_asinf4_ha_e9(float a);\n+   float __svml_asinf8_ha_e9(float a);\n+   float __svml_asinf16_ha_z0(float a);\n+   float __svml_atanf4_ha_ex(float a);\n+   double __svml_atan1_ha_ex(double a);\n+   double __svml_atan2_ha_ex(double a);\n+   double __svml_atan1_ha_l9(double a);\n+   double __svml_atan2_ha_l9(double a);\n+   double __svml_atan4_ha_l9(double a);\n+   double __svml_atan1_ha_e9(double a);\n+   double __svml_atan2_ha_e9(double a);\n+   double __svml_atan4_ha_e9(double a);\n+   double __svml_atan8_ha_z0(double a);\n+   float __svml_atanf4_ha_l9(float a);\n+   float __svml_atanf8_ha_l9(float a);\n+   float __svml_atanf4_ha_e9(float a);\n+   float __svml_atanf8_ha_e9(float a);\n+   float __svml_atanf16_ha_z0(float a);\n+   float __svml_powf4_ha_l9(float a, float b);\n+   float __svml_powf8_ha_l9(float a, float b);\n+   float __svml_powf4_ha_e9(float a, float b);\n+   float __svml_powf8_ha_e9(float a, float b);\n+   float __svml_powf16_ha_z0(float a, float b);\n+   double __svml_pow1_ha_l9(double a, double b);\n+   double __svml_pow2_ha_l9(double a, double b);\n+   double __svml_pow4_ha_l9(double a, double b);\n+   double __svml_pow1_ha_e9(double a, double b);\n+   double __svml_pow2_ha_e9(double a, double b);\n+   double __svml_pow4_ha_e9(double a, double b);\n+   double __svml_pow8_ha_z0(double a, double b);\n+   float __svml_hypotf4_ha_l9(float a, float b);\n+   float __svml_hypotf8_ha_l9(float a, float b);\n+   float __svml_hypotf4_ha_e9(float a, float b);\n+   float __svml_hypotf8_ha_e9(float a, float b);\n+   float __svml_hypotf16_ha_z0(float a, float b);\n+   double __svml_hypot1_ha_l9(double a, double b);\n+   double __svml_hypot2_ha_l9(double a, double b);\n+   double __svml_hypot4_ha_l9(double a, double b);\n+   double __svml_hypot1_ha_e9(double a, double b);\n+   double __svml_hypot2_ha_e9(double a, double b);\n+   double __svml_hypot4_ha_e9(double a, double b);\n+   double __svml_hypot8_ha_z0(double a, double b);\n+   float __svml_cbrtf4_ha_l9(float a);\n+   float __svml_cbrtf8_ha_l9(float a);\n+   float __svml_cbrtf4_ha_e9(float a);\n+   float __svml_cbrtf8_ha_e9(float a);\n+   float __svml_cbrtf16_ha_z0(float a);\n+   double __svml_cbrt1_ha_l9(double a);\n+   double __svml_cbrt2_ha_l9(double a);\n+   double __svml_cbrt4_ha_l9(double a);\n+   double __svml_cbrt1_ha_e9(double a);\n+   double __svml_cbrt2_ha_e9(double a);\n+   double __svml_cbrt4_ha_e9(double a);\n+   double __svml_cbrt8_ha_z0(double a);\n+   float __svml_atan2f4_ha_l9(float a, float b);\n+   float __svml_atan2f8_ha_l9(float a, float b);\n+   float __svml_atan2f4_ha_e9(float a, float b);\n+   float __svml_atan2f8_ha_e9(float a, float b);\n+   float __svml_atan2f16_ha_z0(float a, float b);\n+   double __svml_atan21_ha_l9(double a, double b);\n+   double __svml_atan22_ha_l9(double a, double b);\n+   double __svml_atan24_ha_l9(double a, double b);\n+   double __svml_atan28_ha_z0(double a, double b);\n+   double __svml_atan21_ha_e9(double a, double b);\n+   double __svml_atan22_ha_e9(double a, double b);\n+   double __svml_atan24_ha_e9(double a, double b);\n+   float __svml_sinf4_ha_ex(float a);\n+   double __svml_sin1_ha_ex(double a);\n+   double __svml_sin2_ha_ex(double a);\n+   float __svml_cosf4_ha_ex(float a);\n+   double __svml_cos1_ha_ex(double a);\n+   double __svml_cos2_ha_ex(double a);\n+   float __svml_tanf4_ha_ex(float a);\n+   double __svml_tan1_ha_ex(double a);\n+   double __svml_tan2_ha_ex(double a);\n+   float __svml_sinhf4_ha_ex(float a);\n+   double __svml_sinh1_ha_ex(double a);\n+   double __svml_sinh2_ha_ex(double a);\n+   float __svml_coshf4_ha_ex(float a);\n+   double __svml_cosh1_ha_ex(double a);\n+   double __svml_cosh2_ha_ex(double a);\n+   float __svml_tanhf4_ha_ex(float a);\n+   double __svml_tanh1_ha_ex(double a);\n+   double __svml_tanh2_ha_ex(double a);\n+   double __svml_log1_ha_ex(double a);\n+   double __svml_log2_ha_ex(double a);\n+   double __svml_log1p1_ha_ex(double a);\n+   double __svml_log1p2_ha_ex(double a);\n+   double __svml_log101_ha_ex(double a);\n+   double __svml_log102_ha_ex(double a);\n+   float __svml_logf4_ha_ex(float a);\n+   float __svml_log1pf4_ha_ex(float a);\n+   float __svml_log10f4_ha_ex(float a);\n+   double __svml_atan21_ha_ex(double a);\n+   double __svml_atan22_ha_ex(double a);\n+   float __svml_atan2f4_ha_ex(float a);\n+   float __svml_hypotf4_ha_ex(float a);\n+   double __svml_hypot1_ha_ex(double a);\n+   double __svml_hypot2_ha_ex(double a);\n+   double __svml_pow1_ha_ex(double a);\n+   double __svml_pow2_ha_ex(double a);\n+   float __svml_powf4_ha_ex(float a);\n+   double __svml_cbrt1_ha_ex(double a);\n+   double __svml_cbrt2_ha_ex(double a);\n+   float __svml_cbrtf4_ha_ex(float a);\n+}\n+#endif\n+\n@@ -6967,0 +7244,335 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+#ifdef __VECTOR_API_MATH_INTRINSICS_LINUX\n+    if (UseAVX > 2) {\n+      StubRoutines::_vector_exp_float512    = CAST_FROM_FN_PTR(address, __svml_expf16_ha_z0);\n+      StubRoutines::_vector_exp_double512   = CAST_FROM_FN_PTR(address, __svml_exp8_ha_z0);\n+      StubRoutines::_vector_expm1_float512  = CAST_FROM_FN_PTR(address, __svml_expm1f16_ha_z0);\n+      StubRoutines::_vector_expm1_double512 = CAST_FROM_FN_PTR(address, __svml_expm18_ha_z0);\n+      StubRoutines::_vector_log1p_float512  = CAST_FROM_FN_PTR(address, __svml_log1pf16_ha_z0);\n+      StubRoutines::_vector_log1p_double512 = CAST_FROM_FN_PTR(address, __svml_log1p8_ha_z0);\n+      StubRoutines::_vector_log_float512    = CAST_FROM_FN_PTR(address, __svml_logf16_ha_z0);\n+      StubRoutines::_vector_log_double512   = CAST_FROM_FN_PTR(address, __svml_log8_ha_z0);\n+      StubRoutines::_vector_log10_float512  = CAST_FROM_FN_PTR(address, __svml_log10f16_ha_z0);\n+      StubRoutines::_vector_log10_double512 = CAST_FROM_FN_PTR(address, __svml_log108_ha_z0);\n+      StubRoutines::_vector_sin_float512    = CAST_FROM_FN_PTR(address, __svml_sinf16_ha_z0);\n+      StubRoutines::_vector_sin_double512   = CAST_FROM_FN_PTR(address, __svml_sin8_ha_z0);\n+      StubRoutines::_vector_cos_float512    = CAST_FROM_FN_PTR(address, __svml_cosf16_ha_z0);\n+      StubRoutines::_vector_cos_double512   = CAST_FROM_FN_PTR(address, __svml_cos8_ha_z0);\n+      StubRoutines::_vector_tan_float512    = CAST_FROM_FN_PTR(address, __svml_tanf16_ha_z0);\n+      StubRoutines::_vector_tan_double512   = CAST_FROM_FN_PTR(address, __svml_tan8_ha_z0);\n+      StubRoutines::_vector_sinh_float512   = CAST_FROM_FN_PTR(address, __svml_sinhf16_ha_z0);\n+      StubRoutines::_vector_sinh_double512  = CAST_FROM_FN_PTR(address, __svml_sinh8_ha_z0);\n+      StubRoutines::_vector_cosh_float512   = CAST_FROM_FN_PTR(address, __svml_coshf16_ha_z0);\n+      StubRoutines::_vector_cosh_double512  = CAST_FROM_FN_PTR(address, __svml_cosh8_ha_z0);\n+      StubRoutines::_vector_tanh_float512   = CAST_FROM_FN_PTR(address, __svml_tanhf16_ha_z0);\n+      StubRoutines::_vector_tanh_double512  = CAST_FROM_FN_PTR(address, __svml_tanh8_ha_z0);\n+      StubRoutines::_vector_acos_float512   = CAST_FROM_FN_PTR(address, __svml_acosf16_ha_z0);\n+      StubRoutines::_vector_acos_double512  = CAST_FROM_FN_PTR(address, __svml_acos8_ha_z0);\n+      StubRoutines::_vector_asin_float512   = CAST_FROM_FN_PTR(address, __svml_asinf16_ha_z0);\n+      StubRoutines::_vector_asin_double512  = CAST_FROM_FN_PTR(address, __svml_asin8_ha_z0);\n+      StubRoutines::_vector_atan_float512   = CAST_FROM_FN_PTR(address, __svml_atanf16_ha_z0);\n+      StubRoutines::_vector_atan_double512  = CAST_FROM_FN_PTR(address, __svml_atan8_ha_z0);\n+      StubRoutines::_vector_pow_float512    = CAST_FROM_FN_PTR(address, __svml_powf16_ha_z0);\n+      StubRoutines::_vector_pow_double512   = CAST_FROM_FN_PTR(address, __svml_pow8_ha_z0);\n+      StubRoutines::_vector_hypot_float512  = CAST_FROM_FN_PTR(address, __svml_hypotf16_ha_z0);\n+      StubRoutines::_vector_hypot_double512 = CAST_FROM_FN_PTR(address, __svml_hypot8_ha_z0);\n+      StubRoutines::_vector_cbrt_float512   = CAST_FROM_FN_PTR(address, __svml_cbrtf16_ha_z0);\n+      StubRoutines::_vector_cbrt_double512  = CAST_FROM_FN_PTR(address, __svml_cbrt8_ha_z0);\n+      StubRoutines::_vector_atan2_float512  = CAST_FROM_FN_PTR(address, __svml_atan2f16_ha_z0);\n+      StubRoutines::_vector_atan2_double512 = CAST_FROM_FN_PTR(address, __svml_atan28_ha_z0);\n+    }\n+#endif\n+    if (UseAVX > 1) {\n+      StubRoutines::_vector_exp_float64     = CAST_FROM_FN_PTR(address, __svml_expf4_ha_l9);\n+      StubRoutines::_vector_exp_float128    = CAST_FROM_FN_PTR(address, __svml_expf4_ha_l9);\n+      StubRoutines::_vector_exp_float256    = CAST_FROM_FN_PTR(address, __svml_expf8_ha_l9);\n+      StubRoutines::_vector_exp_double64    = CAST_FROM_FN_PTR(address, __svml_exp1_ha_l9);\n+      StubRoutines::_vector_exp_double128   = CAST_FROM_FN_PTR(address, __svml_exp2_ha_l9);\n+      StubRoutines::_vector_exp_double256   = CAST_FROM_FN_PTR(address, __svml_exp4_ha_l9);\n+      StubRoutines::_vector_expm1_float64   = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_l9);\n+      StubRoutines::_vector_expm1_float128  = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_l9);\n+      StubRoutines::_vector_expm1_float256  = CAST_FROM_FN_PTR(address, __svml_expm1f8_ha_l9);\n+      StubRoutines::_vector_expm1_double64  = CAST_FROM_FN_PTR(address, __svml_expm11_ha_l9);\n+      StubRoutines::_vector_expm1_double128 = CAST_FROM_FN_PTR(address, __svml_expm12_ha_l9);\n+      StubRoutines::_vector_expm1_double256 = CAST_FROM_FN_PTR(address, __svml_expm14_ha_l9);\n+      StubRoutines::_vector_log1p_float64   = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_l9);\n+      StubRoutines::_vector_log1p_float128  = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_l9);\n+      StubRoutines::_vector_log1p_float256  = CAST_FROM_FN_PTR(address, __svml_log1pf8_ha_l9);\n+      StubRoutines::_vector_log1p_double64  = CAST_FROM_FN_PTR(address, __svml_log1p1_ha_l9);\n+      StubRoutines::_vector_log1p_double128 = CAST_FROM_FN_PTR(address, __svml_log1p2_ha_l9);\n+      StubRoutines::_vector_log1p_double256 = CAST_FROM_FN_PTR(address, __svml_log1p4_ha_l9);\n+      StubRoutines::_vector_log_float64     = CAST_FROM_FN_PTR(address, __svml_logf4_ha_l9);\n+      StubRoutines::_vector_log_float128    = CAST_FROM_FN_PTR(address, __svml_logf4_ha_l9);\n+      StubRoutines::_vector_log_float256    = CAST_FROM_FN_PTR(address, __svml_logf8_ha_l9);\n+      StubRoutines::_vector_log_double64    = CAST_FROM_FN_PTR(address, __svml_log1_ha_l9);\n+      StubRoutines::_vector_log_double128   = CAST_FROM_FN_PTR(address, __svml_log2_ha_l9);\n+      StubRoutines::_vector_log_double256   = CAST_FROM_FN_PTR(address, __svml_log4_ha_l9);\n+      StubRoutines::_vector_log10_float64   = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_l9);\n+      StubRoutines::_vector_log10_float128  = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_l9);\n+      StubRoutines::_vector_log10_float256  = CAST_FROM_FN_PTR(address, __svml_log10f8_ha_l9);\n+      StubRoutines::_vector_log10_double64  = CAST_FROM_FN_PTR(address, __svml_log101_ha_l9);\n+      StubRoutines::_vector_log10_double128 = CAST_FROM_FN_PTR(address, __svml_log102_ha_l9);\n+      StubRoutines::_vector_log10_double256 = CAST_FROM_FN_PTR(address, __svml_log104_ha_l9);\n+      StubRoutines::_vector_sin_float64     = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_l9);\n+      StubRoutines::_vector_sin_float128    = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_l9);\n+      StubRoutines::_vector_sin_float256    = CAST_FROM_FN_PTR(address, __svml_sinf8_ha_l9);\n+      StubRoutines::_vector_sin_double64    = CAST_FROM_FN_PTR(address, __svml_sin1_ha_l9);\n+      StubRoutines::_vector_sin_double128   = CAST_FROM_FN_PTR(address, __svml_sin2_ha_l9);\n+      StubRoutines::_vector_sin_double256   = CAST_FROM_FN_PTR(address, __svml_sin4_ha_l9);\n+      StubRoutines::_vector_cos_float64     = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_l9);\n+      StubRoutines::_vector_cos_float128    = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_l9);\n+      StubRoutines::_vector_cos_float256    = CAST_FROM_FN_PTR(address, __svml_cosf8_ha_l9);\n+      StubRoutines::_vector_cos_double64    = CAST_FROM_FN_PTR(address, __svml_cos1_ha_l9);\n+      StubRoutines::_vector_cos_double128   = CAST_FROM_FN_PTR(address, __svml_cos2_ha_l9);\n+      StubRoutines::_vector_cos_double256   = CAST_FROM_FN_PTR(address, __svml_cos4_ha_l9);\n+      StubRoutines::_vector_tan_float64     = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_l9);\n+      StubRoutines::_vector_tan_float128    = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_l9);\n+      StubRoutines::_vector_tan_float256    = CAST_FROM_FN_PTR(address, __svml_tanf8_ha_l9);\n+      StubRoutines::_vector_tan_double64    = CAST_FROM_FN_PTR(address, __svml_tan1_ha_l9);\n+      StubRoutines::_vector_tan_double128   = CAST_FROM_FN_PTR(address, __svml_tan2_ha_l9);\n+      StubRoutines::_vector_tan_double256   = CAST_FROM_FN_PTR(address, __svml_tan4_ha_l9);\n+      StubRoutines::_vector_sinh_float64    = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_l9);\n+      StubRoutines::_vector_sinh_float128   = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_l9);\n+      StubRoutines::_vector_sinh_float256   = CAST_FROM_FN_PTR(address, __svml_sinhf8_ha_l9);\n+      StubRoutines::_vector_sinh_double64   = CAST_FROM_FN_PTR(address, __svml_sinh1_ha_l9);\n+      StubRoutines::_vector_sinh_double128  = CAST_FROM_FN_PTR(address, __svml_sinh2_ha_l9);\n+      StubRoutines::_vector_sinh_double256  = CAST_FROM_FN_PTR(address, __svml_sinh4_ha_l9);\n+      StubRoutines::_vector_cosh_float64    = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_l9);\n+      StubRoutines::_vector_cosh_float128   = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_l9);\n+      StubRoutines::_vector_cosh_float256   = CAST_FROM_FN_PTR(address, __svml_coshf8_ha_l9);\n+      StubRoutines::_vector_cosh_double64   = CAST_FROM_FN_PTR(address, __svml_cosh1_ha_l9);\n+      StubRoutines::_vector_cosh_double128  = CAST_FROM_FN_PTR(address, __svml_cosh2_ha_l9);\n+      StubRoutines::_vector_cosh_double256  = CAST_FROM_FN_PTR(address, __svml_cosh4_ha_l9);\n+      StubRoutines::_vector_tanh_float64    = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_l9);\n+      StubRoutines::_vector_tanh_float128   = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_l9);\n+      StubRoutines::_vector_tanh_float256   = CAST_FROM_FN_PTR(address, __svml_tanhf8_ha_l9);\n+      StubRoutines::_vector_tanh_double64   = CAST_FROM_FN_PTR(address, __svml_tanh1_ha_l9);\n+      StubRoutines::_vector_tanh_double128  = CAST_FROM_FN_PTR(address, __svml_tanh2_ha_l9);\n+      StubRoutines::_vector_tanh_double256  = CAST_FROM_FN_PTR(address, __svml_tanh4_ha_l9);\n+      StubRoutines::_vector_acos_float64    = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_l9);\n+      StubRoutines::_vector_acos_float128   = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_l9);\n+      StubRoutines::_vector_acos_float256   = CAST_FROM_FN_PTR(address, __svml_acosf8_ha_l9);\n+      StubRoutines::_vector_acos_double64   = CAST_FROM_FN_PTR(address, __svml_acos1_ha_l9);\n+      StubRoutines::_vector_acos_double128  = CAST_FROM_FN_PTR(address, __svml_acos2_ha_l9);\n+      StubRoutines::_vector_acos_double256  = CAST_FROM_FN_PTR(address, __svml_acos4_ha_l9);\n+      StubRoutines::_vector_asin_float64    = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_l9);\n+      StubRoutines::_vector_asin_float128   = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_l9);\n+      StubRoutines::_vector_asin_float256   = CAST_FROM_FN_PTR(address, __svml_asinf8_ha_l9);\n+      StubRoutines::_vector_asin_double64   = CAST_FROM_FN_PTR(address, __svml_asin1_ha_l9);\n+      StubRoutines::_vector_asin_double128  = CAST_FROM_FN_PTR(address, __svml_asin2_ha_l9);\n+      StubRoutines::_vector_asin_double256  = CAST_FROM_FN_PTR(address, __svml_asin4_ha_l9);\n+      StubRoutines::_vector_atan_float64    = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_l9);\n+      StubRoutines::_vector_atan_float128   = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_l9);\n+      StubRoutines::_vector_atan_float256   = CAST_FROM_FN_PTR(address, __svml_atanf8_ha_l9);\n+      StubRoutines::_vector_atan_double64   = CAST_FROM_FN_PTR(address, __svml_atan1_ha_l9);\n+      StubRoutines::_vector_atan_double128  = CAST_FROM_FN_PTR(address, __svml_atan2_ha_l9);\n+      StubRoutines::_vector_atan_double256  = CAST_FROM_FN_PTR(address, __svml_atan4_ha_l9);\n+      StubRoutines::_vector_pow_float64     = CAST_FROM_FN_PTR(address, __svml_powf4_ha_l9);\n+      StubRoutines::_vector_pow_float128    = CAST_FROM_FN_PTR(address, __svml_powf4_ha_l9);\n+      StubRoutines::_vector_pow_float256    = CAST_FROM_FN_PTR(address, __svml_powf8_ha_l9);\n+      StubRoutines::_vector_pow_double64    = CAST_FROM_FN_PTR(address, __svml_pow1_ha_l9);\n+      StubRoutines::_vector_pow_double128   = CAST_FROM_FN_PTR(address, __svml_pow2_ha_l9);\n+      StubRoutines::_vector_pow_double256   = CAST_FROM_FN_PTR(address, __svml_pow4_ha_l9);\n+      StubRoutines::_vector_hypot_float64   = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_l9);\n+      StubRoutines::_vector_hypot_float128  = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_l9);\n+      StubRoutines::_vector_hypot_float256  = CAST_FROM_FN_PTR(address, __svml_hypotf8_ha_l9);\n+      StubRoutines::_vector_hypot_double64  = CAST_FROM_FN_PTR(address, __svml_hypot1_ha_l9);\n+      StubRoutines::_vector_hypot_double128 = CAST_FROM_FN_PTR(address, __svml_hypot2_ha_l9);\n+      StubRoutines::_vector_hypot_double256 = CAST_FROM_FN_PTR(address, __svml_hypot4_ha_l9);\n+      StubRoutines::_vector_cbrt_float64    = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_l9);\n+      StubRoutines::_vector_cbrt_float128   = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_l9);\n+      StubRoutines::_vector_cbrt_float256   = CAST_FROM_FN_PTR(address, __svml_cbrtf8_ha_l9);\n+      StubRoutines::_vector_cbrt_double64   = CAST_FROM_FN_PTR(address, __svml_cbrt1_ha_l9);\n+      StubRoutines::_vector_cbrt_double128  = CAST_FROM_FN_PTR(address, __svml_cbrt2_ha_l9);\n+      StubRoutines::_vector_cbrt_double256  = CAST_FROM_FN_PTR(address, __svml_cbrt4_ha_l9);\n+      StubRoutines::_vector_atan2_float64   = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_l9);\n+      StubRoutines::_vector_atan2_float128  = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_l9);\n+      StubRoutines::_vector_atan2_float256  = CAST_FROM_FN_PTR(address, __svml_atan2f8_ha_l9);\n+      StubRoutines::_vector_atan2_double64  = CAST_FROM_FN_PTR(address, __svml_atan21_ha_l9);\n+      StubRoutines::_vector_atan2_double128 = CAST_FROM_FN_PTR(address, __svml_atan22_ha_l9);\n+      StubRoutines::_vector_atan2_double256 = CAST_FROM_FN_PTR(address, __svml_atan24_ha_l9);\n+    } else if (UseAVX > 0) {\n+      StubRoutines::_vector_exp_float64     = CAST_FROM_FN_PTR(address, __svml_expf4_ha_e9);\n+      StubRoutines::_vector_exp_float128    = CAST_FROM_FN_PTR(address, __svml_expf4_ha_e9);\n+      StubRoutines::_vector_exp_float256    = CAST_FROM_FN_PTR(address, __svml_expf8_ha_e9);\n+      StubRoutines::_vector_exp_double64    = CAST_FROM_FN_PTR(address, __svml_exp1_ha_e9);\n+      StubRoutines::_vector_exp_double128   = CAST_FROM_FN_PTR(address, __svml_exp2_ha_e9);\n+      StubRoutines::_vector_exp_double256   = CAST_FROM_FN_PTR(address, __svml_exp4_ha_e9);\n+      StubRoutines::_vector_expm1_float64   = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_e9);\n+      StubRoutines::_vector_expm1_float128  = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_e9);\n+      StubRoutines::_vector_expm1_float256  = CAST_FROM_FN_PTR(address, __svml_expm1f8_ha_e9);\n+      StubRoutines::_vector_expm1_double64  = CAST_FROM_FN_PTR(address, __svml_expm11_ha_e9);\n+      StubRoutines::_vector_expm1_double128 = CAST_FROM_FN_PTR(address, __svml_expm12_ha_e9);\n+      StubRoutines::_vector_expm1_double256 = CAST_FROM_FN_PTR(address, __svml_expm14_ha_e9);\n+      StubRoutines::_vector_log1p_float64   = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_e9);\n+      StubRoutines::_vector_log1p_float128  = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_e9);\n+      StubRoutines::_vector_log1p_float256  = CAST_FROM_FN_PTR(address, __svml_log1pf8_ha_e9);\n+      StubRoutines::_vector_log1p_double64  = CAST_FROM_FN_PTR(address, __svml_log1p1_ha_e9);\n+      StubRoutines::_vector_log1p_double128 = CAST_FROM_FN_PTR(address, __svml_log1p2_ha_e9);\n+      StubRoutines::_vector_log1p_double256 = CAST_FROM_FN_PTR(address, __svml_log1p4_ha_e9);\n+      StubRoutines::_vector_log_float64     = CAST_FROM_FN_PTR(address, __svml_logf4_ha_e9);\n+      StubRoutines::_vector_log_float128    = CAST_FROM_FN_PTR(address, __svml_logf4_ha_e9);\n+      StubRoutines::_vector_log_float256    = CAST_FROM_FN_PTR(address, __svml_logf8_ha_e9);\n+      StubRoutines::_vector_log_double64    = CAST_FROM_FN_PTR(address, __svml_log1_ha_e9);\n+      StubRoutines::_vector_log_double128   = CAST_FROM_FN_PTR(address, __svml_log2_ha_e9);\n+      StubRoutines::_vector_log_double256   = CAST_FROM_FN_PTR(address, __svml_log4_ha_e9);\n+      StubRoutines::_vector_log10_float64   = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_e9);\n+      StubRoutines::_vector_log10_float128  = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_e9);\n+      StubRoutines::_vector_log10_float256  = CAST_FROM_FN_PTR(address, __svml_log10f8_ha_e9);\n+      StubRoutines::_vector_log10_double64  = CAST_FROM_FN_PTR(address, __svml_log101_ha_e9);\n+      StubRoutines::_vector_log10_double128 = CAST_FROM_FN_PTR(address, __svml_log102_ha_e9);\n+      StubRoutines::_vector_log10_double256 = CAST_FROM_FN_PTR(address, __svml_log104_ha_e9);\n+      StubRoutines::_vector_sin_float64     = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_e9);\n+      StubRoutines::_vector_sin_float128    = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_e9);\n+      StubRoutines::_vector_sin_float256    = CAST_FROM_FN_PTR(address, __svml_sinf8_ha_e9);\n+      StubRoutines::_vector_sin_double64    = CAST_FROM_FN_PTR(address, __svml_sin1_ha_e9);\n+      StubRoutines::_vector_sin_double128   = CAST_FROM_FN_PTR(address, __svml_sin2_ha_e9);\n+      StubRoutines::_vector_sin_double256   = CAST_FROM_FN_PTR(address, __svml_sin4_ha_e9);\n+      StubRoutines::_vector_cos_float64     = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_e9);\n+      StubRoutines::_vector_cos_float128    = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_e9);\n+      StubRoutines::_vector_cos_float256    = CAST_FROM_FN_PTR(address, __svml_cosf8_ha_e9);\n+      StubRoutines::_vector_cos_double64    = CAST_FROM_FN_PTR(address, __svml_cos1_ha_e9);\n+      StubRoutines::_vector_cos_double128   = CAST_FROM_FN_PTR(address, __svml_cos2_ha_e9);\n+      StubRoutines::_vector_cos_double256   = CAST_FROM_FN_PTR(address, __svml_cos4_ha_e9);\n+      StubRoutines::_vector_tan_float64     = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_e9);\n+      StubRoutines::_vector_tan_float128    = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_e9);\n+      StubRoutines::_vector_tan_float256    = CAST_FROM_FN_PTR(address, __svml_tanf8_ha_e9);\n+      StubRoutines::_vector_tan_double64    = CAST_FROM_FN_PTR(address, __svml_tan1_ha_e9);\n+      StubRoutines::_vector_tan_double128   = CAST_FROM_FN_PTR(address, __svml_tan2_ha_e9);\n+      StubRoutines::_vector_tan_double256   = CAST_FROM_FN_PTR(address, __svml_tan4_ha_e9);\n+      StubRoutines::_vector_sinh_float64    = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_e9);\n+      StubRoutines::_vector_sinh_float128   = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_e9);\n+      StubRoutines::_vector_sinh_float256   = CAST_FROM_FN_PTR(address, __svml_sinhf8_ha_e9);\n+      StubRoutines::_vector_sinh_double64   = CAST_FROM_FN_PTR(address, __svml_sinh1_ha_e9);\n+      StubRoutines::_vector_sinh_double128  = CAST_FROM_FN_PTR(address, __svml_sinh2_ha_e9);\n+      StubRoutines::_vector_sinh_double256  = CAST_FROM_FN_PTR(address, __svml_sinh4_ha_e9);\n+      StubRoutines::_vector_cosh_float64    = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_e9);\n+      StubRoutines::_vector_cosh_float128   = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_e9);\n+      StubRoutines::_vector_cosh_float256   = CAST_FROM_FN_PTR(address, __svml_coshf8_ha_e9);\n+      StubRoutines::_vector_cosh_double64   = CAST_FROM_FN_PTR(address, __svml_cosh1_ha_e9);\n+      StubRoutines::_vector_cosh_double128  = CAST_FROM_FN_PTR(address, __svml_cosh2_ha_e9);\n+      StubRoutines::_vector_cosh_double256  = CAST_FROM_FN_PTR(address, __svml_cosh4_ha_e9);\n+      StubRoutines::_vector_tanh_float64    = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_e9);\n+      StubRoutines::_vector_tanh_float128   = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_e9);\n+      StubRoutines::_vector_tanh_float256   = CAST_FROM_FN_PTR(address, __svml_tanhf8_ha_e9);\n+      StubRoutines::_vector_tanh_double64   = CAST_FROM_FN_PTR(address, __svml_tanh1_ha_e9);\n+      StubRoutines::_vector_tanh_double128  = CAST_FROM_FN_PTR(address, __svml_tanh2_ha_e9);\n+      StubRoutines::_vector_tanh_double256  = CAST_FROM_FN_PTR(address, __svml_tanh4_ha_e9);\n+      StubRoutines::_vector_acos_float64    = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_e9);\n+      StubRoutines::_vector_acos_float128   = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_e9);\n+      StubRoutines::_vector_acos_float256   = CAST_FROM_FN_PTR(address, __svml_acosf8_ha_e9);\n+      StubRoutines::_vector_acos_double64   = CAST_FROM_FN_PTR(address, __svml_acos1_ha_e9);\n+      StubRoutines::_vector_acos_double128  = CAST_FROM_FN_PTR(address, __svml_acos2_ha_e9);\n+      StubRoutines::_vector_acos_double256  = CAST_FROM_FN_PTR(address, __svml_acos4_ha_e9);\n+      StubRoutines::_vector_asin_float64    = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_e9);\n+      StubRoutines::_vector_asin_float128   = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_e9);\n+      StubRoutines::_vector_asin_float256   = CAST_FROM_FN_PTR(address, __svml_asinf8_ha_e9);\n+      StubRoutines::_vector_asin_double64   = CAST_FROM_FN_PTR(address, __svml_asin1_ha_e9);\n+      StubRoutines::_vector_asin_double128  = CAST_FROM_FN_PTR(address, __svml_asin2_ha_e9);\n+      StubRoutines::_vector_asin_double256  = CAST_FROM_FN_PTR(address, __svml_asin4_ha_e9);\n+      StubRoutines::_vector_atan_float64    = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_e9);\n+      StubRoutines::_vector_atan_float128   = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_e9);\n+      StubRoutines::_vector_atan_float256   = CAST_FROM_FN_PTR(address, __svml_atanf8_ha_e9);\n+      StubRoutines::_vector_atan_double64   = CAST_FROM_FN_PTR(address, __svml_atan1_ha_e9);\n+      StubRoutines::_vector_atan_double128  = CAST_FROM_FN_PTR(address, __svml_atan2_ha_e9);\n+      StubRoutines::_vector_atan_double256  = CAST_FROM_FN_PTR(address, __svml_atan4_ha_e9);\n+      StubRoutines::_vector_pow_float64     = CAST_FROM_FN_PTR(address, __svml_powf4_ha_e9);\n+      StubRoutines::_vector_pow_float128    = CAST_FROM_FN_PTR(address, __svml_powf4_ha_e9);\n+      StubRoutines::_vector_pow_float256    = CAST_FROM_FN_PTR(address, __svml_powf8_ha_e9);\n+      StubRoutines::_vector_pow_double64    = CAST_FROM_FN_PTR(address, __svml_pow1_ha_e9);\n+      StubRoutines::_vector_pow_double128   = CAST_FROM_FN_PTR(address, __svml_pow2_ha_e9);\n+      StubRoutines::_vector_pow_double256   = CAST_FROM_FN_PTR(address, __svml_pow4_ha_e9);\n+      StubRoutines::_vector_hypot_float64   = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_e9);\n+      StubRoutines::_vector_hypot_float128  = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_e9);\n+      StubRoutines::_vector_hypot_float256  = CAST_FROM_FN_PTR(address, __svml_hypotf8_ha_e9);\n+      StubRoutines::_vector_hypot_double64  = CAST_FROM_FN_PTR(address, __svml_hypot1_ha_e9);\n+      StubRoutines::_vector_hypot_double128 = CAST_FROM_FN_PTR(address, __svml_hypot2_ha_e9);\n+      StubRoutines::_vector_hypot_double256 = CAST_FROM_FN_PTR(address, __svml_hypot4_ha_e9);\n+      StubRoutines::_vector_cbrt_float64    = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_e9);\n+      StubRoutines::_vector_cbrt_float128   = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_e9);\n+      StubRoutines::_vector_cbrt_float256   = CAST_FROM_FN_PTR(address, __svml_cbrtf8_ha_e9);\n+      StubRoutines::_vector_cbrt_double64   = CAST_FROM_FN_PTR(address, __svml_cbrt1_ha_e9);\n+      StubRoutines::_vector_cbrt_double128  = CAST_FROM_FN_PTR(address, __svml_cbrt2_ha_e9);\n+      StubRoutines::_vector_cbrt_double256  = CAST_FROM_FN_PTR(address, __svml_cbrt4_ha_e9);\n+      StubRoutines::_vector_atan2_float64   = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_e9);\n+      StubRoutines::_vector_atan2_float128  = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_e9);\n+      StubRoutines::_vector_atan2_float256  = CAST_FROM_FN_PTR(address, __svml_atan2f8_ha_e9);\n+      StubRoutines::_vector_atan2_double64  = CAST_FROM_FN_PTR(address, __svml_atan21_ha_e9);\n+      StubRoutines::_vector_atan2_double128 = CAST_FROM_FN_PTR(address, __svml_atan22_ha_e9);\n+      StubRoutines::_vector_atan2_double256 = CAST_FROM_FN_PTR(address, __svml_atan24_ha_e9);\n+    } else {\n+      assert(UseAVX == 0 && UseSSE >= 2, \"\");\n+      StubRoutines::_vector_exp_float64     = CAST_FROM_FN_PTR(address, __svml_expf4_ha_ex);\n+      StubRoutines::_vector_exp_float128    = CAST_FROM_FN_PTR(address, __svml_expf4_ha_ex);\n+      StubRoutines::_vector_exp_double64    = CAST_FROM_FN_PTR(address, __svml_exp1_ha_ex);\n+      StubRoutines::_vector_exp_double128   = CAST_FROM_FN_PTR(address, __svml_exp2_ha_ex);\n+      StubRoutines::_vector_expm1_float64   = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_ex);\n+      StubRoutines::_vector_expm1_float128  = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_ex);\n+      StubRoutines::_vector_expm1_double64  = CAST_FROM_FN_PTR(address, __svml_expm11_ha_ex);\n+      StubRoutines::_vector_expm1_double128 = CAST_FROM_FN_PTR(address, __svml_expm12_ha_ex);\n+      StubRoutines::_vector_acos_float64    = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_ex);\n+      StubRoutines::_vector_acos_float128   = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_ex);\n+      StubRoutines::_vector_acos_double64   = CAST_FROM_FN_PTR(address, __svml_acos1_ha_ex);\n+      StubRoutines::_vector_acos_double128  = CAST_FROM_FN_PTR(address, __svml_acos2_ha_ex);\n+      StubRoutines::_vector_asin_float64    = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_ex);\n+      StubRoutines::_vector_asin_float128   = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_ex);\n+      StubRoutines::_vector_asin_double64   = CAST_FROM_FN_PTR(address, __svml_asin1_ha_ex);\n+      StubRoutines::_vector_asin_double128  = CAST_FROM_FN_PTR(address, __svml_asin2_ha_ex);\n+      StubRoutines::_vector_atan_float64    = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_ex);\n+      StubRoutines::_vector_atan_float128   = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_ex);\n+      StubRoutines::_vector_atan_double64   = CAST_FROM_FN_PTR(address, __svml_atan1_ha_ex);\n+      StubRoutines::_vector_atan_double128  = CAST_FROM_FN_PTR(address, __svml_atan2_ha_ex);\n+      StubRoutines::_vector_sin_float64     = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_ex);\n+      StubRoutines::_vector_sin_float128    = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_ex);\n+      StubRoutines::_vector_sin_double64    = CAST_FROM_FN_PTR(address, __svml_sin1_ha_ex);\n+      StubRoutines::_vector_sin_double128   = CAST_FROM_FN_PTR(address, __svml_sin2_ha_ex);\n+      StubRoutines::_vector_cos_float64     = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_ex);\n+      StubRoutines::_vector_cos_float128    = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_ex);\n+      StubRoutines::_vector_cos_double64    = CAST_FROM_FN_PTR(address, __svml_cos1_ha_ex);\n+      StubRoutines::_vector_cos_double128   = CAST_FROM_FN_PTR(address, __svml_cos2_ha_ex);\n+      StubRoutines::_vector_tan_float64     = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_ex);\n+      StubRoutines::_vector_tan_float128    = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_ex);\n+      StubRoutines::_vector_tan_double64    = CAST_FROM_FN_PTR(address, __svml_tan1_ha_ex);\n+      StubRoutines::_vector_tan_double128   = CAST_FROM_FN_PTR(address, __svml_tan2_ha_ex);\n+      StubRoutines::_vector_sinh_float64    = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_ex);\n+      StubRoutines::_vector_sinh_float128   = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_ex);\n+      StubRoutines::_vector_sinh_double64   = CAST_FROM_FN_PTR(address, __svml_sinh1_ha_ex);\n+      StubRoutines::_vector_sinh_double128  = CAST_FROM_FN_PTR(address, __svml_sinh2_ha_ex);\n+      StubRoutines::_vector_cosh_float64    = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_ex);\n+      StubRoutines::_vector_cosh_float128   = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_ex);\n+      StubRoutines::_vector_cosh_double64   = CAST_FROM_FN_PTR(address, __svml_cosh1_ha_ex);\n+      StubRoutines::_vector_cosh_double128  = CAST_FROM_FN_PTR(address, __svml_cosh2_ha_ex);\n+      StubRoutines::_vector_tanh_float64    = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_ex);\n+      StubRoutines::_vector_tanh_float128   = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_ex);\n+      StubRoutines::_vector_tanh_double64   = CAST_FROM_FN_PTR(address, __svml_tanh1_ha_ex);\n+      StubRoutines::_vector_tanh_double128  = CAST_FROM_FN_PTR(address, __svml_tanh2_ha_ex);\n+      StubRoutines::_vector_log_float64     = CAST_FROM_FN_PTR(address, __svml_logf4_ha_ex);\n+      StubRoutines::_vector_log_float128    = CAST_FROM_FN_PTR(address, __svml_logf4_ha_ex);\n+      StubRoutines::_vector_log_double64    = CAST_FROM_FN_PTR(address, __svml_log1_ha_ex);\n+      StubRoutines::_vector_log_double128   = CAST_FROM_FN_PTR(address, __svml_log2_ha_ex);\n+      StubRoutines::_vector_log10_float64   = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_ex);\n+      StubRoutines::_vector_log10_float128  = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_ex);\n+      StubRoutines::_vector_log10_double64  = CAST_FROM_FN_PTR(address, __svml_log101_ha_ex);\n+      StubRoutines::_vector_log10_double128 = CAST_FROM_FN_PTR(address, __svml_log102_ha_ex);\n+      StubRoutines::_vector_log1p_float64   = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_ex);\n+      StubRoutines::_vector_log1p_float128  = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_ex);\n+      StubRoutines::_vector_log1p_double64  = CAST_FROM_FN_PTR(address, __svml_log1p1_ha_ex);\n+      StubRoutines::_vector_log1p_double128 = CAST_FROM_FN_PTR(address, __svml_log1p2_ha_ex);\n+      StubRoutines::_vector_atan2_float64   = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_ex);\n+      StubRoutines::_vector_atan2_float128  = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_ex);\n+      StubRoutines::_vector_atan2_double64  = CAST_FROM_FN_PTR(address, __svml_atan21_ha_ex);\n+      StubRoutines::_vector_atan2_double128 = CAST_FROM_FN_PTR(address, __svml_atan22_ha_ex);\n+      StubRoutines::_vector_hypot_float64   = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_ex);\n+      StubRoutines::_vector_hypot_float128  = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_ex);\n+      StubRoutines::_vector_hypot_double64  = CAST_FROM_FN_PTR(address, __svml_hypot1_ha_ex);\n+      StubRoutines::_vector_hypot_double128 = CAST_FROM_FN_PTR(address, __svml_hypot2_ha_ex);\n+      StubRoutines::_vector_pow_float64     = CAST_FROM_FN_PTR(address, __svml_powf4_ha_ex);\n+      StubRoutines::_vector_pow_float128    = CAST_FROM_FN_PTR(address, __svml_powf4_ha_ex);\n+      StubRoutines::_vector_pow_double64    = CAST_FROM_FN_PTR(address, __svml_pow1_ha_ex);\n+      StubRoutines::_vector_pow_double128   = CAST_FROM_FN_PTR(address, __svml_pow2_ha_ex);\n+      StubRoutines::_vector_cbrt_float64    = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_ex);\n+      StubRoutines::_vector_cbrt_float128   = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_ex);\n+      StubRoutines::_vector_cbrt_double64   = CAST_FROM_FN_PTR(address, __svml_cbrt1_ha_ex);\n+      StubRoutines::_vector_cbrt_double128  = CAST_FROM_FN_PTR(address, __svml_cbrt2_ha_ex);\n+    }\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":612,"deletions":0,"binary":false,"changes":612,"status":"modified"},{"patch":"@@ -1374,0 +1374,14 @@\n+\/\/ Vector calling convention not supported.\n+const bool Matcher::supports_vector_calling_convention() {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1585,0 +1585,17 @@\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return true;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  int lo = XMM0_num;\n+  int hi = XMM0b_num;\n+  if (ideal_reg == Op_VecX) hi = XMM0d_num;\n+  else if (ideal_reg == Op_VecY) hi = XMM0h_num;\n+  else if (ideal_reg == Op_VecZ) hi = XMM0p_num;\n+  return OptoRegPair(hi, lo);\n+}\n+\n@@ -12424,0 +12441,12 @@\n+\/\/ Call runtime without safepoint and with vector arguments\n+instruct CallLeafDirectVector(method meth)\n+%{\n+  match(CallLeafVector);\n+  effect(USE meth);\n+\n+  ins_cost(300);\n+  format %{ \"call_leaf,vector \" %}\n+  ins_encode(Java_To_Runtime(meth));\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -715,0 +715,3 @@\n+  product(bool, IncrementalInlineVirtual, true, DIAGNOSTIC,                 \\\n+          \"do post parse inlining of virtual calls\")                        \\\n+                                                                            \\\n@@ -755,0 +758,3 @@\n+  product(bool, UseVectorStubs, false, EXPERIMENTAL,                        \\\n+          \"Use stubs for vector transcendental operations\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,0 +122,3 @@\n+protected:\n+  void set_call_node(CallStaticJavaNode* call) { _call_node = call; }\n+\n@@ -130,1 +133,8 @@\n-  CallStaticJavaNode* call_node() const { return _call_node; }\n+  virtual bool is_direct() const { return true; }\n+\n+  virtual CallNode* call_node() const { return _call_node; }\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    DirectCallGenerator* dcg = new DirectCallGenerator(method(), _separate_io_proj);\n+    dcg->set_call_node(call->as_CallStaticJava());\n+    return dcg;\n+  }\n@@ -180,0 +190,6 @@\n+  bool _separate_io_proj;\n+  CallDynamicJavaNode* _call_node;\n+\n+protected:\n+  void set_call_node(CallDynamicJavaNode* call) { _call_node = call; }\n+\n@@ -181,2 +197,2 @@\n-  VirtualCallGenerator(ciMethod* method, int vtable_index)\n-    : CallGenerator(method), _vtable_index(vtable_index)\n+  VirtualCallGenerator(ciMethod* method, int vtable_index, bool separate_io_proj)\n+    : CallGenerator(method), _vtable_index(vtable_index), _separate_io_proj(separate_io_proj), _call_node(NULL)\n@@ -189,0 +205,9 @@\n+\n+  virtual CallNode* call_node() const { return _call_node; }\n+  int vtable_index() const { return _vtable_index; }\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    VirtualCallGenerator* cg = new VirtualCallGenerator(method(), _vtable_index, _separate_io_proj);\n+    cg->set_call_node(call->as_CallDynamicJava());\n+    return cg;\n+  }\n@@ -251,0 +276,2 @@\n+  _call_node = call;  \/\/ Save the call node in case we need it later\n+\n@@ -252,2 +279,2 @@\n-  kit.set_edges_for_java_call(call);\n-  Node* ret = kit.set_results_for_java_call(call);\n+  kit.set_edges_for_java_call(call, false \/*must_throw*\/, _separate_io_proj);\n+  Node* ret = kit.set_results_for_java_call(call, _separate_io_proj);\n@@ -286,1 +313,1 @@\n-  return new VirtualCallGenerator(m, vtable_index);\n+  return new VirtualCallGenerator(m, vtable_index, false \/*separate_io_projs*\/);\n@@ -342,0 +369,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineCallGenerator* cg = new LateInlineCallGenerator(method(), _inline_cg, _is_pure_call);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -346,1 +379,1 @@\n-  CallStaticJavaNode* call = call_node();\n+  CallStaticJavaNode* call = call_node()->as_CallStaticJava();\n@@ -497,0 +530,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineMHCallGenerator* cg = new LateInlineMHCallGenerator(_caller, method(), _input_not_const);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -526,0 +565,230 @@\n+\/\/ Allow inlining decisions to be delayed\n+class LateInlineVirtualCallGenerator : public VirtualCallGenerator {\n+ private:\n+  jlong _unique_id;   \/\/ unique id for log compilation\n+  CallGenerator* _inline_cg;\n+  ciMethod* _callee;\n+  bool _is_pure_call;\n+  float _prof_factor;\n+ protected:\n+  virtual bool do_late_inline_check(Compile* C, JVMState* jvms);\n+\n+ public:\n+  LateInlineVirtualCallGenerator(ciMethod* method, int vtable_index, float prof_factor)\n+  : VirtualCallGenerator(method, vtable_index, true \/*separate_io_projs*\/), _unique_id(0), _inline_cg(NULL), _callee(NULL), _is_pure_call(false), _prof_factor(prof_factor) {}\n+\n+  virtual bool is_virtual_late_inline() const { return true; }\n+\n+  \/\/ Convert the CallDynamicJava into an inline\n+  virtual void do_late_inline();\n+\n+  virtual void set_callee_method(ciMethod* m) {\n+    assert(_callee == NULL, \"repeated inlining attempt\");\n+    _callee = m;\n+  }\n+\n+  virtual JVMState* generate(JVMState* jvms) {\n+    Compile* C = Compile::current();\n+\n+    \/\/ Emit the CallDynamicJava and request separate projections so\n+    \/\/ that the late inlining logic can distinguish between fall\n+    \/\/ through and exceptional uses of the memory and io projections\n+    \/\/ as is done for allocations and macro expansion.\n+    JVMState* new_jvms = VirtualCallGenerator::generate(jvms);\n+    if (call_node() != NULL) {\n+      call_node()->set_generator(this);\n+    }\n+    return new_jvms;\n+  }\n+\n+  virtual void print_inlining_late(const char* msg) {\n+    CallNode* call = call_node();\n+    Compile* C = Compile::current();\n+    C->print_inlining_assert_ready();\n+    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), msg);\n+    C->print_inlining_move_to(this);\n+    C->print_inlining_update_delayed(this);\n+  }\n+\n+  virtual void set_unique_id(jlong id) {\n+    _unique_id = id;\n+  }\n+\n+  virtual jlong unique_id() const {\n+    return _unique_id;\n+  }\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineVirtualCallGenerator* cg = new LateInlineVirtualCallGenerator(method(), vtable_index(), _prof_factor);\n+    cg->set_call_node(call->as_CallDynamicJava());\n+    return cg;\n+  }\n+};\n+\n+bool LateInlineVirtualCallGenerator::do_late_inline_check(Compile* C, JVMState* jvms) {\n+  \/\/ Method handle linker case is handled in CallDynamicJavaNode::Ideal().\n+  \/\/ Unless inlining is performed, _override_symbolic_info bit will be set in DirectCallGenerator::generate().\n+\n+  bool allow_inline = C->inlining_incrementally();\n+  CallGenerator* cg = C->call_generator(_callee,\n+                                        vtable_index(),\n+                                        false \/*call_does_dispatch*\/,\n+                                        jvms,\n+                                        allow_inline,\n+                                        _prof_factor,\n+                                        NULL \/*speculative_receiver_type*\/,\n+                                        true \/*allow_intrinsics*\/);\n+\n+  Compile::current()->print_inlining_update_delayed(this);\n+\n+  if (cg != NULL) {\n+    assert(!cg->is_late_inline() || cg->is_mh_late_inline() || AlwaysIncrementalInline, \"we're doing late inlining\");\n+    _inline_cg = cg;\n+    return true;\n+  }\n+  call_node()->set_generator(this);\n+  return false;\n+}\n+\n+void LateInlineVirtualCallGenerator::do_late_inline() {\n+  assert(_callee != NULL, \"required\");\n+\n+  \/\/ Can't inline it\n+  CallDynamicJavaNode* call = call_node()->as_CallDynamicJava();\n+  if (call == NULL || call->outcnt() == 0 ||\n+      call->in(0) == NULL || call->in(0)->is_top()) {\n+    return;\n+  }\n+\n+  const TypeTuple *r = call->tf()->domain();\n+  for (int i1 = 0; i1 < method()->arg_size(); i1++) {\n+    if (call->in(TypeFunc::Parms + i1)->is_top() && r->field_at(TypeFunc::Parms + i1) != Type::HALF) {\n+      assert(Compile::current()->inlining_incrementally(), \"shouldn't happen during parsing\");\n+      return;\n+    }\n+  }\n+\n+  if (call->in(TypeFunc::Memory)->is_top()) {\n+    assert(Compile::current()->inlining_incrementally(), \"shouldn't happen during parsing\");\n+    return;\n+  }\n+\n+  \/\/ check for unreachable loop\n+  CallProjections callprojs;\n+  call->extract_projections(&callprojs, true);\n+  if ((callprojs.fallthrough_catchproj == call->in(0)) ||\n+      (callprojs.catchall_catchproj    == call->in(0)) ||\n+      (callprojs.fallthrough_memproj   == call->in(TypeFunc::Memory)) ||\n+      (callprojs.catchall_memproj      == call->in(TypeFunc::Memory)) ||\n+      (callprojs.fallthrough_ioproj    == call->in(TypeFunc::I_O)) ||\n+      (callprojs.catchall_ioproj       == call->in(TypeFunc::I_O)) ||\n+      (callprojs.resproj != NULL && call->find_edge(callprojs.resproj) != -1) ||\n+      (callprojs.exobj   != NULL && call->find_edge(callprojs.exobj) != -1)) {\n+    return;\n+  }\n+\n+  Compile* C = Compile::current();\n+  \/\/ Remove inlined methods from Compiler's lists.\n+  if (call->is_macro()) {\n+    C->remove_macro_node(call);\n+  }\n+\n+  bool result_not_used = (callprojs.resproj == NULL || callprojs.resproj->outcnt() == 0);\n+  if (_is_pure_call && result_not_used) {\n+    \/\/ The call is marked as pure (no important side effects), but result isn't used.\n+    \/\/ It's safe to remove the call.\n+    GraphKit kit(call->jvms());\n+    kit.replace_call(call, C->top(), true);\n+  } else {\n+    \/\/ Make a clone of the JVMState that appropriate to use for driving a parse\n+    JVMState* old_jvms = call->jvms();\n+    JVMState* jvms = old_jvms->clone_shallow(C);\n+    uint size = call->req();\n+    SafePointNode* map = new SafePointNode(size, jvms);\n+    for (uint i1 = 0; i1 < size; i1++) {\n+      map->init_req(i1, call->in(i1));\n+    }\n+\n+    \/\/ Make sure the state is a MergeMem for parsing.\n+    if (!map->in(TypeFunc::Memory)->is_MergeMem()) {\n+      Node* mem = MergeMemNode::make(map->in(TypeFunc::Memory));\n+      C->initial_gvn()->set_type_bottom(mem);\n+      map->set_req(TypeFunc::Memory, mem);\n+    }\n+\n+    uint nargs = method()->arg_size();\n+    \/\/ blow away old call arguments\n+    Node* top = C->top();\n+    for (uint i1 = 0; i1 < nargs; i1++) {\n+      map->set_req(TypeFunc::Parms + i1, top);\n+    }\n+    jvms->set_map(map);\n+\n+    \/\/ Make enough space in the expression stack to transfer\n+    \/\/ the incoming arguments and return value.\n+    map->ensure_stack(jvms, jvms->method()->max_stack());\n+    for (uint i1 = 0; i1 < nargs; i1++) {\n+      map->set_argument(jvms, i1, call->in(TypeFunc::Parms + i1));\n+    }\n+\n+    C->print_inlining_assert_ready();\n+\n+    C->print_inlining_move_to(this);\n+\n+    C->log_late_inline(this);\n+\n+    \/\/ This check is done here because for_method_handle_inline() method\n+    \/\/ needs jvms for inlined state.\n+    if (!do_late_inline_check(C, jvms)) {\n+      map->disconnect_inputs(C);\n+      return;\n+    }\n+\n+    \/\/ Setup default node notes to be picked up by the inlining\n+    Node_Notes* old_nn = C->node_notes_at(call->_idx);\n+    if (old_nn != NULL) {\n+      Node_Notes* entry_nn = old_nn->clone(C);\n+      entry_nn->set_jvms(jvms);\n+      C->set_default_node_notes(entry_nn);\n+    }\n+\n+    { \/\/ Virtual call sometimes involves implicit null check.\n+      GraphKit kit(jvms);\n+      kit.null_check_receiver();\n+      jvms = kit.transfer_exceptions_into_jvms();\n+    }\n+\n+    \/\/ Now perform the inlining using the synthesized JVMState\n+    JVMState* new_jvms = _inline_cg->generate(jvms);\n+    if (new_jvms == NULL)  return;  \/\/ no change\n+    if (C->failing())      return;\n+\n+    \/\/ Capture any exceptional control flow\n+    GraphKit kit(new_jvms);\n+\n+    \/\/ Find the result object\n+    Node* result = C->top();\n+    int   result_size = method()->return_type()->size();\n+    if (result_size != 0 && !kit.stopped()) {\n+      result = (result_size == 1) ? kit.pop() : kit.pop_pair();\n+    }\n+\n+    if (_inline_cg->is_inline()) {\n+      \/\/ TODO: is_inline() == true for intrinsics as well\n+      C->set_has_loops(C->has_loops() || _inline_cg->method()->has_loops());\n+      C->env()->notice_inlined_method(_inline_cg->method());\n+    } else {\n+      assert(_inline_cg->is_direct(), \"sanity\");\n+    }\n+    C->set_inlining_progress(true);\n+    C->set_do_cleanup(kit.stopped()); \/\/ path is dead; needs cleanup\n+    kit.replace_call(call, result, true);\n+  }\n+}\n+\n+CallGenerator* CallGenerator::for_late_inline_virtual(ciMethod* m, int vtable_index, float prof_factor) {\n+  assert(!m->is_static(), \"for_virtual_call mismatch\");\n+  assert(!m->is_method_handle_intrinsic(), \"should be a direct call\");\n+  return new LateInlineVirtualCallGenerator(m, vtable_index, prof_factor);\n+}\n+\n@@ -544,0 +813,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineStringCallGenerator* cg = new LateInlineStringCallGenerator(method(), _inline_cg);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -566,0 +841,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineBoxingCallGenerator* cg = new LateInlineBoxingCallGenerator(method(), _inline_cg);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -588,0 +869,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineVectorReboxingCallGenerator* cg = new LateInlineVectorReboxingCallGenerator(method(), _inline_cg);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -1016,1 +1303,1 @@\n-  virtual bool      is_inlined()   const    { return true; }\n+  virtual bool      is_inline()    const    { return true; }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":295,"deletions":8,"binary":false,"changes":303,"status":"modified"},{"patch":"@@ -355,0 +355,51 @@\n+void Compile::remove_useless_late_inlines(GrowableArray<CallGenerator*>* inlines, Node* dead) {\n+  assert(dead != NULL && dead->is_Call(), \"sanity\");\n+  int shift = 0;\n+  for (int i = 0; i < inlines->length(); i++) {\n+    CallGenerator* cg = inlines->at(i);\n+    CallNode* call = cg->call_node();\n+    if (shift > 0) {\n+      inlines->at_put(i - shift, cg);\n+    }\n+    if (call == dead) {\n+      shift++;\n+    }\n+  }\n+  inlines->trunc_to(inlines->length() - shift);\n+  assert(shift <= 1, \"sanity\");\n+}\n+\n+void Compile::remove_useless_node(Node* dead) {\n+  remove_modified_node(dead);\n+\n+  \/\/ Constant node that has no out-edges and has only one in-edge from\n+  \/\/ root is usually dead. However, sometimes reshaping walk makes\n+  \/\/ it reachable by adding use edges. So, we will NOT count Con nodes\n+  \/\/ as dead to be conservative about the dead node count at any\n+  \/\/ given time.\n+  if (!dead->is_Con()) {\n+    record_dead_node(dead->_idx);\n+  }\n+  if (dead->is_macro()) {\n+    remove_macro_node(dead);\n+  }\n+  if (dead->is_expensive()) {\n+    remove_expensive_node(dead);\n+  }\n+  CastIINode* cast = dead->isa_CastII();\n+  if (cast != NULL && cast->has_range_check()) {\n+    remove_range_check_cast(cast);\n+  }\n+  if (dead->Opcode() == Op_Opaque4) {\n+    remove_opaque4_node(dead);\n+  }\n+  if (dead->is_Call()) {\n+    remove_useless_late_inlines(&_string_late_inlines, dead);\n+    remove_useless_late_inlines(&_boxing_late_inlines, dead);\n+    remove_useless_late_inlines(&_late_inlines, dead);\n+    remove_useless_late_inlines(&_vector_reboxing_late_inlines, dead);\n+  }\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  bs->unregister_potential_barrier_node(dead);\n+}\n+\n@@ -1896,0 +1947,1 @@\n+\n@@ -1898,2 +1950,2 @@\n-  int i = 0;\n-  for (; i <_late_inlines.length() && !inlining_progress(); i++) {\n+\n+  for (int i = 0; i < _late_inlines.length(); i++) {\n@@ -1902,0 +1954,1 @@\n+    assert(inlining_incrementally() || cg->is_virtual_late_inline(), \"no inlining allowed\");\n@@ -1903,5 +1956,8 @@\n-    if (failing())  return false;\n-  }\n-  int j = 0;\n-  for (; i < _late_inlines.length(); i++, j++) {\n-    _late_inlines.at_put(j, _late_inlines.at(i));\n+    assert(_late_inlines.at(i) == cg, \"no insertions before current position allowed\");\n+    if (failing()) {\n+      return false;\n+    } else if (inlining_progress()) {\n+      _late_inlines_pos = i+1; \/\/ restore the position in case new elements were inserted\n+      print_method(PHASE_INCREMENTAL_INLINE_STEP, cg->call_node(), 3);\n+      break; \/\/ process one call site at a time\n+    }\n@@ -1909,2 +1965,5 @@\n-  _late_inlines.trunc_to(j);\n-  assert(inlining_progress() || _late_inlines.length() == 0, \"\");\n+  \/\/ Remove processed elements.\n+  _late_inlines.truncate_to(_late_inlines_pos);\n+  _late_inlines_pos = 0;\n+\n+  assert(inlining_progress() || _late_inlines.length() == 0, \"no progress\");\n@@ -1916,0 +1975,1 @@\n+\n@@ -1930,0 +1990,1 @@\n+  print_method(PHASE_INCREMENTAL_INLINE_CLEANUP, 3);\n@@ -1971,0 +2032,4 @@\n+\n+    if (_late_inlines.length() == 0) {\n+      break; \/\/ no more progress\n+    }\n@@ -2117,1 +2182,2 @@\n-    for_igvn()->clear();\n+    Unique_Node_List* old_worklist = for_igvn();\n+    old_worklist->clear();\n@@ -2126,0 +2192,1 @@\n+    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n@@ -2274,0 +2341,25 @@\n+\n+  assert(_late_inlines.length() == 0 || IncrementalInlineVirtual, \"not empty\");\n+\n+  while (_late_inlines.length() > 0) {\n+    \/\/ More opportunities to optimize virtual calls.\n+    \/\/ Though it's maybe too late for inlining, strength-reducing them to direct calls is still an option.\n+\n+    \/\/ \"inlining_incrementally() == false\" is used to signal that no inlining is allowed.\n+    \/\/ Tracking and verification of modified nodes is disabled by _modified_nodes == NULL as if inlining_incrementally() were set.\n+    assert(inlining_incrementally() == false, \"not allowed\");\n+\n+    for_igvn()->clear();\n+    initial_gvn()->replace_with(&igvn);\n+\n+    DEBUG_ONLY( int late_inlines_before = _late_inlines.length(); )\n+\n+    while (inline_incrementally_one()) {\n+      assert(!failing(), \"inconsistent\");\n+    }\n+    if (failing())  return;\n+\n+    inline_incrementally_cleanup(igvn);\n+\n+    assert(_late_inlines.length() < late_inlines_before, \"no progress\");\n+  }\n@@ -2947,0 +3039,1 @@\n+  case Op_CallLeafVector:\n@@ -3298,3 +3391,4 @@\n-    if (OptimizeStringConcat) {\n-      ProjNode* p = n->as_Proj();\n-      if (p->_is_io_use) {\n+    if (OptimizeStringConcat || IncrementalInline || IncrementalInlineVirtual) {\n+      ProjNode* proj = n->as_Proj();\n+      if (proj->_is_io_use) {\n+        assert(proj->_con == TypeFunc::I_O || proj->_con == TypeFunc::Memory, \"\");\n@@ -3304,13 +3398,4 @@\n-        \/\/ the original one.\n-        Node* proj = NULL;\n-        \/\/ Replace with just one\n-        for (SimpleDUIterator i(p->in(0)); i.has_next(); i.next()) {\n-          Node *use = i.get();\n-          if (use->is_Proj() && p != use && use->as_Proj()->_con == p->_con) {\n-            proj = use;\n-            break;\n-          }\n-        }\n-        assert(proj != NULL || p->_con == TypeFunc::I_O, \"io may be dropped at an infinite loop\");\n-        if (proj != NULL) {\n-          p->subsume_by(proj, this);\n+        \/\/ the original one. Merge them.\n+        Node* non_io_proj = proj->in(0)->as_Multi()->proj_out_or_null(proj->_con, false \/*is_io_use*\/);\n+        if (non_io_proj  != NULL) {\n+          proj->subsume_by(non_io_proj , this);\n@@ -4173,1 +4258,1 @@\n-    if (!cg->is_late_inline()) {\n+    if (!cg->is_late_inline() && !cg->is_virtual_late_inline()) {\n@@ -4227,1 +4312,3 @@\n-        const char* msg = \"live nodes > LiveNodeCountInliningCutoff\";\n+        bool is_virtual = cg->is_virtual_late_inline();\n+        const char* msg = (is_virtual ? \"virtual call\"\n+                                      : \"live nodes > LiveNodeCountInliningCutoff\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":115,"deletions":28,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -928,0 +928,2 @@\n+  void              remove_useless_node(Node* dead);\n+\n@@ -955,0 +957,1 @@\n+  void remove_useless_late_inlines(GrowableArray<CallGenerator*>* inlines, Node* dead);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -277,1 +277,2 @@\n-            miss_cg = CallGenerator::for_virtual_call(callee, vtable_index);\n+            miss_cg = (IncrementalInlineVirtual ? CallGenerator::for_late_inline_virtual(callee, vtable_index, prof_factor)\n+                                                : CallGenerator::for_virtual_call(callee, vtable_index));\n@@ -345,8 +346,10 @@\n-  }\n-\n-  \/\/ Nothing claimed the intrinsic, we go with straight-forward inlining\n-  \/\/ for already discovered intrinsic.\n-  if (allow_inline && allow_intrinsics && cg_intrinsic != NULL) {\n-    assert(cg_intrinsic->does_virtual_dispatch(), \"sanity\");\n-    return cg_intrinsic;\n-  }\n+    \/\/ Nothing claimed the intrinsic, we go with straight-forward inlining\n+    \/\/ for already discovered intrinsic.\n+    if (allow_intrinsics && cg_intrinsic != NULL) {\n+      assert(cg_intrinsic->does_virtual_dispatch(), \"sanity\");\n+      return cg_intrinsic;\n+    }\n+    if (call_does_dispatch && IncrementalInlineVirtual) {\n+      return CallGenerator::for_late_inline_virtual(callee, vtable_index, prof_factor); \/\/ attempt to inline through virtual call later\n+    }\n+  } \/\/ allow_inline\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2497,0 +2497,3 @@\n+  } else  if (flags & RC_VECTOR){\n+    uint num_bits = call_type->range()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte;\n+    call = new CallLeafVectorNode(call_type, call_addr, call_name, adr_type, num_bits);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -856,0 +856,1 @@\n+    case Op_CallLeafVector:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -330,0 +330,1 @@\n+  Node* gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"opto\/callGenerator.hpp\"\n@@ -558,1 +559,1 @@\n-  \/\/ cloning CallNode may need to clone JVMState\n+    \/\/ cloning CallNode may need to clone JVMState\n@@ -561,0 +562,6 @@\n+    \/\/ CallGenerator is linked to the original node.\n+    CallGenerator* cg = n->as_Call()->generator();\n+    if (cg != NULL) {\n+      CallGenerator* cloned_cg = cg->with_call_node(n->as_Call());\n+      n->as_Call()->set_generator(cloned_cg);\n+    }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -895,3 +895,3 @@\n-    } else if ( t->base() == Type::VectorS || t->base() == Type::VectorD ||\n-                t->base() == Type::VectorX || t->base() == Type::VectorY ||\n-                t->base() == Type::VectorZ) {\n+    } else if (t->base() == Type::VectorA || t->base() == Type::VectorS ||\n+               t->base() == Type::VectorD || t->base() == Type::VectorX ||\n+               t->base() == Type::VectorY || t->base() == Type::VectorZ) {\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1101,4 +1101,6 @@\n-  while (modified_list->size()) {\n-    Node* n = modified_list->pop();\n-    n->dump();\n-    assert(false, \"VerifyIterativeGVN: new modified node was added\");\n+  if (modified_list != NULL) {\n+    while (modified_list->size()) {\n+      Node* n = modified_list->pop();\n+      n->dump();\n+      assert(false, \"VerifyIterativeGVN: new modified node was added\");\n+    }\n@@ -1393,24 +1395,1 @@\n-      C->remove_modified_node(dead);\n-      \/\/ Constant node that has no out-edges and has only one in-edge from\n-      \/\/ root is usually dead. However, sometimes reshaping walk makes\n-      \/\/ it reachable by adding use edges. So, we will NOT count Con nodes\n-      \/\/ as dead to be conservative about the dead node count at any\n-      \/\/ given time.\n-      if (!dead->is_Con()) {\n-        C->record_dead_node(dead->_idx);\n-      }\n-      if (dead->is_macro()) {\n-        C->remove_macro_node(dead);\n-      }\n-      if (dead->is_expensive()) {\n-        C->remove_expensive_node(dead);\n-      }\n-      CastIINode* cast = dead->isa_CastII();\n-      if (cast != NULL && cast->has_range_check()) {\n-        C->remove_range_check_cast(cast);\n-      }\n-      if (dead->Opcode() == Op_Opaque4) {\n-        C->remove_opaque4_node(dead);\n-      }\n-      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-      bs->unregister_potential_barrier_node(dead);\n+      C->remove_useless_node(dead);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":7,"deletions":28,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -664,0 +664,19 @@\n+const TypeFunc *OptoRuntime::Math_Vector_Vector_Type(uint num_arg, const TypeVect* in_type, const TypeVect* out_type) {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(num_arg);\n+  \/\/ Symbol* name of class to be loaded\n+  assert(num_arg > 0, \"must have at least 1 input\");\n+  for (uint i = 0; i < num_arg; i++) {\n+    fields[TypeFunc::Parms+i] = in_type;\n+  }\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+num_arg, fields);\n+\n+  \/\/ create result type (range)\n+  const uint num_ret = 1;\n+  fields = TypeTuple::fields(num_ret);\n+  fields[TypeFunc::Parms+0] = out_type;\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+num_ret, fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -4213,0 +4213,5 @@\n+\n+    if (!FLAG_IS_DEFAULT(UseVectorStubs) && UseVectorStubs) {\n+      warning(\"Disabling UseVectorStubs since EnableVectorSupport is turned off.\");\n+    }\n+    FLAG_SET_DEFAULT(UseVectorStubs, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -392,0 +392,4 @@\n+  static int vector_calling_convention(VMRegPair *regs,\n+                                       uint num_bits,\n+                                       uint total_args_passed);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1526,0 +1526,1 @@\n+  declare_c2_type(CallLeafVectorNode, CallLeafNode)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -298,0 +298,11 @@\n+  void truncate_to(int idx) {\n+    for (int i = 0, j = idx; j < length(); i++, j++) {\n+      at_put(i, at(j));\n+    }\n+    trunc_to(length() - idx);\n+  }\n+\n+  void truncate_from(int idx) {\n+    trunc_to(idx);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -70,0 +70,20 @@\n+    \/\/ Math routines\n+    public static final int VECTOR_OP_TAN = 101;\n+    public static final int VECTOR_OP_TANH = 102;\n+    public static final int VECTOR_OP_SIN = 103;\n+    public static final int VECTOR_OP_SINH = 104;\n+    public static final int VECTOR_OP_COS = 105;\n+    public static final int VECTOR_OP_COSH = 106;\n+    public static final int VECTOR_OP_ASIN = 107;\n+    public static final int VECTOR_OP_ACOS = 108;\n+    public static final int VECTOR_OP_ATAN = 109;\n+    public static final int VECTOR_OP_ATAN2 = 110;\n+    public static final int VECTOR_OP_CBRT = 111;\n+    public static final int VECTOR_OP_LOG = 112;\n+    public static final int VECTOR_OP_LOG10 = 113;\n+    public static final int VECTOR_OP_LOG1P = 114;\n+    public static final int VECTOR_OP_POW = 115;\n+    public static final int VECTOR_OP_EXP = 116;\n+    public static final int VECTOR_OP_EXPM1 = 117;\n+    public static final int VECTOR_OP_HYPOT = 118;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -22,0 +22,18 @@\n+    @Test(dataProvider = \"$type$TestOpMaskProvider\")\n+    static void [[TEST]]Masked$vectorteststype$SmokeTest(IntFunction<$type$[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.[[TEST]], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && test[[TEST]](a[i + j]));\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Test.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}