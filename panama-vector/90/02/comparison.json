{"files":[{"patch":"@@ -850,0 +850,6 @@\n+  do_intrinsic(_VectorLoadMaskedOp, jdk_internal_vm_vector_VectorSupport, vector_load_masked_op_name, vector_load_masked_op_sig, F_S)          \\\n+   do_signature(vector_load_masked_op_sig, \"(Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;JLjdk\/internal\/vm\/vector\/VectorSupport$VectorMask;\" \\\n+                                            \"Ljava\/lang\/Object;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;\"                          \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$LoadVectorMaskedOperation;)Ljava\/lang\/Object;\")             \\\n+   do_name(vector_load_masked_op_name,     \"loadMasked\")                                                                                       \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -667,0 +667,1 @@\n+  case vmIntrinsics::_VectorLoadMaskedOp:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -644,0 +644,2 @@\n+  case vmIntrinsics::_VectorLoadMaskedOp:\n+    return inline_vector_mem_masked_operation(\/*is_store*\/false);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -332,4 +332,5 @@\n-    VecMaskUseLoad,\n-    VecMaskUseStore,\n-    VecMaskUseAll,\n-    VecMaskNotUsed\n+    VecMaskUseLoad  = 1 << 0,\n+    VecMaskUseStore = 1 << 1,\n+    VecMaskUseAll   = VecMaskUseLoad | VecMaskUseStore,\n+    VecMaskUsePred  = 1 << 2,\n+    VecMaskNotUsed  = 1 << 3\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  if (mask_use_type == VecMaskUseAll || mask_use_type == VecMaskUseLoad) {\n+  if ((mask_use_type & VecMaskUseLoad) != 0) {\n@@ -174,1 +174,1 @@\n-  if (mask_use_type == VecMaskUseAll || mask_use_type == VecMaskUseStore) {\n+  if ((mask_use_type & VecMaskUseStore) != 0) {\n@@ -186,0 +186,13 @@\n+  if ((mask_use_type & VecMaskUsePred) != 0) {\n+    if (!Matcher::has_predicated_vectors() ||\n+        !Matcher::match_rule_supported_vector_masked(sopc, num_elem, type)) {\n+    #ifndef PRODUCT\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"Rejected vector mask predicate using (%s,%s,%d) because architecture does not support it\",\n+                      NodeClassNames[sopc], type2name(type), num_elem);\n+      }\n+    #endif\n+      return false;\n+    }\n+  }\n+\n@@ -337,1 +350,1 @@\n-      tty->print_cr(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=%d\",\n+      tty->print_cr(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=%d is_masked_op=%d\",\n@@ -339,1 +352,1 @@\n-                    is_vector_mask(vbox_klass) ? 1 : 0);\n+                    is_vector_mask(vbox_klass) ? 1 : 0, is_masked_op ? 1 : 0);\n@@ -344,0 +357,10 @@\n+  \/\/ Return true if current platform has implemented the masked operation with predicate feature.\n+  bool use_predicate = is_masked_op && sopc != 0 && arch_supports_vector(sopc, num_elem, elem_bt, VecMaskUsePred);\n+  if (is_masked_op && !use_predicate && !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=%d opc=%d vlen=%d etype=%s ismask=0 is_masked_op=1\",\n+                    n, sopc, num_elem, type2name(elem_bt));\n+    }\n+    return false;\n+  }\n+\n@@ -383,1 +406,0 @@\n-  bool use_predicate = false;\n@@ -396,7 +418,0 @@\n-\n-    \/\/ Return true if current platform has implemented the masked operation with predicate feature.\n-    use_predicate = sopc != 0 && Matcher::has_predicated_vectors() &&\n-                    Matcher::match_rule_supported_vector_masked(sopc, num_elem, elem_bt);\n-    if (!use_predicate && !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad)) {\n-      return false;\n-    }\n@@ -893,0 +908,7 @@\n+\/\/    <C, V, E, S extends VectorSpecies<E>,\n+\/\/     M extends VectorMask<E>>\n+\/\/    V loadMasked(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType,\n+\/\/                 int length, Object base, long offset, M m\n+\/\/                 C container, int index, S s,  \/\/ Arguments for default implementation\n+\/\/                 LoadVectorMaskedOperation<C, V, E, S, M> defaultImpl) {\n+\/\/\n@@ -896,1 +918,1 @@\n-\/\/                     int length, Object base, long offset,   \/\/ Unsafe addressing\n+\/\/                     int length, Object base, long offset,\n@@ -898,1 +920,1 @@\n-\/\/                     C container, int index,      \/\/ Arguments for default implementation\n+\/\/                     C container, int index,  \/\/ Arguments for default implementation\n@@ -901,10 +923,2 @@\n-\/\/    TODO: Handle special case where load\/store happens from\/to byte array but element type\n-\/\/    is not byte. And also add the mask support for vector load. The intrinsic looks like:\n-\/\/\n-\/\/    <C, V extends Vector<?>,\n-\/\/     M extends VectorMask<?>>\n-\/\/    V loadMasked(Class<?> vectorClass, Class<M> maskClass, Class<?> elementType,\n-\/\/                 int vlen, Object base, long offset,\n-\/\/                 M m,   \/\/ mask arguemnt\n-\/\/                 Object container, int index,\n-\/\/                 LoadMaskedOperation<C, V, M> defaultImpl) {\n+\/\/    TODO: Handle special cases where load\/store happens from\/to byte array but element type\n+\/\/    is not byte.\n@@ -951,1 +965,0 @@\n-\n@@ -954,3 +967,6 @@\n-  int sopc = is_store ? Op_StoreVectorMasked : Op_LoadVectorMasked;\n-  if (!arch_supports_vector(sopc, num_elem, elem_bt, VecMaskUseLoad) ||\n-      !Matcher::match_rule_supported_vector_masked(sopc, num_elem, elem_bt)) {\n+\n+  bool use_predicate = arch_supports_vector(is_store ? Op_StoreVectorMasked : Op_LoadVectorMasked,\n+                                            num_elem, elem_bt, (VectorMaskUseType) (VecMaskUseLoad | VecMaskUsePred));\n+  \/\/ Masked vector store operation needs the architecture predicate feature. We need to check\n+  \/\/ whether the predicated vector operation is supported by backend.\n+  if (is_store && !use_predicate) {\n@@ -958,2 +974,1 @@\n-      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s ismask=yes\",\n-                    is_store, is_store ? \"storeMask\" : \"loadMask\",\n+      tty->print_cr(\"  ** not supported: op=storeMasked vlen=%d etype=%s\",\n@@ -962,1 +977,12 @@\n-    return false; \/\/ not supported\n+    return false;\n+  }\n+\n+  \/\/ This only happens for masked vector load. If predicate is not supported, then check whether\n+  \/\/ the normal vector load and blend operations are supported by backend.\n+  if (!use_predicate && (!arch_supports_vector(Op_LoadVector, num_elem, elem_bt, VecMaskNotUsed) ||\n+      !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad))) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: op=loadMasked vlen=%d etype=%s\",\n+                    num_elem, type2name(elem_bt));\n+    }\n+    return false;\n@@ -975,1 +1001,6 @@\n-  if (arr_type != NULL && elem_bt != arr_type->elem()->array_element_basic_type()) {\n+  if (arr_type != NULL && !elem_consistent_with_arr(elem_bt, arr_type)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s\",\n+                    is_store, is_store ? \"storeMasked\" : \"loadMasked\",\n+                    num_elem, type2name(elem_bt), type2name(arr_type->elem()->array_element_basic_type()));\n+    }\n@@ -993,0 +1024,12 @@\n+  Node* mask = unbox_vector(is_store ? argument(8) : argument(7), mbox_type, elem_bt, num_elem);\n+  if (mask == NULL) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** unbox failed mask=%s\",\n+                    is_store ? NodeClassNames[argument(8)->Opcode()]\n+                             : NodeClassNames[argument(7)->Opcode()]);\n+    }\n+    set_map(old_map);\n+    set_sp(old_sp);\n+    return false;\n+  }\n+\n@@ -1004,11 +1047,0 @@\n-    Node* mask = unbox_vector(argument(8), mbox_type, elem_bt, num_elem);\n-    if (mask == NULL) {\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** unbox failed mask=%s\",\n-                      NodeClassNames[argument(8)->Opcode()]);\n-      }\n-      set_map(old_map);\n-      set_sp(old_sp);\n-      return false;\n-    }\n-\n@@ -1019,2 +1051,14 @@\n-    \/\/ TODO: mask support for load op.\n-    assert(false, \"unimplemented masked memory operation\");\n+    Node* vload = NULL;\n+    if (use_predicate) {\n+      \/\/ Generate masked load vector node if predicate feature is supported.\n+      const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+      vload = gvn().transform(new LoadVectorMaskedNode(control(), memory(addr), addr, addr_type, vt, mask));\n+    } else {\n+      \/\/ Use the vector blend to implement the masked load vector. The biased elements are zeros.\n+      Node* zero = gvn().transform(gvn().zerocon(elem_bt));\n+      zero = gvn().transform(VectorNode::scalar2vector(zero, num_elem, Type::get_const_basic_type(elem_bt)));\n+      vload = gvn().transform(LoadVectorNode::make(0, control(), memory(addr), addr, addr_type, num_elem, elem_bt));\n+      vload = gvn().transform(new VectorBlendNode(zero, vload, mask));\n+    }\n+    Node* box = box_vector(vload, vbox_type, elem_bt, num_elem);\n+    set_result(box);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":89,"deletions":45,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -320,0 +320,18 @@\n+    public interface LoadVectorMaskedOperation<C, V, E, S extends VectorSpecies<E>, M extends VectorMask<E>> {\n+        V load(C container, int index, S s, M m);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <C, V, E, S extends VectorSpecies<E>,\n+     M extends VectorMask<E>>\n+    V loadMasked(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType,\n+                 int length, Object base, long offset, M m,\n+                 C container, int index, S s,  \/\/ Arguments for default implementation\n+                 LoadVectorMaskedOperation<C, V, E, S, M> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.load(container, index, s, m);\n+    }\n+\n+    \/* ============================================================================ *\/\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -814,0 +814,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromArray0Template(Byte128Mask.class, a, offset, (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -822,0 +829,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromBooleanArray0Template(Byte128Mask.class, a, offset, (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -850,0 +864,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n+        super.intoBooleanArray0Template(Byte128Mask.class, a, offset, (Byte128Mask) m);\n+    }\n+\n@@ -857,0 +878,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -846,0 +846,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromArray0Template(Byte256Mask.class, a, offset, (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -854,0 +861,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromBooleanArray0Template(Byte256Mask.class, a, offset, (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -882,0 +896,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n+        super.intoBooleanArray0Template(Byte256Mask.class, a, offset, (Byte256Mask) m);\n+    }\n+\n@@ -889,0 +910,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -910,0 +910,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromArray0Template(Byte512Mask.class, a, offset, (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -918,0 +925,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromBooleanArray0Template(Byte512Mask.class, a, offset, (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -946,0 +960,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n+        super.intoBooleanArray0Template(Byte512Mask.class, a, offset, (Byte512Mask) m);\n+    }\n+\n@@ -953,0 +974,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -798,0 +798,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromArray0Template(Byte64Mask.class, a, offset, (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -806,0 +813,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromBooleanArray0Template(Byte64Mask.class, a, offset, (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -834,0 +848,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n+        super.intoBooleanArray0Template(Byte64Mask.class, a, offset, (Byte64Mask) m);\n+    }\n+\n@@ -841,0 +862,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -784,0 +784,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -792,0 +799,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromBooleanArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -820,0 +834,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m) {\n+        super.intoBooleanArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);\n+    }\n+\n@@ -827,0 +848,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2842,2 +2842,1 @@\n-            ByteVector zero = vsp.zero();\n-            return zero.blend(zero.fromArray0(a, offset), m);\n+            return vsp.dummyVector().fromArray0(a, offset, m);\n@@ -3000,1 +2999,1 @@\n-            return zero.blend(zero.fromBooleanArray0(a, offset), m);\n+            return vsp.dummyVector().fromBooleanArray0(a, offset, m);\n@@ -3407,1 +3406,0 @@\n-            \/\/ FIXME: optimize\n@@ -3410,1 +3408,1 @@\n-            stOp(a, offset, m, (arr, off, i, e) -> arr[off+i] = (e & 1) != 0);\n+            intoBooleanArray0(a, offset, m);\n@@ -3611,0 +3609,17 @@\n+    \/*package-private*\/\n+    abstract\n+    ByteVector fromArray0(byte[] a, int offset, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    ByteVector fromArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        m.check(species());\n+        ByteSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                        (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n@@ -3627,0 +3642,17 @@\n+    \/*package-private*\/\n+    abstract\n+    ByteVector fromBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    ByteVector fromBooleanArray0Template(Class<M> maskClass, boolean[] a, int offset, M m) {\n+        m.check(species());\n+        ByteSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                        (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+    }\n+\n@@ -3687,0 +3719,1 @@\n+        m.check(species());\n@@ -3697,0 +3730,18 @@\n+    abstract\n+    void intoBooleanArray0(boolean[] a, int offset, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    void intoBooleanArray0Template(Class<M> maskClass, boolean[] a, int offset, M m) {\n+        m.check(species());\n+        ByteSpecies vsp = vspecies();\n+        ByteVector normalized = this.and((byte) 1);\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            normalized, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+    }\n+\n@@ -3729,0 +3780,1 @@\n+\n@@ -4055,1 +4107,1 @@\n-                                      AbstractMask<Byte> m,\n+                                      VectorMask<Byte> m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":58,"deletions":6,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -782,0 +782,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromArray0(double[] a, int offset, VectorMask<Double> m) {\n+        return super.fromArray0Template(Double128Mask.class, a, offset, (Double128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -812,0 +819,1 @@\n+\n@@ -819,0 +827,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -786,0 +786,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromArray0(double[] a, int offset, VectorMask<Double> m) {\n+        return super.fromArray0Template(Double256Mask.class, a, offset, (Double256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -816,0 +823,1 @@\n+\n@@ -823,0 +831,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -794,0 +794,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromArray0(double[] a, int offset, VectorMask<Double> m) {\n+        return super.fromArray0Template(Double512Mask.class, a, offset, (Double512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -824,0 +831,1 @@\n+\n@@ -831,0 +839,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -780,0 +780,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromArray0(double[] a, int offset, VectorMask<Double> m) {\n+        return super.fromArray0Template(Double64Mask.class, a, offset, (Double64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -810,0 +817,1 @@\n+\n@@ -817,0 +825,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -779,0 +779,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromArray0(double[] a, int offset, VectorMask<Double> m) {\n+        return super.fromArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -809,0 +816,1 @@\n+\n@@ -816,0 +824,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2673,2 +2673,1 @@\n-            DoubleVector zero = vsp.zero();\n-            return zero.blend(zero.fromArray0(a, offset), m);\n+            return vsp.dummyVector().fromArray0(a, offset, m);\n@@ -3208,0 +3207,17 @@\n+    \/*package-private*\/\n+    abstract\n+    DoubleVector fromArray0(double[] a, int offset, VectorMask<Double> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    DoubleVector fromArray0Template(Class<M> maskClass, double[] a, int offset, M m) {\n+        m.check(species());\n+        DoubleSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                        (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n@@ -3270,0 +3286,1 @@\n+        m.check(species());\n@@ -3280,0 +3297,1 @@\n+\n@@ -3312,0 +3330,1 @@\n+\n@@ -3629,1 +3648,1 @@\n-                                      AbstractMask<Double> m,\n+                                      VectorMask<Double> m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -786,0 +786,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromArray0(float[] a, int offset, VectorMask<Float> m) {\n+        return super.fromArray0Template(Float128Mask.class, a, offset, (Float128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -816,0 +823,1 @@\n+\n@@ -823,0 +831,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -794,0 +794,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromArray0(float[] a, int offset, VectorMask<Float> m) {\n+        return super.fromArray0Template(Float256Mask.class, a, offset, (Float256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -824,0 +831,1 @@\n+\n@@ -831,0 +839,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -810,0 +810,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromArray0(float[] a, int offset, VectorMask<Float> m) {\n+        return super.fromArray0Template(Float512Mask.class, a, offset, (Float512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -840,0 +847,1 @@\n+\n@@ -847,0 +855,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -782,0 +782,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromArray0(float[] a, int offset, VectorMask<Float> m) {\n+        return super.fromArray0Template(Float64Mask.class, a, offset, (Float64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -812,0 +819,1 @@\n+\n@@ -819,0 +827,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -779,0 +779,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromArray0(float[] a, int offset, VectorMask<Float> m) {\n+        return super.fromArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -809,0 +816,1 @@\n+\n@@ -816,0 +824,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2697,2 +2697,1 @@\n-            FloatVector zero = vsp.zero();\n-            return zero.blend(zero.fromArray0(a, offset), m);\n+            return vsp.dummyVector().fromArray0(a, offset, m);\n@@ -3195,0 +3194,17 @@\n+    \/*package-private*\/\n+    abstract\n+    FloatVector fromArray0(float[] a, int offset, VectorMask<Float> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    FloatVector fromArray0Template(Class<M> maskClass, float[] a, int offset, M m) {\n+        m.check(species());\n+        FloatSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                        (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n@@ -3257,0 +3273,1 @@\n+        m.check(species());\n@@ -3267,0 +3284,1 @@\n+\n@@ -3299,0 +3317,1 @@\n+\n@@ -3616,1 +3635,1 @@\n-                                      AbstractMask<Float> m,\n+                                      VectorMask<Float> m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -790,0 +790,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromArray0(int[] a, int offset, VectorMask<Integer> m) {\n+        return super.fromArray0Template(Int128Mask.class, a, offset, (Int128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -820,0 +827,1 @@\n+\n@@ -827,0 +835,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -798,0 +798,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromArray0(int[] a, int offset, VectorMask<Integer> m) {\n+        return super.fromArray0Template(Int256Mask.class, a, offset, (Int256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -828,0 +835,1 @@\n+\n@@ -835,0 +843,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -814,0 +814,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromArray0(int[] a, int offset, VectorMask<Integer> m) {\n+        return super.fromArray0Template(Int512Mask.class, a, offset, (Int512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -844,0 +851,1 @@\n+\n@@ -851,0 +859,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -786,0 +786,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromArray0(int[] a, int offset, VectorMask<Integer> m) {\n+        return super.fromArray0Template(Int64Mask.class, a, offset, (Int64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -816,0 +823,1 @@\n+\n@@ -823,0 +831,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -795,0 +795,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromArray0(int[] a, int offset, VectorMask<Integer> m) {\n+        return super.fromArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -825,0 +832,1 @@\n+\n@@ -832,0 +840,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2834,2 +2834,1 @@\n-            IntVector zero = vsp.zero();\n-            return zero.blend(zero.fromArray0(a, offset), m);\n+            return vsp.dummyVector().fromArray0(a, offset, m);\n@@ -3332,0 +3331,17 @@\n+    \/*package-private*\/\n+    abstract\n+    IntVector fromArray0(int[] a, int offset, VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    IntVector fromArray0Template(Class<M> maskClass, int[] a, int offset, M m) {\n+        m.check(species());\n+        IntSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                        (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n@@ -3394,0 +3410,1 @@\n+        m.check(species());\n@@ -3404,0 +3421,1 @@\n+\n@@ -3436,0 +3454,1 @@\n+\n@@ -3753,1 +3772,1 @@\n-                                      AbstractMask<Integer> m,\n+                                      VectorMask<Integer> m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -776,0 +776,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromArray0(long[] a, int offset, VectorMask<Long> m) {\n+        return super.fromArray0Template(Long128Mask.class, a, offset, (Long128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -806,0 +813,1 @@\n+\n@@ -813,0 +821,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -780,0 +780,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromArray0(long[] a, int offset, VectorMask<Long> m) {\n+        return super.fromArray0Template(Long256Mask.class, a, offset, (Long256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -810,0 +817,1 @@\n+\n@@ -817,0 +825,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -788,0 +788,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromArray0(long[] a, int offset, VectorMask<Long> m) {\n+        return super.fromArray0Template(Long512Mask.class, a, offset, (Long512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -818,0 +825,1 @@\n+\n@@ -825,0 +833,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -774,0 +774,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromArray0(long[] a, int offset, VectorMask<Long> m) {\n+        return super.fromArray0Template(Long64Mask.class, a, offset, (Long64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -804,0 +811,1 @@\n+\n@@ -811,0 +819,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -774,0 +774,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromArray0(long[] a, int offset, VectorMask<Long> m) {\n+        return super.fromArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -804,0 +811,1 @@\n+\n@@ -811,0 +819,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2695,2 +2695,1 @@\n-            LongVector zero = vsp.zero();\n-            return zero.blend(zero.fromArray0(a, offset), m);\n+            return vsp.dummyVector().fromArray0(a, offset, m);\n@@ -3230,0 +3229,17 @@\n+    \/*package-private*\/\n+    abstract\n+    LongVector fromArray0(long[] a, int offset, VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    LongVector fromArray0Template(Class<M> maskClass, long[] a, int offset, M m) {\n+        m.check(species());\n+        LongSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                        (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n@@ -3292,0 +3308,1 @@\n+        m.check(species());\n@@ -3302,0 +3319,1 @@\n+\n@@ -3334,0 +3352,1 @@\n+\n@@ -3642,1 +3661,1 @@\n-                                      AbstractMask<Long> m,\n+                                      VectorMask<Long> m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -798,0 +798,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromArray0(short[] a, int offset, VectorMask<Short> m) {\n+        return super.fromArray0Template(Short128Mask.class, a, offset, (Short128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -805,0 +812,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset, VectorMask<Short> m) {\n+        return super.fromCharArray0Template(Short128Mask.class, a, offset, (Short128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -834,0 +848,1 @@\n+\n@@ -841,0 +856,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Short> m) {\n+        super.intoCharArray0Template(Short128Mask.class, a, offset, (Short128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -814,0 +814,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromArray0(short[] a, int offset, VectorMask<Short> m) {\n+        return super.fromArray0Template(Short256Mask.class, a, offset, (Short256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -821,0 +828,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset, VectorMask<Short> m) {\n+        return super.fromCharArray0Template(Short256Mask.class, a, offset, (Short256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -850,0 +864,1 @@\n+\n@@ -857,0 +872,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Short> m) {\n+        super.intoCharArray0Template(Short256Mask.class, a, offset, (Short256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -846,0 +846,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromArray0(short[] a, int offset, VectorMask<Short> m) {\n+        return super.fromArray0Template(Short512Mask.class, a, offset, (Short512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -853,0 +860,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset, VectorMask<Short> m) {\n+        return super.fromCharArray0Template(Short512Mask.class, a, offset, (Short512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -882,0 +896,1 @@\n+\n@@ -889,0 +904,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Short> m) {\n+        super.intoCharArray0Template(Short512Mask.class, a, offset, (Short512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -790,0 +790,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromArray0(short[] a, int offset, VectorMask<Short> m) {\n+        return super.fromArray0Template(Short64Mask.class, a, offset, (Short64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -797,0 +804,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset, VectorMask<Short> m) {\n+        return super.fromCharArray0Template(Short64Mask.class, a, offset, (Short64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -826,0 +840,1 @@\n+\n@@ -833,0 +848,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Short> m) {\n+        super.intoCharArray0Template(Short64Mask.class, a, offset, (Short64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -784,0 +784,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromArray0(short[] a, int offset, VectorMask<Short> m) {\n+        return super.fromArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -791,0 +798,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset, VectorMask<Short> m) {\n+        return super.fromCharArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -820,0 +834,1 @@\n+\n@@ -827,0 +842,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<Short> m) {\n+        super.intoCharArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2842,2 +2842,1 @@\n-            ShortVector zero = vsp.zero();\n-            return zero.blend(zero.fromArray0(a, offset), m);\n+            return vsp.dummyVector().fromArray0(a, offset, m);\n@@ -2992,2 +2991,1 @@\n-            ShortVector zero = vsp.zero();\n-            return zero.blend(zero.fromCharArray0(a, offset), m);\n+            return vsp.dummyVector().fromCharArray0(a, offset, m);\n@@ -3399,1 +3397,0 @@\n-            \/\/ FIXME: optimize\n@@ -3402,1 +3399,1 @@\n-            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = (char) v);\n+            intoCharArray0(a, offset, m);\n@@ -3598,0 +3595,17 @@\n+    \/*package-private*\/\n+    abstract\n+    ShortVector fromArray0(short[] a, int offset, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    ShortVector fromArray0Template(Class<M> maskClass, short[] a, int offset, M m) {\n+        m.check(species());\n+        ShortSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                        (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n@@ -3613,0 +3627,17 @@\n+    \/*package-private*\/\n+    abstract\n+    ShortVector fromCharArray0(char[] a, int offset, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    ShortVector fromCharArray0Template(Class<M> maskClass, char[] a, int offset, M m) {\n+        m.check(species());\n+        ShortSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                a, charArrayAddress(a, offset), m,\n+                a, offset, vsp,\n+                (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                            (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n@@ -3674,0 +3705,1 @@\n+        m.check(species());\n@@ -3684,0 +3716,1 @@\n+\n@@ -3716,0 +3749,18 @@\n+    \/*package-private*\/\n+    abstract\n+    void intoCharArray0(char[] a, int offset, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    void intoCharArray0Template(Class<M> maskClass, char[] a, int offset, M m) {\n+        m.check(species());\n+        ShortSpecies vsp = vspecies();\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n@@ -4050,1 +4101,1 @@\n-                                      AbstractMask<Short> m,\n+                                      VectorMask<Short> m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":58,"deletions":7,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -3328,2 +3328,1 @@\n-            $abstractvectortype$ zero = vsp.zero();\n-            return zero.blend(zero.fromArray0(a, offset), m);\n+            return vsp.dummyVector().fromArray0(a, offset, m);\n@@ -3551,2 +3550,1 @@\n-            $abstractvectortype$ zero = vsp.zero();\n-            return zero.blend(zero.fromCharArray0(a, offset), m);\n+            return vsp.dummyVector().fromCharArray0(a, offset, m);\n@@ -3712,1 +3710,1 @@\n-            return zero.blend(zero.fromBooleanArray0(a, offset), m);\n+            return vsp.dummyVector().fromBooleanArray0(a, offset, m);\n@@ -4200,1 +4198,0 @@\n-            \/\/ FIXME: optimize\n@@ -4203,1 +4200,1 @@\n-            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = (char) v);\n+            intoCharArray0(a, offset, m);\n@@ -4363,1 +4360,0 @@\n-            \/\/ FIXME: optimize\n@@ -4366,1 +4362,1 @@\n-            stOp(a, offset, m, (arr, off, i, e) -> arr[off+i] = (e & 1) != 0);\n+            intoBooleanArray0(a, offset, m);\n@@ -4568,0 +4564,17 @@\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromArray0($type$[] a, int offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $abstractvectortype$ fromArray0Template(Class<M> maskClass, $type$[] a, int offset, M m) {\n+        m.check(species());\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                        (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n@@ -4583,0 +4596,17 @@\n+\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromCharArray0(char[] a, int offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $abstractvectortype$ fromCharArray0Template(Class<M> maskClass, char[] a, int offset, M m) {\n+        m.check(species());\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                a, charArrayAddress(a, offset), m,\n+                a, offset, vsp,\n+                (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                            (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n@@ -4600,0 +4630,17 @@\n+\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromBooleanArray0(boolean[] a, int offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $abstractvectortype$ fromBooleanArray0Template(Class<M> maskClass, boolean[] a, int offset, M m) {\n+        m.check(species());\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                                        (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+    }\n@@ -4662,0 +4709,1 @@\n+        m.check(species());\n@@ -4672,0 +4720,20 @@\n+#if[byte]\n+    abstract\n+    void intoBooleanArray0(boolean[] a, int offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    void intoBooleanArray0Template(Class<M> maskClass, boolean[] a, int offset, M m) {\n+        m.check(species());\n+        $Type$Species vsp = vspecies();\n+        ByteVector normalized = this.and((byte) 1);\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, booleanArrayAddress(a, offset),\n+            normalized, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+    }\n+#end[byte]\n+\n@@ -4704,0 +4772,20 @@\n+#if[short]\n+    \/*package-private*\/\n+    abstract\n+    void intoCharArray0(char[] a, int offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    void intoCharArray0Template(Class<M> maskClass, char[] a, int offset, M m) {\n+        m.check(species());\n+        $Type$Species vsp = vspecies();\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+#end[short]\n+\n@@ -5079,1 +5167,1 @@\n-                                      AbstractMask<$Boxtype$> m,\n+                                      VectorMask<$Boxtype$> m,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":98,"deletions":10,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -1072,0 +1072,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromArray0($type$[] a, int offset, VectorMask<$Boxtype$> m) {\n+        return super.fromArray0Template($masktype$.class, a, offset, ($masktype$) m);  \/\/ specialize\n+    }\n+\n@@ -1079,0 +1086,7 @@\n+\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromCharArray0(char[] a, int offset, VectorMask<$Boxtype$> m) {\n+        return super.fromCharArray0Template($masktype$.class, a, offset, ($masktype$) m);  \/\/ specialize\n+    }\n@@ -1088,0 +1102,7 @@\n+\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromBooleanArray0(boolean[] a, int offset, VectorMask<$Boxtype$> m) {\n+        return super.fromBooleanArray0Template($masktype$.class, a, offset, ($masktype$) m);  \/\/ specialize\n+    }\n@@ -1118,0 +1139,9 @@\n+#if[byte]\n+    @ForceInline\n+    @Override\n+    final\n+    void intoBooleanArray0(boolean[] a, int offset, VectorMask<$Boxtype$> m) {\n+        super.intoBooleanArray0Template($masktype$.class, a, offset, ($masktype$) m);\n+    }\n+#end[byte]\n+\n@@ -1125,0 +1155,9 @@\n+#if[short]\n+    @ForceInline\n+    @Override\n+    final\n+    void intoCharArray0(char[] a, int offset, VectorMask<$Boxtype$> m) {\n+        super.intoCharArray0Template($masktype$.class, a, offset, ($masktype$) m);\n+    }\n+#end[short]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"}]}