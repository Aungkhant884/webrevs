{"files":[{"patch":"@@ -1083,1 +1083,0 @@\n-                                     \"I[II\"                                                                                                    \\\n@@ -1085,1 +1084,1 @@\n-                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$LoadVectorOperationWithMap;)\"                                      \\\n+                                     \"Ljdk\/internal\/vm\/vector\/VectorSupport$LoadVectorOperationWithIndexMap;)\"                                 \\\n@@ -1087,1 +1086,1 @@\n-    do_name(vector_gather_name, \"loadWithMap\")                                                                                                 \\\n+    do_name(vector_gather_name, \"loadWithIndexMap\")                                                                                            \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1364,6 +1364,6 @@\n-\/\/ V loadWithMap(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int length,\n-\/\/               Class<? extends Vector<Integer>> vectorIndexClass,\n-\/\/               Object base, long offset, \/\/ Unsafe addressing\n-\/\/               W index_vector, M m,\n-\/\/               C container, int index, int[] indexMap, int indexM, S s, \/\/ Arguments for default implementation\n-\/\/               LoadVectorOperationWithMap<C, V, E, S, M> defaultImpl)\n+\/\/  V loadWithIndexMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass, int length,\n+\/\/                     Class<? extends Vector<Integer>> vectorIndexClass,\n+\/\/                     Object base, long offset,\n+\/\/                     W index_vector, M m,\n+\/\/                     C container, S s,\n+\/\/                     LoadVectorOperationWithIndexMap<C, V, W, S, M> defaultImpl)\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -429,5 +429,6 @@\n-    public interface LoadVectorOperationWithMap<C,\n-                                                V extends Vector<?>,\n-                                                S extends VectorSpecies<?>,\n-                                                M extends VectorMask<?>> {\n-        V loadWithMap(C container, int index, int[] indexMap, int indexM, S s, M m);\n+    public interface LoadVectorOperationWithIndexMap<C,\n+                                                     V extends Vector<?>,\n+                                                     W extends Vector<Integer>,\n+                                                     S extends VectorSpecies<?>,\n+                                                     M extends VectorMask<?>> {\n+        V loadWithIndexMap(C container, W w, S s, M m);\n@@ -444,7 +445,7 @@\n-    V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-                  int length,\n-                  Class<? extends Vector<Integer>> vectorIndexClass,\n-                  Object base, long offset,\n-                  W index_vector,\n-                  M m, C container, int index, int[] indexMap, int indexM, S s,\n-                  LoadVectorOperationWithMap<C, V, S, M> defaultImpl) {\n+    V loadWithIndexMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+                       int length,\n+                       Class<? extends Vector<Integer>> vectorIndexClass,\n+                       Object base, long offset,\n+                       W index_vector,\n+                       M m, C container, S s,\n+                       LoadVectorOperationWithIndexMap<C, V, W, S, M> defaultImpl) {\n@@ -452,1 +453,1 @@\n-        return defaultImpl.loadWithMap(container, index, indexMap, indexM, s, m);\n+        return defaultImpl.loadWithIndexMap(container, index_vector, s, m);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3020,0 +3020,1 @@\n+\n@@ -3060,0 +3061,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -849,2 +849,2 @@\n-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        return super.fromArray0Template(Double128Mask.class, a, offset, indexMap, mapOffset, (Double128Mask) m);\n+    DoubleVector fromArray0(double[] a, Vector<Integer> indexVector, VectorMask<Double> m) {\n+        return super.fromArray0Template(Double128Mask.class, a, indexVector, (Double128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -853,2 +853,2 @@\n-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        return super.fromArray0Template(Double256Mask.class, a, offset, indexMap, mapOffset, (Double256Mask) m);\n+    DoubleVector fromArray0(double[] a, Vector<Integer> indexVector, VectorMask<Double> m) {\n+        return super.fromArray0Template(Double256Mask.class, a, indexVector, (Double256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -861,2 +861,2 @@\n-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        return super.fromArray0Template(Double512Mask.class, a, offset, indexMap, mapOffset, (Double512Mask) m);\n+    DoubleVector fromArray0(double[] a, Vector<Integer> indexVector, VectorMask<Double> m) {\n+        return super.fromArray0Template(Double512Mask.class, a, indexVector, (Double512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -847,2 +847,2 @@\n-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        return super.fromArray0Template(Double64Mask.class, a, offset, indexMap, mapOffset, (Double64Mask) m);\n+    DoubleVector fromArray0(double[] a, Vector<Integer> indexVector, VectorMask<Double> m) {\n+        return super.fromArray0Template(Double64Mask.class, a, indexVector, (Double64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -846,2 +846,2 @@\n-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        return super.fromArray0Template(DoubleMaxMask.class, a, offset, indexMap, mapOffset, (DoubleMaxMask) m);\n+    DoubleVector fromArray0(double[] a, Vector<Integer> indexVector, VectorMask<Double> m) {\n+        return super.fromArray0Template(DoubleMaxMask.class, a, indexVector, (DoubleMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2817,0 +2817,42 @@\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code double[]},\n+     * using indexes obtained from an <em>index vector<\/em>.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[index]}, where {@code index} is the lane element\n+     * at lane index {@code N} of <em>index vector<\/em>.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param indexVector the index vector\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code index < 0} or {@code index >= a.length}\n+     *         for any lane element {@code index} at lane index {@code N}\n+     *         in the index vector\n+     * @throws IllegalArgumentException\n+     *         if index vector length and species length differ\n+     *\/\n+    @ForceInline\n+    public static\n+    DoubleVector fromArray(VectorSpecies<Double> species,\n+                                   double[] a, Vector<Integer> indexVector) {\n+        IntVector vix = (IntVector) indexVector;\n+        DoubleSpecies vsp = (DoubleSpecies) species;\n+        VectorSpecies<Integer> isp = vix.species();\n+        Class<? extends DoubleVector> vectorType = vsp.vectorType();\n+\n+        Objects.requireNonNull(a);\n+        VectorIntrinsics.requireLength(vix.length(), species.length());\n+        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+\n+        return VectorSupport.loadWithIndexMap(\n+            vectorType, null, double.class, vsp.laneCount(),\n+            isp.vectorType(),\n+            a, ARRAY_BASE, vix, null,\n+            a, vsp,\n+            (c, iv, s, vm) -> s.vOp(iv, id -> c[id]));\n+    }\n+\n@@ -2857,1 +2899,0 @@\n-        Class<? extends DoubleVector> vectorType = vsp.vectorType();\n@@ -2882,1 +2923,2 @@\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        return fromArray(species, a, vix);\n+    }\n@@ -2884,7 +2926,41 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, null, double.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code double[]},\n+     * under the control of a mask, and\n+     * using indexes obtained from an <em>index vector<\/em>.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[index]}, where {@code index} is the lane element\n+     * at lane index {@code N} of <em>index vector<\/em>.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param indexVector the index vector\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code index < 0} or {@code index >= a.length}\n+     *         for any lane element {@code index} at lane index {@code N}\n+     *         in the index vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException\n+     *         if index vector length and species length differ\n+     *\/\n+    @ForceInline\n+    public static\n+    DoubleVector fromArray(VectorSpecies<Double> species,\n+                                   double[] a, Vector<Integer> indexVector,\n+                                   VectorMask<Double> m) {\n+        if (m.allTrue()) {\n+            return fromArray(species, a, indexVector);\n+        } else {\n+            DoubleSpecies vsp = (DoubleSpecies) species;\n+            Objects.requireNonNull(a);\n+            m.check(vsp);\n+            VectorIntrinsics.requireLength(indexVector.length(), vsp.length());\n+\n+            return vsp.dummyVector().fromArray0(a, indexVector, m);\n+        }\n@@ -2937,2 +3013,1 @@\n-        }\n-        else {\n+        } else {\n@@ -2940,1 +3015,28 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+            Objects.requireNonNull(a);\n+            Objects.requireNonNull(indexMap);\n+            m.check(vsp);\n+            if (vsp.laneCount() == 1) {\n+                return DoubleVector.fromArray(vsp, a, offset + indexMap[mapOffset], m);\n+            }\n+\n+            \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n+            IntVector vix;\n+            if (isp.laneCount() != vsp.laneCount()) {\n+                \/\/ For DoubleMaxVector,  if vector length is non-power-of-two or\n+                \/\/ 2048 bits, indexShape of Double species is S_MAX_BIT.\n+                \/\/ Assume that vector length is 2048, then the lane count of Double\n+                \/\/ vector is 32. When converting Double species to int species,\n+                \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n+                \/\/ is 64. So when loading index vector (IntVector), only lower half\n+                \/\/ of index data is needed.\n+                vix = IntVector\n+                    .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n+                    .add(offset);\n+            } else {\n+                vix = IntVector\n+                    .fromArray(isp, indexMap, mapOffset)\n+                    .add(offset);\n+            }\n+\n+            return vsp.dummyVector().fromArray0(a, vix, m);\n@@ -3327,2 +3429,1 @@\n-    DoubleVector fromArray0(double[] a, int offset,\n-                                    int[] indexMap, int mapOffset,\n+    DoubleVector fromArray0(double[] a, Vector<Integer> indexVector,\n@@ -3333,2 +3434,3 @@\n-    DoubleVector fromArray0Template(Class<M> maskClass, double[] a, int offset,\n-                                            int[] indexMap, int mapOffset, M m) {\n+    DoubleVector fromArray0Template(Class<M> maskClass, double[] a,\n+                                            Vector<Integer> indexVector, M m) {\n+        IntVector vix = (IntVector) indexVector;\n@@ -3336,4 +3438,1 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        m.check(vsp);\n+        VectorSpecies<Integer> isp = vix.species();\n@@ -3342,23 +3441,0 @@\n-        if (vsp.laneCount() == 1) {\n-          return DoubleVector.fromArray(vsp, a, offset + indexMap[mapOffset], m);\n-        }\n-\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For DoubleMaxVector,  if vector length is non-power-of-two or\n-            \/\/ 2048 bits, indexShape of Double species is S_MAX_BIT.\n-            \/\/ Assume that vector length is 2048, then the lane count of Double\n-            \/\/ vector is 32. When converting Double species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n-        }\n-\n@@ -3368,1 +3444,1 @@\n-        return VectorSupport.loadWithMap(\n+        return VectorSupport.loadWithIndexMap(\n@@ -3372,3 +3448,2 @@\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            a, vsp,\n+            (c, iv, s, vm) -> s.vOp(iv, vm, id -> c[id]));\n@@ -3828,1 +3903,2 @@\n-        DoubleVector vOp(FVOp f) {\n+        DoubleVector vOp(Vector<Integer> iv, FVOp f) {\n+            int[] indexMap = ((IntVector)iv).vec();\n@@ -3831,1 +3907,13 @@\n-                res[i] = f.apply(i);\n+                res[i] = f.apply(indexMap[i]);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        DoubleVector vOp(Vector<Integer> iv, VectorMask<Double> m, FVOp f) {\n+            int[] indexMap = ((IntVector)iv).vec();\n+            double[] res = new double[laneCount()];\n+            boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                if (mbits[i]) {\n+                    res[i] = f.apply(indexMap[i]);\n+                }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":137,"deletions":49,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -853,2 +853,2 @@\n-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        return super.fromArray0Template(Float128Mask.class, a, offset, indexMap, mapOffset, (Float128Mask) m);\n+    FloatVector fromArray0(float[] a, Vector<Integer> indexVector, VectorMask<Float> m) {\n+        return super.fromArray0Template(Float128Mask.class, a, indexVector, (Float128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -861,2 +861,2 @@\n-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        return super.fromArray0Template(Float256Mask.class, a, offset, indexMap, mapOffset, (Float256Mask) m);\n+    FloatVector fromArray0(float[] a, Vector<Integer> indexVector, VectorMask<Float> m) {\n+        return super.fromArray0Template(Float256Mask.class, a, indexVector, (Float256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -877,2 +877,2 @@\n-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        return super.fromArray0Template(Float512Mask.class, a, offset, indexMap, mapOffset, (Float512Mask) m);\n+    FloatVector fromArray0(float[] a, Vector<Integer> indexVector, VectorMask<Float> m) {\n+        return super.fromArray0Template(Float512Mask.class, a, indexVector, (Float512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -849,2 +849,2 @@\n-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        return super.fromArray0Template(Float64Mask.class, a, offset, indexMap, mapOffset, (Float64Mask) m);\n+    FloatVector fromArray0(float[] a, Vector<Integer> indexVector, VectorMask<Float> m) {\n+        return super.fromArray0Template(Float64Mask.class, a, indexVector, (Float64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -846,2 +846,2 @@\n-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        return super.fromArray0Template(FloatMaxMask.class, a, offset, indexMap, mapOffset, (FloatMaxMask) m);\n+    FloatVector fromArray0(float[] a, Vector<Integer> indexVector, VectorMask<Float> m) {\n+        return super.fromArray0Template(FloatMaxMask.class, a, indexVector, (FloatMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2841,0 +2841,42 @@\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code float[]},\n+     * using indexes obtained from an <em>index vector<\/em>.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[index]}, where {@code index} is the lane element\n+     * at lane index {@code N} of <em>index vector<\/em>.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param indexVector the index vector\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code index < 0} or {@code index >= a.length}\n+     *         for any lane element {@code index} at lane index {@code N}\n+     *         in the index vector\n+     * @throws IllegalArgumentException\n+     *         if index vector length and species length differ\n+     *\/\n+    @ForceInline\n+    public static\n+    FloatVector fromArray(VectorSpecies<Float> species,\n+                                   float[] a, Vector<Integer> indexVector) {\n+        IntVector vix = (IntVector) indexVector;\n+        FloatSpecies vsp = (FloatSpecies) species;\n+        VectorSpecies<Integer> isp = vix.species();\n+        Class<? extends FloatVector> vectorType = vsp.vectorType();\n+\n+        Objects.requireNonNull(a);\n+        VectorIntrinsics.requireLength(vix.length(), species.length());\n+        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+\n+        return VectorSupport.loadWithIndexMap(\n+            vectorType, null, float.class, vsp.laneCount(),\n+            isp.vectorType(),\n+            a, ARRAY_BASE, vix, null,\n+            a, vsp,\n+            (c, iv, s, vm) -> s.vOp(iv, id -> c[id]));\n+    }\n+\n@@ -2881,1 +2923,0 @@\n-        Class<? extends FloatVector> vectorType = vsp.vectorType();\n@@ -2888,1 +2929,2 @@\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        return fromArray(species, a, vix);\n+    }\n@@ -2890,7 +2932,41 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, null, float.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code float[]},\n+     * under the control of a mask, and\n+     * using indexes obtained from an <em>index vector<\/em>.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[index]}, where {@code index} is the lane element\n+     * at lane index {@code N} of <em>index vector<\/em>.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param indexVector the index vector\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code index < 0} or {@code index >= a.length}\n+     *         for any lane element {@code index} at lane index {@code N}\n+     *         in the index vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException\n+     *         if index vector length and species length differ\n+     *\/\n+    @ForceInline\n+    public static\n+    FloatVector fromArray(VectorSpecies<Float> species,\n+                                   float[] a, Vector<Integer> indexVector,\n+                                   VectorMask<Float> m) {\n+        if (m.allTrue()) {\n+            return fromArray(species, a, indexVector);\n+        } else {\n+            FloatSpecies vsp = (FloatSpecies) species;\n+            Objects.requireNonNull(a);\n+            m.check(vsp);\n+            VectorIntrinsics.requireLength(indexVector.length(), vsp.length());\n+\n+            return vsp.dummyVector().fromArray0(a, indexVector, m);\n+        }\n@@ -2943,2 +3019,1 @@\n-        }\n-        else {\n+        } else {\n@@ -2946,1 +3021,10 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+            Objects.requireNonNull(a);\n+            Objects.requireNonNull(indexMap);\n+            m.check(vsp);\n+            \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n+            IntVector vix = IntVector\n+                .fromArray(isp, indexMap, mapOffset)\n+                .add(offset);\n+\n+            return vsp.dummyVector().fromArray0(a, vix, m);\n@@ -3314,2 +3398,1 @@\n-    FloatVector fromArray0(float[] a, int offset,\n-                                    int[] indexMap, int mapOffset,\n+    FloatVector fromArray0(float[] a, Vector<Integer> indexVector,\n@@ -3320,2 +3403,3 @@\n-    FloatVector fromArray0Template(Class<M> maskClass, float[] a, int offset,\n-                                            int[] indexMap, int mapOffset, M m) {\n+    FloatVector fromArray0Template(Class<M> maskClass, float[] a,\n+                                            Vector<Integer> indexVector, M m) {\n+        IntVector vix = (IntVector) indexVector;\n@@ -3323,4 +3407,1 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        m.check(vsp);\n+        VectorSpecies<Integer> isp = vix.species();\n@@ -3329,5 +3410,0 @@\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-\n@@ -3337,1 +3413,1 @@\n-        return VectorSupport.loadWithMap(\n+        return VectorSupport.loadWithIndexMap(\n@@ -3341,3 +3417,2 @@\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            a, vsp,\n+            (c, iv, s, vm) -> s.vOp(iv, vm, id -> c[id]));\n@@ -3778,1 +3853,2 @@\n-        FloatVector vOp(FVOp f) {\n+        FloatVector vOp(Vector<Integer> iv, FVOp f) {\n+            int[] indexMap = ((IntVector)iv).vec();\n@@ -3781,1 +3857,13 @@\n-                res[i] = f.apply(i);\n+                res[i] = f.apply(indexMap[i]);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        FloatVector vOp(Vector<Integer> iv, VectorMask<Float> m, FVOp f) {\n+            int[] indexMap = ((IntVector)iv).vec();\n+            float[] res = new float[laneCount()];\n+            boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                if (mbits[i]) {\n+                    res[i] = f.apply(indexMap[i]);\n+                }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":119,"deletions":31,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -864,2 +864,2 @@\n-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        return super.fromArray0Template(Int128Mask.class, a, offset, indexMap, mapOffset, (Int128Mask) m);\n+    IntVector fromArray0(int[] a, Vector<Integer> indexVector, VectorMask<Integer> m) {\n+        return super.fromArray0Template(Int128Mask.class, a, indexVector, (Int128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -872,2 +872,2 @@\n-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        return super.fromArray0Template(Int256Mask.class, a, offset, indexMap, mapOffset, (Int256Mask) m);\n+    IntVector fromArray0(int[] a, Vector<Integer> indexVector, VectorMask<Integer> m) {\n+        return super.fromArray0Template(Int256Mask.class, a, indexVector, (Int256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -888,2 +888,2 @@\n-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        return super.fromArray0Template(Int512Mask.class, a, offset, indexMap, mapOffset, (Int512Mask) m);\n+    IntVector fromArray0(int[] a, Vector<Integer> indexVector, VectorMask<Integer> m) {\n+        return super.fromArray0Template(Int512Mask.class, a, indexVector, (Int512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -860,2 +860,2 @@\n-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        return super.fromArray0Template(Int64Mask.class, a, offset, indexMap, mapOffset, (Int64Mask) m);\n+    IntVector fromArray0(int[] a, Vector<Integer> indexVector, VectorMask<Integer> m) {\n+        return super.fromArray0Template(Int64Mask.class, a, indexVector, (Int64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -869,2 +869,2 @@\n-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        return super.fromArray0Template(IntMaxMask.class, a, offset, indexMap, mapOffset, (IntMaxMask) m);\n+    IntVector fromArray0(int[] a, Vector<Integer> indexVector, VectorMask<Integer> m) {\n+        return super.fromArray0Template(IntMaxMask.class, a, indexVector, (IntMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2998,0 +2998,42 @@\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code int[]},\n+     * using indexes obtained from an <em>index vector<\/em>.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[index]}, where {@code index} is the lane element\n+     * at lane index {@code N} of <em>index vector<\/em>.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param indexVector the index vector\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code index < 0} or {@code index >= a.length}\n+     *         for any lane element {@code index} at lane index {@code N}\n+     *         in the index vector\n+     * @throws IllegalArgumentException\n+     *         if index vector length and species length differ\n+     *\/\n+    @ForceInline\n+    public static\n+    IntVector fromArray(VectorSpecies<Integer> species,\n+                                   int[] a, Vector<Integer> indexVector) {\n+        IntVector vix = (IntVector) indexVector;\n+        IntSpecies vsp = (IntSpecies) species;\n+        VectorSpecies<Integer> isp = vix.species();\n+        Class<? extends IntVector> vectorType = vsp.vectorType();\n+\n+        Objects.requireNonNull(a);\n+        VectorIntrinsics.requireLength(vix.length(), species.length());\n+        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+\n+        return VectorSupport.loadWithIndexMap(\n+            vectorType, null, int.class, vsp.laneCount(),\n+            isp.vectorType(),\n+            a, ARRAY_BASE, vix, null,\n+            a, vsp,\n+            (c, iv, s, vm) -> s.vOp(iv, id -> c[id]));\n+    }\n+\n@@ -3038,1 +3080,0 @@\n-        Class<? extends IntVector> vectorType = vsp.vectorType();\n@@ -3045,1 +3086,2 @@\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        return fromArray(species, a, vix);\n+    }\n@@ -3047,7 +3089,41 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, null, int.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code int[]},\n+     * under the control of a mask, and\n+     * using indexes obtained from an <em>index vector<\/em>.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[index]}, where {@code index} is the lane element\n+     * at lane index {@code N} of <em>index vector<\/em>.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param indexVector the index vector\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code index < 0} or {@code index >= a.length}\n+     *         for any lane element {@code index} at lane index {@code N}\n+     *         in the index vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException\n+     *         if index vector length and species length differ\n+     *\/\n+    @ForceInline\n+    public static\n+    IntVector fromArray(VectorSpecies<Integer> species,\n+                                   int[] a, Vector<Integer> indexVector,\n+                                   VectorMask<Integer> m) {\n+        if (m.allTrue()) {\n+            return fromArray(species, a, indexVector);\n+        } else {\n+            IntSpecies vsp = (IntSpecies) species;\n+            Objects.requireNonNull(a);\n+            m.check(vsp);\n+            VectorIntrinsics.requireLength(indexVector.length(), vsp.length());\n+\n+            return vsp.dummyVector().fromArray0(a, indexVector, m);\n+        }\n@@ -3100,2 +3176,1 @@\n-        }\n-        else {\n+        } else {\n@@ -3103,1 +3178,10 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+            Objects.requireNonNull(a);\n+            Objects.requireNonNull(indexMap);\n+            m.check(vsp);\n+            \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n+            IntVector vix = IntVector\n+                .fromArray(isp, indexMap, mapOffset)\n+                .add(offset);\n+\n+            return vsp.dummyVector().fromArray0(a, vix, m);\n@@ -3471,2 +3555,1 @@\n-    IntVector fromArray0(int[] a, int offset,\n-                                    int[] indexMap, int mapOffset,\n+    IntVector fromArray0(int[] a, Vector<Integer> indexVector,\n@@ -3477,2 +3560,3 @@\n-    IntVector fromArray0Template(Class<M> maskClass, int[] a, int offset,\n-                                            int[] indexMap, int mapOffset, M m) {\n+    IntVector fromArray0Template(Class<M> maskClass, int[] a,\n+                                            Vector<Integer> indexVector, M m) {\n+        IntVector vix = (IntVector) indexVector;\n@@ -3480,4 +3564,1 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        m.check(vsp);\n+        VectorSpecies<Integer> isp = vix.species();\n@@ -3486,5 +3567,0 @@\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-\n@@ -3494,1 +3570,1 @@\n-        return VectorSupport.loadWithMap(\n+        return VectorSupport.loadWithIndexMap(\n@@ -3498,3 +3574,2 @@\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            a, vsp,\n+            (c, iv, s, vm) -> s.vOp(iv, vm, id -> c[id]));\n@@ -3935,1 +4010,2 @@\n-        IntVector vOp(FVOp f) {\n+        IntVector vOp(Vector<Integer> iv, FVOp f) {\n+            int[] indexMap = ((IntVector)iv).vec();\n@@ -3938,1 +4014,13 @@\n-                res[i] = f.apply(i);\n+                res[i] = f.apply(indexMap[i]);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        IntVector vOp(Vector<Integer> iv, VectorMask<Integer> m, FVOp f) {\n+            int[] indexMap = ((IntVector)iv).vec();\n+            int[] res = new int[laneCount()];\n+            boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                if (mbits[i]) {\n+                    res[i] = f.apply(indexMap[i]);\n+                }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":119,"deletions":31,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -850,2 +850,2 @@\n-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        return super.fromArray0Template(Long128Mask.class, a, offset, indexMap, mapOffset, (Long128Mask) m);\n+    LongVector fromArray0(long[] a, Vector<Integer> indexVector, VectorMask<Long> m) {\n+        return super.fromArray0Template(Long128Mask.class, a, indexVector, (Long128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -854,2 +854,2 @@\n-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        return super.fromArray0Template(Long256Mask.class, a, offset, indexMap, mapOffset, (Long256Mask) m);\n+    LongVector fromArray0(long[] a, Vector<Integer> indexVector, VectorMask<Long> m) {\n+        return super.fromArray0Template(Long256Mask.class, a, indexVector, (Long256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -862,2 +862,2 @@\n-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        return super.fromArray0Template(Long512Mask.class, a, offset, indexMap, mapOffset, (Long512Mask) m);\n+    LongVector fromArray0(long[] a, Vector<Integer> indexVector, VectorMask<Long> m) {\n+        return super.fromArray0Template(Long512Mask.class, a, indexVector, (Long512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -848,2 +848,2 @@\n-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        return super.fromArray0Template(Long64Mask.class, a, offset, indexMap, mapOffset, (Long64Mask) m);\n+    LongVector fromArray0(long[] a, Vector<Integer> indexVector, VectorMask<Long> m) {\n+        return super.fromArray0Template(Long64Mask.class, a, indexVector, (Long64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -848,2 +848,2 @@\n-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        return super.fromArray0Template(LongMaxMask.class, a, offset, indexMap, mapOffset, (LongMaxMask) m);\n+    LongVector fromArray0(long[] a, Vector<Integer> indexVector, VectorMask<Long> m) {\n+        return super.fromArray0Template(LongMaxMask.class, a, indexVector, (LongMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2859,0 +2859,42 @@\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code long[]},\n+     * using indexes obtained from an <em>index vector<\/em>.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[index]}, where {@code index} is the lane element\n+     * at lane index {@code N} of <em>index vector<\/em>.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param indexVector the index vector\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code index < 0} or {@code index >= a.length}\n+     *         for any lane element {@code index} at lane index {@code N}\n+     *         in the index vector\n+     * @throws IllegalArgumentException\n+     *         if index vector length and species length differ\n+     *\/\n+    @ForceInline\n+    public static\n+    LongVector fromArray(VectorSpecies<Long> species,\n+                                   long[] a, Vector<Integer> indexVector) {\n+        IntVector vix = (IntVector) indexVector;\n+        LongSpecies vsp = (LongSpecies) species;\n+        VectorSpecies<Integer> isp = vix.species();\n+        Class<? extends LongVector> vectorType = vsp.vectorType();\n+\n+        Objects.requireNonNull(a);\n+        VectorIntrinsics.requireLength(vix.length(), species.length());\n+        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+\n+        return VectorSupport.loadWithIndexMap(\n+            vectorType, null, long.class, vsp.laneCount(),\n+            isp.vectorType(),\n+            a, ARRAY_BASE, vix, null,\n+            a, vsp,\n+            (c, iv, s, vm) -> s.vOp(iv, id -> c[id]));\n+    }\n+\n@@ -2899,1 +2941,0 @@\n-        Class<? extends LongVector> vectorType = vsp.vectorType();\n@@ -2924,1 +2965,2 @@\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        return fromArray(species, a, vix);\n+    }\n@@ -2926,7 +2968,41 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, null, long.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code long[]},\n+     * under the control of a mask, and\n+     * using indexes obtained from an <em>index vector<\/em>.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[index]}, where {@code index} is the lane element\n+     * at lane index {@code N} of <em>index vector<\/em>.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param indexVector the index vector\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code index < 0} or {@code index >= a.length}\n+     *         for any lane element {@code index} at lane index {@code N}\n+     *         in the index vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException\n+     *         if index vector length and species length differ\n+     *\/\n+    @ForceInline\n+    public static\n+    LongVector fromArray(VectorSpecies<Long> species,\n+                                   long[] a, Vector<Integer> indexVector,\n+                                   VectorMask<Long> m) {\n+        if (m.allTrue()) {\n+            return fromArray(species, a, indexVector);\n+        } else {\n+            LongSpecies vsp = (LongSpecies) species;\n+            Objects.requireNonNull(a);\n+            m.check(vsp);\n+            VectorIntrinsics.requireLength(indexVector.length(), vsp.length());\n+\n+            return vsp.dummyVector().fromArray0(a, indexVector, m);\n+        }\n@@ -2979,2 +3055,1 @@\n-        }\n-        else {\n+        } else {\n@@ -2982,1 +3057,28 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+            Objects.requireNonNull(a);\n+            Objects.requireNonNull(indexMap);\n+            m.check(vsp);\n+            if (vsp.laneCount() == 1) {\n+                return LongVector.fromArray(vsp, a, offset + indexMap[mapOffset], m);\n+            }\n+\n+            \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n+            IntVector vix;\n+            if (isp.laneCount() != vsp.laneCount()) {\n+                \/\/ For LongMaxVector,  if vector length is non-power-of-two or\n+                \/\/ 2048 bits, indexShape of Long species is S_MAX_BIT.\n+                \/\/ Assume that vector length is 2048, then the lane count of Long\n+                \/\/ vector is 32. When converting Long species to int species,\n+                \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n+                \/\/ is 64. So when loading index vector (IntVector), only lower half\n+                \/\/ of index data is needed.\n+                vix = IntVector\n+                    .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n+                    .add(offset);\n+            } else {\n+                vix = IntVector\n+                    .fromArray(isp, indexMap, mapOffset)\n+                    .add(offset);\n+            }\n+\n+            return vsp.dummyVector().fromArray0(a, vix, m);\n@@ -3369,2 +3471,1 @@\n-    LongVector fromArray0(long[] a, int offset,\n-                                    int[] indexMap, int mapOffset,\n+    LongVector fromArray0(long[] a, Vector<Integer> indexVector,\n@@ -3375,2 +3476,3 @@\n-    LongVector fromArray0Template(Class<M> maskClass, long[] a, int offset,\n-                                            int[] indexMap, int mapOffset, M m) {\n+    LongVector fromArray0Template(Class<M> maskClass, long[] a,\n+                                            Vector<Integer> indexVector, M m) {\n+        IntVector vix = (IntVector) indexVector;\n@@ -3378,4 +3480,1 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        m.check(vsp);\n+        VectorSpecies<Integer> isp = vix.species();\n@@ -3384,23 +3483,0 @@\n-        if (vsp.laneCount() == 1) {\n-          return LongVector.fromArray(vsp, a, offset + indexMap[mapOffset], m);\n-        }\n-\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For LongMaxVector,  if vector length is non-power-of-two or\n-            \/\/ 2048 bits, indexShape of Long species is S_MAX_BIT.\n-            \/\/ Assume that vector length is 2048, then the lane count of Long\n-            \/\/ vector is 32. When converting Long species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n-        }\n-\n@@ -3410,1 +3486,1 @@\n-        return VectorSupport.loadWithMap(\n+        return VectorSupport.loadWithIndexMap(\n@@ -3414,3 +3490,2 @@\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            a, vsp,\n+            (c, iv, s, vm) -> s.vOp(iv, vm, id -> c[id]));\n@@ -3861,1 +3936,2 @@\n-        LongVector vOp(FVOp f) {\n+        LongVector vOp(Vector<Integer> iv, FVOp f) {\n+            int[] indexMap = ((IntVector)iv).vec();\n@@ -3864,1 +3940,13 @@\n-                res[i] = f.apply(i);\n+                res[i] = f.apply(indexMap[i]);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        LongVector vOp(Vector<Integer> iv, VectorMask<Long> m, FVOp f) {\n+            int[] indexMap = ((IntVector)iv).vec();\n+            long[] res = new long[laneCount()];\n+            boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                if (mbits[i]) {\n+                    res[i] = f.apply(indexMap[i]);\n+                }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":137,"deletions":49,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -3021,0 +3021,1 @@\n+\n@@ -3061,0 +3062,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3595,0 +3595,44 @@\n+#if[!byteOrShort]\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code $type$[]},\n+     * using indexes obtained from an <em>index vector<\/em>.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[index]}, where {@code index} is the lane element\n+     * at lane index {@code N} of <em>index vector<\/em>.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param indexVector the index vector\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code index < 0} or {@code index >= a.length}\n+     *         for any lane element {@code index} at lane index {@code N}\n+     *         in the index vector\n+     * @throws IllegalArgumentException\n+     *         if index vector length and species length differ\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromArray(VectorSpecies<$Boxtype$> species,\n+                                   $type$[] a, Vector<Integer> indexVector) {\n+        IntVector vix = (IntVector) indexVector;\n+        $Type$Species vsp = ($Type$Species) species;\n+        VectorSpecies<Integer> isp = vix.species();\n+        Class<? extends $abstractvectortype$> vectorType = vsp.vectorType();\n+\n+        Objects.requireNonNull(a);\n+        VectorIntrinsics.requireLength(vix.length(), species.length());\n+        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+\n+        return VectorSupport.loadWithIndexMap(\n+            vectorType, null, $type$.class, vsp.laneCount(),\n+            isp.vectorType(),\n+            a, ARRAY_BASE, vix, null,\n+            a, vsp,\n+            (c, iv, s, vm) -> s.vOp(iv, id -> c[id]));\n+    }\n+#end[!byteOrShort]\n+\n@@ -3645,1 +3689,0 @@\n-        Class<? extends $abstractvectortype$> vectorType = vsp.vectorType();\n@@ -3677,1 +3720,3 @@\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        return fromArray(species, a, vix);\n+    }\n+#end[byteOrShort]\n@@ -3679,7 +3724,42 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, null, $type$.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+#if[!byteOrShort]\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code $type$[]},\n+     * under the control of a mask, and\n+     * using indexes obtained from an <em>index vector<\/em>.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[index]}, where {@code index} is the lane element\n+     * at lane index {@code N} of <em>index vector<\/em>.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param indexVector the index vector\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code index < 0} or {@code index >= a.length}\n+     *         for any lane element {@code index} at lane index {@code N}\n+     *         in the index vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException\n+     *         if index vector length and species length differ\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromArray(VectorSpecies<$Boxtype$> species,\n+                                   $type$[] a, Vector<Integer> indexVector,\n+                                   VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            return fromArray(species, a, indexVector);\n+        } else {\n+            $Type$Species vsp = ($Type$Species) species;\n+            Objects.requireNonNull(a);\n+            m.check(vsp);\n+            VectorIntrinsics.requireLength(indexVector.length(), vsp.length());\n+\n+            return vsp.dummyVector().fromArray0(a, indexVector, m);\n+        }\n@@ -3744,2 +3824,1 @@\n-        }\n-        else {\n+        } else {\n@@ -3747,1 +3826,35 @@\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+            IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n+            Objects.requireNonNull(a);\n+            Objects.requireNonNull(indexMap);\n+            m.check(vsp);\n+#if[longOrDouble]\n+            if (vsp.laneCount() == 1) {\n+                return $abstractvectortype$.fromArray(vsp, a, offset + indexMap[mapOffset], m);\n+            }\n+\n+            \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n+            IntVector vix;\n+            if (isp.laneCount() != vsp.laneCount()) {\n+                \/\/ For $Type$MaxVector,  if vector length is non-power-of-two or\n+                \/\/ 2048 bits, indexShape of $Type$ species is S_MAX_BIT.\n+                \/\/ Assume that vector length is 2048, then the lane count of $Type$\n+                \/\/ vector is 32. When converting $Type$ species to int species,\n+                \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n+                \/\/ is 64. So when loading index vector (IntVector), only lower half\n+                \/\/ of index data is needed.\n+                vix = IntVector\n+                    .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n+                    .add(offset);\n+            } else {\n+                vix = IntVector\n+                    .fromArray(isp, indexMap, mapOffset)\n+                    .add(offset);\n+            }\n+#else[longOrDouble]\n+            \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n+            IntVector vix = IntVector\n+                .fromArray(isp, indexMap, mapOffset)\n+                .add(offset);\n+#end[longOrDouble]\n+\n+            return vsp.dummyVector().fromArray0(a, vix, m);\n@@ -4806,2 +4919,1 @@\n-    $abstractvectortype$ fromArray0($type$[] a, int offset,\n-                                    int[] indexMap, int mapOffset,\n+    $abstractvectortype$ fromArray0($type$[] a, Vector<Integer> indexVector,\n@@ -4812,2 +4924,3 @@\n-    $abstractvectortype$ fromArray0Template(Class<M> maskClass, $type$[] a, int offset,\n-                                            int[] indexMap, int mapOffset, M m) {\n+    $abstractvectortype$ fromArray0Template(Class<M> maskClass, $type$[] a,\n+                                            Vector<Integer> indexVector, M m) {\n+        IntVector vix = (IntVector) indexVector;\n@@ -4815,4 +4928,1 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        m.check(vsp);\n+        VectorSpecies<Integer> isp = vix.species();\n@@ -4821,30 +4931,0 @@\n-#if[longOrDouble]\n-        if (vsp.laneCount() == 1) {\n-          return $abstractvectortype$.fromArray(vsp, a, offset + indexMap[mapOffset], m);\n-        }\n-\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For $Type$MaxVector,  if vector length is non-power-of-two or\n-            \/\/ 2048 bits, indexShape of $Type$ species is S_MAX_BIT.\n-            \/\/ Assume that vector length is 2048, then the lane count of $Type$\n-            \/\/ vector is 32. When converting $Type$ species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n-        }\n-#else[longOrDouble]\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-#end[longOrDouble]\n-\n@@ -4854,1 +4934,1 @@\n-        return VectorSupport.loadWithMap(\n+        return VectorSupport.loadWithIndexMap(\n@@ -4858,3 +4938,2 @@\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+            a, vsp,\n+            (c, iv, s, vm) -> s.vOp(iv, vm, id -> c[id]));\n@@ -5486,0 +5565,1 @@\n+#if[byteOrShort]\n@@ -5493,0 +5573,22 @@\n+#else[byteOrShort]\n+        $Type$Vector vOp(Vector<Integer> iv, FVOp f) {\n+            int[] indexMap = ((IntVector)iv).vec();\n+            $type$[] res = new $type$[laneCount()];\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(indexMap[i]);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        $Type$Vector vOp(Vector<Integer> iv, VectorMask<$Boxtype$> m, FVOp f) {\n+            int[] indexMap = ((IntVector)iv).vec();\n+            $type$[] res = new $type$[laneCount()];\n+            boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                if (mbits[i]) {\n+                    res[i] = f.apply(indexMap[i]);\n+                }\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+#end[byteOrShort]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":156,"deletions":54,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -1147,2 +1147,2 @@\n-    $abstractvectortype$ fromArray0($type$[] a, int offset, int[] indexMap, int mapOffset, VectorMask<$Boxtype$> m) {\n-        return super.fromArray0Template($masktype$.class, a, offset, indexMap, mapOffset, ($masktype$) m);\n+    $abstractvectortype$ fromArray0($type$[] a, Vector<Integer> indexVector, VectorMask<$Boxtype$> m) {\n+        return super.fromArray0Template($masktype$.class, a, indexVector, ($masktype$) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}