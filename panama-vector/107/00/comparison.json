{"files":[{"patch":"@@ -979,3 +979,0 @@\n-\/\/    TODO: Handle special cases where load\/store happens from\/to byte array but element type\n-\/\/    is not byte.\n-\/\/\n@@ -1021,0 +1018,1 @@\n+\n@@ -1024,0 +1022,27 @@\n+  Node* base = argument(4);\n+  Node* offset = ConvL2X(argument(5));\n+\n+  \/\/ Save state and restore on bailout\n+  uint old_sp = sp();\n+  SafePointNode* old_map = clone_map();\n+\n+  Node* addr = make_unsafe_address(base, offset, elem_bt, true);\n+  const TypePtr *addr_type = gvn().type(addr)->isa_ptr();\n+  const TypeAryPtr* arr_type = addr_type->isa_aryptr();\n+\n+  \/\/ Now handle special case where load\/store happens from\/to byte array but element type is not byte.\n+  bool using_byte_array = arr_type != NULL && arr_type->elem()->array_element_basic_type() == T_BYTE && elem_bt != T_BYTE;\n+  \/\/ If there is no consistency between array and vector element types, it must be special byte array case\n+  if (arr_type != NULL && !using_byte_array && !elem_consistent_with_arr(elem_bt, arr_type)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s\",\n+                    is_store, is_store ? \"storeMasked\" : \"loadMasked\",\n+                    num_elem, type2name(elem_bt), type2name(arr_type->elem()->array_element_basic_type()));\n+    }\n+    set_map(old_map);\n+    set_sp(old_sp);\n+    return false;\n+  }\n+\n+  int mem_num_elem = using_byte_array ? num_elem * type2aelembytes(elem_bt) : num_elem;\n+  BasicType mem_elem_bt = using_byte_array ? T_BYTE : elem_bt;\n@@ -1025,1 +1050,2 @@\n-                                            num_elem, elem_bt, (VectorMaskUseType) (VecMaskUseLoad | VecMaskUsePred));\n+                                            mem_num_elem, mem_elem_bt,\n+                                            (VectorMaskUseType) (VecMaskUseLoad | VecMaskUsePred));\n@@ -1030,2 +1056,2 @@\n-      tty->print_cr(\"  ** not supported: op=storeMasked vlen=%d etype=%s\",\n-                    num_elem, type2name(elem_bt));\n+      tty->print_cr(\"  ** not supported: op=storeMasked vlen=%d etype=%s using_byte_array=%d\",\n+                    num_elem, type2name(elem_bt), using_byte_array ? 1 : 0);\n@@ -1033,0 +1059,2 @@\n+    set_map(old_map);\n+    set_sp(old_sp);\n@@ -1038,2 +1066,2 @@\n-  if (!use_predicate && (!arch_supports_vector(Op_LoadVector, num_elem, elem_bt, VecMaskNotUsed) ||\n-      !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad))) {\n+  if (!use_predicate && (!arch_supports_vector(Op_LoadVector, mem_num_elem, mem_elem_bt, VecMaskNotUsed) ||\n+      !arch_supports_vector(Op_VectorBlend, mem_num_elem, mem_elem_bt, VecMaskUseLoad))) {\n@@ -1041,2 +1069,2 @@\n-      tty->print_cr(\"  ** not supported: op=loadMasked vlen=%d etype=%s\",\n-                    num_elem, type2name(elem_bt));\n+      tty->print_cr(\"  ** not supported: op=loadMasked vlen=%d etype=%s using_byte_array=%d\",\n+                    num_elem, type2name(elem_bt), using_byte_array ? 1 : 0);\n@@ -1044,0 +1072,2 @@\n+    set_map(old_map);\n+    set_sp(old_sp);\n@@ -1047,6 +1077,14 @@\n-  Node* base = argument(4);\n-  Node* offset = ConvL2X(argument(5));\n-\n-  \/\/ Save state and restore on bailout\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  \/\/ Since we are using byte array, we need to double check that the vector reinterpret operation\n+  \/\/ with byte type is supported by backend.\n+  if (using_byte_array) {\n+    if (!arch_supports_vector(Op_VectorReinterpret, mem_num_elem, T_BYTE, VecMaskNotUsed)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s using_byte_array=1\",\n+                      is_store, is_store ? \"storeMasked\" : \"loadMasked\",\n+                      num_elem, type2name(elem_bt));\n+      }\n+      set_map(old_map);\n+      set_sp(old_sp);\n+      return false;\n+    }\n+  }\n@@ -1054,4 +1092,3 @@\n-  Node* addr = make_unsafe_address(base, offset, elem_bt, true);\n-  const TypePtr *addr_type = gvn().type(addr)->isa_ptr();\n-  const TypeAryPtr* arr_type = addr_type->isa_aryptr();\n-  if (arr_type != NULL && !elem_consistent_with_arr(elem_bt, arr_type)) {\n+  \/\/ Since it needs to unbox the mask, we need to double check that the related load operations\n+  \/\/ for mask are supported by backend.\n+  if (!arch_supports_vector(Op_LoadVector, num_elem, elem_bt, VecMaskUseLoad)) {\n@@ -1059,3 +1096,3 @@\n-      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s atype=%s\",\n-                    is_store, is_store ? \"storeMasked\" : \"loadMasked\",\n-                    num_elem, type2name(elem_bt), type2name(arr_type->elem()->array_element_basic_type()));\n+      tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s\",\n+                      is_store, is_store ? \"storeMasked\" : \"loadMasked\",\n+                      num_elem, type2name(elem_bt));\n@@ -1104,0 +1141,10 @@\n+\n+    if (using_byte_array) {\n+      \/\/ Reinterpret the incoming vector to byte vector.\n+      const TypeVect* to_vect_type = TypeVect::make(mem_elem_bt, mem_num_elem);\n+      val = gvn().transform(new VectorReinterpretNode(val, val->bottom_type()->is_vect(), to_vect_type));\n+      \/\/ Reinterpret the vector mask to byte type.\n+      const TypeVect* from_mask_type = TypeVect::makemask(elem_bt, num_elem);\n+      const TypeVect* to_mask_type = TypeVect::makemask(mem_elem_bt, mem_num_elem);\n+      mask = gvn().transform(new VectorReinterpretNode(mask, from_mask_type, to_mask_type));\n+    }\n@@ -1108,0 +1155,8 @@\n+\n+    if (using_byte_array) {\n+      \/\/ Reinterpret the vector mask to byte type.\n+      const TypeVect* from_mask_type = TypeVect::makemask(elem_bt, num_elem);\n+      const TypeVect* to_mask_type = TypeVect::makemask(mem_elem_bt, mem_num_elem);\n+      mask = gvn().transform(new VectorReinterpretNode(mask, from_mask_type, to_mask_type));\n+    }\n+\n@@ -1110,1 +1165,1 @@\n-      const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+      const TypeVect* vt = TypeVect::make(mem_elem_bt, mem_num_elem);\n@@ -1114,3 +1169,3 @@\n-      Node* zero = gvn().transform(gvn().zerocon(elem_bt));\n-      zero = gvn().transform(VectorNode::scalar2vector(zero, num_elem, Type::get_const_basic_type(elem_bt)));\n-      vload = gvn().transform(LoadVectorNode::make(0, control(), memory(addr), addr, addr_type, num_elem, elem_bt));\n+      Node* zero = gvn().transform(gvn().zerocon(mem_elem_bt));\n+      zero = gvn().transform(VectorNode::scalar2vector(zero, mem_num_elem, Type::get_const_basic_type(mem_elem_bt)));\n+      vload = gvn().transform(LoadVectorNode::make(0, control(), memory(addr), addr, addr_type, mem_num_elem, mem_elem_bt));\n@@ -1119,0 +1174,6 @@\n+\n+    if (using_byte_array) {\n+      const TypeVect* to_vect_type = TypeVect::make(elem_bt, num_elem);\n+      vload = gvn().transform(new VectorReinterpretNode(vload, vload->bottom_type()->is_vect(), to_vect_type));\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":88,"deletions":27,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -418,0 +418,43 @@\n+    @ForceInline\n+    public static\n+    <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>,\n+     M extends VectorSupport.VectorMask<E>>\n+    V loadFromByteBufferMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n+                               int length, ByteBuffer bb, int offset, M m, S s,\n+                               VectorSupport.LoadVectorMaskedOperation<ByteBuffer, V, E, S, M> defaultImpl) {\n+        try {\n+            return loadFromByteBufferMaskedScoped(\n+                    BufferAccess.scope(bb),\n+                    vmClass, maskClass, e, length,\n+                    bb, offset, m,\n+                    s,\n+                    defaultImpl);\n+        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @Scoped\n+    @ForceInline\n+    private static\n+    <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>,\n+     M extends VectorSupport.VectorMask<E>>\n+    V loadFromByteBufferMaskedScoped(ScopedMemoryAccess.Scope scope, Class<? extends V> vmClass,\n+                                     Class<M> maskClass, Class<E> e, int length,\n+                                     ByteBuffer bb, int offset, M m,\n+                                     S s,\n+                                     VectorSupport.LoadVectorMaskedOperation<ByteBuffer, V, E, S, M> defaultImpl) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+\n+            return VectorSupport.loadMasked(vmClass, maskClass, e, length,\n+                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset), m,\n+                    bb, offset, s,\n+                    defaultImpl);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n@@ -461,0 +504,42 @@\n+    @ForceInline\n+    public static\n+    <V extends VectorSupport.Vector<E>, E, M extends VectorSupport.VectorMask<E>>\n+    void storeIntoByteBufferMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n+                                   int length, V v, M m,\n+                                   ByteBuffer bb, int offset,\n+                                   VectorSupport.StoreVectorMaskedOperation<ByteBuffer, V, M> defaultImpl) {\n+        try {\n+            storeIntoByteBufferMaskedScoped(\n+                    BufferAccess.scope(bb),\n+                    vmClass, maskClass, e, length,\n+                    v, m,\n+                    bb, offset,\n+                    defaultImpl);\n+        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @Scoped\n+    @ForceInline\n+    private static\n+    <V extends VectorSupport.Vector<E>, E, M extends VectorSupport.VectorMask<E>>\n+    void storeIntoByteBufferMaskedScoped(ScopedMemoryAccess.Scope scope,\n+                                         Class<? extends V> vmClass, Class<M> maskClass,\n+                                         Class<E> e, int length, V v, M m,\n+                                         ByteBuffer bb, int offset,\n+                                         VectorSupport.StoreVectorMaskedOperation<ByteBuffer, V, M> defaultImpl) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+\n+            VectorSupport.storeMasked(vmClass, maskClass, e, length,\n+                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n+                    v, m,\n+                    bb, offset,\n+                    defaultImpl);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -236,1 +236,0 @@\n-            \/\/ This requires a split test.\n@@ -238,6 +237,3 @@\n-            int elemCount = Math.min(vlength, (alength - clipOffset) \/ esize);\n-            badMask = checkIndex0(0, elemCount, iota, vlength);\n-            clipOffset &= (esize - 1);  \/\/ power of two, so OK\n-            VectorMask<E> badMask2 = checkIndex0(clipOffset \/ esize, vlength,\n-                                                 iota, vlength);\n-            badMask = badMask.or(badMask2);\n+            badMask = checkIndex0(clipOffset, alength,\n+                                  iota.lanewise(VectorOperators.MUL, esize),\n+                                  vlength * esize);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -863,0 +863,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromByteArray0Template(Byte128Mask.class, a, offset, (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -870,0 +877,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n+        return super.fromByteBuffer0Template(Byte128Mask.class, bb, offset, (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -899,0 +913,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        super.intoByteArray0Template(Byte128Mask.class, a, offset, (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n+        super.intoByteBuffer0Template(Byte128Mask.class, bb, offset, (Byte128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -895,0 +895,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromByteArray0Template(Byte256Mask.class, a, offset, (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -902,0 +909,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n+        return super.fromByteBuffer0Template(Byte256Mask.class, bb, offset, (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -931,0 +945,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        super.intoByteArray0Template(Byte256Mask.class, a, offset, (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n+        super.intoByteBuffer0Template(Byte256Mask.class, bb, offset, (Byte256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -959,0 +959,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromByteArray0Template(Byte512Mask.class, a, offset, (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -966,0 +973,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n+        return super.fromByteBuffer0Template(Byte512Mask.class, bb, offset, (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -995,0 +1009,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        super.intoByteArray0Template(Byte512Mask.class, a, offset, (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n+        super.intoByteBuffer0Template(Byte512Mask.class, bb, offset, (Byte512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -847,0 +847,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromByteArray0Template(Byte64Mask.class, a, offset, (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -854,0 +861,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n+        return super.fromByteBuffer0Template(Byte64Mask.class, bb, offset, (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -883,0 +897,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        super.intoByteArray0Template(Byte64Mask.class, a, offset, (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n+        super.intoByteBuffer0Template(Byte64Mask.class, bb, offset, (Byte64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -833,0 +833,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        return super.fromByteArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -840,0 +847,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n+        return super.fromByteBuffer0Template(ByteMaxMask.class, bb, offset, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -869,0 +883,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n+        super.intoByteArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n+        super.intoByteBuffer0Template(ByteMaxMask.class, bb, offset, (ByteMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2857,3 +2857,1 @@\n-            ByteVector zero = vsp.zero();\n-            ByteVector v = zero.fromByteArray0(a, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n@@ -3256,3 +3254,1 @@\n-            ByteVector zero = vsp.zero();\n-            ByteVector v = zero.fromByteBuffer0(bb, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n@@ -3606,1 +3602,0 @@\n-            \/\/ FIXME: optimize\n@@ -3609,3 +3604,1 @@\n-            ByteBuffer wb = wrapper(a, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+            maybeSwap(bo).intoByteArray0(a, offset, m);\n@@ -3642,1 +3635,0 @@\n-            \/\/ FIXME: optimize\n@@ -3648,3 +3640,1 @@\n-            ByteBuffer wb = wrapper(bb, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n@@ -3757,0 +3747,19 @@\n+    abstract\n+    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    ByteVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        ByteSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                return s.ldOp(wb, off, vm,\n+                        (wb_, o, i) -> wb_.get(o + i * 1));\n+            });\n+    }\n+\n@@ -3773,0 +3782,18 @@\n+    abstract\n+    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    ByteVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        ByteSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                bb, offset, m, vsp,\n+                (buf, off, s, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off, vm,\n+                            (wb_, o, i) -> wb_.get(o + i * 1));\n+                });\n+    }\n+\n@@ -3845,0 +3872,19 @@\n+    abstract\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        ByteSpecies vsp = vspecies();\n+        m.check(vsp);\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                v.stOp(wb, off, vm,\n+                        (tb_, o, i, e) -> tb_.put(o + i * 1, e));\n+            });\n+    }\n+\n@@ -3859,0 +3905,18 @@\n+    abstract\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        ByteSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m, bb, offset,\n+                (buf, off, v, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off, vm,\n+                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                });\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":78,"deletions":14,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -817,0 +817,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n+        return super.fromByteArray0Template(Double128Mask.class, a, offset, (Double128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -824,0 +831,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n+        return super.fromByteBuffer0Template(Double128Mask.class, bb, offset, (Double128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -853,0 +867,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n+        super.intoByteArray0Template(Double128Mask.class, a, offset, (Double128Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n+        super.intoByteBuffer0Template(Double128Mask.class, bb, offset, (Double128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -821,0 +821,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n+        return super.fromByteArray0Template(Double256Mask.class, a, offset, (Double256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -828,0 +835,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n+        return super.fromByteBuffer0Template(Double256Mask.class, bb, offset, (Double256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -857,0 +871,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n+        super.intoByteArray0Template(Double256Mask.class, a, offset, (Double256Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n+        super.intoByteBuffer0Template(Double256Mask.class, bb, offset, (Double256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -829,0 +829,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n+        return super.fromByteArray0Template(Double512Mask.class, a, offset, (Double512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -836,0 +843,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n+        return super.fromByteBuffer0Template(Double512Mask.class, bb, offset, (Double512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -865,0 +879,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n+        super.intoByteArray0Template(Double512Mask.class, a, offset, (Double512Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n+        super.intoByteBuffer0Template(Double512Mask.class, bb, offset, (Double512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -815,0 +815,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n+        return super.fromByteArray0Template(Double64Mask.class, a, offset, (Double64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -822,0 +829,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n+        return super.fromByteBuffer0Template(Double64Mask.class, bb, offset, (Double64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -851,0 +865,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n+        super.intoByteArray0Template(Double64Mask.class, a, offset, (Double64Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n+        super.intoByteBuffer0Template(Double64Mask.class, bb, offset, (Double64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -814,0 +814,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n+        return super.fromByteArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -821,0 +828,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n+        return super.fromByteBuffer0Template(DoubleMaxMask.class, bb, offset, (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -850,0 +864,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n+        super.intoByteArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n+        super.intoByteBuffer0Template(DoubleMaxMask.class, bb, offset, (DoubleMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2661,3 +2661,1 @@\n-            DoubleVector zero = vsp.zero();\n-            DoubleVector v = zero.fromByteArray0(a, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n@@ -2950,3 +2948,1 @@\n-            DoubleVector zero = vsp.zero();\n-            DoubleVector v = zero.fromByteBuffer0(bb, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n@@ -3171,1 +3167,0 @@\n-            \/\/ FIXME: optimize\n@@ -3174,3 +3169,1 @@\n-            ByteBuffer wb = wrapper(a, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+            maybeSwap(bo).intoByteArray0(a, offset, m);\n@@ -3207,1 +3200,0 @@\n-            \/\/ FIXME: optimize\n@@ -3213,3 +3205,1 @@\n-            ByteBuffer wb = wrapper(bb, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n@@ -3342,0 +3332,19 @@\n+    abstract\n+    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    DoubleVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        DoubleSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                return s.ldOp(wb, off, vm,\n+                        (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+            });\n+    }\n+\n@@ -3358,0 +3367,18 @@\n+    abstract\n+    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    DoubleVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        DoubleSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                bb, offset, m, vsp,\n+                (buf, off, s, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off, vm,\n+                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                });\n+    }\n+\n@@ -3465,0 +3492,19 @@\n+    abstract\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        DoubleSpecies vsp = vspecies();\n+        m.check(vsp);\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                v.stOp(wb, off, vm,\n+                        (tb_, o, i, e) -> tb_.putDouble(o + i * 8, e));\n+            });\n+    }\n+\n@@ -3479,0 +3525,18 @@\n+    abstract\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        DoubleSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m, bb, offset,\n+                (buf, off, v, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off, vm,\n+                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                });\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":78,"deletions":14,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -821,0 +821,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n+        return super.fromByteArray0Template(Float128Mask.class, a, offset, (Float128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -828,0 +835,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n+        return super.fromByteBuffer0Template(Float128Mask.class, bb, offset, (Float128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -857,0 +871,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n+        super.intoByteArray0Template(Float128Mask.class, a, offset, (Float128Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n+        super.intoByteBuffer0Template(Float128Mask.class, bb, offset, (Float128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -829,0 +829,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n+        return super.fromByteArray0Template(Float256Mask.class, a, offset, (Float256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -836,0 +843,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n+        return super.fromByteBuffer0Template(Float256Mask.class, bb, offset, (Float256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -865,0 +879,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n+        super.intoByteArray0Template(Float256Mask.class, a, offset, (Float256Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n+        super.intoByteBuffer0Template(Float256Mask.class, bb, offset, (Float256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -845,0 +845,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n+        return super.fromByteArray0Template(Float512Mask.class, a, offset, (Float512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -852,0 +859,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n+        return super.fromByteBuffer0Template(Float512Mask.class, bb, offset, (Float512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -881,0 +895,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n+        super.intoByteArray0Template(Float512Mask.class, a, offset, (Float512Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n+        super.intoByteBuffer0Template(Float512Mask.class, bb, offset, (Float512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -817,0 +817,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n+        return super.fromByteArray0Template(Float64Mask.class, a, offset, (Float64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -824,0 +831,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n+        return super.fromByteBuffer0Template(Float64Mask.class, bb, offset, (Float64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -853,0 +867,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n+        super.intoByteArray0Template(Float64Mask.class, a, offset, (Float64Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n+        super.intoByteBuffer0Template(Float64Mask.class, bb, offset, (Float64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -814,0 +814,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n+        return super.fromByteArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -821,0 +828,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n+        return super.fromByteBuffer0Template(FloatMaxMask.class, bb, offset, (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -850,0 +864,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n+        super.intoByteArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n+        super.intoByteBuffer0Template(FloatMaxMask.class, bb, offset, (FloatMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2685,3 +2685,1 @@\n-            FloatVector zero = vsp.zero();\n-            FloatVector v = zero.fromByteArray0(a, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n@@ -2956,3 +2954,1 @@\n-            FloatVector zero = vsp.zero();\n-            FloatVector v = zero.fromByteBuffer0(bb, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n@@ -3158,1 +3154,0 @@\n-            \/\/ FIXME: optimize\n@@ -3161,3 +3156,1 @@\n-            ByteBuffer wb = wrapper(a, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+            maybeSwap(bo).intoByteArray0(a, offset, m);\n@@ -3194,1 +3187,0 @@\n-            \/\/ FIXME: optimize\n@@ -3200,3 +3192,1 @@\n-            ByteBuffer wb = wrapper(bb, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n@@ -3311,0 +3301,19 @@\n+    abstract\n+    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    FloatVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        FloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                return s.ldOp(wb, off, vm,\n+                        (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+            });\n+    }\n+\n@@ -3327,0 +3336,18 @@\n+    abstract\n+    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    FloatVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        FloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                bb, offset, m, vsp,\n+                (buf, off, s, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off, vm,\n+                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                });\n+    }\n+\n@@ -3415,0 +3442,19 @@\n+    abstract\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        FloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                v.stOp(wb, off, vm,\n+                        (tb_, o, i, e) -> tb_.putFloat(o + i * 4, e));\n+            });\n+    }\n+\n@@ -3429,0 +3475,18 @@\n+    abstract\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        FloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m, bb, offset,\n+                (buf, off, v, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off, vm,\n+                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                });\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":78,"deletions":14,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -832,0 +832,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n+        return super.fromByteArray0Template(Int128Mask.class, a, offset, (Int128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -839,0 +846,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n+        return super.fromByteBuffer0Template(Int128Mask.class, bb, offset, (Int128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -868,0 +882,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n+        super.intoByteArray0Template(Int128Mask.class, a, offset, (Int128Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n+        super.intoByteBuffer0Template(Int128Mask.class, bb, offset, (Int128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -840,0 +840,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n+        return super.fromByteArray0Template(Int256Mask.class, a, offset, (Int256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -847,0 +854,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n+        return super.fromByteBuffer0Template(Int256Mask.class, bb, offset, (Int256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -876,0 +890,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n+        super.intoByteArray0Template(Int256Mask.class, a, offset, (Int256Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n+        super.intoByteBuffer0Template(Int256Mask.class, bb, offset, (Int256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -856,0 +856,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n+        return super.fromByteArray0Template(Int512Mask.class, a, offset, (Int512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -863,0 +870,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n+        return super.fromByteBuffer0Template(Int512Mask.class, bb, offset, (Int512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -892,0 +906,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n+        super.intoByteArray0Template(Int512Mask.class, a, offset, (Int512Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n+        super.intoByteBuffer0Template(Int512Mask.class, bb, offset, (Int512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -828,0 +828,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n+        return super.fromByteArray0Template(Int64Mask.class, a, offset, (Int64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -835,0 +842,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n+        return super.fromByteBuffer0Template(Int64Mask.class, bb, offset, (Int64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -864,0 +878,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n+        super.intoByteArray0Template(Int64Mask.class, a, offset, (Int64Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n+        super.intoByteBuffer0Template(Int64Mask.class, bb, offset, (Int64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -837,0 +837,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n+        return super.fromByteArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -844,0 +851,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n+        return super.fromByteBuffer0Template(IntMaxMask.class, bb, offset, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -873,0 +887,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n+        super.intoByteArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n+        super.intoByteBuffer0Template(IntMaxMask.class, bb, offset, (IntMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2849,3 +2849,1 @@\n-            IntVector zero = vsp.zero();\n-            IntVector v = zero.fromByteArray0(a, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n@@ -3120,3 +3118,1 @@\n-            IntVector zero = vsp.zero();\n-            IntVector v = zero.fromByteBuffer0(bb, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n@@ -3322,1 +3318,0 @@\n-            \/\/ FIXME: optimize\n@@ -3325,3 +3320,1 @@\n-            ByteBuffer wb = wrapper(a, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+            maybeSwap(bo).intoByteArray0(a, offset, m);\n@@ -3358,1 +3351,0 @@\n-            \/\/ FIXME: optimize\n@@ -3364,3 +3356,1 @@\n-            ByteBuffer wb = wrapper(bb, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n@@ -3475,0 +3465,19 @@\n+    abstract\n+    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    IntVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        IntSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                return s.ldOp(wb, off, vm,\n+                        (wb_, o, i) -> wb_.getInt(o + i * 4));\n+            });\n+    }\n+\n@@ -3491,0 +3500,18 @@\n+    abstract\n+    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    IntVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        IntSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                bb, offset, m, vsp,\n+                (buf, off, s, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off, vm,\n+                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                });\n+    }\n+\n@@ -3579,0 +3606,19 @@\n+    abstract\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        IntSpecies vsp = vspecies();\n+        m.check(vsp);\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                v.stOp(wb, off, vm,\n+                        (tb_, o, i, e) -> tb_.putInt(o + i * 4, e));\n+            });\n+    }\n+\n@@ -3593,0 +3639,18 @@\n+    abstract\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        IntSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m, bb, offset,\n+                (buf, off, v, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off, vm,\n+                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                });\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":78,"deletions":14,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -818,0 +818,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n+        return super.fromByteArray0Template(Long128Mask.class, a, offset, (Long128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -825,0 +832,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n+        return super.fromByteBuffer0Template(Long128Mask.class, bb, offset, (Long128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -854,0 +868,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n+        super.intoByteArray0Template(Long128Mask.class, a, offset, (Long128Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n+        super.intoByteBuffer0Template(Long128Mask.class, bb, offset, (Long128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -822,0 +822,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n+        return super.fromByteArray0Template(Long256Mask.class, a, offset, (Long256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -829,0 +836,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n+        return super.fromByteBuffer0Template(Long256Mask.class, bb, offset, (Long256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -858,0 +872,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n+        super.intoByteArray0Template(Long256Mask.class, a, offset, (Long256Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n+        super.intoByteBuffer0Template(Long256Mask.class, bb, offset, (Long256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -830,0 +830,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n+        return super.fromByteArray0Template(Long512Mask.class, a, offset, (Long512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -837,0 +844,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n+        return super.fromByteBuffer0Template(Long512Mask.class, bb, offset, (Long512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -866,0 +880,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n+        super.intoByteArray0Template(Long512Mask.class, a, offset, (Long512Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n+        super.intoByteBuffer0Template(Long512Mask.class, bb, offset, (Long512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -816,0 +816,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n+        return super.fromByteArray0Template(Long64Mask.class, a, offset, (Long64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -823,0 +830,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n+        return super.fromByteBuffer0Template(Long64Mask.class, bb, offset, (Long64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -852,0 +866,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n+        super.intoByteArray0Template(Long64Mask.class, a, offset, (Long64Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n+        super.intoByteBuffer0Template(Long64Mask.class, bb, offset, (Long64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -816,0 +816,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n+        return super.fromByteArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -823,0 +830,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n+        return super.fromByteBuffer0Template(LongMaxMask.class, bb, offset, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -852,0 +866,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n+        super.intoByteArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n+        super.intoByteBuffer0Template(LongMaxMask.class, bb, offset, (LongMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2710,3 +2710,1 @@\n-            LongVector zero = vsp.zero();\n-            LongVector v = zero.fromByteArray0(a, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n@@ -2999,3 +2997,1 @@\n-            LongVector zero = vsp.zero();\n-            LongVector v = zero.fromByteBuffer0(bb, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n@@ -3220,1 +3216,0 @@\n-            \/\/ FIXME: optimize\n@@ -3223,3 +3218,1 @@\n-            ByteBuffer wb = wrapper(a, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+            maybeSwap(bo).intoByteArray0(a, offset, m);\n@@ -3256,1 +3249,0 @@\n-            \/\/ FIXME: optimize\n@@ -3262,3 +3254,1 @@\n-            ByteBuffer wb = wrapper(bb, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n@@ -3391,0 +3381,19 @@\n+    abstract\n+    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    LongVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        LongSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                return s.ldOp(wb, off, vm,\n+                        (wb_, o, i) -> wb_.getLong(o + i * 8));\n+            });\n+    }\n+\n@@ -3407,0 +3416,18 @@\n+    abstract\n+    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    LongVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        LongSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                bb, offset, m, vsp,\n+                (buf, off, s, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off, vm,\n+                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                });\n+    }\n+\n@@ -3514,0 +3541,19 @@\n+    abstract\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        LongSpecies vsp = vspecies();\n+        m.check(vsp);\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                v.stOp(wb, off, vm,\n+                        (tb_, o, i, e) -> tb_.putLong(o + i * 8, e));\n+            });\n+    }\n+\n@@ -3528,0 +3574,18 @@\n+    abstract\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        LongSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m, bb, offset,\n+                (buf, off, v, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off, vm,\n+                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                });\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":78,"deletions":14,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -847,0 +847,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n+        return super.fromByteArray0Template(Short128Mask.class, a, offset, (Short128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -854,0 +861,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n+        return super.fromByteBuffer0Template(Short128Mask.class, bb, offset, (Short128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -877,0 +891,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n+        super.intoByteArray0Template(Short128Mask.class, a, offset, (Short128Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n+        super.intoByteBuffer0Template(Short128Mask.class, bb, offset, (Short128Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -863,0 +863,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n+        return super.fromByteArray0Template(Short256Mask.class, a, offset, (Short256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -870,0 +877,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n+        return super.fromByteBuffer0Template(Short256Mask.class, bb, offset, (Short256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -893,0 +907,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n+        super.intoByteArray0Template(Short256Mask.class, a, offset, (Short256Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n+        super.intoByteBuffer0Template(Short256Mask.class, bb, offset, (Short256Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -895,0 +895,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n+        return super.fromByteArray0Template(Short512Mask.class, a, offset, (Short512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -902,0 +909,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n+        return super.fromByteBuffer0Template(Short512Mask.class, bb, offset, (Short512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -925,0 +939,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n+        super.intoByteArray0Template(Short512Mask.class, a, offset, (Short512Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n+        super.intoByteBuffer0Template(Short512Mask.class, bb, offset, (Short512Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -839,0 +839,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n+        return super.fromByteArray0Template(Short64Mask.class, a, offset, (Short64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -846,0 +853,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n+        return super.fromByteBuffer0Template(Short64Mask.class, bb, offset, (Short64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -869,0 +883,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n+        super.intoByteArray0Template(Short64Mask.class, a, offset, (Short64Mask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n+        super.intoByteBuffer0Template(Short64Mask.class, bb, offset, (Short64Mask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -833,0 +833,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n+        return super.fromByteArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -840,0 +847,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n+        return super.fromByteBuffer0Template(ShortMaxMask.class, bb, offset, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -863,0 +877,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n+        super.intoByteArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n+        super.intoByteBuffer0Template(ShortMaxMask.class, bb, offset, (ShortMaxMask) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2857,3 +2857,1 @@\n-            ShortVector zero = vsp.zero();\n-            ShortVector v = zero.fromByteArray0(a, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n@@ -3255,3 +3253,1 @@\n-            ShortVector zero = vsp.zero();\n-            ShortVector v = zero.fromByteBuffer0(bb, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n@@ -3592,1 +3588,0 @@\n-            \/\/ FIXME: optimize\n@@ -3595,3 +3590,1 @@\n-            ByteBuffer wb = wrapper(a, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+            maybeSwap(bo).intoByteArray0(a, offset, m);\n@@ -3628,1 +3621,0 @@\n-            \/\/ FIXME: optimize\n@@ -3634,3 +3626,1 @@\n-            ByteBuffer wb = wrapper(bb, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n@@ -3743,0 +3733,19 @@\n+    abstract\n+    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    ShortVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        ShortSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                return s.ldOp(wb, off, vm,\n+                        (wb_, o, i) -> wb_.getShort(o + i * 2));\n+            });\n+    }\n+\n@@ -3759,0 +3768,18 @@\n+    abstract\n+    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    ShortVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        ShortSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                bb, offset, m, vsp,\n+                (buf, off, s, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off, vm,\n+                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                });\n+    }\n+\n@@ -3814,0 +3841,19 @@\n+    abstract\n+    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        ShortSpecies vsp = vspecies();\n+        m.check(vsp);\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                v.stOp(wb, off, vm,\n+                        (tb_, o, i, e) -> tb_.putShort(o + i * 2, e));\n+            });\n+    }\n+\n@@ -3828,0 +3874,18 @@\n+    abstract\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        ShortSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m, bb, offset,\n+                (buf, off, v, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off, vm,\n+                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                });\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":78,"deletions":14,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -3343,3 +3343,1 @@\n-            $abstractvectortype$ zero = vsp.zero();\n-            $abstractvectortype$ v = zero.fromByteArray0(a, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n@@ -3979,3 +3977,1 @@\n-            $abstractvectortype$ zero = vsp.zero();\n-            $abstractvectortype$ v = zero.fromByteBuffer0(bb, offset);\n-            return zero.blend(v.maybeSwap(bo), m);\n+            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n@@ -4555,1 +4551,0 @@\n-            \/\/ FIXME: optimize\n@@ -4558,3 +4553,1 @@\n-            ByteBuffer wb = wrapper(a, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+            maybeSwap(bo).intoByteArray0(a, offset, m);\n@@ -4591,1 +4584,0 @@\n-            \/\/ FIXME: optimize\n@@ -4597,3 +4589,1 @@\n-            ByteBuffer wb = wrapper(bb, bo);\n-            this.stOp(wb, offset, m,\n-                    (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n@@ -4801,0 +4791,19 @@\n+    abstract\n+    $abstractvectortype$ fromByteArray0(byte[] a, int offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $abstractvectortype$ fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        $Type$Species vsp = vspecies();\n+        m.check(vsp);\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset), m,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                return s.ldOp(wb, off, vm,\n+                        (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+            });\n+    }\n+\n@@ -4817,0 +4826,18 @@\n+    abstract\n+    $abstractvectortype$ fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $abstractvectortype$ fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        $Type$Species vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                bb, offset, m, vsp,\n+                (buf, off, s, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off, vm,\n+                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                });\n+    }\n+\n@@ -4952,0 +4979,19 @@\n+    abstract\n+    void intoByteArray0(byte[] a, int offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+        $Type$Species vsp = vspecies();\n+        m.check(vsp);\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, byteArrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm) -> {\n+                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n+                v.stOp(wb, off, vm,\n+                        (tb_, o, i, e) -> tb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+            });\n+    }\n+\n@@ -4966,0 +5012,18 @@\n+    abstract\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+        $Type$Species vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m, bb, offset,\n+                (buf, off, v, vm) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off, vm,\n+                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                });\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":78,"deletions":14,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -1146,0 +1146,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromByteArray0(byte[] a, int offset, VectorMask<$Boxtype$> m) {\n+        return super.fromByteArray0Template($masktype$.class, a, offset, ($masktype$) m);  \/\/ specialize\n+    }\n+\n@@ -1153,0 +1160,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<$Boxtype$> m) {\n+        return super.fromByteBuffer0Template($masktype$.class, bb, offset, ($masktype$) m);  \/\/ specialize\n+    }\n+\n@@ -1192,0 +1206,14 @@\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteArray0(byte[] a, int offset, VectorMask<$Boxtype$> m) {\n+        super.intoByteArray0Template($masktype$.class, a, offset, ($masktype$) m);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<$Boxtype$> m) {\n+        super.intoByteBuffer0Template($masktype$.class, bb, offset, ($masktype$) m);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"}]}