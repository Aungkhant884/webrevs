{"files":[{"patch":"@@ -492,0 +492,20 @@\n+    case VECTOR_OP_CTZ: {\n+     switch (bt) {\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:   return Op_CountTrailingZerosI;\n+        case T_LONG:  return Op_CountTrailingZerosL;\n+        default: fatal(\"CTZ: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_CLZ: {\n+     switch (bt) {\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:   return Op_CountLeadingZerosI;\n+        case T_LONG:  return Op_CountLeadingZerosL;\n+        default: fatal(\"CLZ: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+    VECTOR_OP_CTZ     = 29,\n+    VECTOR_OP_CLZ     = 30,\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+    public static final int VECTOR_OP_CTZ  = 29;\n+    public static final int VECTOR_OP_CLZ  = 30;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -661,0 +661,6 @@\n+            case VECTOR_OP_CTZ: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (byte) numberOfTrailingZeros(a));\n+\n+            case VECTOR_OP_CLZ: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (byte) numberOfLeadingZeros(a));\n+\n@@ -1791,0 +1797,8 @@\n+    static int numberOfTrailingZeros(byte a) {\n+        return a != 0 ? Integer.numberOfTrailingZeros(a) : 8;\n+    }\n+\n+    static int numberOfLeadingZeros(byte a) {\n+        return a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -637,0 +637,2 @@\n+\n+\n@@ -1629,0 +1631,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -637,0 +637,2 @@\n+\n+\n@@ -1637,0 +1639,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -661,0 +661,6 @@\n+            case VECTOR_OP_CTZ: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.numberOfTrailingZeros(a));\n+\n+            case VECTOR_OP_CLZ: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.numberOfLeadingZeros(a));\n+\n@@ -1787,0 +1793,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -619,0 +619,6 @@\n+            case VECTOR_OP_CTZ: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.numberOfTrailingZeros(a));\n+\n+            case VECTOR_OP_CLZ: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.numberOfLeadingZeros(a));\n+\n@@ -1700,0 +1706,2 @@\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -661,0 +661,6 @@\n+            case VECTOR_OP_CTZ: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) numberOfTrailingZeros(a));\n+\n+            case VECTOR_OP_CLZ: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) numberOfLeadingZeros(a));\n+\n@@ -1791,0 +1797,8 @@\n+    static int numberOfTrailingZeros(short a) {\n+        return a != 0 ? Integer.numberOfTrailingZeros(a) : 16;\n+    }\n+\n+    static int numberOfLeadingZeros(short a) {\n+        return a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -455,0 +455,4 @@\n+    \/** Produce {@code numberOfTrailingZeros(a)} *\/\n+    public static final Unary CTZ = unary(\"CTZ\", \"numberOfTrailingZeros\", VectorSupport.VECTOR_OP_CTZ, VO_NOFP);\n+    \/** Produce {@code numberOfLeadingZeros(a)} *\/\n+    public static final Unary CLZ = unary(\"CLZ\", \"numberOfLeadingZeros\", VectorSupport.VECTOR_OP_CLZ, VO_NOFP);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -693,0 +693,18 @@\n+#if[!FP]\n+            case VECTOR_OP_CTZ: return (v0, m) ->\n+#if[intOrLong]\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.numberOfTrailingZeros(a));\n+#else[intOrLong]\n+                    v0.uOp(m, (i, a) -> ($type$) numberOfTrailingZeros(a));\n+#end[intOrLong]\n+#end[!FP]\n+\n+#if[!FP]\n+            case VECTOR_OP_CLZ: return (v0, m) ->\n+#if[intOrLong]\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.numberOfLeadingZeros(a));\n+#else[intOrLong]\n+                    v0.uOp(m, (i, a) -> ($type$) numberOfLeadingZeros(a));\n+#end[intOrLong]\n+#end[!FP]\n+\n@@ -2046,0 +2064,24 @@\n+#if[!FP]\n+#if[!intOrLong]\n+    static int numberOfTrailingZeros($type$ a) {\n+#if[short]\n+        return a != 0 ? Integer.numberOfTrailingZeros(a) : 16;\n+#else[short]\n+        return a != 0 ? Integer.numberOfTrailingZeros(a) : 8;\n+#end[short]\n+    }\n+#end[!intOrLong]\n+#end[!FP]\n+\n+#if[!FP]\n+#if[!intOrLong]\n+    static int numberOfLeadingZeros($type$ a) {\n+#if[short]\n+        return a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0;\n+#else[short]\n+        return a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0;\n+#end[short]\n+    }\n+#end[!intOrLong]\n+#end[!FP]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1213,0 +1213,8 @@\n+    static byte CTZ_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte CLZ_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n@@ -5313,0 +5321,86 @@\n+\n+    static byte CTZ(byte a) {\n+        return (byte)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void CTZByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void CTZMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static byte CLZ(byte a) {\n+        return (byte)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void CLZByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void CLZMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1213,0 +1213,8 @@\n+    static byte CTZ_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte CLZ_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n@@ -5313,0 +5321,86 @@\n+\n+    static byte CTZ(byte a) {\n+        return (byte)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void CTZByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void CTZMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static byte CLZ(byte a) {\n+        return (byte)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void CLZByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void CLZMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1213,0 +1213,8 @@\n+    static byte CTZ_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte CLZ_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n@@ -5313,0 +5321,86 @@\n+\n+    static byte CTZ(byte a) {\n+        return (byte)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void CTZByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void CTZMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static byte CLZ(byte a) {\n+        return (byte)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void CLZByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void CLZMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1213,0 +1213,8 @@\n+    static byte CTZ_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte CLZ_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n@@ -5313,0 +5321,86 @@\n+\n+    static byte CTZ(byte a) {\n+        return (byte)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void CTZByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void CTZMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static byte CLZ(byte a) {\n+        return (byte)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void CLZByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void CLZMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1218,0 +1218,8 @@\n+    static byte CTZ_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte CLZ_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n@@ -5318,0 +5326,86 @@\n+\n+    static byte CTZ(byte a) {\n+        return (byte)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void CTZByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void CTZMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::CTZ);\n+    }\n+\n+\n+\n+    static byte CLZ(byte a) {\n+        return (byte)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void CLZByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void CLZMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1325,1 +1325,0 @@\n-\n@@ -4673,0 +4672,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1325,1 +1325,0 @@\n-\n@@ -4673,0 +4672,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1325,1 +1325,0 @@\n-\n@@ -4673,0 +4672,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1325,1 +1325,0 @@\n-\n@@ -4673,0 +4672,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1330,1 +1330,0 @@\n-\n@@ -4678,0 +4677,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1335,1 +1335,0 @@\n-\n@@ -4641,0 +4640,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1335,1 +1335,0 @@\n-\n@@ -4641,0 +4640,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1335,1 +1335,0 @@\n-\n@@ -4641,0 +4640,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1335,1 +1335,0 @@\n-\n@@ -4638,0 +4637,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1340,1 +1340,0 @@\n-\n@@ -4646,0 +4645,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1173,0 +1173,8 @@\n+    static int CTZ_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int CLZ_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n@@ -5278,0 +5286,86 @@\n+\n+    static int CTZ(int a) {\n+        return (int)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void CTZInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void CTZMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static int CLZ(int a) {\n+        return (int)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void CLZInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void CLZMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1173,0 +1173,8 @@\n+    static int CTZ_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int CLZ_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n@@ -5278,0 +5286,86 @@\n+\n+    static int CTZ(int a) {\n+        return (int)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void CTZInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void CTZMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static int CLZ(int a) {\n+        return (int)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void CLZInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void CLZMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1173,0 +1173,8 @@\n+    static int CTZ_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int CLZ_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n@@ -5278,0 +5286,86 @@\n+\n+    static int CTZ(int a) {\n+        return (int)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void CTZInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void CTZMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static int CLZ(int a) {\n+        return (int)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void CLZInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void CLZMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1173,0 +1173,8 @@\n+    static int CTZ_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int CLZ_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n@@ -5278,0 +5286,86 @@\n+\n+    static int CTZ(int a) {\n+        return (int)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void CTZInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void CTZMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static int CLZ(int a) {\n+        return (int)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void CLZInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void CLZMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1178,0 +1178,8 @@\n+    static int CTZ_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int CLZ_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n@@ -5283,0 +5291,86 @@\n+\n+    static int CTZ(int a) {\n+        return (int)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void CTZIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void CTZMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::CTZ);\n+    }\n+\n+\n+\n+    static int CLZ(int a) {\n+        return (int)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void CLZIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void CLZMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1195,0 +1195,8 @@\n+    static long CTZ_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long CLZ_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n@@ -5228,0 +5236,86 @@\n+\n+    static long CTZ(long a) {\n+        return (long)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void CTZLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void CTZMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static long CLZ(long a) {\n+        return (long)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void CLZLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void CLZMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1195,0 +1195,8 @@\n+    static long CTZ_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long CLZ_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n@@ -5228,0 +5236,86 @@\n+\n+    static long CTZ(long a) {\n+        return (long)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void CTZLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void CTZMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static long CLZ(long a) {\n+        return (long)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void CLZLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void CLZMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1195,0 +1195,8 @@\n+    static long CTZ_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long CLZ_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n@@ -5228,0 +5236,86 @@\n+\n+    static long CTZ(long a) {\n+        return (long)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void CTZLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void CTZMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static long CLZ(long a) {\n+        return (long)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void CLZLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void CLZMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1195,0 +1195,8 @@\n+    static long CTZ_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long CLZ_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n@@ -5228,0 +5236,86 @@\n+\n+    static long CTZ(long a) {\n+        return (long)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void CTZLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void CTZMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static long CLZ(long a) {\n+        return (long)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void CLZLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void CLZMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1200,0 +1200,8 @@\n+    static long CTZ_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long CLZ_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n@@ -5233,0 +5241,86 @@\n+\n+    static long CTZ(long a) {\n+        return (long)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void CTZLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void CTZMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::CTZ);\n+    }\n+\n+\n+\n+    static long CLZ(long a) {\n+        return (long)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void CLZLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void CLZMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1203,0 +1203,8 @@\n+    static short CTZ_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short CLZ_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n@@ -5303,0 +5311,86 @@\n+\n+    static short CTZ(short a) {\n+        return (short)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CTZShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void CTZMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static short CLZ(short a) {\n+        return (short)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CLZShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void CLZMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1203,0 +1203,8 @@\n+    static short CTZ_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short CLZ_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n@@ -5303,0 +5311,86 @@\n+\n+    static short CTZ(short a) {\n+        return (short)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CTZShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void CTZMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static short CLZ(short a) {\n+        return (short)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CLZShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void CLZMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1203,0 +1203,8 @@\n+    static short CTZ_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short CLZ_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n@@ -5303,0 +5311,86 @@\n+\n+    static short CTZ(short a) {\n+        return (short)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CTZShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void CTZMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static short CLZ(short a) {\n+        return (short)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CLZShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void CLZMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1203,0 +1203,8 @@\n+    static short CTZ_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short CLZ_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n@@ -5303,0 +5311,86 @@\n+\n+    static short CTZ(short a) {\n+        return (short)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CTZShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void CTZMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::CTZ);\n+    }\n+\n+\n+\n+    static short CLZ(short a) {\n+        return (short)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CLZShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void CLZMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1208,0 +1208,8 @@\n+    static short CTZ_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short CLZ_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n@@ -5308,0 +5316,86 @@\n+\n+    static short CTZ(short a) {\n+        return (short)(CTZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CTZShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::CTZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void CTZMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::CTZ);\n+    }\n+\n+\n+\n+    static short CLZ(short a) {\n+        return (short)(CLZ_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CLZShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::CLZ);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void CLZMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::CLZ);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -555,0 +555,2 @@\n+gen_unary_alu_op \"CTZ\" \"CTZ_scalar(a)\" \"BITWISE\"\n+gen_unary_alu_op \"CLZ\" \"CLZ_scalar(a)\" \"BITWISE\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -150,0 +150,25 @@\n+\n+    static $type$ CTZ_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfTrailingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+#else[short]\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ CLZ_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfLeadingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+#else[short]\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-header.template","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1459,1 +1459,0 @@\n-#end[BITWISE]\n@@ -1461,0 +1460,25 @@\n+    static $type$ CTZ_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfTrailingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+#else[short]\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ CLZ_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfLeadingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+#else[short]\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+#end[BITWISE]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte128Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte256Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte512Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte64Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteMaxVector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -132,0 +132,9 @@\n+    static byte CTZ_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte CLZ_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n+\n@@ -1701,0 +1710,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(CTZ_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(CTZ_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(CLZ_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(CLZ_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteScalar.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -1667,0 +1667,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double128Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1667,0 +1667,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double256Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1667,0 +1667,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double512Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1667,0 +1667,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double64Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1667,0 +1667,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleMaxVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1261,0 +1261,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleScalar.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1667,0 +1667,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float128Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1667,0 +1667,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float256Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1667,0 +1667,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float512Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1667,0 +1667,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float64Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1667,0 +1667,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatMaxVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1261,0 +1261,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatScalar.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int128Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int256Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int512Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int64Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -132,0 +132,9 @@\n+    static int CTZ_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int CLZ_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n+\n@@ -1701,0 +1710,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(CTZ_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(CTZ_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(CLZ_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(CLZ_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long256Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long512Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long64Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -132,0 +132,9 @@\n+    static long CTZ_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long CLZ_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n+\n@@ -1701,0 +1710,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(CTZ_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(CTZ_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(CLZ_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(CLZ_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short128Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short256Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short512Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short64Vector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2143,0 +2143,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CTZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CLZ, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortMaxVector.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -132,0 +132,9 @@\n+    static short CTZ_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short CLZ_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n+\n@@ -1701,0 +1710,72 @@\n+\n+\n+    @Benchmark\n+    public void CTZ(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(CTZ_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CTZMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(CTZ_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZ(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(CLZ_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void CLZMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(CLZ_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortScalar.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"}]}