{"files":[{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public Byte128Vector compress(VectorMask<Byte> m) {\n+        return (Byte128Vector)\n+            super.compressTemplate(Byte128Mask.class,\n+                                   (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte128Vector compress(VectorMask<Byte> m, Vector<Byte> v) {\n+        return (Byte128Vector)\n+            super.compressTemplate(Byte128Mask.class,\n+                                   (Byte128Mask) m, (Byte128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte128Vector expand(VectorMask<Byte> m) {\n+        return (Byte128Vector)\n+            super.expandTemplate(Byte128Mask.class,\n+                                   (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte128Vector expand(VectorMask<Byte> m, Vector<Byte> v) {\n+        return (Byte128Vector)\n+            super.expandTemplate(Byte128Mask.class,\n+                                   (Byte128Mask) m, (Byte128Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public Byte256Vector compress(VectorMask<Byte> m) {\n+        return (Byte256Vector)\n+            super.compressTemplate(Byte256Mask.class,\n+                                   (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte256Vector compress(VectorMask<Byte> m, Vector<Byte> v) {\n+        return (Byte256Vector)\n+            super.compressTemplate(Byte256Mask.class,\n+                                   (Byte256Mask) m, (Byte256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte256Vector expand(VectorMask<Byte> m) {\n+        return (Byte256Vector)\n+            super.expandTemplate(Byte256Mask.class,\n+                                   (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte256Vector expand(VectorMask<Byte> m, Vector<Byte> v) {\n+        return (Byte256Vector)\n+            super.expandTemplate(Byte256Mask.class,\n+                                   (Byte256Mask) m, (Byte256Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public Byte512Vector compress(VectorMask<Byte> m) {\n+        return (Byte512Vector)\n+            super.compressTemplate(Byte512Mask.class,\n+                                   (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte512Vector compress(VectorMask<Byte> m, Vector<Byte> v) {\n+        return (Byte512Vector)\n+            super.compressTemplate(Byte512Mask.class,\n+                                   (Byte512Mask) m, (Byte512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte512Vector expand(VectorMask<Byte> m) {\n+        return (Byte512Vector)\n+            super.expandTemplate(Byte512Mask.class,\n+                                   (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte512Vector expand(VectorMask<Byte> m, Vector<Byte> v) {\n+        return (Byte512Vector)\n+            super.expandTemplate(Byte512Mask.class,\n+                                   (Byte512Mask) m, (Byte512Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public Byte64Vector compress(VectorMask<Byte> m) {\n+        return (Byte64Vector)\n+            super.compressTemplate(Byte64Mask.class,\n+                                   (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte64Vector compress(VectorMask<Byte> m, Vector<Byte> v) {\n+        return (Byte64Vector)\n+            super.compressTemplate(Byte64Mask.class,\n+                                   (Byte64Mask) m, (Byte64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte64Vector expand(VectorMask<Byte> m) {\n+        return (Byte64Vector)\n+            super.expandTemplate(Byte64Mask.class,\n+                                   (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte64Vector expand(VectorMask<Byte> m, Vector<Byte> v) {\n+        return (Byte64Vector)\n+            super.expandTemplate(Byte64Mask.class,\n+                                   (Byte64Mask) m, (Byte64Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector compress(VectorMask<Byte> m) {\n+        return (ByteMaxVector)\n+            super.compressTemplate(ByteMaxMask.class,\n+                                   (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector compress(VectorMask<Byte> m, Vector<Byte> v) {\n+        return (ByteMaxVector)\n+            super.compressTemplate(ByteMaxMask.class,\n+                                   (ByteMaxMask) m, (ByteMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector expand(VectorMask<Byte> m) {\n+        return (ByteMaxVector)\n+            super.expandTemplate(ByteMaxMask.class,\n+                                   (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector expand(VectorMask<Byte> m, Vector<Byte> v) {\n+        return (ByteMaxVector)\n+            super.expandTemplate(ByteMaxMask.class,\n+                                   (ByteMaxMask) m, (ByteMaxVector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2361,0 +2361,90 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector compress(VectorMask<Byte> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    ByteVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      ByteVector v = ByteVector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector compress(VectorMask<Byte> m, Vector<Byte> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    ByteVector compressTemplate(Class<M> masktype, M m, ByteVector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector expand(VectorMask<Byte> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    ByteVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      ByteVector v = ByteVector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector expand(VectorMask<Byte> m, Vector<Byte> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    ByteVector expandTemplate(Class<M> masktype, M m, ByteVector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -456,0 +456,32 @@\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double128Vector compress(VectorMask<Double> m) {\n+        return (Double128Vector)\n+            super.compressTemplate(Double128Mask.class,\n+                                   (Double128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double128Vector compress(VectorMask<Double> m, Vector<Double> v) {\n+        return (Double128Vector)\n+            super.compressTemplate(Double128Mask.class,\n+                                   (Double128Mask) m, (Double128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double128Vector expand(VectorMask<Double> m) {\n+        return (Double128Vector)\n+            super.expandTemplate(Double128Mask.class,\n+                                   (Double128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double128Vector expand(VectorMask<Double> m, Vector<Double> v) {\n+        return (Double128Vector)\n+            super.expandTemplate(Double128Mask.class,\n+                                   (Double128Mask) m, (Double128Vector) v);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -458,0 +458,32 @@\n+    @Override\n+    @ForceInline\n+    public Double256Vector compress(VectorMask<Double> m) {\n+        return (Double256Vector)\n+            super.compressTemplate(Double256Mask.class,\n+                                   (Double256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double256Vector compress(VectorMask<Double> m, Vector<Double> v) {\n+        return (Double256Vector)\n+            super.compressTemplate(Double256Mask.class,\n+                                   (Double256Mask) m, (Double256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double256Vector expand(VectorMask<Double> m) {\n+        return (Double256Vector)\n+            super.expandTemplate(Double256Mask.class,\n+                                   (Double256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double256Vector expand(VectorMask<Double> m, Vector<Double> v) {\n+        return (Double256Vector)\n+            super.expandTemplate(Double256Mask.class,\n+                                   (Double256Mask) m, (Double256Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -458,0 +458,32 @@\n+    @Override\n+    @ForceInline\n+    public Double512Vector compress(VectorMask<Double> m) {\n+        return (Double512Vector)\n+            super.compressTemplate(Double512Mask.class,\n+                                   (Double512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double512Vector compress(VectorMask<Double> m, Vector<Double> v) {\n+        return (Double512Vector)\n+            super.compressTemplate(Double512Mask.class,\n+                                   (Double512Mask) m, (Double512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double512Vector expand(VectorMask<Double> m) {\n+        return (Double512Vector)\n+            super.expandTemplate(Double512Mask.class,\n+                                   (Double512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double512Vector expand(VectorMask<Double> m, Vector<Double> v) {\n+        return (Double512Vector)\n+            super.expandTemplate(Double512Mask.class,\n+                                   (Double512Mask) m, (Double512Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -458,0 +458,32 @@\n+    @Override\n+    @ForceInline\n+    public Double64Vector compress(VectorMask<Double> m) {\n+        return (Double64Vector)\n+            super.compressTemplate(Double64Mask.class,\n+                                   (Double64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double64Vector compress(VectorMask<Double> m, Vector<Double> v) {\n+        return (Double64Vector)\n+            super.compressTemplate(Double64Mask.class,\n+                                   (Double64Mask) m, (Double64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double64Vector expand(VectorMask<Double> m) {\n+        return (Double64Vector)\n+            super.expandTemplate(Double64Mask.class,\n+                                   (Double64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double64Vector expand(VectorMask<Double> m, Vector<Double> v) {\n+        return (Double64Vector)\n+            super.expandTemplate(Double64Mask.class,\n+                                   (Double64Mask) m, (Double64Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -458,0 +458,32 @@\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector compress(VectorMask<Double> m) {\n+        return (DoubleMaxVector)\n+            super.compressTemplate(DoubleMaxMask.class,\n+                                   (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector compress(VectorMask<Double> m, Vector<Double> v) {\n+        return (DoubleMaxVector)\n+            super.compressTemplate(DoubleMaxMask.class,\n+                                   (DoubleMaxMask) m, (DoubleMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector expand(VectorMask<Double> m) {\n+        return (DoubleMaxVector)\n+            super.expandTemplate(DoubleMaxMask.class,\n+                                   (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector expand(VectorMask<Double> m, Vector<Double> v) {\n+        return (DoubleMaxVector)\n+            super.expandTemplate(DoubleMaxMask.class,\n+                                   (DoubleMaxMask) m, (DoubleMaxVector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2207,0 +2207,90 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    DoubleVector compress(VectorMask<Double> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    DoubleVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      DoubleVector v = DoubleVector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    DoubleVector compress(VectorMask<Double> m, Vector<Double> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    DoubleVector compressTemplate(Class<M> masktype, M m, DoubleVector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    DoubleVector expand(VectorMask<Double> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    DoubleVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      DoubleVector v = DoubleVector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    DoubleVector expand(VectorMask<Double> m, Vector<Double> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    DoubleVector expandTemplate(Class<M> masktype, M m, DoubleVector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -460,0 +460,32 @@\n+    public Float128Vector compress(VectorMask<Float> m) {\n+        return (Float128Vector)\n+            super.compressTemplate(Float128Mask.class,\n+                                   (Float128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float128Vector compress(VectorMask<Float> m, Vector<Float> v) {\n+        return (Float128Vector)\n+            super.compressTemplate(Float128Mask.class,\n+                                   (Float128Mask) m, (Float128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float128Vector expand(VectorMask<Float> m) {\n+        return (Float128Vector)\n+            super.expandTemplate(Float128Mask.class,\n+                                   (Float128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float128Vector expand(VectorMask<Float> m, Vector<Float> v) {\n+        return (Float128Vector)\n+            super.expandTemplate(Float128Mask.class,\n+                                   (Float128Mask) m, (Float128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -458,0 +458,32 @@\n+    @Override\n+    @ForceInline\n+    public Float256Vector compress(VectorMask<Float> m) {\n+        return (Float256Vector)\n+            super.compressTemplate(Float256Mask.class,\n+                                   (Float256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float256Vector compress(VectorMask<Float> m, Vector<Float> v) {\n+        return (Float256Vector)\n+            super.compressTemplate(Float256Mask.class,\n+                                   (Float256Mask) m, (Float256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float256Vector expand(VectorMask<Float> m) {\n+        return (Float256Vector)\n+            super.expandTemplate(Float256Mask.class,\n+                                   (Float256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float256Vector expand(VectorMask<Float> m, Vector<Float> v) {\n+        return (Float256Vector)\n+            super.expandTemplate(Float256Mask.class,\n+                                   (Float256Mask) m, (Float256Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -458,0 +458,32 @@\n+    @Override\n+    @ForceInline\n+    public Float512Vector compress(VectorMask<Float> m) {\n+        return (Float512Vector)\n+            super.compressTemplate(Float512Mask.class,\n+                                   (Float512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float512Vector compress(VectorMask<Float> m, Vector<Float> v) {\n+        return (Float512Vector)\n+            super.compressTemplate(Float512Mask.class,\n+                                   (Float512Mask) m, (Float512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float512Vector expand(VectorMask<Float> m) {\n+        return (Float512Vector)\n+            super.expandTemplate(Float512Mask.class,\n+                                   (Float512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float512Vector expand(VectorMask<Float> m, Vector<Float> v) {\n+        return (Float512Vector)\n+            super.expandTemplate(Float512Mask.class,\n+                                   (Float512Mask) m, (Float512Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -458,0 +458,32 @@\n+    @Override\n+    @ForceInline\n+    public Float64Vector compress(VectorMask<Float> m) {\n+        return (Float64Vector)\n+            super.compressTemplate(Float64Mask.class,\n+                                   (Float64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float64Vector compress(VectorMask<Float> m, Vector<Float> v) {\n+        return (Float64Vector)\n+            super.compressTemplate(Float64Mask.class,\n+                                   (Float64Mask) m, (Float64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float64Vector expand(VectorMask<Float> m) {\n+        return (Float64Vector)\n+            super.expandTemplate(Float64Mask.class,\n+                                   (Float64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float64Vector expand(VectorMask<Float> m, Vector<Float> v) {\n+        return (Float64Vector)\n+            super.expandTemplate(Float64Mask.class,\n+                                   (Float64Mask) m, (Float64Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -458,0 +458,32 @@\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector compress(VectorMask<Float> m) {\n+        return (FloatMaxVector)\n+            super.compressTemplate(FloatMaxMask.class,\n+                                   (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector compress(VectorMask<Float> m, Vector<Float> v) {\n+        return (FloatMaxVector)\n+            super.compressTemplate(FloatMaxMask.class,\n+                                   (FloatMaxMask) m, (FloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector expand(VectorMask<Float> m) {\n+        return (FloatMaxVector)\n+            super.expandTemplate(FloatMaxMask.class,\n+                                   (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector expand(VectorMask<Float> m, Vector<Float> v) {\n+        return (FloatMaxVector)\n+            super.expandTemplate(FloatMaxMask.class,\n+                                   (FloatMaxMask) m, (FloatMaxVector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2219,0 +2219,90 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    FloatVector compress(VectorMask<Float> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    FloatVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      FloatVector v = FloatVector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    FloatVector compress(VectorMask<Float> m, Vector<Float> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    FloatVector compressTemplate(Class<M> masktype, M m, FloatVector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    FloatVector expand(VectorMask<Float> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    FloatVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      FloatVector v = FloatVector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    FloatVector expand(VectorMask<Float> m, Vector<Float> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    FloatVector expandTemplate(Class<M> masktype, M m, FloatVector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public Int128Vector compress(VectorMask<Integer> m) {\n+        return (Int128Vector)\n+            super.compressTemplate(Int128Mask.class,\n+                                   (Int128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int128Vector compress(VectorMask<Integer> m, Vector<Integer> v) {\n+        return (Int128Vector)\n+            super.compressTemplate(Int128Mask.class,\n+                                   (Int128Mask) m, (Int128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int128Vector expand(VectorMask<Integer> m) {\n+        return (Int128Vector)\n+            super.expandTemplate(Int128Mask.class,\n+                                   (Int128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int128Vector expand(VectorMask<Integer> m, Vector<Integer> v) {\n+        return (Int128Vector)\n+            super.expandTemplate(Int128Mask.class,\n+                                   (Int128Mask) m, (Int128Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public Int256Vector compress(VectorMask<Integer> m) {\n+        return (Int256Vector)\n+            super.compressTemplate(Int256Mask.class,\n+                                   (Int256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int256Vector compress(VectorMask<Integer> m, Vector<Integer> v) {\n+        return (Int256Vector)\n+            super.compressTemplate(Int256Mask.class,\n+                                   (Int256Mask) m, (Int256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int256Vector expand(VectorMask<Integer> m) {\n+        return (Int256Vector)\n+            super.expandTemplate(Int256Mask.class,\n+                                   (Int256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int256Vector expand(VectorMask<Integer> m, Vector<Integer> v) {\n+        return (Int256Vector)\n+            super.expandTemplate(Int256Mask.class,\n+                                   (Int256Mask) m, (Int256Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public Int512Vector compress(VectorMask<Integer> m) {\n+        return (Int512Vector)\n+            super.compressTemplate(Int512Mask.class,\n+                                   (Int512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int512Vector compress(VectorMask<Integer> m, Vector<Integer> v) {\n+        return (Int512Vector)\n+            super.compressTemplate(Int512Mask.class,\n+                                   (Int512Mask) m, (Int512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int512Vector expand(VectorMask<Integer> m) {\n+        return (Int512Vector)\n+            super.expandTemplate(Int512Mask.class,\n+                                   (Int512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int512Vector expand(VectorMask<Integer> m, Vector<Integer> v) {\n+        return (Int512Vector)\n+            super.expandTemplate(Int512Mask.class,\n+                                   (Int512Mask) m, (Int512Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public Int64Vector compress(VectorMask<Integer> m) {\n+        return (Int64Vector)\n+            super.compressTemplate(Int64Mask.class,\n+                                   (Int64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int64Vector compress(VectorMask<Integer> m, Vector<Integer> v) {\n+        return (Int64Vector)\n+            super.compressTemplate(Int64Mask.class,\n+                                   (Int64Mask) m, (Int64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int64Vector expand(VectorMask<Integer> m) {\n+        return (Int64Vector)\n+            super.expandTemplate(Int64Mask.class,\n+                                   (Int64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int64Vector expand(VectorMask<Integer> m, Vector<Integer> v) {\n+        return (Int64Vector)\n+            super.expandTemplate(Int64Mask.class,\n+                                   (Int64Mask) m, (Int64Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public IntMaxVector compress(VectorMask<Integer> m) {\n+        return (IntMaxVector)\n+            super.compressTemplate(IntMaxMask.class,\n+                                   (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector compress(VectorMask<Integer> m, Vector<Integer> v) {\n+        return (IntMaxVector)\n+            super.compressTemplate(IntMaxMask.class,\n+                                   (IntMaxMask) m, (IntMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector expand(VectorMask<Integer> m) {\n+        return (IntMaxVector)\n+            super.expandTemplate(IntMaxMask.class,\n+                                   (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector expand(VectorMask<Integer> m, Vector<Integer> v) {\n+        return (IntMaxVector)\n+            super.expandTemplate(IntMaxMask.class,\n+                                   (IntMaxMask) m, (IntMaxVector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2360,0 +2360,90 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector compress(VectorMask<Integer> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    IntVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      IntVector v = IntVector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector compress(VectorMask<Integer> m, Vector<Integer> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    IntVector compressTemplate(Class<M> masktype, M m, IntVector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector expand(VectorMask<Integer> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    IntVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      IntVector v = IntVector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector expand(VectorMask<Integer> m, Vector<Integer> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    IntVector expandTemplate(Class<M> masktype, M m, IntVector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -461,0 +461,32 @@\n+    @Override\n+    @ForceInline\n+    public Long128Vector compress(VectorMask<Long> m) {\n+        return (Long128Vector)\n+            super.compressTemplate(Long128Mask.class,\n+                                   (Long128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long128Vector compress(VectorMask<Long> m, Vector<Long> v) {\n+        return (Long128Vector)\n+            super.compressTemplate(Long128Mask.class,\n+                                   (Long128Mask) m, (Long128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long128Vector expand(VectorMask<Long> m) {\n+        return (Long128Vector)\n+            super.expandTemplate(Long128Mask.class,\n+                                   (Long128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long128Vector expand(VectorMask<Long> m, Vector<Long> v) {\n+        return (Long128Vector)\n+            super.expandTemplate(Long128Mask.class,\n+                                   (Long128Mask) m, (Long128Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -461,0 +461,32 @@\n+    @Override\n+    @ForceInline\n+    public Long256Vector compress(VectorMask<Long> m) {\n+        return (Long256Vector)\n+            super.compressTemplate(Long256Mask.class,\n+                                   (Long256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long256Vector compress(VectorMask<Long> m, Vector<Long> v) {\n+        return (Long256Vector)\n+            super.compressTemplate(Long256Mask.class,\n+                                   (Long256Mask) m, (Long256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long256Vector expand(VectorMask<Long> m) {\n+        return (Long256Vector)\n+            super.expandTemplate(Long256Mask.class,\n+                                   (Long256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long256Vector expand(VectorMask<Long> m, Vector<Long> v) {\n+        return (Long256Vector)\n+            super.expandTemplate(Long256Mask.class,\n+                                   (Long256Mask) m, (Long256Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -461,0 +461,32 @@\n+    @Override\n+    @ForceInline\n+    public Long512Vector compress(VectorMask<Long> m) {\n+        return (Long512Vector)\n+            super.compressTemplate(Long512Mask.class,\n+                                   (Long512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long512Vector compress(VectorMask<Long> m, Vector<Long> v) {\n+        return (Long512Vector)\n+            super.compressTemplate(Long512Mask.class,\n+                                   (Long512Mask) m, (Long512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long512Vector expand(VectorMask<Long> m) {\n+        return (Long512Vector)\n+            super.expandTemplate(Long512Mask.class,\n+                                   (Long512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long512Vector expand(VectorMask<Long> m, Vector<Long> v) {\n+        return (Long512Vector)\n+            super.expandTemplate(Long512Mask.class,\n+                                   (Long512Mask) m, (Long512Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -461,0 +461,32 @@\n+    @Override\n+    @ForceInline\n+    public Long64Vector compress(VectorMask<Long> m) {\n+        return (Long64Vector)\n+            super.compressTemplate(Long64Mask.class,\n+                                   (Long64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long64Vector compress(VectorMask<Long> m, Vector<Long> v) {\n+        return (Long64Vector)\n+            super.compressTemplate(Long64Mask.class,\n+                                   (Long64Mask) m, (Long64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long64Vector expand(VectorMask<Long> m) {\n+        return (Long64Vector)\n+            super.expandTemplate(Long64Mask.class,\n+                                   (Long64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long64Vector expand(VectorMask<Long> m, Vector<Long> v) {\n+        return (Long64Vector)\n+            super.expandTemplate(Long64Mask.class,\n+                                   (Long64Mask) m, (Long64Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -461,0 +461,32 @@\n+    @Override\n+    @ForceInline\n+    public LongMaxVector compress(VectorMask<Long> m) {\n+        return (LongMaxVector)\n+            super.compressTemplate(LongMaxMask.class,\n+                                   (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector compress(VectorMask<Long> m, Vector<Long> v) {\n+        return (LongMaxVector)\n+            super.compressTemplate(LongMaxMask.class,\n+                                   (LongMaxMask) m, (LongMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector expand(VectorMask<Long> m) {\n+        return (LongMaxVector)\n+            super.expandTemplate(LongMaxMask.class,\n+                                   (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector expand(VectorMask<Long> m, Vector<Long> v) {\n+        return (LongMaxVector)\n+            super.expandTemplate(LongMaxMask.class,\n+                                   (LongMaxMask) m, (LongMaxVector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2226,0 +2226,90 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector compress(VectorMask<Long> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    LongVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      LongVector v = LongVector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector compress(VectorMask<Long> m, Vector<Long> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    LongVector compressTemplate(Class<M> masktype, M m, LongVector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector expand(VectorMask<Long> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    LongVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      LongVector v = LongVector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector expand(VectorMask<Long> m, Vector<Long> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    LongVector expandTemplate(Class<M> masktype, M m, LongVector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public Short128Vector compress(VectorMask<Short> m) {\n+        return (Short128Vector)\n+            super.compressTemplate(Short128Mask.class,\n+                                   (Short128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short128Vector compress(VectorMask<Short> m, Vector<Short> v) {\n+        return (Short128Vector)\n+            super.compressTemplate(Short128Mask.class,\n+                                   (Short128Mask) m, (Short128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short128Vector expand(VectorMask<Short> m) {\n+        return (Short128Vector)\n+            super.expandTemplate(Short128Mask.class,\n+                                   (Short128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short128Vector expand(VectorMask<Short> m, Vector<Short> v) {\n+        return (Short128Vector)\n+            super.expandTemplate(Short128Mask.class,\n+                                   (Short128Mask) m, (Short128Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public Short256Vector compress(VectorMask<Short> m) {\n+        return (Short256Vector)\n+            super.compressTemplate(Short256Mask.class,\n+                                   (Short256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short256Vector compress(VectorMask<Short> m, Vector<Short> v) {\n+        return (Short256Vector)\n+            super.compressTemplate(Short256Mask.class,\n+                                   (Short256Mask) m, (Short256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short256Vector expand(VectorMask<Short> m) {\n+        return (Short256Vector)\n+            super.expandTemplate(Short256Mask.class,\n+                                   (Short256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short256Vector expand(VectorMask<Short> m, Vector<Short> v) {\n+        return (Short256Vector)\n+            super.expandTemplate(Short256Mask.class,\n+                                   (Short256Mask) m, (Short256Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public Short512Vector compress(VectorMask<Short> m) {\n+        return (Short512Vector)\n+            super.compressTemplate(Short512Mask.class,\n+                                   (Short512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short512Vector compress(VectorMask<Short> m, Vector<Short> v) {\n+        return (Short512Vector)\n+            super.compressTemplate(Short512Mask.class,\n+                                   (Short512Mask) m, (Short512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short512Vector expand(VectorMask<Short> m) {\n+        return (Short512Vector)\n+            super.expandTemplate(Short512Mask.class,\n+                                   (Short512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short512Vector expand(VectorMask<Short> m, Vector<Short> v) {\n+        return (Short512Vector)\n+            super.expandTemplate(Short512Mask.class,\n+                                   (Short512Mask) m, (Short512Vector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -469,0 +469,32 @@\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short64Vector compress(VectorMask<Short> m) {\n+        return (Short64Vector)\n+            super.compressTemplate(Short64Mask.class,\n+                                   (Short64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short64Vector compress(VectorMask<Short> m, Vector<Short> v) {\n+        return (Short64Vector)\n+            super.compressTemplate(Short64Mask.class,\n+                                   (Short64Mask) m, (Short64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short64Vector expand(VectorMask<Short> m) {\n+        return (Short64Vector)\n+            super.expandTemplate(Short64Mask.class,\n+                                   (Short64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short64Vector expand(VectorMask<Short> m, Vector<Short> v) {\n+        return (Short64Vector)\n+            super.expandTemplate(Short64Mask.class,\n+                                   (Short64Mask) m, (Short64Vector) v);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -471,0 +471,32 @@\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector compress(VectorMask<Short> m) {\n+        return (ShortMaxVector)\n+            super.compressTemplate(ShortMaxMask.class,\n+                                   (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector compress(VectorMask<Short> m, Vector<Short> v) {\n+        return (ShortMaxVector)\n+            super.compressTemplate(ShortMaxMask.class,\n+                                   (ShortMaxMask) m, (ShortMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector expand(VectorMask<Short> m) {\n+        return (ShortMaxVector)\n+            super.expandTemplate(ShortMaxMask.class,\n+                                   (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector expand(VectorMask<Short> m, Vector<Short> v) {\n+        return (ShortMaxVector)\n+            super.expandTemplate(ShortMaxMask.class,\n+                                   (ShortMaxMask) m, (ShortMaxVector) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2361,0 +2361,90 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector compress(VectorMask<Short> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    ShortVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      ShortVector v = ShortVector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector compress(VectorMask<Short> m, Vector<Short> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    ShortVector compressTemplate(Class<M> masktype, M m, ShortVector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector expand(VectorMask<Short> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    ShortVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      ShortVector v = ShortVector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector expand(VectorMask<Short> m, Vector<Short> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    ShortVector expandTemplate(Class<M> masktype, M m, ShortVector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2692,0 +2692,88 @@\n+    \/**\n+     * Compresses the lane elements of this vector selecting lanes\n+     * under the control of a specific mask.\n+     *\n+     * This is a cross-lane operation that compresses the lane\n+     * elements of this vector as selected by the specified mask.\n+     *\n+     * For each lane {@code N} of the mask, if the mask at\n+     * lane {@code N} is set, the element at lane {@code N}\n+     * of input vector is selected and stored into the output\n+     * vector contiguously starting from the lane {@code 0}.\n+     * All the upper remaining lanes, if any, of the output\n+     * vector are set to zero.\n+     *\n+     * @param m the mask controlling the compression\n+     * @return the compressed lane elements of this vector\n+     * @see #compress(VectorMask,Vector)\n+     *\/\n+    public abstract Vector<E> compress(VectorMask<E> m);\n+\n+    \/**\n+     * Compresses the lane elements of this vector within another\n+     * background vector selecting lanes under the control of a\n+     * specific mask.\n+     *\n+     * This is a cross-lane operation that compresses the lane\n+     * elements of this vector within another background vector\n+     * as selected by the specified mask.\n+     *\n+     * For each lane {@code N} of the mask, if the mask at\n+     * lane {@code N} is set, the element at lane {@code N}\n+     * of this vector is selected and stored into the\n+     * output vector contiguously starting from the lane {@code 0}.\n+     * All the upper remaining lanes, if any, of the output\n+     * vector get the value from the corresponding lanes\n+     * of the background vector.\n+     *\n+     * @param m the mask controlling the compression\n+     * @param v the background vector\n+     * @return the compressed lane elements of this vector\n+     * @see #compress(VectorMask)\n+     *\/\n+    public abstract Vector<E> compress(VectorMask<E> m, Vector<E> v);\n+\n+    \/**\n+     * Expands the lane elements of this vector\n+     * under the control of a specific mask.\n+     *\n+     * This is a cross-lane operation that expands the contguous lane\n+     * elements of this vector into lanes of an output vector\n+     * as selected by the specified mask.\n+     *\n+     * For each lane {@code N} of the mask, if the mask at\n+     * lane {@code N} is set, the next contiguous element of input vector\n+     * starting from lane {@code 0} is selected and stored into the output\n+     * vector at lane {@code N}.\n+     * All the remaining lanes, if any, of the output vector are set to zero.\n+     *\n+     * @param m the mask controlling the compression\n+     * @return the expanded lane elements of this vector\n+     * @see #expand(VectorMask,Vector)\n+     *\/\n+    public abstract Vector<E> expand(VectorMask<E> m);\n+\n+    \/**\n+     * Expands the lane elements of this vector into another background\n+     * vector under the control of a specific mask.\n+     *\n+     * This is a cross-lane operation that expands the contguous lane\n+     * elements of this vector into lanes of a background vector\n+     * as selected by the specified mask.\n+     *\n+     * For each lane {@code N} of the mask, if the mask at\n+     * lane {@code N} is set, the next contiguous element of input vector\n+     * starting from lane {@code 0} is selected and stored into the output\n+     * vector at lane {@code N}.\n+     * All the remaining lanes, if any, of the output\n+     * vector get the value from the corresponding lanes\n+     * of the background vector.\n+     *\n+     * @param m the mask controlling the compression\n+     * @param v the background vector\n+     * @return the expanded lane elements of this vector\n+     * @see #expand(VectorMask)\n+     *\/\n+    public abstract Vector<E> expand(VectorMask<E> m, Vector<E> v);\n+\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2660,0 +2660,90 @@\n+     *\/\n+    @Override\n+    public abstract\n+    $Type$Vector compress(VectorMask<$Boxtype$> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $Type$Vector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      $Type$Vector v = $Type$Vector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    $Type$Vector compress(VectorMask<$Boxtype$> m, Vector<$Boxtype$> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $Type$Vector compressTemplate(Class<M> masktype, M m, $Type$Vector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(j++, lane(i));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    $Type$Vector expand(VectorMask<$Boxtype$> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $Type$Vector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      $Type$Vector v = $Type$Vector.zero(species());\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    $abstractvectortype$ expand(VectorMask<$Boxtype$> m, Vector<$Boxtype$> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $Type$Vector expandTemplate(Class<M> masktype, M m, $Type$Vector v) {\n+      m.check(masktype, this);\n+      int j = 0;\n+      for (int i = 0; i < length(); i++) {\n+        if (m.laneIsSet(i)) {\n+           v = v.withLane(i, lane(j++));\n+        }\n+      }\n+      return v;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -477,0 +477,32 @@\n+    @Override\n+    @ForceInline\n+    public $vectortype$ compress(VectorMask<$Boxtype$> m) {\n+        return ($vectortype$)\n+            super.compressTemplate($masktype$.class,\n+                                   ($masktype$) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public $vectortype$ compress(VectorMask<$Boxtype$> m, Vector<$Boxtype$> v) {\n+        return ($vectortype$)\n+            super.compressTemplate($masktype$.class,\n+                                   ($masktype$) m, ($vectortype$) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public $vectortype$ expand(VectorMask<$Boxtype$> m) {\n+        return ($vectortype$)\n+            super.expandTemplate($masktype$.class,\n+                                   ($masktype$) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public $vectortype$ expand(VectorMask<$Boxtype$> m, Vector<$Boxtype$> v) {\n+        return ($vectortype$)\n+            super.expandTemplate($masktype$.class,\n+                                   ($masktype$) m, ($vectortype$) v);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, byte[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, byte[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4227,0 +4325,74 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void compressByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void expandByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, byte[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, byte[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4227,0 +4325,74 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void compressByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void expandByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, byte[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, byte[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4227,0 +4325,74 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void compressByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void expandByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, byte[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, byte[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4227,0 +4325,74 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void compressByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void expandByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -267,0 +267,98 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, byte[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, byte[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4232,0 +4330,74 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void compressByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteBinaryOpMaskProvider\")\n+    static void expandByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(double[] r, double[] a, double[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, double[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3177,0 +3275,74 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressMaskedDouble128VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void compressDouble128VectorTestsMasked(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandMaskedDouble128VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void expandDouble128VectorTestsMasked(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(double[] r, double[] a, double[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, double[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3177,0 +3275,74 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressMaskedDouble256VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void compressDouble256VectorTestsMasked(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandMaskedDouble256VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void expandDouble256VectorTestsMasked(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(double[] r, double[] a, double[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, double[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3177,0 +3275,74 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressMaskedDouble512VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void compressDouble512VectorTestsMasked(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandMaskedDouble512VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void expandDouble512VectorTestsMasked(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(double[] r, double[] a, double[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, double[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3177,0 +3275,74 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressMaskedDouble64VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void compressDouble64VectorTestsMasked(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandMaskedDouble64VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void expandDouble64VectorTestsMasked(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -267,0 +267,98 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(double[] r, double[] a, double[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, double[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3182,0 +3280,74 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void compressDoubleMaxVectorTestsMasked(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleBinaryOpMaskProvider\")\n+    static void expandDoubleMaxVectorTestsMasked(IntFunction<double[]> fa, IntFunction<double[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(float[] r, float[] a, float[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, float[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3187,0 +3285,74 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressMaskedFloat128VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void compressFloat128VectorTestsMasked(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandMaskedFloat128VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void expandFloat128VectorTestsMasked(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(float[] r, float[] a, float[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, float[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3187,0 +3285,74 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressMaskedFloat256VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void compressFloat256VectorTestsMasked(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandMaskedFloat256VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void expandFloat256VectorTestsMasked(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(float[] r, float[] a, float[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, float[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3187,0 +3285,74 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressMaskedFloat512VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void compressFloat512VectorTestsMasked(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandMaskedFloat512VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void expandFloat512VectorTestsMasked(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(float[] r, float[] a, float[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, float[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3187,0 +3285,74 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressMaskedFloat64VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void compressFloat64VectorTestsMasked(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandMaskedFloat64VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void expandFloat64VectorTestsMasked(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -267,0 +267,98 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(float[] r, float[] a, float[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, float[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -3192,0 +3290,74 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressMaskedFloatMaxVectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void compressFloatMaxVectorTestsMasked(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandMaskedFloatMaxVectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatBinaryOpMaskProvider\")\n+    static void expandFloatMaxVectorTestsMasked(IntFunction<float[]> fa, IntFunction<float[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(int[] r, int[] a, int[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, int[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4192,0 +4290,74 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void compressInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void expandInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(int[] r, int[] a, int[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, int[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4192,0 +4290,74 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void compressInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void expandInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(int[] r, int[] a, int[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, int[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4192,0 +4290,74 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void compressInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void expandInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(int[] r, int[] a, int[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, int[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4192,0 +4290,74 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void compressInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void expandInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -267,0 +267,98 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(int[] r, int[] a, int[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, int[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4197,0 +4295,74 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void compressIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void expandIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -219,0 +219,98 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(long[] r, long[] a, long[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, long[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4142,0 +4240,74 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void compressLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void expandLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -219,0 +219,98 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(long[] r, long[] a, long[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, long[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4142,0 +4240,74 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void compressLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void expandLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -219,0 +219,98 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(long[] r, long[] a, long[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, long[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4142,0 +4240,74 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void compressLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void expandLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -219,0 +219,98 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(long[] r, long[] a, long[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, long[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4142,0 +4240,74 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void compressLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void expandLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -224,0 +224,98 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(long[] r, long[] a, long[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, long[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4147,0 +4245,74 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void compressLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void expandLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, short[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, short[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4217,0 +4315,74 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void compressShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void expandShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, short[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, short[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4217,0 +4315,74 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void compressShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void expandShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, short[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, short[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4217,0 +4315,74 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void compressShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void expandShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -262,0 +262,98 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, short[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, short[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4217,0 +4315,74 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void compressShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void expandShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -267,0 +267,98 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, short[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, short[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -4222,0 +4320,74 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void compressShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.compress(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertcompressArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void expandShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.expand(vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assertexpandArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+compressexpand_template=\"CompressExpand\"\n@@ -506,0 +507,4 @@\n+# Compress\/Expand\n+gen_op_tmpl $compressexpand_template \"compress\" \"\"\n+gen_op_tmpl $compressexpand_template \"expand\" \"\"\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void [[TEST]]Masked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.[[TEST]](vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assert[[TEST]]ArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void [[TEST]]$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.[[TEST]](vmask, bv).intoArray(r, i);\n+            }\n+        }\n+        assert[[TEST]]ArraysEquals(r, a, b, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-CompressExpand.template","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -293,0 +293,98 @@\n+    static void assertcompressArraysEquals($type$[] r, $type$[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], ($type$)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals($type$[] r, $type$[] a, $type$[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], b[i + k]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals($type$[] r, $type$[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], ($type$)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals($type$[] r, $type$[] a, $type$[] b, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], b[i + j]);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], b[idx], \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"}]}