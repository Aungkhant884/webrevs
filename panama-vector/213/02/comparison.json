{"files":[{"patch":"@@ -2837,0 +2837,14 @@\n+void Assembler::kxnorbl(KRegister dst, KRegister src1, KRegister src2) {\n+  assert(VM_Version::supports_avx512dq(), \"\");\n+  InstructionAttr attributes(AVX_256bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x46, (0xC0 | encode));\n+}\n+\n+void Assembler::kxnorwl(KRegister dst, KRegister src1, KRegister src2) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(AVX_256bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x46, (0xC0 | encode));\n+}\n+\n@@ -2954,7 +2968,0 @@\n-void Assembler::kxnorbl(KRegister dst, KRegister src1, KRegister src2) {\n-  assert(VM_Version::supports_avx512dq(), \"\");\n-  InstructionAttr attributes(AVX_256bit, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n-  emit_int16(0x46, (0xC0 | encode));\n-}\n-\n@@ -10642,1 +10649,1 @@\n-  emit_int8((unsigned char)0x90);\n+  emit_int8(0x90);\n@@ -10655,1 +10662,1 @@\n-  emit_int8((unsigned char)0x90);\n+  emit_int8(0x90);\n@@ -10668,1 +10675,1 @@\n-  emit_int8((unsigned char)0x92);\n+  emit_int8(0x92);\n@@ -10681,1 +10688,1 @@\n-  emit_int8((unsigned char)0x92);\n+  emit_int8(0x92);\n@@ -10698,1 +10705,1 @@\n-  emit_int8((unsigned char)0x90);\n+  emit_int8(0x90);\n@@ -10710,1 +10717,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -10716,1 +10723,1 @@\n-  emit_int8((unsigned char)0x90);\n+  emit_int8(0x90);\n@@ -10728,1 +10735,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -10734,1 +10741,1 @@\n-  emit_int8((unsigned char)0x92);\n+  emit_int8(0x92);\n@@ -10752,1 +10759,124 @@\n-  emit_int8((unsigned char)0x92);\n+  emit_int8(0x92);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpgatherqd(XMMRegister dst, Address src, XMMRegister mask, int vector_len) {\n+  assert(VM_Version::supports_avx2(), \"\");\n+  assert(vector_len == Assembler::AVX_128bit || vector_len == Assembler::AVX_256bit, \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  assert(src.isxmmindex(),\"expected to be xmm index\");\n+  assert(dst != src.xmmindex(), \"instruction will #UD if dst and index are the same\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  vex_prefix(src, mask->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x91);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vpgatherqq(XMMRegister dst, Address src, XMMRegister mask, int vector_len) {\n+  assert(VM_Version::supports_avx2(), \"\");\n+  assert(vector_len == Assembler::AVX_128bit || vector_len == Assembler::AVX_256bit, \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  assert(src.isxmmindex(),\"expected to be xmm index\");\n+  assert(dst != src.xmmindex(), \"instruction will #UD if dst and index are the same\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  vex_prefix(src, mask->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x91);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vgatherqpd(XMMRegister dst, Address src, XMMRegister mask, int vector_len) {\n+  assert(VM_Version::supports_avx2(), \"\");\n+  assert(vector_len == Assembler::AVX_128bit || vector_len == Assembler::AVX_256bit, \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  assert(src.isxmmindex(),\"expected to be xmm index\");\n+  assert(dst != src.xmmindex(), \"instruction will #UD if dst and index are the same\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  vex_prefix(src, mask->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x93);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vgatherqps(XMMRegister dst, Address src, XMMRegister mask, int vector_len) {\n+  assert(VM_Version::supports_avx2(), \"\");\n+  assert(vector_len == Assembler::AVX_128bit || vector_len == Assembler::AVX_256bit, \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  assert(src.isxmmindex(),\"expected to be xmm index\");\n+  assert(dst != src.xmmindex(), \"instruction will #UD if dst and index are the same\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  vex_prefix(src, mask->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x93);\n+  emit_operand(dst, src, 0);\n+}\n+void Assembler::evpgatherqd(XMMRegister dst, KRegister mask, Address src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  assert(src.isxmmindex(),\"expected to be xmm index\");\n+  assert(dst != src.xmmindex(), \"instruction will #UD if dst and index are the same\");\n+  assert(mask != k0, \"instruction will #UD if mask is in k0\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  \/\/ swap src<->dst for encoding\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x91);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evpgatherqq(XMMRegister dst, KRegister mask, Address src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  assert(src.isxmmindex(),\"expected to be xmm index\");\n+  assert(dst != src.xmmindex(), \"instruction will #UD if dst and index are the same\");\n+  assert(mask != k0, \"instruction will #UD if mask is in k0\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  \/\/ swap src<->dst for encoding\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x91);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evgatherqpd(XMMRegister dst, KRegister mask, Address src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  assert(src.isxmmindex(),\"expected to be xmm index\");\n+  assert(dst != src.xmmindex(), \"instruction will #UD if dst and index are the same\");\n+  assert(mask != k0, \"instruction will #UD if mask is in k0\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  \/\/ swap src<->dst for encoding\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x93);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::evgatherqps(XMMRegister dst, KRegister mask, Address src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(dst != xnoreg, \"sanity\");\n+  assert(src.isxmmindex(),\"expected to be xmm index\");\n+  assert(dst != src.xmmindex(), \"instruction will #UD if dst and index are the same\");\n+  assert(mask != k0, \"instruction will #UD if mask is in k0\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  \/\/ swap src<->dst for encoding\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0x93);\n@@ -10766,1 +10896,1 @@\n-  emit_int8((unsigned char)0xA0);\n+  emit_int8(0xA0);\n@@ -10775,1 +10905,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -10780,1 +10910,1 @@\n-  emit_int8((unsigned char)0xA0);\n+  emit_int8(0xA0);\n@@ -10794,1 +10924,1 @@\n-  emit_int8((unsigned char)0xA2);\n+  emit_int8(0xA2);\n@@ -10803,0 +10933,42 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0xA2);\n+  emit_operand(src, dst, 0);\n+}\n+\n+void Assembler::evpscatterqd(Address dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(mask != k0, \"instruction will #UD if mask is in k0\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0xA1);\n+  emit_operand(src, dst, 0);\n+}\n+\n+void Assembler::evpscatterqq(Address dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(mask != k0, \"instruction will #UD if mask is in k0\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0xA1);\n+  emit_operand(src, dst, 0);\n+}\n+\n+void Assembler::evscatterqps(Address dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(mask != k0, \"instruction will #UD if mask is in k0\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -10808,1 +10980,1 @@\n-  emit_int8((unsigned char)0xA2);\n+  emit_int8(0xA3);\n@@ -10811,0 +10983,15 @@\n+\n+void Assembler::evscatterqpd(Address dst, KRegister mask, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(mask != k0, \"instruction will #UD if mask is in k0\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8(0xA3);\n+  emit_operand(src, dst, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":209,"deletions":22,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -1521,0 +1521,4 @@\n+\n+  void kxnorbl(KRegister dst, KRegister src1, KRegister src2);\n+  void kxnorwl(KRegister dst, KRegister src1, KRegister src2);\n+\n@@ -1547,1 +1551,0 @@\n-  void kxnorbl(KRegister dst, KRegister src1, KRegister src2);\n@@ -2762,0 +2765,4 @@\n+  void vpgatherqd(XMMRegister dst, Address src, XMMRegister mask, int vector_len);\n+  void vpgatherqq(XMMRegister dst, Address src, XMMRegister mask, int vector_len);\n+  void vgatherqpd(XMMRegister dst, Address src, XMMRegister mask, int vector_len);\n+  void vgatherqps(XMMRegister dst, Address src, XMMRegister mask, int vector_len);\n@@ -2766,0 +2773,4 @@\n+  void evpgatherqd(XMMRegister dst, KRegister mask, Address src, int vector_len);\n+  void evpgatherqq(XMMRegister dst, KRegister mask, Address src, int vector_len);\n+  void evgatherqpd(XMMRegister dst, KRegister mask, Address src, int vector_len);\n+  void evgatherqps(XMMRegister dst, KRegister mask, Address src, int vector_len);\n@@ -2772,0 +2783,4 @@\n+  void evpscatterqd(Address dst, KRegister mask, XMMRegister src, int vector_len);\n+  void evpscatterqq(Address dst, KRegister mask, XMMRegister src, int vector_len);\n+  void evscatterqps(Address dst, KRegister mask, XMMRegister src, int vector_len);\n+  void evscatterqpd(Address dst, KRegister mask, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1502,17 +1502,23 @@\n-void C2_MacroAssembler::vgather(BasicType typ, XMMRegister dst, Register base, XMMRegister idx, XMMRegister mask, int vector_len) {\n-  switch(typ) {\n-    case T_INT:\n-      vpgatherdd(dst, Address(base, idx, Address::times_4), mask, vector_len);\n-      break;\n-    case T_FLOAT:\n-      vgatherdps(dst, Address(base, idx, Address::times_4), mask, vector_len);\n-      break;\n-    case T_LONG:\n-      vpgatherdq(dst, Address(base, idx, Address::times_8), mask, vector_len);\n-      break;\n-    case T_DOUBLE:\n-      vgatherdpd(dst, Address(base, idx, Address::times_8), mask, vector_len);\n-      break;\n-    default:\n-      assert(false,\"Should not reach here.\");\n-      break;\n+void C2_MacroAssembler::vgather(BasicType elem_bt, BasicType idx_bt, XMMRegister dst, Register base,\n+                                XMMRegister idx, int scale, int disp, XMMRegister mask, int vlen) {\n+  int vlen_enc = vector_length_encoding(MAX2(type2aelembytes(elem_bt), type2aelembytes(idx_bt)) * vlen);\n+  Address::ScaleFactor scale_factor = Address::times(scale);\n+  assert_different_registers(dst, idx, mask);\n+  if (idx_bt == T_INT) {\n+    switch (elem_bt) {\n+      case T_INT:    vpgatherdd(dst, Address(base, idx, scale_factor, disp), mask, vlen_enc); break;\n+      case T_LONG:   vpgatherdq(dst, Address(base, idx, scale_factor, disp), mask, vlen_enc); break;\n+      case T_FLOAT:  vgatherdps(dst, Address(base, idx, scale_factor, disp), mask, vlen_enc); break;\n+      case T_DOUBLE: vgatherdpd(dst, Address(base, idx, scale_factor, disp), mask, vlen_enc); break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  } else {\n+    switch (elem_bt) {\n+      case T_INT:    vpgatherqd(dst, Address(base, idx, scale_factor, disp), mask, vlen_enc); break;\n+      case T_LONG:   vpgatherqq(dst, Address(base, idx, scale_factor, disp), mask, vlen_enc); break;\n+      case T_FLOAT:  vgatherqps(dst, Address(base, idx, scale_factor, disp), mask, vlen_enc); break;\n+      case T_DOUBLE: vgatherqpd(dst, Address(base, idx, scale_factor, disp), mask, vlen_enc); break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n@@ -1522,17 +1528,23 @@\n-void C2_MacroAssembler::evgather(BasicType typ, XMMRegister dst, KRegister mask, Register base, XMMRegister idx, int vector_len) {\n-  switch(typ) {\n-    case T_INT:\n-      evpgatherdd(dst, mask, Address(base, idx, Address::times_4), vector_len);\n-      break;\n-    case T_FLOAT:\n-      evgatherdps(dst, mask, Address(base, idx, Address::times_4), vector_len);\n-      break;\n-    case T_LONG:\n-      evpgatherdq(dst, mask, Address(base, idx, Address::times_8), vector_len);\n-      break;\n-    case T_DOUBLE:\n-      evgatherdpd(dst, mask, Address(base, idx, Address::times_8), vector_len);\n-      break;\n-    default:\n-      assert(false,\"Should not reach here.\");\n-      break;\n+void C2_MacroAssembler::evgather(BasicType elem_bt, BasicType idx_bt, XMMRegister dst, KRegister mask,\n+                                 Register base, XMMRegister idx, int scale, int disp, int vlen) {\n+  int vlen_enc = vector_length_encoding(MAX2(type2aelembytes(elem_bt), type2aelembytes(idx_bt)) * vlen);\n+  Address::ScaleFactor scale_factor = Address::times(scale);\n+  assert(dst != idx, \"\");\n+  if (idx_bt == T_INT) {\n+    switch (elem_bt) {\n+      case T_INT:    evpgatherdd(dst, mask, Address(base, idx, scale_factor, disp), vlen_enc); break;\n+      case T_LONG:   evpgatherdq(dst, mask, Address(base, idx, scale_factor, disp), vlen_enc); break;\n+      case T_FLOAT:  evgatherdps(dst, mask, Address(base, idx, scale_factor, disp), vlen_enc); break;\n+      case T_DOUBLE: evgatherdpd(dst, mask, Address(base, idx, scale_factor, disp), vlen_enc); break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  } else {\n+    switch (elem_bt) {\n+      case T_INT:    evpgatherqd(dst, mask, Address(base, idx, scale_factor, disp), vlen_enc); break;\n+      case T_LONG:   evpgatherqq(dst, mask, Address(base, idx, scale_factor, disp), vlen_enc); break;\n+      case T_FLOAT:  evgatherqps(dst, mask, Address(base, idx, scale_factor, disp), vlen_enc); break;\n+      case T_DOUBLE: evgatherqpd(dst, mask, Address(base, idx, scale_factor, disp), vlen_enc); break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n@@ -1542,17 +1554,30 @@\n-void C2_MacroAssembler::evscatter(BasicType typ, Register base, XMMRegister idx, KRegister mask, XMMRegister src, int vector_len) {\n-  switch(typ) {\n-    case T_INT:\n-      evpscatterdd(Address(base, idx, Address::times_4), mask, src, vector_len);\n-      break;\n-    case T_FLOAT:\n-      evscatterdps(Address(base, idx, Address::times_4), mask, src, vector_len);\n-      break;\n-    case T_LONG:\n-      evpscatterdq(Address(base, idx, Address::times_8), mask, src, vector_len);\n-      break;\n-    case T_DOUBLE:\n-      evscatterdpd(Address(base, idx, Address::times_8), mask, src, vector_len);\n-      break;\n-    default:\n-      assert(false,\"Should not reach here.\");\n-      break;\n+void C2_MacroAssembler::evscatter(BasicType elem_bt, BasicType idx_bt, Register base, XMMRegister idx, int scale,\n+                                  int disp, KRegister mask, XMMRegister src, XMMRegister xtmp, int vlen) {\n+  int vlen_enc = vector_length_encoding(MAX2(type2aelembytes(elem_bt), type2aelembytes(idx_bt)) * vlen);\n+\n+  if (src == idx) {\n+    assert(elem_bt == idx_bt, \"\");\n+    evmovdqul(xtmp, idx, vlen_enc);\n+    idx = xtmp;\n+  }\n+\n+  Address::ScaleFactor scale_factor = Address::times(scale);\n+  assert(src != idx, \"\");\n+  if (idx_bt == T_INT) {\n+    switch (elem_bt) {\n+      case T_INT:    evpscatterdd(Address(base, idx, scale_factor, disp), mask, src, vlen_enc); break;\n+      case T_LONG:   evpscatterdq(Address(base, idx, scale_factor, disp), mask, src, vlen_enc); break;\n+      case T_FLOAT:  evscatterdps(Address(base, idx, scale_factor, disp), mask, src, vlen_enc); break;\n+      case T_DOUBLE: evscatterdpd(Address(base, idx, scale_factor, disp), mask, src, vlen_enc); break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  } else {\n+    switch (elem_bt) {\n+      case T_INT:    evpscatterqd(Address(base, idx, scale_factor, disp), mask, src, vlen_enc); break;\n+      case T_LONG:   evpscatterqq(Address(base, idx, scale_factor, disp), mask, src, vlen_enc); break;\n+      case T_FLOAT:  evscatterqps(Address(base, idx, scale_factor, disp), mask, src, vlen_enc); break;\n+      case T_DOUBLE: evscatterqpd(Address(base, idx, scale_factor, disp), mask, src, vlen_enc); break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":76,"deletions":51,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -124,3 +124,6 @@\n-  void vgather(BasicType typ, XMMRegister dst, Register base, XMMRegister idx, XMMRegister mask, int vector_len);\n-  void evgather(BasicType typ, XMMRegister dst, KRegister mask, Register base, XMMRegister idx, int vector_len);\n-  void evscatter(BasicType typ, Register base, XMMRegister idx, KRegister mask, XMMRegister src, int vector_len);\n+  void vgather(BasicType elem_bt, BasicType idx_bt, XMMRegister dst, Register base,\n+               XMMRegister idx, int scale, int disp, XMMRegister mask, int vlen);\n+  void evgather(BasicType elem_bt, BasicType idx_bt, XMMRegister dst, KRegister mask,\n+                Register base, XMMRegister idx, int scale, int disp, int vlen);\n+  void evscatter(BasicType elem_bt, BasicType idx_bt, Register base, XMMRegister idx, int scale,\n+                 int disp, KRegister mask, XMMRegister src, XMMRegister xtmp, int vlen);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1406,1 +1406,0 @@\n-    case Op_StoreVectorScatter:\n@@ -1574,1 +1573,2 @@\n-    case Op_LoadVectorGather:\n+    case Op_LoadGatherI:\n+    case Op_LoadGatherL:\n@@ -1579,0 +1579,10 @@\n+    case Op_StoreScatterI:\n+    case Op_StoreScatterL:\n+    case Op_LoadGatherIMasked:\n+    case Op_LoadGatherLMasked:\n+    case Op_StoreScatterIMasked:\n+    case Op_StoreScatterLMasked:\n+      if (UseAVX < 3) {\n+        return false;\n+      }\n+      break;\n@@ -1926,3 +1936,9 @@\n-    case Op_LoadVectorGatherMasked:\n-    case Op_StoreVectorScatterMasked:\n-    case Op_StoreVectorScatter:\n+    case Op_StoreScatterI:\n+    case Op_LoadGatherIMasked:\n+    case Op_StoreScatterIMasked:\n+      \/\/ The encodings of these are of the data vectors\n+      if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      \/\/ fallthrough\n+    case Op_LoadGatherI:\n@@ -1931,1 +1947,9 @@\n-      } else if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+      } else if (size_in_bits < 128) {\n+        return false;\n+      }\n+      break;\n+    case Op_StoreScatterL:\n+    case Op_LoadGatherLMasked:\n+    case Op_StoreScatterLMasked:\n+      \/\/ The encodings of these are of the index vectors\n+      if (vlen < 8 && !VM_Version::supports_avx512vl()) {\n@@ -1935,2 +1959,4 @@\n-    case Op_LoadVectorGather:\n-      if (size_in_bits == 64 ) {\n+    case Op_LoadGatherL:\n+      if (is_subword_type(bt)) {\n+        return false;\n+      } else if (vlen < 2) {\n@@ -2111,2 +2137,4 @@\n-    case Op_LoadVectorGatherMasked:\n-    case Op_StoreVectorScatterMasked:\n+    case Op_LoadGatherIMasked:\n+    case Op_LoadGatherLMasked:\n+    case Op_StoreScatterIMasked:\n+    case Op_StoreScatterLMasked:\n@@ -4080,1 +4108,1 @@\n-\/\/ ---------------------------------------- Gather ------------------------------------\n+\/\/ ---------------------------------------- LoadGather ------------------------------------\n@@ -4082,1 +4110,1 @@\n-\/\/ Gather INT, LONG, FLOAT, DOUBLE\n+\/\/ LoadGather INT, LONG, FLOAT, DOUBLE\n@@ -4084,1 +4112,1 @@\n-instruct gather(legVec dst, memory mem, legVec idx, rRegP tmp, legVec mask) %{\n+instruct gatherI(legVec dst, noIndexMemory mem, legVec idx, immL scale, legVec mask) %{\n@@ -4086,3 +4114,3 @@\n-  match(Set dst (LoadVectorGather mem idx));\n-  effect(TEMP dst, TEMP tmp, TEMP mask);\n-  format %{ \"load_vector_gather $dst, $mem, $idx\\t! using $tmp and $mask as TEMP\" %}\n+  match(Set dst (LoadGatherI mem (Binary idx scale)));\n+  effect(TEMP dst, TEMP mask);\n+  format %{ \"gather $dst, $mem, $idx, $scale\\t! using $mask as TEMP\" %}\n@@ -4091,1 +4119,1 @@\n-\n+    int vlen = Matcher::vector_length(this);\n@@ -4094,11 +4122,4 @@\n-\n-    assert(Matcher::vector_length_in_bytes(this) >= 16, \"sanity\");\n-    assert(!is_subword_type(elem_bt), \"sanity\"); \/\/ T_INT, T_LONG, T_FLOAT, T_DOUBLE\n-\n-    if (vlen_enc == Assembler::AVX_128bit) {\n-      __ movdqu($mask$$XMMRegister, ExternalAddress(vector_all_bits_set()), noreg);\n-    } else {\n-      __ vmovdqu($mask$$XMMRegister, ExternalAddress(vector_all_bits_set()), noreg);\n-    }\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ vgather(elem_bt, $dst$$XMMRegister, $tmp$$Register, $idx$$XMMRegister, $mask$$XMMRegister, vlen_enc);\n+    Address mem = $mem$$Address;\n+    __ vallones($mask$$XMMRegister, vlen_enc);\n+    __ vgather(elem_bt, T_INT, $dst$$XMMRegister, mem.base(), $idx$$XMMRegister,\n+               $scale$$constant, mem.disp(), $mask$$XMMRegister, vlen);\n@@ -4109,5 +4130,5 @@\n-instruct evgather(vec dst, memory mem, vec idx, rRegP tmp, kReg ktmp) %{\n-  predicate(VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64);\n-  match(Set dst (LoadVectorGather mem idx));\n-  effect(TEMP dst, TEMP tmp, TEMP ktmp);\n-  format %{ \"load_vector_gather $dst, $mem, $idx\\t! using $tmp and ktmp as TEMP\" %}\n+instruct gatherL(legVec dst, noIndexMemory mem, legVec idx, immL scale, legVec mask) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(MemNode::ValueIn)->in(1)) <= 32);\n+  match(Set dst (LoadGatherL mem (Binary idx scale)));\n+  effect(TEMP dst, TEMP mask);\n+  format %{ \"gather $dst, $mem, $idx, $scale\\t! using $mask as TEMP\" %}\n@@ -4115,2 +4136,2 @@\n-    assert(UseAVX > 2, \"sanity\");\n-\n+    assert(UseAVX >= 2, \"sanity\");\n+    int vlen = Matcher::vector_length(this);\n@@ -4119,0 +4140,7 @@\n+    Address mem = $mem$$Address;\n+    __ vallones($mask$$XMMRegister, vlen_enc);\n+    __ vgather(elem_bt, T_LONG, $dst$$XMMRegister, mem.base(), $idx$$XMMRegister,\n+               $scale$$constant, mem.disp(), $mask$$XMMRegister, vlen);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -4120,1 +4148,15 @@\n-    assert(!is_subword_type(elem_bt), \"sanity\"); \/\/ T_INT, T_LONG, T_FLOAT, T_DOUBLE\n+instruct evgatherI(vec dst, noIndexMemory mem, vec idx, immL scale, kReg mask) %{\n+  predicate(VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64);\n+  match(Set dst (LoadGatherI mem (Binary idx scale)));\n+  effect(TEMP dst, TEMP mask);\n+  format %{ \"gather $dst, $mem, $idx, $scale\\t! using $mask as TEMP\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    Address mem = $mem$$Address;\n+    __ kxnorwl($mask$$KRegister, $mask$$KRegister, $mask$$KRegister);\n+    __ evgather(elem_bt, T_INT, $dst$$XMMRegister, $mask$$KRegister, mem.base(),\n+                $idx$$XMMRegister, $scale$$constant, mem.disp(), vlen);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -4122,3 +4164,12 @@\n-    __ kmovwl($ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), noreg);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ evgather(elem_bt, $dst$$XMMRegister, $ktmp$$KRegister, $tmp$$Register, $idx$$XMMRegister, vlen_enc);\n+instruct evgatherL(vec dst, noIndexMemory mem, vec idx, immL scale, kReg mask) %{\n+  predicate(VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(MemNode::ValueIn)->in(1)) == 64);\n+  match(Set dst (LoadGatherL mem (Binary idx scale)));\n+  effect(TEMP dst, TEMP mask);\n+  format %{ \"gather $dst, $mem, $idx, $scale\\t! using $mask as TEMP\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    Address mem = $mem$$Address;\n+    __ kxnorwl($mask$$KRegister, $mask$$KRegister, $mask$$KRegister);\n+    __ evgather(elem_bt, T_LONG, $dst$$XMMRegister, $mask$$KRegister, mem.base(),\n+                $idx$$XMMRegister, $scale$$constant, mem.disp(), vlen);\n@@ -4129,4 +4180,4 @@\n-instruct evgather_masked(vec dst, memory mem, vec idx, kReg mask, kReg ktmp, rRegP tmp) %{\n-  match(Set dst (LoadVectorGatherMasked mem (Binary idx mask)));\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP ktmp);\n-  format %{ \"load_vector_gather_masked $dst, $mem, $idx, $mask\\t! using $tmp and ktmp as TEMP\" %}\n+instruct evgatherI_masked(vec dst, kReg mask, noIndexMemory mem, vec idx, immL scale, kReg ktmp) %{\n+  match(Set dst (LoadGatherIMasked mem (Binary (Binary idx scale) mask)));\n+  effect(TEMP dst, TEMP ktmp);\n+  format %{ \"gather_masked $dst, $mem, $idx, $scale, $mask\\t! using $ktmp as TEMP\" %}\n@@ -4134,1 +4185,0 @@\n-    assert(UseAVX > 2, \"sanity\");\n@@ -4136,0 +4186,19 @@\n+    int vlen = Matcher::vector_length(this);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this);\n+    Address mem = $mem$$Address;\n+    __ kmovwl($ktmp$$KRegister, $mask$$KRegister);\n+    __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    __ evgather(elem_bt, T_INT, $dst$$XMMRegister, $ktmp$$KRegister, mem.base(),\n+                $idx$$XMMRegister, $scale$$constant, mem.disp(), vlen);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct evgatherL_masked(vec dst, kReg mask, noIndexMemory mem, vec idx, immL scale, kReg ktmp) %{\n+  match(Set dst (LoadGatherLMasked mem (Binary (Binary idx scale) mask)));\n+  effect(TEMP dst, TEMP ktmp);\n+  format %{ \"gather_masked $dst, $mem, $idx, $scale, $mask\\t! using $ktmp as TEMP\" %}\n+  ins_encode %{\n+    \/\/ Use the vlen_enc of the larger vector\n+    int vlen_enc = vector_length_encoding(this, $idx);\n+    int vlen = Matcher::vector_length(this);\n@@ -4137,3 +4206,1 @@\n-    assert(!is_subword_type(elem_bt), \"sanity\"); \/\/ T_INT, T_LONG, T_FLOAT, T_DOUBLE\n-    \/\/ Note: Since gather instruction partially updates the opmask register used\n-    \/\/ for predication hense moving mask operand to a temporary.\n+    Address mem = $mem$$Address;\n@@ -4142,2 +4209,2 @@\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ evgather(elem_bt, $dst$$XMMRegister, $ktmp$$KRegister, $tmp$$Register, $idx$$XMMRegister, vlen_enc);\n+    __ evgather(elem_bt, T_LONG, $dst$$XMMRegister, $ktmp$$KRegister, mem.base(),\n+                $idx$$XMMRegister, $scale$$constant, mem.disp(), vlen);\n@@ -4147,1 +4214,0 @@\n-\/\/ ====================Scatter=======================================\n@@ -4149,1 +4215,3 @@\n-\/\/ Scatter INT, LONG, FLOAT, DOUBLE\n+\/\/ ====================StoreScatter=======================================\n+\n+\/\/ StoreScatter INT, LONG, FLOAT, DOUBLE\n@@ -4151,5 +4219,4 @@\n-instruct scatter(memory mem, vec src, vec idx, rRegP tmp, kReg ktmp) %{\n-  predicate(UseAVX > 2);\n-  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n-  effect(TEMP tmp, TEMP ktmp);\n-  format %{ \"store_vector_scatter $mem, $idx, $src\\t! using k2 and $tmp as TEMP\" %}\n+instruct evscatterI(noIndexMemory mem, vec idx, immL scale, vec src, vec xtmp, kReg mask) %{\n+  match(Set mem (StoreScatterI mem (Binary src (Binary idx scale))));\n+  effect(TEMP xtmp, TEMP mask);\n+  format %{ \"scatter $mem, $idx, $scale, $src\\t! using $xtmp and $mask as TEMP\" %}\n@@ -4157,1 +4224,1 @@\n-    int vlen_enc = vector_length_encoding(this, $src);\n+    int vlen = Matcher::vector_length(this, $src);\n@@ -4159,0 +4226,7 @@\n+    Address mem = $mem$$Address;\n+    __ kxnorwl($mask$$KRegister, $mask$$KRegister, $mask$$KRegister);\n+    __ evscatter(elem_bt, T_INT, mem.base(), $idx$$XMMRegister, $scale$$constant,\n+                 mem.disp(), $mask$$KRegister, $src$$XMMRegister, $xtmp$$XMMRegister, vlen);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -4160,2 +4234,14 @@\n-    assert(Matcher::vector_length_in_bytes(this, $src) >= 16, \"sanity\");\n-    assert(!is_subword_type(elem_bt), \"sanity\"); \/\/ T_INT, T_LONG, T_FLOAT, T_DOUBLE\n+instruct evscatterL(noIndexMemory mem, vec idx, immL scale, vec src, vec xtmp, kReg mask) %{\n+  match(Set mem (StoreScatterL mem (Binary src (Binary idx scale))));\n+  effect(TEMP xtmp, TEMP mask);\n+  format %{ \"scatter $mem, $idx, $scale, $src\\t! using $xtmp and $mask as TEMP\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this, $src);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this, $src);\n+    Address mem = $mem$$Address;\n+    __ kxnorwl($mask$$KRegister, $mask$$KRegister, $mask$$KRegister);\n+    __ evscatter(elem_bt, T_LONG, mem.base(), $idx$$XMMRegister, $scale$$constant,\n+                 mem.disp(), $mask$$KRegister, $src$$XMMRegister, $xtmp$$XMMRegister, vlen);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -4163,3 +4249,11 @@\n-    __ kmovwl($ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), noreg);\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ evscatter(elem_bt, $tmp$$Register, $idx$$XMMRegister, $ktmp$$KRegister, $src$$XMMRegister, vlen_enc);\n+instruct evscatterI_masked(memory mem, vec idx, immL scale, kReg mask, vec src, vec xtmp, kReg ktmp) %{\n+  match(Set mem (StoreScatterIMasked mem (Binary src (Binary (Binary idx scale) mask))));\n+  effect(TEMP xtmp, TEMP ktmp);\n+  format %{ \"scatter_masked $mem, $idx, $scale, $src, $mask\\t! using $xtmp and $ktmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this, $src);\n+    BasicType elem_bt = Matcher::vector_element_basic_type(this, $src);\n+    Address mem = $mem$$Address;\n+    __ kmovwl($ktmp$$KRegister, $mask$$KRegister);\n+    __ evscatter(elem_bt, T_INT, mem.base(), $idx$$XMMRegister, $scale$$constant,\n+                 mem.disp(), $ktmp$$KRegister, $src$$XMMRegister, $xtmp$$XMMRegister, vlen);\n@@ -4170,4 +4264,4 @@\n-instruct scatter_masked(memory mem, vec src, vec idx, kReg mask, kReg ktmp, rRegP tmp) %{\n-  match(Set mem (StoreVectorScatterMasked mem (Binary src (Binary idx mask))));\n-  effect(TEMP tmp, TEMP ktmp);\n-  format %{ \"store_vector_scatter_masked $mem, $idx, $src, $mask\\t!\" %}\n+instruct evscatterL_masked(memory mem, vec idx, immL scale, kReg mask, vec src, vec xtmp, kReg ktmp) %{\n+  match(Set mem (StoreScatterLMasked mem (Binary src (Binary (Binary idx scale) mask))));\n+  effect(TEMP xtmp, TEMP ktmp);\n+  format %{ \"scatter_masked $mem, $idx, $scale, $src, $mask\\t! using $xtmp and $ktmp as TEMP\" %}\n@@ -4175,1 +4269,1 @@\n-    int vlen_enc = vector_length_encoding(this, $src);\n+    int vlen = Matcher::vector_length(this, $src);\n@@ -4177,4 +4271,1 @@\n-    assert(Matcher::vector_length_in_bytes(this, $src) >= 16, \"sanity\");\n-    assert(!is_subword_type(elem_bt), \"sanity\"); \/\/ T_INT, T_LONG, T_FLOAT, T_DOUBLE\n-    \/\/ Note: Since scatter instruction partially updates the opmask register used\n-    \/\/ for predication hense moving mask operand to a temporary.\n+    Address mem = $mem$$Address;\n@@ -4182,2 +4273,2 @@\n-    __ lea($tmp$$Register, $mem$$Address);\n-    __ evscatter(elem_bt, $tmp$$Register, $idx$$XMMRegister, $ktmp$$KRegister, $src$$XMMRegister, vlen_enc);\n+    __ evscatter(elem_bt, T_LONG, mem.base(), $idx$$XMMRegister, $scale$$constant,\n+                 mem.disp(), $ktmp$$KRegister, $src$$XMMRegister, $xtmp$$XMMRegister, vlen);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":164,"deletions":73,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -4544,0 +4544,2 @@\n+opclass noIndexMemory(indirect, indOffset8, indOffset32);\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4348,0 +4348,2 @@\n+opclass noIndexMemory(indirect, indOffset8, indOffset32);\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -270,2 +270,0 @@\n-  if( strcmp(opType,\"LoadVectorGather\")==0 )  return Form::idealV;\n-  if( strcmp(opType,\"LoadVectorGatherMasked\")==0 )  return Form::idealV;\n@@ -273,0 +271,4 @@\n+  if( strcmp(opType,\"LoadGatherI\")==0 )  return Form::idealV;\n+  if( strcmp(opType,\"LoadGatherL\")==0 )  return Form::idealV;\n+  if( strcmp(opType,\"LoadGatherIMasked\")==0 )  return Form::idealV;\n+  if( strcmp(opType,\"LoadGatherLMasked\")==0 )  return Form::idealV;\n@@ -287,5 +289,7 @@\n-  if( strcmp(opType,\"StoreNKlass\")==0)  return Form::idealNKlass;\n-  if( strcmp(opType,\"StoreVector\")==0 )  return Form::idealV;\n-  if( strcmp(opType,\"StoreVectorScatter\")==0 )  return Form::idealV;\n-  if( strcmp(opType,\"StoreVectorScatterMasked\")==0 )  return Form::idealV;\n-  if( strcmp(opType,\"StoreVectorMasked\")==0 )  return Form::idealV;\n+  if( strcmp(opType,\"StoreNKlass\")==0)          return Form::idealNKlass;\n+  if( strcmp(opType,\"StoreVector\")==0 )         return Form::idealV;\n+  if( strcmp(opType,\"StoreVectorMasked\")==0 )   return Form::idealV;\n+  if( strcmp(opType,\"StoreScatterI\")==0 )       return Form::idealV;\n+  if( strcmp(opType,\"StoreScatterL\")==0 )       return Form::idealV;\n+  if( strcmp(opType,\"StoreScatterIMasked\")==0 ) return Form::idealV;\n+  if( strcmp(opType,\"StoreScatterLMasked\")==0 ) return Form::idealV;\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3518,1 +3518,2 @@\n-    \"LoadVectorGather\", \"StoreVectorScatter\", \"LoadVectorGatherMasked\", \"StoreVectorScatterMasked\",\n+    \"LoadGatherI\",  \"LoadGatherL\", \"StoreScatterI\", \"StoreScatterL\",\n+    \"LoadGatherIMasked\",  \"LoadGatherLMasked\", \"StoreScatterIMasked\", \"StoreScatterLMasked\",\n@@ -4227,1 +4228,2 @@\n-    \"LoadVectorGather\", \"StoreVectorScatter\", \"LoadVectorGatherMasked\", \"StoreVectorScatterMasked\",\n+    \"LoadGatherI\",  \"LoadGatherL\", \"StoreScatterI\", \"StoreScatterL\",\n+    \"LoadGatherIMasked\",  \"LoadGatherLMasked\", \"StoreScatterIMasked\", \"StoreScatterLMasked\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1154,0 +1154,1 @@\n+                                     \"Ljava\/lang\/Class;\"                                                                                       \\\n@@ -1157,0 +1158,1 @@\n+                                     \"J\"                                                                                                       \\\n@@ -1159,1 +1161,0 @@\n-                                     \"I[II\"                                                                                                    \\\n@@ -1171,0 +1172,1 @@\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n@@ -1174,0 +1176,2 @@\n+                                      \"J\"                                                                                                      \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;\"                                                      \\\n@@ -1175,2 +1179,1 @@\n-                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljava\/lang\/Object;\"                                    \\\n-                                      \"I[II\"                                                                                                   \\\n+                                      \"Ljava\/lang\/Object;\"                                                                                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -445,2 +445,4 @@\n-macro(LoadVectorGather)\n-macro(LoadVectorGatherMasked)\n+macro(LoadGatherI)\n+macro(LoadGatherL)\n+macro(LoadGatherIMasked)\n+macro(LoadGatherLMasked)\n@@ -448,2 +450,4 @@\n-macro(StoreVectorScatter)\n-macro(StoreVectorScatterMasked)\n+macro(StoreScatterI)\n+macro(StoreScatterL)\n+macro(StoreScatterIMasked)\n+macro(StoreScatterLMasked)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3659,4 +3659,8 @@\n-  case Op_LoadVectorGather:\n-  case Op_StoreVectorScatter:\n-  case Op_LoadVectorGatherMasked:\n-  case Op_StoreVectorScatterMasked:\n+  case Op_LoadGatherI:\n+  case Op_LoadGatherL:\n+  case Op_StoreScatterI:\n+  case Op_StoreScatterL:\n+  case Op_LoadGatherIMasked:\n+  case Op_LoadGatherLMasked:\n+  case Op_StoreScatterIMasked:\n+  case Op_StoreScatterLMasked:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -726,2 +726,4 @@\n-        case Op_StoreVectorScatter:\n-        case Op_StoreVectorScatterMasked:\n+        case Op_StoreScatterI:\n+        case Op_StoreScatterL:\n+        case Op_StoreScatterIMasked:\n+        case Op_StoreScatterLMasked:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2491,3 +2491,11 @@\n-    case Op_LoadVectorGatherMasked:\n-    case Op_StoreVectorScatter: {\n-      Node* pair = new BinaryNode(n->in(MemNode::ValueIn), n->in(MemNode::ValueIn+1));\n+    case Op_LoadGatherI:\n+    case Op_LoadGatherL: {\n+      Node* is = new BinaryNode(n->in(MemNode::ValueIn), n->in(MemNode::ValueIn+1));\n+      n->set_req(MemNode::ValueIn, is);\n+      n->del_req(MemNode::ValueIn+1);\n+      break;\n+    }\n+    case Op_LoadGatherIMasked:\n+    case Op_LoadGatherLMasked: {\n+      Node* is = new BinaryNode(n->in(MemNode::ValueIn), n->in(MemNode::ValueIn+1));\n+      Node* pair = new BinaryNode(is, n->in(MemNode::ValueIn+2));\n@@ -2495,0 +2503,1 @@\n+      n->del_req(MemNode::ValueIn+2);\n@@ -2498,3 +2507,5 @@\n-    case Op_StoreVectorScatterMasked: {\n-      Node* pair = new BinaryNode(n->in(MemNode::ValueIn+1), n->in(MemNode::ValueIn+2));\n-      n->set_req(MemNode::ValueIn+1, pair);\n+    case Op_StoreScatterI:\n+    case Op_StoreScatterL: {\n+      Node* is = new BinaryNode(n->in(MemNode::ValueIn+1), n->in(MemNode::ValueIn+2));\n+      Node* pair = new BinaryNode(n->in(MemNode::ValueIn), is);\n+      n->set_req(MemNode::ValueIn, pair);\n@@ -2502,1 +2513,8 @@\n-      pair = new BinaryNode(n->in(MemNode::ValueIn), n->in(MemNode::ValueIn+1));\n+      n->del_req(MemNode::ValueIn+1);\n+      break;\n+    }\n+    case Op_StoreScatterIMasked:\n+    case Op_StoreScatterLMasked: {\n+      Node* is = new BinaryNode(n->in(MemNode::ValueIn+1), n->in(MemNode::ValueIn+2));\n+      Node* coordinates = new BinaryNode(is, n->in(MemNode::ValueIn+3));\n+      Node* pair = new BinaryNode(n->in(MemNode::ValueIn), coordinates);\n@@ -2504,0 +2522,2 @@\n+      n->del_req(MemNode::ValueIn+3);\n+      n->del_req(MemNode::ValueIn+2);\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2653,2 +2653,2 @@\n-             st->Opcode() == Op_StoreVectorScatter ||\n-             Opcode() == Op_StoreVectorScatter ||\n+             st->is_StoreScatter() ||\n+             is_StoreScatter() ||\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-class LoadVectorGatherNode;\n+class LoadGatherNode;\n@@ -173,1 +173,1 @@\n-class StoreVectorScatterNode;\n+class StoreScatterNode;\n@@ -731,2 +731,2 @@\n-          DEFINE_CLASS_ID(LoadVectorGather, LoadVector, 0)\n-          DEFINE_CLASS_ID(LoadVectorGatherMasked, LoadVector, 1)\n+          DEFINE_CLASS_ID(LoadGather, LoadVector, 0)\n+          DEFINE_CLASS_ID(LoadGatherMasked, LoadVector, 1)\n@@ -736,2 +736,2 @@\n-          DEFINE_CLASS_ID(StoreVectorScatter, StoreVector, 0)\n-          DEFINE_CLASS_ID(StoreVectorScatterMasked, StoreVector, 1)\n+          DEFINE_CLASS_ID(StoreScatter, StoreVector, 0)\n+          DEFINE_CLASS_ID(StoreScatterMasked, StoreVector, 1)\n@@ -955,1 +955,1 @@\n-  DEFINE_CLASS_QUERY(LoadVectorGather)\n+  DEFINE_CLASS_QUERY(LoadGather)\n@@ -957,1 +957,1 @@\n-  DEFINE_CLASS_QUERY(StoreVectorScatter)\n+  DEFINE_CLASS_QUERY(StoreScatter)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1385,12 +1385,12 @@\n-\/\/ <C,\n-\/\/  V extends Vector<?>,\n-\/\/  W extends Vector<Integer>,\n-\/\/  S extends VectorSpecies<E>,\n-\/\/  M extends VectorMask<E>,\n-\/\/  E>\n-\/\/ V loadWithMap(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType, int length,\n-\/\/               Class<? extends Vector<Integer>> vectorIndexClass,\n-\/\/               Object base, long offset, \/\/ Unsafe addressing\n-\/\/               W index_vector, M m,\n-\/\/               C container, int index, int[] indexMap, int indexM, S s, \/\/ Arguments for default implementation\n-\/\/               LoadVectorOperationWithMap<C, V, E, S, M> defaultImpl)\n+\/\/  <C,\n+\/\/   V extends Vector<E>,\n+\/\/   IV extends Vector<IE>,\n+\/\/   S extends VectorSpecies<E>,\n+\/\/   M extends VectorMask<E>,\n+\/\/   E, IE>\n+\/\/  V loadWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+\/\/                int length, Class<? extends IV> ivClass, Class<IE> ieClass,\n+\/\/                Object base, long baseOffset, \/\/ Unsafe addressing\n+\/\/                IV indexMap, long scale, M m,\n+\/\/                C container, S s, \/\/ Arguments for default implementation\n+\/\/                LoadVectorOperationWithMap<C, V, IV, S, M, E, IE> defaultImpl)\n@@ -1400,1 +1400,1 @@\n-\/\/   W extends Vector<Integer>,\n+\/\/   IV extends Vector<IE>,\n@@ -1402,6 +1402,7 @@\n-\/\/   E>\n-\/\/  void storeWithMap(Class<? extends V> vectorClass, Class<M> maskClass, Class<E> elementType,\n-\/\/                    int length, Class<? extends Vector<Integer>> vectorIndexClass, Object base, long offset,    \/\/ Unsafe addressing\n-\/\/                    W index_vector, V v, M m,\n-\/\/                    C container, int index, int[] indexMap, int indexM, \/\/ Arguments for default implementation\n-\/\/                    StoreVectorOperationWithMap<C, V, M, E> defaultImpl)\n+\/\/   E, IE>\n+\/\/  void storeWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+\/\/                    int length, Class<? extends IV> ivClass, Class<IE> ieClass,\n+\/\/                    Object base, long baseOffset, \/\/ Unsafe addressing\n+\/\/                    IV indexMap, long scale, M m, V v,\n+\/\/                    C container, \/\/ Arguments for default implementation\n+\/\/                    StoreVectorOperationWithMap<C, V, IV, M, E, IE> defaultImpl)\n@@ -1414,1 +1415,3 @@\n-  const TypeInstPtr* vector_idx_klass = gvn().type(argument(4))->isa_instptr();\n+  const TypeInstPtr* idx_vector_klass = gvn().type(argument(4))->isa_instptr();\n+  const TypeInstPtr* idx_elem_klass   = gvn().type(argument(5))->isa_instptr();\n+  const TypeLong*    scale_type       = gvn().type(argument(10))->isa_long();\n@@ -1416,2 +1419,4 @@\n-  if (vector_klass == nullptr || elem_klass == nullptr || vector_idx_klass == nullptr || vlen == nullptr ||\n-      vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || vector_idx_klass->const_oop() == nullptr || !vlen->is_con()) {\n+  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr ||\n+      idx_vector_klass == nullptr || idx_elem_klass == nullptr || scale_type == nullptr ||\n+      vector_klass->const_oop() == nullptr || elem_klass->const_oop() == nullptr || !vlen->is_con() ||\n+      idx_vector_klass->const_oop() == nullptr || idx_elem_klass->const_oop() == nullptr || !scale_type->is_con()) {\n@@ -1419,1 +1424,1 @@\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s viclass=%s\",\n+      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s ivclass=%s ieclass=%s scale=%s\",\n@@ -1423,1 +1428,3 @@\n-                    NodeClassNames[argument(4)->Opcode()]);\n+                    NodeClassNames[argument(4)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()],\n+                    NodeClassNames[argument(10)->Opcode()]);\n@@ -1428,1 +1435,1 @@\n-  if (!is_klass_initialized(vector_klass) || !is_klass_initialized(vector_idx_klass)) {\n+  if (!is_klass_initialized(vector_klass) || !is_klass_initialized(idx_vector_klass)) {\n@@ -1436,1 +1443,2 @@\n-  if (!elem_type->is_primitive_type()) {\n+  ciType* idx_elem_type = idx_elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type() || !idx_elem_type->is_primitive_type()) {\n@@ -1438,1 +1446,1 @@\n-      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+      tty->print_cr(\"  ** not a primitive bt=%d idx_bt=%d\", elem_type->basic_type(), idx_elem_type->basic_type());\n@@ -1443,0 +1451,1 @@\n+  int opc;\n@@ -1444,0 +1453,1 @@\n+  BasicType idx_elem_bt = idx_elem_type->basic_type();\n@@ -1446,1 +1456,11 @@\n-  const Type* vmask_type = gvn().type(is_scatter ? argument(10) : argument(9));\n+  \/\/ Check that the vector holding indices is supported by architecture\n+  if (!arch_supports_vector(Op_LoadVector, num_elem, idx_elem_bt, VecMaskNotUsed)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s ietype=%s\",\n+                      is_scatter, is_scatter ? \"scatter\" : \"gather\",\n+                      num_elem, type2name(elem_bt), type2name(idx_elem_bt));\n+      }\n+      return false; \/\/ not supported\n+  }\n+\n+  const Type* vmask_type = gvn().type(argument(12));\n@@ -1470,0 +1490,1 @@\n+    opc = is_scatter ? StoreScatterMaskedNode::opcode(idx_elem_bt) : LoadGatherMaskedNode::opcode(idx_elem_bt);\n@@ -1471,2 +1492,1 @@\n-    if (!arch_supports_vector(is_scatter ? Op_StoreVectorScatterMasked : Op_LoadVectorGatherMasked, num_elem, elem_bt,\n-                              (VectorMaskUseType) (VecMaskUseLoad | VecMaskUsePred))) {\n+    if (!arch_supports_vector(opc, num_elem, elem_bt, (VectorMaskUseType) (VecMaskUseLoad | VecMaskUsePred))) {\n@@ -1474,1 +1494,1 @@\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s is_masked_op=1\",\n+        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s ietype=%s is_masked_op=1\",\n@@ -1476,1 +1496,1 @@\n-                      num_elem, type2name(elem_bt));\n+                      num_elem, type2name(elem_bt), type2name(idx_elem_bt));\n@@ -1482,1 +1502,2 @@\n-    if (!arch_supports_vector(is_scatter ? Op_StoreVectorScatter : Op_LoadVectorGather, num_elem, elem_bt, VecMaskNotUsed)) {\n+    opc = is_scatter ? StoreScatterNode::opcode(idx_elem_bt) : LoadGatherNode::opcode(idx_elem_bt);\n+    if (!arch_supports_vector(opc, num_elem, elem_bt, VecMaskNotUsed)) {\n@@ -1484,1 +1505,1 @@\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s is_masked_op=0\",\n+        tty->print_cr(\"  ** not supported: arity=%d op=%s vlen=%d etype=%s ietype=%s is_masked_op=0\",\n@@ -1486,1 +1507,1 @@\n-                      num_elem, type2name(elem_bt));\n+                      num_elem, type2name(elem_bt), type2name(idx_elem_bt));\n@@ -1492,12 +1513,3 @@\n-  \/\/ Check that the vector holding indices is supported by architecture\n-  if (!arch_supports_vector(Op_LoadVector, num_elem, T_INT, VecMaskNotUsed)) {\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s\/loadindex vlen=%d etype=int is_masked_op=%d\",\n-                      is_scatter, is_scatter ? \"scatter\" : \"gather\",\n-                      num_elem, is_masked_op ? 1 : 0);\n-      }\n-      return false; \/\/ not supported\n-  }\n-\n-  Node* base = argument(5);\n-  Node* offset = ConvL2X(argument(6));\n+  Node* base = argument(6);\n+  Node* offset = ConvL2X(argument(7));\n+  Node* scale = argument(10);\n@@ -1528,2 +1540,2 @@\n-  ciKlass* vbox_idx_klass = vector_idx_klass->const_oop()->as_instance()->java_lang_Class_klass();\n-  if (vbox_idx_klass == nullptr) {\n+  ciKlass* idx_vbox_klass = idx_vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  if (idx_vbox_klass == nullptr) {\n@@ -1535,2 +1547,2 @@\n-  const TypeInstPtr* vbox_idx_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_idx_klass);\n-  Node* index_vect = unbox_vector(argument(8), vbox_idx_type, T_INT, num_elem);\n+  const TypeInstPtr* idx_vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, idx_vbox_klass);\n+  Node* index_vect = unbox_vector(argument(9), idx_vbox_type, idx_elem_bt, num_elem);\n@@ -1547,1 +1559,1 @@\n-    mask = unbox_vector(is_scatter ? argument(10) : argument(9), mbox_type, elem_bt, num_elem);\n+    mask = unbox_vector(argument(12), mbox_type, elem_bt, num_elem);\n@@ -1550,3 +1562,1 @@\n-        tty->print_cr(\"  ** unbox failed mask=%s\",\n-                    is_scatter ? NodeClassNames[argument(10)->Opcode()]\n-                               : NodeClassNames[argument(9)->Opcode()]);\n+        tty->print_cr(\"  ** unbox failed mask=%s\", NodeClassNames[argument(10)->Opcode()]);\n@@ -1562,1 +1572,1 @@\n-    Node* val = unbox_vector(argument(9), vbox_type, elem_bt, num_elem);\n+    Node* val = unbox_vector(argument(13), vbox_type, elem_bt, num_elem);\n@@ -1572,1 +1582,1 @@\n-      vstore = gvn().transform(new StoreVectorScatterMaskedNode(control(), memory(addr), addr, addr_type, val, index_vect, mask));\n+      vstore = gvn().transform(StoreScatterMaskedNode::make(opc, control(), memory(addr), addr, addr_type, val, index_vect, scale, mask));\n@@ -1574,1 +1584,1 @@\n-      vstore = gvn().transform(new StoreVectorScatterNode(control(), memory(addr), addr, addr_type, val, index_vect));\n+      vstore = gvn().transform(StoreScatterNode::make(opc, control(), memory(addr), addr, addr_type, val, index_vect, scale));\n@@ -1580,1 +1590,1 @@\n-      vload = gvn().transform(new LoadVectorGatherMaskedNode(control(), memory(addr), addr, addr_type, vector_type, index_vect, mask));\n+      vload = gvn().transform(LoadGatherMaskedNode::make(opc, control(), memory(addr), addr, addr_type, vector_type, index_vect, scale, mask));\n@@ -1582,1 +1592,1 @@\n-      vload = gvn().transform(new LoadVectorGatherNode(control(), memory(addr), addr, addr_type, vector_type, index_vect));\n+      vload = gvn().transform(LoadGatherNode::make(opc, control(), memory(addr), addr, addr_type, vector_type, index_vect, scale));\n@@ -1589,1 +1599,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":70,"deletions":61,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -915,1 +915,1 @@\n-  \/\/ Generate the related masked op for vector load\/store\/load_gather\/store_scatter.\n+  \/\/ Generate the related masked op for vector load\/store\/load_LoadGather\/store_StoreScatter.\n@@ -922,4 +922,8 @@\n-  case Op_LoadVectorGather:\n-    return new LoadVectorGatherMaskedNode(node->in(0), node->in(1), node->in(2),\n-                                          node->as_LoadVector()->adr_type(), vt,\n-                                          node->in(3), mask);\n+  case Op_LoadGatherI:\n+    return new LoadGatherIMaskedNode(node->in(0), node->in(1), node->in(2),\n+                                 node->as_LoadVector()->adr_type(), vt,\n+                                 node->in(3), node->in(4), mask);\n+  case Op_LoadGatherL:\n+    return new LoadGatherLMaskedNode(node->in(0), node->in(1), node->in(2),\n+                                 node->as_LoadVector()->adr_type(), vt,\n+                                 node->in(3), node->in(4), mask);\n@@ -929,4 +933,8 @@\n-  case Op_StoreVectorScatter:\n-    return new StoreVectorScatterMaskedNode(node->in(0), node->in(1), node->in(2),\n-                                            node->as_StoreVector()->adr_type(),\n-                                            node->in(3), node->in(4), mask);\n+  case Op_StoreScatterI:\n+    return new StoreScatterIMaskedNode(node->in(0), node->in(1), node->in(2),\n+                                  node->as_StoreVector()->adr_type(),\n+                                  node->in(3), node->in(4), node->in(5), mask);\n+  case Op_StoreScatterL:\n+    return new StoreScatterLMaskedNode(node->in(0), node->in(1), node->in(2),\n+                                  node->as_StoreVector()->adr_type(),\n+                                  node->in(3), node->in(4), node->in(5), mask);\n@@ -1983,0 +1991,72 @@\n+int LoadGatherNode::opcode(BasicType bt) {\n+  switch (bt) {\n+    case T_INT:  return Op_LoadGatherI;\n+    case T_LONG: return Op_LoadGatherL;\n+    default: ShouldNotReachHere();\n+  }\n+  return 0;\n+}\n+\n+LoadGatherNode* LoadGatherNode::make(int opc, Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* scale) {\n+  switch (opc) {\n+    case Op_LoadGatherI: return new LoadGatherINode(c, mem, adr, at, vt, indices, scale);\n+    case Op_LoadGatherL: return new LoadGatherLNode(c, mem, adr, at, vt, indices, scale);\n+    default: ShouldNotReachHere();\n+  }\n+  return nullptr;\n+}\n+\n+int StoreScatterNode::opcode(BasicType bt) {\n+  switch (bt) {\n+    case T_INT:  return Op_StoreScatterI;\n+    case T_LONG: return Op_StoreScatterL;\n+    default: ShouldNotReachHere();\n+  }\n+  return 0;\n+}\n+\n+StoreScatterNode* StoreScatterNode::make(int opc, Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val, Node* indices, Node* scale) {\n+  switch (opc) {\n+    case Op_StoreScatterI: return new StoreScatterINode(c, mem, adr, at, val, indices, scale);\n+    case Op_StoreScatterL: return new StoreScatterLNode(c, mem, adr, at, val, indices, scale);\n+    default: ShouldNotReachHere();\n+  }\n+  return nullptr;\n+}\n+\n+int LoadGatherMaskedNode::opcode(BasicType bt) {\n+  switch (bt) {\n+    case T_INT:  return Op_LoadGatherIMasked;\n+    case T_LONG: return Op_LoadGatherLMasked;\n+    default: ShouldNotReachHere();\n+  }\n+  return 0;\n+}\n+\n+LoadGatherMaskedNode* LoadGatherMaskedNode::make(int opc, Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* scale, Node* mask) {\n+  switch (opc) {\n+    case Op_LoadGatherIMasked: return new LoadGatherIMaskedNode(c, mem, adr, at, vt, indices, scale, mask);\n+    case Op_LoadGatherLMasked: return new LoadGatherLMaskedNode(c, mem, adr, at, vt, indices, scale, mask);\n+    default: ShouldNotReachHere();\n+  }\n+  return nullptr;\n+}\n+\n+int StoreScatterMaskedNode::opcode(BasicType bt) {\n+  switch (bt) {\n+    case T_INT:  return Op_StoreScatterIMasked;\n+    case T_LONG: return Op_StoreScatterLMasked;\n+    default: ShouldNotReachHere();\n+  }\n+  return 0;\n+}\n+\n+StoreScatterMaskedNode* StoreScatterMaskedNode::make(int opc, Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val, Node* indices, Node* scale, Node* mask) {\n+  switch (opc) {\n+    case Op_StoreScatterIMasked: return new StoreScatterIMaskedNode(c, mem, adr, at, val, indices, scale, mask);\n+    case Op_StoreScatterLMasked: return new StoreScatterLMaskedNode(c, mem, adr, at, val, indices, scale, mask);\n+    default: ShouldNotReachHere();\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":89,"deletions":9,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -858,1 +858,1 @@\n-\/\/------------------------------LoadVectorGatherNode------------------------------\n+\/\/------------------------------LoadGatherNode------------------------------\n@@ -860,1 +860,1 @@\n-class LoadVectorGatherNode : public LoadVectorNode {\n+class LoadGatherNode : public LoadVectorNode {\n@@ -862,1 +862,1 @@\n-  LoadVectorGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices)\n+  LoadGatherNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* scale)\n@@ -864,2 +864,3 @@\n-    init_class_id(Class_LoadVectorGather);\n-    assert(indices->bottom_type()->is_vect(), \"indices must be in vector\");\n+    init_class_id(Class_LoadGather);\n+    const TypeVect* indices_vt = indices->bottom_type()->is_vect();\n+    assert(indices_vt->length() == vt->length(), \"indices must have the same length\");\n@@ -867,1 +868,2 @@\n-    assert(req() == MemNode::ValueIn + 1, \"match_edge expects that last input is in MemNode::ValueIn\");\n+    add_req(scale);\n+    assert(req() == MemNode::ValueIn + 2, \"match_edge expects that last input is in MemNode::ValueIn\");\n@@ -870,1 +872,0 @@\n-  virtual int Opcode() const;\n@@ -872,0 +873,23 @@\n+\n+  static int opcode(BasicType bt);\n+  static LoadGatherNode* make(int opc, Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* scale);\n+};\n+\n+class LoadGatherINode : public LoadGatherNode {\n+ public:\n+  LoadGatherINode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* scale)\n+    : LoadGatherNode(c, mem, adr, at, vt, indices, scale) {\n+    assert(indices->bottom_type()->is_vect()->element_basic_type() == T_INT, \"\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n+class LoadGatherLNode : public LoadGatherNode {\n+ public:\n+  LoadGatherLNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* scale)\n+    : LoadGatherNode(c, mem, adr, at, vt, indices, scale) {\n+    assert(indices->bottom_type()->is_vect()->element_basic_type() == T_LONG, \"\");\n+  }\n+\n+  virtual int Opcode() const;\n@@ -905,1 +929,1 @@\n-\/\/------------------------------StoreVectorScatterNode------------------------------\n+\/\/------------------------------StoreScatterNode------------------------------\n@@ -908,13 +932,38 @@\n- class StoreVectorScatterNode : public StoreVectorNode {\n-  public:\n-   StoreVectorScatterNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val, Node* indices)\n-     : StoreVectorNode(c, mem, adr, at, val) {\n-     init_class_id(Class_StoreVectorScatter);\n-     assert(indices->bottom_type()->is_vect(), \"indices must be in vector\");\n-     add_req(indices);\n-     assert(req() == MemNode::ValueIn + 2, \"match_edge expects that last input is in MemNode::ValueIn+1\");\n-   }\n-   virtual int Opcode() const;\n-   virtual uint match_edge(uint idx) const { return idx == MemNode::Address ||\n-                                                    idx == MemNode::ValueIn ||\n-                                                    idx == MemNode::ValueIn + 1; }\n+class StoreScatterNode : public StoreVectorNode {\n+ public:\n+  StoreScatterNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val, Node* indices, Node* scale)\n+    : StoreVectorNode(c, mem, adr, at, val) {\n+    init_class_id(Class_StoreScatter);\n+    const TypeVect* indices_vt = indices->bottom_type()->is_vect();\n+    assert(indices_vt->length() == val->bottom_type()->is_vect()->length(), \"indices must have the same length\");\n+    add_req(indices);\n+    add_req(scale);\n+    assert(req() == MemNode::ValueIn + 3, \"match_edge expects that last input is in MemNode::ValueIn+1\");\n+  }\n+\n+  virtual uint match_edge(uint idx) const { return idx == MemNode::Address ||\n+                                                   idx == MemNode::ValueIn ||\n+                                                   idx == MemNode::ValueIn + 1; }\n+\n+  static int opcode(BasicType bt);\n+  static StoreScatterNode* make(int opc, Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val, Node* indices, Node* scale);\n+};\n+\n+class StoreScatterINode : public StoreScatterNode {\n+ public:\n+  StoreScatterINode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val, Node* indices, Node* scale)\n+    : StoreScatterNode(c, mem, adr, at, val, indices, scale) {\n+    assert(indices->bottom_type()->is_vect()->element_basic_type() == T_INT, \"\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n+class StoreScatterLNode : public StoreScatterNode {\n+ public:\n+  StoreScatterLNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val, Node* indices, Node* scale)\n+    : StoreScatterNode(c, mem, adr, at, val, indices, scale) {\n+    assert(indices->bottom_type()->is_vect()->element_basic_type() == T_LONG, \"\");\n+  }\n+\n+  virtual int Opcode() const;\n@@ -962,1 +1011,1 @@\n-\/\/-------------------------------LoadVectorGatherMaskedNode---------------------------------\n+\/\/-------------------------------LoadGatherMaskedNode---------------------------------\n@@ -964,1 +1013,1 @@\n-class LoadVectorGatherMaskedNode : public LoadVectorNode {\n+class LoadGatherMaskedNode : public LoadVectorNode {\n@@ -966,1 +1015,1 @@\n-  LoadVectorGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* mask)\n+  LoadGatherMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* scale, Node* mask)\n@@ -968,2 +1017,3 @@\n-    init_class_id(Class_LoadVectorGatherMasked);\n-    assert(indices->bottom_type()->is_vect(), \"indices must be in vector\");\n+    init_class_id(Class_LoadGatherMasked);\n+    const TypeVect* indices_vt = indices->bottom_type()->is_vect();\n+    assert(indices_vt->length() == vt->length(), \"indices must have the same length\");\n@@ -972,0 +1022,1 @@\n+    add_req(scale);\n@@ -973,1 +1024,1 @@\n-    assert(req() == MemNode::ValueIn + 2, \"match_edge expects that last input is in MemNode::ValueIn+1\");\n+    assert(req() == MemNode::ValueIn + 3, \"match_edge expects that last input is in MemNode::ValueIn+1\");\n@@ -976,1 +1027,0 @@\n-  virtual int Opcode() const;\n@@ -980,0 +1030,23 @@\n+\n+  static int opcode(BasicType bt);\n+  static LoadGatherMaskedNode* make(int opc, Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* scale, Node* mask);\n+};\n+\n+class LoadGatherIMaskedNode : public LoadGatherMaskedNode {\n+ public:\n+  LoadGatherIMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* scale, Node* mask)\n+    : LoadGatherMaskedNode(c, mem, adr, at, vt, indices, scale, mask) {\n+    assert(indices->bottom_type()->is_vect()->element_basic_type() == T_INT, \"\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n+class LoadGatherLMaskedNode : public LoadGatherMaskedNode {\n+ public:\n+  LoadGatherLMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, Node* indices, Node* scale, Node* mask)\n+    : LoadGatherMaskedNode(c, mem, adr, at, vt, indices, scale, mask) {\n+    assert(indices->bottom_type()->is_vect()->element_basic_type() == T_LONG, \"\");\n+  }\n+\n+  virtual int Opcode() const;\n@@ -982,1 +1055,1 @@\n-\/\/------------------------------StoreVectorScatterMaskedNode--------------------------------\n+\/\/------------------------------StoreScatterMaskedNode--------------------------------\n@@ -984,13 +1057,15 @@\n-class StoreVectorScatterMaskedNode : public StoreVectorNode {\n-  public:\n-   StoreVectorScatterMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val, Node* indices, Node* mask)\n-     : StoreVectorNode(c, mem, adr, at, val) {\n-     init_class_id(Class_StoreVectorScatterMasked);\n-     assert(indices->bottom_type()->is_vect(), \"indices must be in vector\");\n-     assert(mask->bottom_type()->isa_vectmask(), \"sanity\");\n-     add_req(indices);\n-     add_req(mask);\n-     assert(req() == MemNode::ValueIn + 3, \"match_edge expects that last input is in MemNode::ValueIn+2\");\n-   }\n-   virtual int Opcode() const;\n-   virtual uint match_edge(uint idx) const { return idx == MemNode::Address ||\n+class StoreScatterMaskedNode : public StoreVectorNode {\n+ public:\n+  StoreScatterMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val, Node* indices, Node* scale, Node* mask)\n+    : StoreVectorNode(c, mem, adr, at, val) {\n+    init_class_id(Class_StoreScatterMasked);\n+    const TypeVect* indices_vt = indices->bottom_type()->is_vect();\n+    assert(indices_vt->length() == val->bottom_type()->is_vect()->length(), \"indices must have the same length\");\n+    assert(mask->bottom_type()->isa_vectmask(), \"sanity\");\n+    add_req(indices);\n+    add_req(scale);\n+    add_req(mask);\n+    assert(req() == MemNode::ValueIn + 4, \"match_edge expects that last input is in MemNode::ValueIn+2\");\n+  }\n+\n+  virtual uint match_edge(uint idx) const { return idx == MemNode::Address ||\n@@ -1000,0 +1075,13 @@\n+\n+  static int opcode(BasicType bt);\n+  static StoreScatterMaskedNode* make(int opc, Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val, Node* indices, Node* scale, Node* mask);\n+};\n+\n+class StoreScatterIMaskedNode : public StoreScatterMaskedNode {\n+ public:\n+  StoreScatterIMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val, Node* indices, Node* scale, Node* mask)\n+    : StoreScatterMaskedNode(c, mem, adr, at, val, indices, scale, mask) {\n+    assert(indices->bottom_type()->is_vect()->element_basic_type() == T_INT, \"\");\n+  }\n+\n+  virtual int Opcode() const;\n@@ -1002,0 +1090,11 @@\n+class StoreScatterLMaskedNode : public StoreScatterMaskedNode {\n+ public:\n+  StoreScatterLMaskedNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val, Node* indices, Node* scale, Node* mask)\n+    : StoreScatterMaskedNode(c, mem, adr, at, val, indices, scale, mask) {\n+    assert(indices->bottom_type()->is_vect()->element_basic_type() == T_LONG, \"\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":141,"deletions":42,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -1803,0 +1803,2 @@\n+  declare_c2_type(LoadVectorMaskedNode, LoadVectorNode)                   \\\n+  declare_c2_type(StoreVectorMaskedNode, StoreVectorNode)                 \\\n@@ -1847,2 +1849,12 @@\n-  declare_c2_type(LoadVectorGatherNode, LoadVectorNode)                   \\\n-  declare_c2_type(StoreVectorScatterNode, StoreVectorNode)                \\\n+  declare_c2_type(LoadGatherNode, LoadVectorNode)                         \\\n+  declare_c2_type(LoadGatherINode, LoadGatherNode)                        \\\n+  declare_c2_type(LoadGatherLNode, LoadGatherNode)                        \\\n+  declare_c2_type(StoreScatterNode, StoreVectorNode)                      \\\n+  declare_c2_type(StoreScatterINode, StoreScatterNode)                    \\\n+  declare_c2_type(StoreScatterLNode, StoreScatterNode)                    \\\n+  declare_c2_type(LoadGatherMaskedNode, LoadVectorNode)                   \\\n+  declare_c2_type(LoadGatherIMaskedNode, LoadGatherMaskedNode)            \\\n+  declare_c2_type(LoadGatherLMaskedNode, LoadGatherMaskedNode)            \\\n+  declare_c2_type(StoreScatterMaskedNode, StoreVectorNode)                \\\n+  declare_c2_type(StoreScatterIMaskedNode, StoreScatterMaskedNode)        \\\n+  declare_c2_type(StoreScatterLMaskedNode, StoreScatterMaskedNode)        \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -459,4 +459,6 @@\n-                                                V extends Vector<?>,\n-                                                S extends VectorSpecies<?>,\n-                                                M extends VectorMask<?>> {\n-        V loadWithMap(C container, int index, int[] indexMap, int indexM, S s, M m);\n+                                                V extends Vector<E>,\n+                                                IV extends Vector<IE>,\n+                                                S extends VectorSpecies<E>,\n+                                                M extends VectorMask<E>,\n+                                                E, IE> {\n+        V loadWithMap(C container, IV indexMap, S s, M m);\n@@ -468,2 +470,2 @@\n-     V extends Vector<?>,\n-     W extends Vector<Integer>,\n+     V extends Vector<E>,\n+     IV extends Vector<IE>,\n@@ -472,1 +474,1 @@\n-     E>\n+     E, IE>\n@@ -474,6 +476,5 @@\n-                  int length,\n-                  Class<? extends Vector<Integer>> vectorIndexClass,\n-                  Object base, long offset,\n-                  W index_vector,\n-                  M m, C container, int index, int[] indexMap, int indexM, S s,\n-                  LoadVectorOperationWithMap<C, V, S, M> defaultImpl) {\n+                  int length, Class<? extends IV> ivClass, Class<IE> ieClass,\n+                  Object base, long baseOffset,\n+                  IV indexMap, long scale, M m,\n+                  C container, S s,\n+                  LoadVectorOperationWithMap<C, V, IV, S, M, E, IE> defaultImpl) {\n@@ -481,1 +482,1 @@\n-        return defaultImpl.loadWithMap(container, index, indexMap, indexM, s, m);\n+        return defaultImpl.loadWithMap(container, indexMap, s, m);\n@@ -528,3 +529,5 @@\n-                                                 V extends Vector<?>,\n-                                                 M extends VectorMask<?>> {\n-        void storeWithMap(C container, int index, V v, int[] indexMap, int indexM, M m);\n+                                                 V extends Vector<E>,\n+                                                 IV extends Vector<IE>,\n+                                                 M extends VectorMask<E>,\n+                                                 E, IE> {\n+        void storeWithMap(C container, IV indexMap, V v, M m);\n@@ -537,1 +540,1 @@\n-     W extends Vector<Integer>,\n+     IV extends Vector<IE>,\n@@ -539,1 +542,1 @@\n-     E>\n+     E, IE>\n@@ -541,6 +544,6 @@\n-                      int length,\n-                      Class<? extends Vector<Integer>> vectorIndexClass,\n-                      Object base, long offset,\n-                      W index_vector,\n-                      V v, M m, C container, int index, int[] indexMap, int indexM,\n-                      StoreVectorOperationWithMap<C, V, M> defaultImpl) {\n+                      int length, Class<? extends IV> ivClass, Class<IE> ieClass,\n+                      Object base, long baseOffset,\n+                      IV indexMap, long scale, M m,\n+                      V v,\n+                      C container,\n+                      StoreVectorOperationWithMap<C, V, IV, M, E, IE> defaultImpl) {\n@@ -548,1 +551,1 @@\n-        defaultImpl.storeWithMap(container, index, v, indexMap, indexM, m);\n+        defaultImpl.storeWithMap(container, indexMap, v, m);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":29,"deletions":26,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -449,8 +449,0 @@\n-    \/*package-private*\/\n-    interface RVOp {\n-        long apply(int i);  \/\/ supply raw element bits\n-    }\n-\n-    \/*package-private*\/\n-    abstract AbstractVector<E> rvOp(RVOp f);\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -886,0 +886,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ByteVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap) {\n+        return super.fromArray0Template(Byte128Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ByteVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, VectorMask<Byte> m) {\n+        return super.fromArray0Template(Byte128Mask.class, ivClass, ieClass, a, offsetMap, (Byte128Mask) m);\n+    }\n@@ -930,0 +945,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap) {\n+        super.intoArray0Template(Byte128Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, VectorMask<Byte> m) {\n+        super.intoArray0Template(Byte128Mask.class, ivClass, ieClass, a, offsetMap, (Byte128Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -918,0 +918,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ByteVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap) {\n+        return super.fromArray0Template(Byte256Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ByteVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, VectorMask<Byte> m) {\n+        return super.fromArray0Template(Byte256Mask.class, ivClass, ieClass, a, offsetMap, (Byte256Mask) m);\n+    }\n@@ -962,0 +977,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap) {\n+        super.intoArray0Template(Byte256Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, VectorMask<Byte> m) {\n+        super.intoArray0Template(Byte256Mask.class, ivClass, ieClass, a, offsetMap, (Byte256Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -982,0 +982,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ByteVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap) {\n+        return super.fromArray0Template(Byte512Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ByteVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, VectorMask<Byte> m) {\n+        return super.fromArray0Template(Byte512Mask.class, ivClass, ieClass, a, offsetMap, (Byte512Mask) m);\n+    }\n@@ -1026,0 +1041,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap) {\n+        super.intoArray0Template(Byte512Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, VectorMask<Byte> m) {\n+        super.intoArray0Template(Byte512Mask.class, ivClass, ieClass, a, offsetMap, (Byte512Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -870,0 +870,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ByteVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap) {\n+        return super.fromArray0Template(Byte64Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ByteVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, VectorMask<Byte> m) {\n+        return super.fromArray0Template(Byte64Mask.class, ivClass, ieClass, a, offsetMap, (Byte64Mask) m);\n+    }\n@@ -914,0 +929,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap) {\n+        super.intoArray0Template(Byte64Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, VectorMask<Byte> m) {\n+        super.intoArray0Template(Byte64Mask.class, ivClass, ieClass, a, offsetMap, (Byte64Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -856,0 +856,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ByteVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap) {\n+        return super.fromArray0Template(ByteMaxMask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ByteVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, VectorMask<Byte> m) {\n+        return super.fromArray0Template(ByteMaxMask.class, ivClass, ieClass, a, offsetMap, (ByteMaxMask) m);\n+    }\n@@ -900,0 +915,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap) {\n+        super.intoArray0Template(ByteMaxMask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, VectorMask<Byte> m) {\n+        super.intoArray0Template(ByteMaxMask.class, ivClass, ieClass, a, offsetMap, (ByteMaxMask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -119,2 +119,4 @@\n-    \/\/ Constant loader (takes dummy as vector arg)\n-    interface FVOp {\n+    \/\/ Nullary operator\n+\n+    \/*package-private*\/\n+    interface FNulOp {\n@@ -127,1 +129,1 @@\n-    ByteVector vOp(FVOp f) {\n+    ByteVector nOp(FNulOp f) {\n@@ -137,1 +139,1 @@\n-    ByteVector vOp(VectorMask<Byte> m, FVOp f) {\n+    ByteVector nOp(VectorMask<Byte> m, FNulOp f) {\n@@ -319,41 +321,1 @@\n-    \/\/ Memory reference\n-\n-    \/*package-private*\/\n-    interface FLdOp<M> {\n-        byte apply(M memory, int offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> ByteVector ldOp(M memory, int offset,\n-                                  FLdOp<M> f) {\n-        \/\/dummy; no vec = vec();\n-        byte[] res = new byte[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> ByteVector ldOp(M memory, int offset,\n-                                  VectorMask<Byte> m,\n-                                  FLdOp<M> f) {\n-        \/\/byte[] vec = vec();\n-        byte[] res = new byte[length()];\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    interface FLdLongOp {\n-        byte apply(MemorySegment memory, long offset, int i);\n-    }\n+    \/\/ Consume operator\n@@ -361,11 +323,2 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    ByteVector ldLongOp(MemorySegment memory, long offset,\n-                                  FLdLongOp f) {\n-        \/\/dummy; no vec = vec();\n-        byte[] res = new byte[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n+    interface FCOp<M> {\n+        void apply(int i, byte a);\n@@ -377,27 +330,1 @@\n-    ByteVector ldLongOp(MemorySegment memory, long offset,\n-                                  VectorMask<Byte> m,\n-                                  FLdLongOp f) {\n-        \/\/byte[] vec = vec();\n-        byte[] res = new byte[length()];\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    static byte memorySegmentGet(MemorySegment ms, long o, int i) {\n-        return ms.get(ELEMENT_LAYOUT, o + i * 1L);\n-    }\n-\n-    interface FStOp<M> {\n-        void apply(M memory, int offset, int i, byte a);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> void stOp(M memory, int offset,\n-                  FStOp<M> f) {\n+    <M> void cOp(FCOp<M> f) {\n@@ -406,1 +333,1 @@\n-            f.apply(memory, offset, i, vec[i]);\n+            f.apply(i, vec[i]);\n@@ -413,3 +340,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  VectorMask<Byte> m,\n-                  FStOp<M> f) {\n+    <M> void cOp(VectorMask<Byte> m, FCOp<M> f) {\n@@ -420,1 +345,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(i, vec[i]);\n@@ -425,28 +350,2 @@\n-    interface FStLongOp {\n-        void apply(MemorySegment memory, long offset, int i, byte a);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  FStLongOp f) {\n-        byte[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n-        }\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  VectorMask<Byte> m,\n-                  FStLongOp f) {\n-        byte[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n-            }\n-        }\n+    static byte memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 1L);\n@@ -454,1 +353,0 @@\n-\n@@ -564,2 +462,2 @@\n-                                0, MODE_BROADCAST, vsp,\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+            0, MODE_BROADCAST, vsp,\n+            ((b, s) -> s.nOp(i -> fromBits(b))));\n@@ -1074,1 +972,1 @@\n-   \/**\n+    \/**\n@@ -3017,6 +2915,2 @@\n-     * {@code byte[]},\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code byte[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3027,2 +2921,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3032,5 +2925,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3038,0 +2927,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3039,3 +2930,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3044,1 +2933,0 @@\n-     * @see ByteVector#toIntArray()\n@@ -3049,2 +2937,1 @@\n-                                   byte[] a, int offset,\n-                                   int[] indexMap, int mapOffset) {\n+                                   byte[] a, IntVector offsetMap) {\n@@ -3052,1 +2939,6 @@\n-        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap);\n@@ -3057,7 +2949,37 @@\n-     * {@code byte[]},\n-     * under the control of a mask, and\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code byte[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromArray(VectorSpecies<Byte> species,\n+                                   byte[] a, LongVector offsetMap) {\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code byte[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3069,3 +2991,3 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n-     * Unset lanes in the resulting vector are set to zero.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code byte} (zero).\n@@ -3075,5 +2997,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3082,0 +3000,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3083,3 +3003,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3089,1 +3007,0 @@\n-     * @see ByteVector#toIntArray()\n@@ -3094,2 +3011,43 @@\n-                                   byte[] a, int offset,\n-                                   int[] indexMap, int mapOffset,\n+                                   byte[] a, IntVector offsetMap,\n+                                   VectorMask<Byte> m) {\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code byte[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code byte} (zero).\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromArray(VectorSpecies<Byte> species,\n+                                   byte[] a, LongVector offsetMap,\n@@ -3098,1 +3056,7 @@\n-        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3173,6 +3137,2 @@\n-     * {@code boolean[]},\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code boolean[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3183,2 +3143,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3188,5 +3147,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3194,0 +3149,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3195,3 +3152,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3200,1 +3155,0 @@\n-     * @see ByteVector#toIntArray()\n@@ -3205,3 +3159,1 @@\n-                                          boolean[] a, int offset,\n-                                          int[] indexMap, int mapOffset) {\n-        \/\/ FIXME: optimize\n+                                          boolean[] a, IntVector offsetMap) {\n@@ -3209,1 +3161,6 @@\n-        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.nOp(i -> (byte) (a[offsetMap.lane(i)] ? 1 : 0));\n@@ -3214,7 +3171,37 @@\n-     * {@code boolean[]},\n-     * under the control of a mask, and\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code boolean[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, LongVector offsetMap) {\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.nOp(i -> (byte) (a[(int) offsetMap.lane(i)] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3226,3 +3213,3 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n-     * Unset lanes in the resulting vector are set to zero.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code byte} (zero).\n@@ -3232,5 +3219,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3239,0 +3222,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3240,3 +3225,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3246,1 +3229,0 @@\n-     * @see ByteVector#toIntArray()\n@@ -3251,2 +3233,43 @@\n-                                          boolean[] a, int offset,\n-                                          int[] indexMap, int mapOffset,\n+                                          boolean[] a, IntVector offsetMap,\n+                                          VectorMask<Byte> m) {\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.nOp(m, i -> (byte) (a[offsetMap.lane(i)] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code byte} (zero).\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromBooleanArray(VectorSpecies<Byte> species,\n+                                          boolean[] a, LongVector offsetMap,\n@@ -3254,1 +3277,0 @@\n-        \/\/ FIXME: optimize\n@@ -3256,1 +3278,7 @@\n-        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.nOp(m, i -> (byte) (a[(int) offsetMap.lane(i)] ? 1 : 0));\n@@ -3383,3 +3411,1 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> arr[(int)off + i] = e));\n@@ -3429,5 +3455,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3436,1 +3459,1 @@\n-     * the lane element at index {@code N} is stored into the array\n+     * the lane is stored into the array\n@@ -3438,2 +3461,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3442,3 +3464,3 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3446,3 +3468,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3451,1 +3471,0 @@\n-     * @see ByteVector#toIntArray()\n@@ -3455,7 +3474,37 @@\n-    void intoArray(byte[] a, int offset,\n-                   int[] indexMap, int mapOffset) {\n-        stOp(a, offset,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = e;\n-             });\n+    void intoArray(byte[] a, IntVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap);\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code byte[]}\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(byte[] a, LongVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap);\n@@ -3464,0 +3513,1 @@\n+\n@@ -3465,1 +3515,1 @@\n-     * Scatters this vector into an array of type {@code byte[]},\n+     * Scatters this vector into an array of type {@code byte[]}\n@@ -3467,5 +3517,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3474,2 +3521,2 @@\n-     * if the mask lane at index {@code N} is set then\n-     * the lane element at index {@code N} is stored into the array\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n@@ -3477,2 +3524,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3481,3 +3527,1 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3485,0 +3529,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3486,3 +3532,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3492,1 +3536,0 @@\n-     * @see ByteVector#toIntArray()\n@@ -3496,8 +3539,41 @@\n-    void intoArray(byte[] a, int offset,\n-                   int[] indexMap, int mapOffset,\n-                   VectorMask<Byte> m) {\n-        stOp(a, offset, m,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = e;\n-             });\n+    void intoArray(byte[] a, IntVector offsetMap, VectorMask<Byte> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code byte[]}\n+     * under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(byte[] a, LongVector offsetMap, VectorMask<Byte> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3536,3 +3612,1 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+            (arr, off, v) -> v.cOp((i, e) -> arr[(int)off + i] = (e & 1) != 0));\n@@ -3586,5 +3660,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3593,3 +3664,2 @@\n-     * the lane element at index {@code N}\n-     * is first converted to a {@code boolean} value and then\n-     * stored into the array\n+     * the lane element is first converted to a {@code boolean} value\n+     * and then store into the array\n@@ -3597,2 +3667,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3604,3 +3673,3 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3608,3 +3677,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3613,1 +3680,0 @@\n-     * @see ByteVector#toIntArray()\n@@ -3617,8 +3683,9 @@\n-    void intoBooleanArray(boolean[] a, int offset,\n-                          int[] indexMap, int mapOffset) {\n-        \/\/ FIXME: optimize\n-        stOp(a, offset,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = (e & 1) != 0;\n-             });\n+    void intoBooleanArray(boolean[] a, IntVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        cOp((i, e) -> {\n+            a[offsetMap.lane(i)] = (e & 1) != 0;\n+        });\n@@ -3628,1 +3695,38 @@\n-     * Scatters this vector into an array of type {@code boolean[]},\n+     * Scatters this vector into an array of type {@code boolean[]}\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element is first converted to a {@code boolean} value\n+     * and then store into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, LongVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        cOp((i, e) -> {\n+            a[(int) offsetMap.lane(i)] = (e & 1) != 0;\n+        });\n+    }\n+\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]}\n@@ -3630,5 +3734,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3637,4 +3738,3 @@\n-     * if the mask lane at index {@code N} is set then\n-     * the lane element at index {@code N}\n-     * is first converted to a {@code boolean} value and then\n-     * stored into the array\n+     * if the lane is set in the mask,\n+     * the lane element is first converted to a {@code boolean} value\n+     * and then store into the array\n@@ -3642,2 +3742,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3649,3 +3748,1 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3653,0 +3750,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3654,3 +3753,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3660,1 +3757,0 @@\n-     * @see ByteVector#toIntArray()\n@@ -3664,9 +3760,49 @@\n-    void intoBooleanArray(boolean[] a, int offset,\n-                          int[] indexMap, int mapOffset,\n-                          VectorMask<Byte> m) {\n-        \/\/ FIXME: optimize\n-        stOp(a, offset, m,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = (e & 1) != 0;\n-             });\n+    void intoBooleanArray(boolean[] a, IntVector offsetMap, VectorMask<Byte> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        cOp(m, (i, e) -> {\n+            a[offsetMap.lane(i)] = (e & 1) != 0;\n+        });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]}\n+     * under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane element is first converted to a {@code boolean} value\n+     * and then store into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, LongVector offsetMap, VectorMask<Byte> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        cOp(m, (i, e) -> {\n+            a[(int) offsetMap.lane(i)] = (e & 1) != 0;\n+        });\n@@ -3746,2 +3882,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n-                                    (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s) -> s.nOp(i -> arr[(int)off + i]));\n@@ -3763,2 +3898,20 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n-                                        (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s, vm) -> s.nOp(vm, i -> arr[(int)off + i]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    ByteVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>,\n+     IV extends Vector<IE>,\n+     IE>\n+    ByteVector fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap) {\n+        ByteSpecies vsp = vspecies();\n+        return VectorSupport.<byte[], ByteVector, IV, ByteSpecies, M, Byte, IE>loadWithMap(\n+            vsp.vectorType(), mClass, byte.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 1L, null,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(i -> arr[map.toIntArray()[i]]));\n@@ -3767,0 +3920,18 @@\n+    \/*package-private*\/\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    ByteVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>,\n+     IV extends Vector<IE>,\n+     IE>\n+    ByteVector fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, M m) {\n+        ByteSpecies vsp = vspecies();\n+        return VectorSupport.<byte[], ByteVector, IV, ByteSpecies, M, Byte, IE>loadWithMap(\n+            vsp.vectorType(), mClass, byte.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 1L, m,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(vm, i -> arr[map.toIntArray()[i]]));\n+    }\n@@ -3780,2 +3951,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n-                                    (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+            (arr, off, s) -> s.nOp(i -> (byte) (arr[(int)off + i] ? 1 : 0)));\n@@ -3797,2 +3967,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n-                                        (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+            (arr, off, s, vm) -> s.nOp(vm, i -> (byte) (arr[(int)off + i] ? 1 : 0)));\n@@ -3808,5 +3977,3 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, vsp,\n-                (msp, off, s) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, ByteVector::memorySegmentGet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, vsp,\n+            (msp, off, s) -> s.nOp(i -> memorySegmentGet(msp, off, i)));\n@@ -3824,5 +3991,3 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n-                (msp, off, s, vm) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, ByteVector::memorySegmentGet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n+            (msp, off, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, off, i)));\n@@ -3845,3 +4010,3 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_+i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -3862,3 +4027,3 @@\n-            (arr, off, v, vm)\n-            -> v.stOp(arr, (int) off, vm,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -3867,0 +4032,37 @@\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap) {\n+        ByteSpecies vsp = vspecies();\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, byte.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 1L, null,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp((i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n+    }\n+\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, byte[] a, IV offsetMap, M m) {\n+        ByteSpecies vsp = vspecies();\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, byte.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 1L, m,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n+    }\n@@ -3882,2 +4084,3 @@\n-            -> v.stOp(arr, (int) off, vm,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+            -> v.cOp(vm, (i, e) -> {\n+                arr[(int)off + i] = (e & 1) != 0;\n+            }));\n@@ -3891,6 +4094,4 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v) -> {\n-                    v.stLongOp((MemorySegment) msp, off, ByteVector::memorySegmentSet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            this,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v) -> v.cOp((i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -3908,6 +4109,4 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v, vm) -> {\n-                    v.stLongOp((MemorySegment) msp, off, vm, ByteVector::memorySegmentSet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            this, m,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v, vm) -> v.cOp(vm, (i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -3918,1 +4117,1 @@\n-\n+    @ForceInline\n@@ -3929,0 +4128,1 @@\n+    @ForceInline\n@@ -4142,1 +4342,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (b, s) -> s.nOp(i -> fromBits(b)));\n@@ -4212,75 +4412,0 @@\n-        \/*package-private*\/\n-        final @Override\n-        @ForceInline\n-        ByteVector rvOp(RVOp f) {\n-            byte[] res = new byte[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                byte bits = (byte) f.apply(i);\n-                res[i] = fromBits(bits);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        ByteVector vOp(FVOp f) {\n-            byte[] res = new byte[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        ByteVector vOp(VectorMask<Byte> m, FVOp f) {\n-            byte[] res = new byte[laneCount()];\n-            boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                if (mbits[i]) {\n-                    res[i] = f.apply(i);\n-                }\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> ByteVector ldOp(M memory, int offset,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> ByteVector ldOp(M memory, int offset,\n-                                      VectorMask<Byte> m,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        ByteVector ldLongOp(MemorySegment memory, long offset,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        ByteVector ldLongOp(MemorySegment memory, long offset,\n-                                      VectorMask<Byte> m,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Byte> m,\n-                      FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, m, f);\n-        }\n-\n@@ -4289,2 +4414,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        <M> ByteVector nOp(FNulOp f) {\n+            return dummyVector().nOp(f);\n@@ -4295,4 +4420,2 @@\n-        void stLongOp(MemorySegment memory, long offset,\n-                      AbstractMask<Byte> m,\n-                      FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, m, f);\n+        <M> ByteVector nOp(VectorMask<Byte> m, FNulOp f) {\n+            return dummyVector().nOp(m, f);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":556,"deletions":433,"binary":false,"changes":989,"status":"modified"},{"patch":"@@ -850,2 +850,11 @@\n-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        return super.fromArray0Template(Double128Mask.class, a, offset, indexMap, mapOffset, (Double128Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    DoubleVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap) {\n+        return super.fromArray0Template(Double128Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    DoubleVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, VectorMask<Double> m) {\n+        return super.fromArray0Template(Double128Mask.class, ivClass, ieClass, a, offsetMap, (Double128Mask) m);\n@@ -887,2 +896,11 @@\n-    void intoArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        super.intoArray0Template(Double128Mask.class, a, offset, indexMap, mapOffset, (Double128Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap) {\n+        super.intoArray0Template(Double128Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, VectorMask<Double> m) {\n+        super.intoArray0Template(Double128Mask.class, ivClass, ieClass, a, offsetMap, (Double128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -854,2 +854,11 @@\n-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        return super.fromArray0Template(Double256Mask.class, a, offset, indexMap, mapOffset, (Double256Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    DoubleVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap) {\n+        return super.fromArray0Template(Double256Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    DoubleVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, VectorMask<Double> m) {\n+        return super.fromArray0Template(Double256Mask.class, ivClass, ieClass, a, offsetMap, (Double256Mask) m);\n@@ -891,2 +900,11 @@\n-    void intoArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        super.intoArray0Template(Double256Mask.class, a, offset, indexMap, mapOffset, (Double256Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap) {\n+        super.intoArray0Template(Double256Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, VectorMask<Double> m) {\n+        super.intoArray0Template(Double256Mask.class, ivClass, ieClass, a, offsetMap, (Double256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -862,2 +862,11 @@\n-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        return super.fromArray0Template(Double512Mask.class, a, offset, indexMap, mapOffset, (Double512Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    DoubleVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap) {\n+        return super.fromArray0Template(Double512Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    DoubleVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, VectorMask<Double> m) {\n+        return super.fromArray0Template(Double512Mask.class, ivClass, ieClass, a, offsetMap, (Double512Mask) m);\n@@ -899,2 +908,11 @@\n-    void intoArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        super.intoArray0Template(Double512Mask.class, a, offset, indexMap, mapOffset, (Double512Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap) {\n+        super.intoArray0Template(Double512Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, VectorMask<Double> m) {\n+        super.intoArray0Template(Double512Mask.class, ivClass, ieClass, a, offsetMap, (Double512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -848,2 +848,11 @@\n-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        return super.fromArray0Template(Double64Mask.class, a, offset, indexMap, mapOffset, (Double64Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    DoubleVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap) {\n+        return super.fromArray0Template(Double64Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    DoubleVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, VectorMask<Double> m) {\n+        return super.fromArray0Template(Double64Mask.class, ivClass, ieClass, a, offsetMap, (Double64Mask) m);\n@@ -885,2 +894,11 @@\n-    void intoArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        super.intoArray0Template(Double64Mask.class, a, offset, indexMap, mapOffset, (Double64Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap) {\n+        super.intoArray0Template(Double64Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, VectorMask<Double> m) {\n+        super.intoArray0Template(Double64Mask.class, ivClass, ieClass, a, offsetMap, (Double64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -847,2 +847,11 @@\n-    DoubleVector fromArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        return super.fromArray0Template(DoubleMaxMask.class, a, offset, indexMap, mapOffset, (DoubleMaxMask) m);\n+    <IV extends Vector<IE>, IE>\n+    DoubleVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap) {\n+        return super.fromArray0Template(DoubleMaxMask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    DoubleVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, VectorMask<Double> m) {\n+        return super.fromArray0Template(DoubleMaxMask.class, ivClass, ieClass, a, offsetMap, (DoubleMaxMask) m);\n@@ -884,2 +893,11 @@\n-    void intoArray0(double[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Double> m) {\n-        super.intoArray0Template(DoubleMaxMask.class, a, offset, indexMap, mapOffset, (DoubleMaxMask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap) {\n+        super.intoArray0Template(DoubleMaxMask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, VectorMask<Double> m) {\n+        super.intoArray0Template(DoubleMaxMask.class, ivClass, ieClass, a, offsetMap, (DoubleMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -119,2 +119,4 @@\n-    \/\/ Constant loader (takes dummy as vector arg)\n-    interface FVOp {\n+    \/\/ Nullary operator\n+\n+    \/*package-private*\/\n+    interface FNulOp {\n@@ -127,1 +129,1 @@\n-    DoubleVector vOp(FVOp f) {\n+    DoubleVector nOp(FNulOp f) {\n@@ -137,1 +139,1 @@\n-    DoubleVector vOp(VectorMask<Double> m, FVOp f) {\n+    DoubleVector nOp(VectorMask<Double> m, FNulOp f) {\n@@ -319,71 +321,1 @@\n-    \/\/ Memory reference\n-\n-    \/*package-private*\/\n-    interface FLdOp<M> {\n-        double apply(M memory, int offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> DoubleVector ldOp(M memory, int offset,\n-                                  FLdOp<M> f) {\n-        \/\/dummy; no vec = vec();\n-        double[] res = new double[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> DoubleVector ldOp(M memory, int offset,\n-                                  VectorMask<Double> m,\n-                                  FLdOp<M> f) {\n-        \/\/double[] vec = vec();\n-        double[] res = new double[length()];\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    interface FLdLongOp {\n-        double apply(MemorySegment memory, long offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    DoubleVector ldLongOp(MemorySegment memory, long offset,\n-                                  FLdLongOp f) {\n-        \/\/dummy; no vec = vec();\n-        double[] res = new double[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    DoubleVector ldLongOp(MemorySegment memory, long offset,\n-                                  VectorMask<Double> m,\n-                                  FLdLongOp f) {\n-        \/\/double[] vec = vec();\n-        double[] res = new double[length()];\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n+    \/\/ Consume operator\n@@ -391,6 +323,2 @@\n-    static double memorySegmentGet(MemorySegment ms, long o, int i) {\n-        return ms.get(ELEMENT_LAYOUT, o + i * 8L);\n-    }\n-\n-    interface FStOp<M> {\n-        void apply(M memory, int offset, int i, double a);\n+    interface FCOp<M> {\n+        void apply(int i, double a);\n@@ -402,2 +330,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  FStOp<M> f) {\n+    <M> void cOp(FCOp<M> f) {\n@@ -406,1 +333,1 @@\n-            f.apply(memory, offset, i, vec[i]);\n+            f.apply(i, vec[i]);\n@@ -413,3 +340,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  VectorMask<Double> m,\n-                  FStOp<M> f) {\n+    <M> void cOp(VectorMask<Double> m, FCOp<M> f) {\n@@ -420,1 +345,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(i, vec[i]);\n@@ -425,28 +350,2 @@\n-    interface FStLongOp {\n-        void apply(MemorySegment memory, long offset, int i, double a);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  FStLongOp f) {\n-        double[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n-        }\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  VectorMask<Double> m,\n-                  FStLongOp f) {\n-        double[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n-            }\n-        }\n+    static double memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 8L);\n@@ -454,1 +353,0 @@\n-\n@@ -553,2 +451,2 @@\n-                        toBits(0.0f), MODE_BROADCAST, vsp,\n-                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+            0, MODE_BROADCAST, vsp,\n+            ((b, s) -> s.nOp(i -> fromBits(b))));\n@@ -956,1 +854,1 @@\n-   \/**\n+    \/**\n@@ -2815,6 +2713,2 @@\n-     * {@code double[]},\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code double[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -2825,2 +2719,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -2830,5 +2723,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -2836,0 +2725,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -2837,3 +2728,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -2842,1 +2731,0 @@\n-     * @see DoubleVector#toIntArray()\n@@ -2847,2 +2735,1 @@\n-                                   double[] a, int offset,\n-                                   int[] indexMap, int mapOffset) {\n+                                   double[] a, IntVector offsetMap) {\n@@ -2850,26 +2737,2 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        Class<? extends DoubleVector> vectorType = vsp.vectorType();\n-\n-        if (vsp.laneCount() == 1) {\n-          return DoubleVector.fromArray(vsp, a, offset + indexMap[mapOffset]);\n-        }\n-\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For DoubleMaxVector,  if vector length is non-power-of-two or\n-            \/\/ 2048 bits, indexShape of Double species is S_MAX_BIT.\n-            \/\/ Assume that vector length is 2048, then the lane count of Double\n-            \/\/ vector is 32. When converting Double species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n@@ -2878,1 +2741,33 @@\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code double[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    DoubleVector fromArray(VectorSpecies<Double> species,\n+                                   double[] a, LongVector offsetMap) {\n+        DoubleSpecies vsp = (DoubleSpecies) species;\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n@@ -2880,7 +2775,2 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, null, double.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap);\n@@ -2891,7 +2781,3 @@\n-     * {@code double[]},\n-     * under the control of a mask, and\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code double[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -2903,3 +2789,3 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n-     * Unset lanes in the resulting vector are set to zero.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code double} (positive zero).\n@@ -2909,5 +2795,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -2916,0 +2798,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -2917,3 +2801,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -2923,1 +2805,0 @@\n-     * @see DoubleVector#toIntArray()\n@@ -2928,2 +2809,1 @@\n-                                   double[] a, int offset,\n-                                   int[] indexMap, int mapOffset,\n+                                   double[] a, IntVector offsetMap,\n@@ -2931,2 +2811,4 @@\n-        if (m.allTrue()) {\n-            return fromArray(species, a, offset, indexMap, mapOffset);\n+        DoubleSpecies vsp = (DoubleSpecies) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n@@ -2934,3 +2816,41 @@\n-        else {\n-            DoubleSpecies vsp = (DoubleSpecies) species;\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code double[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code double} (positive zero).\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    DoubleVector fromArray(VectorSpecies<Double> species,\n+                                   double[] a, LongVector offsetMap,\n+                                   VectorMask<Double> m) {\n+        DoubleSpecies vsp = (DoubleSpecies) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n@@ -2938,0 +2858,3 @@\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3071,3 +2994,1 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> arr[(int)off + i] = e));\n@@ -3117,5 +3038,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3124,1 +3042,1 @@\n-     * the lane element at index {@code N} is stored into the array\n+     * the lane is stored into the array\n@@ -3126,2 +3044,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3130,3 +3047,3 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3134,3 +3051,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3139,1 +3054,0 @@\n-     * @see DoubleVector#toIntArray()\n@@ -3143,25 +3057,3 @@\n-    void intoArray(double[] a, int offset,\n-                   int[] indexMap, int mapOffset) {\n-        DoubleSpecies vsp = vspecies();\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        if (vsp.laneCount() == 1) {\n-            intoArray(a, offset + indexMap[mapOffset]);\n-            return;\n-        }\n-\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For DoubleMaxVector,  if vector length  is 2048 bits, indexShape\n-            \/\/ of Double species is S_MAX_BIT. and the lane count of Double\n-            \/\/ vector is 32. When converting Double species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n+    void intoArray(double[] a, IntVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n@@ -3170,0 +3062,3 @@\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap);\n+    }\n@@ -3171,1 +3066,25 @@\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+    \/**\n+     * Scatters this vector into an array of type {@code double[]}\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(double[] a, LongVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n@@ -3173,12 +3092,2 @@\n-        VectorSupport.storeWithMap(\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n-            isp.vectorType(),\n-            a, arrayAddress(a, 0), vix,\n-            this, null,\n-            a, offset, indexMap, mapOffset,\n-            (arr, off, v, map, mo, vm)\n-            -> v.stOp(arr, off,\n-                      (arr_, off_, i, e) -> {\n-                          int j = map[mo + i];\n-                          arr[off + j] = e;\n-                      }));\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap);\n@@ -3187,0 +3096,1 @@\n+\n@@ -3188,1 +3098,1 @@\n-     * Scatters this vector into an array of type {@code double[]},\n+     * Scatters this vector into an array of type {@code double[]}\n@@ -3190,5 +3100,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3197,2 +3104,2 @@\n-     * if the mask lane at index {@code N} is set then\n-     * the lane element at index {@code N} is stored into the array\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n@@ -3200,2 +3107,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3204,3 +3110,1 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3208,0 +3112,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3209,3 +3115,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3215,1 +3119,0 @@\n-     * @see DoubleVector#toIntArray()\n@@ -3219,5 +3122,3 @@\n-    void intoArray(double[] a, int offset,\n-                   int[] indexMap, int mapOffset,\n-                   VectorMask<Double> m) {\n-        if (m.allTrue()) {\n-            intoArray(a, offset, indexMap, mapOffset);\n+    void intoArray(double[] a, IntVector offsetMap, VectorMask<Double> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n@@ -3225,2 +3126,33 @@\n-        else {\n-            intoArray0(a, offset, indexMap, mapOffset, m);\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code double[]}\n+     * under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(double[] a, LongVector offsetMap, VectorMask<Double> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n@@ -3228,0 +3160,3 @@\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3303,2 +3238,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n-                                    (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s) -> s.nOp(i -> arr[(int)off + i]));\n@@ -3320,2 +3254,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n-                                        (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s, vm) -> s.nOp(vm, i -> arr[(int)off + i]));\n@@ -3326,3 +3259,2 @@\n-    DoubleVector fromArray0(double[] a, int offset,\n-                                    int[] indexMap, int mapOffset,\n-                                    VectorMask<Double> m);\n+    <IV extends Vector<IE>, IE>\n+    DoubleVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap);\n@@ -3331,3 +3263,4 @@\n-    <M extends VectorMask<Double>>\n-    DoubleVector fromArray0Template(Class<M> maskClass, double[] a, int offset,\n-                                            int[] indexMap, int mapOffset, M m) {\n+    <M extends VectorMask<Double>,\n+     IV extends Vector<IE>,\n+     IE>\n+    DoubleVector fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap) {\n@@ -3335,31 +3268,7 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        m.check(vsp);\n-        Class<? extends DoubleVector> vectorType = vsp.vectorType();\n-\n-        if (vsp.laneCount() == 1) {\n-          return DoubleVector.fromArray(vsp, a, offset + indexMap[mapOffset], m);\n-        }\n-\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For DoubleMaxVector,  if vector length is non-power-of-two or\n-            \/\/ 2048 bits, indexShape of Double species is S_MAX_BIT.\n-            \/\/ Assume that vector length is 2048, then the lane count of Double\n-            \/\/ vector is 32. When converting Double species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n-        }\n-\n-        \/\/ FIXME: Check index under mask controlling.\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        return VectorSupport.<double[], DoubleVector, IV, DoubleSpecies, M, Double, IE>loadWithMap(\n+            vsp.vectorType(), mClass, double.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 8L, null,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(i -> arr[map.toIntArray()[i]]));\n+    }\n@@ -3367,7 +3276,17 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, maskClass, double.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+    \/*package-private*\/\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    DoubleVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, VectorMask<Double> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>,\n+     IV extends Vector<IE>,\n+     IE>\n+    DoubleVector fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, M m) {\n+        DoubleSpecies vsp = vspecies();\n+        return VectorSupport.<double[], DoubleVector, IV, DoubleSpecies, M, Double, IE>loadWithMap(\n+            vsp.vectorType(), mClass, double.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 8L, m,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(vm, i -> arr[map.toIntArray()[i]]));\n@@ -3385,5 +3304,3 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, vsp,\n-                (msp, off, s) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, DoubleVector::memorySegmentGet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, vsp,\n+            (msp, off, s) -> s.nOp(i -> memorySegmentGet(msp, off, i)));\n@@ -3401,5 +3318,3 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n-                (msp, off, s, vm) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, DoubleVector::memorySegmentGet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n+            (msp, off, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, off, i)));\n@@ -3422,3 +3337,3 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_+i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -3439,3 +3354,3 @@\n-            (arr, off, v, vm)\n-            -> v.stOp(arr, (int) off, vm,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -3445,3 +3360,2 @@\n-    void intoArray0(double[] a, int offset,\n-                    int[] indexMap, int mapOffset,\n-                    VectorMask<Double> m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap);\n@@ -3450,4 +3364,4 @@\n-    <M extends VectorMask<Double>>\n-    void intoArray0Template(Class<M> maskClass, double[] a, int offset,\n-                            int[] indexMap, int mapOffset, M m) {\n-        m.check(species());\n+    <M extends VectorMask<Double>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap) {\n@@ -3455,27 +3369,8 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        if (vsp.laneCount() == 1) {\n-            intoArray(a, offset + indexMap[mapOffset], m);\n-            return;\n-        }\n-\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For DoubleMaxVector,  if vector length  is 2048 bits, indexShape\n-            \/\/ of Double species is S_MAX_BIT. and the lane count of Double\n-            \/\/ vector is 32. When converting Double species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n-        }\n-\n-\n-        \/\/ FIXME: Check index under mask controlling.\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, double.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 8L, null,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp((i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n+    }\n@@ -3483,12 +3378,17 @@\n-        VectorSupport.storeWithMap(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            isp.vectorType(),\n-            a, arrayAddress(a, 0), vix,\n-            this, m,\n-            a, offset, indexMap, mapOffset,\n-            (arr, off, v, map, mo, vm)\n-            -> v.stOp(arr, off, vm,\n-                      (arr_, off_, i, e) -> {\n-                          int j = map[mo + i];\n-                          arr[off + j] = e;\n-                      }));\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, VectorMask<Double> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, double[] a, IV offsetMap, M m) {\n+        DoubleSpecies vsp = vspecies();\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, double.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 8L, m,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n@@ -3503,6 +3403,4 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v) -> {\n-                    v.stLongOp((MemorySegment) msp, off, DoubleVector::memorySegmentSet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            this,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v) -> v.cOp((i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -3520,6 +3418,4 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v, vm) -> {\n-                    v.stLongOp((MemorySegment) msp, off, vm, DoubleVector::memorySegmentSet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            this, m,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v, vm) -> v.cOp(vm, (i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -3530,1 +3426,1 @@\n-\n+    @ForceInline\n@@ -3541,0 +3437,1 @@\n+    @ForceInline\n@@ -3745,1 +3642,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (b, s) -> s.nOp(i -> fromBits(b)));\n@@ -3815,75 +3712,0 @@\n-        \/*package-private*\/\n-        final @Override\n-        @ForceInline\n-        DoubleVector rvOp(RVOp f) {\n-            double[] res = new double[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                long bits = (long) f.apply(i);\n-                res[i] = fromBits(bits);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        DoubleVector vOp(FVOp f) {\n-            double[] res = new double[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        DoubleVector vOp(VectorMask<Double> m, FVOp f) {\n-            double[] res = new double[laneCount()];\n-            boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                if (mbits[i]) {\n-                    res[i] = f.apply(i);\n-                }\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> DoubleVector ldOp(M memory, int offset,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> DoubleVector ldOp(M memory, int offset,\n-                                      VectorMask<Double> m,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        DoubleVector ldLongOp(MemorySegment memory, long offset,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        DoubleVector ldLongOp(MemorySegment memory, long offset,\n-                                      VectorMask<Double> m,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Double> m,\n-                      FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, m, f);\n-        }\n-\n@@ -3892,2 +3714,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        <M> DoubleVector nOp(FNulOp f) {\n+            return dummyVector().nOp(f);\n@@ -3898,4 +3720,2 @@\n-        void stLongOp(MemorySegment memory, long offset,\n-                      AbstractMask<Double> m,\n-                      FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, m, f);\n+        <M> DoubleVector nOp(VectorMask<Double> m, FNulOp f) {\n+            return dummyVector().nOp(m, f);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":304,"deletions":484,"binary":false,"changes":788,"status":"modified"},{"patch":"@@ -854,2 +854,11 @@\n-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        return super.fromArray0Template(Float128Mask.class, a, offset, indexMap, mapOffset, (Float128Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    FloatVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap) {\n+        return super.fromArray0Template(Float128Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    FloatVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, VectorMask<Float> m) {\n+        return super.fromArray0Template(Float128Mask.class, ivClass, ieClass, a, offsetMap, (Float128Mask) m);\n@@ -891,2 +900,11 @@\n-    void intoArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        super.intoArray0Template(Float128Mask.class, a, offset, indexMap, mapOffset, (Float128Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap) {\n+        super.intoArray0Template(Float128Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, VectorMask<Float> m) {\n+        super.intoArray0Template(Float128Mask.class, ivClass, ieClass, a, offsetMap, (Float128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -862,2 +862,11 @@\n-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        return super.fromArray0Template(Float256Mask.class, a, offset, indexMap, mapOffset, (Float256Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    FloatVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap) {\n+        return super.fromArray0Template(Float256Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    FloatVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, VectorMask<Float> m) {\n+        return super.fromArray0Template(Float256Mask.class, ivClass, ieClass, a, offsetMap, (Float256Mask) m);\n@@ -899,2 +908,11 @@\n-    void intoArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        super.intoArray0Template(Float256Mask.class, a, offset, indexMap, mapOffset, (Float256Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap) {\n+        super.intoArray0Template(Float256Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, VectorMask<Float> m) {\n+        super.intoArray0Template(Float256Mask.class, ivClass, ieClass, a, offsetMap, (Float256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -878,2 +878,11 @@\n-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        return super.fromArray0Template(Float512Mask.class, a, offset, indexMap, mapOffset, (Float512Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    FloatVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap) {\n+        return super.fromArray0Template(Float512Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    FloatVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, VectorMask<Float> m) {\n+        return super.fromArray0Template(Float512Mask.class, ivClass, ieClass, a, offsetMap, (Float512Mask) m);\n@@ -915,2 +924,11 @@\n-    void intoArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        super.intoArray0Template(Float512Mask.class, a, offset, indexMap, mapOffset, (Float512Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap) {\n+        super.intoArray0Template(Float512Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, VectorMask<Float> m) {\n+        super.intoArray0Template(Float512Mask.class, ivClass, ieClass, a, offsetMap, (Float512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -850,2 +850,11 @@\n-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        return super.fromArray0Template(Float64Mask.class, a, offset, indexMap, mapOffset, (Float64Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    FloatVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap) {\n+        return super.fromArray0Template(Float64Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    FloatVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, VectorMask<Float> m) {\n+        return super.fromArray0Template(Float64Mask.class, ivClass, ieClass, a, offsetMap, (Float64Mask) m);\n@@ -887,2 +896,11 @@\n-    void intoArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        super.intoArray0Template(Float64Mask.class, a, offset, indexMap, mapOffset, (Float64Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap) {\n+        super.intoArray0Template(Float64Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, VectorMask<Float> m) {\n+        super.intoArray0Template(Float64Mask.class, ivClass, ieClass, a, offsetMap, (Float64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -847,2 +847,11 @@\n-    FloatVector fromArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        return super.fromArray0Template(FloatMaxMask.class, a, offset, indexMap, mapOffset, (FloatMaxMask) m);\n+    <IV extends Vector<IE>, IE>\n+    FloatVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap) {\n+        return super.fromArray0Template(FloatMaxMask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    FloatVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, VectorMask<Float> m) {\n+        return super.fromArray0Template(FloatMaxMask.class, ivClass, ieClass, a, offsetMap, (FloatMaxMask) m);\n@@ -884,2 +893,11 @@\n-    void intoArray0(float[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Float> m) {\n-        super.intoArray0Template(FloatMaxMask.class, a, offset, indexMap, mapOffset, (FloatMaxMask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap) {\n+        super.intoArray0Template(FloatMaxMask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, VectorMask<Float> m) {\n+        super.intoArray0Template(FloatMaxMask.class, ivClass, ieClass, a, offsetMap, (FloatMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -119,2 +119,4 @@\n-    \/\/ Constant loader (takes dummy as vector arg)\n-    interface FVOp {\n+    \/\/ Nullary operator\n+\n+    \/*package-private*\/\n+    interface FNulOp {\n@@ -127,1 +129,1 @@\n-    FloatVector vOp(FVOp f) {\n+    FloatVector nOp(FNulOp f) {\n@@ -137,1 +139,1 @@\n-    FloatVector vOp(VectorMask<Float> m, FVOp f) {\n+    FloatVector nOp(VectorMask<Float> m, FNulOp f) {\n@@ -319,71 +321,1 @@\n-    \/\/ Memory reference\n-\n-    \/*package-private*\/\n-    interface FLdOp<M> {\n-        float apply(M memory, int offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> FloatVector ldOp(M memory, int offset,\n-                                  FLdOp<M> f) {\n-        \/\/dummy; no vec = vec();\n-        float[] res = new float[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> FloatVector ldOp(M memory, int offset,\n-                                  VectorMask<Float> m,\n-                                  FLdOp<M> f) {\n-        \/\/float[] vec = vec();\n-        float[] res = new float[length()];\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    interface FLdLongOp {\n-        float apply(MemorySegment memory, long offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    FloatVector ldLongOp(MemorySegment memory, long offset,\n-                                  FLdLongOp f) {\n-        \/\/dummy; no vec = vec();\n-        float[] res = new float[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    FloatVector ldLongOp(MemorySegment memory, long offset,\n-                                  VectorMask<Float> m,\n-                                  FLdLongOp f) {\n-        \/\/float[] vec = vec();\n-        float[] res = new float[length()];\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n+    \/\/ Consume operator\n@@ -391,6 +323,2 @@\n-    static float memorySegmentGet(MemorySegment ms, long o, int i) {\n-        return ms.get(ELEMENT_LAYOUT, o + i * 4L);\n-    }\n-\n-    interface FStOp<M> {\n-        void apply(M memory, int offset, int i, float a);\n+    interface FCOp<M> {\n+        void apply(int i, float a);\n@@ -402,2 +330,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  FStOp<M> f) {\n+    <M> void cOp(FCOp<M> f) {\n@@ -406,1 +333,1 @@\n-            f.apply(memory, offset, i, vec[i]);\n+            f.apply(i, vec[i]);\n@@ -413,3 +340,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  VectorMask<Float> m,\n-                  FStOp<M> f) {\n+    <M> void cOp(VectorMask<Float> m, FCOp<M> f) {\n@@ -420,1 +345,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(i, vec[i]);\n@@ -425,28 +350,2 @@\n-    interface FStLongOp {\n-        void apply(MemorySegment memory, long offset, int i, float a);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  FStLongOp f) {\n-        float[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n-        }\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  VectorMask<Float> m,\n-                  FStLongOp f) {\n-        float[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n-            }\n-        }\n+    static float memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 4L);\n@@ -454,1 +353,0 @@\n-\n@@ -553,2 +451,2 @@\n-                        toBits(0.0f), MODE_BROADCAST, vsp,\n-                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+            0, MODE_BROADCAST, vsp,\n+            ((b, s) -> s.nOp(i -> fromBits(b))));\n@@ -956,1 +854,1 @@\n-   \/**\n+    \/**\n@@ -2839,6 +2737,2 @@\n-     * {@code float[]},\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code float[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -2849,2 +2743,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -2854,5 +2747,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -2860,0 +2749,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -2861,3 +2752,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -2866,1 +2755,0 @@\n-     * @see FloatVector#toIntArray()\n@@ -2871,2 +2759,1 @@\n-                                   float[] a, int offset,\n-                                   int[] indexMap, int mapOffset) {\n+                                   float[] a, IntVector offsetMap) {\n@@ -2874,4 +2761,3 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        Class<? extends FloatVector> vectorType = vsp.vectorType();\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n@@ -2879,4 +2765,3 @@\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap);\n+    }\n@@ -2884,1 +2769,29 @@\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code float[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    FloatVector fromArray(VectorSpecies<Float> species,\n+                                   float[] a, LongVector offsetMap) {\n+        FloatSpecies vsp = (FloatSpecies) species;\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n@@ -2886,7 +2799,2 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, null, float.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap);\n@@ -2897,7 +2805,3 @@\n-     * {@code float[]},\n-     * under the control of a mask, and\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code float[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -2909,3 +2813,3 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n-     * Unset lanes in the resulting vector are set to zero.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code float} (positive zero).\n@@ -2915,5 +2819,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -2922,0 +2822,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -2923,3 +2825,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -2929,1 +2829,0 @@\n-     * @see FloatVector#toIntArray()\n@@ -2934,2 +2833,1 @@\n-                                   float[] a, int offset,\n-                                   int[] indexMap, int mapOffset,\n+                                   float[] a, IntVector offsetMap,\n@@ -2937,2 +2835,4 @@\n-        if (m.allTrue()) {\n-            return fromArray(species, a, offset, indexMap, mapOffset);\n+        FloatSpecies vsp = (FloatSpecies) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n@@ -2940,3 +2840,41 @@\n-        else {\n-            FloatSpecies vsp = (FloatSpecies) species;\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code float[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code float} (positive zero).\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    FloatVector fromArray(VectorSpecies<Float> species,\n+                                   float[] a, LongVector offsetMap,\n+                                   VectorMask<Float> m) {\n+        FloatSpecies vsp = (FloatSpecies) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n@@ -2944,0 +2882,3 @@\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3077,3 +3018,1 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> arr[(int)off + i] = e));\n@@ -3123,5 +3062,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3130,1 +3066,1 @@\n-     * the lane element at index {@code N} is stored into the array\n+     * the lane is stored into the array\n@@ -3132,2 +3068,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3136,3 +3071,3 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3140,3 +3075,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3145,1 +3078,0 @@\n-     * @see FloatVector#toIntArray()\n@@ -3149,23 +3081,7 @@\n-    void intoArray(float[] a, int offset,\n-                   int[] indexMap, int mapOffset) {\n-        FloatSpecies vsp = vspecies();\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n-\n-        VectorSupport.storeWithMap(\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n-            isp.vectorType(),\n-            a, arrayAddress(a, 0), vix,\n-            this, null,\n-            a, offset, indexMap, mapOffset,\n-            (arr, off, v, map, mo, vm)\n-            -> v.stOp(arr, off,\n-                      (arr_, off_, i, e) -> {\n-                          int j = map[mo + i];\n-                          arr[off + j] = e;\n-                      }));\n+    void intoArray(float[] a, IntVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap);\n@@ -3175,1 +3091,32 @@\n-     * Scatters this vector into an array of type {@code float[]},\n+     * Scatters this vector into an array of type {@code float[]}\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(float[] a, LongVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap);\n+    }\n+\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code float[]}\n@@ -3177,5 +3124,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3184,2 +3128,2 @@\n-     * if the mask lane at index {@code N} is set then\n-     * the lane element at index {@code N} is stored into the array\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n@@ -3187,2 +3131,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3191,3 +3134,1 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3195,0 +3136,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3196,3 +3139,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3202,1 +3143,0 @@\n-     * @see FloatVector#toIntArray()\n@@ -3206,5 +3146,3 @@\n-    void intoArray(float[] a, int offset,\n-                   int[] indexMap, int mapOffset,\n-                   VectorMask<Float> m) {\n-        if (m.allTrue()) {\n-            intoArray(a, offset, indexMap, mapOffset);\n+    void intoArray(float[] a, IntVector offsetMap, VectorMask<Float> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n@@ -3212,2 +3150,33 @@\n-        else {\n-            intoArray0(a, offset, indexMap, mapOffset, m);\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code float[]}\n+     * under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(float[] a, LongVector offsetMap, VectorMask<Float> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n@@ -3215,0 +3184,3 @@\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3290,2 +3262,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n-                                    (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s) -> s.nOp(i -> arr[(int)off + i]));\n@@ -3307,2 +3278,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n-                                        (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s, vm) -> s.nOp(vm, i -> arr[(int)off + i]));\n@@ -3313,3 +3283,2 @@\n-    FloatVector fromArray0(float[] a, int offset,\n-                                    int[] indexMap, int mapOffset,\n-                                    VectorMask<Float> m);\n+    <IV extends Vector<IE>, IE>\n+    FloatVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap);\n@@ -3318,3 +3287,4 @@\n-    <M extends VectorMask<Float>>\n-    FloatVector fromArray0Template(Class<M> maskClass, float[] a, int offset,\n-                                            int[] indexMap, int mapOffset, M m) {\n+    <M extends VectorMask<Float>,\n+     IV extends Vector<IE>,\n+     IE>\n+    FloatVector fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap) {\n@@ -3322,13 +3292,7 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        m.check(vsp);\n-        Class<? extends FloatVector> vectorType = vsp.vectorType();\n-\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-\n-        \/\/ FIXME: Check index under mask controlling.\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        return VectorSupport.<float[], FloatVector, IV, FloatSpecies, M, Float, IE>loadWithMap(\n+            vsp.vectorType(), mClass, float.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 4L, null,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(i -> arr[map.toIntArray()[i]]));\n+    }\n@@ -3336,7 +3300,17 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, maskClass, float.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+    \/*package-private*\/\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    FloatVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, VectorMask<Float> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>,\n+     IV extends Vector<IE>,\n+     IE>\n+    FloatVector fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, M m) {\n+        FloatSpecies vsp = vspecies();\n+        return VectorSupport.<float[], FloatVector, IV, FloatSpecies, M, Float, IE>loadWithMap(\n+            vsp.vectorType(), mClass, float.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 4L, m,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(vm, i -> arr[map.toIntArray()[i]]));\n@@ -3354,5 +3328,3 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, vsp,\n-                (msp, off, s) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, FloatVector::memorySegmentGet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, vsp,\n+            (msp, off, s) -> s.nOp(i -> memorySegmentGet(msp, off, i)));\n@@ -3370,5 +3342,3 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n-                (msp, off, s, vm) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, FloatVector::memorySegmentGet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n+            (msp, off, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, off, i)));\n@@ -3391,3 +3361,3 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_+i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -3408,3 +3378,3 @@\n-            (arr, off, v, vm)\n-            -> v.stOp(arr, (int) off, vm,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -3414,3 +3384,2 @@\n-    void intoArray0(float[] a, int offset,\n-                    int[] indexMap, int mapOffset,\n-                    VectorMask<Float> m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap);\n@@ -3419,4 +3388,4 @@\n-    <M extends VectorMask<Float>>\n-    void intoArray0Template(Class<M> maskClass, float[] a, int offset,\n-                            int[] indexMap, int mapOffset, M m) {\n-        m.check(species());\n+    <M extends VectorMask<Float>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap) {\n@@ -3424,8 +3393,8 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-\n-        \/\/ FIXME: Check index under mask controlling.\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, float.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 4L, null,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp((i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n+    }\n@@ -3433,12 +3402,17 @@\n-        VectorSupport.storeWithMap(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            isp.vectorType(),\n-            a, arrayAddress(a, 0), vix,\n-            this, m,\n-            a, offset, indexMap, mapOffset,\n-            (arr, off, v, map, mo, vm)\n-            -> v.stOp(arr, off, vm,\n-                      (arr_, off_, i, e) -> {\n-                          int j = map[mo + i];\n-                          arr[off + j] = e;\n-                      }));\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, VectorMask<Float> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, float[] a, IV offsetMap, M m) {\n+        FloatSpecies vsp = vspecies();\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, float.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 4L, m,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n@@ -3453,6 +3427,4 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v) -> {\n-                    v.stLongOp((MemorySegment) msp, off, FloatVector::memorySegmentSet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            this,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v) -> v.cOp((i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -3470,6 +3442,4 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v, vm) -> {\n-                    v.stLongOp((MemorySegment) msp, off, vm, FloatVector::memorySegmentSet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            this, m,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v, vm) -> v.cOp(vm, (i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -3480,1 +3450,1 @@\n-\n+    @ForceInline\n@@ -3491,0 +3461,1 @@\n+    @ForceInline\n@@ -3695,1 +3666,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (b, s) -> s.nOp(i -> fromBits(b)));\n@@ -3765,75 +3736,0 @@\n-        \/*package-private*\/\n-        final @Override\n-        @ForceInline\n-        FloatVector rvOp(RVOp f) {\n-            float[] res = new float[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                int bits = (int) f.apply(i);\n-                res[i] = fromBits(bits);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        FloatVector vOp(FVOp f) {\n-            float[] res = new float[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        FloatVector vOp(VectorMask<Float> m, FVOp f) {\n-            float[] res = new float[laneCount()];\n-            boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                if (mbits[i]) {\n-                    res[i] = f.apply(i);\n-                }\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> FloatVector ldOp(M memory, int offset,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> FloatVector ldOp(M memory, int offset,\n-                                      VectorMask<Float> m,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        FloatVector ldLongOp(MemorySegment memory, long offset,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        FloatVector ldLongOp(MemorySegment memory, long offset,\n-                                      VectorMask<Float> m,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Float> m,\n-                      FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, m, f);\n-        }\n-\n@@ -3842,2 +3738,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        <M> FloatVector nOp(FNulOp f) {\n+            return dummyVector().nOp(f);\n@@ -3848,4 +3744,2 @@\n-        void stLongOp(MemorySegment memory, long offset,\n-                      AbstractMask<Float> m,\n-                      FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, m, f);\n+        <M> FloatVector nOp(VectorMask<Float> m, FNulOp f) {\n+            return dummyVector().nOp(m, f);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":308,"deletions":414,"binary":false,"changes":722,"status":"modified"},{"patch":"@@ -865,2 +865,11 @@\n-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        return super.fromArray0Template(Int128Mask.class, a, offset, indexMap, mapOffset, (Int128Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    IntVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap) {\n+        return super.fromArray0Template(Int128Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    IntVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, VectorMask<Integer> m) {\n+        return super.fromArray0Template(Int128Mask.class, ivClass, ieClass, a, offsetMap, (Int128Mask) m);\n@@ -902,2 +911,11 @@\n-    void intoArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        super.intoArray0Template(Int128Mask.class, a, offset, indexMap, mapOffset, (Int128Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap) {\n+        super.intoArray0Template(Int128Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, VectorMask<Integer> m) {\n+        super.intoArray0Template(Int128Mask.class, ivClass, ieClass, a, offsetMap, (Int128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -873,2 +873,11 @@\n-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        return super.fromArray0Template(Int256Mask.class, a, offset, indexMap, mapOffset, (Int256Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    IntVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap) {\n+        return super.fromArray0Template(Int256Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    IntVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, VectorMask<Integer> m) {\n+        return super.fromArray0Template(Int256Mask.class, ivClass, ieClass, a, offsetMap, (Int256Mask) m);\n@@ -910,2 +919,11 @@\n-    void intoArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        super.intoArray0Template(Int256Mask.class, a, offset, indexMap, mapOffset, (Int256Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap) {\n+        super.intoArray0Template(Int256Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, VectorMask<Integer> m) {\n+        super.intoArray0Template(Int256Mask.class, ivClass, ieClass, a, offsetMap, (Int256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -889,2 +889,11 @@\n-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        return super.fromArray0Template(Int512Mask.class, a, offset, indexMap, mapOffset, (Int512Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    IntVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap) {\n+        return super.fromArray0Template(Int512Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    IntVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, VectorMask<Integer> m) {\n+        return super.fromArray0Template(Int512Mask.class, ivClass, ieClass, a, offsetMap, (Int512Mask) m);\n@@ -926,2 +935,11 @@\n-    void intoArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        super.intoArray0Template(Int512Mask.class, a, offset, indexMap, mapOffset, (Int512Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap) {\n+        super.intoArray0Template(Int512Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, VectorMask<Integer> m) {\n+        super.intoArray0Template(Int512Mask.class, ivClass, ieClass, a, offsetMap, (Int512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -861,2 +861,11 @@\n-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        return super.fromArray0Template(Int64Mask.class, a, offset, indexMap, mapOffset, (Int64Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    IntVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap) {\n+        return super.fromArray0Template(Int64Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    IntVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, VectorMask<Integer> m) {\n+        return super.fromArray0Template(Int64Mask.class, ivClass, ieClass, a, offsetMap, (Int64Mask) m);\n@@ -898,2 +907,11 @@\n-    void intoArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        super.intoArray0Template(Int64Mask.class, a, offset, indexMap, mapOffset, (Int64Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap) {\n+        super.intoArray0Template(Int64Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, VectorMask<Integer> m) {\n+        super.intoArray0Template(Int64Mask.class, ivClass, ieClass, a, offsetMap, (Int64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -870,2 +870,11 @@\n-    IntVector fromArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        return super.fromArray0Template(IntMaxMask.class, a, offset, indexMap, mapOffset, (IntMaxMask) m);\n+    <IV extends Vector<IE>, IE>\n+    IntVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap) {\n+        return super.fromArray0Template(IntMaxMask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    IntVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, VectorMask<Integer> m) {\n+        return super.fromArray0Template(IntMaxMask.class, ivClass, ieClass, a, offsetMap, (IntMaxMask) m);\n@@ -907,2 +916,11 @@\n-    void intoArray0(int[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Integer> m) {\n-        super.intoArray0Template(IntMaxMask.class, a, offset, indexMap, mapOffset, (IntMaxMask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap) {\n+        super.intoArray0Template(IntMaxMask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, VectorMask<Integer> m) {\n+        super.intoArray0Template(IntMaxMask.class, ivClass, ieClass, a, offsetMap, (IntMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -119,2 +119,4 @@\n-    \/\/ Constant loader (takes dummy as vector arg)\n-    interface FVOp {\n+    \/\/ Nullary operator\n+\n+    \/*package-private*\/\n+    interface FNulOp {\n@@ -127,1 +129,1 @@\n-    IntVector vOp(FVOp f) {\n+    IntVector nOp(FNulOp f) {\n@@ -137,1 +139,1 @@\n-    IntVector vOp(VectorMask<Integer> m, FVOp f) {\n+    IntVector nOp(VectorMask<Integer> m, FNulOp f) {\n@@ -319,71 +321,1 @@\n-    \/\/ Memory reference\n-\n-    \/*package-private*\/\n-    interface FLdOp<M> {\n-        int apply(M memory, int offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> IntVector ldOp(M memory, int offset,\n-                                  FLdOp<M> f) {\n-        \/\/dummy; no vec = vec();\n-        int[] res = new int[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> IntVector ldOp(M memory, int offset,\n-                                  VectorMask<Integer> m,\n-                                  FLdOp<M> f) {\n-        \/\/int[] vec = vec();\n-        int[] res = new int[length()];\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    interface FLdLongOp {\n-        int apply(MemorySegment memory, long offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    IntVector ldLongOp(MemorySegment memory, long offset,\n-                                  FLdLongOp f) {\n-        \/\/dummy; no vec = vec();\n-        int[] res = new int[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    IntVector ldLongOp(MemorySegment memory, long offset,\n-                                  VectorMask<Integer> m,\n-                                  FLdLongOp f) {\n-        \/\/int[] vec = vec();\n-        int[] res = new int[length()];\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n+    \/\/ Consume operator\n@@ -391,6 +323,2 @@\n-    static int memorySegmentGet(MemorySegment ms, long o, int i) {\n-        return ms.get(ELEMENT_LAYOUT, o + i * 4L);\n-    }\n-\n-    interface FStOp<M> {\n-        void apply(M memory, int offset, int i, int a);\n+    interface FCOp<M> {\n+        void apply(int i, int a);\n@@ -402,2 +330,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  FStOp<M> f) {\n+    <M> void cOp(FCOp<M> f) {\n@@ -406,1 +333,1 @@\n-            f.apply(memory, offset, i, vec[i]);\n+            f.apply(i, vec[i]);\n@@ -413,3 +340,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  VectorMask<Integer> m,\n-                  FStOp<M> f) {\n+    <M> void cOp(VectorMask<Integer> m, FCOp<M> f) {\n@@ -420,1 +345,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(i, vec[i]);\n@@ -425,28 +350,2 @@\n-    interface FStLongOp {\n-        void apply(MemorySegment memory, long offset, int i, int a);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  FStLongOp f) {\n-        int[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n-        }\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  VectorMask<Integer> m,\n-                  FStLongOp f) {\n-        int[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n-            }\n-        }\n+    static int memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 4L);\n@@ -454,1 +353,0 @@\n-\n@@ -564,2 +462,2 @@\n-                                0, MODE_BROADCAST, vsp,\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+            0, MODE_BROADCAST, vsp,\n+            ((b, s) -> s.nOp(i -> fromBits(b))));\n@@ -1077,1 +975,1 @@\n-   \/**\n+    \/**\n@@ -2995,6 +2893,2 @@\n-     * {@code int[]},\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code int[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3005,2 +2899,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3010,5 +2903,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3016,0 +2905,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3017,3 +2908,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3022,1 +2911,0 @@\n-     * @see IntVector#toIntArray()\n@@ -3027,2 +2915,1 @@\n-                                   int[] a, int offset,\n-                                   int[] indexMap, int mapOffset) {\n+                                   int[] a, IntVector offsetMap) {\n@@ -3030,4 +2917,3 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        Class<? extends IntVector> vectorType = vsp.vectorType();\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n@@ -3035,4 +2921,3 @@\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap);\n+    }\n@@ -3040,1 +2925,29 @@\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code int[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    IntVector fromArray(VectorSpecies<Integer> species,\n+                                   int[] a, LongVector offsetMap) {\n+        IntSpecies vsp = (IntSpecies) species;\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n@@ -3042,7 +2955,2 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, null, int.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap);\n@@ -3053,7 +2961,3 @@\n-     * {@code int[]},\n-     * under the control of a mask, and\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code int[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3065,3 +2969,3 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n-     * Unset lanes in the resulting vector are set to zero.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code int} (zero).\n@@ -3071,5 +2975,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3078,0 +2978,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3079,3 +2981,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3085,1 +2985,0 @@\n-     * @see IntVector#toIntArray()\n@@ -3090,2 +2989,1 @@\n-                                   int[] a, int offset,\n-                                   int[] indexMap, int mapOffset,\n+                                   int[] a, IntVector offsetMap,\n@@ -3093,2 +2991,4 @@\n-        if (m.allTrue()) {\n-            return fromArray(species, a, offset, indexMap, mapOffset);\n+        IntSpecies vsp = (IntSpecies) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n@@ -3096,3 +2996,41 @@\n-        else {\n-            IntSpecies vsp = (IntSpecies) species;\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code int[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code int} (zero).\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    IntVector fromArray(VectorSpecies<Integer> species,\n+                                   int[] a, LongVector offsetMap,\n+                                   VectorMask<Integer> m) {\n+        IntSpecies vsp = (IntSpecies) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n@@ -3100,0 +3038,3 @@\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3233,3 +3174,1 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> arr[(int)off + i] = e));\n@@ -3279,5 +3218,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3286,1 +3222,1 @@\n-     * the lane element at index {@code N} is stored into the array\n+     * the lane is stored into the array\n@@ -3288,2 +3224,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3292,3 +3227,3 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3296,3 +3231,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3301,1 +3234,0 @@\n-     * @see IntVector#toIntArray()\n@@ -3305,23 +3237,7 @@\n-    void intoArray(int[] a, int offset,\n-                   int[] indexMap, int mapOffset) {\n-        IntSpecies vsp = vspecies();\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n-\n-        VectorSupport.storeWithMap(\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n-            isp.vectorType(),\n-            a, arrayAddress(a, 0), vix,\n-            this, null,\n-            a, offset, indexMap, mapOffset,\n-            (arr, off, v, map, mo, vm)\n-            -> v.stOp(arr, off,\n-                      (arr_, off_, i, e) -> {\n-                          int j = map[mo + i];\n-                          arr[off + j] = e;\n-                      }));\n+    void intoArray(int[] a, IntVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap);\n@@ -3331,1 +3247,32 @@\n-     * Scatters this vector into an array of type {@code int[]},\n+     * Scatters this vector into an array of type {@code int[]}\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(int[] a, LongVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap);\n+    }\n+\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code int[]}\n@@ -3333,5 +3280,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3340,2 +3284,2 @@\n-     * if the mask lane at index {@code N} is set then\n-     * the lane element at index {@code N} is stored into the array\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n@@ -3343,2 +3287,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3347,3 +3290,1 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3351,0 +3292,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3352,3 +3295,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3358,1 +3299,0 @@\n-     * @see IntVector#toIntArray()\n@@ -3362,5 +3302,3 @@\n-    void intoArray(int[] a, int offset,\n-                   int[] indexMap, int mapOffset,\n-                   VectorMask<Integer> m) {\n-        if (m.allTrue()) {\n-            intoArray(a, offset, indexMap, mapOffset);\n+    void intoArray(int[] a, IntVector offsetMap, VectorMask<Integer> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n@@ -3368,2 +3306,33 @@\n-        else {\n-            intoArray0(a, offset, indexMap, mapOffset, m);\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code int[]}\n+     * under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(int[] a, LongVector offsetMap, VectorMask<Integer> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n@@ -3371,0 +3340,3 @@\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3446,2 +3418,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n-                                    (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s) -> s.nOp(i -> arr[(int)off + i]));\n@@ -3463,2 +3434,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n-                                        (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s, vm) -> s.nOp(vm, i -> arr[(int)off + i]));\n@@ -3469,3 +3439,2 @@\n-    IntVector fromArray0(int[] a, int offset,\n-                                    int[] indexMap, int mapOffset,\n-                                    VectorMask<Integer> m);\n+    <IV extends Vector<IE>, IE>\n+    IntVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap);\n@@ -3474,3 +3443,4 @@\n-    <M extends VectorMask<Integer>>\n-    IntVector fromArray0Template(Class<M> maskClass, int[] a, int offset,\n-                                            int[] indexMap, int mapOffset, M m) {\n+    <M extends VectorMask<Integer>,\n+     IV extends Vector<IE>,\n+     IE>\n+    IntVector fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap) {\n@@ -3478,13 +3448,7 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        m.check(vsp);\n-        Class<? extends IntVector> vectorType = vsp.vectorType();\n-\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-\n-        \/\/ FIXME: Check index under mask controlling.\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        return VectorSupport.<int[], IntVector, IV, IntSpecies, M, Integer, IE>loadWithMap(\n+            vsp.vectorType(), mClass, int.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 4L, null,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(i -> arr[map.toIntArray()[i]]));\n+    }\n@@ -3492,7 +3456,17 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, maskClass, int.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+    \/*package-private*\/\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    IntVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>,\n+     IV extends Vector<IE>,\n+     IE>\n+    IntVector fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, M m) {\n+        IntSpecies vsp = vspecies();\n+        return VectorSupport.<int[], IntVector, IV, IntSpecies, M, Integer, IE>loadWithMap(\n+            vsp.vectorType(), mClass, int.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 4L, m,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(vm, i -> arr[map.toIntArray()[i]]));\n@@ -3510,5 +3484,3 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, vsp,\n-                (msp, off, s) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, IntVector::memorySegmentGet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, vsp,\n+            (msp, off, s) -> s.nOp(i -> memorySegmentGet(msp, off, i)));\n@@ -3526,5 +3498,3 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n-                (msp, off, s, vm) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, IntVector::memorySegmentGet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n+            (msp, off, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, off, i)));\n@@ -3547,3 +3517,3 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_+i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -3564,3 +3534,3 @@\n-            (arr, off, v, vm)\n-            -> v.stOp(arr, (int) off, vm,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -3570,3 +3540,2 @@\n-    void intoArray0(int[] a, int offset,\n-                    int[] indexMap, int mapOffset,\n-                    VectorMask<Integer> m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap);\n@@ -3575,4 +3544,4 @@\n-    <M extends VectorMask<Integer>>\n-    void intoArray0Template(Class<M> maskClass, int[] a, int offset,\n-                            int[] indexMap, int mapOffset, M m) {\n-        m.check(species());\n+    <M extends VectorMask<Integer>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap) {\n@@ -3580,8 +3549,8 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-\n-        \/\/ FIXME: Check index under mask controlling.\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, int.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 4L, null,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp((i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n+    }\n@@ -3589,12 +3558,17 @@\n-        VectorSupport.storeWithMap(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            isp.vectorType(),\n-            a, arrayAddress(a, 0), vix,\n-            this, m,\n-            a, offset, indexMap, mapOffset,\n-            (arr, off, v, map, mo, vm)\n-            -> v.stOp(arr, off, vm,\n-                      (arr_, off_, i, e) -> {\n-                          int j = map[mo + i];\n-                          arr[off + j] = e;\n-                      }));\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, int[] a, IV offsetMap, M m) {\n+        IntSpecies vsp = vspecies();\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, int.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 4L, m,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n@@ -3609,6 +3583,4 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v) -> {\n-                    v.stLongOp((MemorySegment) msp, off, IntVector::memorySegmentSet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            this,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v) -> v.cOp((i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -3626,6 +3598,4 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v, vm) -> {\n-                    v.stLongOp((MemorySegment) msp, off, vm, IntVector::memorySegmentSet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            this, m,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v, vm) -> v.cOp(vm, (i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -3636,1 +3606,1 @@\n-\n+    @ForceInline\n@@ -3647,0 +3617,1 @@\n+    @ForceInline\n@@ -3851,1 +3822,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (b, s) -> s.nOp(i -> fromBits(b)));\n@@ -3921,75 +3892,0 @@\n-        \/*package-private*\/\n-        final @Override\n-        @ForceInline\n-        IntVector rvOp(RVOp f) {\n-            int[] res = new int[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                int bits = (int) f.apply(i);\n-                res[i] = fromBits(bits);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        IntVector vOp(FVOp f) {\n-            int[] res = new int[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        IntVector vOp(VectorMask<Integer> m, FVOp f) {\n-            int[] res = new int[laneCount()];\n-            boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                if (mbits[i]) {\n-                    res[i] = f.apply(i);\n-                }\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> IntVector ldOp(M memory, int offset,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> IntVector ldOp(M memory, int offset,\n-                                      VectorMask<Integer> m,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        IntVector ldLongOp(MemorySegment memory, long offset,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        IntVector ldLongOp(MemorySegment memory, long offset,\n-                                      VectorMask<Integer> m,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Integer> m,\n-                      FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, m, f);\n-        }\n-\n@@ -3998,2 +3894,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        <M> IntVector nOp(FNulOp f) {\n+            return dummyVector().nOp(f);\n@@ -4004,4 +3900,2 @@\n-        void stLongOp(MemorySegment memory, long offset,\n-                      AbstractMask<Integer> m,\n-                      FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, m, f);\n+        <M> IntVector nOp(VectorMask<Integer> m, FNulOp f) {\n+            return dummyVector().nOp(m, f);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":308,"deletions":414,"binary":false,"changes":722,"status":"modified"},{"patch":"@@ -851,2 +851,11 @@\n-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        return super.fromArray0Template(Long128Mask.class, a, offset, indexMap, mapOffset, (Long128Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    LongVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap) {\n+        return super.fromArray0Template(Long128Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    LongVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, VectorMask<Long> m) {\n+        return super.fromArray0Template(Long128Mask.class, ivClass, ieClass, a, offsetMap, (Long128Mask) m);\n@@ -888,2 +897,11 @@\n-    void intoArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        super.intoArray0Template(Long128Mask.class, a, offset, indexMap, mapOffset, (Long128Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap) {\n+        super.intoArray0Template(Long128Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, VectorMask<Long> m) {\n+        super.intoArray0Template(Long128Mask.class, ivClass, ieClass, a, offsetMap, (Long128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -855,2 +855,11 @@\n-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        return super.fromArray0Template(Long256Mask.class, a, offset, indexMap, mapOffset, (Long256Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    LongVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap) {\n+        return super.fromArray0Template(Long256Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    LongVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, VectorMask<Long> m) {\n+        return super.fromArray0Template(Long256Mask.class, ivClass, ieClass, a, offsetMap, (Long256Mask) m);\n@@ -892,2 +901,11 @@\n-    void intoArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        super.intoArray0Template(Long256Mask.class, a, offset, indexMap, mapOffset, (Long256Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap) {\n+        super.intoArray0Template(Long256Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, VectorMask<Long> m) {\n+        super.intoArray0Template(Long256Mask.class, ivClass, ieClass, a, offsetMap, (Long256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -863,2 +863,11 @@\n-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        return super.fromArray0Template(Long512Mask.class, a, offset, indexMap, mapOffset, (Long512Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    LongVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap) {\n+        return super.fromArray0Template(Long512Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    LongVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, VectorMask<Long> m) {\n+        return super.fromArray0Template(Long512Mask.class, ivClass, ieClass, a, offsetMap, (Long512Mask) m);\n@@ -900,2 +909,11 @@\n-    void intoArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        super.intoArray0Template(Long512Mask.class, a, offset, indexMap, mapOffset, (Long512Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap) {\n+        super.intoArray0Template(Long512Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, VectorMask<Long> m) {\n+        super.intoArray0Template(Long512Mask.class, ivClass, ieClass, a, offsetMap, (Long512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -849,2 +849,11 @@\n-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        return super.fromArray0Template(Long64Mask.class, a, offset, indexMap, mapOffset, (Long64Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    LongVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap) {\n+        return super.fromArray0Template(Long64Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    LongVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, VectorMask<Long> m) {\n+        return super.fromArray0Template(Long64Mask.class, ivClass, ieClass, a, offsetMap, (Long64Mask) m);\n@@ -886,2 +895,11 @@\n-    void intoArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        super.intoArray0Template(Long64Mask.class, a, offset, indexMap, mapOffset, (Long64Mask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap) {\n+        super.intoArray0Template(Long64Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, VectorMask<Long> m) {\n+        super.intoArray0Template(Long64Mask.class, ivClass, ieClass, a, offsetMap, (Long64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -849,2 +849,11 @@\n-    LongVector fromArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        return super.fromArray0Template(LongMaxMask.class, a, offset, indexMap, mapOffset, (LongMaxMask) m);\n+    <IV extends Vector<IE>, IE>\n+    LongVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap) {\n+        return super.fromArray0Template(LongMaxMask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    LongVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, VectorMask<Long> m) {\n+        return super.fromArray0Template(LongMaxMask.class, ivClass, ieClass, a, offsetMap, (LongMaxMask) m);\n@@ -886,2 +895,11 @@\n-    void intoArray0(long[] a, int offset, int[] indexMap, int mapOffset, VectorMask<Long> m) {\n-        super.intoArray0Template(LongMaxMask.class, a, offset, indexMap, mapOffset, (LongMaxMask) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap) {\n+        super.intoArray0Template(LongMaxMask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, VectorMask<Long> m) {\n+        super.intoArray0Template(LongMaxMask.class, ivClass, ieClass, a, offsetMap, (LongMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -119,2 +119,4 @@\n-    \/\/ Constant loader (takes dummy as vector arg)\n-    interface FVOp {\n+    \/\/ Nullary operator\n+\n+    \/*package-private*\/\n+    interface FNulOp {\n@@ -127,1 +129,1 @@\n-    LongVector vOp(FVOp f) {\n+    LongVector nOp(FNulOp f) {\n@@ -137,1 +139,1 @@\n-    LongVector vOp(VectorMask<Long> m, FVOp f) {\n+    LongVector nOp(VectorMask<Long> m, FNulOp f) {\n@@ -319,75 +321,1 @@\n-    \/\/ Memory reference\n-\n-    \/*package-private*\/\n-    interface FLdOp<M> {\n-        long apply(M memory, int offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> LongVector ldOp(M memory, int offset,\n-                                  FLdOp<M> f) {\n-        \/\/dummy; no vec = vec();\n-        long[] res = new long[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> LongVector ldOp(M memory, int offset,\n-                                  VectorMask<Long> m,\n-                                  FLdOp<M> f) {\n-        \/\/long[] vec = vec();\n-        long[] res = new long[length()];\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    interface FLdLongOp {\n-        long apply(MemorySegment memory, long offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    LongVector ldLongOp(MemorySegment memory, long offset,\n-                                  FLdLongOp f) {\n-        \/\/dummy; no vec = vec();\n-        long[] res = new long[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    LongVector ldLongOp(MemorySegment memory, long offset,\n-                                  VectorMask<Long> m,\n-                                  FLdLongOp f) {\n-        \/\/long[] vec = vec();\n-        long[] res = new long[length()];\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    static long memorySegmentGet(MemorySegment ms, long o, int i) {\n-        return ms.get(ELEMENT_LAYOUT, o + i * 8L);\n-    }\n+    \/\/ Consume operator\n@@ -395,2 +323,2 @@\n-    interface FStOp<M> {\n-        void apply(M memory, int offset, int i, long a);\n+    interface FCOp<M> {\n+        void apply(int i, long a);\n@@ -402,2 +330,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  FStOp<M> f) {\n+    <M> void cOp(FCOp<M> f) {\n@@ -406,1 +333,1 @@\n-            f.apply(memory, offset, i, vec[i]);\n+            f.apply(i, vec[i]);\n@@ -413,3 +340,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  VectorMask<Long> m,\n-                  FStOp<M> f) {\n+    <M> void cOp(VectorMask<Long> m, FCOp<M> f) {\n@@ -420,1 +345,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(i, vec[i]);\n@@ -425,28 +350,2 @@\n-    interface FStLongOp {\n-        void apply(MemorySegment memory, long offset, int i, long a);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  FStLongOp f) {\n-        long[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n-        }\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  VectorMask<Long> m,\n-                  FStLongOp f) {\n-        long[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n-            }\n-        }\n+    static long memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 8L);\n@@ -454,1 +353,0 @@\n-\n@@ -564,2 +462,2 @@\n-                                0, MODE_BROADCAST, vsp,\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+            0, MODE_BROADCAST, vsp,\n+            ((b, s) -> s.nOp(i -> fromBits(b))));\n@@ -990,1 +888,1 @@\n-   \/**\n+    \/**\n@@ -2856,6 +2754,2 @@\n-     * {@code long[]},\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code long[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -2866,2 +2760,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -2871,5 +2764,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -2877,0 +2766,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -2878,3 +2769,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -2883,1 +2772,0 @@\n-     * @see LongVector#toIntArray()\n@@ -2888,2 +2776,1 @@\n-                                   long[] a, int offset,\n-                                   int[] indexMap, int mapOffset) {\n+                                   long[] a, IntVector offsetMap) {\n@@ -2891,26 +2778,2 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        Class<? extends LongVector> vectorType = vsp.vectorType();\n-\n-        if (vsp.laneCount() == 1) {\n-          return LongVector.fromArray(vsp, a, offset + indexMap[mapOffset]);\n-        }\n-\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For LongMaxVector,  if vector length is non-power-of-two or\n-            \/\/ 2048 bits, indexShape of Long species is S_MAX_BIT.\n-            \/\/ Assume that vector length is 2048, then the lane count of Long\n-            \/\/ vector is 32. When converting Long species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n@@ -2919,1 +2782,33 @@\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code long[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    LongVector fromArray(VectorSpecies<Long> species,\n+                                   long[] a, LongVector offsetMap) {\n+        LongSpecies vsp = (LongSpecies) species;\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n@@ -2921,7 +2816,2 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, null, long.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap);\n@@ -2932,7 +2822,3 @@\n-     * {@code long[]},\n-     * under the control of a mask, and\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code long[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -2944,3 +2830,3 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n-     * Unset lanes in the resulting vector are set to zero.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code long} (zero).\n@@ -2950,5 +2836,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -2957,0 +2839,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -2958,3 +2842,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -2964,1 +2846,0 @@\n-     * @see LongVector#toIntArray()\n@@ -2969,2 +2850,1 @@\n-                                   long[] a, int offset,\n-                                   int[] indexMap, int mapOffset,\n+                                   long[] a, IntVector offsetMap,\n@@ -2972,2 +2852,4 @@\n-        if (m.allTrue()) {\n-            return fromArray(species, a, offset, indexMap, mapOffset);\n+        LongSpecies vsp = (LongSpecies) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n@@ -2975,3 +2857,41 @@\n-        else {\n-            LongSpecies vsp = (LongSpecies) species;\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code long[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code long} (zero).\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    LongVector fromArray(VectorSpecies<Long> species,\n+                                   long[] a, LongVector offsetMap,\n+                                   VectorMask<Long> m) {\n+        LongSpecies vsp = (LongSpecies) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n@@ -2979,0 +2899,3 @@\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3112,3 +3035,1 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> arr[(int)off + i] = e));\n@@ -3158,5 +3079,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3165,1 +3083,1 @@\n-     * the lane element at index {@code N} is stored into the array\n+     * the lane is stored into the array\n@@ -3167,2 +3085,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3171,3 +3088,3 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3175,3 +3092,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3180,1 +3095,0 @@\n-     * @see LongVector#toIntArray()\n@@ -3184,25 +3098,3 @@\n-    void intoArray(long[] a, int offset,\n-                   int[] indexMap, int mapOffset) {\n-        LongSpecies vsp = vspecies();\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        if (vsp.laneCount() == 1) {\n-            intoArray(a, offset + indexMap[mapOffset]);\n-            return;\n-        }\n-\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For LongMaxVector,  if vector length  is 2048 bits, indexShape\n-            \/\/ of Long species is S_MAX_BIT. and the lane count of Long\n-            \/\/ vector is 32. When converting Long species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n+    void intoArray(long[] a, IntVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n@@ -3211,0 +3103,3 @@\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap);\n+    }\n@@ -3212,1 +3107,25 @@\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+    \/**\n+     * Scatters this vector into an array of type {@code long[]}\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(long[] a, LongVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n@@ -3214,12 +3133,2 @@\n-        VectorSupport.storeWithMap(\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n-            isp.vectorType(),\n-            a, arrayAddress(a, 0), vix,\n-            this, null,\n-            a, offset, indexMap, mapOffset,\n-            (arr, off, v, map, mo, vm)\n-            -> v.stOp(arr, off,\n-                      (arr_, off_, i, e) -> {\n-                          int j = map[mo + i];\n-                          arr[off + j] = e;\n-                      }));\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap);\n@@ -3228,0 +3137,1 @@\n+\n@@ -3229,1 +3139,1 @@\n-     * Scatters this vector into an array of type {@code long[]},\n+     * Scatters this vector into an array of type {@code long[]}\n@@ -3231,5 +3141,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3238,2 +3145,2 @@\n-     * if the mask lane at index {@code N} is set then\n-     * the lane element at index {@code N} is stored into the array\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n@@ -3241,2 +3148,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3245,3 +3151,1 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3249,0 +3153,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3250,3 +3156,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3256,1 +3160,0 @@\n-     * @see LongVector#toIntArray()\n@@ -3260,5 +3163,3 @@\n-    void intoArray(long[] a, int offset,\n-                   int[] indexMap, int mapOffset,\n-                   VectorMask<Long> m) {\n-        if (m.allTrue()) {\n-            intoArray(a, offset, indexMap, mapOffset);\n+    void intoArray(long[] a, IntVector offsetMap, VectorMask<Long> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n@@ -3266,2 +3167,33 @@\n-        else {\n-            intoArray0(a, offset, indexMap, mapOffset, m);\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code long[]}\n+     * under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(long[] a, LongVector offsetMap, VectorMask<Long> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n@@ -3269,0 +3201,3 @@\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3344,2 +3279,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n-                                    (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s) -> s.nOp(i -> arr[(int)off + i]));\n@@ -3361,2 +3295,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n-                                        (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s, vm) -> s.nOp(vm, i -> arr[(int)off + i]));\n@@ -3367,3 +3300,2 @@\n-    LongVector fromArray0(long[] a, int offset,\n-                                    int[] indexMap, int mapOffset,\n-                                    VectorMask<Long> m);\n+    <IV extends Vector<IE>, IE>\n+    LongVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap);\n@@ -3372,3 +3304,4 @@\n-    <M extends VectorMask<Long>>\n-    LongVector fromArray0Template(Class<M> maskClass, long[] a, int offset,\n-                                            int[] indexMap, int mapOffset, M m) {\n+    <M extends VectorMask<Long>,\n+     IV extends Vector<IE>,\n+     IE>\n+    LongVector fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap) {\n@@ -3376,31 +3309,7 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        m.check(vsp);\n-        Class<? extends LongVector> vectorType = vsp.vectorType();\n-\n-        if (vsp.laneCount() == 1) {\n-          return LongVector.fromArray(vsp, a, offset + indexMap[mapOffset], m);\n-        }\n-\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For LongMaxVector,  if vector length is non-power-of-two or\n-            \/\/ 2048 bits, indexShape of Long species is S_MAX_BIT.\n-            \/\/ Assume that vector length is 2048, then the lane count of Long\n-            \/\/ vector is 32. When converting Long species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n-        }\n-\n-        \/\/ FIXME: Check index under mask controlling.\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        return VectorSupport.<long[], LongVector, IV, LongSpecies, M, Long, IE>loadWithMap(\n+            vsp.vectorType(), mClass, long.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 8L, null,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(i -> arr[map.toIntArray()[i]]));\n+    }\n@@ -3408,7 +3317,17 @@\n-        return VectorSupport.loadWithMap(\n-            vectorType, maskClass, long.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+    \/*package-private*\/\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    LongVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>,\n+     IV extends Vector<IE>,\n+     IE>\n+    LongVector fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, M m) {\n+        LongSpecies vsp = vspecies();\n+        return VectorSupport.<long[], LongVector, IV, LongSpecies, M, Long, IE>loadWithMap(\n+            vsp.vectorType(), mClass, long.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 8L, m,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(vm, i -> arr[map.toIntArray()[i]]));\n@@ -3426,5 +3345,3 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, vsp,\n-                (msp, off, s) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, LongVector::memorySegmentGet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, vsp,\n+            (msp, off, s) -> s.nOp(i -> memorySegmentGet(msp, off, i)));\n@@ -3442,5 +3359,3 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n-                (msp, off, s, vm) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, LongVector::memorySegmentGet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n+            (msp, off, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, off, i)));\n@@ -3463,3 +3378,3 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_+i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -3480,3 +3395,3 @@\n-            (arr, off, v, vm)\n-            -> v.stOp(arr, (int) off, vm,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -3486,3 +3401,2 @@\n-    void intoArray0(long[] a, int offset,\n-                    int[] indexMap, int mapOffset,\n-                    VectorMask<Long> m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap);\n@@ -3491,4 +3405,4 @@\n-    <M extends VectorMask<Long>>\n-    void intoArray0Template(Class<M> maskClass, long[] a, int offset,\n-                            int[] indexMap, int mapOffset, M m) {\n-        m.check(species());\n+    <M extends VectorMask<Long>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap) {\n@@ -3496,27 +3410,8 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        if (vsp.laneCount() == 1) {\n-            intoArray(a, offset + indexMap[mapOffset], m);\n-            return;\n-        }\n-\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For LongMaxVector,  if vector length  is 2048 bits, indexShape\n-            \/\/ of Long species is S_MAX_BIT. and the lane count of Long\n-            \/\/ vector is 32. When converting Long species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n-        }\n-\n-\n-        \/\/ FIXME: Check index under mask controlling.\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, long.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 8L, null,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp((i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n+    }\n@@ -3524,12 +3419,17 @@\n-        VectorSupport.storeWithMap(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            isp.vectorType(),\n-            a, arrayAddress(a, 0), vix,\n-            this, m,\n-            a, offset, indexMap, mapOffset,\n-            (arr, off, v, map, mo, vm)\n-            -> v.stOp(arr, off, vm,\n-                      (arr_, off_, i, e) -> {\n-                          int j = map[mo + i];\n-                          arr[off + j] = e;\n-                      }));\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, long[] a, IV offsetMap, M m) {\n+        LongSpecies vsp = vspecies();\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, long.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 8L, m,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n@@ -3544,6 +3444,4 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v) -> {\n-                    v.stLongOp((MemorySegment) msp, off, LongVector::memorySegmentSet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            this,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v) -> v.cOp((i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -3561,6 +3459,4 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v, vm) -> {\n-                    v.stLongOp((MemorySegment) msp, off, vm, LongVector::memorySegmentSet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            this, m,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v, vm) -> v.cOp(vm, (i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -3571,1 +3467,1 @@\n-\n+    @ForceInline\n@@ -3582,0 +3478,1 @@\n+    @ForceInline\n@@ -3786,1 +3683,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (b, s) -> s.nOp(i -> fromBits(b)));\n@@ -3847,75 +3744,0 @@\n-        \/*package-private*\/\n-        final @Override\n-        @ForceInline\n-        LongVector rvOp(RVOp f) {\n-            long[] res = new long[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                long bits =  f.apply(i);\n-                res[i] = fromBits(bits);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        LongVector vOp(FVOp f) {\n-            long[] res = new long[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        LongVector vOp(VectorMask<Long> m, FVOp f) {\n-            long[] res = new long[laneCount()];\n-            boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                if (mbits[i]) {\n-                    res[i] = f.apply(i);\n-                }\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> LongVector ldOp(M memory, int offset,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> LongVector ldOp(M memory, int offset,\n-                                      VectorMask<Long> m,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        LongVector ldLongOp(MemorySegment memory, long offset,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        LongVector ldLongOp(MemorySegment memory, long offset,\n-                                      VectorMask<Long> m,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Long> m,\n-                      FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, m, f);\n-        }\n-\n@@ -3924,2 +3746,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        <M> LongVector nOp(FNulOp f) {\n+            return dummyVector().nOp(f);\n@@ -3930,4 +3752,2 @@\n-        void stLongOp(MemorySegment memory, long offset,\n-                      AbstractMask<Long> m,\n-                      FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, m, f);\n+        <M> LongVector nOp(VectorMask<Long> m, FNulOp f) {\n+            return dummyVector().nOp(m, f);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":304,"deletions":484,"binary":false,"changes":788,"status":"modified"},{"patch":"@@ -870,0 +870,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ShortVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap) {\n+        return super.fromArray0Template(Short128Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ShortVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, VectorMask<Short> m) {\n+        return super.fromArray0Template(Short128Mask.class, ivClass, ieClass, a, offsetMap, (Short128Mask) m);\n+    }\n@@ -914,0 +929,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap) {\n+        super.intoArray0Template(Short128Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, VectorMask<Short> m) {\n+        super.intoArray0Template(Short128Mask.class, ivClass, ieClass, a, offsetMap, (Short128Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -886,0 +886,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ShortVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap) {\n+        return super.fromArray0Template(Short256Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ShortVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, VectorMask<Short> m) {\n+        return super.fromArray0Template(Short256Mask.class, ivClass, ieClass, a, offsetMap, (Short256Mask) m);\n+    }\n@@ -930,0 +945,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap) {\n+        super.intoArray0Template(Short256Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, VectorMask<Short> m) {\n+        super.intoArray0Template(Short256Mask.class, ivClass, ieClass, a, offsetMap, (Short256Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -918,0 +918,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ShortVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap) {\n+        return super.fromArray0Template(Short512Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ShortVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, VectorMask<Short> m) {\n+        return super.fromArray0Template(Short512Mask.class, ivClass, ieClass, a, offsetMap, (Short512Mask) m);\n+    }\n@@ -962,0 +977,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap) {\n+        super.intoArray0Template(Short512Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, VectorMask<Short> m) {\n+        super.intoArray0Template(Short512Mask.class, ivClass, ieClass, a, offsetMap, (Short512Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -862,0 +862,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ShortVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap) {\n+        return super.fromArray0Template(Short64Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ShortVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, VectorMask<Short> m) {\n+        return super.fromArray0Template(Short64Mask.class, ivClass, ieClass, a, offsetMap, (Short64Mask) m);\n+    }\n@@ -906,0 +921,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap) {\n+        super.intoArray0Template(Short64Mask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, VectorMask<Short> m) {\n+        super.intoArray0Template(Short64Mask.class, ivClass, ieClass, a, offsetMap, (Short64Mask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -856,0 +856,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ShortVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap) {\n+        return super.fromArray0Template(ShortMaxMask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    ShortVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, VectorMask<Short> m) {\n+        return super.fromArray0Template(ShortMaxMask.class, ivClass, ieClass, a, offsetMap, (ShortMaxMask) m);\n+    }\n@@ -900,0 +915,15 @@\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap) {\n+        super.intoArray0Template(ShortMaxMask.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, VectorMask<Short> m) {\n+        super.intoArray0Template(ShortMaxMask.class, ivClass, ieClass, a, offsetMap, (ShortMaxMask) m);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -119,2 +119,4 @@\n-    \/\/ Constant loader (takes dummy as vector arg)\n-    interface FVOp {\n+    \/\/ Nullary operator\n+\n+    \/*package-private*\/\n+    interface FNulOp {\n@@ -127,1 +129,1 @@\n-    ShortVector vOp(FVOp f) {\n+    ShortVector nOp(FNulOp f) {\n@@ -137,1 +139,1 @@\n-    ShortVector vOp(VectorMask<Short> m, FVOp f) {\n+    ShortVector nOp(VectorMask<Short> m, FNulOp f) {\n@@ -319,75 +321,1 @@\n-    \/\/ Memory reference\n-\n-    \/*package-private*\/\n-    interface FLdOp<M> {\n-        short apply(M memory, int offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> ShortVector ldOp(M memory, int offset,\n-                                  FLdOp<M> f) {\n-        \/\/dummy; no vec = vec();\n-        short[] res = new short[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> ShortVector ldOp(M memory, int offset,\n-                                  VectorMask<Short> m,\n-                                  FLdOp<M> f) {\n-        \/\/short[] vec = vec();\n-        short[] res = new short[length()];\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    interface FLdLongOp {\n-        short apply(MemorySegment memory, long offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    ShortVector ldLongOp(MemorySegment memory, long offset,\n-                                  FLdLongOp f) {\n-        \/\/dummy; no vec = vec();\n-        short[] res = new short[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    ShortVector ldLongOp(MemorySegment memory, long offset,\n-                                  VectorMask<Short> m,\n-                                  FLdLongOp f) {\n-        \/\/short[] vec = vec();\n-        short[] res = new short[length()];\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    static short memorySegmentGet(MemorySegment ms, long o, int i) {\n-        return ms.get(ELEMENT_LAYOUT, o + i * 2L);\n-    }\n+    \/\/ Consume operator\n@@ -395,2 +323,2 @@\n-    interface FStOp<M> {\n-        void apply(M memory, int offset, int i, short a);\n+    interface FCOp<M> {\n+        void apply(int i, short a);\n@@ -402,2 +330,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  FStOp<M> f) {\n+    <M> void cOp(FCOp<M> f) {\n@@ -406,1 +333,1 @@\n-            f.apply(memory, offset, i, vec[i]);\n+            f.apply(i, vec[i]);\n@@ -413,3 +340,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  VectorMask<Short> m,\n-                  FStOp<M> f) {\n+    <M> void cOp(VectorMask<Short> m, FCOp<M> f) {\n@@ -420,1 +345,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(i, vec[i]);\n@@ -425,28 +350,2 @@\n-    interface FStLongOp {\n-        void apply(MemorySegment memory, long offset, int i, short a);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  FStLongOp f) {\n-        short[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n-        }\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  VectorMask<Short> m,\n-                  FStLongOp f) {\n-        short[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n-            }\n-        }\n+    static short memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 2L);\n@@ -454,1 +353,0 @@\n-\n@@ -564,2 +462,2 @@\n-                                0, MODE_BROADCAST, vsp,\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+            0, MODE_BROADCAST, vsp,\n+            ((b, s) -> s.nOp(i -> fromBits(b))));\n@@ -1074,1 +972,1 @@\n-   \/**\n+    \/**\n@@ -3018,6 +2916,2 @@\n-     * {@code short[]},\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code short[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3028,2 +2922,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3033,5 +2926,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3039,0 +2928,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3040,3 +2931,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3045,1 +2934,0 @@\n-     * @see ShortVector#toIntArray()\n@@ -3050,2 +2938,1 @@\n-                                   short[] a, int offset,\n-                                   int[] indexMap, int mapOffset) {\n+                                   short[] a, IntVector offsetMap) {\n@@ -3053,1 +2940,6 @@\n-        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap);\n@@ -3058,7 +2950,37 @@\n-     * {@code short[]},\n-     * under the control of a mask, and\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code short[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromArray(VectorSpecies<Short> species,\n+                                   short[] a, LongVector offsetMap) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code short[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3070,3 +2992,3 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n-     * Unset lanes in the resulting vector are set to zero.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (zero).\n@@ -3076,5 +2998,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3083,0 +3001,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3084,3 +3004,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3090,1 +3008,0 @@\n-     * @see ShortVector#toIntArray()\n@@ -3095,2 +3012,1 @@\n-                                   short[] a, int offset,\n-                                   int[] indexMap, int mapOffset,\n+                                   short[] a, IntVector offsetMap,\n@@ -3099,1 +3015,49 @@\n-        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code short[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (zero).\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromArray(VectorSpecies<Short> species,\n+                                   short[] a, LongVector offsetMap,\n+                                   VectorMask<Short> m) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3166,6 +3130,2 @@\n-     * {@code char[]},\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code char[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3174,4 +3134,3 @@\n-     * the lane is loaded from the expression\n-     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3181,5 +3140,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3187,0 +3142,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3188,3 +3145,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3193,1 +3148,0 @@\n-     * @see ShortVector#toIntArray()\n@@ -3198,3 +3152,1 @@\n-                                       char[] a, int offset,\n-                                       int[] indexMap, int mapOffset) {\n-        \/\/ FIXME: optimize\n+                                       char[] a, IntVector offsetMap) {\n@@ -3202,1 +3154,6 @@\n-        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.nOp(i -> (short) a[offsetMap.lane(i)]);\n@@ -3207,7 +3164,37 @@\n-     * {@code char[]},\n-     * under the control of a mask, and\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code char[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, LongVector offsetMap) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.nOp(i -> (short) a[(int) offsetMap.lane(i)]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3217,5 +3204,5 @@\n-     * the lane is loaded from the expression\n-     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n-     * Unset lanes in the resulting vector are set to zero.\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (zero).\n@@ -3225,5 +3212,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3232,0 +3215,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3233,3 +3218,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3239,1 +3222,0 @@\n-     * @see ShortVector#toIntArray()\n@@ -3244,2 +3226,43 @@\n-                                       char[] a, int offset,\n-                                       int[] indexMap, int mapOffset,\n+                                       char[] a, IntVector offsetMap,\n+                                       VectorMask<Short> m) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.nOp(m, i -> (short) a[offsetMap.lane(i)]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (zero).\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, LongVector offsetMap,\n@@ -3247,1 +3270,0 @@\n-        \/\/ FIXME: optimize\n@@ -3249,1 +3271,7 @@\n-        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.nOp(m, i -> (short) a[(int) offsetMap.lane(i)]);\n@@ -3382,3 +3410,1 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> arr[(int)off + i] = e));\n@@ -3428,5 +3454,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3435,1 +3458,1 @@\n-     * the lane element at index {@code N} is stored into the array\n+     * the lane is stored into the array\n@@ -3437,2 +3460,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3441,3 +3463,3 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3445,3 +3467,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3450,1 +3470,0 @@\n-     * @see ShortVector#toIntArray()\n@@ -3454,7 +3473,7 @@\n-    void intoArray(short[] a, int offset,\n-                   int[] indexMap, int mapOffset) {\n-        stOp(a, offset,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = e;\n-             });\n+    void intoArray(short[] a, IntVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap);\n@@ -3464,1 +3483,32 @@\n-     * Scatters this vector into an array of type {@code short[]},\n+     * Scatters this vector into an array of type {@code short[]}\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, LongVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap);\n+    }\n+\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code short[]}\n@@ -3466,5 +3516,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3473,2 +3520,2 @@\n-     * if the mask lane at index {@code N} is set then\n-     * the lane element at index {@code N} is stored into the array\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n@@ -3476,2 +3523,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3480,3 +3526,1 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3484,0 +3528,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3485,3 +3531,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3491,1 +3535,0 @@\n-     * @see ShortVector#toIntArray()\n@@ -3495,8 +3538,41 @@\n-    void intoArray(short[] a, int offset,\n-                   int[] indexMap, int mapOffset,\n-                   VectorMask<Short> m) {\n-        stOp(a, offset, m,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = e;\n-             });\n+    void intoArray(short[] a, IntVector offsetMap, VectorMask<Short> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code short[]}\n+     * under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(short[] a, LongVector offsetMap, VectorMask<Short> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3530,3 +3606,1 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+            (arr, off, v) -> v.cOp((i, e) -> arr[(int)off + i] = (char) e));\n@@ -3577,5 +3651,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3584,3 +3655,1 @@\n-     * the lane element at index {@code N}\n-     * is first cast to a {@code char} value and then\n-     * stored into the array\n+     * the lane is stored into the array\n@@ -3588,2 +3657,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3592,3 +3660,3 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3596,3 +3664,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3601,1 +3667,0 @@\n-     * @see ShortVector#toIntArray()\n@@ -3605,8 +3670,9 @@\n-    void intoCharArray(char[] a, int offset,\n-                       int[] indexMap, int mapOffset) {\n-        \/\/ FIXME: optimize\n-        stOp(a, offset,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = (char) e;\n-             });\n+    void intoCharArray(char[] a, IntVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        cOp((i, e) -> {\n+            a[offsetMap.lane(i)] = (char) e;\n+        });\n@@ -3616,1 +3682,34 @@\n-     * Scatters this vector into an array of type {@code char[]},\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, LongVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        cOp((i, e) -> {\n+            a[(int) offsetMap.lane(i)] = (char) e;\n+        });\n+    }\n+\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n@@ -3618,5 +3717,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3625,4 +3721,2 @@\n-     * if the mask lane at index {@code N} is set then\n-     * the lane element at index {@code N}\n-     * is first cast to a {@code char} value and then\n-     * stored into the array\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n@@ -3630,2 +3724,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3634,3 +3727,1 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3638,0 +3729,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -3639,3 +3732,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3645,1 +3736,0 @@\n-     * @see ShortVector#toIntArray()\n@@ -3649,9 +3739,45 @@\n-    void intoCharArray(char[] a, int offset,\n-                       int[] indexMap, int mapOffset,\n-                       VectorMask<Short> m) {\n-        \/\/ FIXME: optimize\n-        stOp(a, offset, m,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = (char) e;\n-             });\n+    void intoCharArray(char[] a, IntVector offsetMap, VectorMask<Short> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        cOp(m, (i, e) -> {\n+            a[offsetMap.lane(i)] = (char) e;\n+        });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, LongVector offsetMap, VectorMask<Short> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        cOp(m, (i, e) -> {\n+            a[(int) offsetMap.lane(i)] = (char) e;\n+        });\n@@ -3732,2 +3858,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n-                                    (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s) -> s.nOp(i -> arr[(int)off + i]));\n@@ -3749,2 +3874,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n-                                        (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s, vm) -> s.nOp(vm, i -> arr[(int)off + i]));\n@@ -3753,0 +3877,37 @@\n+    \/*package-private*\/\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    ShortVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>,\n+     IV extends Vector<IE>,\n+     IE>\n+    ShortVector fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap) {\n+        ShortSpecies vsp = vspecies();\n+        return VectorSupport.<short[], ShortVector, IV, ShortSpecies, M, Short, IE>loadWithMap(\n+            vsp.vectorType(), mClass, short.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 2L, null,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(i -> arr[map.toIntArray()[i]]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    ShortVector fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>,\n+     IV extends Vector<IE>,\n+     IE>\n+    ShortVector fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, M m) {\n+        ShortSpecies vsp = vspecies();\n+        return VectorSupport.<short[], ShortVector, IV, ShortSpecies, M, Short, IE>loadWithMap(\n+            vsp.vectorType(), mClass, short.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 2L, m,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(vm, i -> arr[map.toIntArray()[i]]));\n+    }\n@@ -3765,2 +3926,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n-                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+            (arr, off, s) -> s.nOp(i -> (short) arr[(int)off + i]));\n@@ -3779,5 +3939,4 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                a, charArrayAddress(a, offset), m, offsetInRange,\n-                a, offset, vsp,\n-                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n-                                            (arr_, off_, i) -> (short) arr_[off_ + i]));\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset), m, offsetInRange,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.nOp(vm, i -> (short) arr[(int)off + i]));\n@@ -3794,5 +3953,3 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, vsp,\n-                (msp, off, s) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, ShortVector::memorySegmentGet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, vsp,\n+            (msp, off, s) -> s.nOp(i -> memorySegmentGet(msp, off, i)));\n@@ -3810,5 +3967,3 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n-                (msp, off, s, vm) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, ShortVector::memorySegmentGet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n+            (msp, off, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, off, i)));\n@@ -3831,3 +3986,3 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_+i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -3848,3 +4003,22 @@\n-            (arr, off, v, vm)\n-            -> v.stOp(arr, (int) off, vm,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n+    }\n+\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap) {\n+        ShortSpecies vsp = vspecies();\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, short.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 2L, null,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp((i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n@@ -3853,0 +4027,18 @@\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, short[] a, IV offsetMap, M m) {\n+        ShortSpecies vsp = vspecies();\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, short.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, 2L, m,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n+    }\n@@ -3860,6 +4052,4 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v) -> {\n-                    v.stLongOp((MemorySegment) msp, off, ShortVector::memorySegmentSet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            this,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v) -> v.cOp((i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -3877,6 +4067,4 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v, vm) -> {\n-                    v.stLongOp((MemorySegment) msp, off, vm, ShortVector::memorySegmentSet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            this, m,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v, vm) -> v.cOp(vm, (i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -3899,2 +4087,3 @@\n-            -> v.stOp(arr, (int) off, vm,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+            -> v.cOp(vm, (i, e) -> {\n+                arr[(int)off + i] = (char) e;\n+            }));\n@@ -3904,1 +4093,1 @@\n-\n+    @ForceInline\n@@ -3915,0 +4104,1 @@\n+    @ForceInline\n@@ -4136,1 +4326,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (b, s) -> s.nOp(i -> fromBits(b)));\n@@ -4206,75 +4396,0 @@\n-        \/*package-private*\/\n-        final @Override\n-        @ForceInline\n-        ShortVector rvOp(RVOp f) {\n-            short[] res = new short[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                short bits = (short) f.apply(i);\n-                res[i] = fromBits(bits);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        ShortVector vOp(FVOp f) {\n-            short[] res = new short[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        ShortVector vOp(VectorMask<Short> m, FVOp f) {\n-            short[] res = new short[laneCount()];\n-            boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                if (mbits[i]) {\n-                    res[i] = f.apply(i);\n-                }\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> ShortVector ldOp(M memory, int offset,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> ShortVector ldOp(M memory, int offset,\n-                                      VectorMask<Short> m,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        ShortVector ldLongOp(MemorySegment memory, long offset,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        ShortVector ldLongOp(MemorySegment memory, long offset,\n-                                      VectorMask<Short> m,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<Short> m,\n-                      FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, m, f);\n-        }\n-\n@@ -4283,2 +4398,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        <M> ShortVector nOp(FNulOp f) {\n+            return dummyVector().nOp(f);\n@@ -4289,4 +4404,2 @@\n-        void stLongOp(MemorySegment memory, long offset,\n-                      AbstractMask<Short> m,\n-                      FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, m, f);\n+        <M> ShortVector nOp(VectorMask<Short> m, FNulOp f) {\n+            return dummyVector().nOp(m, f);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":553,"deletions":440,"binary":false,"changes":993,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    static IntVector checkIndex(IntVector vix, int length) {\n+    static void checkIndices(IntVector offsetMap, long length, long scale) {\n@@ -75,1 +75,1 @@\n-            case 0: return vix; \/\/ no range check\n+            case 0: return; \/\/ no range check\n@@ -78,4 +78,3 @@\n-                if (vix.compare(VectorOperators.LT, 0)\n-                    .or(vix.compare(VectorOperators.GE, length))\n-                    .anyTrue()) {\n-                    throw checkIndexFailed(vix, length);\n+                long scaleM1 = scale - 1;\n+                if (length > Integer.MAX_VALUE + scaleM1) {\n+                    return;\n@@ -83,1 +82,60 @@\n-                return vix;\n+                if (length < scaleM1 || offsetMap.compare(VectorOperators.UNSIGNED_GE,\n+                                (int)(length - scaleM1))\n+                        .anyTrue()) {\n+                    throw checkIndexFailed(offsetMap, length, scale, null);\n+                }\n+                return;\n+            default: throw new InternalError();\n+        }\n+    }\n+\n+    @ForceInline\n+    static void checkIndices(LongVector offsetMap, long length, long scale) {\n+        switch (VectorIntrinsics.VECTOR_ACCESS_OOB_CHECK) {\n+            case 0: return; \/\/ no range check\n+            case 1: \/\/ fall-through\n+            case 2:\n+                long scaleM1 = scale - 1;\n+                if (length < scaleM1 || offsetMap.compare(VectorOperators.UNSIGNED_GE,\n+                                length - scaleM1)\n+                        .anyTrue()) {\n+                    throw checkIndexFailed(offsetMap, length, scale, null);\n+                }\n+                return;\n+            default: throw new InternalError();\n+        }\n+    }\n+\n+    @ForceInline\n+    static <E> void checkIndices(IntVector offsetMap, long length, long scale, VectorMask<E> mask) {\n+        switch (VectorIntrinsics.VECTOR_ACCESS_OOB_CHECK) {\n+            case 0: return; \/\/ no range check\n+            case 1: \/\/ fall-through\n+            case 2:\n+                long scaleM1 = scale - 1;\n+                if (length > Integer.MAX_VALUE + scaleM1) {\n+                    return;\n+                }\n+                if (length < scaleM1 || offsetMap.compare(VectorOperators.UNSIGNED_GE,\n+                                (int)(length - scaleM1), mask.cast(offsetMap.vspecies()))\n+                        .anyTrue()) {\n+                    throw checkIndexFailed(offsetMap, length, scale, mask);\n+                }\n+                return;\n+            default: throw new InternalError();\n+        }\n+    }\n+\n+    @ForceInline\n+    static <E> void checkIndices(LongVector offsetMap, long length, long scale, VectorMask<E> mask) {\n+        switch (VectorIntrinsics.VECTOR_ACCESS_OOB_CHECK) {\n+            case 0: return; \/\/ no range check\n+            case 1: \/\/ fall-through\n+            case 2:\n+                long scaleM1 = scale - 1;\n+                if (length < scaleM1 || offsetMap.compare(VectorOperators.UNSIGNED_GE,\n+                                length - scaleM1, mask.cast(offsetMap.vspecies()))\n+                        .anyTrue()) {\n+                    throw checkIndexFailed(offsetMap, length, scale, mask);\n+                }\n+                return;\n@@ -89,3 +147,12 @@\n-    IndexOutOfBoundsException checkIndexFailed(IntVector vix, int length) {\n-        String msg = String.format(\"Range check failed: vector %s out of bounds for length %d\", vix, length);\n-        return new IndexOutOfBoundsException(msg);\n+    IndexOutOfBoundsException checkIndexFailed(Vector<?> vix, long length, long scale, VectorMask<?> mask) {\n+        if (mask == null) {\n+            String msg =\n+                    String.format(\"Range check failed: map %s, scale %d out of bounds for length %d\",\n+                            vix, scale, length);\n+            return new IndexOutOfBoundsException(msg);\n+        } else {\n+            String msg =\n+                    String.format(\"Range check failed: map %s, scale %d with mask %s out of bounds for length %d\",\n+                            vix, scale, mask, length);\n+            return new IndexOutOfBoundsException(msg);\n+        }\n@@ -101,1 +168,1 @@\n-            return index & ~(size - 1);\n+            return index & (-size);\n@@ -121,1 +188,1 @@\n-            return index & ~(size - 1);\n+            return index & (-size);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorIntrinsics.java","additions":79,"deletions":12,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -123,2 +123,4 @@\n-    \/\/ Constant loader (takes dummy as vector arg)\n-    interface FVOp {\n+    \/\/ Nullary operator\n+\n+    \/*package-private*\/\n+    interface FNulOp {\n@@ -131,1 +133,1 @@\n-    $abstractvectortype$ vOp(FVOp f) {\n+    $abstractvectortype$ nOp(FNulOp f) {\n@@ -141,1 +143,1 @@\n-    $abstractvectortype$ vOp(VectorMask<$Boxtype$> m, FVOp f) {\n+    $abstractvectortype$ nOp(VectorMask<$Boxtype$> m, FNulOp f) {\n@@ -323,75 +325,1 @@\n-    \/\/ Memory reference\n-\n-    \/*package-private*\/\n-    interface FLdOp<M> {\n-        $type$ apply(M memory, int offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> $abstractvectortype$ ldOp(M memory, int offset,\n-                                  FLdOp<M> f) {\n-        \/\/dummy; no vec = vec();\n-        $type$[] res = new $type$[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    <M> $abstractvectortype$ ldOp(M memory, int offset,\n-                                  VectorMask<$Boxtype$> m,\n-                                  FLdOp<M> f) {\n-        \/\/$type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    interface FLdLongOp {\n-        $type$ apply(MemorySegment memory, long offset, int i);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n-                                  FLdLongOp f) {\n-        \/\/dummy; no vec = vec();\n-        $type$[] res = new $type$[length()];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(memory, offset, i);\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n-                                  VectorMask<$Boxtype$> m,\n-                                  FLdLongOp f) {\n-        \/\/$type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        for (int i = 0; i < res.length; i++) {\n-            if (mbits[i]) {\n-                res[i] = f.apply(memory, offset, i);\n-            }\n-        }\n-        return vectorFactory(res);\n-    }\n-\n-    static $type$ memorySegmentGet(MemorySegment ms, long o, int i) {\n-        return ms.get(ELEMENT_LAYOUT, o + i * $sizeInBytes$L);\n-    }\n+    \/\/ Consume operator\n@@ -399,2 +327,2 @@\n-    interface FStOp<M> {\n-        void apply(M memory, int offset, int i, $type$ a);\n+    interface FCOp<M> {\n+        void apply(int i, $type$ a);\n@@ -406,2 +334,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  FStOp<M> f) {\n+    <M> void cOp(FCOp<M> f) {\n@@ -410,1 +337,1 @@\n-            f.apply(memory, offset, i, vec[i]);\n+            f.apply(i, vec[i]);\n@@ -417,3 +344,1 @@\n-    <M> void stOp(M memory, int offset,\n-                  VectorMask<$Boxtype$> m,\n-                  FStOp<M> f) {\n+    <M> void cOp(VectorMask<$Boxtype$> m, FCOp<M> f) {\n@@ -424,1 +349,1 @@\n-                f.apply(memory, offset, i, vec[i]);\n+                f.apply(i, vec[i]);\n@@ -429,28 +354,2 @@\n-    interface FStLongOp {\n-        void apply(MemorySegment memory, long offset, int i, $type$ a);\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  FStLongOp f) {\n-        $type$[] vec = vec();\n-        for (int i = 0; i < vec.length; i++) {\n-            f.apply(memory, offset, i, vec[i]);\n-        }\n-    }\n-\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    void stLongOp(MemorySegment memory, long offset,\n-                  VectorMask<$Boxtype$> m,\n-                  FStLongOp f) {\n-        $type$[] vec = vec();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        for (int i = 0; i < vec.length; i++) {\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, vec[i]);\n-            }\n-        }\n+    static $type$ memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * $sizeInBytes$L);\n@@ -458,1 +357,0 @@\n-\n@@ -577,5 +475,0 @@\n-#if[FP]\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),\n-                        toBits(0.0f), MODE_BROADCAST, vsp,\n-                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n-#else[FP]\n@@ -583,3 +476,2 @@\n-                                0, MODE_BROADCAST, vsp,\n-                                ((bits_, s_) -> s_.rvOp(i -> bits_)));\n-#end[FP]\n+            0, MODE_BROADCAST, vsp,\n+            ((b, s) -> s.nOp(i -> fromBits(b))));\n@@ -1207,1 +1099,1 @@\n-   \/**\n+    \/**\n@@ -3589,6 +3481,2 @@\n-     * {@code $type$[]},\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code $type$[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3599,2 +3487,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3604,5 +3491,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3610,0 +3493,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3611,3 +3496,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3616,1 +3499,0 @@\n-     * @see $abstractvectortype$#toIntArray()\n@@ -3618,1 +3500,0 @@\n-#if[byteOrShort]\n@@ -3622,2 +3503,1 @@\n-                                   $type$[] a, int offset,\n-                                   int[] indexMap, int mapOffset) {\n+                                   $type$[] a, IntVector offsetMap) {\n@@ -3625,1 +3505,6 @@\n-        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap);\n@@ -3627,1 +3512,22 @@\n-#else[byteOrShort]\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code $type$[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n@@ -3631,2 +3537,1 @@\n-                                   $type$[] a, int offset,\n-                                   int[] indexMap, int mapOffset) {\n+                                   $type$[] a, LongVector offsetMap) {\n@@ -3634,8 +3539,2 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        Class<? extends $abstractvectortype$> vectorType = vsp.vectorType();\n-\n-#if[longOrDouble]\n-        if (vsp.laneCount() == 1) {\n-          return $abstractvectortype$.fromArray(vsp, a, offset + indexMap[mapOffset]);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n@@ -3644,34 +3543,2 @@\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For $Type$MaxVector,  if vector length is non-power-of-two or\n-            \/\/ 2048 bits, indexShape of $Type$ species is S_MAX_BIT.\n-            \/\/ Assume that vector length is 2048, then the lane count of $Type$\n-            \/\/ vector is 32. When converting $Type$ species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n-        }\n-#else[longOrDouble]\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-#end[longOrDouble]\n-\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n-\n-        return VectorSupport.loadWithMap(\n-            vectorType, null, $type$.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, null,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(n -> c[idx + iMap[idy+n]]));\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap);\n@@ -3679,1 +3546,0 @@\n-#end[byteOrShort]\n@@ -3683,7 +3549,3 @@\n-     * {@code $type$[]},\n-     * under the control of a mask, and\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code $type$[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3695,3 +3557,3 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n-     * Unset lanes in the resulting vector are set to zero.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n@@ -3701,5 +3563,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3708,0 +3566,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3709,3 +3569,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3715,1 +3573,0 @@\n-     * @see $abstractvectortype$#toIntArray()\n@@ -3717,1 +3574,0 @@\n-#if[byteOrShort]\n@@ -3721,2 +3577,1 @@\n-                                   $type$[] a, int offset,\n-                                   int[] indexMap, int mapOffset,\n+                                   $type$[] a, IntVector offsetMap,\n@@ -3725,1 +3580,7 @@\n-        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n@@ -3727,1 +3588,28 @@\n-#else[byteOrShort]\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code $type$[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n@@ -3731,2 +3619,1 @@\n-                                   $type$[] a, int offset,\n-                                   int[] indexMap, int mapOffset,\n+                                   $type$[] a, LongVector offsetMap,\n@@ -3734,6 +3621,4 @@\n-        if (m.allTrue()) {\n-            return fromArray(species, a, offset, indexMap, mapOffset);\n-        }\n-        else {\n-            $Type$Species vsp = ($Type$Species) species;\n-            return vsp.dummyVector().fromArray0(a, offset, indexMap, mapOffset, m);\n+        $Type$Species vsp = ($Type$Species) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n@@ -3741,0 +3626,3 @@\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.dummyVector().fromArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -3742,1 +3630,0 @@\n-#end[byteOrShort]\n@@ -3809,6 +3696,2 @@\n-     * {@code char[]},\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code char[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3817,4 +3700,3 @@\n-     * the lane is loaded from the expression\n-     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3824,5 +3706,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3830,0 +3708,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3831,3 +3711,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3836,1 +3714,0 @@\n-     * @see $abstractvectortype$#toIntArray()\n@@ -3841,3 +3718,1 @@\n-                                       char[] a, int offset,\n-                                       int[] indexMap, int mapOffset) {\n-        \/\/ FIXME: optimize\n+                                       char[] a, IntVector offsetMap) {\n@@ -3845,1 +3720,6 @@\n-        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.nOp(i -> (short) a[offsetMap.lane(i)]);\n@@ -3850,7 +3730,37 @@\n-     * {@code char[]},\n-     * under the control of a mask, and\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code char[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, LongVector offsetMap) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.nOp(i -> (short) a[(int) offsetMap.lane(i)]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3860,5 +3770,5 @@\n-     * the lane is loaded from the expression\n-     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n-     * Unset lanes in the resulting vector are set to zero.\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} (zero).\n@@ -3868,5 +3778,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3875,0 +3781,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3876,3 +3784,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3882,1 +3788,0 @@\n-     * @see $abstractvectortype$#toIntArray()\n@@ -3887,2 +3792,43 @@\n-                                       char[] a, int offset,\n-                                       int[] indexMap, int mapOffset,\n+                                       char[] a, IntVector offsetMap,\n+                                       VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.nOp(m, i -> (short) a[offsetMap.lane(i)]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} (zero).\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, LongVector offsetMap,\n@@ -3890,1 +3836,0 @@\n-        \/\/ FIXME: optimize\n@@ -3892,1 +3837,7 @@\n-        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.nOp(m, i -> (short) a[(int) offsetMap.lane(i)]);\n@@ -3968,6 +3919,2 @@\n-     * {@code boolean[]},\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code boolean[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -3978,2 +3925,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -3983,5 +3929,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -3989,0 +3931,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -3990,3 +3934,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -3995,1 +3937,0 @@\n-     * @see $abstractvectortype$#toIntArray()\n@@ -4000,3 +3941,1 @@\n-                                          boolean[] a, int offset,\n-                                          int[] indexMap, int mapOffset) {\n-        \/\/ FIXME: optimize\n+                                          boolean[] a, IntVector offsetMap) {\n@@ -4004,1 +3943,6 @@\n-        return vsp.vOp(n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.nOp(i -> (byte) (a[offsetMap.lane(i)] ? 1 : 0));\n@@ -4009,7 +3953,2 @@\n-     * {@code boolean[]},\n-     * under the control of a mask, and\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * {@code boolean[]}, using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n@@ -4018,1 +3957,0 @@\n-     * if the lane is set in the mask,\n@@ -4021,3 +3959,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n-     * Unset lanes in the resulting vector are set to zero.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -4027,6 +3963,1 @@\n-     * @param offset the offset into the array, may be negative if relative\n-     * indexes in the index map compensate to produce a value within the\n-     * array bounds\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n-     * @param m the mask controlling lane selection\n+     * @param offsetMap the offset map\n@@ -4034,0 +3965,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -4035,3 +3968,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -4040,2 +3971,0 @@\n-     *         where the mask is set\n-     * @see $abstractvectortype$#toIntArray()\n@@ -4046,4 +3975,1 @@\n-                                          boolean[] a, int offset,\n-                                          int[] indexMap, int mapOffset,\n-                                          VectorMask<$Boxtype$> m) {\n-        \/\/ FIXME: optimize\n+                                          boolean[] a, LongVector offsetMap) {\n@@ -4051,1 +3977,6 @@\n-        return vsp.vOp(m, n -> (byte) (a[offset + indexMap[mapOffset + n]] ? 1 : 0));\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        return vsp.nOp(i -> (byte) (a[(int) offsetMap.lane(i)] ? 1 : 0));\n@@ -4053,1 +3984,0 @@\n-#end[byte]\n@@ -4056,6 +3986,4 @@\n-     * Loads a vector from a {@linkplain MemorySegment memory segment}\n-     * starting at an offset into the memory segment.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -4063,7 +3991,7 @@\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n-     * fromMemorySegment()} as follows:\n-     * <pre>{@code\n-     * var m = species.maskAll(true);\n-     * return fromMemorySegment(species, ms, offset, bo, m);\n-     * }<\/pre>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} (zero).\n@@ -4072,4 +4000,6 @@\n-     * @param ms the memory segment\n-     * @param offset the offset into the memory segment\n-     * @param bo the intended byte order\n-     * @return a vector loaded from the memory segment\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n@@ -4077,2 +4007,2 @@\n-     *         if {@code offset+N*$sizeInBytes$ < 0}\n-     *         or {@code offset+N*$sizeInBytes$ >= ms.byteSize()}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n@@ -4080,2 +4010,87 @@\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, IntVector offsetMap,\n+                                          VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.nOp(m, i -> (byte) (a[offsetMap.lane(i)] ? 1 : 0));\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code boolean[]}, under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (byte) (a[f(N)] ? 1 : 0)}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} (zero).\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IllegalArgumentException\n+     *         if {@code species.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromBooleanArray(VectorSpecies<$Boxtype$> species,\n+                                          boolean[] a, LongVector offsetMap,\n+                                          VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        m.check(vsp);\n+        if (vsp.laneCount() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        return vsp.nOp(m, i -> (byte) (a[(int) offsetMap.lane(i)] ? 1 : 0));\n+    }\n+#end[byte]\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*$sizeInBytes$ < 0}\n+     *         or {@code offset+N*$sizeInBytes$ >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n@@ -4188,3 +4203,1 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> arr[(int)off + i] = e));\n@@ -4234,5 +4247,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -4241,1 +4251,1 @@\n-     * the lane element at index {@code N} is stored into the array\n+     * the lane is stored into the array\n@@ -4243,2 +4253,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -4247,3 +4256,3 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -4251,3 +4260,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -4256,1 +4263,0 @@\n-     * @see $abstractvectortype$#toIntArray()\n@@ -4258,1 +4264,0 @@\n-#if[byteOrShort]\n@@ -4261,7 +4266,7 @@\n-    void intoArray($type$[] a, int offset,\n-                   int[] indexMap, int mapOffset) {\n-        stOp(a, offset,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = e;\n-             });\n+    void intoArray($type$[] a, IntVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap);\n@@ -4269,1 +4274,20 @@\n-#else[byteOrShort]\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code $type$[]}\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n@@ -4272,8 +4296,3 @@\n-    void intoArray($type$[] a, int offset,\n-                   int[] indexMap, int mapOffset) {\n-        $Type$Species vsp = vspecies();\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-#if[longOrDouble]\n-        if (vsp.laneCount() == 1) {\n-            intoArray(a, offset + indexMap[mapOffset]);\n-            return;\n+    void intoArray($type$[] a, LongVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n@@ -4282,39 +4301,2 @@\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For $Type$MaxVector,  if vector length  is 2048 bits, indexShape\n-            \/\/ of $Type$ species is S_MAX_BIT. and the lane count of $Type$\n-            \/\/ vector is 32. When converting $Type$ species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n-        }\n-\n-#else[longOrDouble]\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-#end[longOrDouble]\n-\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n-\n-        VectorSupport.storeWithMap(\n-            vsp.vectorType(), null, vsp.elementType(), vsp.laneCount(),\n-            isp.vectorType(),\n-            a, arrayAddress(a, 0), vix,\n-            this, null,\n-            a, offset, indexMap, mapOffset,\n-            (arr, off, v, map, mo, vm)\n-            -> v.stOp(arr, off,\n-                      (arr_, off_, i, e) -> {\n-                          int j = map[mo + i];\n-                          arr[off + j] = e;\n-                      }));\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap);\n@@ -4322,1 +4304,1 @@\n-#end[byteOrShort]\n+\n@@ -4325,1 +4307,1 @@\n-     * Scatters this vector into an array of type {@code $type$[]},\n+     * Scatters this vector into an array of type {@code $type$[]}\n@@ -4327,5 +4309,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -4334,2 +4313,2 @@\n-     * if the mask lane at index {@code N} is set then\n-     * the lane element at index {@code N} is stored into the array\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n@@ -4337,2 +4316,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -4341,3 +4319,1 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -4345,0 +4321,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -4346,3 +4324,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -4352,1 +4328,0 @@\n-     * @see $abstractvectortype$#toIntArray()\n@@ -4354,1 +4329,0 @@\n-#if[byteOrShort]\n@@ -4357,8 +4331,7 @@\n-    void intoArray($type$[] a, int offset,\n-                   int[] indexMap, int mapOffset,\n-                   VectorMask<$Boxtype$> m) {\n-        stOp(a, offset, m,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = e;\n-             });\n+    void intoArray($type$[] a, IntVector offsetMap, VectorMask<$Boxtype$> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), int.class, a, offsetMap, m);\n@@ -4366,1 +4339,24 @@\n-#else[byteOrShort]\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code $type$[]}\n+     * under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n@@ -4369,8 +4365,3 @@\n-    void intoArray($type$[] a, int offset,\n-                   int[] indexMap, int mapOffset,\n-                   VectorMask<$Boxtype$> m) {\n-        if (m.allTrue()) {\n-            intoArray(a, offset, indexMap, mapOffset);\n-        }\n-        else {\n-            intoArray0(a, offset, indexMap, mapOffset, m);\n+    void intoArray($type$[] a, LongVector offsetMap, VectorMask<$Boxtype$> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n@@ -4378,0 +4369,3 @@\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        intoArray0(offsetMap.getClass(), long.class, a, offsetMap, m);\n@@ -4379,1 +4373,0 @@\n-#end[byteOrShort]\n@@ -4407,3 +4400,1 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+            (arr, off, v) -> v.cOp((i, e) -> arr[(int)off + i] = (char) e));\n@@ -4454,5 +4445,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -4461,3 +4449,1 @@\n-     * the lane element at index {@code N}\n-     * is first cast to a {@code char} value and then\n-     * stored into the array\n+     * the lane is stored into the array\n@@ -4465,2 +4451,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -4469,3 +4454,3 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -4473,3 +4458,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -4478,1 +4461,0 @@\n-     * @see $abstractvectortype$#toIntArray()\n@@ -4482,8 +4464,9 @@\n-    void intoCharArray(char[] a, int offset,\n-                       int[] indexMap, int mapOffset) {\n-        \/\/ FIXME: optimize\n-        stOp(a, offset,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = (char) e;\n-             });\n+    void intoCharArray(char[] a, IntVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        cOp((i, e) -> {\n+            a[offsetMap.lane(i)] = (char) e;\n+        });\n@@ -4493,1 +4476,34 @@\n-     * Scatters this vector into an array of type {@code char[]},\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, LongVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        cOp((i, e) -> {\n+            a[(int) offsetMap.lane(i)] = (char) e;\n+        });\n+    }\n+\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n@@ -4495,5 +4511,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -4502,4 +4515,2 @@\n-     * if the mask lane at index {@code N} is set then\n-     * the lane element at index {@code N}\n-     * is first cast to a {@code char} value and then\n-     * stored into the array\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n@@ -4507,2 +4518,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -4511,3 +4521,1 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -4515,0 +4523,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -4516,3 +4526,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -4522,1 +4530,0 @@\n-     * @see $abstractvectortype$#toIntArray()\n@@ -4526,9 +4533,45 @@\n-    void intoCharArray(char[] a, int offset,\n-                       int[] indexMap, int mapOffset,\n-                       VectorMask<$Boxtype$> m) {\n-        \/\/ FIXME: optimize\n-        stOp(a, offset, m,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = (char) e;\n-             });\n+    void intoCharArray(char[] a, IntVector offsetMap, VectorMask<$Boxtype$> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        cOp(m, (i, e) -> {\n+            a[offsetMap.lane(i)] = (char) e;\n+        });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is stored into the array\n+     * element {@code a[(int)f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, LongVector offsetMap, VectorMask<$Boxtype$> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        cOp(m, (i, e) -> {\n+            a[(int) offsetMap.lane(i)] = (char) e;\n+        });\n@@ -4568,3 +4611,1 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+            (arr, off, v) -> v.cOp((i, e) -> arr[(int)off + i] = (e & 1) != 0));\n@@ -4618,5 +4659,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -4625,3 +4663,2 @@\n-     * the lane element at index {@code N}\n-     * is first converted to a {@code boolean} value and then\n-     * stored into the array\n+     * the lane element is first converted to a {@code boolean} value\n+     * and then store into the array\n@@ -4629,2 +4666,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -4636,3 +4672,3 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -4640,3 +4676,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -4645,1 +4679,0 @@\n-     * @see $abstractvectortype$#toIntArray()\n@@ -4649,8 +4682,9 @@\n-    void intoBooleanArray(boolean[] a, int offset,\n-                          int[] indexMap, int mapOffset) {\n-        \/\/ FIXME: optimize\n-        stOp(a, offset,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = (e & 1) != 0;\n-             });\n+    void intoBooleanArray(boolean[] a, IntVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        cOp((i, e) -> {\n+            a[offsetMap.lane(i)] = (e & 1) != 0;\n+        });\n@@ -4660,1 +4694,38 @@\n-     * Scatters this vector into an array of type {@code boolean[]},\n+     * Scatters this vector into an array of type {@code boolean[]}\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element is first converted to a {@code boolean} value\n+     * and then store into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, LongVector offsetMap) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1);\n+        cOp((i, e) -> {\n+            a[(int) offsetMap.lane(i)] = (e & 1) != 0;\n+        });\n+    }\n+\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]}\n@@ -4662,5 +4733,2 @@\n-     * using indexes obtained by adding a fixed {@code offset} to a\n-     * series of secondary offsets from an <em>index map<\/em>.\n-     * The index map is a contiguous sequence of {@code VLENGTH}\n-     * elements in a second array of {@code int}s, starting at a given\n-     * {@code mapOffset}.\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n@@ -4669,4 +4737,3 @@\n-     * if the mask lane at index {@code N} is set then\n-     * the lane element at index {@code N}\n-     * is first converted to a {@code boolean} value and then\n-     * stored into the array\n+     * if the lane is set in the mask,\n+     * the lane element is first converted to a {@code boolean} value\n+     * and then store into the array\n@@ -4674,2 +4741,1 @@\n-     * index mapping expression\n-     * {@code offset + indexMap[mapOffset + N]]}.\n+     * index mapping expression {@code offsetMap.lane(N)}.\n@@ -4681,3 +4747,1 @@\n-     * @param offset an offset to combine with the index map offsets\n-     * @param indexMap the index map\n-     * @param mapOffset the offset into the index map\n+     * @param offsetMap the offset map\n@@ -4685,0 +4749,2 @@\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n@@ -4686,3 +4752,1 @@\n-     *         if {@code mapOffset+N < 0}\n-     *         or if {@code mapOffset+N >= indexMap.length},\n-     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         if {@code f(N)=offsetMap.lane(N)}\n@@ -4692,1 +4756,0 @@\n-     * @see $abstractvectortype$#toIntArray()\n@@ -4696,9 +4759,49 @@\n-    void intoBooleanArray(boolean[] a, int offset,\n-                          int[] indexMap, int mapOffset,\n-                          VectorMask<$Boxtype$> m) {\n-        \/\/ FIXME: optimize\n-        stOp(a, offset, m,\n-             (arr, off, i, e) -> {\n-                 int j = indexMap[mapOffset + i];\n-                 arr[off + j] = (e & 1) != 0;\n-             });\n+    void intoBooleanArray(boolean[] a, IntVector offsetMap, VectorMask<$Boxtype$> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        cOp(m, (i, e) -> {\n+            a[offsetMap.lane(i)] = (e & 1) != 0;\n+        });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code boolean[]}\n+     * under the control of a mask, and\n+     * using indices obtained from an <em>offset map<\/em>.\n+     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane element is first converted to a {@code boolean} value\n+     * and then store into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression {@code offsetMap.lane(N)}.\n+     * <p>\n+     * A {@code byte} value is converted to a {@code boolean} value by applying the\n+     * expression {@code (b & 1) != 0} where {@code b} is the byte value.\n+     *\n+     * @param a the array\n+     * @param offsetMap the offset map\n+     * @param m the mask\n+     * @throws IllegalArgumentException\n+     *         if {@code this.length()!=offsetMap.length()}\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code f(N)=offsetMap.lane(N)}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoBooleanArray(boolean[] a, LongVector offsetMap, VectorMask<$Boxtype$> m) {\n+        if (length() != offsetMap.length()) {\n+            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n+        }\n+\n+        VectorIntrinsics.checkIndices(offsetMap, a.length, 1, m);\n+        cOp(m, (i, e) -> {\n+            a[(int) offsetMap.lane(i)] = (e & 1) != 0;\n+        });\n@@ -4779,2 +4882,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n-                                    (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s) -> s.nOp(i -> arr[(int)off + i]));\n@@ -4796,2 +4898,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n-                                        (arr_, off_, i) -> arr_[off_ + i]));\n+            (arr, off, s, vm) -> s.nOp(vm, i -> arr[(int)off + i]));\n@@ -4800,1 +4901,0 @@\n-#if[!byteOrShort]\n@@ -4803,3 +4903,2 @@\n-    $abstractvectortype$ fromArray0($type$[] a, int offset,\n-                                    int[] indexMap, int mapOffset,\n-                                    VectorMask<$Boxtype$> m);\n+    <IV extends Vector<IE>, IE>\n+    $abstractvectortype$ fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, $type$[] a, IV offsetMap);\n@@ -4808,3 +4907,4 @@\n-    <M extends VectorMask<$Boxtype$>>\n-    $abstractvectortype$ fromArray0Template(Class<M> maskClass, $type$[] a, int offset,\n-                                            int[] indexMap, int mapOffset, M m) {\n+    <M extends VectorMask<$Boxtype$>,\n+     IV extends Vector<IE>,\n+     IE>\n+    $abstractvectortype$ fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, $type$[] a, IV offsetMap) {\n@@ -4812,10 +4912,7 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-        Objects.requireNonNull(a);\n-        Objects.requireNonNull(indexMap);\n-        m.check(vsp);\n-        Class<? extends $abstractvectortype$> vectorType = vsp.vectorType();\n-\n-#if[longOrDouble]\n-        if (vsp.laneCount() == 1) {\n-          return $abstractvectortype$.fromArray(vsp, a, offset + indexMap[mapOffset], m);\n-        }\n+        return VectorSupport.<$type$[], $abstractvectortype$, IV, $Type$Species, M, $Boxtype$, IE>loadWithMap(\n+            vsp.vectorType(), mClass, $type$.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, $sizeInBytes$L, null,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(i -> arr[map.toIntArray()[i]]));\n+    }\n@@ -4823,35 +4920,17 @@\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For $Type$MaxVector,  if vector length is non-power-of-two or\n-            \/\/ 2048 bits, indexShape of $Type$ species is S_MAX_BIT.\n-            \/\/ Assume that vector length is 2048, then the lane count of $Type$\n-            \/\/ vector is 32. When converting $Type$ species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n-        }\n-#else[longOrDouble]\n-        \/\/ Index vector: vix[0:n] = k -> offset + indexMap[mapOffset + k]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-#end[longOrDouble]\n-\n-        \/\/ FIXME: Check index under mask controlling.\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n-\n-        return VectorSupport.loadWithMap(\n-            vectorType, maskClass, $type$.class, vsp.laneCount(),\n-            isp.vectorType(),\n-            a, ARRAY_BASE, vix, m,\n-            a, offset, indexMap, mapOffset, vsp,\n-            (c, idx, iMap, idy, s, vm) ->\n-            s.vOp(vm, n -> c[idx + iMap[idy+n]]));\n+    \/*package-private*\/\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    $abstractvectortype$ fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, $type$[] a, IV offsetMap, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>,\n+     IV extends Vector<IE>,\n+     IE>\n+    $abstractvectortype$ fromArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, $type$[] a, IV offsetMap, M m) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.<$type$[], $abstractvectortype$, IV, $Type$Species, M, $Boxtype$, IE>loadWithMap(\n+            vsp.vectorType(), mClass, $type$.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, $sizeInBytes$L, m,\n+            a, vsp,\n+            (arr, map, s, vm) -> s.nOp(vm, i -> arr[map.toIntArray()[i]]));\n@@ -4859,1 +4938,0 @@\n-#end[!byteOrShort]\n@@ -4873,2 +4951,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n-                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+            (arr, off, s) -> s.nOp(i -> (short) arr[(int)off + i]));\n@@ -4887,5 +4964,4 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                a, charArrayAddress(a, offset), m, offsetInRange,\n-                a, offset, vsp,\n-                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n-                                            (arr_, off_, i) -> (short) arr_[off_ + i]));\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset), m, offsetInRange,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.nOp(vm, i -> (short) arr[(int)off + i]));\n@@ -4907,2 +4983,1 @@\n-            (arr, off, s) -> s.ldOp(arr, (int) off,\n-                                    (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+            (arr, off, s) -> s.nOp(i -> (byte) (arr[(int)off + i] ? 1 : 0)));\n@@ -4924,2 +4999,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n-                                        (arr_, off_, i) -> (byte) (arr_[off_ + i] ? 1 : 0)));\n+            (arr, off, s, vm) -> s.nOp(vm, i -> (byte) (arr[(int)off + i] ? 1 : 0)));\n@@ -4936,5 +5010,3 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, vsp,\n-                (msp, off, s) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, $abstractvectortype$::memorySegmentGet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, vsp,\n+            (msp, off, s) -> s.nOp(i -> memorySegmentGet(msp, off, i)));\n@@ -4952,5 +5024,3 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n-                (msp, off, s, vm) -> {\n-                    return s.ldLongOp((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentGet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n+            (msp, off, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, off, i)));\n@@ -4973,3 +5043,3 @@\n-            (arr, off, v)\n-            -> v.stOp(arr, (int) off,\n-                      (arr_, off_, i, e) -> arr_[off_+i] = e));\n+            (arr, off, v) -> v.cOp((i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -4990,3 +5060,3 @@\n-            (arr, off, v, vm)\n-            -> v.stOp(arr, (int) off, vm,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+            (arr, off, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[(int)off + i] = e;\n+            }));\n@@ -4995,1 +5065,0 @@\n-#if[!byteOrShort]\n@@ -4997,3 +5066,2 @@\n-    void intoArray0($type$[] a, int offset,\n-                    int[] indexMap, int mapOffset,\n-                    VectorMask<$Boxtype$> m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, $type$[] a, IV offsetMap);\n@@ -5002,4 +5070,4 @@\n-    <M extends VectorMask<$Boxtype$>>\n-    void intoArray0Template(Class<M> maskClass, $type$[] a, int offset,\n-                            int[] indexMap, int mapOffset, M m) {\n-        m.check(species());\n+    <M extends VectorMask<$Boxtype$>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, $type$[] a, IV offsetMap) {\n@@ -5007,34 +5075,8 @@\n-        IntVector.IntSpecies isp = IntVector.species(vsp.indexShape());\n-#if[longOrDouble]\n-        if (vsp.laneCount() == 1) {\n-            intoArray(a, offset + indexMap[mapOffset], m);\n-            return;\n-        }\n-\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix;\n-        if (isp.laneCount() != vsp.laneCount()) {\n-            \/\/ For $Type$MaxVector,  if vector length  is 2048 bits, indexShape\n-            \/\/ of $Type$ species is S_MAX_BIT. and the lane count of $Type$\n-            \/\/ vector is 32. When converting $Type$ species to int species,\n-            \/\/ indexShape is still S_MAX_BIT, but the lane count of int vector\n-            \/\/ is 64. So when loading index vector (IntVector), only lower half\n-            \/\/ of index data is needed.\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset, IntMaxVector.IntMaxMask.LOWER_HALF_TRUE_MASK)\n-                .add(offset);\n-        } else {\n-            vix = IntVector\n-                .fromArray(isp, indexMap, mapOffset)\n-                .add(offset);\n-        }\n-\n-#else[longOrDouble]\n-        \/\/ Index vector: vix[0:n] = i -> offset + indexMap[mo + i]\n-        IntVector vix = IntVector\n-            .fromArray(isp, indexMap, mapOffset)\n-            .add(offset);\n-#end[longOrDouble]\n-\n-        \/\/ FIXME: Check index under mask controlling.\n-        vix = VectorIntrinsics.checkIndex(vix, a.length);\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, $type$.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, $sizeInBytes$L, null,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp((i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n+    }\n@@ -5042,12 +5084,17 @@\n-        VectorSupport.storeWithMap(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            isp.vectorType(),\n-            a, arrayAddress(a, 0), vix,\n-            this, m,\n-            a, offset, indexMap, mapOffset,\n-            (arr, off, v, map, mo, vm)\n-            -> v.stOp(arr, off, vm,\n-                      (arr_, off_, i, e) -> {\n-                          int j = map[mo + i];\n-                          arr[off + j] = e;\n-                      }));\n+    abstract\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, $type$[] a, IV offsetMap, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>,\n+     IV extends Vector<IE>,\n+     IE>\n+    void intoArray0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, $type$[] a, IV offsetMap, M m) {\n+        $Type$Species vsp = vspecies();\n+        VectorSupport.storeWithMap(vsp.vectorType(), mClass, $type$.class,\n+            vsp.laneCount(), ivClass, ieClass,\n+            a, ARRAY_BASE, offsetMap, $sizeInBytes$L, m,\n+            this, a,\n+            (arr, map, v, vm) -> v.cOp(vm, (i, e) -> {\n+                arr[map.toIntArray()[i]] = e;\n+            }));\n@@ -5055,1 +5102,0 @@\n-#end[!byteOrShort]\n@@ -5072,2 +5118,3 @@\n-            -> v.stOp(arr, (int) off, vm,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = (e & 1) != 0));\n+            -> v.cOp(vm, (i, e) -> {\n+                arr[(int)off + i] = (e & 1) != 0;\n+            }));\n@@ -5082,6 +5129,4 @@\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v) -> {\n-                    v.stLongOp((MemorySegment) msp, off, $abstractvectortype$::memorySegmentSet);\n-                });\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            this,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v) -> v.cOp((i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -5099,6 +5144,4 @@\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m,\n-                (AbstractMemorySegmentImpl) ms, offset,\n-                (msp, off, v, vm) -> {\n-                    v.stLongOp((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentSet);\n-                });\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            this, m,\n+            (AbstractMemorySegmentImpl) ms, offset,\n+            (msp, off, v, vm) -> v.cOp(vm, (i, e) -> memorySegmentSet(msp, off, i, e)));\n@@ -5122,2 +5165,3 @@\n-            -> v.stOp(arr, (int) off, vm,\n-                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+            -> v.cOp(vm, (i, e) -> {\n+                arr[(int)off + i] = (char) e;\n+            }));\n@@ -5128,1 +5172,1 @@\n-\n+    @ForceInline\n@@ -5139,0 +5183,1 @@\n+    @ForceInline\n@@ -5394,1 +5439,1 @@\n-                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+                    (b, s) -> s.nOp(i -> fromBits(b)));\n@@ -5471,75 +5516,0 @@\n-        \/*package-private*\/\n-        final @Override\n-        @ForceInline\n-        $abstractvectortype$ rvOp(RVOp f) {\n-            $type$[] res = new $type$[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                $bitstype$ bits = {#if[!long]?($bitstype$)} f.apply(i);\n-                res[i] = fromBits(bits);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        $Type$Vector vOp(FVOp f) {\n-            $type$[] res = new $type$[laneCount()];\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i);\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        $Type$Vector vOp(VectorMask<$Boxtype$> m, FVOp f) {\n-            $type$[] res = new $type$[laneCount()];\n-            boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                if (mbits[i]) {\n-                    res[i] = f.apply(i);\n-                }\n-            }\n-            return dummyVector().vectorFactory(res);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> $abstractvectortype$ ldOp(M memory, int offset,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> $abstractvectortype$ ldOp(M memory, int offset,\n-                                      VectorMask<$Boxtype$> m,\n-                                      FLdOp<M> f) {\n-            return dummyVector().ldOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n-                                      VectorMask<$Boxtype$> m,\n-                                      FLdLongOp f) {\n-            return dummyVector().ldLongOp(memory, offset, m, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset, FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, f);\n-        }\n-\n-        \/*package-private*\/\n-        @ForceInline\n-        <M> void stOp(M memory, int offset,\n-                      AbstractMask<$Boxtype$> m,\n-                      FStOp<M> f) {\n-            dummyVector().stOp(memory, offset, m, f);\n-        }\n-\n@@ -5548,2 +5518,2 @@\n-        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, f);\n+        <M> $abstractvectortype$ nOp(FNulOp f) {\n+            return dummyVector().nOp(f);\n@@ -5554,4 +5524,2 @@\n-        void stLongOp(MemorySegment memory, long offset,\n-                      AbstractMask<$Boxtype$> m,\n-                      FStLongOp f) {\n-            dummyVector().stLongOp(memory, offset, m, f);\n+        <M> $abstractvectortype$ nOp(VectorMask<$Boxtype$> m, FNulOp f) {\n+            return dummyVector().nOp(m, f);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":773,"deletions":805,"binary":false,"changes":1578,"status":"modified"},{"patch":"@@ -1144,1 +1144,0 @@\n-#if[!byteOrShort]\n@@ -1148,2 +1147,11 @@\n-    $abstractvectortype$ fromArray0($type$[] a, int offset, int[] indexMap, int mapOffset, VectorMask<$Boxtype$> m) {\n-        return super.fromArray0Template($masktype$.class, a, offset, indexMap, mapOffset, ($masktype$) m);\n+    <IV extends Vector<IE>, IE>\n+    $abstractvectortype$ fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, $type$[] a, IV offsetMap) {\n+        return super.fromArray0Template($masktype$.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    $abstractvectortype$ fromArray0(Class<? extends IV> ivClass, Class<IE> ieClass, $type$[] a, IV offsetMap, VectorMask<$Boxtype$> m) {\n+        return super.fromArray0Template($masktype$.class, ivClass, ieClass, a, offsetMap, ($masktype$) m);\n@@ -1151,1 +1159,0 @@\n-#end[!byteOrShort]\n@@ -1213,1 +1220,0 @@\n-#if[!byteOrShort]\n@@ -1217,2 +1223,11 @@\n-    void intoArray0($type$[] a, int offset, int[] indexMap, int mapOffset, VectorMask<$Boxtype$> m) {\n-        super.intoArray0Template($masktype$.class, a, offset, indexMap, mapOffset, ($masktype$) m);\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, $type$[] a, IV offsetMap) {\n+        super.intoArray0Template($masktype$.class, ivClass, ieClass, a, offsetMap);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    <IV extends Vector<IE>, IE>\n+    void intoArray0(Class<? extends IV> ivClass, Class<IE> ieClass, $type$[] a, IV offsetMap, VectorMask<$Boxtype$> m) {\n+        super.intoArray0Template($masktype$.class, ivClass, ieClass, a, offsetMap, ($masktype$) m);\n@@ -1220,1 +1235,0 @@\n-#end[!byteOrShort]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-    public static final String LOAD_VECTOR_GATHER = PREFIX + \"LOAD_VECTOR_GATHER\" + POSTFIX;\n+    public static final String LOAD_GATHER_INT = PREFIX + \"LOAD_GATHER_INT\" + POSTFIX;\n@@ -602,1 +602,1 @@\n-        beforeMatchingNameRegex(LOAD_VECTOR_GATHER, \"LoadVectorGather\");\n+        beforeMatchingNameRegex(LOAD_GATHER_INT, \"LoadGatherI\");\n@@ -605,1 +605,1 @@\n-    public static final String LOAD_VECTOR_GATHER_MASKED = PREFIX + \"LOAD_VECTOR_GATHER_MASKED\" + POSTFIX;\n+    public static final String LOAD_GATHER_LONG = PREFIX + \"LOAD_GATHER_LONG\" + POSTFIX;\n@@ -607,1 +607,11 @@\n-        beforeMatchingNameRegex(LOAD_VECTOR_GATHER_MASKED, \"LoadVectorGatherMasked\");\n+        beforeMatchingNameRegex(LOAD_GATHER_LONG, \"LoadGatherL\");\n+    }\n+\n+    public static final String LOAD_GATHER_INT_MASKED = PREFIX + \"LOAD_GATHER_INT_MASKED\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_GATHER_INT_MASKED, \"LoadGatherIMasked\");\n+    }\n+\n+    public static final String LOAD_GATHER_LONG_MASKED = PREFIX + \"LOAD_GATHER_LONG_MASKED\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_GATHER_LONG_MASKED, \"LoadGatherLMasked\");\n@@ -1101,1 +1111,11 @@\n-    public static final String STORE_VECTOR_SCATTER = PREFIX + \"STORE_VECTOR_SCATTER\" + POSTFIX;\n+    public static final String STORE_SCATTER_INT = PREFIX + \"STORE_SCATTER_INT\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_SCATTER_INT, \"StoreScatterI\");\n+    }\n+\n+    public static final String STORE_SCATTER_LONG = PREFIX + \"STORE_SCATTER_LONG\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_SCATTER_LONG, \"StoreScatterL\");\n+    }\n+\n+    public static final String STORE_SCATTER_INT_MASKED = PREFIX + \"STORE_SCATTER_INT_MASKED\" + POSTFIX;\n@@ -1103,1 +1123,1 @@\n-        beforeMatchingNameRegex(STORE_VECTOR_SCATTER, \"StoreVectorScatter\");\n+        beforeMatchingNameRegex(STORE_SCATTER_INT_MASKED, \"StoreScatterIMasked\");\n@@ -1106,1 +1126,1 @@\n-    public static final String STORE_VECTOR_SCATTER_MASKED = PREFIX + \"STORE_VECTOR_SCATTER_MASKED\" + POSTFIX;\n+    public static final String STORE_SCATTER_LONG_MASKED = PREFIX + \"STORE_SCATTER_LONG_MASKED\" + POSTFIX;\n@@ -1108,1 +1128,1 @@\n-        beforeMatchingNameRegex(STORE_VECTOR_SCATTER_MASKED, \"StoreVectorScatterMasked\");\n+        beforeMatchingNameRegex(STORE_SCATTER_LONG_MASKED, \"StoreScatterLMasked\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -29,8 +30,1 @@\n-\n-import jdk.incubator.vector.DoubleVector;\n-import jdk.incubator.vector.IntVector;\n-import jdk.incubator.vector.LongVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorShape;\n-import jdk.incubator.vector.VectorSpecies;\n-\n+import jdk.incubator.vector.*;\n@@ -42,1 +36,1 @@\n- * @bug 8288397\n+ * @bug 8288397 8287289\n@@ -45,2 +39,1 @@\n- * @requires vm.cpu.features ~= \".*sve.*\" & (vm.opt.MaxVectorSize == \"null\" | vm.opt.MaxVectorSize >= 16)\n- * @summary AArch64: Fix register issues in SVE backend match rules\n+ * @summary Test vector gather, scatter intrinsics\n@@ -49,1 +42,1 @@\n- * @run driver compiler.vectorapi.VectorGatherScatterTest\n+ * @run main compiler.vectorapi.VectorGatherScatterTest\n@@ -58,0 +51,3 @@\n+    private static final VectorSpecies<Float> F_SPECIES =\n+            VectorSpecies.of(float.class, VectorShape.forBitSize(L_SPECIES.vectorBitSize() \/ 2));\n+\n@@ -65,0 +61,2 @@\n+    private static float[] fa;\n+    private static float[] fr;\n@@ -74,0 +72,2 @@\n+        fa = new float[LENGTH];\n+        fr = new float[LENGTH];\n@@ -79,3 +79,4 @@\n-            ia[i] = i;\n-            la[i] = RD.nextLong(25);\n-            da[i] = RD.nextDouble(25.0);\n+            ia[i] = RD.nextInt(100);\n+            la[i] = RD.nextLong(100);\n+            fa[i] = RD.nextFloat();\n+            da[i] = RD.nextDouble();\n@@ -86,11 +87,15 @@\n-    @Test\n-    @Warmup(10000)\n-    @IR(counts = { IRNode.LOAD_VECTOR_GATHER, \">= 1\" })\n-    public static void testLoadGather() {\n-        LongVector av = LongVector.fromArray(L_SPECIES, la, 0, ia, 0);\n-        av.intoArray(lr, 0);\n-        IntVector bv = IntVector.fromArray(I_SPECIES, ia, 0);\n-        bv.add(0).intoArray(ir, 0);\n-\n-        for(int i = 0; i < I_SPECIES.length(); i++) {\n-            Asserts.assertEquals(ia[i], ir[i]);\n+    @DontInline\n+    public static void verifyGather(boolean intIndex, boolean masked) {\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            int index = intIndex ? ia[i] : (int) la[i];\n+            if (!masked || m[i]) {\n+                Asserts.assertEquals(ir[i], ia[index]);\n+                Asserts.assertEquals(lr[i], la[index]);\n+                Asserts.assertEquals(fr[i], fa[index]);\n+                Asserts.assertEquals(dr[i], da[index]);\n+            } else {\n+                Asserts.assertEquals(ir[i], 0);\n+                Asserts.assertEquals(lr[i], 0L);\n+                Asserts.assertEquals(fr[i], 0F);\n+                Asserts.assertEquals(dr[i], 0D);\n+            }\n@@ -100,14 +105,11 @@\n-    @Test\n-    @Warmup(10000)\n-    @IR(counts = { IRNode.LOAD_VECTOR_GATHER_MASKED, \">= 1\" })\n-    public static void testLoadGatherMasked() {\n-        VectorMask<Long> mask = VectorMask.fromArray(L_SPECIES, m, 0);\n-        \/\/ \"mask\" is guaranteed to be not alltrue, in case the masked\n-        \/\/ gather load is optimized to the non-masked version.\n-        LongVector av = LongVector.fromArray(L_SPECIES, la, 0, ia, 0, mask);\n-        av.intoArray(lr, 0);\n-        IntVector bv = IntVector.fromArray(I_SPECIES, ia, 0);\n-        bv.add(0).intoArray(ir, 0);\n-\n-        for(int i = 0; i < I_SPECIES.length(); i++) {\n-            Asserts.assertEquals(ia[i], ir[i]);\n+    @DontInline\n+    public static void verifyScatter(boolean intIndex, boolean masked,\n+                                     int[] ie, long[] le, float[] fe, double[] de) {\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            int index = intIndex ? ia[i] : (int) la[i];\n+            if (!masked || m[i]) {\n+                ie[index] = ia[i];\n+                le[index] = la[i];\n+                fe[index] = fa[i];\n+                de[index] = da[i];\n+            }\n@@ -115,0 +117,4 @@\n+        Asserts.assertTrue(Arrays.equals(ie, ir));\n+        Asserts.assertTrue(Arrays.equals(le, lr));\n+        Asserts.assertTrue(Arrays.equals(fe, fr));\n+        Asserts.assertTrue(Arrays.equals(de, dr));\n@@ -118,11 +124,13 @@\n-    @Warmup(10000)\n-    @IR(counts = { IRNode.STORE_VECTOR_SCATTER, \">= 1\" })\n-    public static void testStoreScatter() {\n-        DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, 0);\n-        av.intoArray(dr, 0, ia, 0);\n-        IntVector bv = IntVector.fromArray(I_SPECIES, ia, 0);\n-        bv.add(0).intoArray(ir, 0);\n-\n-        for(int i = 0; i < I_SPECIES.length(); i++) {\n-            Asserts.assertEquals(ia[i], ir[i]);\n-        }\n+    @IR(counts = {IRNode.LOAD_GATHER_INT, \"4\"}, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testGatherInt() {\n+        var idx = IntVector.fromArray(I_SPECIES, ia, 0);\n+        DoubleVector.fromArray(D_SPECIES, da, idx)\n+                .intoArray(dr, 0);\n+        FloatVector.fromArray(F_SPECIES, fa, idx)\n+                .intoArray(fr, 0);\n+        LongVector.fromArray(L_SPECIES, la, idx)\n+                .intoArray(lr, 0);\n+        IntVector.fromArray(I_SPECIES, ia, idx)\n+                .intoArray(ir, 0);\n+\n+        verifyGather(true, false);\n@@ -132,14 +140,133 @@\n-    @Warmup(10000)\n-    @IR(counts = { IRNode.STORE_VECTOR_SCATTER_MASKED, \">= 1\" })\n-    public static void testStoreScatterMasked() {\n-        VectorMask<Double> mask = VectorMask.fromArray(D_SPECIES, m, 0);\n-        DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, 0);\n-        \/\/ \"mask\" is guaranteed to be not alltrue, in case the masked\n-        \/\/ scatter store is optimized to the non-masked version.\n-        av.intoArray(dr, 0, ia, 0, mask);\n-        IntVector bv = IntVector.fromArray(I_SPECIES, ia, 0);\n-        bv.add(0).intoArray(ir, 0);\n-\n-        for(int i = 0; i < I_SPECIES.length(); i++) {\n-            Asserts.assertEquals(ia[i], ir[i]);\n-        }\n+    @IR(counts = {IRNode.LOAD_GATHER_LONG, \"4\"}, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    public static void testGatherLong() {\n+        var idx = LongVector.fromArray(L_SPECIES, la, 0);\n+        DoubleVector.fromArray(D_SPECIES, da, idx)\n+                .intoArray(dr, 0);\n+        FloatVector.fromArray(F_SPECIES, fa, idx)\n+                .intoArray(fr, 0);\n+        LongVector.fromArray(L_SPECIES, la, idx)\n+                .intoArray(lr, 0);\n+        IntVector.fromArray(I_SPECIES, ia, idx)\n+                .intoArray(ir, 0);\n+\n+        verifyGather(false, false);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_GATHER_INT_MASKED, \"4\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"sve\", \"true\"})\n+    public static void testGatherIntMasked() {\n+        var idx = IntVector.fromArray(I_SPECIES, ia, 0);\n+        var mask = VectorMask.fromArray(I_SPECIES, m, 0);\n+        DoubleVector.fromArray(D_SPECIES, da, idx, mask.cast(D_SPECIES))\n+                .intoArray(dr, 0);\n+        FloatVector.fromArray(F_SPECIES, fa, idx, mask.cast(F_SPECIES))\n+                .intoArray(fr, 0);\n+        LongVector.fromArray(L_SPECIES, la, idx, mask.cast(L_SPECIES))\n+                .intoArray(lr, 0);\n+        IntVector.fromArray(I_SPECIES, ia, idx, mask.cast(I_SPECIES))\n+                .intoArray(ir, 0);\n+\n+        verifyGather(true, true);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_GATHER_LONG_MASKED, \"4\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"sve\", \"true\"})\n+    public static void testGatherLongMasked() {\n+        var idx = LongVector.fromArray(L_SPECIES, la, 0);\n+        var mask = VectorMask.fromArray(I_SPECIES, m, 0);\n+        DoubleVector.fromArray(D_SPECIES, da, idx, mask.cast(D_SPECIES))\n+                .intoArray(dr, 0);\n+        FloatVector.fromArray(F_SPECIES, fa, idx, mask.cast(F_SPECIES))\n+                .intoArray(fr, 0);\n+        LongVector.fromArray(L_SPECIES, la, idx, mask.cast(L_SPECIES))\n+                .intoArray(lr, 0);\n+        IntVector.fromArray(I_SPECIES, ia, idx, mask.cast(I_SPECIES))\n+                .intoArray(ir, 0);\n+\n+        verifyGather(false, true);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_SCATTER_INT, \"4\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"sve\", \"true\"})\n+    public static void testScatterInt() {\n+        int[] ie = ir.clone();\n+        long[] le = lr.clone();\n+        float[] fe = fr.clone();\n+        double[] de = dr.clone();\n+\n+        var idx = IntVector.fromArray(I_SPECIES, ia, 0);\n+        DoubleVector.fromArray(D_SPECIES, da, 0)\n+                .intoArray(dr, idx);\n+        FloatVector.fromArray(F_SPECIES, fa, 0)\n+                .intoArray(fr, idx);\n+        LongVector.fromArray(L_SPECIES, la, 0)\n+                .intoArray(lr, idx);\n+        IntVector.fromArray(I_SPECIES, ia, 0)\n+                .intoArray(ir, idx);\n+\n+        verifyScatter(true, false, ie, le, fe, de);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_SCATTER_LONG, \"4\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"sve\", \"true\"})\n+    public static void testScatterLong() {\n+        int[] ie = ir.clone();\n+        long[] le = lr.clone();\n+        float[] fe = fr.clone();\n+        double[] de = dr.clone();\n+\n+        var idx = LongVector.fromArray(L_SPECIES, la, 0);\n+        DoubleVector.fromArray(D_SPECIES, da, 0)\n+                .intoArray(dr, idx);\n+        FloatVector.fromArray(F_SPECIES, fa, 0)\n+                .intoArray(fr, idx);\n+        LongVector.fromArray(L_SPECIES, la, 0)\n+                .intoArray(lr, idx);\n+        IntVector.fromArray(I_SPECIES, ia, 0)\n+                .intoArray(ir, idx);\n+\n+        verifyScatter(false, false, ie, le, fe, de);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_SCATTER_INT_MASKED, \"4\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"sve\", \"true\"})\n+    public static void testScatterIntMasked() {\n+        int[] ie = ir.clone();\n+        long[] le = lr.clone();\n+        float[] fe = fr.clone();\n+        double[] de = dr.clone();\n+\n+        var idx = IntVector.fromArray(I_SPECIES, ia, 0);\n+        var mask = VectorMask.fromArray(I_SPECIES, m, 0);\n+        DoubleVector.fromArray(D_SPECIES, da, 0)\n+                .intoArray(dr, idx, mask.cast(D_SPECIES));\n+        FloatVector.fromArray(F_SPECIES, fa, 0)\n+                .intoArray(fr, idx, mask.cast(F_SPECIES));\n+        LongVector.fromArray(L_SPECIES, la, 0)\n+                .intoArray(lr, idx, mask.cast(L_SPECIES));\n+        IntVector.fromArray(I_SPECIES, ia, 0)\n+                .intoArray(ir, idx, mask.cast(I_SPECIES));\n+\n+        verifyScatter(true, true, ie, le, fe, de);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_SCATTER_LONG_MASKED, \"4\"}, applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"sve\", \"true\"})\n+    public static void testScatterLongMasked() {\n+        int[] ie = ir.clone();\n+        long[] le = lr.clone();\n+        float[] fe = fr.clone();\n+        double[] de = dr.clone();\n+\n+        var idx = LongVector.fromArray(L_SPECIES, la, 0);\n+        var mask = VectorMask.fromArray(I_SPECIES, m, 0);\n+        DoubleVector.fromArray(D_SPECIES, da, 0)\n+                .intoArray(dr, idx, mask.cast(D_SPECIES));\n+        FloatVector.fromArray(F_SPECIES, fa, 0)\n+                .intoArray(fr, idx, mask.cast(F_SPECIES));\n+        LongVector.fromArray(L_SPECIES, la, 0)\n+                .intoArray(lr, idx, mask.cast(L_SPECIES));\n+        IntVector.fromArray(I_SPECIES, ia, 0)\n+                .intoArray(ir, idx, mask.cast(I_SPECIES));\n+\n+        verifyScatter(false, true, ie, le, fe, de);\n@@ -149,2 +276,4 @@\n-        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\",\n-                                   \"-XX:UseSVE=1\");\n+        TestFramework inst = new TestFramework();\n+        inst.setDefaultWarmup(10000)\n+                .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                .start();\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherScatterTest.java","additions":196,"deletions":67,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-\n+import java.util.function.LongFunction;\n@@ -52,2 +52,2 @@\n-    static final List<IntFunction<MemorySegment>> MEMORY_SEGMENT_GENERATORS = List.of(\n-            withToString(\"HMS\", (int s) ->\n+    static final List<LongFunction<MemorySegment>> MEMORY_SEGMENT_GENERATORS = List.of(\n+            withToString(\"HMS\", (long s) ->\n@@ -56,3 +56,7 @@\n-            withToString(\"DMS\", (int s) -> {\n-                byte[] b = new byte[s];\n-                return MemorySegment.ofArray(b);\n+            withToString(\"DMS\", (long s) -> {\n+                if (s > Integer.MAX_VALUE) {\n+                    return MemorySegment.allocateNative(s, SegmentScope.auto());\n+                } else {\n+                    byte[] b = new byte[(int) s];\n+                    return MemorySegment.ofArray(b);\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorLoadStoreTest.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.LongFunction;\n@@ -73,2 +74,2 @@\n-    static <R> BiFunction<Integer,Integer,R> withToStringBi(String s, BiFunction<Integer,Integer,R> f) {\n-        return new BiFunction<Integer,Integer,R>() {\n+    static <R> LongFunction<R> withToString(String s, LongFunction<R> f) {\n+        return new LongFunction<R>() {\n@@ -76,1 +77,15 @@\n-            public R apply(Integer v, Integer u) {\n+            public R apply(long v) {\n+                return f.apply(v);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return s;\n+            }\n+        };\n+    }\n+\n+    static <T, R> BiFunction<Integer,T,R> withToStringBi(String s, BiFunction<Integer,T,R> f) {\n+        return new BiFunction<Integer,T,R>() {\n+            @Override\n+            public R apply(Integer v, T u) {\n@@ -180,0 +195,5 @@\n+    static final List<BiFunction<Integer,Long,long[]>> LONG_INDEX_GENERATORS = List.of(\n+            withToStringBi(\"index[random]\",\n+                    (Integer l, Long m) -> RAND.longs(l, 0, m).toArray())\n+    );\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorTest.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -30,4 +30,1 @@\n-import jdk.incubator.vector.FloatVector;\n-import jdk.incubator.vector.VectorShape;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.*;\n@@ -41,0 +38,2 @@\n+    static final VectorSpecies<Integer> INT_SPECIES =\n+            IntVector.SPECIES_256;\n@@ -43,3 +42,3 @@\n-    static float[] a = new float[SIZE];\n-    static float[] b = new float[SIZE];\n-    static float[] c = new float[SIZE];\n+    static final float[] a = new float[SIZE];\n+    static final float[] b = new float[SIZE];\n+    static final float[] c = new float[SIZE];\n@@ -62,1 +61,1 @@\n-    static final int[] IDENTITY_INDEX_MAPPING = IntStream.range(0, SPECIES.length()).toArray();\n+    static final int[] IDENTITY_INDEX_MAPPING = IntStream.range(0, SIZE).toArray();\n@@ -66,3 +65,4 @@\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i, IDENTITY_INDEX_MAPPING, 0);\n-            FloatVector bv = FloatVector.fromArray(SPECIES, b, i, IDENTITY_INDEX_MAPPING, 0);\n-            av.add(bv).intoArray(c, i, IDENTITY_INDEX_MAPPING, 0);\n+            IntVector idx = IntVector.fromArray(INT_SPECIES, IDENTITY_INDEX_MAPPING, i);\n+            FloatVector av = FloatVector.fromArray(SPECIES, a, idx);\n+            FloatVector bv = FloatVector.fromArray(SPECIES, b, idx);\n+            av.add(bv).intoArray(c, idx);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AddTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.ByteVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(byte[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -786,8 +817,7 @@\n-    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n@@ -796,2 +826,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -801,8 +829,8 @@\n-    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n@@ -811,2 +839,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n@@ -822,2 +848,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -831,1 +857,1 @@\n-    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, long[] indexMap, boolean[] mask) {\n@@ -837,1 +863,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -845,1 +874,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -854,1 +883,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -863,0 +901,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -864,10 +911,13 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[b.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -875,1 +925,0 @@\n-        }\n@@ -877,1 +926,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -880,12 +930,13 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -893,1 +944,0 @@\n-        }\n@@ -895,1 +945,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -898,5 +949,16 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -904,4 +966,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -909,0 +986,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -910,0 +989,1 @@\n+    }\n@@ -911,1 +991,17 @@\n-        assertScatterArraysEquals(r, a, b);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -914,7 +1010,14 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n@@ -922,4 +1025,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n@@ -927,0 +1045,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -928,0 +1048,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n@@ -929,1 +1067,2 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -933,8 +1072,7 @@\n-    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], false, \"at index #\" + j);\n@@ -943,2 +1081,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -948,8 +1084,8 @@\n-    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], false, \"at index #\" + j);\n@@ -958,2 +1094,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n@@ -969,2 +1103,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -978,1 +1112,1 @@\n-    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, long[] indexMap, boolean[] mask) {\n@@ -984,1 +1118,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -991,10 +1128,13 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n-                av.intoBooleanArray(r, i);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void booleanGatherInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1002,1 +1142,0 @@\n-        }\n@@ -1004,1 +1143,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1007,12 +1147,13 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n-                av.intoBooleanArray(r, i);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void booleanGatherLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1020,1 +1161,0 @@\n-        }\n@@ -1022,1 +1162,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1025,10 +1166,15 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n-                av.intoBooleanArray(r, i, b, i);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void booleanGatherIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx, vmask);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1036,0 +1182,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1037,0 +1185,1 @@\n+    }\n@@ -1038,1 +1187,19 @@\n-        assertScatterArraysEquals(r, a, b);\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void booleanGatherLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx, vmask);\n+                    av.intoBooleanArray(r, i);\n+                }\n+            }\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -1041,7 +1208,14 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void booleanScatterInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx);\n+                }\n+            }\n@@ -1049,4 +1223,17 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n-                av.intoBooleanArray(r, i, b, i, vmask);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void booleanScatterLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx);\n+                }\n@@ -1054,0 +1241,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1055,0 +1244,1 @@\n+    }\n@@ -1056,1 +1246,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void booleanScatterIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1059,0 +1267,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void booleanScatterLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":384,"deletions":156,"binary":false,"changes":540,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.ByteVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(byte[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -786,8 +817,7 @@\n-    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n@@ -796,2 +826,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -801,8 +829,8 @@\n-    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n@@ -811,2 +839,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n@@ -822,2 +848,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -831,1 +857,1 @@\n-    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, long[] indexMap, boolean[] mask) {\n@@ -837,1 +863,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -845,1 +874,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -854,1 +883,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -863,0 +901,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -864,10 +911,13 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[b.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -875,1 +925,0 @@\n-        }\n@@ -877,1 +926,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -880,12 +930,13 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -893,1 +944,0 @@\n-        }\n@@ -895,1 +945,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -898,5 +949,16 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -904,4 +966,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -909,0 +986,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -910,0 +989,1 @@\n+    }\n@@ -911,1 +991,17 @@\n-        assertScatterArraysEquals(r, a, b);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -914,7 +1010,14 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n@@ -922,4 +1025,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n@@ -927,0 +1045,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -928,0 +1048,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n@@ -929,1 +1067,2 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -933,8 +1072,7 @@\n-    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], false, \"at index #\" + j);\n@@ -943,2 +1081,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -948,8 +1084,8 @@\n-    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], false, \"at index #\" + j);\n@@ -958,2 +1094,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n@@ -969,2 +1103,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -978,1 +1112,1 @@\n-    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, long[] indexMap, boolean[] mask) {\n@@ -984,1 +1118,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -991,10 +1128,13 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n-                av.intoBooleanArray(r, i);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void booleanGatherInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1002,1 +1142,0 @@\n-        }\n@@ -1004,1 +1143,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1007,12 +1147,13 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n-                av.intoBooleanArray(r, i);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void booleanGatherLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1020,1 +1161,0 @@\n-        }\n@@ -1022,1 +1162,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1025,10 +1166,15 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n-                av.intoBooleanArray(r, i, b, i);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void booleanGatherIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx, vmask);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1036,0 +1182,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1037,0 +1185,1 @@\n+    }\n@@ -1038,1 +1187,19 @@\n-        assertScatterArraysEquals(r, a, b);\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void booleanGatherLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx, vmask);\n+                    av.intoBooleanArray(r, i);\n+                }\n+            }\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -1041,7 +1208,14 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void booleanScatterInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx);\n+                }\n+            }\n@@ -1049,4 +1223,17 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n-                av.intoBooleanArray(r, i, b, i, vmask);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void booleanScatterLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx);\n+                }\n@@ -1054,0 +1241,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1055,0 +1244,1 @@\n+    }\n@@ -1056,1 +1246,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void booleanScatterIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1059,0 +1267,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void booleanScatterLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":384,"deletions":156,"binary":false,"changes":540,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.ByteVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(byte[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -786,8 +817,7 @@\n-    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n@@ -796,2 +826,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -801,8 +829,8 @@\n-    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n@@ -811,2 +839,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n@@ -822,2 +848,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -831,1 +857,1 @@\n-    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, long[] indexMap, boolean[] mask) {\n@@ -837,1 +863,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -845,1 +874,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -854,1 +883,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -863,0 +901,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -864,10 +911,13 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[b.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -875,1 +925,0 @@\n-        }\n@@ -877,1 +926,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -880,12 +930,13 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -893,1 +944,0 @@\n-        }\n@@ -895,1 +945,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -898,5 +949,16 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -904,4 +966,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -909,0 +986,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -910,0 +989,1 @@\n+    }\n@@ -911,1 +991,17 @@\n-        assertScatterArraysEquals(r, a, b);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -914,7 +1010,14 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n@@ -922,4 +1025,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n@@ -927,0 +1045,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -928,0 +1048,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n@@ -929,1 +1067,2 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -933,8 +1072,7 @@\n-    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], false, \"at index #\" + j);\n@@ -943,2 +1081,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -948,8 +1084,8 @@\n-    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], false, \"at index #\" + j);\n@@ -958,2 +1094,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n@@ -969,2 +1103,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -978,1 +1112,1 @@\n-    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, long[] indexMap, boolean[] mask) {\n@@ -984,1 +1118,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -991,10 +1128,13 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n-                av.intoBooleanArray(r, i);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void booleanGatherInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1002,1 +1142,0 @@\n-        }\n@@ -1004,1 +1143,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1007,12 +1147,13 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n-                av.intoBooleanArray(r, i);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void booleanGatherLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1020,1 +1161,0 @@\n-        }\n@@ -1022,1 +1162,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1025,10 +1166,15 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n-                av.intoBooleanArray(r, i, b, i);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void booleanGatherIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx, vmask);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1036,0 +1182,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1037,0 +1185,1 @@\n+    }\n@@ -1038,1 +1187,19 @@\n-        assertScatterArraysEquals(r, a, b);\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void booleanGatherLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx, vmask);\n+                    av.intoBooleanArray(r, i);\n+                }\n+            }\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -1041,7 +1208,14 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void booleanScatterInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx);\n+                }\n+            }\n@@ -1049,4 +1223,17 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n-                av.intoBooleanArray(r, i, b, i, vmask);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void booleanScatterLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx);\n+                }\n@@ -1054,0 +1241,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1055,0 +1244,1 @@\n+    }\n@@ -1056,1 +1246,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void booleanScatterIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1059,0 +1267,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void booleanScatterLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":384,"deletions":156,"binary":false,"changes":540,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.ByteVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(byte[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -786,8 +817,7 @@\n-    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n@@ -796,2 +826,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -801,8 +829,8 @@\n-    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n@@ -811,2 +839,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n@@ -822,2 +848,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -831,1 +857,1 @@\n-    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, long[] indexMap, boolean[] mask) {\n@@ -837,1 +863,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -845,1 +874,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -854,1 +883,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -863,0 +901,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -864,10 +911,13 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[b.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -875,1 +925,0 @@\n-        }\n@@ -877,1 +926,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -880,12 +930,13 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -893,1 +944,0 @@\n-        }\n@@ -895,1 +945,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -898,5 +949,16 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -904,4 +966,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -909,0 +986,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -910,0 +989,1 @@\n+    }\n@@ -911,1 +991,17 @@\n-        assertScatterArraysEquals(r, a, b);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -914,7 +1010,14 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n@@ -922,4 +1025,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n@@ -927,0 +1045,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -928,0 +1048,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n@@ -929,1 +1067,2 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -933,8 +1072,7 @@\n-    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], false, \"at index #\" + j);\n@@ -943,2 +1081,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -948,8 +1084,8 @@\n-    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], false, \"at index #\" + j);\n@@ -958,2 +1094,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n@@ -969,2 +1103,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -978,1 +1112,1 @@\n-    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, long[] indexMap, boolean[] mask) {\n@@ -984,1 +1118,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -991,10 +1128,13 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n-                av.intoBooleanArray(r, i);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void booleanGatherInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1002,1 +1142,0 @@\n-        }\n@@ -1004,1 +1143,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1007,12 +1147,13 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n-                av.intoBooleanArray(r, i);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void booleanGatherLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1020,1 +1161,0 @@\n-        }\n@@ -1022,1 +1162,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1025,10 +1166,15 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n-                av.intoBooleanArray(r, i, b, i);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void booleanGatherIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx, vmask);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1036,0 +1182,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1037,0 +1185,1 @@\n+    }\n@@ -1038,1 +1187,19 @@\n-        assertScatterArraysEquals(r, a, b);\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void booleanGatherLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx, vmask);\n+                    av.intoBooleanArray(r, i);\n+                }\n+            }\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -1041,7 +1208,14 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void booleanScatterInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx);\n+                }\n+            }\n@@ -1049,4 +1223,17 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n-                av.intoBooleanArray(r, i, b, i, vmask);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void booleanScatterLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx);\n+                }\n@@ -1054,0 +1241,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1055,0 +1244,1 @@\n+    }\n@@ -1056,1 +1246,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void booleanScatterIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1059,0 +1267,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void booleanScatterLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":384,"deletions":156,"binary":false,"changes":540,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,5 +38,1 @@\n-import jdk.incubator.vector.ByteVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorShape;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -50,0 +46,1 @@\n+import java.util.Objects;\n@@ -57,0 +54,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -229,1 +259,1 @@\n-    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(byte[] a, LongFunction<MemorySegment> fb) {\n@@ -469,1 +499,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -548,1 +578,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -645,1 +675,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -793,8 +823,7 @@\n-    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n@@ -803,2 +832,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -808,8 +835,8 @@\n-    static void assertGatherArraysEquals(byte[] r, byte[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0);\n+    static void assertGatherArraysEquals(byte[] r, byte[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n@@ -818,2 +845,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (byte) 0, \"at index #\" + j);\n@@ -829,2 +854,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -838,1 +863,1 @@\n-    static void assertScatterArraysEquals(byte[] r, byte[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(byte[] r, byte[] a, long[] indexMap, boolean[] mask) {\n@@ -844,1 +869,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -852,1 +880,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -861,1 +889,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -870,0 +907,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            BYTE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -871,5 +917,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[b.length];\n@@ -877,4 +924,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -882,1 +931,0 @@\n-        }\n@@ -884,1 +932,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -887,7 +936,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n@@ -895,4 +943,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -900,1 +950,0 @@\n-        }\n@@ -902,1 +951,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -905,10 +955,15 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -916,0 +971,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -917,0 +974,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -918,1 +993,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -921,7 +997,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        byte[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n@@ -929,4 +1004,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -934,0 +1011,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -935,0 +1014,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n@@ -936,1 +1023,10 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -939,0 +1035,16 @@\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n@@ -940,8 +1052,18 @@\n-    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            byte[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            byte[] r = new byte[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n@@ -950,2 +1072,2 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -955,0 +1077,1 @@\n+\n@@ -956,7 +1079,19 @@\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], false, \"at index #\" + j);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], false, \"at index #\" + j);\n@@ -965,2 +1100,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n@@ -976,2 +1109,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -985,1 +1118,1 @@\n-    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, long[] indexMap, boolean[] mask) {\n@@ -991,1 +1124,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -998,5 +1134,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void booleanGatherInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n@@ -1004,4 +1141,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i);\n-                av.intoBooleanArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1009,1 +1148,0 @@\n-        }\n@@ -1011,1 +1149,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1014,7 +1153,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void booleanGatherLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n@@ -1022,4 +1160,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n-                av.intoBooleanArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1027,1 +1167,0 @@\n-        }\n@@ -1029,1 +1168,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1032,5 +1172,16 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void booleanGatherIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx, vmask);\n+                    av.intoBooleanArray(r, i);\n+                }\n+            }\n@@ -1038,4 +1189,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n-                av.intoBooleanArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void booleanGatherLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, idx, vmask);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1043,0 +1209,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1044,0 +1212,16 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void booleanScatterInt(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx);\n+                }\n+            }\n@@ -1045,1 +1229,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1048,7 +1233,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void booleanScatterLong(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n@@ -1056,4 +1240,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n-                av.intoBooleanArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx);\n+                }\n@@ -1061,0 +1247,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1062,0 +1250,1 @@\n+    }\n@@ -1063,1 +1252,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void booleanScatterIntMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1066,0 +1273,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void booleanScatterLongMask(IntFunction<byte[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ByteVector av = ByteVector.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":379,"deletions":152,"binary":false,"changes":531,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.DoubleVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(double[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+    static void assertGatherArraysEquals(double[] r, double[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(double[] r, double[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.DoubleVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(double[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+    static void assertGatherArraysEquals(double[] r, double[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(double[] r, double[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.DoubleVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(double[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+    static void assertGatherArraysEquals(double[] r, double[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(double[] r, double[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.DoubleVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(double[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+    static void assertGatherArraysEquals(double[] r, double[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(double[] r, double[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,5 +38,1 @@\n-import jdk.incubator.vector.DoubleVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorShape;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -50,0 +46,1 @@\n+import java.util.Objects;\n@@ -57,0 +54,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -229,1 +259,1 @@\n-    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(double[] a, LongFunction<MemorySegment> fb) {\n@@ -469,1 +499,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -548,1 +578,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -645,1 +675,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -706,8 +736,7 @@\n-    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n@@ -716,2 +745,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -721,8 +748,8 @@\n-    static void assertGatherArraysEquals(double[] r, double[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0);\n+    static void assertGatherArraysEquals(double[] r, double[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n@@ -731,2 +758,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (double) 0, \"at index #\" + j);\n@@ -742,2 +767,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -751,1 +776,1 @@\n-    static void assertScatterArraysEquals(double[] r, double[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(double[] r, double[] a, long[] indexMap, boolean[] mask) {\n@@ -757,1 +782,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -765,1 +793,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -774,1 +802,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -783,0 +820,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            DOUBLE_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -784,5 +830,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[b.length];\n@@ -790,4 +837,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -795,1 +844,0 @@\n-        }\n@@ -797,1 +845,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -800,7 +849,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n@@ -808,4 +856,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -813,0 +863,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -814,0 +866,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -815,1 +885,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -818,5 +889,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -824,4 +898,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -829,0 +905,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -830,0 +908,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n@@ -831,1 +917,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -834,7 +929,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        double[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        double[] r = new double[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n@@ -842,4 +936,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -847,0 +943,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -848,0 +946,1 @@\n+    }\n@@ -849,1 +948,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<double[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -852,0 +969,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<double[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            double[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            double[] r = new double[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":218,"deletions":81,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.FloatVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(float[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+    static void assertGatherArraysEquals(float[] r, float[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(float[] r, float[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.FloatVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(float[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+    static void assertGatherArraysEquals(float[] r, float[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(float[] r, float[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.FloatVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(float[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+    static void assertGatherArraysEquals(float[] r, float[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(float[] r, float[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.FloatVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(float[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+    static void assertGatherArraysEquals(float[] r, float[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(float[] r, float[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,5 +38,1 @@\n-import jdk.incubator.vector.FloatVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorShape;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -50,0 +46,1 @@\n+import java.util.Objects;\n@@ -57,0 +54,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -229,1 +259,1 @@\n-    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(float[] a, LongFunction<MemorySegment> fb) {\n@@ -469,1 +499,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -548,1 +578,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -645,1 +675,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -706,8 +736,7 @@\n-    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n@@ -716,2 +745,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -721,8 +748,8 @@\n-    static void assertGatherArraysEquals(float[] r, float[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0);\n+    static void assertGatherArraysEquals(float[] r, float[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n@@ -731,2 +758,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (float) 0, \"at index #\" + j);\n@@ -742,2 +767,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -751,1 +776,1 @@\n-    static void assertScatterArraysEquals(float[] r, float[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(float[] r, float[] a, long[] indexMap, boolean[] mask) {\n@@ -757,1 +782,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -765,1 +793,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -774,1 +802,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -783,0 +820,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            FLOAT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -784,5 +830,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[b.length];\n@@ -790,4 +837,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -795,1 +844,0 @@\n-        }\n@@ -797,1 +845,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -800,7 +849,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n@@ -808,4 +856,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -813,0 +863,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -814,0 +866,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -815,1 +885,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -818,5 +889,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -824,4 +898,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -829,0 +905,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -830,0 +908,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n@@ -831,1 +917,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -834,7 +929,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        float[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        float[] r = new float[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n@@ -842,4 +936,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -847,0 +943,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -848,0 +946,1 @@\n+    }\n@@ -849,1 +948,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<float[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -852,0 +969,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<float[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            float[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            float[] r = new float[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":218,"deletions":81,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.IntVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(int[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+    static void assertGatherArraysEquals(int[] r, int[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(int[] r, int[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.IntVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(int[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+    static void assertGatherArraysEquals(int[] r, int[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(int[] r, int[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.IntVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(int[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+    static void assertGatherArraysEquals(int[] r, int[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(int[] r, int[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.IntVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(int[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+    static void assertGatherArraysEquals(int[] r, int[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(int[] r, int[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,5 +38,1 @@\n-import jdk.incubator.vector.IntVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorShape;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -50,0 +46,1 @@\n+import java.util.Objects;\n@@ -57,0 +54,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -229,1 +259,1 @@\n-    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(int[] a, LongFunction<MemorySegment> fb) {\n@@ -469,1 +499,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -548,1 +578,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -645,1 +675,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -706,8 +736,7 @@\n-    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n@@ -716,2 +745,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -721,8 +748,8 @@\n-    static void assertGatherArraysEquals(int[] r, int[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0);\n+    static void assertGatherArraysEquals(int[] r, int[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n@@ -731,2 +758,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (int) 0, \"at index #\" + j);\n@@ -742,2 +767,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -751,1 +776,1 @@\n-    static void assertScatterArraysEquals(int[] r, int[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(int[] r, int[] a, long[] indexMap, boolean[] mask) {\n@@ -757,1 +782,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -765,1 +793,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -774,1 +802,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -783,0 +820,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            INT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -784,5 +830,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[b.length];\n@@ -790,4 +837,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -795,1 +844,0 @@\n-        }\n@@ -797,1 +845,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -800,7 +849,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n@@ -808,4 +856,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -813,0 +863,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -814,0 +866,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -815,1 +885,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -818,5 +889,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -824,4 +898,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -829,0 +905,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -830,0 +908,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n@@ -831,1 +917,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -834,7 +929,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        int[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        int[] r = new int[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n@@ -842,4 +936,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -847,0 +943,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -848,0 +946,1 @@\n+    }\n@@ -849,1 +948,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<int[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -852,0 +969,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<int[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            int[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            int[] r = new int[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":218,"deletions":81,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.LongVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(long[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+    static void assertGatherArraysEquals(long[] r, long[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(long[] r, long[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.LongVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(long[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+    static void assertGatherArraysEquals(long[] r, long[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(long[] r, long[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.LongVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(long[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+    static void assertGatherArraysEquals(long[] r, long[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(long[] r, long[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.LongVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(long[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -699,8 +730,7 @@\n-    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n@@ -709,2 +739,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -714,8 +742,8 @@\n-    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+    static void assertGatherArraysEquals(long[] r, long[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n@@ -724,2 +752,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n@@ -735,2 +761,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -744,1 +770,1 @@\n-    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(long[] r, long[] a, long[] indexMap, boolean[] mask) {\n@@ -750,1 +776,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -758,1 +787,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -767,1 +796,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -776,0 +814,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -777,5 +824,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[b.length];\n@@ -783,4 +831,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -788,1 +838,0 @@\n-        }\n@@ -790,1 +839,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -793,7 +843,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n@@ -801,4 +850,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -806,0 +857,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -807,0 +860,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -808,1 +879,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -811,5 +883,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -817,4 +892,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -822,0 +899,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -823,0 +902,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n@@ -824,1 +911,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -827,7 +923,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n@@ -835,4 +930,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -840,0 +937,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -841,0 +940,1 @@\n+    }\n@@ -842,1 +942,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -845,0 +963,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":218,"deletions":80,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,5 +38,1 @@\n-import jdk.incubator.vector.LongVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorShape;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -50,0 +46,1 @@\n+import java.util.Objects;\n@@ -57,0 +54,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -229,1 +259,1 @@\n-    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(long[] a, LongFunction<MemorySegment> fb) {\n@@ -469,1 +499,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -548,1 +578,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -645,1 +675,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -706,8 +736,7 @@\n-    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n@@ -716,2 +745,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -721,8 +748,8 @@\n-    static void assertGatherArraysEquals(long[] r, long[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0);\n+    static void assertGatherArraysEquals(long[] r, long[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n@@ -731,2 +758,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (long) 0, \"at index #\" + j);\n@@ -742,2 +767,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -751,1 +776,1 @@\n-    static void assertScatterArraysEquals(long[] r, long[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(long[] r, long[] a, long[] indexMap, boolean[] mask) {\n@@ -757,1 +782,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -765,1 +793,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -774,1 +802,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -783,0 +820,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            LONG_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -784,5 +830,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[b.length];\n@@ -790,4 +837,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -795,1 +844,0 @@\n-        }\n@@ -797,1 +845,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -800,7 +849,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n@@ -808,4 +856,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -813,0 +863,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -814,0 +866,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -815,1 +885,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -818,5 +889,8 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -824,4 +898,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -829,0 +905,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -830,0 +908,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n@@ -831,1 +917,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -834,7 +929,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        long[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        long[] r = new long[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n@@ -842,4 +936,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -847,0 +943,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -848,0 +946,1 @@\n+    }\n@@ -849,1 +948,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<long[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -852,0 +969,20 @@\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<long[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            long[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            long[] r = new long[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":218,"deletions":81,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.ShortVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(short[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -943,8 +974,7 @@\n-    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n@@ -953,2 +983,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -958,8 +986,8 @@\n-    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+    static void assertGatherArraysEquals(short[] r, short[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n@@ -968,2 +996,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n@@ -979,2 +1005,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -988,1 +1014,1 @@\n-    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(short[] r, short[] a, long[] indexMap, boolean[] mask) {\n@@ -994,1 +1020,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1002,1 +1031,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -1011,1 +1040,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -1020,0 +1058,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -1021,5 +1068,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[b.length];\n@@ -1027,4 +1075,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -1032,1 +1082,0 @@\n-        }\n@@ -1034,1 +1083,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1037,7 +1087,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n@@ -1045,4 +1094,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -1050,1 +1101,0 @@\n-        }\n@@ -1052,1 +1102,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1055,5 +1106,16 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -1061,4 +1123,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -1066,0 +1143,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1067,0 +1146,16 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n@@ -1068,1 +1163,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1071,7 +1167,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n@@ -1079,4 +1174,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -1084,0 +1181,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1085,0 +1184,1 @@\n+    }\n@@ -1086,1 +1186,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1089,8 +1207,14 @@\n-    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n@@ -1099,2 +1223,2 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -1105,7 +1229,19 @@\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (char) 0, \"at index #\" + j);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (char) 0, \"at index #\" + j);\n@@ -1114,2 +1250,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n@@ -1125,2 +1259,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -1134,1 +1268,1 @@\n-    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(char[] r, char[] a, long[] indexMap, boolean[] mask) {\n@@ -1140,1 +1274,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1148,1 +1285,1 @@\n-    public Object[][] charGatherScatterProvider() {\n+    public Object[][] charGatherScatterIntProvider() {\n@@ -1157,1 +1294,10 @@\n-    public Object[][] charGatherScatterMaskProvider() {\n+    public Object[][] charGatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterIntMaskProvider() {\n@@ -1166,0 +1312,9 @@\n+    @DataProvider\n+    public Object[][] charGatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -1167,5 +1322,6 @@\n-    @Test(dataProvider = \"charGatherScatterProvider\")\n-    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n+    @Test(dataProvider = \"charGatherScatterIntProvider\")\n+    static void charGatherInt(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n@@ -1173,4 +1329,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n-                av.intoCharArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1178,1 +1336,0 @@\n-        }\n@@ -1180,1 +1337,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1183,7 +1341,6 @@\n-    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n-    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"charGatherScatterLongProvider\")\n+    static void charGatherLong(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n@@ -1191,4 +1348,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n-                av.intoCharArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1196,1 +1355,0 @@\n-        }\n@@ -1198,1 +1356,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1201,5 +1360,16 @@\n-    @Test(dataProvider = \"charGatherScatterProvider\")\n-    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n+    @Test(dataProvider = \"charGatherScatterIntMaskProvider\")\n+    static void charGatherIntMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx, vmask);\n+                    av.intoCharArray(r, i);\n+                }\n+            }\n@@ -1207,4 +1377,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n-                av.intoCharArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterLongMaskProvider\")\n+    static void charGatherLongMask(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx, vmask);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1212,0 +1397,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1213,0 +1400,16 @@\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterIntProvider\")\n+    static void charScatterInt(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx);\n+                }\n+            }\n@@ -1214,1 +1417,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1217,7 +1421,6 @@\n-    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n-    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"charGatherScatterLongProvider\")\n+    static void charScatterLong(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n@@ -1225,4 +1428,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n-                av.intoCharArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx);\n+                }\n@@ -1230,0 +1435,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1231,0 +1438,1 @@\n+    }\n@@ -1232,1 +1440,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"charGatherScatterIntMaskProvider\")\n+    static void charScatterIntMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1235,0 +1461,20 @@\n+    @Test(dataProvider = \"charGatherScatterLongMaskProvider\")\n+    static void charScatterLongMask(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":398,"deletions":152,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.ShortVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(short[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -943,8 +974,7 @@\n-    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n@@ -953,2 +983,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -958,8 +986,8 @@\n-    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+    static void assertGatherArraysEquals(short[] r, short[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n@@ -968,2 +996,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n@@ -979,2 +1005,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -988,1 +1014,1 @@\n-    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(short[] r, short[] a, long[] indexMap, boolean[] mask) {\n@@ -994,1 +1020,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1002,1 +1031,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -1011,1 +1040,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -1020,0 +1058,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -1021,5 +1068,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[b.length];\n@@ -1027,4 +1075,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -1032,1 +1082,0 @@\n-        }\n@@ -1034,1 +1083,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1037,7 +1087,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n@@ -1045,4 +1094,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -1050,1 +1101,0 @@\n-        }\n@@ -1052,1 +1102,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1055,5 +1106,16 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -1061,4 +1123,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -1066,0 +1143,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1067,0 +1146,16 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n@@ -1068,1 +1163,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1071,7 +1167,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n@@ -1079,4 +1174,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -1084,0 +1181,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1085,0 +1184,1 @@\n+    }\n@@ -1086,1 +1186,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1089,8 +1207,14 @@\n-    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n@@ -1099,2 +1223,2 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -1105,7 +1229,19 @@\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (char) 0, \"at index #\" + j);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (char) 0, \"at index #\" + j);\n@@ -1114,2 +1250,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n@@ -1125,2 +1259,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -1134,1 +1268,1 @@\n-    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(char[] r, char[] a, long[] indexMap, boolean[] mask) {\n@@ -1140,1 +1274,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1148,1 +1285,1 @@\n-    public Object[][] charGatherScatterProvider() {\n+    public Object[][] charGatherScatterIntProvider() {\n@@ -1157,1 +1294,10 @@\n-    public Object[][] charGatherScatterMaskProvider() {\n+    public Object[][] charGatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterIntMaskProvider() {\n@@ -1166,0 +1312,9 @@\n+    @DataProvider\n+    public Object[][] charGatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -1167,5 +1322,6 @@\n-    @Test(dataProvider = \"charGatherScatterProvider\")\n-    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n+    @Test(dataProvider = \"charGatherScatterIntProvider\")\n+    static void charGatherInt(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n@@ -1173,4 +1329,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n-                av.intoCharArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1178,1 +1336,0 @@\n-        }\n@@ -1180,1 +1337,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1183,7 +1341,6 @@\n-    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n-    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"charGatherScatterLongProvider\")\n+    static void charGatherLong(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n@@ -1191,4 +1348,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n-                av.intoCharArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1196,1 +1355,0 @@\n-        }\n@@ -1198,1 +1356,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1201,5 +1360,16 @@\n-    @Test(dataProvider = \"charGatherScatterProvider\")\n-    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n+    @Test(dataProvider = \"charGatherScatterIntMaskProvider\")\n+    static void charGatherIntMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx, vmask);\n+                    av.intoCharArray(r, i);\n+                }\n+            }\n@@ -1207,4 +1377,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n-                av.intoCharArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterLongMaskProvider\")\n+    static void charGatherLongMask(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx, vmask);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1212,0 +1397,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1213,0 +1400,16 @@\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterIntProvider\")\n+    static void charScatterInt(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx);\n+                }\n+            }\n@@ -1214,1 +1417,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1217,7 +1421,6 @@\n-    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n-    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"charGatherScatterLongProvider\")\n+    static void charScatterLong(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n@@ -1225,4 +1428,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n-                av.intoCharArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx);\n+                }\n@@ -1230,0 +1435,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1231,0 +1438,1 @@\n+    }\n@@ -1232,1 +1440,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"charGatherScatterIntMaskProvider\")\n+    static void charScatterIntMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1235,0 +1461,20 @@\n+    @Test(dataProvider = \"charGatherScatterLongMaskProvider\")\n+    static void charScatterLongMask(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":398,"deletions":152,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.ShortVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(short[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -943,8 +974,7 @@\n-    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n@@ -953,2 +983,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -958,8 +986,8 @@\n-    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+    static void assertGatherArraysEquals(short[] r, short[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n@@ -968,2 +996,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n@@ -979,2 +1005,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -988,1 +1014,1 @@\n-    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(short[] r, short[] a, long[] indexMap, boolean[] mask) {\n@@ -994,1 +1020,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1002,1 +1031,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -1011,1 +1040,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -1020,0 +1058,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -1021,5 +1068,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[b.length];\n@@ -1027,4 +1075,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -1032,1 +1082,0 @@\n-        }\n@@ -1034,1 +1083,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1037,7 +1087,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n@@ -1045,4 +1094,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -1050,1 +1101,0 @@\n-        }\n@@ -1052,1 +1102,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1055,5 +1106,16 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -1061,4 +1123,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -1066,0 +1143,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1067,0 +1146,16 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n@@ -1068,1 +1163,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1071,7 +1167,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n@@ -1079,4 +1174,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -1084,0 +1181,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1085,0 +1184,1 @@\n+    }\n@@ -1086,1 +1186,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1089,8 +1207,14 @@\n-    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n@@ -1099,2 +1223,2 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -1105,7 +1229,19 @@\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (char) 0, \"at index #\" + j);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (char) 0, \"at index #\" + j);\n@@ -1114,2 +1250,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n@@ -1125,2 +1259,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -1134,1 +1268,1 @@\n-    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(char[] r, char[] a, long[] indexMap, boolean[] mask) {\n@@ -1140,1 +1274,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1148,1 +1285,1 @@\n-    public Object[][] charGatherScatterProvider() {\n+    public Object[][] charGatherScatterIntProvider() {\n@@ -1157,1 +1294,10 @@\n-    public Object[][] charGatherScatterMaskProvider() {\n+    public Object[][] charGatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterIntMaskProvider() {\n@@ -1166,0 +1312,9 @@\n+    @DataProvider\n+    public Object[][] charGatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -1167,5 +1322,6 @@\n-    @Test(dataProvider = \"charGatherScatterProvider\")\n-    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n+    @Test(dataProvider = \"charGatherScatterIntProvider\")\n+    static void charGatherInt(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n@@ -1173,4 +1329,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n-                av.intoCharArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1178,1 +1336,0 @@\n-        }\n@@ -1180,1 +1337,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1183,7 +1341,6 @@\n-    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n-    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"charGatherScatterLongProvider\")\n+    static void charGatherLong(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n@@ -1191,4 +1348,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n-                av.intoCharArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1196,1 +1355,0 @@\n-        }\n@@ -1198,1 +1356,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1201,5 +1360,16 @@\n-    @Test(dataProvider = \"charGatherScatterProvider\")\n-    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n+    @Test(dataProvider = \"charGatherScatterIntMaskProvider\")\n+    static void charGatherIntMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx, vmask);\n+                    av.intoCharArray(r, i);\n+                }\n+            }\n@@ -1207,4 +1377,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n-                av.intoCharArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterLongMaskProvider\")\n+    static void charGatherLongMask(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx, vmask);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1212,0 +1397,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1213,0 +1400,16 @@\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterIntProvider\")\n+    static void charScatterInt(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx);\n+                }\n+            }\n@@ -1214,1 +1417,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1217,7 +1421,6 @@\n-    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n-    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"charGatherScatterLongProvider\")\n+    static void charScatterLong(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n@@ -1225,4 +1428,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n-                av.intoCharArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx);\n+                }\n@@ -1230,0 +1435,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1231,0 +1438,1 @@\n+    }\n@@ -1232,1 +1440,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"charGatherScatterIntMaskProvider\")\n+    static void charScatterIntMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1235,0 +1461,20 @@\n+    @Test(dataProvider = \"charGatherScatterLongMaskProvider\")\n+    static void charScatterLongMask(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":398,"deletions":152,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,1 @@\n-import jdk.incubator.vector.ShortVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -48,0 +45,1 @@\n+import java.util.Objects;\n@@ -55,0 +53,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -222,1 +253,1 @@\n-    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(short[] a, LongFunction<MemorySegment> fb) {\n@@ -462,1 +493,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -541,1 +572,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -638,1 +669,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -943,8 +974,7 @@\n-    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n@@ -953,2 +983,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -958,8 +986,8 @@\n-    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+    static void assertGatherArraysEquals(short[] r, short[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n@@ -968,2 +996,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n@@ -979,2 +1005,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -988,1 +1014,1 @@\n-    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(short[] r, short[] a, long[] indexMap, boolean[] mask) {\n@@ -994,1 +1020,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1002,1 +1031,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -1011,1 +1040,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -1020,0 +1058,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -1021,5 +1068,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[b.length];\n@@ -1027,4 +1075,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -1032,1 +1082,0 @@\n-        }\n@@ -1034,1 +1083,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1037,7 +1087,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n@@ -1045,4 +1094,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -1050,1 +1101,0 @@\n-        }\n@@ -1052,1 +1102,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1055,5 +1106,16 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -1061,4 +1123,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -1066,0 +1143,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1067,0 +1146,16 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n@@ -1068,1 +1163,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1071,7 +1167,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n@@ -1079,4 +1174,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -1084,0 +1181,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1085,0 +1184,1 @@\n+    }\n@@ -1086,1 +1186,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1089,8 +1207,14 @@\n-    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n@@ -1099,2 +1223,2 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -1105,7 +1229,19 @@\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (char) 0, \"at index #\" + j);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (char) 0, \"at index #\" + j);\n@@ -1114,2 +1250,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n@@ -1125,2 +1259,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -1134,1 +1268,1 @@\n-    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(char[] r, char[] a, long[] indexMap, boolean[] mask) {\n@@ -1140,1 +1274,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1148,1 +1285,1 @@\n-    public Object[][] charGatherScatterProvider() {\n+    public Object[][] charGatherScatterIntProvider() {\n@@ -1157,1 +1294,10 @@\n-    public Object[][] charGatherScatterMaskProvider() {\n+    public Object[][] charGatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterIntMaskProvider() {\n@@ -1166,0 +1312,9 @@\n+    @DataProvider\n+    public Object[][] charGatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -1167,5 +1322,6 @@\n-    @Test(dataProvider = \"charGatherScatterProvider\")\n-    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n+    @Test(dataProvider = \"charGatherScatterIntProvider\")\n+    static void charGatherInt(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n@@ -1173,4 +1329,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n-                av.intoCharArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1178,1 +1336,0 @@\n-        }\n@@ -1180,1 +1337,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1183,7 +1341,6 @@\n-    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n-    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"charGatherScatterLongProvider\")\n+    static void charGatherLong(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n@@ -1191,4 +1348,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n-                av.intoCharArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1196,1 +1355,0 @@\n-        }\n@@ -1198,1 +1356,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1201,5 +1360,16 @@\n-    @Test(dataProvider = \"charGatherScatterProvider\")\n-    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n+    @Test(dataProvider = \"charGatherScatterIntMaskProvider\")\n+    static void charGatherIntMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx, vmask);\n+                    av.intoCharArray(r, i);\n+                }\n+            }\n@@ -1207,4 +1377,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n-                av.intoCharArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterLongMaskProvider\")\n+    static void charGatherLongMask(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx, vmask);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1212,0 +1397,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1213,0 +1400,16 @@\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterIntProvider\")\n+    static void charScatterInt(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx);\n+                }\n+            }\n@@ -1214,1 +1417,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1217,7 +1421,6 @@\n-    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n-    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"charGatherScatterLongProvider\")\n+    static void charScatterLong(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n@@ -1225,4 +1428,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n-                av.intoCharArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx);\n+                }\n@@ -1230,0 +1435,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1231,0 +1438,1 @@\n+    }\n@@ -1232,1 +1440,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"charGatherScatterIntMaskProvider\")\n+    static void charScatterIntMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1235,0 +1461,20 @@\n+    @Test(dataProvider = \"charGatherScatterLongMaskProvider\")\n+    static void charScatterLongMask(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":398,"deletions":152,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,5 +38,1 @@\n-import jdk.incubator.vector.ShortVector;\n-import jdk.incubator.vector.VectorMask;\n-import jdk.incubator.vector.VectorShape;\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -50,0 +46,1 @@\n+import java.util.Objects;\n@@ -57,0 +54,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -229,1 +259,1 @@\n-    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment(short[] a, LongFunction<MemorySegment> fb) {\n@@ -469,1 +499,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -548,1 +578,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -645,1 +675,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -950,8 +980,7 @@\n-    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n@@ -960,2 +989,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -965,8 +992,8 @@\n-    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+    static void assertGatherArraysEquals(short[] r, short[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n@@ -975,2 +1002,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n@@ -986,2 +1011,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -995,1 +1020,1 @@\n-    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(short[] r, short[] a, long[] indexMap, boolean[] mask) {\n@@ -1001,1 +1026,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1009,1 +1037,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -1018,1 +1046,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -1027,0 +1064,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -1028,5 +1074,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[b.length];\n@@ -1034,4 +1081,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -1039,1 +1088,0 @@\n-        }\n@@ -1041,1 +1089,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1044,7 +1093,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n@@ -1052,4 +1100,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -1057,1 +1107,0 @@\n-        }\n@@ -1059,1 +1108,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1062,5 +1112,16 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n@@ -1068,4 +1129,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -1073,0 +1149,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1074,0 +1152,16 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n@@ -1075,1 +1169,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1078,7 +1173,6 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        short[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        short[] r = new short[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n@@ -1086,4 +1180,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -1091,0 +1187,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1092,0 +1190,1 @@\n+    }\n@@ -1093,1 +1192,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1096,8 +1213,14 @@\n-    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<short[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            short[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            short[] r = new short[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n@@ -1106,2 +1229,2 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -1112,7 +1235,19 @@\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (char) 0, \"at index #\" + j);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(char[] r, char[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (char) 0, \"at index #\" + j);\n@@ -1121,2 +1256,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n@@ -1132,2 +1265,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -1141,1 +1274,1 @@\n-    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(char[] r, char[] a, long[] indexMap, boolean[] mask) {\n@@ -1147,1 +1280,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1155,1 +1291,1 @@\n-    public Object[][] charGatherScatterProvider() {\n+    public Object[][] charGatherScatterIntProvider() {\n@@ -1164,1 +1300,10 @@\n-    public Object[][] charGatherScatterMaskProvider() {\n+    public Object[][] charGatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterIntMaskProvider() {\n@@ -1173,0 +1318,9 @@\n+    @DataProvider\n+    public Object[][] charGatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -1174,5 +1328,6 @@\n-    @Test(dataProvider = \"charGatherScatterProvider\")\n-    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n+    @Test(dataProvider = \"charGatherScatterIntProvider\")\n+    static void charGatherInt(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n@@ -1180,4 +1335,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i);\n-                av.intoCharArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1185,1 +1342,0 @@\n-        }\n@@ -1187,1 +1343,2 @@\n-        assertGatherArraysEquals(r, a, b);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1190,7 +1347,6 @@\n-    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n-    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"charGatherScatterLongProvider\")\n+    static void charGatherLong(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n@@ -1198,4 +1354,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, b, i, vmask);\n-                av.intoCharArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1203,1 +1361,0 @@\n-        }\n@@ -1205,1 +1362,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1208,5 +1366,16 @@\n-    @Test(dataProvider = \"charGatherScatterProvider\")\n-    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n+    @Test(dataProvider = \"charGatherScatterIntMaskProvider\")\n+    static void charGatherIntMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx, vmask);\n+                    av.intoCharArray(r, i);\n+                }\n+            }\n@@ -1214,4 +1383,19 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n-                av.intoCharArray(r, i, b, i);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterLongMaskProvider\")\n+    static void charGatherLongMask(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, idx, vmask);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1219,0 +1403,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1220,0 +1406,16 @@\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterIntProvider\")\n+    static void charScatterInt(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx);\n+                }\n+            }\n@@ -1221,1 +1423,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1224,7 +1427,6 @@\n-    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n-    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"charGatherScatterLongProvider\")\n+    static void charScatterLong(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n@@ -1232,4 +1434,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n-                av.intoCharArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx);\n+                }\n@@ -1237,0 +1441,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1238,0 +1444,1 @@\n+    }\n@@ -1239,1 +1446,19 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"charGatherScatterIntMaskProvider\")\n+    static void charScatterIntMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1242,0 +1467,20 @@\n+    @Test(dataProvider = \"charGatherScatterLongMaskProvider\")\n+    static void charScatterLongMask(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":398,"deletions":153,"binary":false,"changes":551,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,7 +42,1 @@\n-import jdk.incubator.vector.$Type$Vector;\n-import jdk.incubator.vector.VectorMask;\n-#if[MaxBit]\n-import jdk.incubator.vector.VectorShape;\n-#end[MaxBit]\n-import jdk.incubator.vector.VectorSpecies;\n-import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.*;\n@@ -56,0 +50,1 @@\n+import java.util.Objects;\n@@ -68,0 +63,33 @@\n+    static final VectorSpecies<Integer> SAME_LENGTH_INT_SPECIES;\n+    static final VectorSpecies<Long> SAME_LENGTH_LONG_SPECIES;\n+\n+    static {\n+        VectorSpecies<Integer> intSpecies;\n+        try {\n+            intSpecies = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Integer.SIZE)\n+            );\n+            if (intSpecies.length() != SPECIES.length()) {\n+                intSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            intSpecies = null;\n+        }\n+        SAME_LENGTH_INT_SPECIES = intSpecies;\n+\n+        VectorSpecies<Long> longSpecies;\n+        try {\n+            longSpecies = VectorSpecies.of(\n+                    long.class,\n+                    VectorShape.forBitSize(SPECIES.length() * Long.SIZE)\n+            );\n+            if (longSpecies.length() != SPECIES.length()) {\n+                longSpecies = null;\n+            }\n+        } catch (Throwable e) {\n+            longSpecies = null;\n+        }\n+        SAME_LENGTH_LONG_SPECIES = longSpecies;\n+    }\n+\n@@ -242,1 +270,1 @@\n-    static MemorySegment toSegment($type$[] a, IntFunction<MemorySegment> fb) {\n+    static MemorySegment toSegment($type$[] a, LongFunction<MemorySegment> fb) {\n@@ -482,1 +510,1 @@\n-                                       IntFunction<MemorySegment> fb,\n+                                       LongFunction<MemorySegment> fb,\n@@ -561,1 +589,1 @@\n-                                           IntFunction<MemorySegment> fb,\n+                                           LongFunction<MemorySegment> fb,\n@@ -658,1 +686,1 @@\n-                                               IntFunction<MemorySegment> fb,\n+                                               LongFunction<MemorySegment> fb,\n@@ -1054,8 +1082,7 @@\n-    static void assertGatherArraysEquals($type$[] r, $type$[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals($type$[] r, $type$[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], ($type$) 0, \"at index #\" + j);\n@@ -1064,2 +1091,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -1069,8 +1094,8 @@\n-    static void assertGatherArraysEquals($type$[] r, $type$[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: ($type$) 0);\n+    static void assertGatherArraysEquals($type$[] r, $type$[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], ($type$) 0, \"at index #\" + j);\n@@ -1079,2 +1104,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: ($type$) 0, \"at index #\" + j);\n@@ -1090,2 +1113,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -1099,1 +1122,1 @@\n-    static void assertScatterArraysEquals($type$[] r, $type$[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals($type$[] r, $type$[] a, long[] indexMap, boolean[] mask) {\n@@ -1105,1 +1128,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1113,1 +1139,1 @@\n-    public Object[][] gatherScatterProvider() {\n+    public Object[][] gatherScatterIntProvider() {\n@@ -1122,1 +1148,10 @@\n-    public Object[][] gatherScatterMaskProvider() {\n+    public Object[][] gatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> $TYPE$_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterIntMaskProvider() {\n@@ -1131,0 +1166,9 @@\n+    @DataProvider\n+    public Object[][] gatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            $TYPE$_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -1132,5 +1176,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void gather(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        $type$[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        $type$[] r = new $type$[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void gatherInt(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            $type$[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            $type$[] r = new $type$[b.length];\n@@ -1138,4 +1183,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i, b, i);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n@@ -1143,0 +1190,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -1144,0 +1193,1 @@\n+    }\n@@ -1145,1 +1195,17 @@\n-        assertGatherArraysEquals(r, a, b);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void gatherLong(IntFunction<$type$[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            $type$[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            $type$[] r = new $type$[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, idx);\n+                    av.intoArray(r, i);\n+                }\n+            }\n+\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1148,7 +1214,8 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void gatherMask(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        $type$[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        $type$[] r = new $type$[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void gatherIntMask(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            $type$[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            $type$[] r = new $type$[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -1156,4 +1223,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i, b, i, vmask);\n-                av.intoArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n@@ -1161,0 +1230,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1162,0 +1233,1 @@\n+    }\n@@ -1163,1 +1235,19 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void gatherLongMask(IntFunction<$type$[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            $type$[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            $type$[] r = new $type$[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, idx, vmask);\n+                    av.intoArray(r, i);\n+                }\n+            }\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -1166,5 +1256,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void scatter(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        $type$[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        $type$[] r = new $type$[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void scatterInt(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            $type$[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            $type$[] r = new $type$[a.length];\n@@ -1172,4 +1263,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n@@ -1177,0 +1270,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1178,0 +1273,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void scatterLong(IntFunction<$type$[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            $type$[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            $type$[] r = new $type$[a.length];\n@@ -1179,1 +1282,10 @@\n-        assertScatterArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1182,7 +1294,8 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void scatterMask(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        $type$[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        $type$[] r = new $type$[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void scatterIntMask(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            $type$[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            $type$[] r = new $type$[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -1190,4 +1303,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                av.intoArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n@@ -1195,0 +1310,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -1196,0 +1313,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void scatterLongMask(IntFunction<$type$[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            $type$[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            $type$[] r = new $type$[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                    av.intoArray(r, idx, vmask);\n+                }\n+            }\n@@ -1197,1 +1332,2 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1201,8 +1337,7 @@\n-    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (char) 0, \"at index #\" + j);\n@@ -1211,2 +1346,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -1216,8 +1349,8 @@\n-    static void assertGatherArraysEquals(char[] r, char[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0);\n+    static void assertGatherArraysEquals(char[] r, char[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], (char) 0, \"at index #\" + j);\n@@ -1226,2 +1359,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (char) 0, \"at index #\" + j);\n@@ -1237,2 +1368,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -1246,1 +1377,1 @@\n-    static void assertScatterArraysEquals(char[] r, char[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(char[] r, char[] a, long[] indexMap, boolean[] mask) {\n@@ -1252,1 +1383,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1260,1 +1394,1 @@\n-    public Object[][] charGatherScatterProvider() {\n+    public Object[][] charGatherScatterIntProvider() {\n@@ -1269,1 +1403,10 @@\n-    public Object[][] charGatherScatterMaskProvider() {\n+    public Object[][] charGatherScatterLongProvider() {\n+        return LONG_INDEX_GENERATORS.stream().\n+                flatMap(fs -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charGatherScatterIntMaskProvider() {\n@@ -1278,0 +1421,9 @@\n+    @DataProvider\n+    public Object[][] charGatherScatterLongMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> LONG_INDEX_GENERATORS.stream().flatMap(fm ->\n+            CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n@@ -1279,5 +1431,6 @@\n-    @Test(dataProvider = \"charGatherScatterProvider\")\n-    static void charGather(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n+    @Test(dataProvider = \"charGatherScatterIntProvider\")\n+    static void charGatherInt(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n@@ -1285,4 +1438,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i, b, i);\n-                av.intoCharArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, idx);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1290,0 +1445,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -1291,0 +1448,8 @@\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterLongProvider\")\n+    static void charGatherLong(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n@@ -1292,1 +1457,10 @@\n-        assertGatherArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, idx);\n+                    av.intoCharArray(r, i);\n+                }\n+            }\n+\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1295,7 +1469,8 @@\n-    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n-    static void charGatherMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"charGatherScatterIntMaskProvider\")\n+    static void charGatherIntMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -1303,4 +1478,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i, b, i, vmask);\n-                av.intoCharArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, idx, vmask);\n+                    av.intoCharArray(r, i);\n+                }\n@@ -1308,0 +1485,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1309,0 +1488,1 @@\n+    }\n@@ -1310,1 +1490,19 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+    @Test(dataProvider = \"charGatherScatterLongMaskProvider\")\n+    static void charGatherLongMask(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, idx, vmask);\n+                    av.intoCharArray(r, i);\n+                }\n+            }\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -1313,5 +1511,6 @@\n-    @Test(dataProvider = \"charGatherScatterProvider\")\n-    static void charScatter(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n+    @Test(dataProvider = \"charGatherScatterIntProvider\")\n+    static void charScatterInt(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n@@ -1319,4 +1518,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n-                av.intoCharArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx);\n+                }\n@@ -1324,0 +1525,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1325,0 +1528,16 @@\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterLongProvider\")\n+    static void charScatterLong(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx);\n+                }\n+            }\n@@ -1326,1 +1545,2 @@\n-        assertScatterArraysEquals(r, a, b);\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1329,7 +1549,8 @@\n-    @Test(dataProvider = \"charGatherScatterMaskProvider\")\n-    static void charScatterMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        char[] a = fa.apply(SPECIES.length());\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        char[] r = new char[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"charGatherScatterIntMaskProvider\")\n+    static void charScatterIntMask(IntFunction<char[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            int[] b = fs.apply(a.length, a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -1337,4 +1558,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n-                av.intoCharArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx, vmask);\n+                }\n@@ -1342,0 +1565,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -1343,0 +1568,18 @@\n+    }\n+\n+    @Test(dataProvider = \"charGatherScatterLongMaskProvider\")\n+    static void charScatterLongMask(IntFunction<char[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            char[] a = fa.apply(SPECIES.length());\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            char[] r = new char[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                    av.intoCharArray(r, idx, vmask);\n+                }\n+            }\n@@ -1344,1 +1587,2 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1349,8 +1593,7 @@\n-    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], false, \"at index #\" + j);\n@@ -1359,2 +1602,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n@@ -1364,8 +1605,8 @@\n-    static void assertGatherArraysEquals(boolean[] r, boolean[] a, int[] indexMap, boolean[] mask) {\n-        int i = 0;\n-        int j = 0;\n-        try {\n-            for (; i < a.length; i += SPECIES.length()) {\n-                j = i;\n-                for (; j < i + SPECIES.length(); j++) {\n-                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false);\n+    static void assertGatherArraysEquals(boolean[] r, boolean[] a, long[] indexMap, boolean[] mask) {\n+        for (int i = 0; i < r.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], a.length);\n+                    Assert.assertEquals(r[j], a[(int)indexMap[j]], \"at index #\" + j);\n+                } else {\n+                    Assert.assertEquals(r[j], false, \"at index #\" + j);\n@@ -1374,2 +1615,0 @@\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: false, \"at index #\" + j);\n@@ -1385,2 +1624,2 @@\n-                if (mask[j % SPECIES.length()]) {\n-                    expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    expected[indexMap[j]] = a[j];\n@@ -1394,1 +1633,1 @@\n-    static void assertScatterArraysEquals(boolean[] r, boolean[] a, int[] indexMap) {\n+    static void assertScatterArraysEquals(boolean[] r, boolean[] a, long[] indexMap, boolean[] mask) {\n@@ -1400,1 +1639,4 @@\n-                expected[i + indexMap[j]] = a[j];\n+                if (mask == null || mask[j % SPECIES.length()]) {\n+                    Objects.checkIndex(indexMap[j], r.length);\n+                    expected[(int)indexMap[j]] = a[j];\n+                }\n@@ -1407,5 +1649,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void booleanGather(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void booleanGatherInt(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n@@ -1413,4 +1656,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i, b, i);\n-                av.intoBooleanArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, idx);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1418,0 +1663,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, null);\n@@ -1419,0 +1666,8 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void booleanGatherLong(IntFunction<$type$[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n@@ -1420,1 +1675,10 @@\n-        assertGatherArraysEquals(r, a, b);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, idx);\n+                    av.intoBooleanArray(r, i);\n+                }\n+            }\n+\n+            assertGatherArraysEquals(r, a, b, null);\n+        }\n@@ -1423,7 +1687,8 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void booleanGatherMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void booleanGatherIntMask(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -1431,4 +1696,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i, b, i, vmask);\n-                av.intoBooleanArray(r, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, idx, vmask);\n+                    av.intoBooleanArray(r, i);\n+                }\n@@ -1436,0 +1703,2 @@\n+\n+            assertGatherArraysEquals(r, a, b, mask);\n@@ -1437,0 +1706,18 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void booleanGatherLongMask(IntFunction<$type$[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < r.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, idx, vmask);\n+                    av.intoBooleanArray(r, i);\n+                }\n+            }\n@@ -1438,1 +1725,2 @@\n-        assertGatherArraysEquals(r, a, b, mask);\n+            assertGatherArraysEquals(r, a, b, mask);\n+        }\n@@ -1441,5 +1729,6 @@\n-    @Test(dataProvider = \"gatherScatterProvider\")\n-    static void booleanScatter(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n+    @Test(dataProvider = \"gatherScatterIntProvider\")\n+    static void booleanScatterInt(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n@@ -1447,4 +1736,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i);\n-                av.intoBooleanArray(r, i, b, i);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx);\n+                }\n@@ -1452,0 +1743,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, null);\n@@ -1453,0 +1746,1 @@\n+    }\n@@ -1454,1 +1748,17 @@\n-        assertScatterArraysEquals(r, a, b);\n+    @Test(dataProvider = \"gatherScatterLongProvider\")\n+    static void booleanScatterLong(IntFunction<$type$[]> fa, BiFunction<Integer,Long,long[]> fs) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, null);\n+        }\n@@ -1457,7 +1767,8 @@\n-    @Test(dataProvider = \"gatherScatterMaskProvider\")\n-    static void booleanScatterMask(IntFunction<byte[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n-        boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n-        int[] b = fs.apply(a.length, SPECIES.length());\n-        boolean[] r = new boolean[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+    @Test(dataProvider = \"gatherScatterIntMaskProvider\")\n+    static void booleanScatterIntMask(IntFunction<$type$[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_INT_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            int[] b = fs.apply(a.length, a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -1465,4 +1776,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i);\n-                av.intoBooleanArray(r, i, b, i, vmask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx, vmask);\n+                }\n@@ -1470,0 +1783,2 @@\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n@@ -1471,0 +1786,10 @@\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterLongMaskProvider\")\n+    static void booleanScatterLongMask(IntFunction<$type$[]> fa, BiFunction<Integer,Long,long[]> fs, IntFunction<boolean[]> fm) {\n+        if (SAME_LENGTH_LONG_SPECIES != null) {\n+            boolean[] a = convertToBooleanArray(fa.apply(SPECIES.length()));\n+            long[] b = fs.apply(a.length, (long) a.length);\n+            boolean[] r = new boolean[a.length];\n+            boolean[] mask = fm.apply(SPECIES.length());\n+            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n@@ -1472,1 +1797,10 @@\n-        assertScatterArraysEquals(r, a, b, mask);\n+            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+                for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n+                    $abstractvectortype$ av = $abstractvectortype$.fromBooleanArray(SPECIES, a, i);\n+                    av.intoBooleanArray(r, idx, vmask);\n+                }\n+            }\n+\n+            assertScatterArraysEquals(r, a, b, mask);\n+        }\n@@ -1475,1 +1809,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":554,"deletions":221,"binary":false,"changes":775,"status":"modified"}]}