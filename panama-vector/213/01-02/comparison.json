{"files":[{"patch":"@@ -416,112 +416,0 @@\n-    @ForceInline\n-    public static\n-    <V extends VectorSupport.Vector<E>,\n-     IV extends VectorSupport.Vector<IE>,\n-     S extends VectorSupport.VectorSpecies<E>,\n-     M extends VectorSupport.VectorMask<E>,\n-     E, IE>\n-    V loadFromMemorySegmentWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-                                   int length, Class<? extends IV> ivClass, Class<IE> ieClass,\n-                                   AbstractMemorySegmentImpl msp, IV offsetMap, S s,\n-                                   VectorSupport.LoadVectorOperationWithMap<AbstractMemorySegmentImpl, V, IV, S, M, E, IE> defaultImpl) {\n-        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n-        if (msp.maxAlignMask() > 1) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        try {\n-            return loadFromMemorySegmentWithMapScopedInternal(\n-                    msp.sessionImpl(),\n-                    vClass, mClass, eClass,\n-                    length, ivClass, ieClass,\n-                    msp, offsetMap, s,\n-                    defaultImpl);\n-        } catch (ScopedAccessError ex) {\n-            throw ex.newRuntimeException();\n-        }\n-    }\n-\n-    @Scoped\n-    @ForceInline\n-    private static\n-    <V extends VectorSupport.Vector<E>,\n-     IV extends VectorSupport.Vector<IE>,\n-     S extends VectorSupport.VectorSpecies<E>,\n-     M extends VectorSupport.VectorMask<E>,\n-     E, IE>\n-    V loadFromMemorySegmentWithMapScopedInternal(MemorySessionImpl session,\n-                                                 Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-                                                 int length, Class<? extends IV> ivClass, Class<IE> ieClass,\n-                                                 AbstractMemorySegmentImpl msp, IV offsetMap, S s,\n-                                                 VectorSupport.LoadVectorOperationWithMap<AbstractMemorySegmentImpl, V, IV, S, M, E, IE> defaultImpl){\n-        try {\n-            session.checkValidStateRaw();\n-\n-            return VectorSupport.<AbstractMemorySegmentImpl, V, IV, S, M, E, IE>loadWithMap(\n-                    vClass, mClass, eClass,\n-                    length, ivClass, ieClass,\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset(),\n-                    offsetMap, 1L, null,\n-                    msp, s,\n-                    defaultImpl);\n-        } finally {\n-            Reference.reachabilityFence(session);\n-        }\n-    }\n-\n-    @ForceInline\n-    public static\n-    <V extends VectorSupport.Vector<E>,\n-     IV extends VectorSupport.Vector<IE>,\n-     S extends VectorSupport.VectorSpecies<E>,\n-     M extends VectorSupport.VectorMask<E>,\n-     E, IE>\n-    V loadFromMemorySegmentWithMapMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-                                         int length, Class<? extends IV> ivClass, Class<IE> ieClass,\n-                                         AbstractMemorySegmentImpl msp, IV offsetMap, M m, S s,\n-                                         VectorSupport.LoadVectorOperationWithMap<AbstractMemorySegmentImpl, V, IV, S, M, E, IE> defaultImpl) {\n-        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n-        if (msp.maxAlignMask() > 1) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        try {\n-            return loadFromMemorySegmentWithMapMaskedScopedInternal(\n-                    msp.sessionImpl(),\n-                    vClass, mClass, eClass,\n-                    length, ivClass, ieClass,\n-                    msp, offsetMap, m, s,\n-                    defaultImpl);\n-        } catch (ScopedAccessError ex) {\n-            throw ex.newRuntimeException();\n-        }\n-    }\n-\n-    @Scoped\n-    @ForceInline\n-    private static\n-    <V extends VectorSupport.Vector<E>,\n-     IV extends VectorSupport.Vector<IE>,\n-     S extends VectorSupport.VectorSpecies<E>,\n-     M extends VectorSupport.VectorMask<E>,\n-     E, IE>\n-    V loadFromMemorySegmentWithMapMaskedScopedInternal(MemorySessionImpl session,\n-                                                       Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-                                                       int length, Class<? extends IV> ivClass, Class<IE> ieClass,\n-                                                       AbstractMemorySegmentImpl msp, IV offsetMap, M m, S s,\n-                                                       VectorSupport.LoadVectorOperationWithMap<AbstractMemorySegmentImpl, V, IV, S, M, E, IE> defaultImpl){\n-        try {\n-            session.checkValidStateRaw();\n-\n-            return VectorSupport.loadWithMap(\n-                    vClass, mClass, eClass,\n-                    length, ivClass, ieClass,\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset(),\n-                    offsetMap, 1L, m,\n-                    msp, s,\n-                    defaultImpl);\n-        } finally {\n-            Reference.reachabilityFence(session);\n-        }\n-    }\n-\n@@ -620,109 +508,0 @@\n-    @ForceInline\n-    public static\n-    <V extends VectorSupport.Vector<E>,\n-     IV extends VectorSupport.Vector<IE>,\n-     M extends VectorSupport.VectorMask<E>,\n-     E, IE>\n-    void storeIntoMemorySegmentWithMap(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-                                       int length, Class<? extends IV> ivClass, Class<IE> ieClass,\n-                                       V v, AbstractMemorySegmentImpl msp, IV offsetMap,\n-                                       VectorSupport.StoreVectorOperationWithMap<AbstractMemorySegmentImpl, V, IV, M, E, IE> defaultImpl) {\n-        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n-        if (msp.maxAlignMask() > 1) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        try {\n-            storeIntoMemorySegmentWithMapScopedInternal(\n-                    msp.sessionImpl(),\n-                    vClass, mClass, eClass,\n-                    length, ivClass, ieClass,\n-                    v, msp, offsetMap,\n-                    defaultImpl);\n-        } catch (ScopedAccessError ex) {\n-            throw ex.newRuntimeException();\n-        }\n-    }\n-\n-    @Scoped\n-    @ForceInline\n-    private static\n-    <V extends VectorSupport.Vector<E>,\n-     IV extends VectorSupport.Vector<IE>,\n-     M extends VectorSupport.VectorMask<E>,\n-     E, IE>\n-    void storeIntoMemorySegmentWithMapScopedInternal(MemorySessionImpl session,\n-                                                     Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-                                                     int length, Class<? extends IV> ivClass, Class<IE> ieClass,\n-                                                     V v, AbstractMemorySegmentImpl msp, IV offsetMap,\n-                                                     VectorSupport.StoreVectorOperationWithMap<AbstractMemorySegmentImpl, V, IV, M, E, IE> defaultImpl){\n-        try {\n-            session.checkValidStateRaw();\n-\n-            VectorSupport.storeWithMap(\n-                    vClass, mClass, eClass,\n-                    length, ivClass, ieClass,\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset(),\n-                    offsetMap, 1L, null,\n-                    v, msp,\n-                    defaultImpl);\n-        } finally {\n-            Reference.reachabilityFence(session);\n-        }\n-    }\n-\n-    @ForceInline\n-    public static\n-    <V extends VectorSupport.Vector<E>,\n-     IV extends VectorSupport.Vector<IE>,\n-     S extends VectorSupport.VectorSpecies<E>,\n-     M extends VectorSupport.VectorMask<E>,\n-     E, IE>\n-    void storeIntoMemorySegmentWithMapMasked(Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-                                             int length, Class<? extends IV> ivClass, Class<IE> ieClass,\n-                                             V v, AbstractMemorySegmentImpl msp, IV offsetMap, M m,\n-                                             VectorSupport.StoreVectorOperationWithMap<AbstractMemorySegmentImpl, V, IV, M, E, IE> defaultImpl) {\n-        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n-        if (msp.maxAlignMask() > 1) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        try {\n-            storeIntoMemorySegmentWithMapMaskedScopedInternal(\n-                    msp.sessionImpl(),\n-                    vClass, mClass, eClass,\n-                    length, ivClass, ieClass,\n-                    v, msp, offsetMap, m,\n-                    defaultImpl);\n-        } catch (ScopedAccessError ex) {\n-            throw ex.newRuntimeException();\n-        }\n-    }\n-\n-    @Scoped\n-    @ForceInline\n-    private static\n-    <V extends VectorSupport.Vector<E>,\n-     IV extends VectorSupport.Vector<IE>,\n-     M extends VectorSupport.VectorMask<E>,\n-     E, IE>\n-    void storeIntoMemorySegmentWithMapMaskedScopedInternal(MemorySessionImpl session,\n-                                                           Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n-                                                           int length, Class<? extends IV> ivClass, Class<IE> ieClass,\n-                                                           V v, AbstractMemorySegmentImpl msp, IV offsetMap, M m,\n-                                                           VectorSupport.StoreVectorOperationWithMap<AbstractMemorySegmentImpl, V, IV, M, E, IE> defaultImpl){\n-        try {\n-            session.checkValidStateRaw();\n-\n-            VectorSupport.storeWithMap(\n-                    vClass, mClass, eClass,\n-                    length, ivClass, ieClass,\n-                    msp.unsafeGetBase(), msp.unsafeGetOffset(),\n-                    offsetMap, 1L, m,\n-                    v, msp,\n-                    defaultImpl);\n-        } finally {\n-            Reference.reachabilityFence(session);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":0,"deletions":221,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -931,16 +931,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ByteVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Byte128Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ByteVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Byte> m) {\n-        return super.fromMemorySegment0Template(Byte128Mask.class, ivClass, ieClass, ms, offsetMap, (Byte128Mask) m);\n-    }\n-\n@@ -991,16 +975,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Byte128Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Byte> m) {\n-        super.intoMemorySegment0Template(Byte128Mask.class, ivClass, ieClass, ms, offsetMap, (Byte128Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -963,16 +963,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ByteVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Byte256Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ByteVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Byte> m) {\n-        return super.fromMemorySegment0Template(Byte256Mask.class, ivClass, ieClass, ms, offsetMap, (Byte256Mask) m);\n-    }\n-\n@@ -1023,16 +1007,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Byte256Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Byte> m) {\n-        super.intoMemorySegment0Template(Byte256Mask.class, ivClass, ieClass, ms, offsetMap, (Byte256Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1027,16 +1027,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ByteVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Byte512Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ByteVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Byte> m) {\n-        return super.fromMemorySegment0Template(Byte512Mask.class, ivClass, ieClass, ms, offsetMap, (Byte512Mask) m);\n-    }\n-\n@@ -1087,16 +1071,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Byte512Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Byte> m) {\n-        super.intoMemorySegment0Template(Byte512Mask.class, ivClass, ieClass, ms, offsetMap, (Byte512Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -915,16 +915,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ByteVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Byte64Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ByteVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Byte> m) {\n-        return super.fromMemorySegment0Template(Byte64Mask.class, ivClass, ieClass, ms, offsetMap, (Byte64Mask) m);\n-    }\n-\n@@ -975,16 +959,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Byte64Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Byte> m) {\n-        super.intoMemorySegment0Template(Byte64Mask.class, ivClass, ieClass, ms, offsetMap, (Byte64Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -901,16 +901,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ByteVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(ByteMaxMask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ByteVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Byte> m) {\n-        return super.fromMemorySegment0Template(ByteMaxMask.class, ivClass, ieClass, ms, offsetMap, (ByteMaxMask) m);\n-    }\n-\n@@ -961,16 +945,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(ByteMaxMask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Byte> m) {\n-        super.intoMemorySegment0Template(ByteMaxMask.class, ivClass, ieClass, ms, offsetMap, (ByteMaxMask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3385,188 +3385,0 @@\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-     * The byte order argument is ignored.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+1>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    ByteVector fromMemorySegment(VectorSpecies<Byte> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo) {\n-        ByteSpecies vsp = (ByteSpecies) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 1);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-     * The byte order argument is ignored.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+1>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    ByteVector fromMemorySegment(VectorSpecies<Byte> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo) {\n-        ByteSpecies vsp = (ByteSpecies) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 1);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code byte} (zero).\n-     * <p>\n-     * The byte order argument is ignored.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+1>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    ByteVector fromMemorySegment(VectorSpecies<Byte> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo, VectorMask<Byte> m) {\n-        ByteSpecies vsp = (ByteSpecies) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 1, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code byte} (zero).\n-     * <p>\n-     * The byte order argument is ignored.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+1>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    ByteVector fromMemorySegment(VectorSpecies<Byte> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo, VectorMask<Byte> m) {\n-        ByteSpecies vsp = (ByteSpecies) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 1, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n@@ -4040,66 +3852,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 1);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 1);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo, VectorMask<Byte> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 1, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo, VectorMask<Byte> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 1, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m);\n-    }\n-\n@@ -4250,36 +3996,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    ByteVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Byte>,\n-     IV extends Vector<IE>,\n-     IE>\n-    ByteVector fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        ByteSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.<ByteVector, IV, ByteSpecies, M, Byte, IE>loadFromMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, byte.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, vsp,\n-            (msp, map, s, vm) -> s.nOp(i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    ByteVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Byte> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Byte>,\n-     IV extends Vector<IE>,\n-     IE>\n-    ByteVector fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        ByteSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.<ByteVector, IV, ByteSpecies, M, Byte, IE>loadFromMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, byte.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, m, vsp,\n-            (msp, map, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n@@ -4405,36 +4115,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Byte>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        ByteSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, byte.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap,\n-            (msp, map, s, vm) -> s.cOp((i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Byte> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Byte>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        ByteSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, byte.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap, m,\n-            (msp, map, s, vm) -> s.cOp(vm, (i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":0,"deletions":326,"binary":false,"changes":326,"status":"modified"},{"patch":"@@ -879,16 +879,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    DoubleVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Double128Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    DoubleVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Double> m) {\n-        return super.fromMemorySegment0Template(Double128Mask.class, ivClass, ieClass, ms, offsetMap, (Double128Mask) m);\n-    }\n-\n@@ -933,16 +917,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Double128Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Double> m) {\n-        super.intoMemorySegment0Template(Double128Mask.class, ivClass, ieClass, ms, offsetMap, (Double128Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -883,16 +883,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    DoubleVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Double256Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    DoubleVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Double> m) {\n-        return super.fromMemorySegment0Template(Double256Mask.class, ivClass, ieClass, ms, offsetMap, (Double256Mask) m);\n-    }\n-\n@@ -937,16 +921,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Double256Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Double> m) {\n-        super.intoMemorySegment0Template(Double256Mask.class, ivClass, ieClass, ms, offsetMap, (Double256Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -891,16 +891,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    DoubleVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Double512Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    DoubleVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Double> m) {\n-        return super.fromMemorySegment0Template(Double512Mask.class, ivClass, ieClass, ms, offsetMap, (Double512Mask) m);\n-    }\n-\n@@ -945,16 +929,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Double512Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Double> m) {\n-        super.intoMemorySegment0Template(Double512Mask.class, ivClass, ieClass, ms, offsetMap, (Double512Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -877,16 +877,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    DoubleVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Double64Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    DoubleVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Double> m) {\n-        return super.fromMemorySegment0Template(Double64Mask.class, ivClass, ieClass, ms, offsetMap, (Double64Mask) m);\n-    }\n-\n@@ -931,16 +915,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Double64Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Double> m) {\n-        super.intoMemorySegment0Template(Double64Mask.class, ivClass, ieClass, ms, offsetMap, (Double64Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -876,16 +876,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    DoubleVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(DoubleMaxMask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    DoubleVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Double> m) {\n-        return super.fromMemorySegment0Template(DoubleMaxMask.class, ivClass, ieClass, ms, offsetMap, (DoubleMaxMask) m);\n-    }\n-\n@@ -930,16 +914,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(DoubleMaxMask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Double> m) {\n-        super.intoMemorySegment0Template(DoubleMaxMask.class, ivClass, ieClass, ms, offsetMap, (DoubleMaxMask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2968,208 +2968,0 @@\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+8>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    DoubleVector fromMemorySegment(VectorSpecies<Double> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo) {\n-        DoubleSpecies vsp = (DoubleSpecies) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+8>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    DoubleVector fromMemorySegment(VectorSpecies<Double> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo) {\n-        DoubleSpecies vsp = (DoubleSpecies) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code double} (positive zero).\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+8>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    DoubleVector fromMemorySegment(VectorSpecies<Double> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo, VectorMask<Double> m) {\n-        DoubleSpecies vsp = (DoubleSpecies) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code double} (positive zero).\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+8>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    DoubleVector fromMemorySegment(VectorSpecies<Double> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo, VectorMask<Double> m) {\n-        DoubleSpecies vsp = (DoubleSpecies) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n@@ -3416,66 +3208,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo, VectorMask<Double> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo, VectorMask<Double> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m);\n-    }\n-\n@@ -3597,36 +3323,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    DoubleVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Double>,\n-     IV extends Vector<IE>,\n-     IE>\n-    DoubleVector fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        DoubleSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.<DoubleVector, IV, DoubleSpecies, M, Double, IE>loadFromMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, double.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, vsp,\n-            (msp, map, s, vm) -> s.nOp(i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    DoubleVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Double> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Double>,\n-     IV extends Vector<IE>,\n-     IE>\n-    DoubleVector fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        DoubleSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.<DoubleVector, IV, DoubleSpecies, M, Double, IE>loadFromMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, double.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, m, vsp,\n-            (msp, map, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n@@ -3734,36 +3424,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Double>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        DoubleSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, double.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap,\n-            (msp, map, s, vm) -> s.cOp((i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Double> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Double>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        DoubleSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, double.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap, m,\n-            (msp, map, s, vm) -> s.cOp(vm, (i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":0,"deletions":346,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -883,16 +883,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    FloatVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Float128Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    FloatVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Float> m) {\n-        return super.fromMemorySegment0Template(Float128Mask.class, ivClass, ieClass, ms, offsetMap, (Float128Mask) m);\n-    }\n-\n@@ -937,16 +921,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Float128Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Float> m) {\n-        super.intoMemorySegment0Template(Float128Mask.class, ivClass, ieClass, ms, offsetMap, (Float128Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -891,16 +891,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    FloatVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Float256Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    FloatVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Float> m) {\n-        return super.fromMemorySegment0Template(Float256Mask.class, ivClass, ieClass, ms, offsetMap, (Float256Mask) m);\n-    }\n-\n@@ -945,16 +929,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Float256Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Float> m) {\n-        super.intoMemorySegment0Template(Float256Mask.class, ivClass, ieClass, ms, offsetMap, (Float256Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -907,16 +907,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    FloatVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Float512Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    FloatVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Float> m) {\n-        return super.fromMemorySegment0Template(Float512Mask.class, ivClass, ieClass, ms, offsetMap, (Float512Mask) m);\n-    }\n-\n@@ -961,16 +945,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Float512Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Float> m) {\n-        super.intoMemorySegment0Template(Float512Mask.class, ivClass, ieClass, ms, offsetMap, (Float512Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -879,16 +879,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    FloatVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Float64Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    FloatVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Float> m) {\n-        return super.fromMemorySegment0Template(Float64Mask.class, ivClass, ieClass, ms, offsetMap, (Float64Mask) m);\n-    }\n-\n@@ -933,16 +917,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Float64Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Float> m) {\n-        super.intoMemorySegment0Template(Float64Mask.class, ivClass, ieClass, ms, offsetMap, (Float64Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -876,16 +876,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    FloatVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(FloatMaxMask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    FloatVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Float> m) {\n-        return super.fromMemorySegment0Template(FloatMaxMask.class, ivClass, ieClass, ms, offsetMap, (FloatMaxMask) m);\n-    }\n-\n@@ -930,16 +914,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(FloatMaxMask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Float> m) {\n-        super.intoMemorySegment0Template(FloatMaxMask.class, ivClass, ieClass, ms, offsetMap, (FloatMaxMask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2992,208 +2992,0 @@\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+4>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    FloatVector fromMemorySegment(VectorSpecies<Float> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo) {\n-        FloatSpecies vsp = (FloatSpecies) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+4>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    FloatVector fromMemorySegment(VectorSpecies<Float> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo) {\n-        FloatSpecies vsp = (FloatSpecies) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code float} (positive zero).\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+4>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    FloatVector fromMemorySegment(VectorSpecies<Float> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo, VectorMask<Float> m) {\n-        FloatSpecies vsp = (FloatSpecies) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code float} (positive zero).\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+4>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    FloatVector fromMemorySegment(VectorSpecies<Float> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo, VectorMask<Float> m) {\n-        FloatSpecies vsp = (FloatSpecies) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n@@ -3440,66 +3232,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo, VectorMask<Float> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo, VectorMask<Float> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m);\n-    }\n-\n@@ -3621,36 +3347,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    FloatVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Float>,\n-     IV extends Vector<IE>,\n-     IE>\n-    FloatVector fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        FloatSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.<FloatVector, IV, FloatSpecies, M, Float, IE>loadFromMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, float.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, vsp,\n-            (msp, map, s, vm) -> s.nOp(i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    FloatVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Float> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Float>,\n-     IV extends Vector<IE>,\n-     IE>\n-    FloatVector fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        FloatSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.<FloatVector, IV, FloatSpecies, M, Float, IE>loadFromMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, float.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, m, vsp,\n-            (msp, map, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n@@ -3758,36 +3448,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Float>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        FloatSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, float.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap,\n-            (msp, map, s, vm) -> s.cOp((i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Float> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Float>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        FloatSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, float.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap, m,\n-            (msp, map, s, vm) -> s.cOp(vm, (i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":0,"deletions":346,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -894,16 +894,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    IntVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Int128Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    IntVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Integer> m) {\n-        return super.fromMemorySegment0Template(Int128Mask.class, ivClass, ieClass, ms, offsetMap, (Int128Mask) m);\n-    }\n-\n@@ -948,16 +932,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Int128Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Integer> m) {\n-        super.intoMemorySegment0Template(Int128Mask.class, ivClass, ieClass, ms, offsetMap, (Int128Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -902,16 +902,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    IntVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Int256Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    IntVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Integer> m) {\n-        return super.fromMemorySegment0Template(Int256Mask.class, ivClass, ieClass, ms, offsetMap, (Int256Mask) m);\n-    }\n-\n@@ -956,16 +940,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Int256Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Integer> m) {\n-        super.intoMemorySegment0Template(Int256Mask.class, ivClass, ieClass, ms, offsetMap, (Int256Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -918,16 +918,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    IntVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Int512Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    IntVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Integer> m) {\n-        return super.fromMemorySegment0Template(Int512Mask.class, ivClass, ieClass, ms, offsetMap, (Int512Mask) m);\n-    }\n-\n@@ -972,16 +956,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Int512Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Integer> m) {\n-        super.intoMemorySegment0Template(Int512Mask.class, ivClass, ieClass, ms, offsetMap, (Int512Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -890,16 +890,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    IntVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Int64Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    IntVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Integer> m) {\n-        return super.fromMemorySegment0Template(Int64Mask.class, ivClass, ieClass, ms, offsetMap, (Int64Mask) m);\n-    }\n-\n@@ -944,16 +928,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Int64Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Integer> m) {\n-        super.intoMemorySegment0Template(Int64Mask.class, ivClass, ieClass, ms, offsetMap, (Int64Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -899,16 +899,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    IntVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(IntMaxMask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    IntVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Integer> m) {\n-        return super.fromMemorySegment0Template(IntMaxMask.class, ivClass, ieClass, ms, offsetMap, (IntMaxMask) m);\n-    }\n-\n@@ -953,16 +937,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(IntMaxMask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Integer> m) {\n-        super.intoMemorySegment0Template(IntMaxMask.class, ivClass, ieClass, ms, offsetMap, (IntMaxMask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3148,208 +3148,0 @@\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+4>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    IntVector fromMemorySegment(VectorSpecies<Integer> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo) {\n-        IntSpecies vsp = (IntSpecies) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+4>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    IntVector fromMemorySegment(VectorSpecies<Integer> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo) {\n-        IntSpecies vsp = (IntSpecies) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code int} (zero).\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+4>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    IntVector fromMemorySegment(VectorSpecies<Integer> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo, VectorMask<Integer> m) {\n-        IntSpecies vsp = (IntSpecies) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code int} (zero).\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+4>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    IntVector fromMemorySegment(VectorSpecies<Integer> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo, VectorMask<Integer> m) {\n-        IntSpecies vsp = (IntSpecies) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n@@ -3596,66 +3388,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo, VectorMask<Integer> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo, VectorMask<Integer> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 4, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m);\n-    }\n-\n@@ -3777,36 +3503,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    IntVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Integer>,\n-     IV extends Vector<IE>,\n-     IE>\n-    IntVector fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        IntSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.<IntVector, IV, IntSpecies, M, Integer, IE>loadFromMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, int.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, vsp,\n-            (msp, map, s, vm) -> s.nOp(i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    IntVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Integer> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Integer>,\n-     IV extends Vector<IE>,\n-     IE>\n-    IntVector fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        IntSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.<IntVector, IV, IntSpecies, M, Integer, IE>loadFromMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, int.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, m, vsp,\n-            (msp, map, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n@@ -3914,36 +3604,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Integer>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        IntSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, int.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap,\n-            (msp, map, s, vm) -> s.cOp((i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Integer> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Integer>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        IntSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, int.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap, m,\n-            (msp, map, s, vm) -> s.cOp(vm, (i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":0,"deletions":346,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -880,16 +880,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    LongVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Long128Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    LongVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Long> m) {\n-        return super.fromMemorySegment0Template(Long128Mask.class, ivClass, ieClass, ms, offsetMap, (Long128Mask) m);\n-    }\n-\n@@ -934,16 +918,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Long128Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Long> m) {\n-        super.intoMemorySegment0Template(Long128Mask.class, ivClass, ieClass, ms, offsetMap, (Long128Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -884,16 +884,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    LongVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Long256Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    LongVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Long> m) {\n-        return super.fromMemorySegment0Template(Long256Mask.class, ivClass, ieClass, ms, offsetMap, (Long256Mask) m);\n-    }\n-\n@@ -938,16 +922,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Long256Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Long> m) {\n-        super.intoMemorySegment0Template(Long256Mask.class, ivClass, ieClass, ms, offsetMap, (Long256Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -892,16 +892,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    LongVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Long512Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    LongVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Long> m) {\n-        return super.fromMemorySegment0Template(Long512Mask.class, ivClass, ieClass, ms, offsetMap, (Long512Mask) m);\n-    }\n-\n@@ -946,16 +930,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Long512Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Long> m) {\n-        super.intoMemorySegment0Template(Long512Mask.class, ivClass, ieClass, ms, offsetMap, (Long512Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -878,16 +878,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    LongVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Long64Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    LongVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Long> m) {\n-        return super.fromMemorySegment0Template(Long64Mask.class, ivClass, ieClass, ms, offsetMap, (Long64Mask) m);\n-    }\n-\n@@ -932,16 +916,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Long64Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Long> m) {\n-        super.intoMemorySegment0Template(Long64Mask.class, ivClass, ieClass, ms, offsetMap, (Long64Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -878,16 +878,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    LongVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(LongMaxMask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    LongVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Long> m) {\n-        return super.fromMemorySegment0Template(LongMaxMask.class, ivClass, ieClass, ms, offsetMap, (LongMaxMask) m);\n-    }\n-\n@@ -932,16 +916,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(LongMaxMask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Long> m) {\n-        super.intoMemorySegment0Template(LongMaxMask.class, ivClass, ieClass, ms, offsetMap, (LongMaxMask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3009,208 +3009,0 @@\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+8>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    LongVector fromMemorySegment(VectorSpecies<Long> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo) {\n-        LongSpecies vsp = (LongSpecies) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+8>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    LongVector fromMemorySegment(VectorSpecies<Long> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo) {\n-        LongSpecies vsp = (LongSpecies) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code long} (zero).\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+8>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    LongVector fromMemorySegment(VectorSpecies<Long> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo, VectorMask<Long> m) {\n-        LongSpecies vsp = (LongSpecies) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code long} (zero).\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+8>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    LongVector fromMemorySegment(VectorSpecies<Long> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo, VectorMask<Long> m) {\n-        LongSpecies vsp = (LongSpecies) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n@@ -3457,66 +3249,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo, VectorMask<Long> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo, VectorMask<Long> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 8, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m);\n-    }\n-\n@@ -3638,36 +3364,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    LongVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Long>,\n-     IV extends Vector<IE>,\n-     IE>\n-    LongVector fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        LongSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.<LongVector, IV, LongSpecies, M, Long, IE>loadFromMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, long.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, vsp,\n-            (msp, map, s, vm) -> s.nOp(i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    LongVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Long> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Long>,\n-     IV extends Vector<IE>,\n-     IE>\n-    LongVector fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        LongSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.<LongVector, IV, LongSpecies, M, Long, IE>loadFromMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, long.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, m, vsp,\n-            (msp, map, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n@@ -3775,36 +3465,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Long>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        LongSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, long.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap,\n-            (msp, map, s, vm) -> s.cOp((i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Long> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Long>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        LongSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, long.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap, m,\n-            (msp, map, s, vm) -> s.cOp(vm, (i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":0,"deletions":346,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -915,16 +915,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ShortVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Short128Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ShortVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Short> m) {\n-        return super.fromMemorySegment0Template(Short128Mask.class, ivClass, ieClass, ms, offsetMap, (Short128Mask) m);\n-    }\n-\n@@ -969,16 +953,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Short128Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Short> m) {\n-        super.intoMemorySegment0Template(Short128Mask.class, ivClass, ieClass, ms, offsetMap, (Short128Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -931,16 +931,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ShortVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Short256Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ShortVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Short> m) {\n-        return super.fromMemorySegment0Template(Short256Mask.class, ivClass, ieClass, ms, offsetMap, (Short256Mask) m);\n-    }\n-\n@@ -985,16 +969,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Short256Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Short> m) {\n-        super.intoMemorySegment0Template(Short256Mask.class, ivClass, ieClass, ms, offsetMap, (Short256Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -963,16 +963,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ShortVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Short512Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ShortVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Short> m) {\n-        return super.fromMemorySegment0Template(Short512Mask.class, ivClass, ieClass, ms, offsetMap, (Short512Mask) m);\n-    }\n-\n@@ -1017,16 +1001,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Short512Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Short> m) {\n-        super.intoMemorySegment0Template(Short512Mask.class, ivClass, ieClass, ms, offsetMap, (Short512Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -907,16 +907,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ShortVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(Short64Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ShortVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Short> m) {\n-        return super.fromMemorySegment0Template(Short64Mask.class, ivClass, ieClass, ms, offsetMap, (Short64Mask) m);\n-    }\n-\n@@ -961,16 +945,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(Short64Mask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Short> m) {\n-        super.intoMemorySegment0Template(Short64Mask.class, ivClass, ieClass, ms, offsetMap, (Short64Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -901,16 +901,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ShortVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template(ShortMaxMask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    ShortVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Short> m) {\n-        return super.fromMemorySegment0Template(ShortMaxMask.class, ivClass, ieClass, ms, offsetMap, (ShortMaxMask) m);\n-    }\n-\n@@ -955,16 +939,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template(ShortMaxMask.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Short> m) {\n-        super.intoMemorySegment0Template(ShortMaxMask.class, ivClass, ieClass, ms, offsetMap, (ShortMaxMask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3384,208 +3384,0 @@\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+2>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    ShortVector fromMemorySegment(VectorSpecies<Short> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo) {\n-        ShortSpecies vsp = (ShortSpecies) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 2);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+2>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    ShortVector fromMemorySegment(VectorSpecies<Short> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo) {\n-        ShortSpecies vsp = (ShortSpecies) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 2);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code short} (zero).\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+2>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    ShortVector fromMemorySegment(VectorSpecies<Short> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo, VectorMask<Short> m) {\n-        ShortSpecies vsp = (ShortSpecies) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 2, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code short} (zero).\n-     * <p>\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+2>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    ShortVector fromMemorySegment(VectorSpecies<Short> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo, VectorMask<Short> m) {\n-        ShortSpecies vsp = (ShortSpecies) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 2, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n@@ -4036,66 +3828,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 2);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 2);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo, VectorMask<Short> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 2, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo, VectorMask<Short> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), 2, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m);\n-    }\n-\n@@ -4246,36 +3972,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    ShortVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Short>,\n-     IV extends Vector<IE>,\n-     IE>\n-    ShortVector fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        ShortSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.<ShortVector, IV, ShortSpecies, M, Short, IE>loadFromMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, short.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, vsp,\n-            (msp, map, s, vm) -> s.nOp(i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    ShortVector fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Short> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Short>,\n-     IV extends Vector<IE>,\n-     IE>\n-    ShortVector fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        ShortSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.<ShortVector, IV, ShortSpecies, M, Short, IE>loadFromMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, short.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, m, vsp,\n-            (msp, map, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n@@ -4385,36 +4075,0 @@\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Short>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        ShortSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, short.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap,\n-            (msp, map, s, vm) -> s.cOp((i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<Short> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Short>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        ShortSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, short.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap, m,\n-            (msp, map, s, vm) -> s.cOp(vm, (i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":0,"deletions":346,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -3454,163 +3454,0 @@\n-\n-    \/**\n-     * Scatters this vector into a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is stored into the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     *\n-     * @implNote\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     * In the special case where {@code ETYPE} is\n-     * {@code byte}, the byte order argument is\n-     * ignored.\n-     *\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @throws IllegalArgumentException\n-     *         if {@code this.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+$sizeInBytes$>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    public abstract void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo);\n-    \/**\n-     * Scatters this vector into a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is stored into the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     *\n-     * @implNote\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     * In the special case where {@code ETYPE} is\n-     * {@code byte}, the byte order argument is\n-     * ignored.\n-     *\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @throws IllegalArgumentException\n-     *         if {@code this.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+$sizeInBytes$>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    public abstract void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo);\n-\n-    \/**\n-     * Scatters this vector into a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is stored into the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     *\n-     * @implNote\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     * In the special case where {@code ETYPE} is\n-     * {@code byte}, the byte order argument is\n-     * ignored.\n-     *\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @throws IllegalArgumentException\n-     *         if {@code this.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+$sizeInBytes$>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    public abstract void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo, VectorMask<E> m);\n-\n-    \/**\n-     * Scatters this vector into a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is stored into the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     *\n-     * @implNote\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     * In the special case where {@code ETYPE} is\n-     * {@code byte}, the byte order argument is\n-     * ignored.\n-     *\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @throws IllegalArgumentException\n-     *         if {@code this.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+$sizeInBytes$>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    public abstract void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo, VectorMask<E> m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":0,"deletions":163,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -4177,224 +4177,0 @@\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-#if[!byte]\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-#else[!byte]\n-     * The byte order argument is ignored.\n-#end[!byte]\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+$sizeInBytes$>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    $abstractvectortype$ fromMemorySegment(VectorSpecies<$Boxtype$> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo) {\n-        $Type$Species vsp = ($Type$Species) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), $sizeInBytes$);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment}\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * <p>\n-#if[!byte]\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-#else[!byte]\n-     * The byte order argument is ignored.\n-#end[!byte]\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+$sizeInBytes$>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    $abstractvectortype$ fromMemorySegment(VectorSpecies<$Boxtype$> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo) {\n-        $Type$Species vsp = ($Type$Species) species;\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), $sizeInBytes$);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is an {@link IntVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code $type$} ({#if[FP]?positive }zero).\n-     * <p>\n-#if[!byte]\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-#else[!byte]\n-     * The byte order argument is ignored.\n-#end[!byte]\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+$sizeInBytes$>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    $abstractvectortype$ fromMemorySegment(VectorSpecies<$Boxtype$> species,\n-                                           MemorySegment ms, IntVector offsetMap,\n-                                           ByteOrder bo, VectorMask<$Boxtype$> m) {\n-        $Type$Species vsp = ($Type$Species) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), $sizeInBytes$, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Gathers a new vector composed of elements from a {@linkplain\n-     * MemorySegment memory segment} under the control of a mask\n-     * using indices obtained from an <em>offset map<\/em>.\n-     * The offset map is a {@link LongVector} of length {@code VLENGTH}.\n-     * <p>\n-     * For each vector lane, where {@code N} is the vector lane index,\n-     * if the lane is set in the mask,\n-     * the lane is loaded from the memory location at offset {@code f(N)}\n-     * of the memory segment, where {@code f(N)} is the index mapping\n-     * expression {@code offsetMap.lane(N)}.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code $type$} ({#if[FP]?positive }zero).\n-     * <p>\n-#if[!byte]\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-#else[!byte]\n-     * The byte order argument is ignored.\n-#end[!byte]\n-     *\n-     * @param species species of desired vector\n-     * @param ms the memory segment\n-     * @param offsetMap the offset map\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return the vector loaded from the indexed elements of the\n-     *         memory segment\n-     * @throws IllegalArgumentException\n-     *         if {@code species.length()!=offsetMap.length()}\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offsetMap.lane(N)<0}\n-     *         or {@code offsetMap.lane(N)+$sizeInBytes$>ms.byteSize()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n-     *         not backed by a {@code byte[]} array.\n-     * @throws IllegalStateException if the memory segment's session is not alive,\n-     *         or if access occurs from a thread other than the thread owning the session.\n-     *\/\n-    @ForceInline\n-    public static\n-    $abstractvectortype$ fromMemorySegment(VectorSpecies<$Boxtype$> species,\n-                                           MemorySegment ms, LongVector offsetMap,\n-                                           ByteOrder bo, VectorMask<$Boxtype$> m) {\n-        $Type$Species vsp = ($Type$Species) species;\n-        m.check(vsp);\n-        if (vsp.laneCount() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"species length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), $sizeInBytes$, m);\n-        return vsp.dummyVector().fromMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m).maybeSwap(bo);\n-    }\n-\n@@ -5076,66 +4852,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), $sizeInBytes$);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo) {\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), $sizeInBytes$);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, IntVector offsetMap,\n-                           ByteOrder bo, VectorMask<$Boxtype$> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), $sizeInBytes$, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), int.class, ms, offsetMap, m);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoMemorySegment(MemorySegment ms, LongVector offsetMap,\n-                           ByteOrder bo, VectorMask<$Boxtype$> m) {\n-        m.check(vspecies());\n-        if (length() != offsetMap.length()) {\n-            throw new IllegalArgumentException(\"vector length and offsetMap length differ\");\n-        }\n-\n-        VectorIntrinsics.checkIndices(offsetMap, ms.byteSize(), $sizeInBytes$, m);\n-        maybeSwap(bo).intoMemorySegment0(offsetMap.getClass(), long.class, ms, offsetMap, m);\n-    }\n-\n@@ -5319,36 +5029,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    $abstractvectortype$ fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<$Boxtype$>,\n-     IV extends Vector<IE>,\n-     IE>\n-    $abstractvectortype$ fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        $Type$Species vsp = vspecies();\n-        return ScopedMemoryAccess.<$abstractvectortype$, IV, $Type$Species, M, $Boxtype$, IE>loadFromMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, $type$.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, vsp,\n-            (msp, map, s, vm) -> s.nOp(i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    $abstractvectortype$ fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<$Boxtype$> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<$Boxtype$>,\n-     IV extends Vector<IE>,\n-     IE>\n-    $abstractvectortype$ fromMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        $Type$Species vsp = vspecies();\n-        return ScopedMemoryAccess.<$abstractvectortype$, IV, $Type$Species, M, $Boxtype$, IE>loadFromMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, $type$.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            (AbstractMemorySegmentImpl) ms, offsetMap, m, vsp,\n-            (msp, map, s, vm) -> s.nOp(vm, i -> memorySegmentGet(msp, map.toLongArray()[i], 0)));\n-    }\n-\n@@ -5476,36 +5150,0 @@\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<$Boxtype$>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        $Type$Species vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMap(\n-            vsp.vectorType(), mClass, $type$.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap,\n-            (msp, map, s, vm) -> s.cOp((i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n-    \/*package-private*\/\n-    abstract\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<$Boxtype$> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<$Boxtype$>,\n-     IV extends Vector<IE>,\n-     IE>\n-    void intoMemorySegment0Template(Class<M> mClass, Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, M m) {\n-        $Type$Species vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoMemorySegmentWithMapMasked(\n-            vsp.vectorType(), mClass, $type$.class,\n-            vsp.laneCount(), ivClass, ieClass,\n-            this, (AbstractMemorySegmentImpl) ms, offsetMap, m,\n-            (msp, map, s, vm) -> s.cOp(vm, (i, e) -> memorySegmentSet(msp, map.toLongArray()[i], 0, e)));\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":0,"deletions":362,"binary":false,"changes":362,"status":"modified"},{"patch":"@@ -1206,16 +1206,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    $abstractvectortype$ fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        return super.fromMemorySegment0Template($masktype$.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    $abstractvectortype$ fromMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<$Boxtype$> m) {\n-        return super.fromMemorySegment0Template($masktype$.class, ivClass, ieClass, ms, offsetMap, ($masktype$) m);\n-    }\n-\n@@ -1268,16 +1252,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap) {\n-        super.intoMemorySegment0Template($masktype$.class, ivClass, ieClass, ms, offsetMap);\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    <IV extends Vector<IE>, IE>\n-    void intoMemorySegment0(Class<? extends IV> ivClass, Class<IE> ieClass, MemorySegment ms, IV offsetMap, VectorMask<$Boxtype$> m) {\n-        super.intoMemorySegment0Template($masktype$.class, ivClass, ieClass, ms, offsetMap, ($masktype$) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-\n@@ -32,1 +31,0 @@\n-\n@@ -44,1 +42,1 @@\n- * @run driver compiler.vectorapi.VectorGatherScatterTest\n+ * @run main compiler.vectorapi.VectorGatherScatterTest\n@@ -83,1 +81,2 @@\n-            da[i] = RD.nextDouble(100);\n+            fa[i] = RD.nextFloat();\n+            da[i] = RD.nextDouble();\n@@ -197,0 +196,1 @@\n+\n@@ -217,0 +217,1 @@\n+\n@@ -237,0 +238,1 @@\n+\n@@ -258,0 +260,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherScatterTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1287,272 +1287,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(byte[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(byte[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, byte[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, byte[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -1287,272 +1287,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(byte[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(byte[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, byte[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, byte[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -1287,272 +1287,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(byte[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(byte[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, byte[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, byte[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -1287,272 +1287,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(byte[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(byte[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, byte[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, byte[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -1293,272 +1293,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(byte[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(byte[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (byte) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, byte[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, byte[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            byte[] r = new byte[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Byte.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<byte[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            byte[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Byte.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Byte.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(double[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(double[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, double[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, double[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(double[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(double[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, double[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, double[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(double[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(double[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, double[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, double[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(double[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(double[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, double[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, double[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -991,272 +991,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(double[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(double[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (double) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, double[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, double[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            double[] r = new double[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Double.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<double[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            double[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Double.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Double.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(float[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(float[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, float[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, float[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(float[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(float[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, float[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, float[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(float[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(float[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, float[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, float[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(float[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(float[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, float[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, float[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -991,272 +991,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(float[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(float[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (float) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, float[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, float[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            float[] r = new float[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Float.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<float[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            float[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Float.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Float.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(int[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(int[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, int[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, int[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(int[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(int[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, int[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, int[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(int[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(int[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, int[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, int[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(int[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(int[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, int[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, int[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -991,272 +991,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(int[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(int[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (int) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, int[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, int[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            int[] r = new int[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Integer.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<int[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            int[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Integer.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Integer.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    IntVector av = IntVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(long[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(long[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, long[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, long[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(long[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(long[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, long[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, long[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(long[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(long[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, long[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, long[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -985,272 +985,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(long[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(long[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, long[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, long[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -991,272 +991,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(long[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(long[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (long) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, long[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, long[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            long[] r = new long[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Long.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<long[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            long[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Long.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Long.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    LongVector av = LongVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -1482,272 +1482,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(short[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(short[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, short[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, short[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -1482,272 +1482,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(short[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(short[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, short[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, short[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -1482,272 +1482,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(short[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(short[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, short[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, short[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -1482,272 +1482,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(short[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(short[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, short[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, short[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -1488,272 +1488,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals(short[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals(short[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], (short) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, short[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, short[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            short[] r = new short[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - Short.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<short[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            short[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * Short.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - Short.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -1809,272 +1809,0 @@\n-\n-    static void assertGatherMemorySegmentsEquals($type$[] r, MemorySegment ms, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], ($type$) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertGatherMemorySegmentsEquals($type$[] r, MemorySegment ms, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        for (int i = 0; i < r.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    Assert.assertEquals(r[j], ms.get(ELEMENT_LAYOUT.withOrder(bo), indexMap[j]), \"at index #\" + j);\n-                } else {\n-                    Assert.assertEquals(r[j], ($type$) 0, \"at index #\" + j);\n-                }\n-            }\n-        }\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, $type$[] a, int[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    static void assertScatterMemorySegmentsEquals(MemorySegment ms, $type$[] a, long[] indexMap, ByteOrder bo, boolean[] mask) {\n-        MemorySegment expected = MEMORY_SEGMENT_GENERATORS.get(0).apply(ms.byteSize());\n-\n-        \/\/ Store before checking, since the same location may be stored to more than once\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            for (int j = i; j < i + SPECIES.length(); j++) {\n-                if (mask == null || mask[j % SPECIES.length()]) {\n-                    expected.set(ELEMENT_LAYOUT.withOrder(bo), indexMap[j], a[j]);\n-                }\n-            }\n-        }\n-\n-        Assert.assertEquals(expected.mismatch(ms), -1);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntProvider() {\n-        return $TYPE$_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongProvider() {\n-        return $TYPE$_GENERATORS.stream().\n-                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                    return new Object[]{fa, fb, fs, bo};\n-                                })))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterIntMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> $TYPE$_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> INT_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] msGatherScatterLongMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> $TYPE$_GENERATORS.stream().\n-                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().\n-                                        flatMap(bo -> LONG_INDEX_GENERATORS.stream().map(fs -> {\n-                                            return new Object[]{fa, fb, fs, bo, fm};\n-                                        }))))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msGatherInt(IntFunction<$type$[]> fa, LongFunction<MemorySegment> fb,\n-                            BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            $type$[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - $Boxtype$.BYTES + 1);\n-            $type$[] r = new $type$[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msGatherLong(IntFunction<$type$[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            $type$[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - $Boxtype$.BYTES + 1);\n-            $type$[] r = new $type$[a.length];\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, ms, idx, bo);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msGatherIntMask(IntFunction<$type$[]> fa, LongFunction<MemorySegment> fb,\n-                                BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            $type$[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - $Boxtype$.BYTES + 1);\n-            $type$[] r = new $type$[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msGatherLongMask(IntFunction<$type$[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            $type$[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = toSegment(a, fb);\n-            long[] b = fs.apply(a.length, ms.byteSize() - $Boxtype$.BYTES + 1);\n-            $type$[] r = new $type$[a.length];\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < r.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, ms, idx, bo, vmask);\n-                    av.intoArray(r, i);\n-                }\n-            }\n-\n-            assertGatherMemorySegmentsEquals(r, ms, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntProvider\")\n-    static void msScatterInt(IntFunction<$type$[]> fa, LongFunction<MemorySegment> fb,\n-                             BiFunction<Integer,Integer,int[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            $type$[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * $Boxtype$.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - $Boxtype$.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongProvider\")\n-    static void msScatterLong(IntFunction<$type$[]> fa, LongFunction<MemorySegment> fb,\n-                              BiFunction<Integer,Long,long[]> fs, ByteOrder bo) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            $type$[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * $Boxtype$.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - $Boxtype$.BYTES + 1);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, null);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterIntMaskProvider\")\n-    static void msScatterIntMask(IntFunction<$type$[]> fa, LongFunction<MemorySegment> fb,\n-                                 BiFunction<Integer,Integer,int[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_INT_SPECIES != null) {\n-            $type$[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * $Boxtype$.BYTES);\n-            int[] b = fs.apply(a.length, (int) ms.byteSize() - $Boxtype$.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    IntVector idx = IntVector.fromArray(SAME_LENGTH_INT_SPECIES, b, i);\n-                    $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"msGatherScatterLongMaskProvider\")\n-    static void msScatterLongMask(IntFunction<$type$[]> fa, LongFunction<MemorySegment> fb,\n-                                  BiFunction<Integer,Long,long[]> fs, ByteOrder bo, IntFunction<boolean[]> fm) {\n-        if (SAME_LENGTH_LONG_SPECIES != null) {\n-            $type$[] a = fa.apply(SPECIES.length());\n-            MemorySegment ms = fb.apply(a.length * $Boxtype$.BYTES);\n-            long[] b = fs.apply(a.length, ms.byteSize() - $Boxtype$.BYTES + 1);\n-            boolean[] mask = fm.apply(SPECIES.length());\n-            VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n-\n-            for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-                for (int i = 0; i < a.length; i += SPECIES.length()) {\n-                    LongVector idx = LongVector.fromArray(SAME_LENGTH_LONG_SPECIES, b, i);\n-                    $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-                    av.intoMemorySegment(ms, idx, bo, vmask);\n-                }\n-            }\n-\n-            assertScatterMemorySegmentsEquals(ms, a, b, bo, mask);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":0,"deletions":272,"binary":false,"changes":272,"status":"modified"}]}