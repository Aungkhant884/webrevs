{"files":[{"patch":"@@ -253,2 +253,2 @@\n-     * @return true IFF the receiver is a reference projection type of a *value favoring* primitive class\n-     * and false otherwise.\n+     * @return true IFF the receiver is a reference projection of a primitive class type and false\n+     * for primitives or plain references\n@@ -261,18 +261,2 @@\n-     * @return true IFF the receiver is a primitive reference type and false otherwise.\n-     *\/\n-    public boolean isPrimitiveReferenceType() {\n-        return false;\n-    }\n-\n-    \/**\n-     * @return true IFF the receiver is a value projection of a *reference favoring* primitive class type\n-     * and false otherwise.\n-     *\/\n-    public boolean isValueProjection() {\n-        return false;\n-    }\n-\n-    \/**\n-     * Returns the ClassType representing the primitive value type\n-     * of this type, if the class of this type is a primitive class\n-     * null otherwise\n+     * @return the value projection type IFF the receiver is a reference projection of a primitive class type\n+     * and null otherwise\n@@ -280,1 +264,1 @@\n-    public ClassType asValueType() {\n+    public Type valueProjection() {\n@@ -305,1 +289,1 @@\n-    public static abstract class StructuralTypeMapping<S> extends Types.TypeMapping<S> {\n+    public abstract static class StructuralTypeMapping<S> extends Types.TypeMapping<S> {\n@@ -941,1 +925,3 @@\n-            return kind == UNBOUND;\n+            \/\/ is it `?` or `? extends Object`?\n+            return kind == UNBOUND ||\n+                    (kind == EXTENDS && type.tsym.flatName() == type.tsym.name.table.names.java_lang_Object);\n@@ -1058,2 +1044,2 @@\n-             * A primitive reference type:  (Assosiated primitive class could be either\n-             * reference default or value-default)\n+             * Reference projection type of a primitive-favoring aka primitive-default\n+             * plain vanilla primitive class type,\n@@ -1088,2 +1074,1 @@\n-             *  As yet unknown projection type of an as yet unknown default provenance class. Is also\n-             *  the terminal flavor for package-info\/module-info files.\n+             *  As yet unknown projection type of an as yet unknown default provenance class.\n@@ -1101,4 +1086,1 @@\n-            public Flavor metamorphose(long classFlags) {\n-\n-                boolean isPrimtiveClass = (classFlags & PRIMITIVE_CLASS) != 0;\n-                boolean isReferenceFavoring = (classFlags & REFERENCE_FAVORING) != 0;\n+            public Flavor metamorphose(boolean isPrimtiveClass) {\n@@ -1118,1 +1100,1 @@\n-                            return isReferenceFavoring ? Q_TypeOf_L : Q_TypeOf_Q;\n+                            return isPrimtiveClass ? Q_TypeOf_Q : Q_TypeOf_L;\n@@ -1120,1 +1102,1 @@\n-                            return isPrimtiveClass ? (isReferenceFavoring ? L_TypeOf_Q : Q_TypeOf_Q) : L_TypeOf_L;\n+                            return isPrimtiveClass ? Q_TypeOf_Q : L_TypeOf_L;\n@@ -1233,0 +1215,2 @@\n+\n+            boolean isReferenceProjection;\n@@ -1234,7 +1218,1 @@\n-                if (isReferenceProjection()) {\n-                    buf.append('.');\n-                    buf.append(tsym.name.table.names.ref);\n-                } else if (isValueProjection()) {\n-                    buf.append('.');\n-                    buf.append(tsym.name.table.names.val);\n-                }\n+                isReferenceProjection = isReferenceProjection();\n@@ -1242,1 +1220,5 @@\n-                \/\/ don't let missing types capsize the boat.\n+                isReferenceProjection = false; \/\/ handle missing types gracefully.\n+            }\n+            if (isReferenceProjection) {\n+                buf.append('.');\n+                buf.append(tsym.name.table.names.ref);\n@@ -1244,0 +1226,1 @@\n+\n@@ -1306,1 +1289,1 @@\n-                outer_field = outer_field.asValueType();\n+                outer_field = outer_field.valueProjection();\n@@ -1341,7 +1324,1 @@\n-            \/\/ guard against over-eager and\/or inopportune completion\n-            if (tsym != null) {\n-                if (flavor == Flavor.Q_TypeOf_X || tsym.isCompleted()) {\n-                    flavor = flavor.metamorphose(tsym.flags());\n-                }\n-            }\n-            return flavor == Flavor.Q_TypeOf_Q || flavor == Flavor.Q_TypeOf_L;\n+            return !isReferenceProjection() && tsym != null && tsym.isPrimitiveClass();\n@@ -1352,12 +1329,1 @@\n-            \/\/ guard against over-eager and\/or inopportune completion\n-            if (tsym != null) {\n-                if (flavor == Flavor.L_TypeOf_X || tsym.isCompleted()) {\n-                    flavor = flavor.metamorphose(tsym.flags());\n-                }\n-            }\n-            return flavor == Flavor.L_TypeOf_Q && tsym.type.getFlavor() == Flavor.Q_TypeOf_Q; \/\/ discount reference favoring primitives.\n-        }\n-\n-        @Override\n-        public boolean isPrimitiveReferenceType() {\n-            \/\/ guard against over-eager and\/or inopportune completion\n+            \/\/ gaurd against over-eager and\/or inopportune completion\n@@ -1366,1 +1332,1 @@\n-                    flavor = flavor.metamorphose(tsym.flags());\n+                    flavor = flavor.metamorphose(tsym.isPrimitiveClass());\n@@ -1373,5 +1339,3 @@\n-        public boolean isValueProjection() {\n-            \/\/ guard against over-eager and\/or inopportune completion\n-            if (tsym != null) {\n-                if (flavor == Flavor.Q_TypeOf_X || tsym.isCompleted()) {\n-                    flavor = flavor.metamorphose(tsym.flags());\n+        public Type valueProjection() {\n+            if (!isReferenceProjection())\n+                return null;\n@@ -1379,4 +1343,2 @@\n-                }\n-            }\n-            return flavor == Flavor.Q_TypeOf_L;\n-        }\n+            if (projection !=  null)\n+                return projection;\n@@ -1384,5 +1346,3 @@\n-        \/\/ return the primitive value type *preserving parameterizations*\n-        @Override\n-        public ClassType asValueType() {\n-            if (tsym == null || !tsym.isPrimitiveClass())\n-                return null;\n+            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.Q_TypeOf_Q);\n+            projection.allparams_field = allparams_field;\n+            projection.supertype_field = supertype_field;\n@@ -1390,21 +1350,4 @@\n-            switch (flavor) {\n-                case Q_TypeOf_L:\n-                case Q_TypeOf_Q:\n-                    return this;\n-                case L_TypeOf_Q:\n-                    if (projection != null)\n-                        return projection;\n-\n-                    projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(),\n-                            tsym.isReferenceFavoringPrimitiveClass() ? Flavor.Q_TypeOf_L : Flavor.Q_TypeOf_Q);\n-                    projection.allparams_field = allparams_field;\n-                    projection.supertype_field = supertype_field;\n-\n-                    projection.interfaces_field = interfaces_field;\n-                    projection.all_interfaces_field = all_interfaces_field;\n-                    projection.projection = this;\n-                    return projection;\n-                default:\n-                    Assert.check(false, \"Should not get here\");\n-                    return null;\n-            }\n+            projection.interfaces_field = interfaces_field;\n+            projection.all_interfaces_field = all_interfaces_field;\n+            projection.projection = this;\n+            return projection;\n@@ -2148,1 +2091,1 @@\n-    public static abstract class DelegatedType extends Type {\n+    public abstract static class DelegatedType extends Type {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":41,"deletions":98,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -1262,2 +1261,1 @@\n-                    && (t.tsym != s.tsym ||\n-                        (t.isReferenceProjection() == s.isReferenceProjection() && t.isValueProjection() == s.isValueProjection()))\n+                    && (t.tsym != s.tsym || t.isReferenceProjection() == s.isReferenceProjection())\n@@ -1510,1 +1508,0 @@\n-                    && t.isValueProjection() == s.isValueProjection()\n@@ -1518,1 +1515,1 @@\n-                        et = et.asValueType();\n+                        et = et.valueProjection();\n@@ -1784,1 +1781,1 @@\n-                    false :\n+                    true :\n@@ -2326,1 +2323,1 @@\n-            if (t.hasTag(CLASS) && !t.tsym.isPrimitiveClass() && !t.tsym.isInterface() && !t.tsym.isAbstract()) {\n+            if (t.hasTag(CLASS) && !t.isReferenceProjection() && !t.tsym.isInterface() && !t.tsym.isAbstract()) {\n@@ -2689,9 +2686,1 @@\n-                Flavor wantedFlavor = t.flavor;\n-                if (t.isIntersection()) {\n-                    IntersectionClassType ict = (IntersectionClassType) t;\n-                    Type firstExplicitBound = ict.getExplicitComponents().head;\n-                    if (firstExplicitBound.hasTag(CLASS))\n-                        wantedFlavor = firstExplicitBound.getFlavor();\n-                    \/\/ Todo: Handle Type variable case.\n-                }\n-                if (erased.hasTag(CLASS) && wantedFlavor != erased.getFlavor()) {\n+                if (erased.hasTag(CLASS) && t.flavor != erased.getFlavor()) {\n@@ -2700,1 +2689,1 @@\n-                            erased.getMetadata(), wantedFlavor);\n+                            erased.getMetadata(), t.flavor);\n@@ -5185,1 +5174,1 @@\n-    public static abstract class DefaultTypeVisitor<R,S> implements Type.Visitor<R,S> {\n+    public abstract static class DefaultTypeVisitor<R,S> implements Type.Visitor<R,S> {\n@@ -5212,1 +5201,1 @@\n-    public static abstract class DefaultSymbolVisitor<R,S> implements Symbol.Visitor<R,S> {\n+    public abstract static class DefaultSymbolVisitor<R,S> implements Symbol.Visitor<R,S> {\n@@ -5235,1 +5224,1 @@\n-    public static abstract class SimpleVisitor<R,S> extends DefaultTypeVisitor<R,S> {\n+    public abstract static class SimpleVisitor<R,S> extends DefaultTypeVisitor<R,S> {\n@@ -5255,1 +5244,1 @@\n-    public static abstract class TypeRelation extends SimpleVisitor<Boolean,Type> {}\n+    public abstract static class TypeRelation extends SimpleVisitor<Boolean,Type> {}\n@@ -5265,1 +5254,1 @@\n-    public static abstract class UnaryVisitor<R> extends SimpleVisitor<R,Void> {\n+    public abstract static class UnaryVisitor<R> extends SimpleVisitor<R,Void> {\n@@ -5330,1 +5319,1 @@\n-    public static abstract class SignatureGenerator {\n+    public abstract static class SignatureGenerator {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":12,"deletions":23,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-                if (env.info.inWithField && v.getKind() == ElementKind.FIELD && (v.flags() & STATIC) == 0 && v.owner.isPrimitiveClass()) {\n+                if (env.info.inWithField && v.getKind() == ElementKind.FIELD && (v.flags() & STATIC) == 0 && types.isPrimitiveClass(v.owner.type)) {\n@@ -638,1 +638,4 @@\n-                    if (pt == Type.recoveryType) {\n+                    boolean needsReport = pt == Type.recoveryType ||\n+                            (details.getDiagnosticPosition() != null &&\n+                            details.getDiagnosticPosition().getTree().hasTag(LAMBDA));\n+                    if (needsReport) {\n@@ -1336,1 +1339,1 @@\n-                if ((v.flags_field & FINAL) == 0 || ((v.flags_field & STATIC) == 0 && v.owner.isPrimitiveClass()) ||\n+                if ((v.flags_field & FINAL) == 0 || ((v.flags_field & STATIC) == 0 && types.isPrimitiveClass(v.owner.type)) ||\n@@ -1539,1 +1542,1 @@\n-                        (sym.flags() & STATIC) != 0 || !sym.owner.isPrimitiveClass()) {\n+                        (sym.flags() & STATIC) != 0 || !types.isPrimitiveClass(sym.owner.type)) {\n@@ -1553,2 +1556,1 @@\n-                    \/\/ withfield always evaluates to the primitive value type.\n-                    capturedType = capture(ownType.asValueType());\n+                    capturedType = capture(ownType);\n@@ -1621,1 +1623,1 @@\n-                            loopEnv, exprType, names.iterator, List.nil(), List.nil());\n+                            loopEnv, types.skipTypeVars(exprType, false), names.iterator, List.nil(), List.nil());\n@@ -1875,0 +1877,1 @@\n+                preFlow(c);\n@@ -2216,1 +2219,1 @@\n-                                         : t.isPrimitiveReferenceType() ? t.asValueType() : t)\n+                                         : t.isReferenceProjection() ? t.valueProjection() : t)\n@@ -2661,1 +2664,1 @@\n-                boolean superCallOnPrimitiveReceiver = env.enclClass.sym.isPrimitiveClass()\n+                boolean superCallOnPrimitiveReceiver = types.isPrimitiveClass(env.enclClass.sym.type)\n@@ -2712,1 +2715,1 @@\n-                    msym.owner == syms.objectType.tsym &&\n+                    (msym.owner == syms.objectType.tsym || msym.owner.isInterface()) &&\n@@ -2899,6 +2902,3 @@\n-            JCExpression instantiation = clazz;\n-            if (instantiation.hasTag(TYPEAPPLY))\n-                instantiation = ((JCTypeApply) instantiation).clazz;\n-            if (instantiation.hasTag(SELECT)) {\n-                JCFieldAccess fieldAccess = (JCFieldAccess) instantiation;\n-                if (fieldAccess.selected.type.tsym.isPrimitiveClass() &&\n+            if (clazz.hasTag(SELECT)) {\n+                JCFieldAccess fieldAccess = (JCFieldAccess) clazz;\n+                if (fieldAccess.selected.type.isPrimitiveClass() &&\n@@ -2998,4 +2998,0 @@\n-        \/\/ For primitive classes construction always returns the value type.\n-        if (owntype.tsym.isPrimitiveClass()) {\n-            owntype = owntype.asValueType();\n-        }\n@@ -3103,1 +3099,1 @@\n-                    isSerializable(clazztype)) {\n+                    rs.isSerializable(clazztype)) {\n@@ -3231,1 +3227,1 @@\n-            if (needsRecovery && isSerializable(pt())) {\n+            if (needsRecovery && rs.isSerializable(pt())) {\n@@ -3732,1 +3728,1 @@\n-                    isSerializable(pt());\n+                    rs.isSerializable(pt());\n@@ -4339,7 +4335,2 @@\n-        \/\/ (1) Also find the environment current for the class where\n-        \/\/     sym is defined (`symEnv').\n-        \/\/ Only for pre-tiger versions (1.4 and earlier):\n-        \/\/ (2) Also determine whether we access symbol out of an anonymous\n-        \/\/     class in a this or super call.  This is illegal for instance\n-        \/\/     members since such classes don't carry a this$n link.\n-        \/\/     (`noOuterThisPath').\n+        \/\/ Also find the environment current for the class where\n+        \/\/ sym is defined (`symEnv').\n@@ -4347,1 +4338,0 @@\n-        boolean noOuterThisPath = false;\n@@ -4356,2 +4346,0 @@\n-                if ((symEnv.enclClass.sym.flags() & NOOUTERTHIS) != 0)\n-                    noOuterThisPath = false;\n@@ -4379,1 +4367,1 @@\n-        if ((symEnv.info.isSelfCall || noOuterThisPath) &&\n+        if (symEnv.info.isSelfCall &&\n@@ -4590,2 +4578,2 @@\n-                } else if ((name == names.ref || name == names.val) && site.tsym != null && site.tsym.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP)) {\n-                    return site.tsym; \/\/ TODO: JDK-8244229: Need more robust handling of .ref and .val reference in source code\n+                } else if (site.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n+                    return site.tsym;\n@@ -4705,2 +4693,2 @@\n-                    \/\/ (a) If symbol is a primitive class and its reference\/value projection\n-                    \/\/ is requested via the .ref\/.val notation, then adjust the computed type to\n+                    \/\/ (a) If symbol is a primitive class and its reference projection\n+                    \/\/ is requested via the .ref notation, then adjust the computed type to\n@@ -4708,22 +4696,2 @@\n-                    if (sym.isPrimitiveClass()) {\n-                        if (sym.isReferenceFavoringPrimitiveClass()) {\n-                            Assert.check(owntype.getFlavor() == Flavor.L_TypeOf_Q);\n-                        } else {\n-                            Assert.check(owntype.getFlavor() == Flavor.Q_TypeOf_Q);\n-                        }\n-                        if (tree.hasTag(SELECT)) {\n-                            Name name = ((JCFieldAccess)tree).name;\n-                            if (name == names.ref) {\n-                                if (sym.isReferenceFavoringPrimitiveClass()) {\n-                                    \/\/ We should already be good to go with owntype\n-                                } else {\n-                                    owntype = new ClassType(ownOuter, owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.L_TypeOf_Q);\n-                                }\n-                            } else if (name == names.val) {\n-                                if (sym.isReferenceFavoringPrimitiveClass()) {\n-                                    owntype = new ClassType(ownOuter, owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.Q_TypeOf_L);\n-                                } else {\n-                                    \/\/ We should already be good to go with owntype\n-                                }\n-                            }\n-                        }\n+                    if (owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n+                        owntype = new ClassType(owntype.getEnclosingType(), owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.L_TypeOf_Q);\n@@ -5342,0 +5310,8 @@\n+    @Override\n+    public void visitModifiers(JCModifiers tree) {\n+        \/\/error recovery only:\n+        Assert.check(resultInfo.pkind == KindSelector.ERR);\n+\n+        attribAnnotationTypes(tree.annotations, env);\n+    }\n+\n@@ -5439,1 +5415,1 @@\n-            if (c.isPrimitiveClass()) {\n+            if (types.isPrimitiveClass(c.type)) {\n@@ -5550,3 +5526,10 @@\n-                    boolean hasErrorSuper = types.directSupertypes(c.type)\n-                                                 .stream()\n-                                                 .anyMatch(s -> s.tsym.kind == Kind.ERR);\n+                    boolean hasErrorSuper = false;\n+\n+                    hasErrorSuper |= types.directSupertypes(c.type)\n+                                          .stream()\n+                                          .anyMatch(s -> s.tsym.kind == Kind.ERR);\n+\n+                    ClassType ct = (ClassType) c.type;\n+\n+                    hasErrorSuper |= !ct.isCompound() && ct.interfaces_field != ct.all_interfaces_field;\n+\n@@ -5608,1 +5591,1 @@\n-                if (isSerializable(c.type)) {\n+                if (rs.isSerializable(c.type)) {\n@@ -5751,1 +5734,2 @@\n-        \/\/ Check for proper use of serialVersionUID\n+        \/\/ Check for proper use of serialVersionUID and other\n+        \/\/ serialization-related fields and methods\n@@ -5753,2 +5737,1 @@\n-                && isSerializable(c.type)\n-                && (c.flags() & (Flags.ENUM | Flags.INTERFACE)) == 0\n+                && rs.isSerializable(c.type)\n@@ -5756,1 +5739,1 @@\n-            checkSerialVersionUID(tree, c, env);\n+            chk.checkSerialStructure(tree, c);\n@@ -5777,53 +5760,0 @@\n-        \/** check if a type is a subtype of Serializable, if that is available. *\/\n-        boolean isSerializable(Type t) {\n-            try {\n-                syms.serializableType.complete();\n-            }\n-            catch (CompletionFailure e) {\n-                return false;\n-            }\n-            return types.isSubtype(t, syms.serializableType);\n-        }\n-\n-        \/** Check that an appropriate serialVersionUID member is defined. *\/\n-        private void checkSerialVersionUID(JCClassDecl tree, ClassSymbol c, Env<AttrContext> env) {\n-\n-            \/\/ check for presence of serialVersionUID\n-            VarSymbol svuid = null;\n-            for (Symbol sym : c.members().getSymbolsByName(names.serialVersionUID)) {\n-                if (sym.kind == VAR) {\n-                    svuid = (VarSymbol)sym;\n-                    break;\n-                }\n-            }\n-\n-            if (svuid == null) {\n-                if (!c.isRecord())\n-                    log.warning(LintCategory.SERIAL, tree.pos(), Warnings.MissingSVUID(c));\n-                return;\n-            }\n-\n-            \/\/ Check if @SuppressWarnings(\"serial\") is an annotation of serialVersionUID.\n-            \/\/ See JDK-8231622 for more information.\n-            Lint lint = env.info.lint.augment(svuid);\n-            if (lint.isSuppressed(LintCategory.SERIAL)) {\n-                return;\n-            }\n-\n-            \/\/ check that it is static final\n-            if ((svuid.flags() & (STATIC | FINAL)) !=\n-                (STATIC | FINAL))\n-                log.warning(LintCategory.SERIAL,\n-                        TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ImproperSVUID(c));\n-\n-            \/\/ check that it is long\n-            else if (!svuid.type.hasTag(LONG))\n-                log.warning(LintCategory.SERIAL,\n-                        TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.LongSVUID(c));\n-\n-            \/\/ check constant\n-            else if (svuid.getConstValue() == null)\n-                log.warning(LintCategory.SERIAL,\n-                        TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ConstantSVUID(c));\n-        }\n-\n@@ -6169,0 +6099,2 @@\n+            initTypeIfNeeded(that);\n+            initTypeIfNeeded(that.var);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":54,"deletions":122,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.function.BiConsumer;\n@@ -75,0 +76,7 @@\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.ElementKindVisitor14;\n@@ -822,6 +830,3 @@\n-                JCExpression instantiation = expr;\n-                if (instantiation.hasTag(TYPEAPPLY))\n-                    instantiation = ((JCTypeApply) instantiation).clazz;\n-                if (instantiation.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) instantiation;\n-                    if (fieldAccess.selected.type.tsym.isPrimitiveClass() &&\n+                if (expr.hasTag(SELECT)) {\n+                    JCFieldAccess fieldAccess = (JCFieldAccess) expr;\n+                    if (fieldAccess.selected.type.isPrimitiveClass() &&\n@@ -875,2 +880,2 @@\n-                    diags.fragment(Fragments.TypeReqRef),\n-                    t);\n+                                diags.fragment(Fragments.TypeReqRef),\n+                                t);\n@@ -888,1 +893,1 @@\n-        if (t.isPrimitive() || t.tsym.isPrimitiveClass())\n+        if (t.isPrimitive() || t.isPrimitiveClass() || t.isReferenceProjection())\n@@ -1391,1 +1396,1 @@\n-                if (sym.owner.isPrimitiveClass() && (flags & STATIC) == 0) {\n+                if (types.isPrimitiveClass(sym.owner.type) && (flags & STATIC) == 0) {\n@@ -1703,1 +1708,1 @@\n-                    (!tree.type.tsym.isPrimitiveClass() || (tree.name != names.ref && tree.name != names.val))) {\n+                    (tree.name != names.ref || !tree.type.isReferenceProjection())) {\n@@ -1707,5 +1712,2 @@\n-\n-                \/\/ Tolerate the pseudo-select V.ref\/V.val: V<T>.ref\/val will be static if V<T> is and\n-                \/\/ should not be confused as selecting a static member of a parameterized type. Both\n-                \/\/ these constructs are illegal anyway & will be more appropriately complained against shortly.\n-                \/\/ Note: the canonicl form is V.ref<T> and V.val<T> not V<T>.ref and V<T>.val\n+                \/\/ Tolerate the pseudo-select V.ref: V<T>.ref will be static if V<T> is and\n+                \/\/ should not be confused as selecting a static member of a parameterized type.\n@@ -2775,1 +2777,1 @@\n-        if (c.tsym.isPrimitiveClass() && implementsIdentityObject) {\n+        if (c.isPrimitiveClass() && implementsIdentityObject) {\n@@ -2777,1 +2779,1 @@\n-        } else if (implementsPrimitiveObject && !c.tsym.isPrimitiveClass() && !c.isReferenceProjection() && !c.tsym.isInterface() && !c.tsym.isAbstract()) {\n+        } else if (implementsPrimitiveObject && !c.isPrimitiveClass() && !c.isReferenceProjection() && !c.tsym.isInterface() && !c.tsym.isAbstract()) {\n@@ -3378,1 +3380,3 @@\n-            t = ((Attribute.Class)l.head.snd).getValue();\n+            if (l.head.snd instanceof Attribute.Class) {\n+                t = ((Attribute.Class)l.head.snd).getValue();\n+            }\n@@ -4619,0 +4623,689 @@\n+\n+    \/** check if a type is a subtype of Externalizable, if that is available. *\/\n+    boolean isExternalizable(Type t) {\n+        try {\n+            syms.externalizableType.complete();\n+        }\n+        catch (CompletionFailure e) {\n+            return false;\n+        }\n+        return types.isSubtype(t, syms.externalizableType);\n+    }\n+\n+    \/**\n+     * Check structure of serialization declarations.\n+     *\/\n+    public void checkSerialStructure(JCClassDecl tree, ClassSymbol c) {\n+        (new SerialTypeVisitor()).visit(c, tree);\n+    }\n+\n+    \/**\n+     * This visitor will warn if a serialization-related field or\n+     * method is declared in a suspicious or incorrect way. In\n+     * particular, it will warn for cases where the runtime\n+     * serialization mechanism will silently ignore a mis-declared\n+     * entity.\n+     *\n+     * Distinguished serialization-related fields and methods:\n+     *\n+     * Methods:\n+     *\n+     * private void writeObject(ObjectOutputStream stream) throws IOException\n+     * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException\n+     *\n+     * private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException\n+     * private void readObjectNoData() throws ObjectStreamException\n+     * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException\n+     *\n+     * Fields:\n+     *\n+     * private static final long serialVersionUID\n+     * private static final ObjectStreamField[] serialPersistentFields\n+     *\n+     * Externalizable: methods defined on the interface\n+     * public void writeExternal(ObjectOutput) throws IOException\n+     * public void readExternal(ObjectInput) throws IOException\n+     *\/\n+    private class SerialTypeVisitor extends ElementKindVisitor14<Void, JCClassDecl> {\n+        SerialTypeVisitor() {\n+            this.lint = Check.this.lint;\n+        }\n+\n+        private static final Set<String> serialMethodNames =\n+            Set.of(\"writeObject\", \"writeReplace\",\n+                   \"readObject\",  \"readObjectNoData\",\n+                   \"readResolve\");\n+\n+        private static final Set<String> serialFieldNames =\n+            Set.of(\"serialVersionUID\", \"serialPersistentFields\");\n+\n+        \/\/ Type of serialPersistentFields\n+        private final Type OSF_TYPE = new Type.ArrayType(syms.objectStreamFieldType, syms.arrayClass);\n+\n+        Lint lint;\n+\n+        @Override\n+        public Void defaultAction(Element e, JCClassDecl p) {\n+            throw new IllegalArgumentException(Objects.requireNonNullElse(e.toString(), \"\"));\n+        }\n+\n+        @Override\n+        public Void visitType(TypeElement e, JCClassDecl p) {\n+            runUnderLint(e, p, (symbol, param) -> super.visitType(symbol, param));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitTypeAsClass(TypeElement e,\n+                                     JCClassDecl p) {\n+            \/\/ Anonymous classes filtered out by caller.\n+\n+            ClassSymbol c = (ClassSymbol)e;\n+\n+            checkCtorAccess(p, c);\n+\n+            \/\/ Check for missing serialVersionUID; check *not* done\n+            \/\/ for enums or records.\n+            VarSymbol svuidSym = null;\n+            for (Symbol sym : c.members().getSymbolsByName(names.serialVersionUID)) {\n+                if (sym.kind == VAR) {\n+                    svuidSym = (VarSymbol)sym;\n+                    break;\n+                }\n+            }\n+\n+            if (svuidSym == null) {\n+                log.warning(LintCategory.SERIAL, p.pos(), Warnings.MissingSVUID(c));\n+            }\n+\n+            \/\/ Check for serialPersistentFields to gate checks for\n+            \/\/ non-serializable non-transient instance fields\n+            boolean serialPersistentFieldsPresent =\n+                    c.members()\n+                     .getSymbolsByName(names.serialPersistentFields, sym -> sym.kind == VAR)\n+                     .iterator()\n+                     .hasNext();\n+\n+            \/\/ Check declarations of serialization-related methods and\n+            \/\/ fields\n+            for(Symbol el : c.getEnclosedElements()) {\n+                runUnderLint(el, p, (enclosed, tree) -> {\n+                    String name = null;\n+                    switch(enclosed.getKind()) {\n+                    case FIELD -> {\n+                        if (!serialPersistentFieldsPresent) {\n+                            var flags = enclosed.flags();\n+                            if ( ((flags & TRANSIENT) == 0) &&\n+                                 ((flags & STATIC) == 0)) {\n+                                Type varType = enclosed.asType();\n+                                if (!canBeSerialized(varType)) {\n+                                    \/\/ Note per JLS arrays are\n+                                    \/\/ serializable even if the\n+                                    \/\/ component type is not.\n+                                    log.warning(LintCategory.SERIAL,\n+                                                TreeInfo.diagnosticPositionFor(enclosed, tree),\n+                                                Warnings.NonSerializableInstanceField);\n+                                } else if (varType.hasTag(ARRAY)) {\n+                                    ArrayType arrayType = (ArrayType)varType;\n+                                    Type elementType = arrayType.elemtype;\n+                                    while (elementType.hasTag(ARRAY)) {\n+                                        arrayType = (ArrayType)elementType;\n+                                        elementType = arrayType.elemtype;\n+                                    }\n+                                    if (!canBeSerialized(elementType)) {\n+                                        log.warning(LintCategory.SERIAL,\n+                                                    TreeInfo.diagnosticPositionFor(enclosed, tree),\n+                                                    Warnings.NonSerializableInstanceFieldArray(elementType));\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                        name = enclosed.getSimpleName().toString();\n+                        if (serialFieldNames.contains(name)) {\n+                            VarSymbol field = (VarSymbol)enclosed;\n+                            switch (name) {\n+                            case \"serialVersionUID\"       ->  checkSerialVersionUID(tree, e, field);\n+                            case \"serialPersistentFields\" ->  checkSerialPersistentFields(tree, e, field);\n+                            default -> throw new AssertionError();\n+                            }\n+                        }\n+                    }\n+\n+                    \/\/ Correctly checking the serialization-related\n+                    \/\/ methods is subtle. For the methods declared to be\n+                    \/\/ private or directly declared in the class, the\n+                    \/\/ enclosed elements of the class can be checked in\n+                    \/\/ turn. However, writeReplace and readResolve can be\n+                    \/\/ declared in a superclass and inherited. Note that\n+                    \/\/ the runtime lookup walks the superclass chain\n+                    \/\/ looking for writeReplace\/readResolve via\n+                    \/\/ Class.getDeclaredMethod. This differs from calling\n+                    \/\/ Elements.getAllMembers(TypeElement) as the latter\n+                    \/\/ will also pull in default methods from\n+                    \/\/ superinterfaces. In other words, the runtime checks\n+                    \/\/ (which long predate default methods on interfaces)\n+                    \/\/ do not admit the possibility of inheriting methods\n+                    \/\/ this way, a difference from general inheritance.\n+\n+                    \/\/ The current implementation just checks the enclosed\n+                    \/\/ elements and does not directly check the inherited\n+                    \/\/ methods. If all the types are being checked this is\n+                    \/\/ less of a concern; however, there are cases that\n+                    \/\/ could be missed. In particular, readResolve and\n+                    \/\/ writeReplace could, in principle, by inherited from\n+                    \/\/ a non-serializable superclass and thus not checked\n+                    \/\/ even if compiled with a serializable child class.\n+                    case METHOD -> {\n+                        var method = (MethodSymbol)enclosed;\n+                        name = method.getSimpleName().toString();\n+                        if (serialMethodNames.contains(name)) {\n+                            switch (name) {\n+                            case \"writeObject\"      -> checkWriteObject(tree, e, method);\n+                            case \"writeReplace\"     -> checkWriteReplace(tree,e, method);\n+                            case \"readObject\"       -> checkReadObject(tree,e, method);\n+                            case \"readObjectNoData\" -> checkReadObjectNoData(tree, e, method);\n+                            case \"readResolve\"      -> checkReadResolve(tree, e, method);\n+                            default ->  throw new AssertionError();\n+                            }\n+                        }\n+                    }\n+                    }\n+                });\n+            }\n+\n+            return null;\n+        }\n+\n+        boolean canBeSerialized(Type type) {\n+            return type.isPrimitive() || rs.isSerializable(type);\n+        }\n+\n+        \/**\n+         * Check that Externalizable class needs a public no-arg\n+         * constructor.\n+         *\n+         * Check that a Serializable class has access to the no-arg\n+         * constructor of its first nonserializable superclass.\n+         *\/\n+        private void checkCtorAccess(JCClassDecl tree, ClassSymbol c) {\n+            if (isExternalizable(c.type)) {\n+                for(var sym : c.getEnclosedElements()) {\n+                    if (sym.isConstructor() &&\n+                        ((sym.flags() & PUBLIC) == PUBLIC)) {\n+                        if (((MethodSymbol)sym).getParameters().isEmpty()) {\n+                            return;\n+                        }\n+                    }\n+                }\n+                log.warning(LintCategory.SERIAL, tree.pos(),\n+                            Warnings.ExternalizableMissingPublicNoArgCtor);\n+            } else {\n+                \/\/ Approximate access to the no-arg constructor up in\n+                \/\/ the superclass chain by checking that the\n+                \/\/ constructor is not private. This may not handle\n+                \/\/ some cross-package situations correctly.\n+                Type superClass = c.getSuperclass();\n+                \/\/ java.lang.Object is *not* Serializable so this loop\n+                \/\/ should terminate.\n+                while (rs.isSerializable(superClass) ) {\n+                    try {\n+                        superClass = (Type)((TypeElement)(((DeclaredType)superClass)).asElement()).getSuperclass();\n+                    } catch(ClassCastException cce) {\n+                        return ; \/\/ Don't try to recover\n+                    }\n+                }\n+                \/\/ Non-Serializable super class\n+                try {\n+                    ClassSymbol supertype = ((ClassSymbol)(((DeclaredType)superClass).asElement()));\n+                    for(var sym : supertype.getEnclosedElements()) {\n+                        if (sym.isConstructor()) {\n+                            MethodSymbol ctor = (MethodSymbol)sym;\n+                            if (ctor.getParameters().isEmpty()) {\n+                                if (((ctor.flags() & PRIVATE) == PRIVATE) ||\n+                                    \/\/ Handle nested classes and implicit this$0\n+                                    (supertype.getNestingKind() == NestingKind.MEMBER &&\n+                                     ((supertype.flags() & STATIC) == 0)))\n+                                    log.warning(LintCategory.SERIAL, tree.pos(),\n+                                                Warnings.SerializableMissingAccessNoArgCtor(supertype.getQualifiedName()));\n+                            }\n+                        }\n+                    }\n+                } catch (ClassCastException cce) {\n+                    return ; \/\/ Don't try to recover\n+                }\n+                return;\n+            }\n+        }\n+\n+        private void checkSerialVersionUID(JCClassDecl tree, Element e, VarSymbol svuid) {\n+            \/\/ To be effective, serialVersionUID must be marked static\n+            \/\/ and final, but private is recommended. But alas, in\n+            \/\/ practice there are many non-private serialVersionUID\n+            \/\/ fields.\n+             if ((svuid.flags() & (STATIC | FINAL)) !=\n+                 (STATIC | FINAL)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(svuid, tree),\n+                             Warnings.ImproperSVUID((Symbol)e));\n+             }\n+\n+             \/\/ check svuid has type long\n+             if (!svuid.type.hasTag(LONG)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(svuid, tree),\n+                             Warnings.LongSVUID((Symbol)e));\n+             }\n+\n+             if (svuid.getConstValue() == null)\n+                 log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(svuid, tree),\n+                             Warnings.ConstantSVUID((Symbol)e));\n+        }\n+\n+        private void checkSerialPersistentFields(JCClassDecl tree, Element e, VarSymbol spf) {\n+            \/\/ To be effective, serialPersisentFields must be private, static, and final.\n+             if ((spf.flags() & (PRIVATE | STATIC | FINAL)) !=\n+                 (PRIVATE | STATIC | FINAL)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(spf, tree), Warnings.ImproperSPF);\n+             }\n+\n+             if (!types.isSameType(spf.type, OSF_TYPE)) {\n+                 log.warning(LintCategory.SERIAL,\n+                             TreeInfo.diagnosticPositionFor(spf, tree), Warnings.OSFArraySPF);\n+             }\n+\n+            if (isExternalizable((Type)(e.asType()))) {\n+                log.warning(LintCategory.SERIAL, tree.pos(),\n+                            Warnings.IneffectualSerialFieldExternalizable);\n+            }\n+\n+            \/\/ Warn if serialPersistentFields is initialized to a\n+            \/\/ literal null.\n+            JCTree spfDecl = TreeInfo.declarationFor(spf, tree);\n+            if (spfDecl != null && spfDecl.getTag() == VARDEF) {\n+                JCVariableDecl variableDef = (JCVariableDecl) spfDecl;\n+                JCExpression initExpr = variableDef.init;\n+                 if (initExpr != null && TreeInfo.isNull(initExpr)) {\n+                     log.warning(LintCategory.SERIAL, initExpr.pos(),\n+                                 Warnings.SPFNullInit);\n+                 }\n+            }\n+        }\n+\n+        private void checkWriteObject(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/ The \"synchronized\" modifier is seen in the wild on\n+            \/\/ readObject and writeObject methods and is generally\n+            \/\/ innocuous.\n+\n+            \/\/ private void writeObject(ObjectOutputStream stream) throws IOException\n+            checkPrivateNonStaticMethod(tree, method);\n+            checkReturnType(tree, e, method, syms.voidType);\n+            checkOneArg(tree, e, method, syms.objectOutputStreamType);\n+            checkExceptions(tree, e, method, syms.ioExceptionType);\n+            checkExternalizable(tree, e, method);\n+        }\n+\n+        private void checkWriteReplace(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/ ANY-ACCESS-MODIFIER Object writeReplace() throws\n+            \/\/ ObjectStreamException\n+\n+            \/\/ Excluding abstract, could have a more complicated\n+            \/\/ rule based on abstract-ness of the class\n+            checkConcreteInstanceMethod(tree, e, method);\n+            checkReturnType(tree, e, method, syms.objectType);\n+            checkNoArgs(tree, e, method);\n+            checkExceptions(tree, e, method, syms.objectStreamExceptionType);\n+        }\n+\n+        private void checkReadObject(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/ The \"synchronized\" modifier is seen in the wild on\n+            \/\/ readObject and writeObject methods and is generally\n+            \/\/ innocuous.\n+\n+            \/\/ private void readObject(ObjectInputStream stream)\n+            \/\/   throws IOException, ClassNotFoundException\n+            checkPrivateNonStaticMethod(tree, method);\n+            checkReturnType(tree, e, method, syms.voidType);\n+            checkOneArg(tree, e, method, syms.objectInputStreamType);\n+            checkExceptions(tree, e, method, syms.ioExceptionType, syms.classNotFoundExceptionType);\n+            checkExternalizable(tree, e, method);\n+        }\n+\n+        private void checkReadObjectNoData(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/ private void readObjectNoData() throws ObjectStreamException\n+            checkPrivateNonStaticMethod(tree, method);\n+            checkReturnType(tree, e, method, syms.voidType);\n+            checkNoArgs(tree, e, method);\n+            checkExceptions(tree, e, method, syms.objectStreamExceptionType);\n+            checkExternalizable(tree, e, method);\n+        }\n+\n+        private void checkReadResolve(JCClassDecl tree, Element e, MethodSymbol method) {\n+            \/\/ ANY-ACCESS-MODIFIER Object readResolve()\n+            \/\/ throws ObjectStreamException\n+\n+            \/\/ Excluding abstract, could have a more complicated\n+            \/\/ rule based on abstract-ness of the class\n+            checkConcreteInstanceMethod(tree, e, method);\n+            checkReturnType(tree,e, method, syms.objectType);\n+            checkNoArgs(tree, e, method);\n+            checkExceptions(tree, e, method, syms.objectStreamExceptionType);\n+        }\n+\n+        void checkPrivateNonStaticMethod(JCClassDecl tree, MethodSymbol method) {\n+            var flags = method.flags();\n+            if ((flags & PRIVATE) == 0) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodNotPrivate(method.getSimpleName()));\n+            }\n+\n+            if ((flags & STATIC) != 0) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodStatic(method.getSimpleName()));\n+            }\n+        }\n+\n+        \/**\n+         * Per section 1.12 \"Serialization of Enum Constants\" of\n+         * the serialization specification, due to the special\n+         * serialization handling of enums, any writeObject,\n+         * readObject, writeReplace, and readResolve methods are\n+         * ignored as are serialPersistentFields and\n+         * serialVersionUID fields.\n+         *\/\n+        @Override\n+        public Void visitTypeAsEnum(TypeElement e,\n+                                    JCClassDecl p) {\n+            for(Element el : e.getEnclosedElements()) {\n+                runUnderLint(el, p, (enclosed, tree) -> {\n+                    String name = enclosed.getSimpleName().toString();\n+                    switch(enclosed.getKind()) {\n+                    case FIELD -> {\n+                        if (serialFieldNames.contains(name)) {\n+                            log.warning(LintCategory.SERIAL, tree.pos(),\n+                                        Warnings.IneffectualSerialFieldEnum(name));\n+                        }\n+                    }\n+\n+                    case METHOD -> {\n+                        if (serialMethodNames.contains(name)) {\n+                            log.warning(LintCategory.SERIAL, tree.pos(),\n+                                        Warnings.IneffectualSerialMethodEnum(name));\n+                        }\n+                    }\n+                    }\n+                });\n+            }\n+            return null;\n+        }\n+\n+        \/**\n+         * Most serialization-related fields and methods on interfaces\n+         * are ineffectual or problematic.\n+         *\/\n+        @Override\n+        public Void visitTypeAsInterface(TypeElement e,\n+                                         JCClassDecl p) {\n+            for(Element el : e.getEnclosedElements()) {\n+                runUnderLint(el, p, (enclosed, tree) -> {\n+                    String name = null;\n+                    switch(enclosed.getKind()) {\n+                    case FIELD -> {\n+                        var field = (VarSymbol)enclosed;\n+                        name = field.getSimpleName().toString();\n+                        switch(name) {\n+                        case \"serialPersistentFields\" -> {\n+                            log.warning(LintCategory.SERIAL,\n+                                        TreeInfo.diagnosticPositionFor(field, tree),\n+                                        Warnings.IneffectualSerialFieldInterface);\n+                        }\n+\n+                        case \"serialVersionUID\" -> {\n+                            checkSerialVersionUID(tree, e, field);\n+                        }\n+                        }\n+                    }\n+\n+                    case METHOD -> {\n+                        var method = (MethodSymbol)enclosed;\n+                        name = enclosed.getSimpleName().toString();\n+                        if (serialMethodNames.contains(name)) {\n+                            switch (name) {\n+                            case\n+                                \"readObject\",\n+                                \"readObjectNoData\",\n+                                \"writeObject\"      -> checkPrivateMethod(tree, e, method);\n+\n+                            case\n+                                \"writeReplace\",\n+                                \"readResolve\"      -> checkDefaultIneffective(tree, e, method);\n+\n+                            default ->  throw new AssertionError();\n+                            }\n+\n+                        }\n+                    }\n+                    }\n+                });\n+            }\n+\n+            return null;\n+        }\n+\n+        private void checkPrivateMethod(JCClassDecl tree,\n+                                        Element e,\n+                                        MethodSymbol method) {\n+            if ((method.flags() & PRIVATE) == 0) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.NonPrivateMethodWeakerAccess);\n+            }\n+        }\n+\n+        private void checkDefaultIneffective(JCClassDecl tree,\n+                                             Element e,\n+                                             MethodSymbol method) {\n+            if ((method.flags() & DEFAULT) == DEFAULT) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.DefaultIneffective);\n+\n+            }\n+        }\n+\n+        @Override\n+        public Void visitTypeAsAnnotationType(TypeElement e,\n+                                              JCClassDecl p) {\n+            \/\/ Per the JLS, annotation types are not serializeable\n+            return null;\n+        }\n+\n+        \/**\n+         * From the Java Object Serialization Specification, 1.13\n+         * Serialization of Records:\n+         *\n+         * \"The process by which record objects are serialized or\n+         * externalized cannot be customized; any class-specific\n+         * writeObject, readObject, readObjectNoData, writeExternal,\n+         * and readExternal methods defined by record classes are\n+         * ignored during serialization and deserialization. However,\n+         * a substitute object to be serialized or a designate\n+         * replacement may be specified, by the writeReplace and\n+         * readResolve methods, respectively. Any\n+         * serialPersistentFields field declaration is\n+         * ignored. Documenting serializable fields and data for\n+         * record classes is unnecessary, since there is no variation\n+         * in the serial form, other than whether a substitute or\n+         * replacement object is used. The serialVersionUID of a\n+         * record class is 0L unless explicitly declared. The\n+         * requirement for matching serialVersionUID values is waived\n+         * for record classes.\"\n+         *\/\n+        @Override\n+        public Void visitTypeAsRecord(TypeElement e,\n+                                      JCClassDecl p) {\n+            for(Element el : e.getEnclosedElements()) {\n+                runUnderLint(el, p, (enclosed, tree) -> {\n+                    String name = enclosed.getSimpleName().toString();\n+                    switch(enclosed.getKind()) {\n+                    case FIELD -> {\n+                        switch(name) {\n+                        case \"serialPersistentFields\" -> {\n+                            log.warning(LintCategory.SERIAL, tree.pos(),\n+                                        Warnings.IneffectualSerialFieldRecord);\n+                        }\n+\n+                        case \"serialVersionUID\" -> {\n+                            \/\/ Could generate additional warning that\n+                            \/\/ svuid value is not checked to match for\n+                            \/\/ records.\n+                            checkSerialVersionUID(tree, e, (VarSymbol)enclosed);\n+                        }\n+\n+                        }\n+                    }\n+\n+                    case METHOD -> {\n+                        var method = (MethodSymbol)enclosed;\n+                        switch(name) {\n+                        case \"writeReplace\" -> checkWriteReplace(tree, e, method);\n+                        case \"readResolve\"  -> checkReadResolve(tree, e, method);\n+                        default -> {\n+                            if (serialMethodNames.contains(name)) {\n+                                log.warning(LintCategory.SERIAL, tree.pos(),\n+                                            Warnings.IneffectualSerialMethodRecord(name));\n+                            }\n+                        }\n+                        }\n+\n+                    }\n+                    }\n+                });\n+            }\n+            return null;\n+        }\n+\n+        void checkConcreteInstanceMethod(JCClassDecl tree,\n+                                         Element enclosing,\n+                                         MethodSymbol method) {\n+            if ((method.flags() & (STATIC | ABSTRACT)) != 0) {\n+                    log.warning(LintCategory.SERIAL,\n+                                TreeInfo.diagnosticPositionFor(method, tree),\n+                                Warnings.SerialConcreteInstanceMethod(method.getSimpleName()));\n+            }\n+        }\n+\n+        private void checkReturnType(JCClassDecl tree,\n+                                     Element enclosing,\n+                                     MethodSymbol method,\n+                                     Type expectedReturnType) {\n+            \/\/ Note: there may be complications checking writeReplace\n+            \/\/ and readResolve since they return Object and could, in\n+            \/\/ principle, have covariant overrides and any synthetic\n+            \/\/ bridge method would not be represented here for\n+            \/\/ checking.\n+            Type rtype = method.getReturnType();\n+            if (!types.isSameType(expectedReturnType, rtype)) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodUnexpectedReturnType(method.getSimpleName(),\n+                                                                      rtype, expectedReturnType));\n+            }\n+        }\n+\n+        private void checkOneArg(JCClassDecl tree,\n+                                 Element enclosing,\n+                                 MethodSymbol method,\n+                                 Type expectedType) {\n+            String name = method.getSimpleName().toString();\n+\n+            var parameters= method.getParameters();\n+\n+            if (parameters.size() != 1) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodOneArg(method.getSimpleName(), parameters.size()));\n+                return;\n+            }\n+\n+            Type parameterType = parameters.get(0).asType();\n+            if (!types.isSameType(parameterType, expectedType)) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n+                            Warnings.SerialMethodParameterType(method.getSimpleName(),\n+                                                               expectedType,\n+                                                               parameterType));\n+            }\n+        }\n+\n+        private void checkNoArgs(JCClassDecl tree, Element enclosing, MethodSymbol method) {\n+            var parameters = method.getParameters();\n+            if (!parameters.isEmpty()) {\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(parameters.get(0), tree),\n+                            Warnings.SerialMethodNoArgs(method.getSimpleName()));\n+            }\n+        }\n+\n+        private void checkExternalizable(JCClassDecl tree, Element enclosing, MethodSymbol method) {\n+            \/\/ If the enclosing class is externalizable, warn for the method\n+            if (isExternalizable((Type)enclosing.asType())) {\n+                log.warning(LintCategory.SERIAL, tree.pos(),\n+                            Warnings.IneffectualSerialMethodExternalizable(method.getSimpleName()));\n+            }\n+            return;\n+        }\n+\n+        private void checkExceptions(JCClassDecl tree,\n+                                     Element enclosing,\n+                                     MethodSymbol method,\n+                                     Type... declaredExceptions) {\n+            for (Type thrownType: method.getThrownTypes()) {\n+                \/\/ For each exception in the throws clause of the\n+                \/\/ method, if not an Error and not a RuntimeException,\n+                \/\/ check if the exception is a subtype of a declared\n+                \/\/ exception from the throws clause of the\n+                \/\/ serialization method in question.\n+                if (types.isSubtype(thrownType, syms.runtimeExceptionType) ||\n+                    types.isSubtype(thrownType, syms.errorType) ) {\n+                    continue;\n+                } else {\n+                    boolean declared = false;\n+                    for (Type declaredException : declaredExceptions) {\n+                        if (types.isSubtype(thrownType, declaredException)) {\n+                            declared = true;\n+                            continue;\n+                        }\n+                    }\n+                    if (!declared) {\n+                        log.warning(LintCategory.SERIAL,\n+                                    TreeInfo.diagnosticPositionFor(method, tree),\n+                                    Warnings.SerialMethodUnexpectedException(method.getSimpleName(),\n+                                                                             thrownType));\n+                    }\n+                }\n+            }\n+            return;\n+        }\n+\n+        private <E extends Element> Void runUnderLint(E symbol, JCClassDecl p, BiConsumer<E, JCClassDecl> task) {\n+            Lint prevLint = lint;\n+            try {\n+                lint = lint.augment((Symbol) symbol);\n+\n+                if (lint.isEnabled(LintCategory.SERIAL)) {\n+                    task.accept(symbol, p);\n+                }\n+\n+                return null;\n+            } finally {\n+                lint = prevLint;\n+            }\n+        }\n+\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":712,"deletions":19,"binary":false,"changes":731,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -380,1 +380,1 @@\n-                c.sourcefile = tree.sourcefile;\n+                c.classfile = c.sourcefile = tree.sourcefile;\n@@ -499,1 +499,1 @@\n-        c.sourcefile = env.toplevel.sourcefile;\n+        c.classfile = c.sourcefile = env.toplevel.sourcefile;\n@@ -504,1 +504,1 @@\n-        ct.flavor = ct.flavor.metamorphose(c.flags_field);\n+        ct.flavor = ct.flavor.metamorphose((c.flags_field & PRIMITIVE_CLASS) != 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+    private final DeferredCompletionFailureHandler dcfh;\n@@ -338,0 +339,1 @@\n+        dcfh = DeferredCompletionFailureHandler.instance(context);\n@@ -348,1 +350,1 @@\n-    static abstract class BaseAnalyzer extends TreeScanner {\n+    abstract static class BaseAnalyzer extends TreeScanner {\n@@ -779,6 +781,3 @@\n-                            if (sup.tsym.kind == TYP && sup.tsym.isAbstract() && sup.tsym.isSealed()) {\n-                                boolean hasAll = ((ClassSymbol) sup.tsym).permitted\n-                                                                         .stream()\n-                                                                         .allMatch(covered::contains);\n-\n-                                if (hasAll && covered.add(sup.tsym)) {\n+                            if (sup.tsym.kind == TYP) {\n+                                if (isTransitivelyCovered(sup.tsym, covered) &&\n+                                    covered.add(sup.tsym)) {\n@@ -794,0 +793,20 @@\n+        private boolean isTransitivelyCovered(Symbol sealed, Set<Symbol> covered) {\n+            DeferredCompletionFailureHandler.Handler prevHandler =\n+                    dcfh.setHandler(dcfh.speculativeCodeHandler);\n+            try {\n+                if (covered.stream().anyMatch(c -> sealed.isSubClass(c, types)))\n+                    return true;\n+                if (sealed.kind == TYP && sealed.isAbstract() && sealed.isSealed()) {\n+                    return ((ClassSymbol) sealed).permitted\n+                                                 .stream()\n+                                                 .allMatch(s -> isTransitivelyCovered(s, covered));\n+                }\n+                return false;\n+            } catch (CompletionFailure cf) {\n+                \/\/safe to ignore, the symbol will be un-completed when the speculative handler is removed.\n+                return false;\n+            } finally {\n+                dcfh.setHandler(prevHandler);\n+            }\n+        }\n+\n@@ -2202,1 +2221,1 @@\n-                        if (tree.sym.owner.isPrimitiveClass())\n+                        if (types.isPrimitiveClass(tree.sym.owner.type))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -430,1 +430,1 @@\n-                site = site.asValueType();\n+                site = site.valueProjection();\n@@ -493,1 +493,1 @@\n-        return (s2 == null || s2 == sym || sym.owner == s2.owner ||\n+        return (s2 == null || s2 == sym || sym.owner == s2.owner || (sym.owner.isInterface() && s2.owner == syms.objectType.tsym) ||\n@@ -1878,1 +1878,2 @@\n-        for (TypeSymbol s : superclasses(intype)) {\n+        boolean isInterface = site.tsym.isInterface();\n+        for (TypeSymbol s : isInterface ? List.of(intype.tsym) : superclasses(intype)) {\n@@ -1916,0 +1917,13 @@\n+        if (isInterface && bestSoFar.kind.isResolutionError()) {\n+            bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,\n+                    syms.objectType.tsym.members(), bestSoFar, allowBoxing, useVarargs, true);\n+            if (bestSoFar.kind.isValid()) {\n+                Symbol baseSymbol = bestSoFar;\n+                bestSoFar = new MethodSymbol(bestSoFar.flags_field, bestSoFar.name, bestSoFar.type, intype.tsym) {\n+                    @Override\n+                    public Symbol baseSymbol() {\n+                        return baseSymbol;\n+                    }\n+                };\n+            }\n+        }\n@@ -3942,0 +3956,11 @@\n+    \/** check if a type is a subtype of Serializable, if that is available.*\/\n+    boolean isSerializable(Type t) {\n+        try {\n+            syms.serializableType.complete();\n+        }\n+        catch (CompletionFailure e) {\n+            return false;\n+        }\n+        return types.isSubtype(t, syms.serializableType);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -325,7 +325,0 @@\n-    protected boolean peekToken(int lookahead, Predicate<TokenKind> tk1, Predicate<TokenKind> tk2, Predicate<TokenKind> tk3, Predicate<TokenKind> tk4) {\n-        return tk1.test(S.token(lookahead + 1).kind) &&\n-                tk2.test(S.token(lookahead + 2).kind) &&\n-                tk3.test(S.token(lookahead + 3).kind) &&\n-                tk4.test(S.token(lookahead + 4).kind);\n-    }\n-\n@@ -1832,2 +1825,2 @@\n-                    if (peekToken(lookahead, LAX_IDENTIFIER) || (peekToken(lookahead, QUES, LAX_IDENTIFIER) && (peekToken(lookahead + 2, RPAREN) || peekToken(lookahead + 2, COMMA)))) {\n-                        \/\/ Identifier[?], Identifier\/'_'\/'assert'\/'enum' -> explicit lambda\n+                    if (peekToken(lookahead, LAX_IDENTIFIER)) {\n+                        \/\/ Identifier, Identifier\/'_'\/'assert'\/'enum' -> explicit lambda\n@@ -1885,2 +1878,0 @@\n-                                peekToken(lookahead, QUES, LAX_IDENTIFIER, COMMA) ||\n-                                peekToken(lookahead, QUES, LAX_IDENTIFIER, RPAREN, ARROW) ||\n@@ -2388,1 +2379,1 @@\n-                long badModifiers = (mods.flags & Flags.PRIMITIVE_CLASS) != 0 ? mods.flags & ~(Flags.FINAL | Flags.REFERENCE_FAVORING) : mods.flags;\n+                long badModifiers = (mods.flags & Flags.PRIMITIVE_CLASS) != 0 ? mods.flags & ~Flags.FINAL : mods.flags;\n@@ -2459,1 +2450,1 @@\n-            long badModifiers = mods.flags & ~(Flags.PRIMITIVE_CLASS | Flags.FINAL | Flags.REFERENCE_FAVORING);\n+            long badModifiers = mods.flags & ~(Flags.PRIMITIVE_CLASS | Flags.FINAL);\n@@ -2468,1 +2459,1 @@\n-                badModifiers = (mods.flags & Flags.PRIMITIVE_CLASS) != 0 ? mods.flags & ~(Flags.FINAL | Flags.REFERENCE_FAVORING) : mods.flags;\n+                badModifiers = (mods.flags & Flags.PRIMITIVE_CLASS) != 0 ? mods.flags & ~Flags.FINAL : mods.flags;\n@@ -3132,0 +3123,1 @@\n+            JCCaseLabel defaultPattern = toP(F.at(pos).DefaultCaseLabel());\n@@ -3134,1 +3126,0 @@\n-            int patternPos = token.pos;\n@@ -3150,1 +3141,0 @@\n-            JCCaseLabel defaultPattern = toP(F.at(patternPos).DefaultCaseLabel());\n@@ -4035,10 +4025,0 @@\n-        if ((mods.flags & Flags.PRIMITIVE_CLASS) != 0) {\n-            if (token.kind == DOT) {\n-                final Token pastDot = S.token(1);\n-                if (pastDot.kind == IDENTIFIER && pastDot.name() == names.val) {\n-                    nextToken(); nextToken(); \/\/ discard .val\n-                    mods.flags |= Flags.REFERENCE_FAVORING;\n-                }\n-            }\n-        }\n-\n@@ -4070,9 +4050,0 @@\n-        if ((mods.flags & Flags.PRIMITIVE_CLASS) != 0) {\n-            if (token.kind == DOT) {\n-                final Token pastDot = S.token(1);\n-                if (pastDot.kind == IDENTIFIER && pastDot.name() == names.val) {\n-                    nextToken(); nextToken(); \/\/ discard .val\n-                    mods.flags |= Flags.REFERENCE_FAVORING;\n-                }\n-            }\n-        }\n@@ -4514,1 +4485,0 @@\n-             peekToken(TokenKind.IDENTIFIER, TokenKind.DOT) ||\n@@ -5157,1 +5127,1 @@\n-    protected static abstract class AbstractEndPosTable implements EndPosTable {\n+    protected abstract static class AbstractEndPosTable implements EndPosTable {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":7,"deletions":37,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    annotation type not applicable to this kind of declaration\n+    annotation interface not applicable to this kind of declaration\n@@ -365,1 +365,1 @@\n-    annotation type declaration not allowed here\n+    annotation interface declaration not allowed here\n@@ -419,1 +419,1 @@\n-    default value only allowed in an annotation type declaration\n+    default value only allowed in an annotation interface declaration\n@@ -435,1 +435,1 @@\n-    {0} is not a repeatable annotation type\n+    {0} is not a repeatable annotation interface\n@@ -455,1 +455,1 @@\n-    containing annotation type ({0}) must declare an element named ''value'' of type {2}\n+    containing annotation interface ({0}) must declare an element named ''value'' of type {2}\n@@ -459,1 +459,1 @@\n-    containing annotation type ({0}) does not have a default value for element {1}\n+    containing annotation interface ({0}) does not have a default value for element {1}\n@@ -463,1 +463,1 @@\n-    retention of containing annotation type ({0}) is shorter than the retention of repeatable annotation type ({2})\n+    retention of containing annotation interface ({0}) is shorter than the retention of repeatable annotation interface ({2})\n@@ -467,1 +467,1 @@\n-    repeatable annotation type ({1}) is @Documented while containing annotation type ({0}) is not\n+    repeatable annotation interface ({1}) is @Documented while containing annotation interface ({0}) is not\n@@ -471,1 +471,1 @@\n-    repeatable annotation type ({1}) is @Inherited while containing annotation type ({0}) is not\n+    repeatable annotation interface ({1}) is @Inherited while containing annotation interface ({0}) is not\n@@ -475,1 +475,1 @@\n-    containing annotation type ({0}) is applicable to more targets than repeatable annotation type ({1})\n+    containing annotation interface ({0}) is applicable to more targets than repeatable annotation interface ({1})\n@@ -536,1 +536,1 @@\n-    enum types may not be instantiated\n+    enum classes may not be instantiated\n@@ -545,1 +545,1 @@\n-    enum types are not extensible\n+    enum classes are not extensible\n@@ -704,1 +704,1 @@\n-    elements in annotation type declarations cannot declare formal parameters\n+    elements in annotation interface declarations cannot declare formal parameters\n@@ -708,1 +708,1 @@\n-    annotation type {0} cannot be generic\n+    annotation interface {0} cannot be generic\n@@ -711,1 +711,1 @@\n-    elements in annotation type declarations cannot be generic methods\n+    elements in annotation interface declarations cannot be generic methods\n@@ -715,1 +715,1 @@\n-    annotation type {1} declares an element with the same name as method {0}\n+    annotation interface {1} declares an element with the same name as method {0}\n@@ -724,1 +724,1 @@\n-    invalid type for annotation type element\n+    invalid type for annotation interface element\n@@ -762,1 +762,1 @@\n-    enum types must not be local\n+    enum classes must not be local\n@@ -929,1 +929,1 @@\n-    {0} is not an annotation type\n+    {0} is not an annotation interface\n@@ -1849,0 +1849,8 @@\n+compiler.warn.improper.SPF=\\\n+    serialPersistentFields must be declared private static final to be effective\n+\n+compiler.warn.SPF.null.init=\\\n+    serialPersistentFields ineffective if initialized to null.\\n\\\n+    Initialize to an empty array to indicate no fields\n+\n+\n@@ -1869,0 +1877,3 @@\n+compiler.warn.OSF.array.SPF=\\\n+    serialPersistentFields must be of type java.io.ObjectStreamField[] to be effective\n+\n@@ -1873,0 +1884,79 @@\n+# 0: name\n+compiler.warn.serializable.missing.access.no.arg.ctor=\\\n+    cannot access a no-arg constructor in first non-serializable superclass {0}\n+\n+# 0: name\n+compiler.warn.serial.method.not.private=\\\n+    serialization-related method {0} not declared private\n+\n+# 0: name\n+compiler.warn.serial.concrete.instance.method=\\\n+    serialization-related method {0} must be a concrete instance method to be effective, neither abstract nor static\n+\n+# 0: name\n+compiler.warn.serial.method.static=\\\n+    serialization-related method {0} declared static; must instead be an instance method to be effective\n+\n+# 0: name\n+compiler.warn.serial.method.no.args=\\\n+    to be effective serialization-related method {0} must have no parameters\n+\n+# 0: name, 1: number\n+compiler.warn.serial.method.one.arg=\\\n+    to be effective serialization-related method {0} must have exactly one parameter rather than {1} parameters\n+\n+# 0: name, 1: type, 2: type\n+compiler.warn.serial.method.parameter.type=\\\n+    sole parameter of serialization-related method {0} must have type {1} to be effective rather than type {2}\n+\n+# 0: name, 1: type, 2: type\n+compiler.warn.serial.method.unexpected.return.type=\\\n+    serialization-related method {0} declared with a return type of {1} rather than expected type {2}.\\n\\\n+    As declared, the method will be ineffective for serialization\n+\n+# 0: name, 1: type\n+compiler.warn.serial.method.unexpected.exception=\\\n+    serialization-related method {0} declared to throw an unexpected type {1}\n+\n+compiler.warn.ineffectual.serial.field.interface=\\\n+    serialPersistentFields is not effective in an interface\n+\n+# 0: string\n+compiler.warn.ineffectual.serial.field.enum=\\\n+     serialization-related field {0} is not effective in an enum class\n+\n+# 0: string\n+compiler.warn.ineffectual.serial.method.enum=\\\n+    serialization-related method {0} is not effective in an enum class\n+\n+compiler.warn.ineffectual.serial.field.record=\\\n+    serialPersistentFields is not effective in a record class\n+\n+# 0: string\n+compiler.warn.ineffectual.serial.method.record=\\\n+    serialization-related method {0} is not effective in a record class\n+\n+# 0: name\n+compiler.warn.ineffectual.serial.method.externalizable=\\\n+    serialization-related method {0} is not effective in an Externalizable class\n+\n+compiler.warn.ineffectual.serial.field.externalizable=\\\n+    serialPersistentFields is not effective in an Externalizable class\n+\n+compiler.warn.externalizable.missing.public.no.arg.ctor=\\\n+    an Externalizable class needs a public no-arg constructor\n+\n+compiler.warn.non.serializable.instance.field=\\\n+    non-transient instance field of a serializable class declared with a non-serializable type\n+\n+# 0: type\n+compiler.warn.non.serializable.instance.field.array=\\\n+    non-transient instance field of a serializable class declared with an array having a non-serializable base component type {0}\n+\n+compiler.warn.non.private.method.weaker.access=\\\n+    serialization-related method declared non-private in an interface will prevent\\n\\\n+    classes implementing the interface from declaring the method as private\n+\n+compiler.warn.default.ineffective=\\\n+    serialization-related default method from an interface will not be run by serialization for an implementing class\n+\n@@ -1990,1 +2080,1 @@\n-    Malformed string ''{0}'' for a supported annotation type returned by processor ''{1}''\n+    Malformed string ''{0}'' for a supported annotation interface returned by processor ''{1}''\n@@ -2006,1 +2096,1 @@\n-    Duplicate supported annotation type ''{0}'' returned by annotation processor ''{1}''\n+    Duplicate supported annotation interface ''{0}'' returned by annotation processor ''{1}''\n@@ -2010,1 +2100,1 @@\n-    Annotation processor ''{0}'' redundantly supports both ''*'' and other annotation types\n+    Annotation processor ''{0}'' redundantly supports both ''*'' and other annotation interfaces\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":112,"deletions":22,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -246,2 +246,2 @@\n-    Warn about Serializable classes that do not provide a serial version ID. \\n\\\n-\\                         Also warn about access to non-public members from a serializable element.\n+    Warn about Serializable classes that do not have a serialVersionUID field. \\n\\\n+\\                         Also warn about other suspect declarations in Serializable and Externalizable classes and interfaces.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -700,1 +700,1 @@\n-    public static abstract class JCStatement extends JCTree implements StatementTree {\n+    public abstract static class JCStatement extends JCTree implements StatementTree {\n@@ -713,1 +713,1 @@\n-    public static abstract class JCCaseLabel extends JCTree implements CaseLabelTree {\n+    public abstract static class JCCaseLabel extends JCTree implements CaseLabelTree {\n@@ -721,1 +721,1 @@\n-    public static abstract class JCExpression extends JCCaseLabel implements ExpressionTree {\n+    public abstract static class JCExpression extends JCCaseLabel implements ExpressionTree {\n@@ -750,1 +750,1 @@\n-    public static abstract class JCPolyExpression extends JCExpression {\n+    public abstract static class JCPolyExpression extends JCExpression {\n@@ -772,1 +772,1 @@\n-    public static abstract class JCFunctionalExpression extends JCPolyExpression {\n+    public abstract static class JCFunctionalExpression extends JCPolyExpression {\n@@ -2125,1 +2125,1 @@\n-    public static abstract class JCOperatorExpression extends JCExpression {\n+    public abstract static class JCOperatorExpression extends JCExpression {\n@@ -2307,1 +2307,1 @@\n-    public static abstract class JCPattern extends JCCaseLabel\n+    public abstract static class JCPattern extends JCCaseLabel\n@@ -3062,1 +3062,1 @@\n-    public static abstract class JCDirective extends JCTree\n+    public abstract static class JCDirective extends JCTree\n@@ -3475,1 +3475,1 @@\n-    public static abstract class Visitor {\n+    public abstract static class Visitor {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -860,1 +860,1 @@\n-                    JCExpression vp = Type(t.asValueType());\n+                    JCExpression vp = Type(t.valueProjection());\n@@ -871,13 +871,0 @@\n-                } else if (t.isValueProjection()) {\n-                    \/\/ For parameterized types, we want V.val<A1 ... An> not V<A1 ... An>.val\n-                    JCExpression vp = Type(t.referenceProjection());\n-                    if (vp.hasTag(Tag.TYPEAPPLY)) {\n-                        \/\/ vp now is V<A1 ... An>, build V.val<A1 ... An>\n-                        JCFieldAccess f = (JCFieldAccess) Select(((JCTypeApply) vp).clazz, t.tsym);\n-                        f.name = names.val;\n-                        tp = TypeApply(f, ((JCTypeApply) vp).arguments);\n-                    } else {\n-                        JCFieldAccess f = (JCFieldAccess) Select(vp, t.tsym);\n-                        f.name = names.val;\n-                        tp = f;\n-                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -562,3 +562,5 @@\n-                \/\/ token wasn't a terminating one.  Special case: within braces,\n-                \/\/ comma can proceed semicolon, e.g. the values list in enum\n-                if (ct.kind.isStart() && !prevTK.isOkToTerminate() && prevTK != COMMA) {\n+                \/\/ token wasn't a terminating one.  Special cases:\n+                \/\/ -within braces, comma can procede semicolon, e.g. the values list in enum\n+                \/\/ -arrow can be followed by a throw, e.g. in a switch\/switch expression\n+                if (ct.kind.isStart() && !prevTK.isOkToTerminate() && prevTK != COMMA &&\n+                    !(prevTK == ARROW && ct.kind == THROW)) {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}