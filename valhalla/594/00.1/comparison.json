{"files":[{"patch":"@@ -1891,0 +1891,12 @@\n+        \/** if this type variable is universal then it could also have a link to a pure reference\n+         *  type variable, it is important to know that a universal type variable and its\n+         *  corresponding referenceTypeVar share the same tsym. So if it is needed to double check if\n+         *  a type variable is universal or not, we need to check its type not the type of its tsym\n+         *\/\n+        public TypeVar projection = null;\n+\n+        protected boolean isReferenceProjection = false;\n+\n+        \/\/ redundant for now but helpful for debug reasons\n+        private boolean isUniversal;\n+\n@@ -1892,0 +1904,4 @@\n+            this(name, owner, lower, false);\n+        }\n+\n+        public TypeVar(Name name, Symbol owner, Type lower, boolean isUniversal) {\n@@ -1894,1 +1910,1 @@\n-            tsym = new TypeVariableSymbol(0, name, this, owner);\n+            tsym = new TypeVariableSymbol(isUniversal ? UNIVERSAL : 0, name, this, owner);\n@@ -1897,0 +1913,4 @@\n+            this.isUniversal = isUniversal;\n+            if (isUniversal && !isReferenceProjection) {\n+                referenceProjection();\n+            }\n@@ -1905,0 +1925,5 @@\n+            this(tsym, bound, lower, metadata, false);\n+        }\n+\n+        public TypeVar(TypeSymbol tsym, Type bound, Type lower,\n+                       TypeMetadata metadata, boolean isReferenceProjection) {\n@@ -1909,0 +1934,5 @@\n+            this.isReferenceProjection = isReferenceProjection;\n+            this.isUniversal = (tsym.flags_field & UNIVERSAL) != 0;\n+            if (isUniversal && !isReferenceProjection) {\n+                referenceProjection();\n+            }\n@@ -1913,1 +1943,1 @@\n-            return new TypeVar(tsym, getUpperBound(), lower, md) {\n+            return new TypeVar(tsym, getUpperBound(), lower, md, isReferenceProjection) {\n@@ -1937,1 +1967,5 @@\n-        public void setUpperBound(Type bound) { this._bound = bound; }\n+        public void setUpperBound(Type bound) {\n+            this._bound = bound;\n+            if (projection != null)\n+                projection.setUpperBound(bound);\n+        }\n@@ -1969,0 +2003,20 @@\n+\n+        @Override\n+        public TypeVar referenceProjection() {\n+            if (projection == null) {\n+                projection = new TypeVar(tsym, _bound, lower, metadata, true);\n+            }\n+            return projection;\n+        }\n+\n+        public boolean isUniversal() {\n+            return ((tsym.flags_field & UNIVERSAL) != 0);\n+        }\n+\n+        public boolean isReferenceProjection() {\n+            return isReferenceProjection;\n+        }\n+\n+        public boolean isValueProjection() {\n+            return isUniversal() && !isReferenceProjection();\n+        }\n@@ -1988,0 +2042,1 @@\n+            this.isReferenceProjection = wildcard.bound != null ? wildcard.bound.isReferenceProjection : false;\n@@ -1998,0 +2053,1 @@\n+            this.isReferenceProjection = wildcard.bound != null ? wildcard.bound.isReferenceProjection : false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":59,"deletions":3,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -97,0 +98,1 @@\n+    final boolean allowUniversalTVars;\n@@ -127,0 +129,1 @@\n+        Preview preview = Preview.instance(context);\n@@ -128,0 +131,1 @@\n+        allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -610,0 +614,9 @@\n+        if (allowUniversalTVars && ((s.hasTag(TYPEVAR)) && ((TypeVar)s).isValueProjection() &&\n+                (t.hasTag(BOT) || t.hasTag(TYPEVAR) && !((TypeVar)t).isValueProjection()))) {\n+            warn.warn(LintCategory.UNIVERSAL);\n+            return true;\n+        }\n+        if (allowUniversalTVars && (s.isPrimitiveClass() && !t.isPrimitiveClass())) {\n+            chk.warnValueConversion(warn.pos(), Warnings.PrimitiveValueConversion);\n+            return true;\n+        }\n@@ -1016,0 +1029,26 @@\n+    @FunctionalInterface\n+    public interface SubtypeTestFlavor {\n+        boolean subtypeTest(Type t, Type s, Warner warn);\n+    }\n+\n+    public boolean isBoundedBy(Type t, Type s, SubtypeTestFlavor subtypeTestFlavor) {\n+        return isBoundedBy(t, s, noWarnings, subtypeTestFlavor);\n+    }\n+\n+    \/**\n+     * Is type t bounded by s?\n+     *\/\n+    public boolean isBoundedBy(Type t, Type s, Warner warn, SubtypeTestFlavor subtypeTestFlavor) {\n+        boolean result = subtypeTestFlavor.subtypeTest(t, s, warn);\n+        if (allowUniversalTVars && !result) {\n+            if (isPrimitiveClass(t)) {\n+                return isBoundedBy(t.referenceProjection(), s, warn, subtypeTestFlavor);\n+            } else if (t.hasTag(TYPEVAR) && ((TypeVar)t).isUniversal()) {\n+                return isBoundedBy(t.getUpperBound(), s, warn, subtypeTestFlavor);\n+            } else if (s.hasTag(TYPEVAR) && ((TypeVar)s).isUniversal()) {\n+                return isBoundedBy(t, s.getLowerBound(), warn, subtypeTestFlavor);\n+            }\n+        }\n+        return result;\n+    }\n+\n@@ -1053,0 +1092,3 @@\n+            } else if (allowUniversalTVars && t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n+                warn.warn(LintCategory.UNIVERSAL);\n+                return true;\n@@ -1104,0 +1146,3 @@\n+        if (t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n+            return true;\n+        }\n@@ -1145,0 +1190,3 @@\n+                     if (allowUniversalTVars && s.hasTag(TYPEVAR) && ((TypeVar)s).isValueProjection()) {\n+                         warnStack.head.warn(LintCategory.UNIVERSAL);\n+                     }\n@@ -1641,2 +1689,4 @@\n-                        || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &&\n-                            (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));\n+                        || ((t.isExtendsBound() || isBoundedBy(wildLowerBound(t), wildLowerBound(s),\n+                                (t1, s1, w) -> isSubtypeNoCapture(t1, s1))) &&\n+                            (t.isSuperBound() || isBoundedBy(wildUpperBound(s), wildUpperBound(t),\n+                                (t1, s1, w) -> isSubtypeNoCapture(t1, s1))));\n@@ -1655,0 +1705,10 @@\n+            @Override\n+            public Boolean visitTypeVar(TypeVar t, Type s) {\n+                if (s.hasTag(TYPEVAR)) {\n+                    TypeVar other = (TypeVar)s;\n+                    if (allowUniversalTVars && t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym)\n+                        return true;\n+                }\n+                return isSameType(t, s);\n+            }\n+\n@@ -2075,1 +2135,1 @@\n-        return !isSubtype(t, relaxBound(s));\n+        return !isBoundedBy(t, relaxBound(s), (t1, s1, w) -> isSubtype(t1, s1));\n@@ -3544,1 +3604,5 @@\n-                if (t.equalsIgnoreMetadata(from.head)) {\n+                if (t.equalsIgnoreMetadata(from.head) ||\n+                    allowUniversalTVars &&\n+                    !t.isValueProjection() &&\n+                    from.head.hasTag(TYPEVAR) &&\n+                    t.equalsIgnoreMetadata(((TypeVar)from.head).referenceProjection())) {\n@@ -3696,1 +3760,5 @@\n-                return new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata());\n+                TypeVar newTV = new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata(), t.isReferenceProjection);\n+                if (t.projection != null) {\n+                    newTV.referenceProjection();\n+                }\n+                return newTV;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":73,"deletions":5,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+        allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -225,0 +226,4 @@\n+    \/** Are universal tvars allowed?\n+     *\/\n+    private final boolean allowUniversalTVars;\n+\n@@ -2663,1 +2668,2 @@\n-                if (types.isPrimitiveClass(qualifier) || superCallOnPrimitiveReceiver) {\n+                boolean qualifierIsUniversal = allowUniversalTVars && qualifier.hasTag(TYPEVAR) && ((TypeVar)qualifier).isUniversal();\n+                if (qualifier.tsym.isPrimitiveClass() || qualifierIsUniversal || superCallOnPrimitiveReceiver) {\n@@ -2671,1 +2677,8 @@\n-                                log.error(tree.pos(), Errors.PrimitiveClassDoesNotSupport(name));\n+                                if (!qualifierIsUniversal) {\n+                                    log.error(tree.pos(), Errors.PrimitiveClassDoesNotSupport(name));\n+                                } else {\n+                                    \/* probably this will be a lint warning in the future, still under discussion\n+                                     * will comment it for now\n+                                     *\/\n+                                    \/\/log.warning(tree.pos(), Warnings.MethodShouldNotBeInvokedOnUniversalTvars(name));\n+                                }\n@@ -2679,1 +2692,8 @@\n-                                log.error(tree.pos(), Errors.PrimitiveClassDoesNotSupport(name));\n+                                if (!qualifierIsUniversal) {\n+                                    log.error(tree.pos(), Errors.PrimitiveClassDoesNotSupport(name));\n+                                } else {\n+                                    \/* probably this will be a lint warning in the future, still under discussion\n+                                     * will comment it for now\n+                                     *\/\n+                                    \/\/log.warning(tree.pos(), Warnings.MethodShouldNotBeInvokedOnUniversalTvars(name));\n+                                }\n@@ -3061,1 +3081,3 @@\n-                    chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n+                    if (!allowUniversalTVars) {\n+                        chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n+                    }\n@@ -4567,0 +4589,3 @@\n+                if (allowUniversalTVars && name == names.ref && ((TypeVar)site).isUniversal()) {\n+                    return ((TypeVar)site).referenceProjection().tsym;\n+                }\n@@ -5077,3 +5102,15 @@\n-\n-        \/\/ Attribute type parameters\n-        List<Type> actuals = attribTypes(tree.arguments, env);\n+        List<Type> actuals;\n+        List<JCExpression> args = tree.arguments;\n+        if (!allowUniversalTVars || args == null || args.isEmpty()) {\n+            actuals = attribTypes(tree.arguments, env);\n+        } else {\n+            \/\/ we use argTypes2 to keep a pointer to the original list as we will use argTypes to iterate over it\n+            List<Type> argTypes, argTypes2;\n+            argTypes2 = argTypes = attribAnyTypes(args, env);\n+            for (Type t : ((ClassType) clazztype.tsym.type).typarams_field) {\n+                argTypes.head = chk.checkRefType(args.head.pos(), argTypes.head, ((TypeVar) t).isUniversal());\n+                args = args.tail;\n+                argTypes = argTypes.tail;\n+            }\n+            actuals = argTypes2;\n+        }\n@@ -5263,1 +5300,1 @@\n-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),\n+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, allowUniversalTVars),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":45,"deletions":8,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.Function;\n@@ -171,0 +172,1 @@\n+        allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -214,0 +216,4 @@\n+    \/** Are universal tvars allowed\n+     *\/\n+    private final boolean allowUniversalTVars;\n+\n@@ -279,0 +285,14 @@\n+    \/** Warn about operation with universal type variables.\n+     *  @param pos        Position to be used for error reporting.\n+     *  @param warnKey    A warning key.\n+     *\/\n+    public void warnUniversalTVar(DiagnosticPosition pos, Warning warnKey) {\n+        if (lint.isEnabled(LintCategory.UNIVERSAL))\n+            log.warning(LintCategory.UNIVERSAL, pos, warnKey);\n+    }\n+\n+    public void warnValueConversion(DiagnosticPosition pos, Warning warnKey) {\n+        if (lint.isEnabled(LintCategory.UNIVERSAL))\n+            log.warning(LintCategory.UNIVERSAL, pos, warnKey);\n+    }\n+\n@@ -617,3 +637,5 @@\n-            if (found.hasTag(CLASS)) {\n-                if (inferenceContext != infer.emptyContext)\n-                    checkParameterizationByPrimitiveClass(pos, found);\n+            if (!allowUniversalTVars) {\n+                if (found.hasTag(CLASS)) {\n+                    if (inferenceContext != infer.emptyContext)\n+                        checkParameterizationByPrimitiveClass(pos, found);\n+                }\n@@ -699,1 +721,1 @@\n-             return types.isSubtype(a, bound);\n+             return types.isBoundedBy(a, bound, (t, s, w) -> types.isSubtype(t, s));\n@@ -939,1 +961,3 @@\n-        parameterizationByPrimitiveClassChecker.visit(t, pos);\n+        if (!allowUniversalTVars) {\n+            parameterizationByPrimitiveClassChecker.visit(t, pos);\n+        }\n@@ -1136,1 +1160,1 @@\n-        if (varType.hasTag(CLASS)) {\n+        if (!allowUniversalTVars && varType.hasTag(CLASS)) {\n@@ -4213,0 +4237,3 @@\n+                case UNIVERSAL:\n+                    Check.this.warnUniversalTVar(pos(), Warnings.UniversalVariableCannotBeAssignedNull);\n+                    break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":33,"deletions":6,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -568,1 +568,1 @@\n-            : new TypeVar(tree.name, env.info.scope.owner, syms.botType);\n+            : new TypeVar(tree.name, env.info.scope.owner, syms.botType, tree.universal);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import static com.sun.tools.javac.code.TypeTag.TYPEVAR;\n@@ -214,0 +215,1 @@\n+    private final boolean allowUniversalTVars;\n@@ -340,0 +342,2 @@\n+        Preview preview = Preview.instance(context);\n+        allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -1871,1 +1875,2 @@\n-                isFinalUninitializedField(sym)));\n+                isFinalUninitializedField(sym)) ||\n+                isUninitializedFieldOfUniversalTVar(sym));\n@@ -1884,0 +1889,7 @@\n+        boolean isUninitializedFieldOfUniversalTVar(VarSymbol sym) {\n+            return allowUniversalTVars && sym.owner.kind == TYP &&\n+                    ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == 0 &&\n+                    classDef.sym.isEnclosedBy((ClassSymbol)sym.owner) &&\n+                    sym.type.hasTag(TYPEVAR) && ((Type.TypeVar)sym.type).isValueProjection());\n+        }\n+\n@@ -1994,1 +2006,5 @@\n-                    log.error(pos, errkey);\n+                    if (isUninitializedFieldOfUniversalTVar(sym)) {\n+                        log.warning(pos, Warnings.VarMightNotHaveBeenInitialized(sym));\n+                    } else {\n+                        log.error(pos, errkey);\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1056,1 +1056,2 @@\n-                    types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn) :\n+                    types.isBoundedBy(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn,\n+                                (t, s, w) -> types.isSubtypeUnchecked(t, s, w)) :\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+        this.allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -240,1 +241,1 @@\n-     boolean allowPrimitiveClasses;\n+    boolean allowPrimitiveClasses;\n@@ -246,0 +247,4 @@\n+    \/** Switch: are primitive classes allowed in this source level?\n+     *\/\n+    boolean allowUniversalTVars;\n+\n@@ -4687,0 +4692,6 @@\n+        boolean universal = false;\n+        if (allowUniversalTVars && token.kind == UNIVERSAL) {\n+            checkSourceLevel(Feature.UNIVERSAL_TVARS);\n+            universal = true;\n+            nextToken();\n+        }\n@@ -4697,1 +4708,3 @@\n-        return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));\n+        return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos, universal));\n+        \/\/ use the line below to make experiments setting all type variables as universal\n+        \/\/return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos, true));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1423,2 +1423,2 @@\n-compiler.err.var.not.initialized.in.default.constructor=\\\n-    variable {0} not initialized in the default constructor\n+compiler.warn.var.might.not.have.been.initialized=\\\n+    variable {0} might not have been initialized\n@@ -3088,0 +3088,3 @@\n+compiler.misc.feature.universal.tvars=\\\n+    universal type variables\n+\n@@ -4005,0 +4008,12 @@\n+\n+### universal type variables\n+\n+# 0: symbol\n+compiler.err.var.not.initialized.in.default.constructor=\\\n+    variable {0} not initialized in the default constructor\n+\n+compiler.warn.universal.variable.cannot.be.assigned.null=\\\n+    variables of type universal type variable cannot be assigned null\n+\n+compiler.warn.primitive.value.conversion=\\\n+    primitive value conversion\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -270,0 +270,3 @@\n+javac.opt.Xlint.desc.universal=\\\n+    Warn about potential heap pollution issues when using universal type variables.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2872,1 +2872,4 @@\n-        protected JCTypeParameter(Name name, List<JCExpression> bounds, List<JCAnnotation> annotations) {\n+        \/** is this an universal type variable?  *\/\n+        public boolean universal;\n+\n+        protected JCTypeParameter(Name name, List<JCExpression> bounds, List<JCAnnotation> annotations, boolean universal) {\n@@ -2876,0 +2879,1 @@\n+            this.universal = universal;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -587,1 +587,5 @@\n-        JCTypeParameter tree = new JCTypeParameter(name, bounds, annos);\n+        return TypeParameter(name, bounds, annos, false);\n+    }\n+\n+    public JCTypeParameter TypeParameter(Name name, List<JCExpression> bounds, List<JCAnnotation> annos, boolean universal) {\n+        JCTypeParameter tree = new JCTypeParameter(name, bounds, annos, universal);\n@@ -1064,1 +1068,1 @@\n-            TypeParameter(name, Types(types.getBounds(tvar))).setPos(pos).setType(tvar);\n+            TypeParameter(name, Types(types.getBounds(tvar)), List.nil(), tvar.isValueProjection()).setPos(pos).setType(tvar);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -233,0 +233,1 @@\n+        UNIVERSAL(TokenKind.UNIVERSAL, XDECL1 | XMODIFIER),  \/\/  __universal (Valhalla)\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}