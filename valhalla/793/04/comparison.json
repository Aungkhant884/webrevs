{"files":[{"patch":"@@ -331,4 +331,2 @@\n-        }\n-        String s;\n-        if (longform) {\n-             s =  sym.getQualifiedName().toString();\n+        } else if (longform) {\n+            return sym.getQualifiedName().toString();\n@@ -336,1 +334,1 @@\n-            s =  sym.name.toString();\n+            return sym.name.toString();\n@@ -338,2 +336,0 @@\n-\n-        return s;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1402,1 +1402,1 @@\n-\n+            else\n@@ -2189,1 +2189,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -98,0 +98,2 @@\n+    private final boolean allowPrimitiveClasses;\n+\n@@ -283,1 +285,1 @@\n-                    if (type.isPrimitiveClass()) {\n+                    if (allowPrimitiveClasses && type.isPrimitiveClass()) {\n@@ -648,3 +650,1 @@\n-        arrayClassType.interfaces_field =\n-                List.of(cloneableType, serializableType);\n-\n+        arrayClassType.interfaces_field = List.of(cloneableType, serializableType);\n@@ -668,1 +668,2 @@\n-\n+        Options options = Options.instance(context);\n+        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1299,4 +1299,2 @@\n-                }\n-                String s;\n-                if (longform) {\n-                    s =  sym.getQualifiedName().toString();\n+                } else if (longform) {\n+                    return sym.getQualifiedName().toString();\n@@ -1304,1 +1302,1 @@\n-                    s = sym.name.toString();\n+                    return sym.name.toString();\n@@ -1306,1 +1304,0 @@\n-                return s;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    final boolean allowValueBasedClasses;\n+    final boolean allowPrimitiveClasses;\n@@ -123,1 +123,1 @@\n-        allowValueBasedClasses = options.isSet(\"allowValueBasedClasses\");\n+        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -604,6 +604,8 @@\n-        boolean tValue = t.isPrimitiveClass();\n-        boolean sValue = s.isPrimitiveClass();\n-        if (tValue != sValue) {\n-            return tValue ?\n-                    isSubtype(t.referenceProjection(), s) :\n-                    !t.hasTag(BOT) && isSubtype(t, s.referenceProjection());\n+        if (allowPrimitiveClasses) {\n+            boolean tValue = t.isPrimitiveClass();\n+            boolean sValue = s.isPrimitiveClass();\n+            if (tValue != sValue) {\n+                return tValue ?\n+                        isSubtype(t.referenceProjection(), s) :\n+                        !t.hasTag(BOT) && isSubtype(t, s.referenceProjection());\n+            }\n@@ -1052,4 +1054,6 @@\n-                    if (et.isPrimitiveClass()) {\n-                        et = et.referenceProjection();\n-                        if (es.isPrimitiveClass())\n-                            es = es.referenceProjection();  \/\/ V <: V, surely\n+                    if (allowPrimitiveClasses) {\n+                        if (et.isPrimitiveClass()) {\n+                            et = et.referenceProjection();\n+                            if (es.isPrimitiveClass())\n+                                es = es.referenceProjection();  \/\/ V <: V, surely\n+                        }\n@@ -1156,1 +1160,1 @@\n-                         s.hasTag(BOT) || (s.hasTag(CLASS) && !s.isPrimitiveClass()) ||\n+                         s.hasTag(BOT) || (s.hasTag(CLASS) && (!allowPrimitiveClasses || !s.isPrimitiveClass())) ||\n@@ -1239,1 +1243,1 @@\n-                        if (et.isPrimitiveClass()) {\n+                        if (allowPrimitiveClasses && et.isPrimitiveClass()) {\n@@ -1792,1 +1796,1 @@\n-                if (s.hasTag(ERROR) || (s.hasTag(BOT) && !t.isPrimitiveClass()))\n+                if (s.hasTag(ERROR) || (s.hasTag(BOT) && (!allowPrimitiveClasses || !t.isPrimitiveClass())))\n@@ -1811,7 +1815,9 @@\n-                    if (t.isPrimitiveClass()) {\n-                        \/\/ (s) Value ? == (s) Value.ref\n-                        t = t.referenceProjection();\n-                    }\n-                    if (s.isPrimitiveClass()) {\n-                        \/\/ (Value) t ? == (Value.ref) t\n-                        s = s.referenceProjection();\n+                    if (allowPrimitiveClasses) {\n+                        if (t.isPrimitiveClass()) {\n+                            \/\/ (s) Value ? == (s) Value.ref\n+                            t = t.referenceProjection();\n+                        }\n+                        if (s.isPrimitiveClass()) {\n+                            \/\/ (Value) t ? == (Value.ref) t\n+                            s = s.referenceProjection();\n+                        }\n@@ -1924,5 +1930,1 @@\n-                        Type et = elemtype(t);\n-                        Type es = elemtype(s);\n-                        if (!visit(et, es))\n-                            return false;\n-                        return true;\n+                        return visit(elemtype(t), elemtype(s));\n@@ -2258,1 +2260,1 @@\n-        if (t.isPrimitiveClass()) {\n+        if (allowPrimitiveClasses && t.isPrimitiveClass()) {\n@@ -2401,1 +2403,1 @@\n-        if (t.isPrimitiveClass())\n+        if (allowPrimitiveClasses && t.isPrimitiveClass())\n@@ -2625,1 +2627,0 @@\n-        long flags = ABSTRACT | PUBLIC | SYNTHETIC | COMPOUND | ACYCLIC;\n@@ -2627,1 +2628,1 @@\n-            new ClassSymbol(flags,\n+            new ClassSymbol(ABSTRACT|PUBLIC|SYNTHETIC|COMPOUND|ACYCLIC,\n@@ -4090,0 +4091,1 @@\n+\n@@ -5251,1 +5253,1 @@\n-                    if (type.isPrimitiveClass())\n+                    if (types.allowPrimitiveClasses && type.isPrimitiveClass())\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":34,"deletions":32,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2171,1 +2171,1 @@\n-                                 .map(t -> chk.checkNonVoid(posIt.next(), t.isPrimitiveClass() ? t.referenceProjection() : t))\n+                                 .map(t -> chk.checkNonVoid(posIt.next(), allowPrimitiveClasses && t.isPrimitiveClass() ? t.referenceProjection() : t))\n@@ -2615,1 +2615,1 @@\n-                Type wcb = types.erasure(qualifierType.isPrimitiveClass() ?\n+                Type wcb = types.erasure(allowPrimitiveClasses && qualifierType.isPrimitiveClass() ?\n@@ -2793,5 +2793,7 @@\n-            if (clazz.hasTag(SELECT)) {\n-                JCFieldAccess fieldAccess = (JCFieldAccess) clazz;\n-                if (fieldAccess.selected.type.isPrimitiveClass() &&\n-                        (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n-                    log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);\n+            if (allowPrimitiveClasses) {\n+                if (clazz.hasTag(SELECT)) {\n+                    JCFieldAccess fieldAccess = (JCFieldAccess) clazz;\n+                    if (fieldAccess.selected.type.isPrimitiveClass() &&\n+                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n+                        log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);\n+                    }\n@@ -2979,1 +2981,3 @@\n-                    chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n+                    if (allowPrimitiveClasses) {\n+                        chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n+                    }\n@@ -3053,1 +3057,1 @@\n-        if (arg.type.isPrimitiveClass())\n+        if (allowPrimitiveClasses && arg.type.isPrimitiveClass())\n@@ -4075,1 +4079,0 @@\n-                chk.checkForSuspectClassLiteralComparison(tree, left, right);\n@@ -4388,1 +4391,1 @@\n-        if (tree.name == names._class && site.isPrimitiveClass()) {\n+        if (allowPrimitiveClasses && tree.name == names._class && site.isPrimitiveClass()) {\n@@ -4417,1 +4420,0 @@\n-\n@@ -4557,1 +4559,1 @@\n-                } else if (site.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n+                } else if (allowPrimitiveClasses && site.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n@@ -4665,1 +4667,3 @@\n-                    Assert.check(owntype.getFlavor() != Flavor.X_Typeof_X);\n+                    if (allowPrimitiveClasses) {\n+                        Assert.check(owntype.getFlavor() != Flavor.X_Typeof_X);\n+                    }\n@@ -4672,1 +4676,1 @@\n-                    if (owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n+                    if (allowPrimitiveClasses && owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n@@ -5030,2 +5034,4 @@\n-\n-        Symbol sym = switch (site.getTag()) {\n+        if (!allowPrimitiveClasses) {\n+            result = types.createErrorType(names._default, site.tsym, site);\n+        } else {\n+            Symbol sym = switch (site.getTag()) {\n@@ -5040,1 +5046,1 @@\n-        };\n+            };\n@@ -5042,2 +5048,4 @@\n-        if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n-            site = types.skipTypeVars(site, true);\n+            if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n+                site = types.skipTypeVars(site, true);\n+            }\n+            result = checkId(tree, site, sym, env, resultInfo);\n@@ -5045,1 +5053,0 @@\n-        result = checkId(tree, site, sym, env, resultInfo);\n@@ -5382,1 +5389,1 @@\n-            if (c.type.isPrimitiveClass()) {\n+            if (allowPrimitiveClasses && c.type.isPrimitiveClass()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":29,"deletions":22,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+\n@@ -171,0 +172,1 @@\n+        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -214,0 +216,4 @@\n+    \/** Are primitive classes allowed\n+     *\/\n+    private final boolean allowPrimitiveClasses;\n+\n@@ -510,1 +516,1 @@\n-    \/* *************************************************************************\n+\/* *************************************************************************\n@@ -617,1 +623,1 @@\n-            if (found.hasTag(CLASS)) {\n+            if (allowPrimitiveClasses && found.hasTag(CLASS)) {\n@@ -817,1 +823,1 @@\n-                    if (fieldAccess.selected.type.isPrimitiveClass() &&\n+                    if (allowPrimitiveClasses && fieldAccess.selected.type.isPrimitiveClass() &&\n@@ -861,1 +867,1 @@\n-        if (t.isReference() && (primitiveClassOK || !t.isPrimitiveClass()))\n+        if (t.isReference() && (!allowPrimitiveClasses || primitiveClassOK || !t.isPrimitiveClass()))\n@@ -962,1 +968,1 @@\n-                if (targ.isPrimitiveClass()) {\n+                if (allowPrimitiveClasses && targ.isPrimitiveClass()) {\n@@ -1142,1 +1148,1 @@\n-        if (varType.hasTag(CLASS)) {\n+        if (allowPrimitiveClasses && varType.hasTag(CLASS)) {\n@@ -1148,33 +1154,0 @@\n-    public void checkForSuspectClassLiteralComparison(\n-            final JCBinary tree,\n-            final Type leftType,\n-            final Type rightType) {\n-\n-        if (lint.isEnabled(LintCategory.MIGRATION)) {\n-            if (isInvocationOfGetClass(tree.lhs) && isClassOfSomeInterface(rightType) ||\n-                    isInvocationOfGetClass(tree.rhs) && isClassOfSomeInterface(leftType)) {\n-                log.warning(LintCategory.MIGRATION, tree.pos(), Warnings.GetClassComparedWithInterface);\n-            }\n-        }\n-    }\n-    \/\/where\n-    private boolean isClassOfSomeInterface(Type someClass) {\n-        if (someClass.tsym.flatName() == names.java_lang_Class) {\n-            List<Type> arguments = someClass.getTypeArguments();\n-            if (arguments.length() == 1) {\n-                return arguments.head.isInterface();\n-            }\n-        }\n-        return false;\n-    }\n-    \/\/where\n-    private boolean isInvocationOfGetClass(JCExpression tree) {\n-        tree = TreeInfo.skipParens(tree);\n-        if (tree.hasTag(APPLY)) {\n-            JCMethodInvocation apply = (JCMethodInvocation)tree;\n-            MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(apply.meth);\n-            return msym.name == names.getClass && msym.implementedIn(syms.objectType.tsym, types) != null;\n-        }\n-        return false;\n-    }\n-\n@@ -2512,8 +2485,10 @@\n-        Assert.check((tree.sym.flags_field & LOCKED) == 0);\n-        try {\n-            tree.sym.flags_field |= LOCKED;\n-            for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                if (l.head.hasTag(VARDEF)) {\n-                    JCVariableDecl field = (JCVariableDecl) l.head;\n-                    if (cyclePossible(field.sym)) {\n-                        checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n+        if (allowPrimitiveClasses) {\n+            Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+            try {\n+                tree.sym.flags_field |= LOCKED;\n+                for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl field = (JCVariableDecl) l.head;\n+                        if (cyclePossible(field.sym)) {\n+                            checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n+                        }\n@@ -2522,0 +2497,2 @@\n+            } finally {\n+                tree.sym.flags_field &= ~LOCKED;\n@@ -2523,2 +2500,0 @@\n-        } finally {\n-            tree.sym.flags_field &= ~LOCKED;\n@@ -2526,1 +2501,0 @@\n-\n@@ -2545,1 +2519,1 @@\n-            return (symbol.flags() & STATIC) == 0 && symbol.type.isPrimitiveClass();\n+            return (symbol.flags() & STATIC) == 0 && allowPrimitiveClasses && symbol.type.isPrimitiveClass();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":25,"deletions":51,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+    boolean allowPrimitiveClasses;\n@@ -147,0 +148,2 @@\n+        Source source = Source.instance(context);\n+        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -505,1 +508,3 @@\n-        ct.flavor = ct.flavor.metamorphose((c.flags_field & PRIMITIVE_CLASS) != 0);\n+        if (allowPrimitiveClasses) {\n+            ct.flavor = ct.flavor.metamorphose((c.flags_field & PRIMITIVE_CLASS) != 0);\n+        }\n@@ -525,1 +530,1 @@\n-        if (ct.isPrimitiveClass()) {\n+        if (allowPrimitiveClasses && ct.isPrimitiveClass()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+    private final boolean allowPrimitiveClasses;\n@@ -127,0 +128,2 @@\n+        Source source = Source.instance(context);\n+        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -1144,1 +1147,1 @@\n-                boolean requireReferenceProjection =\n+                boolean requireReferenceProjection = allowPrimitiveClasses &&\n@@ -1475,1 +1478,0 @@\n-            final Type type = v.erasure(types);\n@@ -1477,1 +1479,1 @@\n-                flags, proxyName, type, owner);\n+                flags, proxyName, v.erasure(types), owner);\n@@ -1544,3 +1546,1 @@\n-        Type target = types.erasure(owner.enclClass().type.getEnclosingType());\n-        long flags = FINAL | SYNTHETIC;\n-        VarSymbol outerThis = makeOuterThisVarSymbol(owner, flags);\n+        VarSymbol outerThis = makeOuterThisVarSymbol(owner, FINAL | SYNTHETIC);\n@@ -3144,1 +3144,0 @@\n-\n@@ -3147,2 +3146,0 @@\n-\n-\n@@ -4150,1 +4147,1 @@\n-        if (needPrimaryMirror && tree.selected.type.isPrimitiveClass()) {\n+        if (needPrimaryMirror && allowPrimitiveClasses && tree.selected.type.isPrimitiveClass()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+    final boolean allowPrimitiveClasses;\n@@ -144,0 +145,1 @@\n+        Target target = Target.instance(context);\n@@ -151,0 +153,1 @@\n+        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -419,11 +422,13 @@\n-        if (sym.kind == MTH || sym.kind == VAR) {\n-            \/* If any primitive class types are involved, ask the same question in the reference universe,\n-               where the hierarchy is navigable\n-            *\/\n-            if (site.isPrimitiveClass())\n-                site = site.referenceProjection();\n-        } else if (sym.kind == TYP) {\n-            \/\/ A type is accessible in a reference projection if it was\n-            \/\/ accessible in the value projection.\n-            if (site.isReferenceProjection())\n-                site = site.valueProjection();\n+        if (allowPrimitiveClasses) {\n+            if (sym.kind == MTH || sym.kind == VAR) {\n+                \/* If any primitive class types are involved, ask the same question in the reference universe,\n+                   where the hierarchy is navigable\n+                *\/\n+                if (site.isPrimitiveClass())\n+                    site = site.referenceProjection();\n+            } else if (sym.kind == TYP) {\n+                \/\/ A type is accessible in a reference projection if it was\n+                \/\/ accessible in the value projection.\n+                if (site.isReferenceProjection())\n+                    site = site.valueProjection();\n+            }\n@@ -488,1 +493,1 @@\n-        if (site.isPrimitiveClass())\n+        if (allowPrimitiveClasses && site.isPrimitiveClass()) {\n@@ -490,0 +495,1 @@\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -821,1 +821,1 @@\n-                    if (sym.isInitOrVNew()  && sym.type.getParameterTypes().size() == 0) {\n+                    if (sym.isInitOrVNew() && sym.type.getParameterTypes().size() == 0) {\n@@ -823,1 +823,1 @@\n-                        if ((code_length == 1 && buf.getByte( bp + 8) == (byte) ByteCodes.return_) ||\n+                        if ((code_length == 1 && buf.getByte(bp + 8) == (byte) ByteCodes.return_) ||\n@@ -825,2 +825,2 @@\n-                                    buf.getByte( bp + 9) == (byte) ByteCodes.invokespecial &&\n-                                            buf.getByte( bp + 12) == (byte) ByteCodes.return_)) {\n+                                    buf.getByte(bp + 9) == (byte) ByteCodes.invokespecial &&\n+                                            buf.getByte(bp + 12) == (byte) ByteCodes.return_)) {\n@@ -1011,1 +1011,1 @@\n-                        if (sym.kind == MTH  && sym.name == names.vnew && !sym.type.getReturnType().hasTag(TypeTag.VOID)) {\n+                        if (sym.kind == MTH && sym.name == names.vnew && !sym.type.getReturnType().hasTag(TypeTag.VOID)) {\n@@ -2326,1 +2326,1 @@\n-            ((name == names.init || name ==names.vnew) && !t.getReturnType().hasTag(TypeTag.VOID))) {\n+            ((name == names.init || name == names.vnew) && !t.getReturnType().hasTag(TypeTag.VOID))) {\n@@ -2548,1 +2548,1 @@\n-            if ((flags & (FINAL | PRIMITIVE_CLASS | IDENTITY_TYPE)) != (FINAL | PRIMITIVE_CLASS)) {\n+            if (!allowPrimitiveClasses || (flags & (FINAL | PRIMITIVE_CLASS | IDENTITY_TYPE)) != (FINAL | PRIMITIVE_CLASS)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -113,0 +113,2 @@\n+    private boolean allowPrimitiveClasses;\n+\n@@ -197,0 +199,2 @@\n+        Source source = Source.instance(context);\n+        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -221,0 +225,1 @@\n+\n@@ -1259,1 +1264,1 @@\n-                databuf.appendChar(t.isPrimitiveClass() ? poolWriter.putClass(new ConstantPoolQType(types.erasure(t), types)) : poolWriter.putClass(types.erasure(t)));\n+                databuf.appendChar(allowPrimitiveClasses && t.isPrimitiveClass() ? poolWriter.putClass(new ConstantPoolQType(types.erasure(t), types)) : poolWriter.putClass(types.erasure(t)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+    private boolean allowPrimitiveClasses;\n@@ -198,1 +199,2 @@\n-                PoolWriter poolWriter) {\n+                PoolWriter poolWriter,\n+                boolean allowPrimitiveClasses) {\n@@ -220,0 +222,1 @@\n+        this.allowPrimitiveClasses = allowPrimitiveClasses;\n@@ -1783,2 +1786,6 @@\n-                Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)) ||\n-                        (old.isPrimitiveClass() != t.isPrimitiveClass() && types.isConvertible(types.erasure(old), types.erasure(t))));\n+                if (!allowPrimitiveClasses) {\n+                    Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)));\n+                } else {\n+                    Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)) ||\n+                            (old.isPrimitiveClass() != t.isPrimitiveClass() && types.isConvertible(types.erasure(old), types.erasure(t))));\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -137,0 +137,2 @@\n+        Source source = Source.instance(context);\n+        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -184,0 +186,2 @@\n+    boolean allowPrimitiveClasses;\n+\n@@ -1064,1 +1068,2 @@\n-                                        poolWriter);\n+                                        poolWriter,\n+                                        allowPrimitiveClasses);\n@@ -2029,1 +2034,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -534,1 +534,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3929,3 +3929,0 @@\n-compiler.warn.get.class.compared.with.interface=\\\n-    return value of getClass() can never equal the class literal of an interface\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -732,0 +732,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -391,3 +391,2 @@\n-            String s;\n-            if (longform)\n-                s =  nameSimplifier.simplify(sym).toString();\n+            else if (longform)\n+                return nameSimplifier.simplify(sym).toString();\n@@ -395,3 +394,1 @@\n-                s = sym.name.toString();\n-\n-            return s;\n+                return sym.name.toString();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.warn.get.class.compared.with.interface\n-\/\/ options: -Xlint:migration\n-\n-class CheckGetClassComparedWithInterfaceLiteral {\n-    boolean checkObject(Object o) {\n-        return o.getClass() == Iterable.class;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CheckGetClassComparedWithInterfaceLiteral.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237074\n- * @summary Result of .getClass() should never be compared to an interface class literal\n- *\n- * @compile\/ref=CheckInterfaceComparison.out -XDrawDiagnostics -Xlint:migration CheckInterfaceComparison.java\n- *\/\n-public class CheckInterfaceComparison {\n-    public boolean bogusCompareLeft(Object o) { \/\/ Should be warned against\n-        return (o.getClass()) == Runnable.class;\n-    }\n-\n-    public boolean bogusCompareNELeft(Object o) { \/\/ Should be warned against\n-        return (o.getClass()) != Runnable.class;\n-    }\n-\n-    public boolean bogusCompareRight(Object o) { \/\/ Should be warned against\n-        return Iterable.class == o.getClass();\n-    }\n-\n-    public boolean bogusCompareNERight(Object o) { \/\/ Should be warned against\n-        return Iterable.class != o.getClass();\n-    }\n-\n-    public boolean goodCompareLeft(Object o) { \/\/ Is fine, no warning required\n-        return o.getClass() == Integer.class;\n-    }\n-\n-    public boolean goodCompareNELeft(Object o) { \/\/ Is fine, no warning required\n-        return o.getClass() != Integer.class;\n-    }\n-\n-    public boolean goodCompareRight(Object o) { \/\/ Is fine, no warning required\n-        return Long.class == o.getClass();\n-    }\n-\n-    public boolean goodCompareNERight(Object o) { \/\/ Is fine, no warning required\n-        return Long.class != o.getClass();\n-    }\n-\n-    public boolean rawCompareLeft(Object o, Class<?> clazz) { \/\/ Is fine, no warning required\n-        return o.getClass() == clazz;\n-    }\n-\n-    public boolean rawCompareNELeft(Object o, Class<?> clazz) { \/\/ Is fine, no warning required\n-        return o.getClass() != clazz;\n-    }\n-\n-    public boolean rawCompareRight(Object o, Class<?> clazz) { \/\/ Is fine, no warning required\n-        return clazz == o.getClass();\n-    }\n-\n-    public boolean rawCompareNERight(Object o, Class<?> clazz) { \/\/ Is fine, no warning required\n-        return clazz != o.getClass();\n-    }\n-\n-    static Class<?> getClass(int x) {\n-        return null;\n-    }\n-\n-    public static boolean compare(Object o, Class<?> clazz) {\n-        return getClass(0) == Runnable.class; \/\/ No warning required for static getClass\n-    }\n-\n-    public Class<?> getClass(String x) {\n-        return null;\n-    }\n-\n-    public boolean compare(Object o, String arg, Class<?> clazz) {\n-        return getClass(arg) == Runnable.class; \/\/ No warning required for non-object.getClass()\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckInterfaceComparison.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-CheckInterfaceComparison.java:10:31: compiler.warn.get.class.compared.with.interface\n-CheckInterfaceComparison.java:14:31: compiler.warn.get.class.compared.with.interface\n-CheckInterfaceComparison.java:18:31: compiler.warn.get.class.compared.with.interface\n-CheckInterfaceComparison.java:22:31: compiler.warn.get.class.compared.with.interface\n-4 warnings\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckInterfaceComparison.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"}]}