{"files":[{"patch":"@@ -19,0 +19,4 @@\n+concurrency:\n+  group: ${{ github.workflow }}-${{ github.ref }}\n+  cancel-in-progress: true\n+\n@@ -26,0 +30,1 @@\n+      jdk_version: ${{ steps.check_jdk_versions.outputs.jdk_version }}\n@@ -73,0 +78,17 @@\n+      - name: Determine full JDK versions\n+        id: check_jdk_versions\n+        shell: bash\n+        run: |\n+          FEATURE=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\n+          INTERIM=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_INTERIM }}\n+          UPDATE=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\n+          if [ \"x${UPDATE}\" != \"x0\" ]; then\n+             V=${FEATURE}.${INTERIM}.${UPDATE}\n+          elif [ \"x${INTERIM}\" != \"x0\" ]; then\n+             V={FEATURE}.${INTERIM}\n+          else\n+             V=${FEATURE}\n+          fi\n+          echo \"::set-output name=jdk_version::${V}\"\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n@@ -128,1 +150,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -190,1 +212,0 @@\n-          --with-version-build=0\n@@ -208,2 +229,2 @@\n-            jdk\/build\/linux-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/linux-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/linux-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/linux-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}.tar.gz\n@@ -257,1 +278,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -315,2 +336,2 @@\n-          mkdir -p \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }}\"\n@@ -320,2 +341,2 @@\n-          mkdir -p \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}\"\n@@ -325,1 +346,1 @@\n-          imageroot=`find ${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }} -name release -type f`\n+          imageroot=`find ${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }} -name release -type f`\n@@ -331,1 +352,1 @@\n-          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}\n+          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}\n@@ -439,1 +460,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -484,2 +505,2 @@\n-          mkdir -p \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin\"\n-          tar -xf \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin.tar.gz\" -C \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin\"\n+          mkdir -p \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin\"\n+          tar -xf \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin.tar.gz\" -C \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin\"\n@@ -489,1 +510,1 @@\n-          build_jdk_root=`find ${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin -name release -type f`\n+          build_jdk_root=`find ${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin -name release -type f`\n@@ -557,1 +578,0 @@\n-          --with-version-build=0\n@@ -587,1 +607,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -656,1 +676,0 @@\n-          --with-version-build=0\n@@ -674,2 +693,2 @@\n-            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\n@@ -724,1 +743,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -782,2 +801,2 @@\n-          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }}\"\n@@ -787,2 +806,2 @@\n-          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}\"\n@@ -792,1 +811,1 @@\n-          imageroot=`find ${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }} -name release -type f`\n+          imageroot=`find ${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }} -name release -type f`\n@@ -798,1 +817,1 @@\n-          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}\n+          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}\n@@ -875,1 +894,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -934,1 +953,0 @@\n-          --with-version-build=0\n@@ -964,1 +982,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1046,1 +1064,0 @@\n-          --with-version-build=0\n@@ -1066,3 +1083,3 @@\n-            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}.zip\n-            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}-symbols.tar.gz\n+            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}.zip\n+            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}-symbols.tar.gz\n@@ -1116,1 +1133,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1188,2 +1205,2 @@\n-          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}.zip\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}.zip\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}\"\n@@ -1193,2 +1210,2 @@\n-          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}-symbols\"\n-          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}-symbols.tar.gz\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}-symbols\"\n+          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}-symbols\"\n+          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}-symbols.tar.gz\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}-symbols\"\n@@ -1198,2 +1215,2 @@\n-          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}\"\n@@ -1202,1 +1219,1 @@\n-        run: echo (\"imageroot=\" + (Get-ChildItem -Path $HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }} -Filter release -Recurse -ErrorAction SilentlyContinue -Force).DirectoryName) | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8\n+        run: echo (\"imageroot=\" + (Get-ChildItem -Path $HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }} -Filter release -Recurse -ErrorAction SilentlyContinue -Force).DirectoryName) | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8\n@@ -1210,1 +1227,1 @@\n-          $env:TEST_IMAGE_DIR = cygpath \"$HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}\" ;\n+          $env:TEST_IMAGE_DIR = cygpath \"$HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}\" ;\n@@ -1291,1 +1308,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1353,1 +1370,0 @@\n-          --with-version-build=0\n@@ -1371,2 +1387,2 @@\n-            jdk\/build\/macos-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/macos-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/macos-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/macos-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}.tar.gz\n@@ -1393,1 +1409,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1456,1 +1472,0 @@\n-          --with-version-build=0\n@@ -1474,2 +1489,2 @@\n-            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-aarch64_bin${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-aarch64_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_macos-aarch64_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_macos-aarch64_bin-tests${{ matrix.artifact }}.tar.gz\n@@ -1524,1 +1539,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1582,2 +1597,2 @@\n-          mkdir -p \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }}\"\n@@ -1587,2 +1602,2 @@\n-          mkdir -p \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin-tests${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin-tests${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}\"\n@@ -1598,1 +1613,1 @@\n-          imageroot=`find ${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin${{ matrix.artifact }} -name release -type f`\n+          imageroot=`find ${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }} -name release -type f`\n@@ -1604,1 +1619,1 @@\n-          TEST_IMAGE_DIR=${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin-tests${{ matrix.artifact }}\n+          TEST_IMAGE_DIR=${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}\n","filename":".github\/workflows\/submit.yml","additions":73,"deletions":58,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-  ifeq ($(VERSION_BUILD), 0)\n+  ifeq ($(VERSION_BUILD), )\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,1 @@\n+\n@@ -121,1 +122,3 @@\n-  [timestamp to use in hotspot version string, empty for on-the-fly @<:@empty@:>@])])\n+  [timestamp to use in hotspot version string, empty means determined at build time @<:@source-date\/empty@:>@])])\n+\n+  AC_MSG_CHECKING([what hotspot build time to use])\n@@ -125,0 +128,10 @@\n+    AC_MSG_RESULT([$HOTSPOT_BUILD_TIME (from --with-hotspot-build-time)])\n+  else\n+    if test \"x$SOURCE_DATE\" = xupdated; then\n+      HOTSPOT_BUILD_TIME=\"\"\n+      AC_MSG_RESULT([determined at build time (default)])\n+    else\n+      # If we have a fixed value for SOURCE_DATE, use it as default\n+      HOTSPOT_BUILD_TIME=\"$SOURCE_DATE_ISO_8601\"\n+      AC_MSG_RESULT([$HOTSPOT_BUILD_TIME (from --with-source-date)])\n+    fi\n@@ -126,0 +139,1 @@\n+\n","filename":"make\/autoconf\/hotspot.m4","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,1 +261,0 @@\n-            \"--with-source-date=current\",\n@@ -1056,1 +1055,1 @@\n-        linux_x64: \"gcc10.3.0-OL6.4+1.0\",\n+        linux_x64: \"gcc11.2.0-OL6.4+1.0\",\n@@ -1059,1 +1058,1 @@\n-        linux_aarch64: \"gcc10.3.0-OL7.6+1.0\",\n+        linux_aarch64: \"gcc11.2.0-OL7.6+1.0\",\n@@ -1427,1 +1426,4 @@\n-    var args = [\"--with-version-build=\" + common.build_number];\n+    var args = [];\n+    if (common.build_number != 0) {\n+        args = concat(args, \"--with-version-build=\" + common.build_number);\n+    }\n@@ -1448,0 +1450,8 @@\n+    var sourceDate\n+    if (input.build_id_data && input.build_id_data.creationTime) {\n+        sourceDate = Math.floor(Date.parse(input.build_id_data.creationTime)\/1000);\n+    } else {\n+        sourceDate = \"current\";\n+    }\n+    args = concat(args, \"--with-source-date=\" + sourceDate);\n+\n","filename":"make\/conf\/jib-profiles.js","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,1 +159,1 @@\n- *  * cd <open-jdk-checkout>\/make\/data\/symbols\n+ *  * cd <open-jdk-checkout>\/src\/jdk.compiler\/share\/data\/symbols\n@@ -167,1 +167,1 @@\n- *  * sanity-check the new and updates files in make\/data\/symbols and commit them\n+ *  * sanity-check the new and updates files in src\/jdk.compiler\/share\/data\/symbols and commit them\n@@ -215,1 +215,2 @@\n- *     java build.tools.symbolgenerator.CreateSymbols build-description make\/data\/symbols $TOPDIR make\/data\/symbols\/include.list\n+ *     java build.tools.symbolgenerator.CreateSymbols build-description src\/jdk.compiler\/share\/data\/symbols\n+ *          $TOPDIR src\/jdk.compiler\/share\/data\/symbols\/include.list\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-VARHANDLES_SRC_DIR := $(TOPDIR)\/src\/java.base\/share\/classes\/java\/lang\/invoke\n+VARHANDLES_SRC_DIR := $(MODULE_SRC)\/share\/classes\/java\/lang\/invoke\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1202,3 +1202,0 @@\n-reg_class p0_reg(P0);\n-reg_class p1_reg(P1);\n-\n@@ -1317,0 +1314,3 @@\n+  \/\/ Assert that the given node is not a variable shift.\n+  bool assert_not_var_shift(const Node* n);\n+\n@@ -1731,0 +1731,6 @@\n+\/\/ Assert that the given node is not a variable shift.\n+bool assert_not_var_shift(const Node* n) {\n+  assert(!n->as_ShiftV()->is_var_shift(), \"illegal variable shift\");\n+  return true;\n+}\n+\n@@ -1862,0 +1868,4 @@\n+  if (VM_Version::use_rop_protection()) {\n+    st->print(\"ldr zr, [lr]\\n\\t\");\n+    st->print(\"pacia  lr, rfp\\n\\t\");\n+  }\n@@ -1958,0 +1968,4 @@\n+  if (VM_Version::use_rop_protection()) {\n+    st->print(\"autia lr, rfp\\n\\t\");\n+    st->print(\"ldr zr, [lr]\\n\\t\");\n+  }\n@@ -3223,0 +3237,5 @@\n+  enc_class aarch64_enc_stlrb0(memory mem) %{\n+    MOV_VOLATILE(zr, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,\n+                 rscratch1, stlrb);\n+  %}\n+\n@@ -3228,0 +3247,5 @@\n+  enc_class aarch64_enc_stlrh0(memory mem) %{\n+    MOV_VOLATILE(zr, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,\n+                 rscratch1, stlrh);\n+  %}\n+\n@@ -3233,0 +3257,4 @@\n+  enc_class aarch64_enc_stlrw0(memory mem) %{\n+    MOV_VOLATILE(zr, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,\n+                 rscratch1, stlrw);\n+  %}\n@@ -3323,0 +3351,5 @@\n+  enc_class aarch64_enc_stlr0(memory mem) %{\n+    MOV_VOLATILE(zr, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,\n+                 rscratch1, stlr);\n+  %}\n+\n@@ -5722,18 +5755,0 @@\n-operand pRegGov_P0()\n-%{\n-  constraint(ALLOC_IN_RC(p0_reg));\n-  match(RegVectMask);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand pRegGov_P1()\n-%{\n-  constraint(ALLOC_IN_RC(p1_reg));\n-  match(RegVectMask);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -8331,0 +8346,12 @@\n+instruct storeimmB0_volatile(immI0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreB mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrb  zr, $mem\\t# byte\" %}\n+\n+  ins_encode(aarch64_enc_stlrb0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8344,0 +8371,12 @@\n+instruct storeimmC0_volatile(immI0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreC mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrh  zr, $mem\\t# short\" %}\n+\n+  ins_encode(aarch64_enc_stlrh0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8358,0 +8397,12 @@\n+instruct storeimmI0_volatile(immI0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem(StoreI mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrw  zr, $mem\\t# int\" %}\n+\n+  ins_encode(aarch64_enc_stlrw0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8371,0 +8422,12 @@\n+instruct storeimmL0_volatile(immL0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreL mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlr  zr, $mem\\t# int\" %}\n+\n+  ins_encode(aarch64_enc_stlr0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8384,0 +8447,12 @@\n+instruct storeimmP0_volatile(immP0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreP mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlr  zr, $mem\\t# ptr\" %}\n+\n+  ins_encode(aarch64_enc_stlr0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8397,0 +8472,12 @@\n+instruct storeimmN0_volatile(immN0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreN mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrw  zr, $mem\\t# compressed ptr\" %}\n+\n+  ins_encode(aarch64_enc_stlrw0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -16770,1 +16857,1 @@\n-  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n+  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -16780,1 +16867,1 @@\n-                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::UU);\n+                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::UU);\n@@ -16788,1 +16875,1 @@\n-  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n+  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -16797,1 +16884,1 @@\n-                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::LL);\n+                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::LL);\n@@ -16806,1 +16893,1 @@\n-  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n+  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n@@ -16817,1 +16904,1 @@\n-                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::UL);\n+                      $vtmp3$$FloatRegister, StrIntrinsicNode::UL);\n@@ -16826,1 +16913,1 @@\n-  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n+  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n@@ -16837,1 +16924,1 @@\n-                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::LU);\n+                      $vtmp3$$FloatRegister,StrIntrinsicNode::LU);\n@@ -17080,1 +17167,1 @@\n-instruct has_negatives(iRegP_R1 ary1, iRegI_R2 len, iRegI_R0 result, rFlagsReg cr)\n+instruct count_positives(iRegP_R1 ary1, iRegI_R2 len, iRegI_R0 result, rFlagsReg cr)\n@@ -17082,1 +17169,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -17084,1 +17171,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result\" %}\n+  format %{ \"count positives byte[] $ary1,$len -> $result\" %}\n@@ -17086,1 +17173,1 @@\n-    address tpc = __ has_negatives($ary1$$Register, $len$$Register, $result$$Register);\n+    address tpc = __ count_positives($ary1$$Register, $len$$Register, $result$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":120,"deletions":33,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -388,0 +388,1 @@\n+    __ authenticate_return_address(exception_pc, rscratch1);\n@@ -436,0 +437,1 @@\n+  __ protect_return_address(exception_pc, rscratch1);\n@@ -451,0 +453,1 @@\n+  __ protect_return_address(r0, rscratch1);\n@@ -499,0 +502,2 @@\n+  __ mov(r3, lr);\n+  __ protect_return_address();\n@@ -502,1 +507,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), rthread, lr);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), rthread, r3);\n@@ -515,0 +520,1 @@\n+  __ authenticate_return_address();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -131,1 +131,0 @@\n-      sender_pc = (address) this->fp()[return_addr_offset];\n@@ -138,0 +137,1 @@\n+      sender_pc = pauth_strip_verifiable((address) this->fp()[return_addr_offset], (address)saved_fp);\n@@ -153,1 +153,0 @@\n-      sender_pc = (address) *(sender_sp-1);\n@@ -156,0 +155,1 @@\n+      sender_pc = pauth_strip_verifiable((address) *(sender_sp-1), (address)saved_fp);\n@@ -274,0 +274,3 @@\n+  address signing_sp = (((address*) sp())[-2]);\n+  address signed_pc = pauth_sign_return_address(pc, (address)signing_sp);\n+  address pc_old = pauth_strip_verifiable(*pc_addr, (address)signing_sp);\n@@ -275,2 +278,6 @@\n-    tty->print_cr(\"patch_pc at address \" INTPTR_FORMAT \" [\" INTPTR_FORMAT \" -> \" INTPTR_FORMAT \"]\",\n-                  p2i(pc_addr), p2i(*pc_addr), p2i(pc));\n+    tty->print(\"patch_pc at address \" INTPTR_FORMAT \" [\" INTPTR_FORMAT \" -> \" INTPTR_FORMAT \"]\",\n+                  p2i(pc_addr), p2i(pc_old), p2i(pc));\n+    if (VM_Version::use_rop_protection()) {\n+      tty->print(\" [signed \" INTPTR_FORMAT \" -> \" INTPTR_FORMAT \"]\", p2i(*pc_addr), p2i(signed_pc));\n+    }\n+    tty->print_cr(\"\");\n@@ -279,2 +286,0 @@\n-  \/\/ Only generated code frames should be patched, therefore the return address will not be signed.\n-  assert(pauth_ptr_is_raw(*pc_addr), \"cannot be signed\");\n@@ -283,2 +288,2 @@\n-  assert(_pc == *pc_addr || pc == *pc_addr, \"must be\");\n-  *pc_addr = pc;\n+  assert(_pc == pc_old || pc == pc_old, \"must be\");\n+  *pc_addr = signed_pc;\n@@ -461,1 +466,2 @@\n-  \/\/ Use the raw version of pc - the interpreter should not have signed it.\n+  \/\/ For ROP protection, Interpreter will have signed the sender_pc, but there is no requirement to authenticate it here.\n+  address sender_pc = pauth_strip_verifiable(sender_pc_maybe_signed(), (address)link());\n@@ -463,1 +469,1 @@\n-  return frame(sender_sp, unextended_sp, link(), sender_pc_maybe_signed());\n+  return frame(sender_sp, unextended_sp, link(), sender_pc);\n@@ -466,1 +472,0 @@\n-\n@@ -486,1 +491,1 @@\n-  address sender_pc_copy = (address) *(l_sender_sp-1);\n+  address sender_pc_copy = pauth_strip_verifiable((address) *(l_sender_sp-1), (address) *(l_sender_sp-2));\n@@ -498,0 +503,3 @@\n+  \/\/ the return_address is always the word on the stack\n+\n+  \/\/ For ROP protection, C1\/C2 will have signed the sender_pc, but there is no requirement to authenticate it here.\n@@ -499,1 +507,1 @@\n-  address sender_pc = (address) *(l_sender_sp-1);\n+  address sender_pc = pauth_strip_verifiable((address) *(l_sender_sp-1), (address) *(l_sender_sp-2));\n@@ -565,0 +573,3 @@\n+  \/\/ Native code may or may not have signed the return address, we have no way to be sure or what\n+  \/\/ signing methods they used. Instead, just ensure the stripped value is used.\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -306,1 +306,1 @@\n-    __ enter(); \/\/ barrier may call runtime\n+    __ enter(\/*strip_ret_addr*\/true); \/\/ barrier may call runtime\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2022, Red Hat, Inc. All rights reserved.\n@@ -240,1 +240,1 @@\n-  __ enter();\n+  __ enter(\/*strip_ret_addr*\/true);\n@@ -362,1 +362,1 @@\n-    __ enter();\n+    __ enter(\/*strip_ret_addr*\/true);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-  __ enter();\n+  __ enter(\/*strip_ret_addr*\/true);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,3 @@\n-          range(1, 99)\n+          range(1, 99)                                                  \\\n+  product(ccstr, UseBranchProtection, \"none\",                           \\\n+          \"Branch Protection to use: none, standard, pac-ret\")          \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1182,0 +1182,2 @@\n+  strip_return_address(); \/\/ This might happen within a stack frame.\n+  protect_return_address();\n@@ -1195,0 +1197,1 @@\n+  authenticate_return_address();\n@@ -1215,0 +1218,2 @@\n+  strip_return_address(); \/\/ This might happen within a stack frame.\n+  protect_return_address();\n@@ -1235,0 +1240,1 @@\n+  authenticate_return_address();\n@@ -2702,1 +2708,1 @@\n-RegSet MacroAssembler::call_clobbered_registers() {\n+RegSet MacroAssembler::call_clobbered_gp_registers() {\n@@ -2712,1 +2718,1 @@\n-  push(call_clobbered_registers() - exclude, sp);\n+  push(call_clobbered_gp_registers() - exclude, sp);\n@@ -2734,1 +2740,1 @@\n-  pop(call_clobbered_registers() - exclude, sp);\n+  pop(call_clobbered_gp_registers() - exclude, sp);\n@@ -4636,0 +4642,1 @@\n+  protect_return_address();\n@@ -4668,0 +4675,1 @@\n+  authenticate_return_address();\n@@ -4722,2 +4730,2 @@\n-\/\/ This method checks if provided byte array contains byte with highest bit set.\n-address MacroAssembler::has_negatives(Register ary1, Register len, Register result) {\n+\/\/ This method counts leading positive bytes (highest bit not set) in provided byte array\n+address MacroAssembler::count_positives(Register ary1, Register len, Register result) {\n@@ -4730,0 +4738,1 @@\n+    mov(result, len);\n@@ -4731,1 +4740,1 @@\n-    br(LE, SET_RESULT);\n+    br(LE, DONE);\n@@ -4750,1 +4759,1 @@\n-    br(EQ, SET_RESULT);\n+    br(EQ, DONE);\n@@ -4753,5 +4762,6 @@\n-    ldr(result, Address(ary1));\n-    sub(len, zr, len, LSL, 3); \/\/ LSL 3 is to get bits from bytes\n-    lslv(result, result, len);\n-    tst(result, UPPER_BIT_MASK);\n-    b(SET_RESULT);\n+    ldr(rscratch1, Address(ary1));\n+    sub(rscratch2, zr, len, LSL, 3); \/\/ LSL 3 is to get bits from bytes\n+    lslv(rscratch1, rscratch1, rscratch2);\n+    tst(rscratch1, UPPER_BIT_MASK);\n+    br(NE, SET_RESULT);\n+    b(DONE);\n@@ -4760,3 +4770,3 @@\n-    RuntimeAddress has_neg = RuntimeAddress(StubRoutines::aarch64::has_negatives());\n-    assert(has_neg.target() != NULL, \"has_negatives stub has not been generated\");\n-    address tpc1 = trampoline_call(has_neg);\n+    RuntimeAddress count_pos = RuntimeAddress(StubRoutines::aarch64::count_positives());\n+    assert(count_pos.target() != NULL, \"count_positives stub has not been generated\");\n+    address tpc1 = trampoline_call(count_pos);\n@@ -4771,3 +4781,3 @@\n-    RuntimeAddress has_neg_long = RuntimeAddress(StubRoutines::aarch64::has_negatives_long());\n-    assert(has_neg_long.target() != NULL, \"has_negatives stub has not been generated\");\n-    address tpc2 = trampoline_call(has_neg_long);\n+    RuntimeAddress count_pos_long = RuntimeAddress(StubRoutines::aarch64::count_positives_long());\n+    assert(count_pos_long.target() != NULL, \"count_positives_long stub has not been generated\");\n+    address tpc2 = trampoline_call(count_pos_long);\n@@ -4782,1 +4792,3 @@\n-    cset(result, NE); \/\/ set true or false\n+\n+    add(len, len, wordSize);\n+    sub(result, result, len);\n@@ -5560,0 +5572,1 @@\n+  protect_return_address();\n@@ -5569,0 +5582,1 @@\n+  authenticate_return_address();\n@@ -6019,0 +6033,99 @@\n+\n+\/\/ Stack frame creation\/removal\n+\n+void MacroAssembler::enter(bool strip_ret_addr) {\n+  if (strip_ret_addr) {\n+    \/\/ Addresses can only be signed once. If there are multiple nested frames being created\n+    \/\/ in the same function, then the return address needs stripping first.\n+    strip_return_address();\n+  }\n+  protect_return_address();\n+  stp(rfp, lr, Address(pre(sp, -2 * wordSize)));\n+  mov(rfp, sp);\n+}\n+\n+void MacroAssembler::leave() {\n+  mov(sp, rfp);\n+  ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n+  authenticate_return_address();\n+}\n+\n+\/\/ ROP Protection\n+\/\/ Use the AArch64 PAC feature to add ROP protection for generated code. Use whenever creating\/\n+\/\/ destroying stack frames or whenever directly loading\/storing the LR to memory.\n+\/\/ If ROP protection is not set then these functions are no-ops.\n+\/\/ For more details on PAC see pauth_aarch64.hpp.\n+\n+\/\/ Sign the LR. Use during construction of a stack frame, before storing the LR to memory.\n+\/\/ Uses the FP as the modifier.\n+\/\/\n+void MacroAssembler::protect_return_address() {\n+  if (VM_Version::use_rop_protection()) {\n+    check_return_address();\n+    \/\/ The standard convention for C code is to use paciasp, which uses SP as the modifier. This\n+    \/\/ works because in C code, FP and SP match on function entry. In the JDK, SP and FP may not\n+    \/\/ match, so instead explicitly use the FP.\n+    pacia(lr, rfp);\n+  }\n+}\n+\n+\/\/ Sign the return value in the given register. Use before updating the LR in the exisiting stack\n+\/\/ frame for the current function.\n+\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n+\/\/ the current FP.\n+\/\/\n+void MacroAssembler::protect_return_address(Register return_reg, Register temp_reg) {\n+  if (VM_Version::use_rop_protection()) {\n+    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n+    check_return_address(return_reg);\n+    ldr(temp_reg, Address(rfp));\n+    pacia(return_reg, temp_reg);\n+  }\n+}\n+\n+\/\/ Authenticate the LR. Use before function return, after restoring FP and loading LR from memory.\n+\/\/\n+void MacroAssembler::authenticate_return_address(Register return_reg) {\n+  if (VM_Version::use_rop_protection()) {\n+    autia(return_reg, rfp);\n+    check_return_address(return_reg);\n+  }\n+}\n+\n+\/\/ Authenticate the return value in the given register. Use before updating the LR in the exisiting\n+\/\/ stack frame for the current function.\n+\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n+\/\/ the current FP.\n+\/\/\n+void MacroAssembler::authenticate_return_address(Register return_reg, Register temp_reg) {\n+  if (VM_Version::use_rop_protection()) {\n+    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n+    ldr(temp_reg, Address(rfp));\n+    autia(return_reg, temp_reg);\n+    check_return_address(return_reg);\n+  }\n+}\n+\n+\/\/ Strip any PAC data from LR without performing any authentication. Use with caution - only if\n+\/\/ there is no guaranteed way of authenticating the LR.\n+\/\/\n+void MacroAssembler::strip_return_address() {\n+  if (VM_Version::use_rop_protection()) {\n+    xpaclri();\n+  }\n+}\n+\n+#ifndef PRODUCT\n+\/\/ PAC failures can be difficult to debug. After an authentication failure, a segfault will only\n+\/\/ occur when the pointer is used - ie when the program returns to the invalid LR. At this point\n+\/\/ it is difficult to debug back to the callee function.\n+\/\/ This function simply loads from the address in the given register.\n+\/\/ Use directly after authentication to catch authentication failures.\n+\/\/ Also use before signing to check that the pointer is valid and hasn't already been signed.\n+\/\/\n+void MacroAssembler::check_return_address(Register return_reg) {\n+  if (VM_Version::use_rop_protection()) {\n+    ldr(zr, Address(return_reg));\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":132,"deletions":19,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -476,1 +476,1 @@\n-  static RegSet call_clobbered_registers();\n+  static RegSet call_clobbered_gp_registers();\n@@ -727,10 +727,10 @@\n-  void enter()\n-  {\n-    stp(rfp, lr, Address(pre(sp, -2 * wordSize)));\n-    mov(rfp, sp);\n-  }\n-  void leave()\n-  {\n-    mov(sp, rfp);\n-    ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n-  }\n+  void enter(bool strip_ret_addr = false);\n+  void leave();\n+\n+  \/\/ ROP Protection\n+  void protect_return_address();\n+  void protect_return_address(Register return_reg, Register temp_reg);\n+  void authenticate_return_address(Register return_reg = lr);\n+  void authenticate_return_address(Register return_reg, Register temp_reg);\n+  void strip_return_address();\n+  void check_return_address(Register return_reg=lr) PRODUCT_RETURN;\n@@ -1316,1 +1316,1 @@\n-  address has_negatives(Register ary1, Register len, Register result);\n+  address count_positives(Register ary1, Register len, Register result);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -495,0 +495,1 @@\n+  __ authenticate_return_address(c_rarg1, rscratch1);\n@@ -2457,1 +2458,1 @@\n-\n+  __ protect_return_address(r3, rscratch1);\n@@ -2566,0 +2567,1 @@\n+  __ authenticate_return_address();\n@@ -2707,0 +2709,1 @@\n+  __ protect_return_address();\n@@ -2781,0 +2784,1 @@\n+  __ authenticate_return_address();\n@@ -2903,0 +2907,5 @@\n+  \/\/ When the signal occured, the LR was either signed and stored on the stack (in which\n+  \/\/ case it will be restored from the stack before being used) or unsigned and not stored\n+  \/\/ on the stack. Stipping ensures we get the right value.\n+  __ strip_return_address();\n+\n@@ -2922,0 +2931,1 @@\n+    __ protect_return_address(r20, rscratch1);\n@@ -2962,0 +2972,1 @@\n+    __ authenticate_return_address(r20, rscratch1);\n@@ -2976,0 +2987,1 @@\n+    __ protect_return_address(r20, rscratch1);\n@@ -3136,0 +3148,1 @@\n+  __ protect_return_address();\n@@ -3189,0 +3202,1 @@\n+  __ authenticate_return_address(r3);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"asm\/register.hpp\"\n@@ -1341,1 +1342,1 @@\n-      = MacroAssembler::call_clobbered_registers() - rscratch1;\n+      = MacroAssembler::call_clobbered_gp_registers() - rscratch1;\n@@ -1344,1 +1345,1 @@\n-    for (RegSetIterator<> it = clobbered.begin(); *it != noreg; ++it) {\n+    for (RegSetIterator<Register> it = clobbered.begin(); *it != noreg; ++it) {\n@@ -4686,1 +4687,1 @@\n-  address generate_has_negatives(address &has_negatives_long) {\n+  address generate_count_positives(address &count_positives_long) {\n@@ -4695,1 +4696,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"has_negatives\");\n+    StubCodeMark mark(this, \"StubRoutines\", \"count_positives\");\n@@ -4700,0 +4701,2 @@\n+    \/\/ precondition: a copy of len is already in result\n+    \/\/ __ mov(result, len);\n@@ -4701,1 +4704,1 @@\n-  Label RET_TRUE, RET_TRUE_NO_POP, RET_FALSE, ALIGNED, LOOP16, CHECK_16, DONE,\n+  Label RET_ADJUST, RET_ADJUST_16, RET_ADJUST_LONG, RET_NO_POP, RET_LEN, ALIGNED, LOOP16, CHECK_16,\n@@ -4715,1 +4718,1 @@\n-  __ cset(result, Assembler::NE);\n+  __ csel(result, zr, result, Assembler::NE);\n@@ -4722,1 +4725,1 @@\n-  __ br(Assembler::NE, RET_TRUE_NO_POP);\n+  __ br(Assembler::NE, RET_NO_POP);\n@@ -4726,1 +4729,2 @@\n-  __ cset(result, Assembler::NE);\n+  __ bind(RET_NO_POP);\n+  __ csel(result, zr, result, Assembler::NE);\n@@ -4733,1 +4737,1 @@\n-  has_negatives_long = __ pc(); \/\/ 2nd entry point\n+  count_positives_long = __ pc(); \/\/ 2nd entry point\n@@ -4745,1 +4749,0 @@\n-    __ sub(len, len, rscratch1);\n@@ -4748,1 +4751,2 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST);\n+    __ sub(len, len, rscratch1);\n@@ -4763,1 +4767,1 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST_16);\n@@ -4795,1 +4799,1 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST_LONG);\n@@ -4808,1 +4812,1 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST_16);\n@@ -4816,2 +4820,2 @@\n-    __ sub(len, len, 8);\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST);\n+    __ sub(len, len, 8);\n@@ -4821,1 +4825,1 @@\n-    __ cbz(len, RET_FALSE); \/\/ Can't shift left by 64 when len==0\n+    __ cbz(len, RET_LEN); \/\/ Can't shift left by 64 when len==0\n@@ -4827,1 +4831,1 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST);\n@@ -4830,1 +4834,1 @@\n-  __ bind(RET_FALSE);\n+  __ bind(RET_LEN);\n@@ -4833,1 +4837,0 @@\n-    __ mov(result, zr);\n@@ -4836,6 +4839,2 @@\n-  __ bind(RET_TRUE);\n-    __ pop(spilled_regs, sp);\n-  __ bind(RET_TRUE_NO_POP);\n-    __ leave();\n-    __ mov(result, 1);\n-    __ ret(lr);\n+    \/\/ difference result - len is the count of guaranteed to be\n+    \/\/ positive bytes\n@@ -4843,1 +4842,5 @@\n-  __ bind(DONE);\n+  __ bind(RET_ADJUST_LONG);\n+    __ add(len, len, (u1)(large_loop_size - 16));\n+  __ bind(RET_ADJUST_16);\n+    __ add(len, len, 16);\n+  __ bind(RET_ADJUST);\n@@ -4846,0 +4849,1 @@\n+    __ sub(result, result, len);\n@@ -4847,0 +4851,1 @@\n+\n@@ -5244,91 +5249,0 @@\n-  enum string_compare_mode {\n-    LL,\n-    LU,\n-    UL,\n-    UU,\n-  };\n-\n-  \/\/ The following registers are declared in aarch64.ad\n-  \/\/ r0  = result\n-  \/\/ r1  = str1\n-  \/\/ r2  = cnt1\n-  \/\/ r3  = str2\n-  \/\/ r4  = cnt2\n-  \/\/ r10 = tmp1\n-  \/\/ r11 = tmp2\n-  \/\/ z0  = ztmp1\n-  \/\/ z1  = ztmp2\n-  \/\/ p0  = pgtmp1\n-  \/\/ p1  = pgtmp2\n-  address generate_compare_long_string_sve(string_compare_mode mode) {\n-    __ align(CodeEntryAlignment);\n-    address entry = __ pc();\n-    Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,\n-             tmp1 = r10, tmp2 = r11;\n-\n-    Label LOOP, MATCH, DONE, NOMATCH;\n-    Register vec_len = tmp1;\n-    Register idx = tmp2;\n-    \/\/ The minimum of the string lengths has been stored in cnt2.\n-    Register cnt = cnt2;\n-    FloatRegister ztmp1 = z0, ztmp2 = z1;\n-    PRegister pgtmp1 = p0, pgtmp2 = p1;\n-\n-    if (mode == LL) {\n-      __ sve_cntb(vec_len);\n-    } else {\n-      __ sve_cnth(vec_len);\n-    }\n-\n-    __ mov(idx, 0);\n-    __ sve_whilelt(pgtmp1, mode == LL ? __ B : __ H, idx, cnt);\n-\n-    __ bind(LOOP);\n-      switch (mode) {\n-        case LL:\n-          __ sve_ld1b(ztmp1, __ B, pgtmp1, Address(str1, idx));\n-          __ sve_ld1b(ztmp2, __ B, pgtmp1, Address(str2, idx));\n-          break;\n-        case LU:\n-          __ sve_ld1b(ztmp1, __ H, pgtmp1, Address(str1, idx));\n-          __ sve_ld1h(ztmp2, __ H, pgtmp1, Address(str2, idx, Address::lsl(1)));\n-          break;\n-        case UL:\n-          __ sve_ld1h(ztmp1, __ H, pgtmp1, Address(str1, idx, Address::lsl(1)));\n-          __ sve_ld1b(ztmp2, __ H, pgtmp1, Address(str2, idx));\n-          break;\n-        case UU:\n-          __ sve_ld1h(ztmp1, __ H, pgtmp1, Address(str1, idx, Address::lsl(1)));\n-          __ sve_ld1h(ztmp2, __ H, pgtmp1, Address(str2, idx, Address::lsl(1)));\n-          break;\n-        default: ShouldNotReachHere();\n-      }\n-      __ add(idx, idx, vec_len);\n-\n-      \/\/ Compare strings.\n-      __ sve_cmp(Assembler::NE, pgtmp2, mode == LL ? __ B : __ H, pgtmp1, ztmp1, ztmp2);\n-      __ br(__ NE, MATCH);\n-      __ sve_whilelt(pgtmp1, mode == LL ? __ B : __ H, idx, cnt);\n-      __ br(__ LT, LOOP);\n-\n-      \/\/ The result has been computed in the caller prior to entering this stub.\n-      __ b(DONE);\n-\n-    __ bind(MATCH);\n-\n-      \/\/ Crop the vector to find its location.\n-      __ sve_brkb(pgtmp2, pgtmp1, pgtmp2, false \/* isMerge *\/);\n-\n-      \/\/ Extract the first different characters of each string.\n-      __ sve_lasta(rscratch1, mode == LL ? __ B : __ H, pgtmp2, ztmp1);\n-      __ sve_lasta(rscratch2, mode == LL ? __ B : __ H, pgtmp2, ztmp2);\n-\n-      \/\/ Compute the difference of the first different characters.\n-      __ sub(result, rscratch1, rscratch2);\n-\n-    __ bind(DONE);\n-      __ ret(lr);\n-\n-    return entry;\n-  }\n-\n@@ -5457,1 +5371,0 @@\n-    if (UseSVE == 0) {\n@@ -5466,10 +5379,0 @@\n-    } else {\n-      StubRoutines::aarch64::_compare_long_string_LL\n-          = generate_compare_long_string_sve(LL);\n-      StubRoutines::aarch64::_compare_long_string_UU\n-          = generate_compare_long_string_sve(UU);\n-      StubRoutines::aarch64::_compare_long_string_LU\n-          = generate_compare_long_string_sve(LU);\n-      StubRoutines::aarch64::_compare_long_string_UL\n-          = generate_compare_long_string_sve(UL);\n-    }\n@@ -6756,1 +6659,1 @@\n-      RegSetIterator<> regs = (RegSet::range(r0, r26) - r18_tls).begin();\n+      RegSetIterator<Register> regs = (RegSet::range(r0, r26) - r18_tls).begin();\n@@ -7785,2 +7688,2 @@\n-    \/\/ has negatives stub for large arrays.\n-    StubRoutines::aarch64::_has_negatives = generate_has_negatives(StubRoutines::aarch64::_has_negatives_long);\n+    \/\/ countPositives stub for large arrays.\n+    StubRoutines::aarch64::_count_positives = generate_count_positives(StubRoutines::aarch64::_count_positives_long);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":35,"deletions":132,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -842,0 +842,1 @@\n+  __ protect_return_address();\n@@ -1758,0 +1759,2 @@\n+    \/\/ This is a return address, so requires authenticating for PAC.\n+    __ authenticate_return_address(c_rarg1, rscratch1);\n@@ -1947,0 +1950,1 @@\n+  __ protect_return_address();\n@@ -1957,0 +1961,1 @@\n+  __ authenticate_return_address();\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1500,0 +1500,20 @@\n+void C2_MacroAssembler::load_vector(XMMRegister dst, Address src, int vlen_in_bytes) {\n+  switch (vlen_in_bytes) {\n+  case 4:  movdl(dst, src);   break;\n+  case 8:  movq(dst, src);    break;\n+  case 16: movdqu(dst, src);  break;\n+  case 32: vmovdqu(dst, src); break;\n+  case 64: evmovdquq(dst, src, Assembler::AVX_512bit); break;\n+  default: ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch) {\n+  if (reachable(src)) {\n+    load_vector(dst, as_Address(src), vlen_in_bytes);\n+  } else {\n+    lea(rscratch, src);\n+    load_vector(dst, Address(rscratch, 0), vlen_in_bytes);\n+  }\n+}\n+\n@@ -3361,1 +3381,2 @@\n-\/\/ return true if it has any and false otherwise.\n+\/\/ return the index of the first such character, otherwise the length\n+\/\/ of the array segment searched.\n@@ -3364,1 +3385,1 @@\n-\/\/   private static boolean hasNegatives(byte[] ba, int off, int len) {\n+\/\/   public static int countPositives(byte[] ba, int off, int len) {\n@@ -3367,1 +3388,1 @@\n-\/\/         return true;\n+\/\/         return i - off;\n@@ -3370,1 +3391,1 @@\n-\/\/     return false;\n+\/\/     return len;\n@@ -3372,1 +3393,1 @@\n-void C2_MacroAssembler::has_negatives(Register ary1, Register len,\n+void C2_MacroAssembler::count_positives(Register ary1, Register len,\n@@ -3381,1 +3402,1 @@\n-  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;\n+  Label ADJUST, TAIL_ADJUST, DONE, TAIL_START, CHAR_ADJUST, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;\n@@ -3383,0 +3404,1 @@\n+  movl(result, len); \/\/ copy\n@@ -3385,1 +3407,1 @@\n-  jcc(Assembler::zero, FALSE_LABEL);\n+  jcc(Assembler::zero, DONE);\n@@ -3391,1 +3413,1 @@\n-    Label test_64_loop, test_tail;\n+    Label test_64_loop, test_tail, BREAK_LOOP;\n@@ -3408,1 +3430,1 @@\n-    jcc(Assembler::notZero, TRUE_LABEL);\n+    jcc(Assembler::notZero, BREAK_LOOP);\n@@ -3413,1 +3435,0 @@\n-\n@@ -3417,1 +3438,1 @@\n-    jcc(Assembler::zero, FALSE_LABEL);\n+    jcc(Assembler::zero, DONE);\n@@ -3454,1 +3475,1 @@\n-    jcc(Assembler::notZero, TRUE_LABEL);\n+    jcc(Assembler::zero, DONE);\n@@ -3456,1 +3477,11 @@\n-    jmp(FALSE_LABEL);\n+    bind(BREAK_LOOP);\n+    \/\/ At least one byte in the last 64 bytes is negative.\n+    \/\/ Set up to look at the last 64 bytes as if they were a tail\n+    lea(ary1, Address(ary1, len, Address::times_1));\n+    addptr(result, len);\n+    \/\/ Ignore the very last byte: if all others are positive,\n+    \/\/ it must be negative, so we can skip right to the 2+1 byte\n+    \/\/ end comparison at this point\n+    orl(result, 63);\n+    movl(len, 63);\n+    \/\/ Fallthru to tail compare\n@@ -3458,1 +3489,0 @@\n-    movl(result, len); \/\/ copy\n@@ -3462,1 +3492,1 @@\n-      Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+      Label COMPARE_WIDE_VECTORS, BREAK_LOOP;\n@@ -3465,3 +3495,2 @@\n-      andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n-      andl(len, 0xffffffe0);   \/\/ vector count (in bytes)\n-      jccb(Assembler::zero, COMPARE_TAIL);\n+      testl(len, 0xffffffe0);   \/\/ vector count (in bytes)\n+      jccb(Assembler::zero, TAIL_START);\n@@ -3469,0 +3498,1 @@\n+      andl(len, 0xffffffe0);\n@@ -3479,1 +3509,1 @@\n-      jccb(Assembler::notZero, TRUE_LABEL);\n+      jccb(Assembler::notZero, BREAK_LOOP);\n@@ -3481,1 +3511,1 @@\n-      jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+      jccb(Assembler::notZero, COMPARE_WIDE_VECTORS);\n@@ -3483,2 +3513,2 @@\n-      testl(result, result);\n-      jccb(Assembler::zero, FALSE_LABEL);\n+      testl(result, 0x0000001f);   \/\/ any bytes remaining?\n+      jcc(Assembler::zero, DONE);\n@@ -3486,1 +3516,4 @@\n-      vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));\n+      \/\/ Quick test using the already prepared vector mask\n+      movl(len, result);\n+      andl(len, 0x0000001f);\n+      vmovdqu(vec1, Address(ary1, len, Address::times_1, -32));\n@@ -3488,2 +3521,3 @@\n-      jccb(Assembler::notZero, TRUE_LABEL);\n-      jmpb(FALSE_LABEL);\n+      jcc(Assembler::zero, DONE);\n+      \/\/ There are zeros, jump to the tail to determine exactly where\n+      jmpb(TAIL_START);\n@@ -3491,2 +3525,10 @@\n-      bind(COMPARE_TAIL); \/\/ len is zero\n-      movl(len, result);\n+      bind(BREAK_LOOP);\n+      \/\/ At least one byte in the last 32-byte vector is negative.\n+      \/\/ Set up to look at the last 32 bytes as if they were a tail\n+      lea(ary1, Address(ary1, len, Address::times_1));\n+      addptr(result, len);\n+      \/\/ Ignore the very last byte: if all others are positive,\n+      \/\/ it must be negative, so we can skip right to the 2+1 byte\n+      \/\/ end comparison at this point\n+      orl(result, 31);\n+      movl(len, 31);\n@@ -3496,1 +3538,1 @@\n-      Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+      Label COMPARE_WIDE_VECTORS, BREAK_LOOP;\n@@ -3499,3 +3541,2 @@\n-      andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n-      andl(len, 0xfffffff0);   \/\/ vector count (in bytes)\n-      jcc(Assembler::zero, COMPARE_TAIL);\n+      testl(len, 0xfffffff0);   \/\/ vector count (in bytes)\n+      jcc(Assembler::zero, TAIL_START);\n@@ -3503,0 +3544,1 @@\n+      andl(len, 0xfffffff0);\n@@ -3513,1 +3555,1 @@\n-      jcc(Assembler::notZero, TRUE_LABEL);\n+      jccb(Assembler::notZero, BREAK_LOOP);\n@@ -3515,1 +3557,1 @@\n-      jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+      jccb(Assembler::notZero, COMPARE_WIDE_VECTORS);\n@@ -3517,2 +3559,2 @@\n-      testl(result, result);\n-      jcc(Assembler::zero, FALSE_LABEL);\n+      testl(result, 0x0000000f); \/\/ len is zero, any bytes remaining?\n+      jcc(Assembler::zero, DONE);\n@@ -3520,1 +3562,4 @@\n-      movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n+      \/\/ Quick test using the already prepared vector mask\n+      movl(len, result);\n+      andl(len, 0x0000000f);   \/\/ tail count (in bytes)\n+      movdqu(vec1, Address(ary1, len, Address::times_1, -16));\n@@ -3522,2 +3567,2 @@\n-      jccb(Assembler::notZero, TRUE_LABEL);\n-      jmpb(FALSE_LABEL);\n+      jcc(Assembler::zero, DONE);\n+      jmpb(TAIL_START);\n@@ -3525,2 +3570,10 @@\n-      bind(COMPARE_TAIL); \/\/ len is zero\n-      movl(len, result);\n+      bind(BREAK_LOOP);\n+      \/\/ At least one byte in the last 16-byte vector is negative.\n+      \/\/ Set up and look at the last 16 bytes as if they were a tail\n+      lea(ary1, Address(ary1, len, Address::times_1));\n+      addptr(result, len);\n+      \/\/ Ignore the very last byte: if all others are positive,\n+      \/\/ it must be negative, so we can skip right to the 2+1 byte\n+      \/\/ end comparison at this point\n+      orl(result, 15);\n+      movl(len, 15);\n@@ -3530,0 +3583,2 @@\n+\n+  bind(TAIL_START);\n@@ -3540,1 +3595,1 @@\n-  jccb(Assembler::notZero, TRUE_LABEL);\n+  jccb(Assembler::notZero, TAIL_ADJUST);\n@@ -3542,1 +3597,1 @@\n-  jcc(Assembler::notZero, COMPARE_VECTORS);\n+  jccb(Assembler::notZero, COMPARE_VECTORS);\n@@ -3544,1 +3599,1 @@\n-  \/\/ Compare trailing char (final 2 bytes), if any\n+  \/\/ Compare trailing char (final 2-3 bytes), if any\n@@ -3546,0 +3601,1 @@\n+\n@@ -3550,2 +3606,1 @@\n-  jccb(Assembler::notZero, TRUE_LABEL);\n-  subptr(result, 2);\n+  jccb(Assembler::notZero, CHAR_ADJUST);\n@@ -3556,1 +3611,1 @@\n-  jccb(Assembler::zero, FALSE_LABEL);\n+  jccb(Assembler::zero, DONE);\n@@ -3558,6 +3613,3 @@\n-  andl(tmp1, 0x00000080);\n-  jccb(Assembler::notEqual, TRUE_LABEL);\n-  jmpb(FALSE_LABEL);\n-\n-  bind(TRUE_LABEL);\n-  movl(result, 1);   \/\/ return true\n+  testl(tmp1, 0x00000080);\n+  jccb(Assembler::zero, DONE);\n+  subptr(result, 1);\n@@ -3566,2 +3618,16 @@\n-  bind(FALSE_LABEL);\n-  xorl(result, result); \/\/ return false\n+  bind(TAIL_ADJUST);\n+  \/\/ there are negative bits in the last 4 byte block.\n+  \/\/ Adjust result and check the next three bytes\n+  addptr(result, len);\n+  orl(result, 3);\n+  lea(ary1, Address(ary1, len, Address::times_1));\n+  jmpb(COMPARE_CHAR);\n+\n+  bind(CHAR_ADJUST);\n+  \/\/ We are looking at a char + optional byte tail, and found that one\n+  \/\/ of the bytes in the char is negative. Adjust the result, check the\n+  \/\/ first byte and readjust if needed.\n+  andl(result, 0xfffffffc);\n+  testl(tmp1, 0x00000080); \/\/ little-endian, so lowest byte comes first\n+  jccb(Assembler::notZero, DONE);\n+  addptr(result, 1);\n@@ -3577,0 +3643,1 @@\n+\n@@ -4081,0 +4148,27 @@\n+void C2_MacroAssembler::vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                                             BasicType from_elem_bt, BasicType to_elem_bt) {\n+  switch (from_elem_bt) {\n+    case T_BYTE:\n+      switch (to_elem_bt) {\n+        case T_SHORT: vpmovzxbw(dst, src, vlen_enc); break;\n+        case T_INT:   vpmovzxbd(dst, src, vlen_enc); break;\n+        case T_LONG:  vpmovzxbq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_SHORT:\n+      switch (to_elem_bt) {\n+        case T_INT:  vpmovzxwd(dst, src, vlen_enc); break;\n+        case T_LONG: vpmovzxwq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_INT:\n+      assert(to_elem_bt == T_LONG, \"\");\n+      vpmovzxdq(dst, src, vlen_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n@@ -4281,0 +4375,88 @@\n+\n+\/\/\n+\/\/ Following is lookup table based popcount computation algorithm:-\n+\/\/       Index   Bit set count\n+\/\/     [ 0000 ->   0,\n+\/\/       0001 ->   1,\n+\/\/       0010 ->   1,\n+\/\/       0011 ->   2,\n+\/\/       0100 ->   1,\n+\/\/       0101 ->   2,\n+\/\/       0110 ->   2,\n+\/\/       0111 ->   3,\n+\/\/       1000 ->   1,\n+\/\/       1001 ->   2,\n+\/\/       1010 ->   3,\n+\/\/       1011 ->   3,\n+\/\/       1100 ->   2,\n+\/\/       1101 ->   3,\n+\/\/       1111 ->   4 ]\n+\/\/  a. Count the number of 1s in 4 LSB bits of each byte. These bits are used as\n+\/\/     shuffle indices for lookup table access.\n+\/\/  b. Right shift each byte of vector lane by 4 positions.\n+\/\/  c. Count the number of 1s in 4 MSB bits each byte. These bits are used as\n+\/\/     shuffle indices for lookup table access.\n+\/\/  d. Add the bitset count of upper and lower 4 bits of each byte.\n+\/\/  e. Unpack double words to quad words and compute sum of absolute difference of bitset\n+\/\/     count of all the bytes of a quadword.\n+\/\/  f. Perform step e. for upper 128bit vector lane.\n+\/\/  g. Pack the bitset count of quadwords back to double word.\n+\/\/  h. Unpacking and packing operations are not needed for 64bit vector lane.\n+void C2_MacroAssembler::vector_popcount_int(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                            XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n+                                            int vec_enc) {\n+  if (VM_Version::supports_avx512_vpopcntdq()) {\n+    vpopcntd(dst, src, vec_enc);\n+  } else {\n+    assert((vec_enc == Assembler::AVX_512bit && VM_Version::supports_avx512bw()) || VM_Version::supports_avx2(), \"\");\n+    movl(rtmp, 0x0F0F0F0F);\n+    movdl(xtmp1, rtmp);\n+    vpbroadcastd(xtmp1, xtmp1, vec_enc);\n+    if (Assembler::AVX_512bit == vec_enc) {\n+      evmovdqul(xtmp2, k0, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), false, vec_enc, rtmp);\n+    } else {\n+      vmovdqu(xtmp2, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), rtmp);\n+    }\n+    vpand(xtmp3, src, xtmp1, vec_enc);\n+    vpshufb(xtmp3, xtmp2, xtmp3, vec_enc);\n+    vpsrlw(dst, src, 4, vec_enc);\n+    vpand(dst, dst, xtmp1, vec_enc);\n+    vpshufb(dst, xtmp2, dst, vec_enc);\n+    vpaddb(xtmp3, dst, xtmp3, vec_enc);\n+    vpxor(xtmp1, xtmp1, xtmp1, vec_enc);\n+    vpunpckhdq(dst, xtmp3, xtmp1, vec_enc);\n+    vpsadbw(dst, dst, xtmp1, vec_enc);\n+    vpunpckldq(xtmp2, xtmp3, xtmp1, vec_enc);\n+    vpsadbw(xtmp2, xtmp2, xtmp1, vec_enc);\n+    vpackuswb(dst, xtmp2, dst, vec_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_popcount_long(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                             XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n+                                             int vec_enc) {\n+  if (VM_Version::supports_avx512_vpopcntdq()) {\n+    vpopcntq(dst, src, vec_enc);\n+  } else if (vec_enc == Assembler::AVX_512bit) {\n+    assert(VM_Version::supports_avx512bw(), \"\");\n+    movl(rtmp, 0x0F0F0F0F);\n+    movdl(xtmp1, rtmp);\n+    vpbroadcastd(xtmp1, xtmp1, vec_enc);\n+    evmovdqul(xtmp2, k0, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), true, vec_enc, rtmp);\n+    vpandq(xtmp3, src, xtmp1, vec_enc);\n+    vpshufb(xtmp3, xtmp2, xtmp3, vec_enc);\n+    vpsrlw(dst, src, 4, vec_enc);\n+    vpandq(dst, dst, xtmp1, vec_enc);\n+    vpshufb(dst, xtmp2, dst, vec_enc);\n+    vpaddb(xtmp3, dst, xtmp3, vec_enc);\n+    vpxorq(xtmp1, xtmp1, xtmp1, vec_enc);\n+    vpsadbw(dst, xtmp3, xtmp1, vec_enc);\n+  } else {\n+    \/\/ We do not see any performance benefit of running\n+    \/\/ above instruction sequence on 256 bit vector which\n+    \/\/ can operate over maximum 4 long elements.\n+    ShouldNotReachHere();\n+  }\n+  evpmovqd(dst, dst, vec_enc);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":236,"deletions":54,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    __ pusha();                      \/\/ push registers\n+    __ push_call_clobbered_registers(false \/* save_fpu *\/);\n@@ -93,1 +93,1 @@\n-    __ popa();\n+    __ pop_call_clobbered_registers(false \/* save_fpu *\/);\n@@ -101,1 +101,1 @@\n-  __ pusha();             \/\/ push registers (overkill)\n+  __ push_call_clobbered_registers(false \/* save_fpu *\/);\n@@ -117,1 +117,1 @@\n-  __ popa();\n+  __ pop_call_clobbered_registers(false \/* save_fpu *\/);\n@@ -208,0 +208,1 @@\n+  \/\/ TODO: use push_set() (see JDK-8283327 push\/pop_call_clobbered_registers & aarch64 )\n@@ -334,0 +335,1 @@\n+  \/\/ TODO: use push_set() (see JDK-8283327 push\/pop_call_clobbered_registers & aarch64)\n@@ -377,3 +379,0 @@\n-  if (tmp3 == noreg) {\n-    tmp3 = LP64_ONLY(r8) NOT_LP64(rsi);\n-  }\n@@ -525,1 +524,1 @@\n-  __ save_live_registers_no_oop_map(true);\n+  __ push_call_clobbered_registers();\n@@ -531,1 +530,1 @@\n-  __ restore_live_registers(true);\n+  __ pop_call_clobbered_registers();\n@@ -544,3 +543,0 @@\n-  \/\/ arg0: store_address\n-  Address store_addr(rbp, 2*BytesPerWord);\n-\n@@ -602,2 +598,1 @@\n-\n-  __ save_live_registers_no_oop_map(true);\n+  __ push_call_clobbered_registers();\n@@ -607,1 +602,1 @@\n-  __ restore_live_registers(true);\n+  __ pop_call_clobbered_registers();\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3 = noreg);\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-    __ kmovql(Address(rsp, _spill_offset), reg);\n+    __ kmov(Address(rsp, _spill_offset), reg);\n@@ -466,1 +466,1 @@\n-    __ kmovql(reg, Address(rsp, _spill_offset));\n+    __ kmov(reg, Address(rsp, _spill_offset));\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2201,9 +2201,8 @@\n-\/\/ Jump if ((*counter_addr += increment) & mask) satisfies the condition.\n-void InterpreterMacroAssembler::increment_mask_and_jump(Address counter_addr,\n-                                                        int increment, Address mask,\n-                                                        Register scratch, bool preloaded,\n-                                                        Condition cond, Label* where) {\n-  if (!preloaded) {\n-    movl(scratch, counter_addr);\n-  }\n-  incrementl(scratch, increment);\n+\/\/ Jump if ((*counter_addr += increment) & mask) == 0\n+void InterpreterMacroAssembler::increment_mask_and_jump(Address counter_addr, Address mask,\n+                                                        Register scratch, Label* where) {\n+  \/\/ This update is actually not atomic and can lose a number of updates\n+  \/\/ under heavy contention, but the alternative of using the (contended)\n+  \/\/ atomic update here penalizes profiling paths too much.\n+  movl(scratch, counter_addr);\n+  incrementl(scratch, InvocationCounter::count_increment);\n@@ -2213,1 +2212,1 @@\n-    jcc(cond, *where);\n+    jcc(Assembler::zero, *where);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -274,4 +274,2 @@\n-  void increment_mask_and_jump(Address counter_addr,\n-                               int increment, Address mask,\n-                               Register scratch, bool preloaded,\n-                               Condition cond, Label* where);\n+  void increment_mask_and_jump(Address counter_addr, Address mask,\n+                               Register scratch, Label* where);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"c1\/c1_FrameMap.hpp\"\n@@ -341,15 +342,0 @@\n-\n-void MacroAssembler::pop_callee_saved_registers() {\n-  pop(rcx);\n-  pop(rdx);\n-  pop(rdi);\n-  pop(rsi);\n-}\n-\n-void MacroAssembler::push_callee_saved_registers() {\n-  push(rsi);\n-  push(rdi);\n-  push(rdx);\n-  push(rcx);\n-}\n-\n@@ -3865,0 +3851,184 @@\n+RegSet MacroAssembler::call_clobbered_gp_registers() {\n+  RegSet regs;\n+#ifdef _LP64\n+  regs += RegSet::of(rax, rcx, rdx);\n+#ifndef WINDOWS\n+  regs += RegSet::of(rsi, rdi);\n+#endif\n+  regs += RegSet::range(r8, r11);\n+#else\n+  regs += RegSet::of(rax, rcx, rdx);\n+#endif\n+  return regs;\n+}\n+\n+XMMRegSet MacroAssembler::call_clobbered_xmm_registers() {\n+#if defined(WINDOWS) && defined(_LP64)\n+  XMMRegSet result = XMMRegSet::range(xmm0, xmm5);\n+  if (FrameMap::get_num_caller_save_xmms() > 16) {\n+     result += XMMRegSet::range(xmm16, as_XMMRegister(FrameMap::get_num_caller_save_xmms() - 1));\n+  }\n+  return result;\n+#else\n+  return XMMRegSet::range(xmm0, as_XMMRegister(FrameMap::get_num_caller_save_xmms() - 1));\n+#endif\n+}\n+\n+static int FPUSaveAreaSize = align_up(108, StackAlignmentInBytes); \/\/ 108 bytes needed for FPU state by fsave\/frstor\n+\n+#ifndef _LP64\n+static bool use_x87_registers() { return UseSSE < 2; }\n+#endif\n+static bool use_xmm_registers() { return UseSSE >= 1; }\n+\n+\/\/ C1 only ever uses the first double\/float of the XMM register.\n+static int xmm_save_size() { return UseSSE >= 2 ? sizeof(double) : sizeof(float); }\n+\n+static void save_xmm_register(MacroAssembler* masm, int offset, XMMRegister reg) {\n+  if (UseSSE == 1) {\n+    masm->movflt(Address(rsp, offset), reg);\n+  } else {\n+    masm->movdbl(Address(rsp, offset), reg);\n+  }\n+}\n+\n+static void restore_xmm_register(MacroAssembler* masm, int offset, XMMRegister reg) {\n+  if (UseSSE == 1) {\n+    masm->movflt(reg, Address(rsp, offset));\n+  } else {\n+    masm->movdbl(reg, Address(rsp, offset));\n+  }\n+}\n+\n+int register_section_sizes(RegSet gp_registers, XMMRegSet xmm_registers, bool save_fpu,\n+                           int& gp_area_size, int& fp_area_size, int& xmm_area_size) {\n+\n+  gp_area_size = align_up(gp_registers.size() * RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size,\n+                         StackAlignmentInBytes);\n+#ifdef _LP64\n+  fp_area_size = 0;\n+#else\n+  fp_area_size = (save_fpu && use_x87_registers()) ? FPUSaveAreaSize : 0;\n+#endif\n+  xmm_area_size = (save_fpu && use_xmm_registers()) ? xmm_registers.size() * xmm_save_size() : 0;\n+\n+  return gp_area_size + fp_area_size + xmm_area_size;\n+}\n+\n+void MacroAssembler::push_call_clobbered_registers_except(RegSet exclude, bool save_fpu) {\n+  block_comment(\"push_call_clobbered_registers start\");\n+  \/\/ Regular registers\n+  RegSet gp_registers_to_push = call_clobbered_gp_registers() - exclude;\n+\n+  int gp_area_size;\n+  int fp_area_size;\n+  int xmm_area_size;\n+  int total_save_size = register_section_sizes(gp_registers_to_push, call_clobbered_xmm_registers(), save_fpu,\n+                                               gp_area_size, fp_area_size, xmm_area_size);\n+  subptr(rsp, total_save_size);\n+\n+  push_set(gp_registers_to_push, 0);\n+\n+#ifndef _LP64\n+  if (save_fpu && use_x87_registers()) {\n+    fnsave(Address(rsp, gp_area_size));\n+    fwait();\n+  }\n+#endif\n+  if (save_fpu && use_xmm_registers()) {\n+    push_set(call_clobbered_xmm_registers(), gp_area_size + fp_area_size);\n+  }\n+\n+  block_comment(\"push_call_clobbered_registers end\");\n+}\n+\n+void MacroAssembler::pop_call_clobbered_registers_except(RegSet exclude, bool restore_fpu) {\n+  block_comment(\"pop_call_clobbered_registers start\");\n+\n+  RegSet gp_registers_to_pop = call_clobbered_gp_registers() - exclude;\n+\n+  int gp_area_size;\n+  int fp_area_size;\n+  int xmm_area_size;\n+  int total_save_size = register_section_sizes(gp_registers_to_pop, call_clobbered_xmm_registers(), restore_fpu,\n+                                               gp_area_size, fp_area_size, xmm_area_size);\n+\n+  if (restore_fpu && use_xmm_registers()) {\n+    pop_set(call_clobbered_xmm_registers(), gp_area_size + fp_area_size);\n+  }\n+#ifndef _LP64\n+  if (restore_fpu && use_x87_registers()) {\n+    frstor(Address(rsp, gp_area_size));\n+  }\n+#endif\n+\n+  pop_set(gp_registers_to_pop, 0);\n+\n+  addptr(rsp, total_save_size);\n+\n+  vzeroupper();\n+\n+  block_comment(\"pop_call_clobbered_registers end\");\n+}\n+\n+void MacroAssembler::push_set(XMMRegSet set, int offset) {\n+  assert(is_aligned(set.size() * xmm_save_size(), StackAlignmentInBytes), \"must be\");\n+  int spill_offset = offset;\n+\n+  for (RegSetIterator<XMMRegister> it = set.begin(); *it != xnoreg; ++it) {\n+    save_xmm_register(this, spill_offset, *it);\n+    spill_offset += xmm_save_size();\n+  }\n+}\n+\n+void MacroAssembler::pop_set(XMMRegSet set, int offset) {\n+  int restore_size = set.size() * xmm_save_size();\n+  assert(is_aligned(restore_size, StackAlignmentInBytes), \"must be\");\n+\n+  int restore_offset = offset + restore_size - xmm_save_size();\n+\n+  for (ReverseRegSetIterator<XMMRegister> it = set.rbegin(); *it != xnoreg; ++it) {\n+    restore_xmm_register(this, restore_offset, *it);\n+    restore_offset -= xmm_save_size();\n+  }\n+}\n+\n+void MacroAssembler::push_set(RegSet set, int offset) {\n+  int spill_offset;\n+  if (offset == -1) {\n+    int register_push_size = set.size() * RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+    int aligned_size = align_up(register_push_size, StackAlignmentInBytes);\n+    subptr(rsp, aligned_size);\n+    spill_offset = 0;\n+  } else {\n+    spill_offset = offset;\n+  }\n+\n+  for (RegSetIterator<Register> it = set.begin(); *it != noreg; ++it) {\n+    movptr(Address(rsp, spill_offset), *it);\n+    spill_offset += RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+  }\n+}\n+\n+void MacroAssembler::pop_set(RegSet set, int offset) {\n+\n+  int gp_reg_size = RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+  int restore_size = set.size() * gp_reg_size;\n+  int aligned_size = align_up(restore_size, StackAlignmentInBytes);\n+\n+  int restore_offset;\n+  if (offset == -1) {\n+    restore_offset = restore_size - gp_reg_size;\n+  } else {\n+    restore_offset = offset + restore_size - gp_reg_size;\n+  }\n+  for (ReverseRegSetIterator<Register> it = set.rbegin(); *it != noreg; ++it) {\n+    movptr(*it, Address(rsp, restore_offset));\n+    restore_offset -= gp_reg_size;\n+  }\n+\n+  if (offset == -1) {\n+    addptr(rsp, aligned_size);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":185,"deletions":15,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"asm\/register.hpp\"\n@@ -383,1 +384,1 @@\n-                       Register tmp1, Register tmp2, Register tmp3 = noreg);\n+                       Register tmp1, Register tmp2, Register tmp3);\n@@ -571,3 +572,28 @@\n-  \/\/ Callee saved registers handling\n-  void push_callee_saved_registers();\n-  void pop_callee_saved_registers();\n+private:\n+  \/\/ General purpose and XMM registers potentially clobbered by native code; there\n+  \/\/ is no need for FPU or AVX opmask related methods because C1\/interpreter\n+  \/\/ - we save\/restore FPU state as a whole always\n+  \/\/ - do not care about AVX-512 opmask\n+  static RegSet call_clobbered_gp_registers();\n+  static XMMRegSet call_clobbered_xmm_registers();\n+\n+  void push_set(XMMRegSet set, int offset);\n+  void pop_set(XMMRegSet set, int offset);\n+\n+public:\n+  void push_set(RegSet set, int offset = -1);\n+  void pop_set(RegSet set, int offset = -1);\n+\n+  \/\/ Push and pop everything that might be clobbered by a native\n+  \/\/ runtime call.\n+  \/\/ Only save the lower 64 bits of each vector register.\n+  \/\/ Additonal registers can be excluded in a passed RegSet.\n+  void push_call_clobbered_registers_except(RegSet exclude, bool save_fpu = true);\n+  void pop_call_clobbered_registers_except(RegSet exclude, bool restore_fpu = true);\n+\n+  void push_call_clobbered_registers(bool save_fpu = true) {\n+    push_call_clobbered_registers_except(RegSet(), save_fpu);\n+  }\n+  void pop_call_clobbered_registers(bool restore_fpu = true) {\n+    pop_call_clobbered_registers_except(RegSet(), restore_fpu);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -3269,1 +3269,1 @@\n-  CodeBuffer buffer(name, 1000, 512);\n+  CodeBuffer buffer(name, 1200, 512);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"asm\/assembler.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"register_x86.hpp\"\n@@ -49,0 +51,2 @@\n+#include \"utilities\/macros.hpp\"\n+#include \"vmreg_x86.inline.hpp\"\n@@ -59,0 +63,1 @@\n+\n@@ -813,0 +818,15 @@\n+  address generate_popcount_avx_lut(const char *stub_name) {\n+    __ align64();\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0302020102010100, relocInfo::none);\n+    __ emit_data64(0x0403030203020201, relocInfo::none);\n+    __ emit_data64(0x0302020102010100, relocInfo::none);\n+    __ emit_data64(0x0403030203020201, relocInfo::none);\n+    __ emit_data64(0x0302020102010100, relocInfo::none);\n+    __ emit_data64(0x0403030203020201, relocInfo::none);\n+    __ emit_data64(0x0302020102010100, relocInfo::none);\n+    __ emit_data64(0x0403030203020201, relocInfo::none);\n+    return start;\n+  }\n+\n@@ -7595,0 +7615,4 @@\n+  \/\/ Register is a class, but it would be assigned numerical value.\n+  \/\/ \"0\" is assigned for xmm0. Thus we need to ignore -Wnonnull.\n+  PRAGMA_DIAG_PUSH\n+  PRAGMA_NONNULL_IGNORED\n@@ -7901,0 +7925,5 @@\n+    if (UsePopCountInstruction && VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n+      \/\/ lut implementation influenced by counting 1s algorithm from section 5-1 of Hackers' Delight.\n+      StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut(\"popcount_lut\");\n+    }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -397,1 +397,0 @@\n-  int increment = InvocationCounter::count_increment;\n@@ -408,1 +407,1 @@\n-    __ increment_mask_and_jump(mdo_invocation_counter, increment, mask, rcx, false, Assembler::zero, overflow);\n+    __ increment_mask_and_jump(mdo_invocation_counter, mask, rcx, overflow);\n@@ -418,2 +417,1 @@\n-  __ increment_mask_and_jump(invocation_counter, increment, mask, rcx,\n-      false, Assembler::zero, overflow);\n+  __ increment_mask_and_jump(invocation_counter, mask, rcx, overflow);\n@@ -722,1 +720,2 @@\n-  \/\/ Quick & dirty stack overflow checking: bang the stack & handle trap.\n+  \/\/ See more discussion in stackOverflow.hpp.\n+\n@@ -728,1 +727,1 @@\n-  \/\/ method receiever, so do the banging after locking the receiver.)\n+  \/\/ method receiver, so do the banging after locking the receiver.)\n@@ -730,3 +729,1 @@\n-  \/\/ Bang each page in the shadow zone. We can't assume it's been done for\n-  \/\/ an interpreter frame with greater than a page of locals, so each page\n-  \/\/ needs to be checked.  Only true for non-native.\n+  const int shadow_zone_size = checked_cast<int>(StackOverflow::stack_shadow_zone_size());\n@@ -734,4 +731,29 @@\n-  const int n_shadow_pages = ((int)StackOverflow::stack_shadow_zone_size()) \/ page_size;\n-  const int start_page = native_call ? n_shadow_pages : 1;\n-  for (int pages = start_page; pages <= n_shadow_pages; pages++) {\n-    __ bang_stack_with_offset(pages*page_size);\n+  const int n_shadow_pages = shadow_zone_size \/ page_size;\n+\n+  const Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);\n+#ifndef _LP64\n+  __ push(thread);\n+  __ get_thread(thread);\n+#endif\n+\n+#ifdef ASSERT\n+  Label L_good_limit;\n+  __ cmpptr(Address(thread, JavaThread::shadow_zone_safe_limit()), (int32_t)NULL_WORD);\n+  __ jcc(Assembler::notEqual, L_good_limit);\n+  __ stop(\"shadow zone safe limit is not initialized\");\n+  __ bind(L_good_limit);\n+\n+  Label L_good_watermark;\n+  __ cmpptr(Address(thread, JavaThread::shadow_zone_growth_watermark()), (int32_t)NULL_WORD);\n+  __ jcc(Assembler::notEqual, L_good_watermark);\n+  __ stop(\"shadow zone growth watermark is not initialized\");\n+  __ bind(L_good_watermark);\n+#endif\n+\n+  Label L_done;\n+\n+  __ cmpptr(rsp, Address(thread, JavaThread::shadow_zone_growth_watermark()));\n+  __ jcc(Assembler::above, L_done);\n+\n+  for (int p = 1; p <= n_shadow_pages; p++) {\n+    __ bang_stack_with_offset(p*page_size);\n@@ -739,0 +761,12 @@\n+\n+  \/\/ Record the new watermark, but only if update is above the safe limit.\n+  \/\/ Otherwise, the next time around the check above would pass the safe limit.\n+  __ cmpptr(rsp, Address(thread, JavaThread::shadow_zone_safe_limit()));\n+  __ jccb(Assembler::belowEqual, L_done);\n+  __ movptr(Address(thread, JavaThread::shadow_zone_growth_watermark()), rsp);\n+\n+  __ bind(L_done);\n+\n+#ifndef _LP64\n+  __ pop(thread);\n+#endif\n@@ -1711,1 +1745,1 @@\n-      __ jmp(L);\n+      __ jmpb(L);\n@@ -1714,1 +1748,1 @@\n-      __ jmp(L);\n+      __ jmpb(L);\n@@ -1718,1 +1752,1 @@\n-      __ jmp(L);\n+      __ jmpb(L);\n@@ -1721,1 +1755,1 @@\n-      __ jmp(L);\n+      __ jmpb(L);\n@@ -1725,1 +1759,1 @@\n-      __ jmp(L);\n+      __ jmpb(L);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":53,"deletions":19,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-  __ store_heap_oop(dst, val, rdx, rbx, noreg, decorators);\n+  __ store_heap_oop(dst, val, rdx, rbx, LP64_ONLY(r8) NOT_LP64(rsi), decorators);\n@@ -531,1 +531,1 @@\n-      __ jcc(Assembler::notEqual, notInt);\n+      __ jccb(Assembler::notEqual, notInt);\n@@ -539,1 +539,1 @@\n-      __ jcc(Assembler::notEqual, notFloat);\n+      __ jccb(Assembler::notEqual, notFloat);\n@@ -547,1 +547,1 @@\n-      __ jcc(Assembler::notEqual, notShort);\n+      __ jccb(Assembler::notEqual, notShort);\n@@ -555,1 +555,1 @@\n-      __ jcc(Assembler::notEqual, notByte);\n+      __ jccb(Assembler::notEqual, notByte);\n@@ -563,1 +563,1 @@\n-      __ jcc(Assembler::notEqual, notChar);\n+      __ jccb(Assembler::notEqual, notChar);\n@@ -571,1 +571,1 @@\n-      __ jcc(Assembler::notEqual, notBool);\n+      __ jccb(Assembler::notEqual, notBool);\n@@ -585,1 +585,1 @@\n-      __ jcc(Assembler::notEqual, notLong);\n+      __ jccb(Assembler::notEqual, notLong);\n@@ -595,1 +595,1 @@\n-      __ jcc(Assembler::notEqual, notDouble);\n+      __ jccb(Assembler::notEqual, notDouble);\n@@ -1091,1 +1091,1 @@\n-                     rax, noreg, noreg);\n+                     rax, noreg, noreg, noreg);\n@@ -1105,1 +1105,1 @@\n-                     noreg \/* ltos *\/, noreg, noreg);\n+                     noreg \/* ltos *\/, noreg, noreg, noreg);\n@@ -1119,1 +1119,1 @@\n-                     noreg \/* ftos *\/, noreg, noreg);\n+                     noreg \/* ftos *\/, noreg, noreg, noreg);\n@@ -1132,1 +1132,1 @@\n-                     noreg \/* dtos *\/, noreg, noreg);\n+                     noreg \/* dtos *\/, noreg, noreg, noreg);\n@@ -1265,1 +1265,1 @@\n-                     rax, noreg, noreg);\n+                     rax, noreg, noreg, noreg);\n@@ -1278,1 +1278,1 @@\n-                     rax, noreg, noreg);\n+                     rax, noreg, noreg, noreg);\n@@ -2276,1 +2276,0 @@\n-    int increment = InvocationCounter::count_increment;\n@@ -2286,1 +2285,1 @@\n-      __ increment_mask_and_jump(mdo_backedge_counter, increment, mask, rax, false, Assembler::zero,\n+      __ increment_mask_and_jump(mdo_backedge_counter, mask, rax,\n@@ -2294,2 +2293,2 @@\n-    __ increment_mask_and_jump(Address(rcx, be_offset), increment, mask,\n-        rax, false, Assembler::zero, UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n+    __ increment_mask_and_jump(Address(rcx, be_offset), mask, rax,\n+        UseOnStackReplacement ? &backedge_counter_overflow : NULL);\n@@ -3348,1 +3347,1 @@\n-    __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);\n+    __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg, noreg);\n@@ -3363,1 +3362,1 @@\n-    __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);\n+    __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg, noreg);\n@@ -3446,1 +3445,1 @@\n-    __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);\n+    __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg, noreg);\n@@ -3461,1 +3460,1 @@\n-    __ access_store_at(T_CHAR, IN_HEAP, field, rax, noreg, noreg);\n+    __ access_store_at(T_CHAR, IN_HEAP, field, rax, noreg, noreg, noreg);\n@@ -3476,1 +3475,1 @@\n-    __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);\n+    __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg, noreg);\n@@ -3492,1 +3491,1 @@\n-    __ access_store_at(T_LONG, IN_HEAP | MO_RELAXED, field, noreg \/* ltos*\/, noreg, noreg);\n+    __ access_store_at(T_LONG, IN_HEAP | MO_RELAXED, field, noreg \/* ltos*\/, noreg, noreg, noreg);\n@@ -3509,1 +3508,1 @@\n-    __ access_store_at(T_FLOAT, IN_HEAP, field, noreg \/* ftos *\/, noreg, noreg);\n+    __ access_store_at(T_FLOAT, IN_HEAP, field, noreg \/* ftos *\/, noreg, noreg, noreg);\n@@ -3528,1 +3527,1 @@\n-    __ access_store_at(T_DOUBLE, IN_HEAP | MO_RELAXED, field, noreg \/* dtos *\/, noreg, noreg);\n+    __ access_store_at(T_DOUBLE, IN_HEAP | MO_RELAXED, field, noreg \/* dtos *\/, noreg, noreg, noreg);\n@@ -3702,1 +3701,1 @@\n-    __ access_store_at(T_LONG, IN_HEAP, field, noreg \/* ltos *\/, noreg, noreg);\n+    __ access_store_at(T_LONG, IN_HEAP, field, noreg \/* ltos *\/, noreg, noreg, noreg);\n@@ -3708,1 +3707,1 @@\n-    __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);\n+    __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg, noreg);\n@@ -3711,1 +3710,1 @@\n-    __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);\n+    __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg, noreg);\n@@ -3714,1 +3713,1 @@\n-    __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);\n+    __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg, noreg);\n@@ -3717,1 +3716,1 @@\n-    __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);\n+    __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg, noreg);\n@@ -3720,1 +3719,1 @@\n-    __ access_store_at(T_CHAR, IN_HEAP, field, rax, noreg, noreg);\n+    __ access_store_at(T_CHAR, IN_HEAP, field, rax, noreg, noreg, noreg);\n@@ -3723,1 +3722,1 @@\n-    __ access_store_at(T_FLOAT, IN_HEAP, field, noreg \/* ftos*\/, noreg, noreg);\n+    __ access_store_at(T_FLOAT, IN_HEAP, field, noreg \/* ftos*\/, noreg, noreg, noreg);\n@@ -3726,1 +3725,1 @@\n-    __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg \/* dtos*\/, noreg, noreg);\n+    __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg \/* dtos*\/, noreg, noreg, noreg);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":34,"deletions":35,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1821,3 +1821,0 @@\n-  if (FLAG_IS_DEFAULT(PrefetchFieldsAhead)) {\n-    FLAG_SET_DEFAULT(PrefetchFieldsAhead, 1);\n-  }\n@@ -1886,3 +1883,0 @@\n-    if (PrefetchFieldsAhead > 0) {\n-      log->print_cr(\"PrefetchFieldsAhead %d\", (int) PrefetchFieldsAhead);\n-    }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1408,0 +1408,4 @@\n+      if (!UsePopCountInstruction || (UseAVX < 2)) {\n+        return false;\n+      }\n+      break;\n@@ -1409,1 +1413,1 @@\n-      if (!UsePopCountInstruction || !VM_Version::supports_avx512_vpopcntdq()) {\n+      if (!UsePopCountInstruction || (UseAVX <= 2)) {\n@@ -1460,0 +1464,3 @@\n+    case Op_VectorUCastB2X:\n+    case Op_VectorUCastS2X:\n+    case Op_VectorUCastI2X:\n@@ -1861,0 +1868,12 @@\n+    case Op_PopCountVI:\n+      if (!VM_Version::supports_avx512_vpopcntdq() &&\n+          (vlen == 16) && !VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+      break;\n+    case Op_PopCountVL:\n+      if (!VM_Version::supports_avx512_vpopcntdq() &&\n+          ((vlen <= 4) || ((vlen == 8) && !VM_Version::supports_avx512bw()))) {\n+        return false;\n+      }\n+      break;\n@@ -2555,9 +2574,15 @@\n-static inline jlong replicate8_imm(int con, int width) {\n-  \/\/ Load a constant of \"width\" (in bytes) and replicate it to fill 64bit.\n-  assert(width == 1 || width == 2 || width == 4, \"only byte, short or int types here\");\n-  int bit_width = width * 8;\n-  jlong val = con;\n-  val &= (((jlong) 1) << bit_width) - 1;  \/\/ mask off sign bits\n-  while(bit_width < 64) {\n-    val |= (val << bit_width);\n-    bit_width <<= 1;\n+template <class T>\n+static inline GrowableArray<jvalue>* vreplicate_imm(BasicType bt, T con, int len) {\n+  GrowableArray<jvalue>* val = new GrowableArray<jvalue>(len);\n+  jvalue ele;\n+  switch (bt) {\n+    case T_BYTE:   ele.b = con; break;\n+    case T_SHORT:  ele.s = con; break;\n+    case T_INT:    ele.i = con; break;\n+    case T_LONG:   ele.j = con; break;\n+    case T_FLOAT:  ele.f = con; break;\n+    case T_DOUBLE: ele.d = con; break;\n+    default: ShouldNotReachHere();\n+  }\n+  for (int i = 0; i < len; i++) {\n+    val->append(ele);\n@@ -3839,8 +3864,1 @@\n-    switch (Matcher::vector_length_in_bytes(this)) {\n-      case  4: __ movdl    ($dst$$XMMRegister, $mem$$Address); break;\n-      case  8: __ movq     ($dst$$XMMRegister, $mem$$Address); break;\n-      case 16: __ movdqu   ($dst$$XMMRegister, $mem$$Address); break;\n-      case 32: __ vmovdqu  ($dst$$XMMRegister, $mem$$Address); break;\n-      case 64: __ evmovdqul($dst$$XMMRegister, $mem$$Address, Assembler::AVX_512bit); break;\n-      default: ShouldNotReachHere();\n-    }\n+    __ load_vector($dst$$XMMRegister, $mem$$Address, Matcher::vector_length_in_bytes(this));\n@@ -4024,16 +4042,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 1));\n-    if (vlen == 4) {\n-      __ movdl($dst$$XMMRegister, const_addr);\n-    } else {\n-      __ movq($dst$$XMMRegister, const_addr);\n-      if (vlen >= 16) {\n-        if (VM_Version::supports_avx2()) {\n-          int vlen_enc = vector_length_encoding(this);\n-          __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-        } else {\n-          assert(vlen == 16, \"sanity\");\n-          __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-        }\n-      }\n-    }\n+    InternalAddress addr = $constantaddress(T_BYTE, vreplicate_imm(T_BYTE, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n@@ -4044,17 +4048,0 @@\n-\/\/ Replicate byte scalar zero to be vector\n-instruct ReplB_zero(vec dst, immI_0 zero) %{\n-  match(Set dst (ReplicateB zero));\n-  format %{ \"replicateB $dst,$zero\" %}\n-  ins_encode %{\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 16) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      \/\/ Use vpxor since AVX512F does not have 512bit vxorpd (requires AVX512DQ).\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n@@ -4106,31 +4093,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 2));\n-    if (vlen == 2) {\n-      __ movdl($dst$$XMMRegister, const_addr);\n-    } else {\n-      __ movq($dst$$XMMRegister, const_addr);\n-      if (vlen >= 8) {\n-        if (VM_Version::supports_avx2()) {\n-          int vlen_enc = vector_length_encoding(this);\n-          __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-        } else {\n-          assert(vlen == 8, \"sanity\");\n-          __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-        }\n-      }\n-    }\n-  %}\n-  ins_pipe( fpu_reg_reg );\n-%}\n-\n-instruct ReplS_zero(vec dst, immI_0 zero) %{\n-  match(Set dst (ReplicateS zero));\n-  format %{ \"replicateS $dst,$zero\" %}\n-  ins_encode %{\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 8) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n+    InternalAddress addr = $constantaddress(T_SHORT, vreplicate_imm(T_SHORT, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n@@ -4138,1 +4096,1 @@\n-  ins_pipe( fpu_reg_reg );\n+  ins_pipe( pipe_slow );\n@@ -4188,13 +4146,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 4));\n-    if (vlen <= 4) {\n-      __ movq($dst$$XMMRegister, const_addr);\n-      if (vlen == 4) {\n-        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-      }\n-    } else {\n-      assert(VM_Version::supports_avx2(), \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n-      __ movq($dst$$XMMRegister, const_addr);\n-      __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n+    InternalAddress addr = $constantaddress(T_INT, vreplicate_imm(T_INT, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n@@ -4205,1 +4152,1 @@\n-\/\/ Replicate integer (4 byte) scalar zero to be vector\n+\/\/ Replicate scalar zero to be vector\n@@ -4207,0 +4154,2 @@\n+  match(Set dst (ReplicateB zero));\n+  match(Set dst (ReplicateS zero));\n@@ -4210,2 +4159,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 4) {\n+    uint vsize = Matcher::vector_length_in_bytes(this);\n+    if (vsize <= 16) {\n@@ -4342,11 +4291,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    InternalAddress const_addr = $constantaddress($con);\n-    if (vlen == 2) {\n-      __ movq($dst$$XMMRegister, const_addr);\n-      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      assert(VM_Version::supports_avx2(), \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n-      __ movq($dst$$XMMRegister, const_addr);\n-      __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n+    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n@@ -4422,0 +4362,11 @@\n+\/\/ Replicate float scalar immediate to be vector by loading from const table.\n+instruct ReplF_imm(vec dst, immF con) %{\n+  match(Set dst (ReplicateF con));\n+  format %{ \"replicateF $dst,$con\" %}\n+  ins_encode %{\n+    InternalAddress addr = $constantaddress(T_FLOAT, vreplicate_imm(T_FLOAT, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4476,0 +4427,11 @@\n+\/\/ Replicate double (8 byte) scalar immediate to be vector by loading from const table.\n+instruct ReplD_imm(vec dst, immD con) %{\n+  match(Set dst (ReplicateD con));\n+  format %{ \"replicateD $dst,$con\" %}\n+  ins_encode %{\n+    InternalAddress addr = $constantaddress(T_DOUBLE, vreplicate_imm(T_DOUBLE, $con$$constant, Matcher::vector_length(this)));\n+    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7283,0 +7245,16 @@\n+instruct vucast(vec dst, vec src) %{\n+  match(Set dst (VectorUCastB2X src));\n+  match(Set dst (VectorUCastS2X src));\n+  match(Set dst (VectorUCastI2X src));\n+  format %{ \"vector_ucast $dst,$src\\t!\" %}\n+  ins_encode %{\n+    assert(UseAVX > 0, \"required\");\n+\n+    BasicType from_elem_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_unsigned_cast($dst$$XMMRegister, $src$$XMMRegister, vlen_enc, from_elem_bt, to_elem_bt);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -8624,1 +8602,2 @@\n-instruct vpopcountI(vec dst, vec src) %{\n+instruct vpopcountI_popcntd(vec dst, vec src) %{\n+  predicate(VM_Version::supports_avx512_vpopcntdq());\n@@ -8626,1 +8605,1 @@\n-  format %{ \"vpopcntd  $dst,$src\\t! vector popcount packedI\" %}\n+  format %{ \"vector_popcount_int $dst, $src\\t! vector popcount packedI\" %}\n@@ -8629,0 +8608,5 @@\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_popcount_int($dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg, noreg, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -8630,0 +8614,7 @@\n+instruct vpopcountI(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp, rFlagsReg cc) %{\n+  predicate(!VM_Version::supports_avx512_vpopcntdq());\n+  match(Set dst (PopCountVI src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, KILL cc);\n+  format %{ \"vector_popcount_int  $dst, $src\\t! using $xtmp1, $xtmp2, $xtmp3, and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"not enabled\");\n@@ -8631,1 +8622,2 @@\n-    __ vpopcntd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ vector_popcount_int($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n+                           $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n@@ -8636,1 +8628,2 @@\n-instruct vpopcountL(vec dst, vec src) %{\n+instruct vpopcountL_popcntd(vec dst, vec src) %{\n+  predicate(VM_Version::supports_avx512_vpopcntdq());\n@@ -8638,1 +8631,1 @@\n-  format %{ \"vpopcntq  $dst,$src\\t! vector popcount packedL\" %}\n+  format %{ \"vector_popcount_long  $dst, $src\\t! vector popcount packedL\" %}\n@@ -8641,3 +8634,4 @@\n-\n-    __ vpopcntq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-    __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    __ vector_popcount_long($dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg, noreg, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -8646,0 +8640,10 @@\n+instruct vpopcountL(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp, rFlagsReg cc) %{\n+  predicate(!VM_Version::supports_avx512_vpopcntdq());\n+  match(Set dst (PopCountVL src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, KILL cc);\n+  format %{ \"vector_popcount_long  $dst, $src\\t! using $xtmp1, $xtmp2, $xtmp3, and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"not enabled\");\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    __ vector_popcount_long($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n+                           $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":122,"deletions":118,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -7825,1 +7825,1 @@\n-instruct divL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{\n+instruct divL_eReg(eADXRegL dst, eRegL src1, eRegL src2) %{\n@@ -7827,1 +7827,1 @@\n-  effect( KILL cr, KILL cx, KILL bx );\n+  effect(CALL);\n@@ -7873,1 +7873,1 @@\n-instruct modL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{\n+instruct modL_eReg(eADXRegL dst, eRegL src1, eRegL src2) %{\n@@ -7875,1 +7875,1 @@\n-  effect( KILL cr, KILL cx, KILL bx );\n+  effect(CALL);\n@@ -12122,2 +12122,2 @@\n-instruct has_negatives(eSIRegP ary1, eCXRegI len, eAXRegI result,\n-                      regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)\n+instruct count_positives(eSIRegP ary1, eCXRegI len, eAXRegI result,\n+                         regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)\n@@ -12126,1 +12126,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -12129,1 +12129,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -12131,3 +12131,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n@@ -12138,2 +12138,2 @@\n-instruct has_negatives_evex(eSIRegP ary1, eCXRegI len, eAXRegI result,\n-                           regD tmp1, regD tmp2, kReg ktmp1, kReg ktmp2, eBXRegI tmp3, eFlagsReg cr)\n+instruct count_positives_evex(eSIRegP ary1, eCXRegI len, eAXRegI result,\n+                              regD tmp1, regD tmp2, kReg ktmp1, kReg ktmp2, eBXRegI tmp3, eFlagsReg cr)\n@@ -12142,1 +12142,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -12145,1 +12145,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -12147,3 +12147,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,0 +244,5 @@\n+\/\/ Class for all long registers (excluding RBP and R13)\n+reg_class long_no_rbp_r13_reg %{\n+  return _LONG_NO_RBP_R13_REG_mask;\n+%}\n+\n@@ -259,0 +264,5 @@\n+\/\/ Class for all int registers (excluding RBP and R13)\n+reg_class int_no_rbp_r13_reg %{\n+  return _INT_NO_RBP_R13_REG_mask;\n+%}\n+\n@@ -322,0 +332,1 @@\n+extern RegMask _LONG_NO_RBP_R13_REG_mask;\n@@ -325,0 +336,1 @@\n+extern RegMask _INT_NO_RBP_R13_REG_mask;\n@@ -351,0 +363,1 @@\n+RegMask _LONG_NO_RBP_R13_REG_mask;\n@@ -354,0 +367,1 @@\n+RegMask _INT_NO_RBP_R13_REG_mask;\n@@ -412,0 +426,6 @@\n+  _LONG_NO_RBP_R13_REG_mask = _LONG_REG_mask;\n+  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()->next()));\n+  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n+  _LONG_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()->next()));\n+\n@@ -430,0 +450,4 @@\n+  _INT_NO_RBP_R13_REG_mask = _INT_REG_mask;\n+  _INT_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(rbp->as_VMReg()));\n+  _INT_NO_RBP_R13_REG_mask.Remove(OptoReg::as_OptoReg(r13->as_VMReg()));\n+\n@@ -1928,1 +1952,1 @@\n-    __ cmp(as_Register(RAX_enc), 0x80000000);\n+    __ cmpl(as_Register(RAX_enc), 0x80000000);\n@@ -3493,0 +3517,15 @@\n+operand no_rbp_r13_RegI()\n+%{\n+  constraint(ALLOC_IN_RC(int_no_rbp_r13_reg));\n+  match(RegI);\n+  match(rRegI);\n+  match(rax_RegI);\n+  match(rbx_RegI);\n+  match(rcx_RegI);\n+  match(rdx_RegI);\n+  match(rdi_RegI);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -3720,0 +3759,13 @@\n+operand no_rbp_r13_RegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_no_rbp_r13_reg));\n+  match(RegL);\n+  match(rRegL);\n+  match(rax_RegL);\n+  match(rcx_RegL);\n+  match(rdx_RegL);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -7474,1 +7526,1 @@\n-instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)\n+instruct leaI_rReg_immI2_immI(rRegI dst, rRegI index, immI2 scale, immI disp)\n@@ -7476,1 +7528,2 @@\n-  match(Set dst (AddI src0 src1));\n+  predicate(VM_Version::supports_fast_2op_lea());\n+  match(Set dst (AddI (LShiftI index scale) disp));\n@@ -7478,2 +7531,14 @@\n-  ins_cost(110);\n-  format %{ \"addr32 leal $dst, [$src0 + $src1]\\t# int\" %}\n+  format %{ \"leal $dst, [$index << $scale + $disp]\\t# int\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leal($dst$$Register, Address(noreg, $index$$Register, scale, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaI_rReg_rReg_immI(rRegI dst, rRegI base, rRegI index, immI disp)\n+%{\n+  predicate(VM_Version::supports_fast_3op_lea());\n+  match(Set dst (AddI (AddI base index) disp));\n+\n+  format %{ \"leal $dst, [$base + $index + $disp]\\t# int\" %}\n@@ -7481,1 +7546,27 @@\n-    __ leal($dst$$Register, Address($src0$$Register, $src1$$constant));\n+    __ leal($dst$$Register, Address($base$$Register, $index$$Register, Address::times_1, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaI_rReg_rReg_immI2(rRegI dst, no_rbp_r13_RegI base, rRegI index, immI2 scale)\n+%{\n+  predicate(VM_Version::supports_fast_2op_lea());\n+  match(Set dst (AddI base (LShiftI index scale)));\n+\n+  format %{ \"leal $dst, [$base + $index << $scale]\\t# int\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leal($dst$$Register, Address($base$$Register, $index$$Register, scale));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaI_rReg_rReg_immI2_immI(rRegI dst, rRegI base, rRegI index, immI2 scale, immI disp)\n+%{\n+  predicate(VM_Version::supports_fast_3op_lea());\n+  match(Set dst (AddI (AddI base (LShiftI index scale)) disp));\n+\n+  format %{ \"leal $dst, [$base + $index << $scale + $disp]\\t# int\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leal($dst$$Register, Address($base$$Register, $index$$Register, scale, $disp$$constant));\n@@ -7605,1 +7696,1 @@\n-instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)\n+instruct leaL_rReg_immI2_immL32(rRegL dst, rRegL index, immI2 scale, immL32 disp)\n@@ -7607,1 +7698,2 @@\n-  match(Set dst (AddL src0 src1));\n+  predicate(VM_Version::supports_fast_2op_lea());\n+  match(Set dst (AddL (LShiftL index scale) disp));\n@@ -7609,2 +7701,39 @@\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, [$src0 + $src1]\\t# long\" %}\n+  format %{ \"leaq $dst, [$index << $scale + $disp]\\t# long\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leaq($dst$$Register, Address(noreg, $index$$Register, scale, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaL_rReg_rReg_immL32(rRegL dst, rRegL base, rRegL index, immL32 disp)\n+%{\n+  predicate(VM_Version::supports_fast_3op_lea());\n+  match(Set dst (AddL (AddL base index) disp));\n+\n+  format %{ \"leaq $dst, [$base + $index + $disp]\\t# long\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, Address($base$$Register, $index$$Register, Address::times_1, $disp$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaL_rReg_rReg_immI2(rRegL dst, no_rbp_r13_RegL base, rRegL index, immI2 scale)\n+%{\n+  predicate(VM_Version::supports_fast_2op_lea());\n+  match(Set dst (AddL base (LShiftL index scale)));\n+\n+  format %{ \"leaq $dst, [$base + $index << $scale]\\t# long\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leaq($dst$$Register, Address($base$$Register, $index$$Register, scale));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct leaL_rReg_rReg_immI2_immL32(rRegL dst, rRegL base, rRegL index, immI2 scale, immL32 disp)\n+%{\n+  predicate(VM_Version::supports_fast_3op_lea());\n+  match(Set dst (AddL (AddL base (LShiftL index scale)) disp));\n+\n+  format %{ \"leaq $dst, [$base + $index << $scale + $disp]\\t# long\" %}\n@@ -7612,1 +7741,2 @@\n-    __ leaq($dst$$Register, Address($src0$$Register, $src1$$constant));\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($scale$$constant);\n+    __ leaq($dst$$Register, Address($base$$Register, $index$$Register, scale, $disp$$constant));\n@@ -7643,12 +7773,0 @@\n-instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)\n-%{\n-  match(Set dst (AddP src0 src1));\n-\n-  ins_cost(110);\n-  format %{ \"leaq    $dst, [$src0 + $src1]\\t# ptr\" %}\n-  ins_encode %{\n-    __ leaq($dst$$Register, Address($src0$$Register, $src1$$constant));\n-  %}\n-  ins_pipe(ialu_reg_reg);\n-%}\n-\n@@ -11928,2 +12046,2 @@\n-instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n-                       legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr,)\n+instruct count_positives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n+                         legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr,)\n@@ -11932,1 +12050,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -11935,1 +12053,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -11937,3 +12055,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n@@ -11944,2 +12062,2 @@\n-instruct has_negatives_evex(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n-                            legRegD tmp1, legRegD tmp2, kReg ktmp1, kReg ktmp2, rbx_RegI tmp3, rFlagsReg cr,)\n+instruct count_positives_evex(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n+                              legRegD tmp1, legRegD tmp2, kReg ktmp1, kReg ktmp2, rbx_RegI tmp3, rFlagsReg cr,)\n@@ -11948,1 +12066,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -11951,1 +12069,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -11953,3 +12071,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":156,"deletions":38,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -615,1 +615,1 @@\n-        strcmp(_matrule->_rChild->_opType,\"HasNegatives\" )==0 ||\n+        strcmp(_matrule->_rChild->_opType,\"CountPositives\" )==0 ||\n@@ -906,1 +906,1 @@\n-        strcmp(_matrule->_rChild->_opType,\"HasNegatives\")==0 ||\n+        strcmp(_matrule->_rChild->_opType,\"CountPositives\")==0 ||\n@@ -1370,1 +1370,1 @@\n-    uniq_idx = (uint*) AllocateHeap(sizeof(uint) * _uniq_idx_length);\n+    uniq_idx = (uint*) AdlAllocateHeap(sizeof(uint) * _uniq_idx_length);\n@@ -3480,1 +3480,1 @@\n-  subtree = (char *)AllocateHeap(len);\n+  subtree = (char *)AdlAllocateHeap(len);\n@@ -3930,1 +3930,1 @@\n-  char* buf = (char*) AllocateHeap(strlen(instr_ident) + 4);\n+  char* buf = (char*) AdlAllocateHeap(strlen(instr_ident) + 4);\n@@ -4238,0 +4238,1 @@\n+    \"VectorUCastB2X\", \"VectorUCastS2X\", \"VectorUCastI2X\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-  JavaThread* _thread;\n@@ -563,0 +562,1 @@\n+, _has_irreducible_loops(false)\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  bool               _has_irreducible_loops;\n@@ -140,0 +141,1 @@\n+  bool has_irreducible_loops() const             { return _has_irreducible_loops; }\n@@ -167,0 +169,1 @@\n+  void set_has_irreducible_loops(bool f)         { _has_irreducible_loops = f; }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -63,1 +64,1 @@\n-  intArray       _loop_map;            \/\/ caches the information if a block is contained in a loop\n+  GrowableArray<ResourceBitMap> _loop_map; \/\/ caches the information if a block is contained in a loop\n@@ -88,1 +89,1 @@\n-  int  mark_loops(BlockBegin* b, bool in_subroutine);\n+  BitMap& mark_loops(BlockBegin* b, bool in_subroutine);\n@@ -380,1 +381,4 @@\n-  _loop_map = intArray(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), 0);\n+  _loop_map = GrowableArray<ResourceBitMap>(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), ResourceBitMap());\n+  for (int i = 0; i < BlockBegin::number_of_blocks(); i++) {\n+    _loop_map.at(i).initialize(BlockBegin::number_of_blocks());\n+  }\n@@ -384,2 +388,17 @@\n-  \/\/ recursively iterate the control flow graph\n-  mark_loops(_bci2block->at(0), false);\n+  \/\/ The loop detection algorithm works as follows:\n+  \/\/ - We maintain the _loop_map, where for each block we have a bitmap indicating which loops contain this block.\n+  \/\/ - The CFG is recursively traversed (depth-first) and if we detect a loop, we assign the loop a unique number that is stored\n+  \/\/ in the bitmap associated with the loop header block. Until we return back through that loop header the bitmap contains\n+  \/\/ only a single bit corresponding to the loop number.\n+  \/\/ -  The bit is then propagated for all the blocks in the loop after we exit them (post-order). There could be multiple bits\n+  \/\/ of course in case of nested loops.\n+  \/\/ -  When we exit the loop header we remove that single bit and assign the real loop state for it.\n+  \/\/ -  Now, the tricky part here is how we detect irriducible loops. In the algorithm above the loop state bits\n+  \/\/ are propagated to the predecessors. If we encounter an irreducible loop (a loop with multiple heads) we would see\n+  \/\/ a node with some loop bit set that would then propagate back and be never cleared because we would\n+  \/\/ never go back through the original loop header. Therefore if there are any irreducible loops the bits in the states\n+  \/\/ for these loops are going to propagate back to the root.\n+  BitMap& loop_state = mark_loops(_bci2block->at(0), false);\n+  if (!loop_state.is_empty()) {\n+    compilation()->set_has_irreducible_loops(true);\n+  }\n@@ -391,0 +410,1 @@\n+  _loop_map.clear();\n@@ -402,4 +422,3 @@\n-    assert(_loop_map.at(block->block_id()) == 0, \"must not be set yet\");\n-    assert(0 <= _next_loop_index && _next_loop_index < BitsPerInt, \"_next_loop_index is used as a bit-index in integer\");\n-    _loop_map.at_put(block->block_id(), 1 << _next_loop_index);\n-    if (_next_loop_index < 31) _next_loop_index++;\n+    assert(_loop_map.at(block->block_id()).is_empty(), \"must not be set yet\");\n+    assert(0 <= _next_loop_index && _next_loop_index < BlockBegin::number_of_blocks(), \"_next_loop_index is too large\");\n+    _loop_map.at(block->block_id()).set_bit(_next_loop_index++);\n@@ -408,1 +427,1 @@\n-    assert(is_power_of_2((unsigned int)_loop_map.at(block->block_id())), \"exactly one bit must be set\");\n+    assert(_loop_map.at(block->block_id()).count_one_bits() == 1, \"exactly one bit must be set\");\n@@ -412,1 +431,1 @@\n-int BlockListBuilder::mark_loops(BlockBegin* block, bool in_subroutine) {\n+BitMap& BlockListBuilder::mark_loops(BlockBegin* block, bool in_subroutine) {\n@@ -414,1 +433,0 @@\n-\n@@ -432,1 +450,2 @@\n-  intptr_t loop_state = 0;\n+  ResourceMark rm;\n+  ResourceBitMap loop_state(BlockBegin::number_of_blocks());\n@@ -435,1 +454,1 @@\n-    loop_state |= mark_loops(successor_at(block, i), in_subroutine);\n+    loop_state.set_union(mark_loops(successor_at(block, i), in_subroutine));\n@@ -445,1 +464,1 @@\n-  if (loop_state != 0 || in_subroutine ) {\n+  if (!loop_state.is_empty() || in_subroutine ) {\n@@ -452,8 +471,4 @@\n-    int header_loop_state = _loop_map.at(block_id);\n-    assert(is_power_of_2((unsigned)header_loop_state), \"exactly one bit must be set\");\n-\n-    \/\/ If the highest bit is set (i.e. when integer value is negative), the method\n-    \/\/ has 32 or more loops. This bit is never cleared because it is used for multiple loops\n-    if (header_loop_state >= 0) {\n-      clear_bits(loop_state, header_loop_state);\n-    }\n+    BitMap& header_loop_state = _loop_map.at(block_id);\n+    assert(header_loop_state.count_one_bits() == 1, \"exactly one bit must be set\");\n+    \/\/ remove the bit with the loop number for the state (header is outside of the loop)\n+    loop_state.set_difference(header_loop_state);\n@@ -463,2 +478,2 @@\n-  _loop_map.at_put(block_id, loop_state);\n-  return loop_state;\n+  _loop_map.at(block_id).set_from(loop_state);\n+  return _loop_map.at(block_id);\n@@ -932,5 +947,1 @@\n-  if (con.basic_type() == T_ILLEGAL) {\n-    \/\/ FIXME: an unresolved Dynamic constant can get here,\n-    \/\/ and that should not terminate the whole compilation.\n-    BAILOUT(\"could not resolve a constant\");\n-  } else {\n+  if (con.is_valid()) {\n@@ -940,11 +951,10 @@\n-      case T_BOOLEAN: t = new IntConstant     (con.as_boolean()); break;\n-      case T_BYTE   : t = new IntConstant     (con.as_byte   ()); break;\n-      case T_CHAR   : t = new IntConstant     (con.as_char   ()); break;\n-      case T_SHORT  : t = new IntConstant     (con.as_short  ()); break;\n-      case T_INT    : t = new IntConstant     (con.as_int    ()); break;\n-      case T_LONG   : t = new LongConstant    (con.as_long   ()); break;\n-      case T_FLOAT  : t = new FloatConstant   (con.as_float  ()); break;\n-      case T_DOUBLE : t = new DoubleConstant  (con.as_double ()); break;\n-      case T_ARRAY  : t = new ArrayConstant   (con.as_object ()->as_array   ()); break;\n-      case T_OBJECT :\n-       {\n+      case T_BOOLEAN: t = new IntConstant   (con.as_boolean()); break;\n+      case T_BYTE   : t = new IntConstant   (con.as_byte   ()); break;\n+      case T_CHAR   : t = new IntConstant   (con.as_char   ()); break;\n+      case T_SHORT  : t = new IntConstant   (con.as_short  ()); break;\n+      case T_INT    : t = new IntConstant   (con.as_int    ()); break;\n+      case T_LONG   : t = new LongConstant  (con.as_long   ()); break;\n+      case T_FLOAT  : t = new FloatConstant (con.as_float  ()); break;\n+      case T_DOUBLE : t = new DoubleConstant(con.as_double ()); break;\n+      case T_ARRAY  : \/\/ fall-through\n+      case T_OBJECT : {\n@@ -952,4 +962,2 @@\n-        if (!obj->is_loaded()\n-            || (PatchALot && obj->klass() != ciEnv::current()->String_klass())) {\n-          \/\/ A Class, MethodType, MethodHandle, or String.\n-          \/\/ Unloaded condy nodes show up as T_ILLEGAL, above.\n+        if (!obj->is_loaded() || (PatchALot && (obj->is_null_object() || obj->klass() != ciEnv::current()->String_klass()))) {\n+          \/\/ A Class, MethodType, MethodHandle, Dynamic, or String.\n@@ -961,1 +969,1 @@\n-          if (obj->is_null_object())\n+          if (obj->is_null_object()) {\n@@ -963,1 +971,1 @@\n-          else if (obj->is_array())\n+          } else if (obj->is_array()) {\n@@ -965,1 +973,1 @@\n-          else\n+          } else {\n@@ -967,0 +975,1 @@\n+          }\n@@ -969,2 +978,2 @@\n-       }\n-      default       : ShouldNotReachHere();\n+      }\n+      default: ShouldNotReachHere();\n@@ -974,1 +983,2 @@\n-      x = new Constant(t, patch_state);\n+      bool kills_memory = stream()->is_dynamic_constant(); \/\/ arbitrary memory effects from running BSM during linkage\n+      x = new Constant(t, patch_state, kills_memory);\n@@ -978,0 +988,18 @@\n+\n+    \/\/ Unbox the value at runtime, if needed.\n+    \/\/ ConstantDynamic entry can be of a primitive type, but it is cached in boxed form.\n+    if (patch_state != NULL) {\n+      int index = stream()->get_constant_pool_index();\n+      BasicType type = stream()->get_basic_type_for_constant_at(index);\n+      if (is_java_primitive(type)) {\n+        ciInstanceKlass* box_klass = ciEnv::current()->get_box_klass_for_primitive_type(type);\n+        assert(box_klass->is_loaded(), \"sanity\");\n+        int offset = java_lang_boxing_object::value_offset(type);\n+        ciField* value_field = box_klass->get_field_by_offset(offset, false \/*is_static*\/);\n+        x = new LoadField(append(x), offset, value_field, false \/*is_static*\/, patch_state, false \/*needs_patching*\/);\n+        t = as_ValueType(type);\n+      } else {\n+        assert(is_reference_type(type), \"not a reference: %s\", type2name(type));\n+      }\n+    }\n+\n@@ -979,0 +1007,2 @@\n+  } else {\n+    BAILOUT(\"could not resolve a constant\");\n@@ -2871,1 +2901,1 @@\n-        if (!entry->try_merge(cur_state)) {\n+        if (!entry->try_merge(cur_state, compilation()->has_irreducible_loops())) {\n@@ -3359,1 +3389,1 @@\n-    if (!sux->try_merge(end->state())) BAILOUT_(\"block join failed\", NULL);\n+    if (!sux->try_merge(end->state(), compilation()->has_irreducible_loops())) BAILOUT_(\"block join failed\", NULL);\n@@ -3513,1 +3543,1 @@\n-    base->std_entry()->merge(state);\n+    base->std_entry()->merge(state, compilation()->has_irreducible_loops());\n@@ -3596,1 +3626,1 @@\n-  target->merge(_osr_entry->end()->state());\n+  target->merge(_osr_entry->end()->state(), compilation()->has_irreducible_loops());\n@@ -3658,1 +3688,1 @@\n-  start_block->merge(_initial_state);\n+  start_block->merge(_initial_state, compilation->has_irreducible_loops());\n@@ -4409,1 +4439,1 @@\n-    callee_start_block->merge(callee_state);\n+    callee_start_block->merge(callee_state, compilation()->has_irreducible_loops());\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":87,"deletions":57,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -855,1 +855,1 @@\n-bool BlockBegin::try_merge(ValueStack* new_state) {\n+bool BlockBegin::try_merge(ValueStack* new_state, bool has_irreducible_loops) {\n@@ -896,1 +896,0 @@\n-\n@@ -899,1 +898,1 @@\n-        if (requires_phi || !SelectivePhiFunctions) {\n+        if (requires_phi || !SelectivePhiFunctions || has_irreducible_loops) {\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -390,0 +390,1 @@\n+    KillsMemoryFlag,\n@@ -755,1 +756,1 @@\n-  Constant(ValueType* type, ValueStack* state_before):\n+  Constant(ValueType* type, ValueStack* state_before, bool kills_memory = false):\n@@ -760,2 +761,2 @@\n-    \/\/ since it's patching it needs to be pinned\n-    pin();\n+    set_flag(KillsMemoryFlag, kills_memory);\n+    pin(); \/\/ since it's patching it needs to be pinned\n@@ -773,0 +774,2 @@\n+  bool kills_memory() const { return check_flag(KillsMemoryFlag); }\n+\n@@ -1916,2 +1919,5 @@\n-  bool try_merge(ValueStack* state);             \/\/ try to merge states at block begin\n-  void merge(ValueStack* state)                  { bool b = try_merge(state); assert(b, \"merge failed\"); }\n+  bool try_merge(ValueStack* state, bool has_irreducible_loops);  \/\/ try to merge states at block begin\n+  void merge(ValueStack* state, bool has_irreducible_loops) {\n+    bool b = try_merge(state, has_irreducible_loops);\n+    assert(b, \"merge failed\");\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-  output()->print(\"%s\", name);\n+  output()->print(\"%s(\", name);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-#include \"gc\/shared\/barrierSet.hpp\"\n@@ -83,0 +82,1 @@\n+      case Bytecodes::_ldc2_w:\n@@ -110,1 +110,0 @@\n- , _bs(BarrierSet::barrier_set())\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-class BarrierSet;\n@@ -42,1 +41,0 @@\n-  BarrierSet*        _bs;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1151,0 +1151,1 @@\n+      case Bytecodes::_ldc2_w:\n@@ -1295,1 +1296,0 @@\n-              assert(mirror() != NULL, \"klass not set\");\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,1 +170,6 @@\n-  void do_Constant       (Constant*        x) { \/* nothing to do *\/ }\n+  void do_Constant       (Constant*        x) {\n+    if (x->kills_memory()) {\n+      assert(x->can_trap(), \"already linked\");\n+      kill_memory();\n+    }\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -520,1 +520,2 @@\n-  } else if (ref->msotype() == MetaspaceObj::MethodDataType) {\n+  } else if (ref->msotype() == MetaspaceObj::MethodDataType ||\n+             ref->msotype() == MetaspaceObj::MethodCountersType) {\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1033,0 +1033,11 @@\n+bool FileMapInfo::check_module_paths() {\n+  const char* rp = Arguments::get_property(\"jdk.module.path\");\n+  int num_paths = Arguments::num_archives(rp);\n+  if (num_paths != header()->num_module_paths()) {\n+    return false;\n+  }\n+  ResourceMark rm;\n+  GrowableArray<const char*>* rp_array = create_path_array(rp);\n+  return check_paths(header()->app_module_paths_start_index(), num_paths, rp_array);\n+}\n+\n@@ -1055,3 +1066,5 @@\n-      DynamicDumpSharedSpaces = false;\n-      warning(\n-        \"Dynamic archiving is disabled because base layer archive has module path\");\n+      if (!check_module_paths()) {\n+        DynamicDumpSharedSpaces = false;\n+        warning(\n+          \"Dynamic archiving is disabled because base layer archive has a different module path\");\n+      }\n@@ -1165,0 +1178,3 @@\n+    if (_header != nullptr) {\n+      FREE_C_HEAP_ARRAY(char, _header);\n+    }\n@@ -2055,1 +2071,1 @@\n-      log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC or UseSerialGC are required.\");\n+      log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC or UseParallelGC are required.\");\n@@ -2229,0 +2245,9 @@\n+  if (_heap_pointers_need_patching) {\n+    char* bitmap_base = map_bitmap_region();\n+    if (bitmap_base == NULL) {\n+      log_info(cds)(\"CDS heap cannot be used because bitmap region cannot be mapped\");\n+      _heap_pointers_need_patching = false;\n+      return;\n+    }\n+  }\n+\n@@ -2358,3 +2383,1 @@\n-  if (bitmap_base == NULL) {\n-    return;\n-  }\n+  assert(bitmap_base != NULL, \"must have already been mapped\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+  bool check_module_paths();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsHeapVerifier.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"logging\/logMessage.hpp\"\n@@ -146,5 +146,18 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/\n-\/\/ Java heap object archiving support\n-\/\/\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+static bool is_subgraph_root_class_of(ArchivableStaticFieldInfo fields[], int num, InstanceKlass* ik) {\n+  for (int i = 0; i < num; i++) {\n+    if (fields[i].klass == ik) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool HeapShared::is_subgraph_root_class(InstanceKlass* ik) {\n+  return is_subgraph_root_class_of(closed_archive_subgraph_entry_fields,\n+                                   num_closed_archive_subgraph_entry_fields, ik) ||\n+         is_subgraph_root_class_of(open_archive_subgraph_entry_fields,\n+                                   num_open_archive_subgraph_entry_fields, ik) ||\n+         is_subgraph_root_class_of(fmg_open_archive_subgraph_entry_fields,\n+                                   num_fmg_open_archive_subgraph_entry_fields, ik);\n+}\n+\n@@ -209,1 +222,1 @@\n-  oop* p = cache->get(obj);\n+  CachedOopInfo* p = cache->get(obj);\n@@ -211,1 +224,1 @@\n-    return *p;\n+    return p->_obj;\n@@ -310,1 +323,2 @@\n-    cache->put(obj, archived_oop);\n+    CachedOopInfo info = make_cached_oop_info(archived_oop);\n+    cache->put(obj, info);\n@@ -344,0 +358,88 @@\n+\/\/ -- Handling of Enum objects\n+\/\/ Java Enum classes have synthetic <clinit> methods that look like this\n+\/\/     enum MyEnum {FOO, BAR}\n+\/\/     MyEnum::<clinint> {\n+\/\/        \/*static final MyEnum*\/ MyEnum::FOO = new MyEnum(\"FOO\");\n+\/\/        \/*static final MyEnum*\/ MyEnum::BAR = new MyEnum(\"BAR\");\n+\/\/     }\n+\/\/\n+\/\/ If MyEnum::FOO object is referenced by any of the archived subgraphs, we must\n+\/\/ ensure the archived value equals (in object address) to the runtime value of\n+\/\/ MyEnum::FOO.\n+\/\/\n+\/\/ However, since MyEnum::<clinint> is synthetically generated by javac, there's\n+\/\/ no way of programatically handling this inside the Java code (as you would handle\n+\/\/ ModuleLayer::EMPTY_LAYER, for example).\n+\/\/\n+\/\/ Instead, we archive all static field of such Enum classes. At runtime,\n+\/\/ HeapShared::initialize_enum_klass() will skip the <clinit> method and pull\n+\/\/ the static fields out of the archived heap.\n+void HeapShared::check_enum_obj(int level,\n+                                KlassSubGraphInfo* subgraph_info,\n+                                oop orig_obj,\n+                                bool is_closed_archive) {\n+  Klass* k = orig_obj->klass();\n+  Klass* relocated_k = ArchiveBuilder::get_relocated_klass(k);\n+  if (!k->is_instance_klass()) {\n+    return;\n+  }\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  if (ik->java_super() == vmClasses::Enum_klass() && !ik->has_archived_enum_objs()) {\n+    ResourceMark rm;\n+    ik->set_has_archived_enum_objs();\n+    relocated_k->set_has_archived_enum_objs();\n+    oop mirror = ik->java_mirror();\n+\n+    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        if (fd.field_type() != T_OBJECT && fd.field_type() != T_ARRAY) {\n+          guarantee(false, \"static field %s::%s must be T_OBJECT or T_ARRAY\",\n+                    ik->external_name(), fd.name()->as_C_string());\n+        }\n+        oop oop_field = mirror->obj_field(fd.offset());\n+        if (oop_field == NULL) {\n+          guarantee(false, \"static field %s::%s must not be null\",\n+                    ik->external_name(), fd.name()->as_C_string());\n+        } else if (oop_field->klass() != ik && oop_field->klass() != ik->array_klass_or_null()) {\n+          guarantee(false, \"static field %s::%s is of the wrong type\",\n+                    ik->external_name(), fd.name()->as_C_string());\n+        }\n+        oop archived_oop_field = archive_reachable_objects_from(level, subgraph_info, oop_field, is_closed_archive);\n+        int root_index = append_root(archived_oop_field);\n+        log_info(cds, heap)(\"Archived enum obj @%d %s::%s (\" INTPTR_FORMAT \" -> \" INTPTR_FORMAT \")\",\n+                            root_index, ik->external_name(), fd.name()->as_C_string(),\n+                            p2i((oopDesc*)oop_field), p2i((oopDesc*)archived_oop_field));\n+        SystemDictionaryShared::add_enum_klass_static_field(ik, root_index);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ See comments in HeapShared::check_enum_obj()\n+bool HeapShared::initialize_enum_klass(InstanceKlass* k, TRAPS) {\n+  if (!is_fully_available()) {\n+    return false;\n+  }\n+\n+  RunTimeClassInfo* info = RunTimeClassInfo::get_for(k);\n+  assert(info != NULL, \"sanity\");\n+\n+  if (log_is_enabled(Info, cds, heap)) {\n+    ResourceMark rm;\n+    log_info(cds, heap)(\"Initializing Enum class: %s\", k->external_name());\n+  }\n+\n+  oop mirror = k->java_mirror();\n+  int i = 0;\n+  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      int root_index = info->enum_klass_static_field_root_index_at(i++);\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      assert(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY, \"must be\");\n+      mirror->obj_field_put(fd.offset(), get_root(root_index, \/*clear=*\/true));\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -385,0 +487,1 @@\n+    CDSHeapVerifier::verify();\n@@ -479,1 +582,1 @@\n-    _dump_time_subgraph_info_table->put_if_absent(relocated_k, KlassSubGraphInfo(relocated_k, is_full_module_graph),\n+    _dump_time_subgraph_info_table->put_if_absent(k, KlassSubGraphInfo(relocated_k, is_full_module_graph),\n@@ -487,2 +590,1 @@\n-  Klass* relocated_k = ArchiveBuilder::get_relocated_klass(k);\n-  KlassSubGraphInfo* info = _dump_time_subgraph_info_table->get(relocated_k);\n+  KlassSubGraphInfo* info = _dump_time_subgraph_info_table->get(k);\n@@ -649,1 +751,2 @@\n-      unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary((address)klass);\n+      Klass* relocated_k = ArchiveBuilder::get_relocated_klass(klass);\n+      unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary((address)relocated_k);\n@@ -911,0 +1014,5 @@\n+\n+  \/\/ The following are for maintaining a stack for determining\n+  \/\/ CachedOopInfo::_referrer\n+  static WalkOopAndArchiveClosure* _current;\n+  WalkOopAndArchiveClosure* _last;\n@@ -920,1 +1028,7 @@\n-    _orig_referencing_obj(orig), _archived_referencing_obj(archived) {}\n+    _orig_referencing_obj(orig), _archived_referencing_obj(archived) {\n+    _last = _current;\n+    _current = this;\n+  }\n+  ~WalkOopAndArchiveClosure() {\n+    _current = _last;\n+  }\n@@ -957,0 +1071,5 @@\n+\n+ public:\n+  static WalkOopAndArchiveClosure* current()  { return _current;              }\n+  oop orig_referencing_obj()                  { return _orig_referencing_obj; }\n+  KlassSubGraphInfo* subgraph_info()          { return _subgraph_info;        }\n@@ -959,0 +1078,13 @@\n+WalkOopAndArchiveClosure* WalkOopAndArchiveClosure::_current = NULL;\n+\n+HeapShared::CachedOopInfo HeapShared::make_cached_oop_info(oop orig_obj) {\n+  CachedOopInfo info;\n+  WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n+\n+  info._subgraph_info = (walker == NULL) ? NULL : walker->subgraph_info();\n+  info._referrer = (walker == NULL) ? NULL : walker->orig_referencing_obj();\n+  info._obj = orig_obj;\n+\n+  return info;\n+}\n+\n@@ -1084,0 +1216,2 @@\n+\n+  check_enum_obj(level + 1, subgraph_info, orig_obj, is_closed_archive);\n@@ -1687,0 +1821,4 @@\n+  if (bitmap_base == 0) {\n+    _loading_failed = true;\n+    return false; \/\/ OOM or CRC error\n+  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":152,"deletions":14,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -419,2 +419,2 @@\n-        constantTag tag = s.get_constant_pool_tag(index);\n-        if (tag.is_long() || tag.is_double()) {\n+        BasicType con_bt = s.get_basic_type_for_constant_at(index);\n+        if (con_bt == T_LONG || con_bt == T_DOUBLE) {\n@@ -423,1 +423,1 @@\n-        } else if (tag.basic_type() == T_OBJECT) {\n+        } else if (con_bt == T_OBJECT) {\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -396,0 +396,17 @@\n+ciInstanceKlass* ciEnv::get_box_klass_for_primitive_type(BasicType type) {\n+  switch (type) {\n+    case T_BOOLEAN: return Boolean_klass();\n+    case T_BYTE   : return Byte_klass();\n+    case T_CHAR   : return Character_klass();\n+    case T_SHORT  : return Short_klass();\n+    case T_INT    : return Integer_klass();\n+    case T_LONG   : return Long_klass();\n+    case T_FLOAT  : return Float_klass();\n+    case T_DOUBLE : return Double_klass();\n+\n+    default:\n+      assert(false, \"not a primitive: %s\", type2name(type));\n+      return NULL;\n+  }\n+}\n+\n@@ -507,7 +524,0 @@\n-  \/\/ setup up the proper type to return on OOM\n-  ciKlass* fail_type;\n-  if (sym->char_at(0) == JVM_SIGNATURE_ARRAY) {\n-    fail_type = _unloaded_ciobjarrayklass;\n-  } else {\n-    fail_type = _unloaded_ciinstance_klass;\n-  }\n@@ -613,1 +623,0 @@\n-  EXCEPTION_CONTEXT;\n@@ -688,0 +697,57 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciEnv::unbox_primitive_value\n+\/\/\n+\/\/ Unbox a primitive and return it as a ciConstant.\n+ciConstant ciEnv::unbox_primitive_value(ciObject* cibox, BasicType expected_bt) {\n+  jvalue value;\n+  BasicType bt = java_lang_boxing_object::get_value(cibox->get_oop(), &value);\n+  if (bt != expected_bt && expected_bt != T_ILLEGAL) {\n+    assert(false, \"type mismatch: %s vs %s\", type2name(expected_bt), cibox->klass()->name()->as_klass_external_name());\n+    return ciConstant();\n+  }\n+  switch (bt) {\n+    case T_BOOLEAN: return ciConstant(bt, value.z);\n+    case T_BYTE:    return ciConstant(bt, value.b);\n+    case T_SHORT:   return ciConstant(bt, value.s);\n+    case T_CHAR:    return ciConstant(bt, value.c);\n+    case T_INT:     return ciConstant(bt, value.i);\n+    case T_LONG:    return ciConstant(value.j);\n+    case T_FLOAT:   return ciConstant(value.f);\n+    case T_DOUBLE:  return ciConstant(value.d);\n+\n+    default:\n+      assert(false, \"not a primitive type: %s\", type2name(bt));\n+      return ciConstant();\n+  }\n+}\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciEnv::get_resolved_constant\n+\/\/\n+ciConstant ciEnv::get_resolved_constant(const constantPoolHandle& cpool, int obj_index) {\n+  assert(obj_index >= 0, \"\");\n+  oop obj = cpool->resolved_references()->obj_at(obj_index);\n+  if (obj == NULL) {\n+    \/\/ Unresolved constant. It is resolved when the corresponding slot contains a non-null reference.\n+    \/\/ Null constant is represented as a sentinel (non-null) value.\n+    return ciConstant();\n+  } else if (obj == Universe::the_null_sentinel()) {\n+    return ciConstant(T_OBJECT, get_object(NULL));\n+  } else {\n+    ciObject* ciobj = get_object(obj);\n+    if (ciobj->is_array()) {\n+      return ciConstant(T_ARRAY, ciobj);\n+    } else {\n+      int cp_index = cpool->object_to_cp_index(obj_index);\n+      BasicType bt = cpool->basic_type_for_constant_at(cp_index);\n+      if (is_java_primitive(bt)) {\n+        assert(cpool->tag_at(cp_index).is_dynamic_constant(), \"sanity\");\n+        return unbox_primitive_value(ciobj, bt);\n+      } else {\n+        assert(ciobj->is_instance(), \"should be an instance\");\n+        return ciConstant(T_OBJECT, ciobj);\n+      }\n+    }\n+  }\n+}\n+\n@@ -693,1 +759,1 @@\n-                                             int pool_index, int cache_index,\n+                                             int index, int obj_index,\n@@ -696,39 +762,4 @@\n-  EXCEPTION_CONTEXT;\n-  int index = pool_index;\n-  if (cache_index >= 0) {\n-    assert(index < 0, \"only one kind of index at a time\");\n-    index = cpool->object_to_cp_index(cache_index);\n-    oop obj = cpool->resolved_references()->obj_at(cache_index);\n-    if (obj != NULL) {\n-      if (obj == Universe::the_null_sentinel()) {\n-        return ciConstant(T_OBJECT, get_object(NULL));\n-      }\n-      BasicType bt = T_OBJECT;\n-      if (cpool->tag_at(index).is_dynamic_constant())\n-        bt = Signature::basic_type(cpool->uncached_signature_ref_at(index));\n-      if (is_reference_type(bt)) {\n-      } else {\n-        \/\/ we have to unbox the primitive value\n-        if (!is_java_primitive(bt))  return ciConstant();\n-        jvalue value;\n-        BasicType bt2 = java_lang_boxing_object::get_value(obj, &value);\n-        assert(bt2 == bt, \"\");\n-        switch (bt2) {\n-        case T_DOUBLE:  return ciConstant(value.d);\n-        case T_FLOAT:   return ciConstant(value.f);\n-        case T_LONG:    return ciConstant(value.j);\n-        case T_INT:     return ciConstant(bt2, value.i);\n-        case T_SHORT:   return ciConstant(bt2, value.s);\n-        case T_BYTE:    return ciConstant(bt2, value.b);\n-        case T_CHAR:    return ciConstant(bt2, value.c);\n-        case T_BOOLEAN: return ciConstant(bt2, value.z);\n-        default:  return ciConstant();\n-        }\n-      }\n-      ciObject* ciobj = get_object(obj);\n-      if (ciobj->is_array()) {\n-        return ciConstant(T_ARRAY, ciobj);\n-      } else {\n-        assert(ciobj->is_instance(), \"should be an instance\");\n-        return ciConstant(T_OBJECT, ciobj);\n-      }\n+  if (obj_index >= 0) {\n+    ciConstant con = get_resolved_constant(cpool, obj_index);\n+    if (con.is_valid()) {\n+      return con;\n@@ -747,3 +778,3 @@\n-    oop string = NULL;\n-    assert(cache_index >= 0, \"should have a cache index\");\n-    string = cpool->string_at(index, cache_index, THREAD);\n+    EXCEPTION_CONTEXT;\n+    assert(obj_index >= 0, \"should have an object index\");\n+    oop string = cpool->string_at(index, obj_index, THREAD);\n@@ -755,7 +786,2 @@\n-    ciObject* constant = get_object(string);\n-    if (constant->is_array()) {\n-      return ciConstant(T_ARRAY, constant);\n-    } else {\n-      assert (constant->is_instance(), \"must be an instance, or not? \");\n-      return ciConstant(T_OBJECT, constant);\n-    }\n+    ciInstance* constant = get_object(string)->as_instance();\n+    return ciConstant(T_OBJECT, constant);\n@@ -763,1 +789,1 @@\n-    return ciConstant();\n+    return ciConstant(T_OBJECT, get_unloaded_klass_mirror(NULL));\n@@ -765,8 +791,0 @@\n-    \/\/ 4881222: allow ldc to take a class type\n-    if (HAS_PENDING_EXCEPTION) {\n-      CLEAR_PENDING_EXCEPTION;\n-      record_out_of_memory_failure();\n-      return ciConstant();\n-    }\n-    assert (klass->is_instance_klass() || klass->is_array_klass(),\n-            \"must be an instance or array klass \");\n@@ -782,1 +800,1 @@\n-  } else if (tag.is_method_type()) {\n+  } else if (tag.is_method_type() || tag.is_method_type_in_error()) {\n@@ -785,0 +803,1 @@\n+    assert(obj_index >= 0, \"should have an object index\");\n@@ -788,1 +807,1 @@\n-  } else if (tag.is_method_handle()) {\n+  } else if (tag.is_method_handle() || tag.is_method_handle_in_error()) {\n@@ -790,0 +809,1 @@\n+    assert(obj_index >= 0, \"should have an object index\");\n@@ -797,2 +817,3 @@\n-  } else if (tag.is_dynamic_constant()) {\n-    return ciConstant();\n+  } else if (tag.is_dynamic_constant() || tag.is_dynamic_constant_in_error()) {\n+    assert(obj_index >= 0, \"should have an object index\");\n+    return ciConstant(T_OBJECT, unloaded_ciinstance()); \/\/ unresolved dynamic constant\n@@ -800,1 +821,1 @@\n-    ShouldNotReachHere();\n+    assert(false, \"unknown tag: %d (%s)\", tag.value(), tag.internal_name());\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":93,"deletions":72,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -170,0 +170,3 @@\n+  ciConstant unbox_primitive_value(ciObject* cibox, BasicType expected_bt = T_ILLEGAL);\n+  ciConstant get_resolved_constant(const constantPoolHandle& cpool, int obj_index);\n+\n@@ -438,0 +441,2 @@\n+  ciInstanceKlass* get_box_klass_for_primitive_type(BasicType type);\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -568,1 +568,1 @@\n-ciInstance* ciObjectFactory::get_unloaded_klass_mirror(ciKlass*  type) {\n+ciInstance* ciObjectFactory::get_unloaded_klass_mirror(ciKlass* type) {\n@@ -583,1 +583,1 @@\n-  if (ciEnv::_MethodHandle_klass == NULL)  return NULL;\n+  assert(ciEnv::_MethodHandle_klass != NULL, \"\");\n@@ -594,1 +594,1 @@\n-  if (ciEnv::_MethodType_klass == NULL)  return NULL;\n+  assert(ciEnv::_MethodType_klass != NULL, \"\");\n@@ -599,1 +599,1 @@\n-  if (ciEnv::_Object_klass == NULL)  return NULL;\n+  assert(ciEnv::_Object_klass != NULL, \"\");\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -244,0 +244,2 @@\n+  VM_ENTRY_MARK;\n+  constantPoolHandle cpool(THREAD, _method->get_Method()->constants());\n@@ -248,1 +250,6 @@\n-    pool_index = -1;\n+    pool_index = cpool->object_to_cp_index(cache_index);\n+  } else if (cpool->tag_at(pool_index).is_dynamic_constant() ||\n+             cpool->tag_at(pool_index).is_dynamic_constant_in_error()) {\n+    \/\/ Condy with primitive type is not quickened, so the index into resolved reference cache should be reconstructed.\n+    assert(is_java_primitive(cpool->basic_type_for_constant_at(pool_index)), \"not quickened\");\n+    cache_index = cpool->cp_to_object_index(pool_index);\n@@ -250,2 +257,0 @@\n-  VM_ENTRY_MARK;\n-  constantPoolHandle cpool(THREAD, _method->get_Method()->constants());\n@@ -266,0 +271,16 @@\n+\/\/ ciBytecodeStream::get_raw_pool_tag\n+\/\/\n+constantTag ciBytecodeStream::get_raw_pool_tag(int index) const {\n+  VM_ENTRY_MARK;\n+  return _method->get_Method()->constants()->tag_at(index);\n+}\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciBytecodeStream::get_basic_type_for_constant_at\n+\/\/\n+BasicType ciBytecodeStream::get_basic_type_for_constant_at(int index) const {\n+  VM_ENTRY_MARK;\n+  return _method->get_Method()->constants()->basic_type_for_constant_at(index);\n+}\n+\n+\/\/ ------------------------------------------------------------------\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  \/\/ Does this instruction contain an index which refes into the CP cache?\n+  \/\/ Does this instruction contain an index which refers into the CP cache?\n@@ -230,1 +230,1 @@\n-  ciConstant get_constant();\n+  ciConstant  get_constant();\n@@ -232,0 +232,3 @@\n+  BasicType   get_basic_type_for_constant_at(int index) const;\n+\n+  constantTag get_raw_pool_tag(int index) const;\n@@ -239,3 +242,22 @@\n-  bool is_unresolved_klass_in_error() const {\n-    constantTag tag = get_constant_pool_tag(get_klass_index());\n-    return tag.is_unresolved_klass_in_error();\n+  bool is_dynamic_constant() const {\n+    assert(cur_bc() == Bytecodes::_ldc    ||\n+           cur_bc() == Bytecodes::_ldc_w  ||\n+           cur_bc() == Bytecodes::_ldc2_w, \"not supported: %s\", Bytecodes::name(cur_bc()));\n+\n+    int index = get_constant_pool_index();\n+    constantTag tag = get_raw_pool_tag(index);\n+    return tag.is_dynamic_constant() ||\n+           tag.is_dynamic_constant_in_error();\n+  }\n+\n+  bool is_in_error() const {\n+    assert(cur_bc() == Bytecodes::_ldc    ||\n+           cur_bc() == Bytecodes::_ldc_w  ||\n+           cur_bc() == Bytecodes::_ldc2_w, \"not supported: %s\", Bytecodes::name(cur_bc()));\n+\n+    int index = get_constant_pool_index();\n+    constantTag tag = get_constant_pool_tag(index);\n+    return tag.is_unresolved_klass_in_error() ||\n+           tag.is_method_handle_in_error()    ||\n+           tag.is_method_type_in_error()      ||\n+           tag.is_dynamic_constant_in_error();\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -790,0 +790,5 @@\n+  if (str->is_in_error()) {\n+    trap(str, NULL, Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n+                                                      Deoptimization::Action_none));\n+    return;\n+  }\n@@ -792,1 +797,2 @@\n-    BasicType basic_type = con.basic_type();\n+    int index = str->get_constant_pool_index();\n+    BasicType basic_type = str->get_basic_type_for_constant_at(index);\n@@ -806,0 +812,2 @@\n+      assert(basic_type == con.basic_type() || con.basic_type() == T_OBJECT,\n+             \"not a boxed form: %s vs %s\", type2name(basic_type), type2name(con.basic_type()));\n@@ -809,8 +817,3 @@\n-    if (str->is_unresolved_klass_in_error()) {\n-      trap(str, NULL, Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n-                                                        Deoptimization::Action_none));\n-    } else {\n-      \/\/ OutOfMemoryError in the CI while loading constant\n-      push_null();\n-      outer()->record_failure(\"ldc did not link\");\n-    }\n+    \/\/ OutOfMemoryError in the CI while loading a String constant.\n+    push_null();\n+    outer()->record_failure(\"ldc did not link\");\n@@ -2288,1 +2291,1 @@\n-      return str.is_unresolved_klass_in_error();\n+      return str.is_in_error();\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2898,0 +2898,1 @@\n+                                     _cp->symbol_at(name_index),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -102,1 +102,2 @@\n-int ClassLoader::_libzip_loaded = 0;\n+int    ClassLoader::_libzip_loaded          = 0;\n+void*  ClassLoader::_zip_handle             = NULL;\n@@ -945,2 +946,1 @@\n-  void* handle = NULL;\n-    handle = os::dll_load(path, ebuf, sizeof ebuf);\n+    _zip_handle = os::dll_load(path, ebuf, sizeof ebuf);\n@@ -949,1 +949,1 @@\n-  if (handle == NULL) {\n+  if (_zip_handle == NULL) {\n@@ -953,6 +953,6 @@\n-  ZipOpen = CAST_TO_FN_PTR(ZipOpen_t, dll_lookup(handle, \"ZIP_Open\", path));\n-  ZipClose = CAST_TO_FN_PTR(ZipClose_t, dll_lookup(handle, \"ZIP_Close\", path));\n-  FindEntry = CAST_TO_FN_PTR(FindEntry_t, dll_lookup(handle, \"ZIP_FindEntry\", path));\n-  ReadEntry = CAST_TO_FN_PTR(ReadEntry_t, dll_lookup(handle, \"ZIP_ReadEntry\", path));\n-  GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, dll_lookup(handle, \"ZIP_GetNextEntry\", path));\n-  Crc32 = CAST_TO_FN_PTR(Crc32_t, dll_lookup(handle, \"ZIP_CRC32\", path));\n+  ZipOpen = CAST_TO_FN_PTR(ZipOpen_t, dll_lookup(_zip_handle, \"ZIP_Open\", path));\n+  ZipClose = CAST_TO_FN_PTR(ZipClose_t, dll_lookup(_zip_handle, \"ZIP_Close\", path));\n+  FindEntry = CAST_TO_FN_PTR(FindEntry_t, dll_lookup(_zip_handle, \"ZIP_FindEntry\", path));\n+  ReadEntry = CAST_TO_FN_PTR(ReadEntry_t, dll_lookup(_zip_handle, \"ZIP_ReadEntry\", path));\n+  GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, dll_lookup(_zip_handle, \"ZIP_GetNextEntry\", path));\n+  Crc32 = CAST_TO_FN_PTR(Crc32_t, dll_lookup(_zip_handle, \"ZIP_CRC32\", path));\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -4169,2 +4169,6 @@\n-  for (int i = 0, limit = pts->length(); i < limit; i++) {\n-    java_lang_Class::print_signature(pts->obj_at(i), st);\n+  if (pts != NULL) {\n+    for (int i = 0, limit = pts->length(); i < limit; i++) {\n+      java_lang_Class::print_signature(pts->obj_at(i), st);\n+    }\n+  } else {\n+    st->print(\"NULL\");\n@@ -4173,1 +4177,6 @@\n-  java_lang_Class::print_signature(rtype(mt), st);\n+  oop rt = rtype(mt);\n+  if (rt != NULL) {\n+    java_lang_Class::print_signature(rt, st);\n+  } else {\n+    st->print(\"NULL\");\n+  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1639,2 +1639,2 @@\n-\/\/ Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Compile_lock\n-\/\/ is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in\n+\/\/ Update hierarchy. This is done before the new klass has been added to the SystemDictionary. The Compile_lock\n+\/\/ is held, to ensure that the compiler is not using the class hierarchy, and that deoptimization will kick in\n@@ -1654,1 +1654,1 @@\n-  \/\/ Link into hierachy.\n+  \/\/ Link into hierarchy.\n@@ -1804,1 +1804,1 @@\n-\/\/ Update class loader data dictionary - done after check_constraint and add_to_hierachy\n+\/\/ Update class loader data dictionary - done after check_constraint and add_to_hierarchy\n@@ -2098,1 +2098,1 @@\n-    if (!Arguments::is_interpreter_only()) {\n+    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n@@ -2100,0 +2100,1 @@\n+      \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n@@ -2162,3 +2163,3 @@\n-                                                          Klass* accessing_klass,\n-                                                          Handle *appendix_result,\n-                                                          TRAPS) {\n+                                                     Klass* accessing_klass,\n+                                                     Handle* appendix_result,\n+                                                     TRAPS) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,0 +142,1 @@\n+  do_klass(Enum_klass,                                  java_lang_Enum                                        ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-    case vmIntrinsics::_hasNegatives:\n+    case vmIntrinsics::_countPositives:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -361,3 +361,3 @@\n-  do_intrinsic(_hasNegatives,             java_lang_StringCoding, hasNegatives_name, hasNegatives_signature,     F_S)   \\\n-   do_name(     hasNegatives_name,                               \"hasNegatives\")                                        \\\n-   do_signature(hasNegatives_signature,                          \"([BII)Z\")                                             \\\n+  do_intrinsic(_countPositives,     java_lang_StringCoding, countPositives_name, countPositives_signature, F_S)         \\\n+   do_name(     countPositives_name,                       \"countPositives\")                                            \\\n+   do_signature(countPositives_signature,                  \"([BII)I\")                                                   \\\n@@ -466,1 +466,1 @@\n-  do_intrinsic(_digestBase_implCompressMB, sun_security_provider_digestbase, implCompressMB_name, implCompressMB_signature, F_R)   \\\n+  do_intrinsic(_digestBase_implCompressMB, sun_security_provider_digestbase, implCompressMB_name, countPositives_signature, F_R)   \\\n@@ -468,1 +468,0 @@\n-   do_signature(implCompressMB_signature,                          \"([BII)I\")                                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -712,0 +712,1 @@\n+  template(java_lang_Enum,                                  \"java\/lang\/Enum\")                                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-  volatile long _stack_traversal_mark;\n+  volatile int64_t _stack_traversal_mark;\n@@ -548,2 +548,2 @@\n-  long  stack_traversal_mark()                    { return _stack_traversal_mark; }\n-  void  set_stack_traversal_mark(long l)          { _stack_traversal_mark = l; }\n+  int64_t stack_traversal_mark()                  { return _stack_traversal_mark; }\n+  void    set_stack_traversal_mark(int64_t l)     { _stack_traversal_mark = l; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-long CompileBroker::_peak_compilation_time         = 0;\n+jlong CompileBroker::_peak_compilation_time        = 0;\n@@ -228,0 +228,2 @@\n+    \/\/ Note: This method can be called from non-Java\/compiler threads to\n+    \/\/ log the global metaspace failure that might affect profiling.\n@@ -232,1 +234,1 @@\n-    log(JavaThread::current(), \"%s\", (const char*)lm);\n+    log(Thread::current(), \"%s\", (const char*)lm);\n@@ -617,2 +619,1 @@\n-    GrowableArray<const char*>* c2_phase_names = new GrowableArray<const char*>(PHASE_NUM_TYPES);\n-      const char* phase_name = CompilerPhaseTypeHelper::to_string((CompilerPhaseType) i);\n+      const char* phase_name = CompilerPhaseTypeHelper::to_description((CompilerPhaseType) i);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -117,1 +117,13 @@\n-bool ParCompactionManager::transfer_from_overflow_stack(ObjArrayTask& task) {\n+inline void ParCompactionManager::publish_and_drain_oop_tasks() {\n+  oop obj;\n+  while (marking_stack()->pop_overflow(obj)) {\n+    if (!marking_stack()->try_push_to_taskqueue(obj)) {\n+      follow_contents(obj);\n+    }\n+  }\n+  while (marking_stack()->pop_local(obj)) {\n+    follow_contents(obj);\n+  }\n+}\n+\n+bool ParCompactionManager::publish_or_pop_objarray_tasks(ObjArrayTask& task) {\n@@ -130,9 +142,1 @@\n-    oop obj;\n-    while (marking_stack()->pop_overflow(obj)) {\n-      if (!marking_stack()->try_push_to_taskqueue(obj)) {\n-        follow_contents(obj);\n-      }\n-    }\n-    while (marking_stack()->pop_local(obj)) {\n-      follow_contents(obj);\n-    }\n+    publish_and_drain_oop_tasks();\n@@ -142,1 +146,2 @@\n-    if (transfer_from_overflow_stack(task) || _objarray_stack.pop_local(task)) {\n+    if (publish_or_pop_objarray_tasks(task) ||\n+        _objarray_stack.pop_local(task)) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -849,28 +849,0 @@\n-class PCReferenceProcessor: public ReferenceProcessor {\n-public:\n-  PCReferenceProcessor(\n-    BoolObjectClosure* is_subject_to_discovery,\n-    BoolObjectClosure* is_alive_non_header) :\n-      ReferenceProcessor(is_subject_to_discovery,\n-      ParallelGCThreads,   \/\/ mt processing degree\n-      ParallelGCThreads,   \/\/ mt discovery degree\n-      true,                \/\/ atomic_discovery\n-      is_alive_non_header) {\n-  }\n-\n-  template<typename T> bool discover(oop obj, ReferenceType type) {\n-    T* referent_addr = (T*) java_lang_ref_Reference::referent_addr_raw(obj);\n-    T heap_oop = RawAccess<>::oop_load(referent_addr);\n-    oop referent = CompressedOops::decode_not_null(heap_oop);\n-    return PSParallelCompact::mark_bitmap()->is_unmarked(referent)\n-        && ReferenceProcessor::discover_reference(obj, type);\n-  }\n-  virtual bool discover_reference(oop obj, ReferenceType type) {\n-    if (UseCompressedOops) {\n-      return discover<narrowOop>(obj, type);\n-    } else {\n-      return discover<oop>(obj, type);\n-    }\n-  }\n-};\n-\n@@ -881,2 +853,5 @@\n-    new PCReferenceProcessor(&_span_based_discoverer,\n-                             &_is_alive_closure); \/\/ non-header is alive closure\n+    new ReferenceProcessor(&_span_based_discoverer,\n+                           ParallelGCThreads,   \/\/ mt processing degree\n+                           ParallelGCThreads,   \/\/ mt discovery degree\n+                           false,               \/\/ concurrent_discovery\n+                           &_is_alive_closure); \/\/ non-header is alive closure\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":5,"deletions":30,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -184,2 +184,1 @@\n-  _totally_drain = (ParallelGCThreads == 1) || (GCDrainStackTargetSize == 0);\n-  if (_totally_drain) {\n+  if (ParallelGCThreads == 1) {\n@@ -231,1 +230,1 @@\n-  totally_drain = totally_drain || _totally_drain;\n+  totally_drain = totally_drain || (_target_stack_size == 0);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -160,0 +160,1 @@\n+  static inline void zap_filler_array_with(HeapWord* start, size_t words, juint value);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n@@ -569,1 +570,1 @@\n-        Op_HasNegatives,\n+        Op_CountPositives,\n@@ -709,1 +710,1 @@\n-    assert(next->unique_ctrl_out() == c || c->is_Proj() || c->is_Region(), \"multiple control flow out but no proj or region?\");\n+    assert(next->unique_ctrl_out_or_null() == c || c->is_Proj() || c->is_Region(), \"multiple control flow out but no proj or region?\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,1 +138,3 @@\n-  return *barrier_set_state()->live(_node);\n+  RegMask* mask = barrier_set_state()->live(_node);\n+  assert(mask != NULL, \"must be mach-node with barrier\");\n+  return *mask;\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,5 +97,0 @@\n-void CallInfo::set_handle(const methodHandle& resolved_method,\n-                          Handle resolved_appendix, TRAPS) {\n-  set_handle(vmClasses::MethodHandle_klass(), resolved_method, resolved_appendix, CHECK);\n-}\n-\n@@ -479,8 +474,6 @@\n-      Handle method_type;\n-      Method* result = SystemDictionary::find_method_handle_invoker(\n-                                                            klass,\n-                                                            name,\n-                                                            full_signature,\n-                                                            link_info.current_klass(),\n-                                                            &appendix,\n-                                                            CHECK_NULL);\n+      Method* result = SystemDictionary::find_method_handle_invoker(klass,\n+                                                                    name,\n+                                                                    full_signature,\n+                                                                    link_info.current_klass(),\n+                                                                    &appendix,\n+                                                                    CHECK_NULL);\n@@ -624,1 +617,1 @@\n-      || (resolved_klass == vmClasses::MethodHandle_klass() &&\n+      || ((resolved_klass == vmClasses::MethodHandle_klass() || resolved_klass == vmClasses::VarHandle_klass()) &&\n@@ -1712,0 +1705,13 @@\n+bool LinkResolver::resolve_previously_linked_invokehandle(CallInfo& result, const LinkInfo& link_info, const constantPoolHandle& pool, int index, TRAPS) {\n+  int cache_index = ConstantPool::decode_cpcache_index(index, true);\n+  ConstantPoolCacheEntry* cpce = pool->cache()->entry_at(cache_index);\n+  if (!cpce->is_f1_null()) {\n+    Klass* resolved_klass = link_info.resolved_klass();\n+    methodHandle method(THREAD, cpce->f1_as_method());\n+    Handle     appendix(THREAD, cpce->appendix_if_resolved(pool));\n+    result.set_handle(resolved_klass, method, appendix, CHECK_false);\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n@@ -1714,1 +1720,0 @@\n-  \/\/ This guy is reached from InterpreterRuntime::resolve_invokehandle.\n@@ -1721,0 +1726,4 @@\n+  { \/\/ Check if the call site has been bound already, and short circuit:\n+    bool is_done = resolve_previously_linked_invokehandle(result, link_info, pool, index, CHECK);\n+    if (is_done) return;\n+  }\n@@ -1732,1 +1741,1 @@\n-  Handle       resolved_appendix;\n+  Handle resolved_appendix;\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -69,2 +69,0 @@\n-  void set_handle(const methodHandle& resolved_method,\n-                  Handle resolved_appendix, TRAPS);\n@@ -252,0 +250,5 @@\n+  static bool resolve_previously_linked_invokehandle(CallInfo& result,\n+                                                     const LinkInfo& link_info,\n+                                                     const constantPoolHandle& pool,\n+                                                     int index, TRAPS);\n+\n@@ -340,1 +343,0 @@\n- public:\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,2 +279,2 @@\n-  Log(interpreter, oopmap) logv;\n-  LogStream st(logv.trace());\n+  const bool log = log_is_enabled(Trace, interpreter, oopmap);\n+  LogStream st(Log(interpreter, oopmap)::trace());\n@@ -282,1 +282,1 @@\n-  st.print(\"Locals (%d): \", max_locals);\n+  if (log) st.print(\"Locals (%d): \", max_locals);\n@@ -287,1 +287,1 @@\n-    st.print(\"%d\", v1 ? 1 : 0);\n+    if (log) st.print(\"%d\", v1 ? 1 : 0);\n@@ -289,1 +289,1 @@\n-  st.cr();\n+  if (log) st.cr();\n@@ -291,1 +291,1 @@\n-  st.print(\"Stack (%d): \", stack_top);\n+  if (log) st.print(\"Stack (%d): \", stack_top);\n@@ -296,1 +296,1 @@\n-    st.print(\"%d\", v1 ? 1 : 0);\n+    if (log) st.print(\"%d\", v1 ? 1 : 0);\n@@ -298,1 +298,1 @@\n-  st.cr();\n+  if (log) st.cr();\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,5 @@\n-  _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,\n+  \/\/ 270+ interpreter codelets are generated and each of them is required to be aligned to\n+  \/\/ CodeEntryAlignment twice. So we need additional size due to alignment.\n+  int max_aligned_codelets = 280;\n+  int max_aligned_bytes = max_aligned_codelets * CodeEntryAlignment * 2;\n+  _code = new StubQueue(new InterpreterCodeletInterface, code_size + max_aligned_bytes, NULL,\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,0 +315,2 @@\n+  static_field(StubRoutines,                _md5_implCompress,                                address)                               \\\n+  static_field(StubRoutines,                _md5_implCompressMB,                              address)                               \\\n@@ -321,0 +323,2 @@\n+  static_field(StubRoutines,                _sha3_implCompress,                               address)                               \\\n+  static_field(StubRoutines,                _sha3_implCompressMB,                             address)                               \\\n@@ -743,0 +747,3 @@\n+  static_field(StubRoutines::aarch64, _count_positives, address)        \\\n+  static_field(StubRoutines::aarch64, _count_positives_long, address)   \\\n+  static_field(VM_Version, _rop_protection, bool)                       \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  f(mtObjectMonitor,  \"Object Monitors\")                                             \\\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,6 +203,0 @@\n-void Universe::basic_type_classes_do(void f(Klass*)) {\n-  for (int i = T_BOOLEAN; i < T_LONG+1; i++) {\n-    f(_typeArrayKlassObjs[i]);\n-  }\n-}\n-\n@@ -1306,0 +1300,1 @@\n+      _fullgc_alot_dummy_array = OopHandle(); \/\/ NULL out OopStorage pointer.\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -352,1 +352,1 @@\n-  \/\/ Apply \"f\" to all klasses for basic types (classes not present in\n+  \/\/ Apply the closure to all klasses for basic types (classes not present in\n@@ -354,1 +354,0 @@\n-  static void basic_type_classes_do(void f(Klass*));\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -929,2 +929,1 @@\n-  if (tag.is_dynamic_constant() ||\n-      tag.is_dynamic_constant_in_error()) {\n+  if (tag.is_dynamic_constant()) {\n@@ -932,2 +931,1 @@\n-    \/\/ dynamic constant could return an array, treat as object\n-    return constantTag::ofBasicType(is_reference_type(bt) ? T_OBJECT : bt);\n+    return constantTag(constantTag::type2tag(bt));\n@@ -1020,1 +1018,0 @@\n-  case JVM_CONSTANT_UnresolvedClassInError:\n@@ -1090,8 +1087,0 @@\n-  case JVM_CONSTANT_DynamicInError:\n-  case JVM_CONSTANT_MethodHandleInError:\n-  case JVM_CONSTANT_MethodTypeInError:\n-    {\n-      throw_resolution_error(this_cp, index, CHECK_NULL);\n-      break;\n-    }\n-\n@@ -1111,1 +1100,4 @@\n-      Klass* callee = klass_at_impl(this_cp, callee_index, CHECK_NULL);\n+      Klass* callee = klass_at_impl(this_cp, callee_index, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        save_and_throw_exception(this_cp, index, tag, CHECK_NULL);\n+      }\n@@ -1115,1 +1107,1 @@\n-          ((!callee->is_interface() && m_tag.is_interface_method()))) {\n+          (!callee->is_interface() && m_tag.is_interface_method())) {\n@@ -1127,1 +1119,2 @@\n-        THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());\n+        Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), \"%s\", ss.as_string());\n+        save_and_throw_exception(this_cp, index, tag, CHECK_NULL);\n@@ -1134,1 +1127,0 @@\n-      result_oop = value();\n@@ -1138,0 +1130,1 @@\n+      result_oop = value();\n@@ -1182,0 +1175,7 @@\n+  case JVM_CONSTANT_UnresolvedClassInError:\n+  case JVM_CONSTANT_DynamicInError:\n+  case JVM_CONSTANT_MethodHandleInError:\n+  case JVM_CONSTANT_MethodTypeInError:\n+    throw_resolution_error(this_cp, index, CHECK_NULL);\n+    break;\n+\n@@ -1183,3 +1183,1 @@\n-    DEBUG_ONLY( tty->print_cr(\"*** %p: tag at CP[%d\/%d] = %d\",\n-                              this_cp(), index, cache_index, tag.value()));\n-    assert(false, \"unexpected constant tag\");\n+    fatal(\"unexpected constant tag at CP %p[%d\/%d] = %d\", this_cp(), index, cache_index, tag.value());\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -1700,0 +1701,11 @@\n+#if INCLUDE_CDS\n+  \/\/ This is needed to ensure the consistency of the archived heap objects.\n+  if (has_archived_enum_objs()) {\n+    assert(is_shared(), \"must be\");\n+    bool initialized = HeapShared::initialize_enum_klass(this, CHECK);\n+    if (initialized) {\n+      return;\n+    }\n+  }\n+#endif\n+\n@@ -2266,0 +2278,46 @@\n+PrintClassClosure::PrintClassClosure(outputStream* st, bool verbose)\n+  :_st(st), _verbose(verbose) {\n+  ResourceMark rm;\n+  _st->print(\"%-18s  \", \"KlassAddr\");\n+  _st->print(\"%-4s  \", \"Size\");\n+  _st->print(\"%-20s  \", \"State\");\n+  _st->print(\"%-7s  \", \"Flags\");\n+  _st->print(\"%-5s  \", \"ClassName\");\n+  _st->cr();\n+}\n+\n+void PrintClassClosure::do_klass(Klass* k)  {\n+  ResourceMark rm;\n+  \/\/ klass pointer\n+  _st->print(INTPTR_FORMAT \"  \", p2i(k));\n+  \/\/ klass size\n+  _st->print(\"%4d  \", k->size());\n+  \/\/ initialization state\n+  if (k->is_instance_klass()) {\n+    _st->print(\"%-20s  \",InstanceKlass::cast(k)->init_state_name());\n+  } else {\n+    _st->print(\"%-20s  \",\"\");\n+  }\n+  \/\/ misc flags(Changes should synced with ClassesDCmd::ClassesDCmd help doc)\n+  char buf[10];\n+  int i = 0;\n+  if (k->has_finalizer()) buf[i++] = 'F';\n+  if (k->has_final_method()) buf[i++] = 'f';\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->is_rewritten()) buf[i++] = 'W';\n+    if (ik->is_contended()) buf[i++] = 'C';\n+    if (ik->has_been_redefined()) buf[i++] = 'R';\n+    if (ik->is_shared()) buf[i++] = 'S';\n+  }\n+  buf[i++] = '\\0';\n+  _st->print(\"%-7s  \", buf);\n+  \/\/ klass name\n+  _st->print(\"%-5s  \", k->external_name());\n+  \/\/ end\n+  _st->cr();\n+  if (_verbose) {\n+    k->print_on(_st);\n+  }\n+}\n+\n@@ -3643,0 +3701,4 @@\n+const char* InstanceKlass::init_state_name() const {\n+  return state_names[_init_state];\n+}\n+\n@@ -3651,1 +3713,1 @@\n-  st->print(BULLET\"state:             \"); st->print_cr(\"%s\", state_names[_init_state]);\n+  st->print(BULLET\"state:             \"); st->print_cr(\"%s\", init_state_name());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":64,"deletions":2,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -668,0 +668,1 @@\n+  const char* init_state_name() const;\n@@ -1419,0 +1420,9 @@\n+class PrintClassClosure : public KlassClosure {\n+private:\n+  outputStream* _st;\n+  bool _verbose;\n+public:\n+  PrintClassClosure(outputStream* st, bool verbose);\n+\n+  void do_klass(Klass* k);\n+};\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,3 +178,5 @@\n-    _archived_lambda_proxy_is_available = 2,\n-    _has_value_based_class_annotation = 4,\n-    _verified_at_dump_time = 8\n+    _archived_lambda_proxy_is_available    = 1 << 1,\n+    _has_value_based_class_annotation      = 1 << 2,\n+    _verified_at_dump_time                 = 1 << 3,\n+    _has_archived_enum_objs                = 1 << 4,\n+    _regenerated                           = 1 << 5\n@@ -344,0 +346,15 @@\n+  void set_has_archived_enum_objs() {\n+    CDS_ONLY(_shared_class_flags |= _has_archived_enum_objs;)\n+  }\n+  bool has_archived_enum_objs() const {\n+    CDS_ONLY(return (_shared_class_flags & _has_archived_enum_objs) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n+  void set_regenerated() {\n+    CDS_ONLY(_shared_class_flags |= _regenerated;)\n+  }\n+  bool is_regenerated() const {\n+    CDS_ONLY(return (_shared_class_flags & _regenerated) != 0;)\n+    NOT_CDS(return false;)\n+  }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,1 +277,1 @@\n-\/\/ See JLS 3rd edition 8.4.6.1\n+\/\/ See JLS 8.4.8.1\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+                         Symbol* name,\n@@ -96,1 +97,1 @@\n-  return new (loader_data, size, MetaspaceObj::MethodType, THREAD) Method(cm, access_flags);\n+  return new (loader_data, size, MetaspaceObj::MethodType, THREAD) Method(cm, access_flags, name);\n@@ -99,1 +100,1 @@\n-Method::Method(ConstMethod* xconst, AccessFlags access_flags) {\n+Method::Method(ConstMethod* xconst, AccessFlags access_flags, Symbol* name) {\n@@ -121,0 +122,2 @@\n+  \/\/ Name is very useful for debugging.\n+  NOT_PRODUCT(_name = name;)\n@@ -406,0 +409,1 @@\n+  NOT_PRODUCT(it->push(&_name);)\n@@ -1525,1 +1529,3 @@\n-                                     ConstMethod::NORMAL, CHECK_(empty));\n+                                     ConstMethod::NORMAL,\n+                                     name,\n+                                     CHECK_(empty));\n@@ -1605,0 +1611,1 @@\n+                                      m->name(),\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,1 @@\n+ friend class MethodTest;\n@@ -104,0 +105,2 @@\n+\n+  Symbol* _name;\n@@ -121,1 +124,1 @@\n-  Method(ConstMethod* xconst, AccessFlags access_flags);\n+  Method(ConstMethod* xconst, AccessFlags access_flags, Symbol* name);\n@@ -129,0 +132,1 @@\n+                          Symbol* name,\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -199,1 +199,0 @@\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -201,2 +200,2 @@\n-  if (igvn != NULL) {\n-    igvn->_worklist.push(mem);\n+  if (can_reshape) {\n+    phase->is_IterGVN()->_worklist.push(mem);\n@@ -314,0 +313,4 @@\n+    if (src_offset->is_top()) {\n+      \/\/ Offset is out of bounds (the ArrayCopyNode will be removed)\n+      return false;\n+    }\n@@ -315,1 +318,1 @@\n-    if (src_offset->is_top() || dest_offset->is_top()) {\n+    if (dest_offset->is_top()) {\n@@ -317,0 +320,4 @@\n+      if (can_reshape) {\n+        \/\/ record src_offset, so it can be deleted later (if it is dead)\n+        phase->is_IterGVN()->_worklist.push(src_offset);\n+      }\n@@ -636,0 +643,2 @@\n+    assert(adr_src == NULL, \"no node can be left behind\");\n+    assert(adr_dest == NULL, \"no node can be left behind\");\n@@ -721,0 +730,3 @@\n+    } else {\n+      \/\/ put in worklist, so that if it happens to be dead it is removed\n+      phase->is_IterGVN()->_worklist.push(mem);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -115,5 +115,0 @@\n-  notproduct(uintx, PrintIdealLevel, 0,                                     \\\n-          \"Print ideal IR on stdout. \"                                      \\\n-          \"Same levels as PrintIdealGraphLevel\")                            \\\n-          range(0, 4)                                                       \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -237,2 +237,2 @@\n-  case vmIntrinsics::_hasNegatives:\n-    if (!Matcher::match_rule_supported(Op_HasNegatives))  return false;\n+  case vmIntrinsics::_countPositives:\n+    if (!Matcher::match_rule_supported(Op_CountPositives))  return false;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -557,0 +557,4 @@\n+    if (C->print_inlining() || C->print_intrinsics()) {\n+      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(),\n+                        \"late call devirtualization failed (receiver may be null)\");\n+    }\n@@ -563,0 +567,4 @@\n+    if (C->print_inlining() || C->print_intrinsics()) {\n+      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(),\n+                        \"late call devirtualization failed (interface call)\");\n+    }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -950,1 +950,1 @@\n-        const Node *cn = pn->unique_ctrl_out();\n+        const Node* cn = pn->unique_ctrl_out_or_null();\n@@ -1625,1 +1625,1 @@\n-    Node* out_c = unique_ctrl_out();\n+    Node* out_c = unique_ctrl_out_or_null();\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -214,0 +214,34 @@\n+  if (res == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  assert(res->isa_int(), \"res must be int\");\n+\n+  \/\/ Similar to ConvI2LNode::Value() for the same reasons\n+  \/\/ see if we can remove type assertion after loop opts\n+  \/\/ But here we have to pay extra attention:\n+  \/\/ Do not narrow the type of range check dependent CastIINodes to\n+  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n+  \/\/ the corresponding range check is not removed.\n+  if (!_range_check_dependency && phase->C->post_loop_opts_phase()) {\n+    const TypeInt* this_type = res->is_int();\n+    const TypeInt* in_type = phase->type(in(1))->isa_int();\n+    if (in_type != NULL &&\n+        (in_type->_lo != this_type->_lo ||\n+         in_type->_hi != this_type->_hi)) {\n+      jint lo1 = this_type->_lo;\n+      jint hi1 = this_type->_hi;\n+      int w1 = this_type->_widen;\n+      if (lo1 >= 0) {\n+        \/\/ Keep a range assertion of >=0.\n+        lo1 = 0;        hi1 = max_jint;\n+      } else if (hi1 < 0) {\n+        \/\/ Keep a range assertion of <0.\n+        lo1 = min_jint; hi1 = -1;\n+      } else {\n+        lo1 = min_jint; hi1 = max_jint;\n+      }\n+      res = TypeInt::make(MAX2(in_type->_lo, lo1),\n+                          MIN2(in_type->_hi, hi1),\n+                          MAX2((int)in_type->_widen, w1));\n+    }\n+  }\n@@ -268,1 +302,0 @@\n-\n@@ -294,2 +327,5 @@\n-\n-  PhaseIterGVN *igvn = phase->is_IterGVN();\n+  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    phase->C->record_for_post_loop_opts_igvn(this);\n+  }\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -320,37 +356,0 @@\n-\n-  \/\/ Similar to ConvI2LNode::Ideal() for the same reasons\n-  \/\/ Do not narrow the type of range check dependent CastIINodes to\n-  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n-  \/\/ the corresponding range check is not removed.\n-  if (can_reshape && !_range_check_dependency) {\n-    if (phase->C->post_loop_opts_phase()) {\n-      const TypeInt* this_type = this->type()->is_int();\n-      const TypeInt* in_type = phase->type(in(1))->isa_int();\n-      if (in_type != NULL && this_type != NULL &&\n-          (in_type->_lo != this_type->_lo ||\n-           in_type->_hi != this_type->_hi)) {\n-        jint lo1 = this_type->_lo;\n-        jint hi1 = this_type->_hi;\n-        int w1  = this_type->_widen;\n-\n-        if (lo1 >= 0) {\n-          \/\/ Keep a range assertion of >=0.\n-          lo1 = 0;        hi1 = max_jint;\n-        } else if (hi1 < 0) {\n-          \/\/ Keep a range assertion of <0.\n-          lo1 = min_jint; hi1 = -1;\n-        } else {\n-          lo1 = min_jint; hi1 = max_jint;\n-        }\n-        const TypeInt* wtype = TypeInt::make(MAX2(in_type->_lo, lo1),\n-                                             MIN2(in_type->_hi, hi1),\n-                                             MAX2((int)in_type->_widen, w1));\n-        if (wtype != type()) {\n-          set_type(wtype);\n-          return this;\n-        }\n-      }\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":39,"deletions":40,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -876,4 +876,4 @@\n-  if (!((proj1->unique_ctrl_out() == iff2 &&\n-         proj2->unique_ctrl_out() == this) ||\n-        (proj2->unique_ctrl_out() == iff1 &&\n-         proj1->unique_ctrl_out() == this))) {\n+  if (!((proj1->unique_ctrl_out_or_null() == iff2 &&\n+         proj2->unique_ctrl_out_or_null() == this) ||\n+        (proj2->unique_ctrl_out_or_null() == iff1 &&\n+         proj1->unique_ctrl_out_or_null() == this))) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-macro(HasNegatives)\n+macro(CountPositives)\n@@ -485,0 +485,3 @@\n+macro(VectorUCastB2X)\n+macro(VectorUCastS2X)\n+macro(VectorUCastI2X)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5371,1 +5371,1 @@\n-  ss.print_raw(CompilerPhaseTypeHelper::to_string(cpt));\n+  ss.print_raw(CompilerPhaseTypeHelper::to_description(cpt));\n@@ -5380,2 +5380,2 @@\n-  if (should_print_ideal(level)) {\n-    print_ideal_ir(name);\n+  if (should_print_phase(cpt)) {\n+    print_ideal_ir(CompilerPhaseTypeHelper::to_name(cpt));\n@@ -5411,0 +5411,9 @@\n+bool Compile::should_print_phase(CompilerPhaseType cpt) {\n+#ifndef PRODUCT\n+  if ((_directive->ideal_phase_mask() & CompilerPhaseTypeHelper::to_bitmask(cpt)) != 0) {\n+    return true;\n+  }\n+#endif\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -655,1 +655,0 @@\n-  bool          should_print_ideal(uint level) const { return _directive->PrintIdealLevelOption >= level; }\n@@ -672,0 +671,1 @@\n+  bool should_print_phase(CompilerPhaseType cpt);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -266,1 +266,3 @@\n-  if( t == Type::TOP ) return Type::TOP;\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -271,1 +273,34 @@\n-  return tl;\n+  if (!tl->isa_long()) {\n+    return tl;\n+  }\n+  const TypeLong* this_type = tl->is_long();\n+  \/\/ Do NOT remove this node's type assertion until no more loop ops can happen.\n+  if (phase->C->post_loop_opts_phase()) {\n+    const TypeInt* in_type = phase->type(in(1))->isa_int();\n+    if (in_type != NULL &&\n+        (in_type->_lo != this_type->_lo ||\n+         in_type->_hi != this_type->_hi)) {\n+      \/\/ Although this WORSENS the type, it increases GVN opportunities,\n+      \/\/ because I2L nodes with the same input will common up, regardless\n+      \/\/ of slightly differing type assertions.  Such slight differences\n+      \/\/ arise routinely as a result of loop unrolling, so this is a\n+      \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n+      \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n+      jlong lo1 = this_type->_lo;\n+      jlong hi1 = this_type->_hi;\n+      int   w1  = this_type->_widen;\n+      if (lo1 >= 0) {\n+        \/\/ Keep a range assertion of >=0.\n+        lo1 = 0;        hi1 = max_jint;\n+      } else if (hi1 < 0) {\n+        \/\/ Keep a range assertion of <0.\n+        lo1 = min_jint; hi1 = -1;\n+      } else {\n+        lo1 = min_jint; hi1 = max_jint;\n+      }\n+      return TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n+                            MIN2((jlong)in_type->_hi, hi1),\n+                            MAX2((int)in_type->_widen, w1));\n+    }\n+  }\n+  return this_type;\n@@ -373,45 +408,3 @@\n-  PhaseIterGVN *igvn = phase->is_IterGVN();\n-  Node* this_changed = NULL;\n-\n-  if (igvn != NULL) {\n-    \/\/ Do NOT remove this node's type assertion until no more loop ops can happen.\n-    if (phase->C->post_loop_opts_phase()) {\n-      const TypeInt* in_type = phase->type(in(1))->isa_int();\n-      if (in_type != NULL && this_type != NULL &&\n-          (in_type->_lo != this_type->_lo ||\n-           in_type->_hi != this_type->_hi)) {\n-        \/\/ Although this WORSENS the type, it increases GVN opportunities,\n-        \/\/ because I2L nodes with the same input will common up, regardless\n-        \/\/ of slightly differing type assertions.  Such slight differences\n-        \/\/ arise routinely as a result of loop unrolling, so this is a\n-        \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n-        \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n-        jlong lo1 = this_type->_lo;\n-        jlong hi1 = this_type->_hi;\n-        int   w1  = this_type->_widen;\n-        if (lo1 != (jint)lo1 ||\n-            hi1 != (jint)hi1 ||\n-            lo1 > hi1) {\n-          \/\/ Overflow leads to wraparound, wraparound leads to range saturation.\n-          lo1 = min_jint; hi1 = max_jint;\n-        } else if (lo1 >= 0) {\n-          \/\/ Keep a range assertion of >=0.\n-          lo1 = 0;        hi1 = max_jint;\n-        } else if (hi1 < 0) {\n-          \/\/ Keep a range assertion of <0.\n-          lo1 = min_jint; hi1 = -1;\n-        } else {\n-          lo1 = min_jint; hi1 = max_jint;\n-        }\n-        const TypeLong* wtype = TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n-                                               MIN2((jlong)in_type->_hi, hi1),\n-                                               MAX2((int)in_type->_widen, w1));\n-        if (wtype != type()) {\n-          set_type(wtype);\n-          \/\/ Note: this_type still has old type value, for the logic below.\n-          this_changed = this;\n-        }\n-      }\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n+  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    phase->C->record_for_post_loop_opts_igvn(this);\n@@ -442,1 +435,1 @@\n-\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -451,1 +444,1 @@\n-      return this_changed;\n+      return NULL;\n@@ -467,1 +460,1 @@\n-  return this_changed;\n+  return NULL;\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":43,"deletions":50,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -231,0 +231,14 @@\n+\n+#ifndef PRODUCT\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    tty->print(\"+++++ Initial worklist for \");\n+    _compile->method()->print_name();\n+    tty->print_cr(\" (ea_inv=%d)\", _invocation);\n+    for (int i = 0; i < ptnodes_worklist.length(); i++) {\n+      PointsToNode* ptn = ptnodes_worklist.at(i);\n+      ptn->dump();\n+    }\n+    tty->print_cr(\"+++++ Calculating escape states and scalar replaceability\");\n+  }\n+#endif\n+\n@@ -649,1 +663,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n@@ -788,1 +802,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n@@ -894,1 +908,1 @@\n-    set_escape_state(ptn, PointsToNode::GlobalEscape);\n+    set_escape_state(ptn, PointsToNode::GlobalEscape NOT_PRODUCT(COMMA \"stored at raw address\"));\n@@ -921,0 +935,1 @@\n+    NOT_PRODUCT(const char* nsr_reason = \"\");\n@@ -926,2 +941,2 @@\n-        if (length < 0 || length > EliminateAllocationArraySizeLimit) {\n-          \/\/ Not scalar replaceable if the length is not constant or too big.\n+        if (length < 0) {\n+          \/\/ Not scalar replaceable if the length is not constant.\n@@ -929,0 +944,5 @@\n+          NOT_PRODUCT(nsr_reason = \"has a non-constant length\");\n+        } else if (length > EliminateAllocationArraySizeLimit) {\n+          \/\/ Not scalar replaceable if the length is too big.\n+          scalar_replaceable = false;\n+          NOT_PRODUCT(nsr_reason = \"has a length that is too big\");\n@@ -943,0 +963,1 @@\n+          NOT_PRODUCT(nsr_reason = \"has too many fields\");\n@@ -949,1 +970,1 @@\n-      ptn->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(ptn NOT_PRODUCT(COMMA nsr_reason));\n@@ -981,1 +1002,1 @@\n-      ptnode_adr(call_idx)->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(ptnode_adr(call_idx) NOT_PRODUCT(COMMA \"is result of multinewarray\"));\n@@ -1003,1 +1024,1 @@\n-        ptnode_adr(call_idx)->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(ptnode_adr(call_idx) NOT_PRODUCT(COMMA \"is result of call\"));\n@@ -1164,1 +1185,1 @@\n-          set_escape_state(arg_ptn, es);\n+          set_escape_state(arg_ptn, es NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1219,1 +1240,1 @@\n-              set_escape_state(arg_ptn, PointsToNode::GlobalEscape);\n+              set_escape_state(arg_ptn, PointsToNode::GlobalEscape NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1221,1 +1242,1 @@\n-              set_escape_state(arg_ptn, PointsToNode::ArgEscape);\n+              set_escape_state(arg_ptn, PointsToNode::ArgEscape NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1224,1 +1245,1 @@\n-                set_fields_escape_state(arg_ptn, PointsToNode::GlobalEscape);\n+                set_fields_escape_state(arg_ptn, PointsToNode::GlobalEscape NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1253,1 +1274,1 @@\n-          set_escape_state(ptnode_adr(arg->_idx), PointsToNode::GlobalEscape);\n+          set_escape_state(ptnode_adr(arg->_idx), PointsToNode::GlobalEscape NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1437,1 +1458,1 @@\n-          set_fields_escape_state(e, field_es);\n+          set_fields_escape_state(e, field_es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1443,1 +1464,1 @@\n-          set_escape_state(e, es);\n+          set_escape_state(e, es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1450,1 +1471,1 @@\n-          set_fields_escape_state(e, field_es);\n+          set_fields_escape_state(e, field_es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1457,1 +1478,1 @@\n-          set_escape_state(e, field_es);\n+          set_escape_state(e, field_es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1460,1 +1481,1 @@\n-          set_escape_state(e, es);\n+          set_escape_state(e, es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1836,1 +1857,1 @@\n-        jobj->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is stored at unknown offset\"));\n@@ -1845,1 +1866,1 @@\n-            jobj->set_scalar_replaceable(false);\n+            set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is stored into field with potentially null base\"));\n@@ -1857,2 +1878,2 @@\n-        jobj->set_scalar_replaceable(false);\n-        ptn->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA trace_merged_message(ptn)));\n+        set_not_scalar_replaceable(ptn NOT_PRODUCT(COMMA trace_merged_message(jobj)));\n@@ -1878,1 +1899,1 @@\n-      jobj->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"has field with unknown offset\"));\n@@ -1893,1 +1914,1 @@\n-      jobj->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is used as base of mixed unsafe access\"));\n@@ -1900,1 +1921,1 @@\n-        jobj->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is used in LoadStore or mismatched access\"));\n@@ -1929,2 +1950,2 @@\n-          jobj->set_scalar_replaceable(false);\n-          base->set_scalar_replaceable(false);\n+          set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"may point to more than one object\"));\n+          set_not_scalar_replaceable(base NOT_PRODUCT(COMMA \"may point to more than one object\"));\n@@ -3225,1 +3246,1 @@\n-      set_escape_state(ptnode_adr(n->_idx), es); \/\/ CheckCastPP escape state\n+      set_escape_state(ptnode_adr(n->_idx), es NOT_PRODUCT(COMMA trace_propagate_message(ptn))); \/\/ CheckCastPP escape state\n@@ -3409,1 +3430,2 @@\n-              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp || op == Op_HasNegatives ||\n+              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp ||\n+              op == Op_CountPositives ||\n@@ -3547,1 +3569,1 @@\n-              op == Op_AryEq || op == Op_StrComp || op == Op_HasNegatives ||\n+              op == Op_AryEq || op == Op_StrComp || op == Op_CountPositives ||\n@@ -3717,1 +3739,1 @@\n-void PointsToNode::dump(bool print_state) const {\n+void PointsToNode::dump_header(bool print_state, outputStream* out) const {\n@@ -3719,1 +3741,1 @@\n-  tty->print(\"%s \", node_type_names[(int) nt]);\n+  out->print(\"%s(%d) \", node_type_names[(int) nt], _pidx);\n@@ -3723,1 +3745,1 @@\n-    tty->print(\"%s(%s) \", esc_names[(int)es], esc_names[(int)fields_es]);\n+    out->print(\"%s(%s) \", esc_names[(int)es], esc_names[(int)fields_es]);\n@@ -3725,1 +3747,1 @@\n-      tty->print(\"NSR \");\n+      out->print(\"NSR \");\n@@ -3728,0 +3750,4 @@\n+}\n+\n+void PointsToNode::dump(bool print_state, outputStream* out, bool newline) const {\n+  dump_header(print_state, out);\n@@ -3731,1 +3757,1 @@\n-      tty->print(\"oop \");\n+      out->print(\"oop \");\n@@ -3734,1 +3760,1 @@\n-      tty->print(\"+%d \", f->offset());\n+      out->print(\"+%d \", f->offset());\n@@ -3736,1 +3762,1 @@\n-    tty->print(\"(\");\n+    out->print(\"(\");\n@@ -3739,1 +3765,1 @@\n-      tty->print(\" %d%s\", b->idx(),(b->is_JavaObject() ? \"P\" : \"\"));\n+      out->print(\" %d%s\", b->idx(),(b->is_JavaObject() ? \"P\" : \"\"));\n@@ -3741,1 +3767,1 @@\n-    tty->print(\" )\");\n+    out->print(\" )\");\n@@ -3743,1 +3769,1 @@\n-  tty->print(\"[\");\n+  out->print(\"[\");\n@@ -3746,1 +3772,1 @@\n-    tty->print(\" %d%s%s\", e->idx(),(e->is_JavaObject() ? \"P\" : (e->is_Field() ? \"F\" : \"\")), e->is_Arraycopy() ? \"cp\" : \"\");\n+    out->print(\" %d%s%s\", e->idx(),(e->is_JavaObject() ? \"P\" : (e->is_Field() ? \"F\" : \"\")), e->is_Arraycopy() ? \"cp\" : \"\");\n@@ -3748,1 +3774,1 @@\n-  tty->print(\" [\");\n+  out->print(\" [\");\n@@ -3756,1 +3782,1 @@\n-    tty->print(\" %d%s%s\", u->idx(), is_base ? \"b\" : \"\", u->is_Arraycopy() ? \"cp\" : \"\");\n+    out->print(\" %d%s%s\", u->idx(), is_base ? \"b\" : \"\", u->is_Arraycopy() ? \"cp\" : \"\");\n@@ -3758,1 +3784,1 @@\n-  tty->print(\" ]]  \");\n+  out->print(\" ]]  \");\n@@ -3760,1 +3786,1 @@\n-    tty->print_cr(\"<null>\");\n+    out->print(\"<null>%s\", newline ? \"\\n\" : \"\");\n@@ -3762,1 +3788,1 @@\n-    _node->dump();\n+    _node->dump(newline ? \"\\n\" : \"\", false, out);\n@@ -3805,0 +3831,45 @@\n+\n+void ConnectionGraph::trace_es_update_helper(PointsToNode* ptn, PointsToNode::EscapeState es, bool fields, const char* reason) const {\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    assert(ptn != nullptr, \"should not be null\");\n+    assert(reason != nullptr, \"should not be null\");\n+    ptn->dump_header(true);\n+    PointsToNode::EscapeState new_es = fields ? ptn->escape_state() : es;\n+    PointsToNode::EscapeState new_fields_es = fields ? es : ptn->fields_escape_state();\n+    tty->print_cr(\"-> %s(%s) %s\", esc_names[(int)new_es], esc_names[(int)new_fields_es], reason);\n+  }\n+}\n+\n+const char* ConnectionGraph::trace_propagate_message(PointsToNode* from) const {\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    stringStream ss;\n+    ss.print(\"propagated from: \");\n+    from->dump(true, &ss, false);\n+    return ss.as_string();\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n+const char* ConnectionGraph::trace_arg_escape_message(CallNode* call) const {\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    stringStream ss;\n+    ss.print(\"escapes as arg to:\");\n+    call->dump(\"\", false, &ss);\n+    return ss.as_string();\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n+const char* ConnectionGraph::trace_merged_message(PointsToNode* other) const {\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    stringStream ss;\n+    ss.print(\"is merged with other object: \");\n+    other->dump_header(true, &ss);\n+    return ss.as_string();\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":117,"deletions":46,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -742,1 +742,1 @@\n-  Node* otherproj_ctrl_use = otherproj->unique_ctrl_out();\n+  Node* otherproj_ctrl_use = otherproj->unique_ctrl_out_or_null();\n@@ -1744,1 +1744,1 @@\n-      Node* head = unique_ctrl_out();\n+      Node* head = unique_ctrl_out_or_null();\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -628,2 +628,2 @@\n-  case vmIntrinsics::_hasNegatives:\n-    return inline_hasNegatives();\n+  case vmIntrinsics::_countPositives:\n+    return inline_countPositives();\n@@ -1022,2 +1022,2 @@\n-\/\/------------------------------inline_hasNegatives------------------------------\n-bool LibraryCallKit::inline_hasNegatives() {\n+\/\/------------------------------inline_countPositives------------------------------\n+bool LibraryCallKit::inline_countPositives() {\n@@ -1028,1 +1028,1 @@\n-  assert(callee()->signature()->size() == 3, \"hasNegatives has 3 parameters\");\n+  assert(callee()->signature()->size() == 3, \"countPositives has 3 parameters\");\n@@ -1042,1 +1042,1 @@\n-  Node* result = new HasNegativesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);\n+  Node* result = new CountPositivesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);\n@@ -1103,1 +1103,0 @@\n-  clear_upper_avx();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -322,1 +322,1 @@\n-  bool inline_hasNegatives();\n+  bool inline_countPositives();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -553,1 +553,2 @@\n-  CountedLoopNode* inner_loop() const;\n+  static void fix_sunk_stores(CountedLoopEndNode* inner_cle, LoopNode* inner_cl, PhaseIterGVN* igvn, PhaseIdealLoop* iloop);\n+\n@@ -569,0 +570,9 @@\n+\n+  void remove_outer_loop_and_safepoint(PhaseIterGVN* igvn) const;\n+\n+  void transform_to_counted_loop(PhaseIterGVN* igvn, PhaseIdealLoop* iloop);\n+\n+  static Node* register_new_node(Node* node, LoopNode* ctrl, PhaseIterGVN* igvn, PhaseIdealLoop* iloop);\n+\n+  Node* register_control(Node* node, Node* loop, Node* idom, PhaseIterGVN* igvn,\n+                         PhaseIdealLoop* iloop);\n@@ -1049,0 +1059,1 @@\n+  LoopOptsMode _mode;\n@@ -1051,1 +1062,1 @@\n-  void build_and_optimize(LoopOptsMode mode);\n+  void build_and_optimize();\n@@ -1062,0 +1073,1 @@\n+    _mode(mode),\n@@ -1064,1 +1076,1 @@\n-    build_and_optimize(mode);\n+    build_and_optimize();\n@@ -1075,0 +1087,1 @@\n+    _mode(LoopOptsVerify),\n@@ -1076,1 +1089,1 @@\n-    build_and_optimize(LoopOptsVerify);\n+    build_and_optimize();\n@@ -1269,1 +1282,1 @@\n-  bool is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt, bool* converted);\n+  bool is_scaled_iv(Node* exp, Node* iv, BasicType bt, jlong* p_scale, bool* p_short_scale, int depth = 0);\n@@ -1274,1 +1287,1 @@\n-  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* converted = NULL, int depth = 0);\n+  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale = NULL, int depth = 0);\n@@ -1277,1 +1290,1 @@\n-    if (is_scaled_iv_plus_offset(exp, iv, &long_scale, p_offset, T_INT)) {\n+    if (is_scaled_iv_plus_offset(exp, iv, T_INT, &long_scale, p_offset)) {\n@@ -1286,0 +1299,6 @@\n+  \/\/ Helper for finding more complex matches to is_scaled_iv_plus_offset.\n+  bool is_scaled_iv_plus_extra_offset(Node* exp1, Node* offset2, Node* iv,\n+                                      BasicType bt,\n+                                      jlong* p_scale, Node** p_offset,\n+                                      bool* p_short_scale, int depth);\n+\n@@ -1662,2 +1681,0 @@\n-  void strip_mined_nest_back_to_counted_loop(IdealLoopTree* loop, const BaseCountedLoopNode* head, Node* back_control,\n-                                             IfNode*&exit_test, SafePointNode*&safepoint);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -4006,0 +4006,2 @@\n+      post = new CastIINode(post, phi->bottom_type()); \/\/ preserve the iv phi's type\n+      register_new_node(post, c);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,3 +208,0 @@\n-private:\n-  bool _removed = false;\n-\n@@ -281,1 +278,1 @@\n-  uint _num_opnds;\n+  uint16_t _num_opnds;\n@@ -283,1 +280,1 @@\n-  uint  num_opnds() const { return _num_opnds; }\n+  uint16_t num_opnds() const { return _num_opnds; }\n@@ -379,2 +376,2 @@\n-  void set_removed() { _removed = true; }\n-  bool get_removed() { return _removed; }\n+  void set_removed() { add_flag(Flag_is_removed_by_peephole); }\n+  bool get_removed() { return (flags() & Flag_is_removed_by_peephole) != 0; }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1090,1 +1090,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n@@ -2285,1 +2285,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4891,23 +4891,0 @@\n-  \/\/ Look carefully at the base node if it is a phi.\n-  PhiNode* phi_base;\n-  if (new_base != NULL && new_base->is_Phi())\n-    phi_base = new_base->as_Phi();\n-  else\n-    phi_base = NULL;\n-\n-  Node*    phi_reg = NULL;\n-  uint     phi_len = (uint)-1;\n-  if (phi_base != NULL) {\n-    phi_reg = phi_base->region();\n-    phi_len = phi_base->req();\n-    \/\/ see if the phi is unfinished\n-    for (uint i = 1; i < phi_len; i++) {\n-      if (phi_base->in(i) == NULL) {\n-        \/\/ incomplete phi; do not look at it yet!\n-        phi_reg = NULL;\n-        phi_len = (uint)-1;\n-        break;\n-      }\n-    }\n-  }\n-\n@@ -5114,1 +5091,0 @@\n-  Compile *C = Compile::current();\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-    out = out->unique_ctrl_out();\n+    out = out->unique_ctrl_out_or_null();\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2398,1 +2398,1 @@\n-\/\/--------------------------unique_ctrl_out------------------------------\n+\/\/--------------------------unique_ctrl_out_or_null-------------------------\n@@ -2400,1 +2400,1 @@\n-Node* Node::unique_ctrl_out() const {\n+Node* Node::unique_ctrl_out_or_null() const {\n@@ -2414,0 +2414,8 @@\n+\/\/--------------------------unique_ctrl_out------------------------------\n+\/\/ Return the unique control out. Asserts if none or more than one control out.\n+Node* Node::unique_ctrl_out() const {\n+  Node* ctrl = unique_ctrl_out_or_null();\n+  assert(ctrl != NULL, \"control out is assumed to be unique\");\n+  return ctrl;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -801,1 +801,2 @@\n-    _last_flag                       = Flag_for_post_loop_opts_igvn\n+    Flag_is_removed_by_peephole      = 1 << 17,\n+    _last_flag                       = Flag_is_removed_by_peephole\n@@ -1106,0 +1107,2 @@\n+  Node* unique_ctrl_out_or_null() const;\n+  \/\/ Return the unique control out. Asserts if none or more than one control out.\n@@ -1172,1 +1175,6 @@\n-    guarantee(t != NULL, \"must be con\");\n+    guarantee(t != NULL && t->is_con(), \"must be con\");\n+    return t->get_con_as_long(bt);\n+  }\n+  jlong find_integer_as_long(BasicType bt, jlong value_if_unknown) const {\n+    const TypeInteger* t = find_integer_type(bt);\n+    if (t == NULL || !t->is_con())  return value_if_unknown;\n@@ -1267,3 +1275,0 @@\n-  int  _debug_idx;                     \/\/ Unique value assigned to every node.\n-  int   debug_idx() const              { return _debug_idx; }\n-  void  set_debug_idx( int debug_idx ) { _debug_idx = debug_idx; }\n@@ -1276,0 +1281,4 @@\n+  int  _debug_idx;                     \/\/ Unique value assigned to every node.\n+  int   debug_idx() const              { return _debug_idx; }\n+  void  set_debug_idx( int debug_idx ) { _debug_idx = debug_idx; }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2611,0 +2611,1 @@\n+\n@@ -2613,18 +2614,3 @@\n-  case Bytecodes::_ldc2_w:\n-    \/\/ If the constant is unresolved, run this BC once in the interpreter.\n-    {\n-      ciConstant constant = iter().get_constant();\n-      if (!constant.is_valid() ||\n-          (constant.basic_type() == T_OBJECT &&\n-           !constant.as_object()->is_loaded())) {\n-        int index = iter().get_constant_pool_index();\n-        constantTag tag = iter().get_constant_pool_tag(index);\n-        uncommon_trap(Deoptimization::make_trap_request\n-                      (Deoptimization::Reason_unloaded,\n-                       Deoptimization::Action_reinterpret,\n-                       index),\n-                      NULL, tag.internal_name());\n-        break;\n-      }\n-      assert(constant.basic_type() != T_OBJECT || constant.as_object()->is_instance(),\n-             \"must be java_mirror of klass\");\n+  case Bytecodes::_ldc2_w: {\n+    ciConstant constant = iter().get_constant();\n+    if (constant.is_loaded()) {\n@@ -2635,1 +2621,6 @@\n-    }\n+    } else {\n+      \/\/ If the constant is unresolved or in error state, run this BC in the interpreter.\n+      if (iter().is_in_error()) {\n+        uncommon_trap(Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n+                                                        Deoptimization::Action_none),\n+                      NULL, \"constant in error state\", true \/* must_throw *\/);\n@@ -2637,0 +2628,8 @@\n+      } else {\n+        int index = iter().get_constant_pool_index();\n+        uncommon_trap(Deoptimization::make_trap_request(Deoptimization::Reason_unloaded,\n+                                                        Deoptimization::Action_reinterpret,\n+                                                        index),\n+                      NULL, \"unresolved constant\", false \/* must_throw *\/);\n+      }\n+    }\n@@ -2638,0 +2637,1 @@\n+  }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1706,1 +1706,1 @@\n-        c = c->unique_ctrl_out();\n+        c = c->unique_ctrl_out_or_null();\n@@ -1735,1 +1735,1 @@\n-      if (n->in(2)->is_top()) {\n+      if (type(n->in(2)) == Type::TOP) {\n@@ -1745,1 +1745,1 @@\n-      if (n->in(2)->is_top()) {\n+      if (type(n->in(2)) == Type::TOP) {\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,46 @@\n+#define COMPILER_PHASES(flags) \\\n+  flags(BEFORE_STRINGOPTS,            \"Before StringOpts\") \\\n+  flags(AFTER_STRINGOPTS,             \"After StringOpts\") \\\n+  flags(BEFORE_REMOVEUSELESS,         \"Before RemoveUseless\") \\\n+  flags(AFTER_PARSING,                \"After Parsing\") \\\n+  flags(ITER_GVN1,                    \"Iter GVN 1\") \\\n+  flags(EXPAND_VUNBOX,                \"Expand VectorUnbox\") \\\n+  flags(SCALARIZE_VBOX,               \"Scalarize VectorBox\") \\\n+  flags(INLINE_VECTOR_REBOX,          \"Inline Vector Rebox Calls\") \\\n+  flags(EXPAND_VBOX,                  \"Expand VectorBox\") \\\n+  flags(ELIMINATE_VBOX_ALLOC,         \"Eliminate VectorBoxAllocate\") \\\n+  flags(PHASEIDEAL_BEFORE_EA,         \"PhaseIdealLoop before EA\") \\\n+  flags(ITER_GVN_AFTER_VECTOR,        \"Iter GVN after vector box elimination\") \\\n+  flags(ITER_GVN_BEFORE_EA,           \"Iter GVN before EA\") \\\n+  flags(ITER_GVN_AFTER_EA,            \"Iter GVN after EA\") \\\n+  flags(ITER_GVN_AFTER_ELIMINATION,   \"Iter GVN after eliminating allocations and locks\") \\\n+  flags(PHASEIDEALLOOP1,              \"PhaseIdealLoop 1\") \\\n+  flags(PHASEIDEALLOOP2,              \"PhaseIdealLoop 2\") \\\n+  flags(PHASEIDEALLOOP3,              \"PhaseIdealLoop 3\") \\\n+  flags(CCP1,                         \"PhaseCCP 1\") \\\n+  flags(ITER_GVN2,                    \"Iter GVN 2\") \\\n+  flags(PHASEIDEALLOOP_ITERATIONS,    \"PhaseIdealLoop iterations\") \\\n+  flags(OPTIMIZE_FINISHED,            \"Optimize finished\") \\\n+  flags(GLOBAL_CODE_MOTION,           \"Global code motion\") \\\n+  flags(FINAL_CODE,                   \"Final Code\") \\\n+  flags(AFTER_EA,                     \"After Escape Analysis\") \\\n+  flags(BEFORE_CLOOPS,                \"Before CountedLoop\") \\\n+  flags(AFTER_CLOOPS,                 \"After CountedLoop\") \\\n+  flags(BEFORE_BEAUTIFY_LOOPS,        \"Before beautify loops\") \\\n+  flags(AFTER_BEAUTIFY_LOOPS,         \"After beautify loops\") \\\n+  flags(BEFORE_MATCHING,              \"Before matching\") \\\n+  flags(MATCHING,                     \"After matching\") \\\n+  flags(INCREMENTAL_INLINE,           \"Incremental Inline\") \\\n+  flags(INCREMENTAL_INLINE_STEP,      \"Incremental Inline Step\") \\\n+  flags(INCREMENTAL_INLINE_CLEANUP,   \"Incremental Inline Cleanup\") \\\n+  flags(INCREMENTAL_BOXING_INLINE,    \"Incremental Boxing Inline\") \\\n+  flags(CALL_CATCH_CLEANUP,           \"Call catch cleanup\") \\\n+  flags(MACRO_EXPANSION,              \"Macro expand\") \\\n+  flags(BARRIER_EXPANSION,            \"Barrier expand\") \\\n+  flags(END,                          \"End\") \\\n+  flags(FAILURE,                      \"Failure\") \\\n+  flags(SPLIT_INLINES_ARRAY,          \"Split inlines array\") \\\n+  flags(SPLIT_INLINES_ARRAY_IGVN,     \"IGVN after split inlines array\") \\\n+  flags(DEBUG,                        \"Debug\")\n+\n+#define table_entry(name, description) PHASE_##name,\n@@ -29,46 +75,16 @@\n-  PHASE_BEFORE_STRINGOPTS,\n-  PHASE_AFTER_STRINGOPTS,\n-  PHASE_BEFORE_REMOVEUSELESS,\n-  PHASE_AFTER_PARSING,\n-  PHASE_ITER_GVN1,\n-  PHASE_EXPAND_VUNBOX,\n-  PHASE_SCALARIZE_VBOX,\n-  PHASE_INLINE_VECTOR_REBOX,\n-  PHASE_EXPAND_VBOX,\n-  PHASE_ELIMINATE_VBOX_ALLOC,\n-  PHASE_PHASEIDEAL_BEFORE_EA,\n-  PHASE_ITER_GVN_AFTER_VECTOR,\n-  PHASE_ITER_GVN_BEFORE_EA,\n-  PHASE_ITER_GVN_AFTER_EA,\n-  PHASE_ITER_GVN_AFTER_ELIMINATION,\n-  PHASE_PHASEIDEALLOOP1,\n-  PHASE_PHASEIDEALLOOP2,\n-  PHASE_PHASEIDEALLOOP3,\n-  PHASE_CCP1,\n-  PHASE_ITER_GVN2,\n-  PHASE_PHASEIDEALLOOP_ITERATIONS,\n-  PHASE_OPTIMIZE_FINISHED,\n-  PHASE_GLOBAL_CODE_MOTION,\n-  PHASE_FINAL_CODE,\n-  PHASE_AFTER_EA,\n-  PHASE_BEFORE_CLOOPS,\n-  PHASE_AFTER_CLOOPS,\n-  PHASE_BEFORE_BEAUTIFY_LOOPS,\n-  PHASE_AFTER_BEAUTIFY_LOOPS,\n-  PHASE_BEFORE_MATCHING,\n-  PHASE_MATCHING,\n-  PHASE_INCREMENTAL_INLINE,\n-  PHASE_INCREMENTAL_INLINE_STEP,\n-  PHASE_INCREMENTAL_INLINE_CLEANUP,\n-  PHASE_INCREMENTAL_BOXING_INLINE,\n-  PHASE_CALL_CATCH_CLEANUP,\n-  PHASE_INSERT_BARRIER,\n-  PHASE_MACRO_EXPANSION,\n-  PHASE_BARRIER_EXPANSION,\n-  PHASE_ADD_UNSAFE_BARRIER,\n-  PHASE_END,\n-  PHASE_FAILURE,\n-  PHASE_SPLIT_INLINES_ARRAY,\n-  PHASE_SPLIT_INLINES_ARRAY_IGVN,\n-  PHASE_DEBUG,\n-  PHASE_NUM_TYPES\n+  COMPILER_PHASES(table_entry)\n+  PHASE_NUM_TYPES,\n+  PHASE_NONE\n+};\n+#undef table_entry\n+\n+static const char* phase_descriptions[] = {\n+#define array_of_labels(name, description) description,\n+       COMPILER_PHASES(array_of_labels)\n+#undef array_of_labels\n+};\n+\n+static const char* phase_names[] = {\n+#define array_of_labels(name, description) #name,\n+       COMPILER_PHASES(array_of_labels)\n+#undef array_of_labels\n@@ -79,50 +95,55 @@\n-  static const char* to_string(CompilerPhaseType cpt) {\n-    switch (cpt) {\n-      case PHASE_BEFORE_STRINGOPTS:          return \"Before StringOpts\";\n-      case PHASE_AFTER_STRINGOPTS:           return \"After StringOpts\";\n-      case PHASE_BEFORE_REMOVEUSELESS:       return \"Before RemoveUseless\";\n-      case PHASE_AFTER_PARSING:              return \"After Parsing\";\n-      case PHASE_ITER_GVN1:                  return \"Iter GVN 1\";\n-      case PHASE_EXPAND_VUNBOX:              return \"Expand VectorUnbox\";\n-      case PHASE_SCALARIZE_VBOX:             return \"Scalarize VectorBox\";\n-      case PHASE_INLINE_VECTOR_REBOX:        return \"Inline Vector Rebox Calls\";\n-      case PHASE_EXPAND_VBOX:                return \"Expand VectorBox\";\n-      case PHASE_ELIMINATE_VBOX_ALLOC:       return \"Eliminate VectorBoxAllocate\";\n-      case PHASE_PHASEIDEAL_BEFORE_EA:       return \"PhaseIdealLoop before EA\";\n-      case PHASE_ITER_GVN_AFTER_VECTOR:      return \"Iter GVN after vector box elimination\";\n-      case PHASE_ITER_GVN_BEFORE_EA:         return \"Iter GVN before EA\";\n-      case PHASE_ITER_GVN_AFTER_EA:          return \"Iter GVN after EA\";\n-      case PHASE_ITER_GVN_AFTER_ELIMINATION: return \"Iter GVN after eliminating allocations and locks\";\n-      case PHASE_PHASEIDEALLOOP1:            return \"PhaseIdealLoop 1\";\n-      case PHASE_PHASEIDEALLOOP2:            return \"PhaseIdealLoop 2\";\n-      case PHASE_PHASEIDEALLOOP3:            return \"PhaseIdealLoop 3\";\n-      case PHASE_CCP1:                       return \"PhaseCCP 1\";\n-      case PHASE_ITER_GVN2:                  return \"Iter GVN 2\";\n-      case PHASE_PHASEIDEALLOOP_ITERATIONS:  return \"PhaseIdealLoop iterations\";\n-      case PHASE_OPTIMIZE_FINISHED:          return \"Optimize finished\";\n-      case PHASE_GLOBAL_CODE_MOTION:         return \"Global code motion\";\n-      case PHASE_FINAL_CODE:                 return \"Final Code\";\n-      case PHASE_AFTER_EA:                   return \"After Escape Analysis\";\n-      case PHASE_BEFORE_CLOOPS:              return \"Before CountedLoop\";\n-      case PHASE_AFTER_CLOOPS:               return \"After CountedLoop\";\n-      case PHASE_BEFORE_BEAUTIFY_LOOPS:      return \"Before beautify loops\";\n-      case PHASE_AFTER_BEAUTIFY_LOOPS:       return \"After beautify loops\";\n-      case PHASE_BEFORE_MATCHING:            return \"Before matching\";\n-      case PHASE_MATCHING:                   return \"After matching\";\n-      case PHASE_INCREMENTAL_INLINE:         return \"Incremental Inline\";\n-      case PHASE_INCREMENTAL_INLINE_STEP:    return \"Incremental Inline Step\";\n-      case PHASE_INCREMENTAL_INLINE_CLEANUP: return \"Incremental Inline Cleanup\";\n-      case PHASE_INCREMENTAL_BOXING_INLINE:  return \"Incremental Boxing Inline\";\n-      case PHASE_CALL_CATCH_CLEANUP:         return \"Call catch cleanup\";\n-      case PHASE_INSERT_BARRIER:             return \"Insert barrier\";\n-      case PHASE_MACRO_EXPANSION:            return \"Macro expand\";\n-      case PHASE_BARRIER_EXPANSION:          return \"Barrier expand\";\n-      case PHASE_ADD_UNSAFE_BARRIER:         return \"Add barrier to unsafe op\";\n-      case PHASE_END:                        return \"End\";\n-      case PHASE_FAILURE:                    return \"Failure\";\n-      case PHASE_SPLIT_INLINES_ARRAY:        return \"Split inlines array\";\n-      case PHASE_SPLIT_INLINES_ARRAY_IGVN:   return \"IGVN after split inlines array\";\n-      case PHASE_DEBUG:                      return \"Debug\";\n-      default:\n-        ShouldNotReachHere();\n-        return NULL;\n+  static const char* to_name(CompilerPhaseType cpt) {\n+    return phase_names[cpt];\n+  }\n+  static const char* to_description(CompilerPhaseType cpt) {\n+    return phase_descriptions[cpt];\n+  }\n+  static int to_bitmask(CompilerPhaseType cpt) {\n+    return (1 << cpt);\n+  }\n+};\n+\n+static CompilerPhaseType find_phase(const char* str) {\n+  for (int i = 0; i < PHASE_NUM_TYPES; i++) {\n+    if (strcmp(phase_names[i], str) == 0) {\n+      return (CompilerPhaseType)i;\n+    }\n+  }\n+  return PHASE_NONE;\n+}\n+\n+class PhaseNameIter {\n+ private:\n+  char* _token;\n+  char* _saved_ptr;\n+  char* _list;\n+\n+ public:\n+  PhaseNameIter(ccstrlist option) {\n+    _list = (char*) canonicalize(option);\n+    _saved_ptr = _list;\n+    _token = strtok_r(_saved_ptr, \",\", &_saved_ptr);\n+  }\n+\n+  ~PhaseNameIter() {\n+    FREE_C_HEAP_ARRAY(char, _list);\n+  }\n+\n+  const char* operator*() const { return _token; }\n+\n+  PhaseNameIter& operator++() {\n+    _token = strtok_r(NULL, \",\", &_saved_ptr);\n+    return *this;\n+  }\n+\n+  ccstrlist canonicalize(ccstrlist option_value) {\n+    char* canonicalized_list = NEW_C_HEAP_ARRAY(char, strlen(option_value) + 1, mtCompiler);\n+    int i = 0;\n+    char current;\n+    while ((current = option_value[i]) != '\\0') {\n+      if (current == '\\n' || current == ' ') {\n+        canonicalized_list[i] = ',';\n+      } else {\n+        canonicalized_list[i] = current;\n+      }\n+      i++;\n@@ -130,0 +151,40 @@\n+    canonicalized_list[i] = '\\0';\n+    return canonicalized_list;\n+  }\n+};\n+\n+class PhaseNameValidator {\n+ private:\n+  bool _valid;\n+  char* _bad;\n+\n+ public:\n+  PhaseNameValidator(ccstrlist option, uint64_t& mask) : _valid(true), _bad(nullptr) {\n+    for (PhaseNameIter iter(option); *iter != NULL && _valid; ++iter) {\n+\n+      CompilerPhaseType cpt = find_phase(*iter);\n+      if (PHASE_NONE == cpt) {\n+        const size_t len = MIN2<size_t>(strlen(*iter), 63) + 1;  \/\/ cap len to a value we know is enough for all phase descriptions\n+        _bad = NEW_C_HEAP_ARRAY(char, len, mtCompiler);\n+        \/\/ strncpy always writes len characters. If the source string is shorter, the function fills the remaining bytes with NULLs.\n+        strncpy(_bad, *iter, len);\n+        _valid = false;\n+      } else {\n+        assert(cpt < 64, \"out of bounds\");\n+        mask |= CompilerPhaseTypeHelper::to_bitmask(cpt);\n+      }\n+    }\n+  }\n+\n+  ~PhaseNameValidator() {\n+    if (_bad != NULL) {\n+      FREE_C_HEAP_ARRAY(char, _bad);\n+    }\n+  }\n+\n+  bool is_valid() const {\n+    return _valid;\n+  }\n+\n+  const char* what() const {\n+    return _bad;\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":157,"deletions":96,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1475,0 +1475,6 @@\n+  \/\/ ret_pc will have been loaded from the stack, so for AArch64 will be signed.\n+  \/\/ This needs authenticating, but to do that here requires the fp of the previous frame.\n+  \/\/ A better way of doing it would be authenticate in the caller by adding a\n+  \/\/ AuthPAuthNode and using it in GraphKit::gen_stub. For now, just strip it.\n+  AARCH64_PORT_ONLY(ret_pc = pauth_strip_pointer(ret_pc));\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -205,0 +205,18 @@\n+  if (n->Opcode() == Op_OpaqueLoopStride || n->Opcode() == Op_OpaqueLoopInit) {\n+    Unique_Node_List wq;\n+    wq.push(n);\n+    for (uint i = 0; i < wq.size(); i++) {\n+      Node* m = wq.at(i);\n+      if (m->is_If()) {\n+        assert(skeleton_predicate_has_opaque(m->as_If()), \"opaque node not reachable from if?\");\n+        Node* bol = clone_skeleton_predicate_bool(m, NULL, NULL, m->in(0));\n+        _igvn.replace_input_of(m, 1, bol);\n+      } else {\n+        assert(!m->is_CFG(), \"not CFG expected\");\n+        for (DUIterator_Fast jmax, j = m->fast_outs(jmax); j < jmax; j++) {\n+          Node* u = m->fast_out(j);\n+          wq.push(u);\n+        }\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  if (in(1)->Opcode() == Op_AddI) {\n+  if (in(1)->Opcode() == Op_AddI || in(1)->Opcode() == Op_AddL) {\n@@ -421,0 +421,4 @@\n+  \/\/ Convert \"(x-y) - x\" into \"-y\"\n+  if (op1 == Op_SubL && in1->in(1) == in2) {\n+    return new SubLNode(phase->makecon(TypeLong::ZERO), in1->in(2));\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-      set_req(ObjOrSubKlass, obj);\n+      set_req_X(ObjOrSubKlass, obj, phase);\n@@ -161,1 +161,1 @@\n-    set_req(ObjOrSubKlass, allocated_klass);\n+    set_req_X(ObjOrSubKlass, allocated_klass, phase);\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoader.inline.hpp\"\n@@ -491,1 +491,1 @@\n-JVM_ENTRY_NO_ENV(jboolean, JVM_IsUseContainerSupport(void))\n+JVM_LEAF(jboolean, JVM_IsUseContainerSupport(void))\n@@ -716,1 +716,1 @@\n-JVM_ENTRY(jboolean, JVM_IsFinalizationEnabled(JNIEnv * env))\n+JVM_LEAF(jboolean, JVM_IsFinalizationEnabled(JNIEnv * env))\n@@ -2937,0 +2937,20 @@\n+#if INCLUDE_CDS\n+  if (DumpSharedSpaces) {\n+    \/\/ During java -Xshare:dump, if we allow multiple Java threads to\n+    \/\/ execute in parallel, symbols and classes may be loaded in\n+    \/\/ random orders which will make the resulting CDS archive\n+    \/\/ non-deterministic.\n+    \/\/\n+    \/\/ Lucikly, during java -Xshare:dump, it's important to run only\n+    \/\/ the code in the main Java thread (which is NOT started here) that\n+    \/\/ creates the module graph, etc. It's safe to not start the other\n+    \/\/ threads which are launched by class static initializers\n+    \/\/ (ReferenceHandler, FinalizerThread and CleanerImpl).\n+    if (log_is_enabled(Info, cds)) {\n+      ResourceMark rm;\n+      oop t = JNIHandles::resolve_non_null(jthread);\n+      log_info(cds)(\"JVM_StartThread() ignored: %s\", t->klass()->external_name());\n+    }\n+    return;\n+  }\n+#endif\n@@ -3107,1 +3127,1 @@\n-JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))\n+JVM_LEAF(void, JVM_Yield(JNIEnv *env, jclass threadClass))\n@@ -3445,0 +3465,5 @@\n+JVM_LEAF(void*, JVM_LoadZipLibrary())\n+  ClassLoader::load_zip_library_if_needed();\n+  return ClassLoader::zip_library_handle();\n+JVM_END\n+\n@@ -3710,1 +3735,1 @@\n-JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))\n+JVM_LEAF(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))\n@@ -3714,1 +3739,1 @@\n-JVM_ENTRY(jboolean, JVM_IsSharingEnabled(JNIEnv* env))\n+JVM_LEAF(jboolean, JVM_IsSharingEnabled(JNIEnv* env))\n@@ -3740,1 +3765,1 @@\n-JVM_ENTRY(jboolean, JVM_IsDumpingClassList(JNIEnv *env))\n+JVM_LEAF(jboolean, JVM_IsDumpingClassList(JNIEnv *env))\n@@ -3756,1 +3781,1 @@\n-      \/\/ Note: LambdaFormInvokers::append_filtered and LambdaFormInvokers::append take same format which is not\n+      \/\/ Note: LambdaFormInvokers::append take same format which is not\n@@ -3758,1 +3783,1 @@\n-      LambdaFormInvokers::append_filtered(os::strdup((const char*)c_line, mtInternal));\n+      LambdaFormInvokers::append(os::strdup((const char*)c_line, mtInternal));\n@@ -3849,1 +3874,1 @@\n-JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))\n+JVM_LEAF(void*, JVM_GetManagement(jint version))\n@@ -3938,1 +3963,1 @@\n-JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))\n+JVM_LEAF(jint, JVM_FindSignal(const char *name))\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":36,"deletions":11,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -291,0 +291,25 @@\n+\/\/ Write MethodParameters attribute\n+\/\/ JVMSpec|   MethodParameters_attribute {\n+\/\/ JVMSpec|     u2 attribute_name_index;\n+\/\/ JVMSpec|     u4 attribute_length;\n+\/\/ JVMSpec|     u1 parameters_count;\n+\/\/ JVMSpec|     {   u2 name_index;\n+\/\/ JVMSpec|         u2 access_flags;\n+\/\/ JVMSpec|     } parameters[parameters_count];\n+\/\/ JVMSpec|   }\n+void JvmtiClassFileReconstituter::write_method_parameter_attribute(const ConstMethod* const_method) {\n+  const MethodParametersElement *parameters = const_method->method_parameters_start();\n+  int length = const_method->method_parameters_length();\n+  assert(length <= max_jubyte, \"must fit u1\");\n+  int size = 1                  \/\/ parameters_count\n+           + (2 + 2) * length;  \/\/ parameters\n+\n+  write_attribute_name_index(\"MethodParameters\");\n+  write_u4(size);\n+  write_u1(length);\n+  for (int index = 0; index < length; index++) {\n+    write_u2(parameters[index].name_cp_index);\n+    write_u2(parameters[index].flags);\n+  }\n+}\n+\n@@ -693,0 +718,3 @@\n+  if (const_method->has_method_parameters()) {\n+    ++attr_count;     \/\/ has MethodParameters attribute\n+  }\n@@ -720,0 +748,3 @@\n+  if (const_method->has_method_parameters()) {\n+    write_method_parameter_attribute(const_method);\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2316,15 +2316,0 @@\n-\n-  \/\/ We also need to rewrite the parameter name indexes, if there is\n-  \/\/ method parameter data present\n-  if(method->has_method_parameters()) {\n-    const int len = method->method_parameters_length();\n-    MethodParametersElement* elem = method->method_parameters_start();\n-\n-    for (int i = 0; i < len; i++) {\n-      const u2 cp_index = elem[i].name_cp_index;\n-      const u2 new_cp_index = find_new_index(cp_index);\n-      if (new_cp_index != 0) {\n-        elem[i].name_cp_index = new_cp_index;\n-      }\n-    }\n-  }\n@@ -3744,0 +3729,13 @@\n+    \/\/ Update constant pool indices in the method's method_parameters.\n+    int mp_length = method->method_parameters_length();\n+    if (mp_length > 0) {\n+      MethodParametersElement* elem = method->method_parameters_start();\n+      for (int j = 0; j < mp_length; j++) {\n+        const int cp_index = elem[j].name_cp_index;\n+        const int new_cp_index = find_new_index(cp_index);\n+        if (new_cp_index != 0) {\n+          elem[j].name_cp_index = (u2)new_cp_index;\n+        }\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,5 @@\n-  _adapter_code = MethodHandlesAdapterBlob::create(adapter_code_size);\n+  \/\/ The adapter entry is required to be aligned to CodeEntryAlignment.\n+  \/\/ So we need additional bytes due to alignment.\n+  int adapter_num = (int)Interpreter::method_handle_invoke_LAST - (int)Interpreter::method_handle_invoke_FIRST + 1;\n+  int max_aligned_bytes = adapter_num * CodeEntryAlignment;\n+  _adapter_code = MethodHandlesAdapterBlob::create(adapter_code_size + max_aligned_bytes);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2157,0 +2157,8 @@\n+WB_ENTRY(jboolean, WB_IsDTraceIncluded(JNIEnv* env))\n+#if defined(DTRACE_ENABLED)\n+  return true;\n+#else\n+  return false;\n+#endif \/\/ DTRACE_ENABLED\n+WB_END\n+\n@@ -2808,0 +2816,1 @@\n+  {CC\"isDTraceIncluded\",                  CC\"()Z\",    (void*)&WB_IsDTraceIncluded },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -59,0 +60,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -66,0 +68,1 @@\n+#include <limits>\n@@ -540,0 +543,3 @@\n+  { \"ExtendedDTraceProbes\",         JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n+  { \"UseContainerCpuShares\",        JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n+  { \"PreferContainerQuotaForCPUCount\", JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n@@ -550,0 +556,1 @@\n+  { \"PrefetchFieldsAhead\",          JDK_Version::undefined(), JDK_Version::jdk(19), JDK_Version::jdk(20) },\n@@ -743,3 +750,13 @@\n-\/\/ Parses a size specification string.\n-bool Arguments::atojulong(const char *s, julong* result) {\n-  julong n = 0;\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ signed 32-bit\n+static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  \/\/ Don't use strtol -- on 64-bit builds, \"long\" could be either 32- or 64-bits\n+  \/\/ so the range tests could be tautological and might cause compiler warnings.\n+  STATIC_ASSERT(sizeof(long long) >= 8); \/\/ C++ specification\n+  errno = 0; \/\/ errno is thread safe\n+  long long v = strtoll(s, endptr, base);\n+  if (errno != 0 || v < min_jint || v > max_jint) {\n+    return false;\n+  }\n+  *result = static_cast<T>(v);\n+  return true;\n+}\n@@ -747,2 +764,3 @@\n-  \/\/ First char must be a digit. Don't allow negative numbers or leading spaces.\n-  if (!isdigit(*s)) {\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ unsigned 32-bit\n+static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  if (s[0] == '-') {\n@@ -751,0 +769,10 @@\n+  \/\/ Don't use strtoul -- same reason as above.\n+  STATIC_ASSERT(sizeof(unsigned long long) >= 8); \/\/ C++ specification\n+  errno = 0; \/\/ errno is thread safe\n+  unsigned long long v = strtoull(s, endptr, base);\n+  if (errno != 0 || v > max_juint) {\n+    return false;\n+  }\n+  *result = static_cast<T>(v);\n+  return true;\n+}\n@@ -752,1 +780,45 @@\n-  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'));\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ signed 64-bit\n+static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  errno = 0; \/\/ errno is thread safe\n+  *result = strtoll(s, endptr, base);\n+  return errno == 0;\n+}\n+\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ unsigned 64-bit\n+static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  if (s[0] == '-') {\n+    return false;\n+  }\n+  errno = 0; \/\/ errno is thread safe\n+  *result = strtoull(s, endptr, base);\n+  return errno == 0;\n+}\n+\n+template<typename T>\n+static bool multiply_by_1k(T& n) {\n+  if (n >= std::numeric_limits<T>::min() \/ 1024 &&\n+      n <= std::numeric_limits<T>::max() \/ 1024) {\n+    n *= 1024;\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ All of the integral types that can be used for command line options:\n+\/\/   int, uint, intx, uintx, uint64_t, size_t\n+\/\/\n+\/\/ In all supported platforms, these types can be mapped to only 4 native types:\n+\/\/    {signed, unsigned} x {32-bit, 64-bit}\n+\/\/\n+\/\/ We use SFINAE to pick the correct parse_integer_impl() function\n+template<typename T>\n+static bool parse_integer(const char *s, T* result) {\n+  if (!isdigit(s[0]) && s[0] != '-') {\n+    \/\/ strtoll\/strtoull may allow leading spaces. Forbid it.\n+    return false;\n+  }\n+\n+  T n = 0;\n+  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ||\n+                (s[0] == '-' && s[1] == '0' && (s[2] == 'x' || s[3] == 'X'));\n@@ -754,3 +826,2 @@\n-  errno = 0;\n-  n = strtoull(s, &remainder, (is_hex ? 16 : 10));\n-  if (errno != 0) {\n+\n+  if (!parse_integer_impl(s, &remainder, (is_hex ? 16 : 10), &n)) {\n@@ -767,4 +838,2 @@\n-      *result = n * G * K;\n-      \/\/ Check for overflow.\n-      if (*result\/((julong)G * K) != n) return false;\n-      return true;\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n@@ -772,3 +841,2 @@\n-      *result = n * G;\n-      if (*result\/G != n) return false;\n-      return true;\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n@@ -776,3 +844,2 @@\n-      *result = n * M;\n-      if (*result\/M != n) return false;\n-      return true;\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n@@ -780,3 +847,2 @@\n-      *result = n * K;\n-      if (*result\/K != n) return false;\n-      return true;\n+      if (!multiply_by_1k(n)) return false;\n+      break;\n@@ -784,2 +850,1 @@\n-      *result = n;\n-      return true;\n+      break;\n@@ -789,0 +854,7 @@\n+\n+  *result = n;\n+  return true;\n+}\n+\n+bool Arguments::atojulong(const char *s, julong* result) {\n+  return parse_integer(s, result);\n@@ -837,6 +909,1 @@\n-static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n-  julong v;\n-  int int_v;\n-  intx intx_v;\n-  bool is_neg = false;\n-\n+static JVMFlag::Error set_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n@@ -844,1 +911,1 @@\n-    return false;\n+    return JVMFlag::INVALID_FLAG;\n@@ -847,14 +914,3 @@\n-  \/\/ Check the sign first since atojulong() parses only unsigned values.\n-  if (*value == '-') {\n-    if (!flag->is_intx() && !flag->is_int()) {\n-      return false;\n-    }\n-    value++;\n-    is_neg = true;\n-  }\n-  if (!Arguments::atojulong(value, &v)) {\n-    return false;\n-  }\n-    int_v = (int) v;\n-    if (is_neg) {\n-      int_v = -int_v;\n+    int v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_int(flag, &v, origin);\n@@ -863,3 +919,4 @@\n-    return JVMFlagAccess::set_int(flag, &int_v, origin) == JVMFlag::SUCCESS;\n-    uint uint_v = (uint) v;\n-    return JVMFlagAccess::set_uint(flag, &uint_v, origin) == JVMFlag::SUCCESS;\n+    uint v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_uint(flag, &v, origin);\n+    }\n@@ -868,3 +925,3 @@\n-    intx_v = (intx) v;\n-    if (is_neg) {\n-      intx_v = -intx_v;\n+    intx v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_intx(flag, &v, origin);\n@@ -872,3 +929,4 @@\n-    return JVMFlagAccess::set_intx(flag, &intx_v, origin) == JVMFlag::SUCCESS;\n-    uintx uintx_v = (uintx) v;\n-    return JVMFlagAccess::set_uintx(flag, &uintx_v, origin) == JVMFlag::SUCCESS;\n+    uintx v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_uintx(flag, &v, origin);\n+    }\n@@ -877,2 +935,4 @@\n-    uint64_t uint64_t_v = (uint64_t) v;\n-    return JVMFlagAccess::set_uint64_t(flag, &uint64_t_v, origin) == JVMFlag::SUCCESS;\n+    uint64_t v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_uint64_t(flag, &v, origin);\n+    }\n@@ -880,2 +940,4 @@\n-    size_t size_t_v = (size_t) v;\n-    return JVMFlagAccess::set_size_t(flag, &size_t_v, origin) == JVMFlag::SUCCESS;\n+    size_t v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_size_t(flag, &v, origin);\n+    }\n@@ -883,4 +945,12 @@\n-    double double_v = (double) v;\n-    return JVMFlagAccess::set_double(flag, &double_v, origin) == JVMFlag::SUCCESS;\n-  } else {\n-    return false;\n+    \/\/ This function parses only input strings without a decimal\n+    \/\/ point character (.)\n+    \/\/ If a string looks like a FP number, it would be parsed by\n+    \/\/ set_fp_numeric_flag(). See Arguments::parse_argument().\n+    jlong v;\n+    if (parse_integer(value, &v)) {\n+      double double_v = (double) v;\n+      if (value[0] == '-' && v == 0) { \/\/ special case: 0.0 is different than -0.0.\n+        double_v = -0.0;\n+      }\n+      return JVMFlagAccess::set_double(flag, &double_v, origin);\n+    }\n@@ -888,0 +958,2 @@\n+\n+  return JVMFlag::WRONG_FORMAT;\n@@ -1049,1 +1121,1 @@\n-    return set_numeric_flag(flag, value, origin);\n+    return set_numeric_flag(flag, value, origin) == JVMFlag::SUCCESS;\n@@ -2076,16 +2148,9 @@\n-\n-  \/\/ Check the sign first since atojulong() parses only unsigned values.\n-  bool value_is_positive = !(*value == '-');\n-\n-  if (value_is_positive) {\n-    julong n;\n-    bool good_return = atojulong(value, &n);\n-    if (good_return) {\n-      bool above_minimum = n >= min_size;\n-      bool value_is_too_large = n > max_uintx;\n-\n-      if (above_minimum && !value_is_too_large) {\n-        *uintx_arg = n;\n-        return true;\n-      }\n-    }\n+  uintx n;\n+  if (!parse_integer(value, &n)) {\n+    return false;\n+  }\n+  if (n >= min_size) {\n+    *uintx_arg = n;\n+    return true;\n+  } else {\n+    return false;\n@@ -2093,1 +2158,0 @@\n-  return false;\n@@ -2144,1 +2208,1 @@\n-  if (!atojulong(s, long_arg)) return arg_unreadable;\n+  if (!parse_integer(s, long_arg)) return arg_unreadable;\n@@ -2899,0 +2963,2 @@\n+      warning(\"Option ExtendedDTraceProbes was deprecated in version 19 and will likely be removed in a future release.\");\n+      warning(\"Use the combination of -XX:+DTraceMethodProbes, -XX:+DTraceAllocProbes and -XX:+DTraceMonitorProbes instead.\");\n@@ -2915,0 +2981,12 @@\n+    } else if (match_option(option, \"-XX:+DTraceMethodProbes\")) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"DTraceMethodProbes flag is not applicable for this configuration\\n\");\n+      return JNI_EINVAL;\n+    } else if (match_option(option, \"-XX:+DTraceAllocProbes\")) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"DTraceAllocProbes flag is not applicable for this configuration\\n\");\n+      return JNI_EINVAL;\n+    } else if (match_option(option, \"-XX:+DTraceMonitorProbes\")) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"DTraceMonitorProbes flag is not applicable for this configuration\\n\");\n+      return JNI_EINVAL;\n@@ -3607,0 +3685,4 @@\n+            if (AutoCreateSharedArchive) {\n+              warning(\"-XX:+AutoCreateSharedArchive is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n+              AutoCreateSharedArchive = false;\n+            }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":163,"deletions":81,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -738,0 +738,15 @@\n+#ifndef PRODUCT\n+static bool falls_through(Bytecodes::Code bc) {\n+  switch (bc) {\n+    \/\/ List may be incomplete.  Here we really only care about bytecodes where compiled code\n+    \/\/ can deoptimize.\n+    case Bytecodes::_goto:\n+    case Bytecodes::_goto_w:\n+    case Bytecodes::_athrow:\n+      return false;\n+    default:\n+      return true;\n+  }\n+}\n+#endif\n+\n@@ -835,1 +850,1 @@\n-          if (!Bytecodes::is_invoke(cur_code) && cur_code != Bytecodes::_athrow) {\n+          if (!Bytecodes::is_invoke(cur_code) && falls_through(cur_code)) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1154,0 +1154,5 @@\n+#ifdef TARGET_ARCH_aarch64\n+  if (!pauth_ptr_is_raw(x)) {\n+    return false;\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -210,0 +210,1 @@\n+  \/\/ might crash if the frame has no parent\n@@ -212,0 +213,3 @@\n+  \/\/ Link (i.e., the pointer to the previous frame) or null if the link cannot be accessed\n+  intptr_t* link_or_null() const;\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1543,1 +1543,1 @@\n-  develop_pd(uintx, CodeCacheSegmentSize,                                   \\\n+  product_pd(uintx, CodeCacheSegmentSize, EXPERIMENTAL,                     \\\n@@ -1549,1 +1549,1 @@\n-  develop_pd(intx, CodeEntryAlignment,                                      \\\n+  product_pd(intx, CodeEntryAlignment, EXPERIMENTAL,                        \\\n@@ -1555,1 +1555,1 @@\n-          range(1, 16)                                                      \\\n+          range(1, 128)                                                     \\\n@@ -1879,1 +1879,3 @@\n-          \"Enable performance-impacting dtrace probes\")                     \\\n+          \"(Deprecated) Enable performance-impacting dtrace probes. \"       \\\n+          \"Use the combination of -XX:+DTraceMethodProbes, \"                \\\n+          \"-XX:+DTraceAllocProbes and -XX:+DTraceMonitorProbes instead.\")   \\\n@@ -1882,1 +1884,1 @@\n-          \"Enable dtrace probes for method-entry and method-exit\")          \\\n+          \"Enable dtrace tool probes for method-entry and method-exit\")     \\\n@@ -1885,1 +1887,1 @@\n-          \"Enable dtrace probes for object allocation\")                     \\\n+          \"Enable dtrace tool probes for object allocation\")                \\\n@@ -1888,1 +1890,1 @@\n-          \"Enable dtrace probes for monitor events\")                        \\\n+          \"Enable dtrace tool probes for monitor events\")                   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -399,1 +399,1 @@\n-  \/\/ stack_shadow_pages_available() and bang_stack_shadow_pages() use the same sp.\n+  \/\/ stack_shadow_pages_available() and map_stack_shadow_pages() use the same sp.\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -427,4 +427,9 @@\n-  }\n-  if (block != NULL) {\n-    Atomic::dec(&_blocks_allocated);\n-    delete block;\n+  } else {\n+    DEBUG_ONLY(block->set_pop_frame_link(NULL));\n+    while (block != NULL) {\n+      JNIHandleBlock* next = block->_next;\n+      Atomic::dec(&_blocks_allocated);\n+      assert(block->pop_frame_link() == NULL, \"pop_frame_link should be NULL\");\n+      delete block;\n+      block = next;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2017,0 +2017,2 @@\n+  AARCH64_PORT_ONLY(assert(pauth_ptr_is_raw(caller_pc), \"should be raw\"));\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,1 +221,4 @@\n-    _code1 = BufferBlob::create(\"StubRoutines (1)\", code_size1);\n+    \/\/ Add extra space for large CodeEntryAlignment\n+    int max_aligned_stubs = 10;\n+    int size = code_size1 + CodeEntryAlignment * max_aligned_stubs;\n+    _code1 = BufferBlob::create(\"StubRoutines (1)\", size);\n@@ -275,1 +278,4 @@\n-    _code2 = BufferBlob::create(\"StubRoutines (2)\", code_size2);\n+    \/\/ Add extra space for large CodeEntryAlignment\n+    int max_aligned_stubs = 100;\n+    int size = code_size2 + CodeEntryAlignment * max_aligned_stubs;\n+    _code2 = BufferBlob::create(\"StubRoutines (2)\", size);\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -340,2 +340,0 @@\n-  register_thread_stack_with_NMT();\n-\n@@ -344,0 +342,2 @@\n+  register_thread_stack_with_NMT();\n+\n@@ -1377,15 +1377,15 @@\n-    \/\/ Call Thread.exit(). We try 3 times in case we got another Thread.stop during\n-    \/\/ the execution of the method. If that is not enough, then we don't really care. Thread.stop\n-    \/\/ is deprecated anyhow.\n-      int count = 3;\n-      while (java_lang_Thread::threadGroup(threadObj()) != NULL && (count-- > 0)) {\n-        EXCEPTION_MARK;\n-        JavaValue result(T_VOID);\n-        Klass* thread_klass = vmClasses::Thread_klass();\n-        JavaCalls::call_virtual(&result,\n-                                threadObj, thread_klass,\n-                                vmSymbols::exit_method_name(),\n-                                vmSymbols::void_method_signature(),\n-                                THREAD);\n-        CLEAR_PENDING_EXCEPTION;\n-      }\n+      \/\/ We have finished executing user-defined Java code and now have to do the\n+      \/\/ implementation specific clean-up by calling Thread.exit(). We prevent any\n+      \/\/ asynchronous exceptions from being delivered while in Thread.exit()\n+      \/\/ to ensure the clean-up is not corrupted.\n+      NoAsyncExceptionDeliveryMark _no_async(this);\n+\n+      EXCEPTION_MARK;\n+      JavaValue result(T_VOID);\n+      Klass* thread_klass = vmClasses::Thread_klass();\n+      JavaCalls::call_virtual(&result,\n+                              threadObj, thread_klass,\n+                              vmSymbols::exit_method_name(),\n+                              vmSymbols::void_method_signature(),\n+                              THREAD);\n+      CLEAR_PENDING_EXCEPTION;\n@@ -1394,0 +1394,1 @@\n+\n@@ -1596,1 +1597,1 @@\n-    \/\/ ok because the call we a returning from already collides\n+    \/\/ ok because the call we are returning from already collides\n@@ -1617,0 +1618,3 @@\n+    if ((_suspend_flags & _async_delivery_disabled) != 0) {\n+      log_info(exceptions)(\"Async exception delivery is disabled\");\n+    }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -790,3 +790,4 @@\n-    _has_async_exception    = 0x00000001U, \/\/ there is a pending async exception\n-    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n-    _obj_deopt              = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n+    _has_async_exception     = 0x00000001U, \/\/ there is a pending async exception\n+    _async_delivery_disabled = 0x00000002U, \/\/ async exception delivery is disabled\n+    _trace_flag              = 0x00000004U, \/\/ call tracing backend\n+    _obj_deopt               = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n@@ -820,1 +821,2 @@\n-    return (_suspend_flags & _has_async_exception) != 0;\n+    return (_suspend_flags & _has_async_exception) != 0 &&\n+           (_suspend_flags & _async_delivery_disabled) == 0;\n@@ -828,0 +830,7 @@\n+  class NoAsyncExceptionDeliveryMark : public StackObj {\n+    friend JavaThread;\n+    JavaThread *_target;\n+    inline NoAsyncExceptionDeliveryMark(JavaThread *t);\n+    inline ~NoAsyncExceptionDeliveryMark();\n+  };\n+\n@@ -1308,0 +1317,6 @@\n+  static ByteSize shadow_zone_safe_limit()  {\n+    return byte_offset_of(JavaThread, _stack_overflow_state._shadow_zone_safe_limit);\n+  }\n+  static ByteSize shadow_zone_growth_watermark()  {\n+    return byte_offset_of(JavaThread, _stack_overflow_state._shadow_zone_growth_watermark);\n+  }\n@@ -1326,2 +1341,4 @@\n-    \/\/ We can't get here in a thread that has completed its execution and so\n-    \/\/ \"is_terminated\", but a thread is also considered terminated if the VM\n+    \/\/ We can't normally get here in a thread that has completed its\n+    \/\/ execution and so \"is_terminated\", except when the call is from\n+    \/\/ AsyncGetCallTrace, which can be triggered by a signal at any point in\n+    \/\/ a thread's lifecycle. A thread is also considered terminated if the VM\n@@ -1333,1 +1350,0 @@\n-      ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  template(PrintClasses)                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -665,1 +665,1 @@\n-  volatile_nonstatic_field(nmethod,            _stack_traversal_mark,                         long)                                  \\\n+  volatile_nonstatic_field(nmethod,            _stack_traversal_mark,                         int64_t)                               \\\n@@ -1204,0 +1204,1 @@\n+  declare_integer_type(int64_t)                                           \\\n@@ -1854,0 +1855,3 @@\n+  declare_c2_type(VectorUCastB2XNode, VectorNode)                         \\\n+  declare_c2_type(VectorUCastS2XNode, VectorNode)                         \\\n+  declare_c2_type(VectorUCastI2XNode, VectorNode)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -105,0 +106,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassesDCmd>(full_export, true, false));\n@@ -981,0 +983,35 @@\n+ClassesDCmd::ClassesDCmd(outputStream* output, bool heap) :\n+                                     DCmdWithParser(output, heap),\n+  _verbose(\"-verbose\",\n+           \"Dump the detailed content of a Java class. \"\n+           \"Some classes are annotated with flags: \"\n+           \"F = has, or inherits, a non-empty finalize method, \"\n+           \"f = has final method, \"\n+           \"W = methods rewritten, \"\n+           \"C = marked with @Contended annotation, \"\n+           \"R = has been redefined, \"\n+           \"S = is shared class\",\n+           \"BOOLEAN\", false, \"false\") {\n+  _dcmdparser.add_dcmd_option(&_verbose);\n+}\n+\n+class VM_PrintClasses : public VM_Operation {\n+private:\n+  outputStream* _out;\n+  bool _verbose;\n+public:\n+  VM_PrintClasses(outputStream* out, bool verbose) : _out(out), _verbose(verbose) {}\n+\n+  virtual VMOp_Type type() const { return VMOp_PrintClasses; }\n+\n+  virtual void doit() {\n+    PrintClassClosure closure(_out, _verbose);\n+    ClassLoaderDataGraph::classes_do(&closure);\n+  }\n+};\n+\n+void ClassesDCmd::execute(DCmdSource source, TRAPS) {\n+  VM_PrintClasses vmop(output(), _verbose.is_set());\n+  VMThread::execute(&vmop);\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -886,0 +886,22 @@\n+class ClassesDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _verbose;\n+public:\n+  ClassesDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"VM.classes\";\n+  }\n+  static const char* description() {\n+    return \"Print all loaded classes\";\n+  }\n+  static const char* impact() {\n+      return \"Medium: Depends on number of loaded classes.\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -958,6 +958,4 @@\n-  \/\/ creates HPROF_GC_CLASS_DUMP record for the given class and each of its\n-  \/\/ array classes\n-  static void dump_class_and_array_classes(AbstractDumpWriter* writer, Klass* k);\n-  \/\/ creates HPROF_GC_CLASS_DUMP record for a given primitive array\n-  \/\/ class (and each multi-dimensional array class too)\n-  static void dump_basic_type_array_class(AbstractDumpWriter* writer, Klass* k);\n+  \/\/ creates HPROF_GC_CLASS_DUMP record for the given instance class\n+  static void dump_instance_class(AbstractDumpWriter* writer, Klass* k);\n+  \/\/ creates HPROF_GC_CLASS_DUMP record for a given array class\n+  static void dump_array_class(AbstractDumpWriter* writer, Klass* k);\n@@ -1356,3 +1354,2 @@\n-\/\/ creates HPROF_GC_CLASS_DUMP record for the given class and each of\n-\/\/ its array classes\n-void DumperSupport::dump_class_and_array_classes(AbstractDumpWriter* writer, Klass* k) {\n+\/\/ creates HPROF_GC_CLASS_DUMP record for the given instance class\n+void DumperSupport::dump_instance_class(AbstractDumpWriter* writer, Klass* k) {\n@@ -1411,0 +1408,1 @@\n+}\n@@ -1412,30 +1410,9 @@\n-  \/\/ array classes\n-  k = k->array_klass_or_null();\n-  while (k != NULL) {\n-    assert(k->is_objArray_klass(), \"not an ObjArrayKlass\");\n-\n-    u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;\n-    writer->start_sub_record(HPROF_GC_CLASS_DUMP, size);\n-    writer->write_classID(k);\n-    writer->write_u4(STACK_TRACE_ID);\n-\n-    \/\/ super class of array classes is java.lang.Object\n-    java_super = k->java_super();\n-    assert(java_super != NULL, \"checking\");\n-    writer->write_classID(java_super);\n-\n-    writer->write_objectID(ik->class_loader());\n-    writer->write_objectID(ik->signers());\n-    writer->write_objectID(ik->protection_domain());\n-\n-    writer->write_objectID(oop(NULL));    \/\/ reserved\n-    writer->write_objectID(oop(NULL));\n-    writer->write_u4(0);             \/\/ instance size\n-    writer->write_u2(0);             \/\/ constant pool\n-    writer->write_u2(0);             \/\/ static fields\n-    writer->write_u2(0);             \/\/ instance fields\n-\n-    writer->end_sub_record();\n-\n-    \/\/ get the array class for the next rank\n-    k = k->array_klass_or_null();\n+\/\/ creates HPROF_GC_CLASS_DUMP record for the given array class\n+void DumperSupport::dump_array_class(AbstractDumpWriter* writer, Klass* k) {\n+  InstanceKlass* ik = NULL; \/\/ bottom class for object arrays, NULL for primitive type arrays\n+  if (k->is_objArray_klass()) {\n+    Klass *bk = ObjArrayKlass::cast(k)->bottom_klass();\n+    assert(bk != NULL, \"checking\");\n+    if (bk->is_instance_klass()) {\n+      ik = InstanceKlass::cast(bk);\n+    }\n@@ -1443,17 +1420,4 @@\n-}\n-\/\/ creates HPROF_GC_CLASS_DUMP record for a given primitive array\n-\/\/ class (and each multi-dimensional array class too)\n-void DumperSupport::dump_basic_type_array_class(AbstractDumpWriter* writer, Klass* k) {\n-  \/\/ array classes\n-  while (k != NULL) {\n-    Klass* klass = k;\n-\n-    u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;\n-    writer->start_sub_record(HPROF_GC_CLASS_DUMP, size);\n-    writer->write_classID(klass);\n-    writer->write_u4(STACK_TRACE_ID);\n-\n-    \/\/ super class of array classes is java.lang.Object\n-    InstanceKlass* java_super = klass->java_super();\n-    assert(java_super != NULL, \"checking\");\n-    writer->write_classID(java_super);\n+  u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;\n+  writer->start_sub_record(HPROF_GC_CLASS_DUMP, size);\n+  writer->write_classID(k);\n+  writer->write_u4(STACK_TRACE_ID);\n@@ -1462,3 +1426,4 @@\n-    writer->write_objectID(oop(NULL));    \/\/ loader\n-    writer->write_objectID(oop(NULL));    \/\/ signers\n-    writer->write_objectID(oop(NULL));    \/\/ protection domain\n+  \/\/ super class of array classes is java.lang.Object\n+  InstanceKlass* java_super = k->java_super();\n+  assert(java_super != NULL, \"checking\");\n+  writer->write_classID(java_super);\n@@ -1466,6 +1431,3 @@\n-    writer->write_objectID(oop(NULL));    \/\/ reserved\n-    writer->write_objectID(oop(NULL));\n-    writer->write_u4(0);             \/\/ instance size\n-    writer->write_u2(0);             \/\/ constant pool\n-    writer->write_u2(0);             \/\/ static fields\n-    writer->write_u2(0);             \/\/ instance fields\n+  writer->write_objectID(ik == NULL ? oop(NULL) : ik->class_loader());\n+  writer->write_objectID(ik == NULL ? oop(NULL) : ik->signers());\n+  writer->write_objectID(ik == NULL ? oop(NULL) : ik->protection_domain());\n@@ -1473,1 +1435,8 @@\n-    writer->end_sub_record();\n+  writer->write_objectID(oop(NULL));    \/\/ reserved\n+  writer->write_objectID(oop(NULL));\n+  writer->write_u4(0);             \/\/ instance size\n+  writer->write_u2(0);             \/\/ constant pool\n+  writer->write_u2(0);             \/\/ static fields\n+  writer->write_u2(0);             \/\/ instance fields\n+\n+  writer->end_sub_record();\n@@ -1475,3 +1444,0 @@\n-    \/\/ get the array class for the next rank\n-    k = klass->array_klass_or_null();\n-  }\n@@ -2072,1 +2038,0 @@\n-  class ClassesDo;\n@@ -2076,1 +2041,0 @@\n-  \/\/ (and each array class too)\n@@ -2079,4 +2043,0 @@\n-  \/\/ writes a HPROF_GC_CLASS_DUMP records for a given basic type\n-  \/\/ array (and each multi-dimensional array too)\n-  static void do_basic_type_array_class_dump(Klass* k);\n-\n@@ -2163,2 +2123,1 @@\n-\/\/ writes a HPROF_LOAD_CLASS record for the class (and each of its\n-\/\/ array classes)\n+\/\/ writes a HPROF_LOAD_CLASS record for the class\n@@ -2171,6 +2130,1 @@\n-  \/\/ write a HPROF_LOAD_CLASS for the class and each array class\n-  do {\n-    DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);\n-\n-    \/\/ class serial number is just a number\n-    writer()->write_u4(++class_serial_num);\n+  DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);\n@@ -2178,3 +2132,2 @@\n-    \/\/ class ID\n-    Klass* klass = k;\n-    writer()->write_classID(klass);\n+  \/\/ class serial number is just a number\n+  writer()->write_u4(++class_serial_num);\n@@ -2182,2 +2135,2 @@\n-    \/\/ add the Klass* and class serial number pair\n-    dumper()->add_class_serial_number(klass, class_serial_num);\n+  \/\/ class ID\n+  writer()->write_classID(k);\n@@ -2185,1 +2138,2 @@\n-    writer()->write_u4(STACK_TRACE_ID);\n+  \/\/ add the Klass* and class serial number pair\n+  dumper()->add_class_serial_number(k, class_serial_num);\n@@ -2187,3 +2141,1 @@\n-    \/\/ class name ID\n-    Symbol* name = klass->name();\n-    writer()->write_symbolID(name);\n+  writer()->write_u4(STACK_TRACE_ID);\n@@ -2191,3 +2143,3 @@\n-    \/\/ write a LOAD_CLASS record for the array type (if it exists)\n-    k = klass->array_klass_or_null();\n-  } while (k != NULL);\n+  \/\/ class name ID\n+  Symbol* name = k->name();\n+  writer()->write_symbolID(name);\n@@ -2199,1 +2151,3 @@\n-    DumperSupport::dump_class_and_array_classes(writer(), k);\n+    DumperSupport::dump_instance_class(writer(), k);\n+  } else {\n+    DumperSupport::dump_array_class(writer(), k);\n@@ -2203,6 +2157,0 @@\n-\/\/ writes a HPROF_GC_CLASS_DUMP records for a given basic type\n-\/\/ array (and each multi-dimensional array too)\n-void VM_HeapDumper::do_basic_type_array_class_dump(Klass* k) {\n-  DumperSupport::dump_basic_type_array_class(writer(), k);\n-}\n-\n@@ -2427,1 +2375,0 @@\n-    Universe::basic_type_classes_do(&do_load_class);\n@@ -2438,1 +2385,0 @@\n-    Universe::basic_type_classes_do(&do_basic_type_array_class_dump);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":51,"deletions":105,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -94,0 +94,7 @@\n+  bool is_in_error() const {\n+    return is_unresolved_klass_in_error() ||\n+           is_method_handle_in_error()    ||\n+           is_method_type_in_error()      ||\n+           is_dynamic_constant_in_error();\n+  }\n+\n@@ -134,2 +141,7 @@\n-  static constantTag ofBasicType(BasicType bt) {\n-    if (is_subword_type(bt))  bt = T_INT;\n+  static jbyte type2tag(BasicType bt) {\n+    if (is_subword_type(bt)) {\n+      bt = T_INT;\n+    }\n+    if (bt == T_ARRAY) {\n+      bt = T_OBJECT;\n+    }\n@@ -137,6 +149,9 @@\n-      case T_OBJECT: return constantTag(JVM_CONSTANT_String);\n-      case T_INT:    return constantTag(JVM_CONSTANT_Integer);\n-      case T_LONG:   return constantTag(JVM_CONSTANT_Long);\n-      case T_FLOAT:  return constantTag(JVM_CONSTANT_Float);\n-      case T_DOUBLE: return constantTag(JVM_CONSTANT_Double);\n-      default:       break;\n+      case T_INT:    return JVM_CONSTANT_Integer;\n+      case T_LONG:   return JVM_CONSTANT_Long;\n+      case T_FLOAT:  return JVM_CONSTANT_Float;\n+      case T_DOUBLE: return JVM_CONSTANT_Double;\n+      case T_OBJECT: return JVM_CONSTANT_String;\n+\n+      default:\n+        assert(false, \"not supported: %s\", type2name(bt));\n+        return JVM_CONSTANT_Invalid;\n@@ -144,2 +159,0 @@\n-    assert(false, \"bad basic type for tag\");\n-    return constantTag();\n","filename":"src\/hotspot\/share\/utilities\/constantTag.hpp","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-\/\/ include hierachy reasons).\n+\/\/ include hierarchy reasons).\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1243,0 +1243,4 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\n+\/\/ Allow use of C++ thread_local when approved - see JDK-8282469.\n+#define APPROVED_CPP_THREAD_LOCAL thread_local\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -715,2 +715,3 @@\n-                throw (IOException) new InvalidClassException(name,\n-                    \"invalid descriptor for field \" + fname).initCause(e);\n+                throw new InvalidClassException(name,\n+                                                \"invalid descriptor for field \" +\n+                                                fname, e);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1891,0 +1891,9 @@\n+     * The canonical name for a primitive class is the keyword for the\n+     * corresponding primitive type ({@code byte}, {@code short},\n+     * {@code char}, {@code int}, and so on).\n+     *\n+     * <p>An array type has a canonical name if and only if its\n+     * component type has a canonical name. When an array type has a\n+     * canonical name, it is equal to the canonical name of the\n+     * component type followed by \"{@code []}\".\n+     *\n@@ -1893,0 +1902,1 @@\n+     * @jls 6.7 Fully Qualified Names and Canonical Names\n@@ -4641,0 +4651,3 @@\n+     * @throws UnsupportedOperationException if this component type is {@linkplain\n+     *         Void#TYPE void} or if the number of dimensions of the resulting array\n+     *         type would exceed 255.\n@@ -4642,0 +4655,2 @@\n+     * @jvms 4.3.2 Field Descriptors\n+     * @jvms 4.4.1 The {@code CONSTANT_Class_info} Structure\n@@ -4646,1 +4661,5 @@\n-        return Array.newInstance(this, 0).getClass();\n+        try {\n+            return Array.newInstance(this, 0).getClass();\n+        } catch (IllegalArgumentException iae) {\n+            throw new UnsupportedOperationException(iae);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,1 @@\n-     * See JVMS 4.3.2 (\"Field Descriptors\") for more detail.\n+     * See JVMS {@jvms 4.3.2 }(\"Field Descriptors\") for more detail.\n@@ -154,1 +154,2 @@\n-     * @throws IllegalStateException if the resulting {@linkplain ClassDesc} would have an array rank of greater than 255\n+     * @throws IllegalStateException if the resulting {@linkplain\n+     * ClassDesc} would have an array rank of greater than 255\n@@ -173,1 +174,2 @@\n-     * @throws IllegalArgumentException if the rank is less than or equal to zero or if the rank of the resulting array type is\n+     * @throws IllegalArgumentException if the rank is less than or\n+     * equal to zero or if the rank of the resulting array type is\n@@ -178,3 +180,15 @@\n-        int currentDepth = ConstantUtils.arrayDepth(descriptorString());\n-        if (rank <= 0 || currentDepth + rank > ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS)\n-            throw new IllegalArgumentException(\"rank: \" + currentDepth + rank);\n+        int netRank;\n+        if (rank <= 0) {\n+            throw new IllegalArgumentException(\"rank \" + rank + \" is not a positive value\");\n+        }\n+        try {\n+            int currentDepth = ConstantUtils.arrayDepth(descriptorString());\n+            netRank = Math.addExact(currentDepth, rank);\n+            if (netRank > ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+                throw new IllegalArgumentException(\"rank: \" + netRank +\n+                                                   \" exceeds maximum supported dimension of \" +\n+                                                   ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS);\n+            }\n+        } catch (ArithmeticException ae) {\n+            throw new IllegalArgumentException(\"Integer overflow in rank computation\");\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -111,0 +111,6 @@\n+     * In cases where {@code MethodHandles.lookup} is called from a context where\n+     * there is no caller frame on the stack (e.g. when called directly\n+     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n+     * To obtain a {@link Lookup lookup object} in such a context, use an auxiliary class that will\n+     * implicitly be identified as the caller, or use {@link MethodHandles#publicLookup()}\n+     * to obtain a low-privileged lookup instead.\n@@ -114,0 +120,1 @@\n+     * @throws IllegalCallerException if there is no caller frame on the stack.\n@@ -118,1 +125,5 @@\n-        return new Lookup(Reflection.getCallerClass());\n+        final Class<?> c = Reflection.getCallerClass();\n+        if (c == null) {\n+            throw new IllegalCallerException(\"no caller frame\");\n+        }\n+        return new Lookup(c);\n@@ -1876,1 +1887,1 @@\n-             * by a garbage collector (JLS 12.7).\n+             * by a garbage collector (JLS {@jls 12.7}).\n@@ -2016,1 +2027,1 @@\n-         * by a garbage collector (JLS 12.7).\n+         * by a garbage collector (JLS {@jls 12.7}).\n@@ -2767,1 +2778,1 @@\n-         * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,\n+         * Such a resolution, as specified in JVMS {@jvms 5.4.3.1}, attempts to locate and load the class,\n@@ -4778,1 +4789,1 @@\n-     *     <em>T0<\/em> is converted to byte via Java casting conversion (JLS 5.5),\n+     *     <em>T0<\/em> is converted to byte via Java casting conversion (JLS {@jls 5.5}),\n@@ -4781,1 +4792,1 @@\n-     *     then a Java casting conversion (JLS 5.5) is applied.\n+     *     then a Java casting conversion (JLS {@jls 5.5}) is applied.\n@@ -4786,1 +4797,1 @@\n-     *     by a Java casting conversion (JLS 5.5) on the primitive value,\n+     *     by a Java casting conversion (JLS {@jls 5.5}) on the primitive value,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-public class PhantomReference<T> extends Reference<T> {\n+public non-sealed class PhantomReference<T> extends Reference<T> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,2 @@\n-public abstract class Reference<T> {\n+public abstract sealed class Reference<T>\n+    permits PhantomReference, SoftReference, WeakReference, FinalReference {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-public class SoftReference<T> extends Reference<T> {\n+public non-sealed class SoftReference<T> extends Reference<T> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/SoftReference.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-public class WeakReference<T> extends Reference<T> {\n+public non-sealed class WeakReference<T> extends Reference<T> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/WeakReference.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,0 +231,1 @@\n+    @ForceInline\n@@ -256,0 +257,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/java\/util\/Objects.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,3 +47,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-        if (sym.isDeprecated()) {\n+        if (sym.isDeprecated() && sym.isDeprecatableViaAnnotation()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -685,1 +685,1 @@\n-     *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4\n+     *  See JLS 8.4.8.1 (without transitivity) and 8.4.8.4\n@@ -2088,1 +2088,1 @@\n-         *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4\n+         *  See JLS 8.4.8.1 (without transitivity) and 8.4.8.4\n@@ -2105,1 +2105,1 @@\n-         *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4\n+         *  See JLS 8.4.8.1 (without transitivity) and 8.4.8.4\n@@ -2143,1 +2143,1 @@\n-            \/\/ JLS 8.4.6.1\n+            \/\/ JLS 8.4.8.1\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1225,2 +1225,10 @@\n-                appendAnnotationsString(buf);\n-                buf.append(className(tsym, true));\n+                if (isAnnotated()) {\n+                    if (!tsym.packge().isUnnamed()) {\n+                        buf.append(tsym.packge());\n+                        buf.append(\".\");\n+                    }\n+                    appendAnnotationsString(buf);\n+                    buf.append(tsym.name);\n+                } else {\n+                    buf.append(className(tsym, true));\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.function.Consumer;\n@@ -5358,2 +5359,2 @@\n-        Env<AttrContext> env = typeEnvs.get(p);\n-        chk.checkDeprecatedAnnotation(((JCPackageDecl) env.tree).pid.pos(), p);\n+        attribWithLint(p,\n+                       env -> chk.checkDeprecatedAnnotation(((JCPackageDecl) env.tree).pid.pos(), p));\n@@ -5372,3 +5373,22 @@\n-        \/\/ Get environment current at the point of module definition.\n-        Env<AttrContext> env = enter.typeEnvs.get(m);\n-        attribStat(env.tree, env);\n+        attribWithLint(m, env -> attribStat(env.tree, env));\n+    }\n+\n+    private void attribWithLint(TypeSymbol sym, Consumer<Env<AttrContext>> attrib) {\n+        Env<AttrContext> env = typeEnvs.get(sym);\n+\n+        Env<AttrContext> lintEnv = env;\n+        while (lintEnv.info.lint == null)\n+            lintEnv = lintEnv.next;\n+\n+        Lint lint = lintEnv.info.lint.augment(sym);\n+\n+        Lint prevLint = chk.setLint(lint);\n+        JavaFileObject prev = log.useSource(env.toplevel.sourcefile);\n+\n+        try {\n+            deferredLintHandler.flush(env.tree.pos());\n+            attrib.accept(env);\n+        } finally {\n+            log.useSource(prev);\n+            chk.setLint(prevLint);\n+        }\n@@ -5653,1 +5673,1 @@\n-            \/\/ yet different return types).  (JLS 8.4.6.3)\n+            \/\/ yet different return types).  (JLS 8.4.8.3)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2008,1 +2008,1 @@\n-        \/\/ Error if static method overrides instance method (JLS 8.4.6.2).\n+        \/\/ Error if static method overrides instance method (JLS 8.4.8.2).\n@@ -2018,1 +2018,1 @@\n-        \/\/ method (JLS 8.4.6.1).\n+        \/\/ method (JLS 8.4.8.1).\n@@ -2034,1 +2034,1 @@\n-        \/\/ Error if overriding method has weaker access (JLS 8.4.6.3).\n+        \/\/ Error if overriding method has weaker access (JLS 8.4.8.3).\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-            c.completer = Completer.NULL_COMPLETER;\n+                c.completer = Completer.NULL_COMPLETER;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -669,4 +669,1 @@\n-            boolean exhaustiveSwitch = tree.patternSwitch ||\n-                                       tree.cases.stream()\n-                                                 .flatMap(c -> c.labels.stream())\n-                                                 .anyMatch(l -> TreeInfo.isNull(l));\n+            boolean exhaustiveSwitch = TreeInfo.expectedExhaustive(tree);\n@@ -694,4 +691,7 @@\n-            if (!tree.hasTotalPattern && exhaustiveSwitch &&\n-                !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) &&\n-                (constants == null || !isExhaustive(tree.selector.pos(), tree.selector.type, constants))) {\n-                log.error(tree, Errors.NotExhaustiveStatement);\n+            tree.isExhaustive = tree.hasTotalPattern ||\n+                                TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases);\n+            if (exhaustiveSwitch) {\n+                tree.isExhaustive |= isExhaustive(tree.selector.pos(), tree.selector.type, constants);\n+                if (!tree.isExhaustive) {\n+                    log.error(tree, Errors.NotExhaustiveStatement);\n+                }\n@@ -730,2 +730,4 @@\n-            if (!tree.hasTotalPattern && !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) &&\n-                !isExhaustive(tree.selector.pos(), tree.selector.type, constants)) {\n+            tree.isExhaustive = tree.hasTotalPattern ||\n+                                TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) ||\n+                                isExhaustive(tree.selector.pos(), tree.selector.type, constants);\n+            if (!tree.isExhaustive) {\n@@ -2478,1 +2480,1 @@\n-            handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern);\n+            handleSwitch(tree, tree.selector, tree.cases, tree.isExhaustive);\n@@ -2482,1 +2484,1 @@\n-            handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern);\n+            handleSwitch(tree, tree.selector, tree.cases, tree.isExhaustive);\n@@ -2486,1 +2488,1 @@\n-                                  List<JCCase> cases, boolean hasTotalPattern) {\n+                                  List<JCCase> cases, boolean isExhaustive) {\n@@ -2524,1 +2526,1 @@\n-            if (!hasTotalPattern) {\n+            if (!isExhaustive) {\n@@ -2527,1 +2529,1 @@\n-                } else {\n+                } else if (tree.hasTag(SWITCH) && !TreeInfo.expectedExhaustive((JCSwitch) tree)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -375,2 +375,7 @@\n-                    \/\/check @Deprecated:\n-                    markDeprecated(decl.sym, decl.mods.annotations, env);\n+                    DiagnosticPosition prevCheckDeprecatedLintPos = deferredLintHandler.setPos(decl.pos());\n+                    try {\n+                        \/\/check @Deprecated:\n+                        markDeprecated(decl.sym, decl.mods.annotations, env);\n+                    } finally {\n+                        deferredLintHandler.setPos(prevCheckDeprecatedLintPos);\n+                    }\n@@ -378,1 +383,1 @@\n-                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, null);\n+                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, decl.pos());\n@@ -406,1 +411,1 @@\n-            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, null);\n+            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, tree.pos());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -304,4 +304,1 @@\n-                AssertionError assertError =\n-                    new AssertionError(\"Problem instantiating PrintingProcessor.\");\n-                assertError.initCause(t);\n-                throw assertError;\n+                throw new AssertionError(\"Problem instantiating PrintingProcessor.\", t);\n@@ -497,1 +494,1 @@\n-        private Map<String, Processor> namedProcessorsMap = new HashMap<>();;\n+        private Map<String, Processor> namedProcessorsMap = new HashMap<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1328,0 +1328,1 @@\n+        public boolean isExhaustive;\n@@ -1440,0 +1441,1 @@\n+        public boolean isExhaustive;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,3 +197,1 @@\n-            IOException e = new IOException(ex.getMessage());\n-            e.initCause(ex);\n-            throw e;\n+            throw new IOException(ex.getMessage(), ex);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1394,0 +1394,6 @@\n+    public static boolean expectedExhaustive(JCSwitch tree) {\n+        return tree.patternSwitch ||\n+               tree.cases.stream()\n+                         .flatMap(c -> c.labels.stream())\n+                         .anyMatch(l -> TreeInfo.isNull(l));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,3 +70,3 @@\n-compiler\/whitebox\/ClearMethodStateTest.java 8265360 macosx-aarch64\n-compiler\/whitebox\/EnqueueMethodForCompilationTest.java 8265360 macosx-aarch64\n-compiler\/whitebox\/MakeMethodNotCompilableTest.java 8265360 macosx-aarch64\n+compiler\/whitebox\/ClearMethodStateTest.java 8265360 macosx-all\n+compiler\/whitebox\/EnqueueMethodForCompilationTest.java 8265360 macosx-all\n+compiler\/whitebox\/MakeMethodNotCompilableTest.java 8265360 macosx-all\n@@ -74,1 +74,1 @@\n-compiler\/codecache\/jmx\/PoolsIndependenceTest.java 8264632 macosx-generic\n+compiler\/codecache\/jmx\/PoolsIndependenceTest.java 8264632 macosx-all\n@@ -77,0 +77,1 @@\n+compiler\/arraycopy\/TestArrayCopyAsLoadsStores.java 8283777 generic-all\n@@ -96,1 +97,0 @@\n-runtime\/cds\/DeterministicDump.java 8253495 generic-all\n@@ -178,1 +178,0 @@\n-vmTestbase\/nsk\/monitoring\/ThreadMXBean\/ThreadInfo\/Deadlock\/JavaDeadlock001\/TestDescription.java 8060733 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -451,0 +451,1 @@\n+ -runtime\/cds\/appcds\/TestParallelGCWithCDS.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8282045\n+ * @summary When loop strip mining fails, safepoints are removed from loop anyway\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestStripMiningDropsSafepoint\n+ *\/\n+\n+public class TestStripMiningDropsSafepoint {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=inline,java.util.Objects::newIdentity\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\", \"-XX:LoopMaxUnroll=1\", \"-XX:-RangeCheckElimination\");\n+        TestFramework.runWithFlags(\"-XX:CompileCommand=inline,java.util.Objects::newIdentity\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\", \"-XX:LoopMaxUnroll=1\", \"-XX:-RangeCheckElimination\", \"-XX:-PartialPeelLoop\");\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, counts = { IRNode.COUNTEDLOOP, \"1\",  IRNode.OUTERSTRIPMINEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    private static void test1(int[] dst, int[] src) {\n+        \/\/ Partial peel is applied. No side effect between exit and\n+        \/\/ safepoint.\n+        for (int i = 0; ; ) {\n+            \/\/ prevent ciTypeFlow from cloning head\n+            synchronized (new Object()) {}\n+            i++;\n+            if (i >= src.length) {\n+                break;\n+            }\n+            dst[i] = src[i];\n+            if (i \/ 2 >= 2000) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test1\")\n+    private static void test1_runner() {\n+        int[] array1 = new int[1000];\n+        int[] array2 = new int[10000];\n+        test1(array1, array1);\n+        test1(array2, array2);\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, counts = { IRNode.COUNTEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, failOn = { IRNode.OUTERSTRIPMINEDLOOP })\n+    private static void test2(int[] dst, int[] src) {\n+        \/\/ Partial peel is applied. Some side effect between exit and\n+        \/\/ safepoint.\n+        int v = src[0];\n+        for (int i = 0; ; ) {\n+            synchronized (new Object()) {}\n+            dst[i] = v;\n+            i++;\n+            if (i >= src.length) {\n+                break;\n+            }\n+            v = src[i];\n+            if (i \/ 2 >= 2000) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test2\")\n+    private static void test2_runner() {\n+        int[] array1 = new int[1000];\n+        int[] array2 = new int[10000];\n+        test2(array1, array1);\n+        test2(array2, array2);\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"PartialPeelLoop\", \"false\" }, counts = { IRNode.COUNTEDLOOP, \"1\",  IRNode.OUTERSTRIPMINEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    private static void test3(int[] dst, int[] src) {\n+        int v = src[0];\n+        for (int i = 0; ; ) {\n+            synchronized (new Object()) {}\n+            dst[i] = v;\n+            int inc = test3_helper(2);\n+            v = src[i];\n+            i += (inc \/ 2);\n+            if (i >= src.length) {\n+                break;\n+            }\n+            for (int j = 0; j < 10; j++) {\n+            }\n+            \/\/ safepoint on backedge\n+        }\n+    }\n+\n+    private static int test3_helper(int stop) {\n+        int i = 1;\n+        do {\n+            synchronized (new Object()) {}\n+            i *= 2;\n+        } while (i < stop);\n+        return i;\n+    }\n+\n+    @Run(test = \"test3\")\n+    private static void test3_runner() {\n+        int[] array1 = new int[1000];\n+        test3(array1, array1);\n+        test3_helper(10);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestStripMiningDropsSafepoint.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -45,0 +45,2 @@\n+import static jdk.vm.ci.meta.MetaUtil.internalNameToJava;\n+import static jdk.vm.ci.meta.MetaUtil.toInternalName;\n@@ -166,3 +168,3 @@\n-    public void internalNameTest() {\n-        \/\/ Verify that the last slash in lambda types are not replaced with a '.' as they\n-        \/\/ are part of the type name.\n+    public void lambdaInternalNameTest() {\n+        \/\/ Verify that the last dot in lambda types is properly handled when transitioning from internal name to java\n+        \/\/ name and vice versa.\n@@ -172,4 +174,3 @@\n-        int typeNameLen = TestResolvedJavaType.class.getSimpleName().length();\n-        int index = typeName.indexOf(TestResolvedJavaType.class.getSimpleName());\n-        String suffix = typeName.substring(index + typeNameLen, typeName.length() - 1);\n-        assertEquals(TestResolvedJavaType.class.getName() + suffix, lambdaType.toJavaName());\n+        String javaName = lambda.getClass().getName();\n+        assertEquals(typeName, toInternalName(javaName));\n+        assertEquals(javaName, internalNameToJava(typeName, true, true));\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -273,1 +273,1 @@\n-        TestFormat.reportIfAnyFailures();\n+        TestFormat.throwIfAnyFailures();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            JarBuilder.build(true, \"WhiteBox\", \"sun\/hotspot\/WhiteBox\");;\n+            JarBuilder.build(true, \"WhiteBox\", \"sun\/hotspot\/WhiteBox\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/SameNameInTwoLoadersTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-            if (i != 0) {\n+            if (i != 0 && !out.getStdout().contains(\"LockDuringDumpAgent timeout\")) {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/LockDuringDump.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+        map.put(\"vm.hasDTrace\", this::vmHasDTrace);\n@@ -370,0 +371,7 @@\n+    }\n+\n+    \/**\n+     * @return \"true\" if the VM is compiled with DTrace\n+     *\/\n+    protected String vmHasDTrace() {\n+        return \"\" + WB.isDTraceIncluded();\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-        List<String> unr = getState().unresolvedDependencies((VarSnippet) undefKey).collect(toList());;\n+        List<String> unr = getState().unresolvedDependencies((VarSnippet) undefKey).collect(toList());\n","filename":"test\/langtools\/jdk\/jshell\/VariablesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import jdk.test.lib.hprof.parser.ReadBuffer;\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaValueArray.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -652,0 +652,1 @@\n+  public native boolean isDTraceIncluded();\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}