{"files":[{"patch":"@@ -867,1 +867,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += libtest-rw.c libtest-rwx.c libTestJNI.c \\\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += libtest-rw.c libtest-rwx.c \\\n@@ -875,1 +875,1 @@\n-    BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c\n+    BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -15049,1 +15049,1 @@\n-instruct clearArray_imm_reg(immL cnt, iRegP_R10 base, Universe dummy, rFlagsReg cr)\n+instruct clearArray_imm_reg(immL cnt, iRegP_R10 base, iRegL_R11 temp, Universe dummy, rFlagsReg cr)\n@@ -15055,1 +15055,1 @@\n-  effect(USE_KILL base);\n+  effect(TEMP temp, USE_KILL base, KILL cr);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1149,2 +1149,2 @@\n-               FrameMap::r2_oop_opr,\n-               FrameMap::r5_oop_opr,\n+               FrameMap::r10_oop_opr,\n+               FrameMap::r11_oop_opr,\n@@ -1165,2 +1165,2 @@\n-               FrameMap::r2_oop_opr,\n-               FrameMap::r5_oop_opr,\n+               FrameMap::r10_oop_opr,\n+               FrameMap::r11_oop_opr,\n@@ -1182,2 +1182,2 @@\n-  LIR_Opr tmp1 = FrameMap::r2_oop_opr;\n-  LIR_Opr tmp2 = FrameMap::r4_oop_opr;\n+  LIR_Opr tmp1 = FrameMap::r10_oop_opr;\n+  LIR_Opr tmp2 = FrameMap::r11_oop_opr;\n@@ -1211,2 +1211,2 @@\n-  LIR_Opr tmp1 = FrameMap::r2_oop_opr;\n-  LIR_Opr tmp2 = FrameMap::r4_oop_opr;\n+  LIR_Opr tmp1 = FrameMap::r10_oop_opr;\n+  LIR_Opr tmp2 = FrameMap::r11_oop_opr;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n@@ -197,1 +197,4 @@\n-void C1_MacroAssembler::initialize_body(Register obj, Register len_in_bytes, int hdr_size_in_bytes, Register t1) {\n+\/\/\n+\/\/ Scratch registers: t1 = r10, t2 = r11\n+\/\/\n+void C1_MacroAssembler::initialize_body(Register obj, Register len_in_bytes, int hdr_size_in_bytes, Register t1, Register t2) {\n@@ -199,0 +202,2 @@\n+  assert(t1 == r10 && t2 == r11, \"must be\");\n+\n@@ -205,6 +210,5 @@\n-  \/\/ Preserve obj\n-  if (hdr_size_in_bytes)\n-    add(obj, obj, hdr_size_in_bytes);\n-  zero_memory(obj, len_in_bytes, t1);\n-  if (hdr_size_in_bytes)\n-    sub(obj, obj, hdr_size_in_bytes);\n+  \/\/ zero_words() takes ptr in r10 and count in words in r11\n+  mov(rscratch1, len_in_bytes);\n+  lea(t1, Address(obj, hdr_size_in_bytes));\n+  lsr(t2, rscratch1, LogBytesPerWord);\n+  zero_words(t1, t2);\n@@ -225,0 +229,1 @@\n+\/\/ Scratch registers: t1 = r10, t2 = r11\n@@ -235,1 +240,0 @@\n-     const int threshold = 16 * BytesPerWord;   \/\/ approximate break even point for code size (see comments below)\n@@ -238,10 +242,1 @@\n-       initialize_body(obj, index, hdr_size_in_bytes, t1);\n-     } else if (con_size_in_bytes <= threshold) {\n-       \/\/ use explicit null stores\n-       int i = hdr_size_in_bytes;\n-       if (i < con_size_in_bytes && (con_size_in_bytes % (2 * BytesPerWord))) {\n-         str(zr, Address(obj, i));\n-         i += BytesPerWord;\n-       }\n-       for (; i < con_size_in_bytes; i += 2 * BytesPerWord)\n-         stp(zr, zr, Address(obj, i));\n+       initialize_body(obj, index, hdr_size_in_bytes, t1, t2);\n@@ -249,25 +244,3 @@\n-       block_comment(\"zero memory\");\n-      \/\/ use loop to null out the fields\n-\n-       int words = (con_size_in_bytes - hdr_size_in_bytes) \/ BytesPerWord;\n-       mov(index,  words \/ 8);\n-\n-       const int unroll = 8; \/\/ Number of str(zr) instructions we'll unroll\n-       int remainder = words % unroll;\n-       lea(rscratch1, Address(obj, hdr_size_in_bytes + remainder * BytesPerWord));\n-\n-       Label entry_point, loop;\n-       b(entry_point);\n-\n-       bind(loop);\n-       sub(index, index, 1);\n-       for (int i = -unroll; i < 0; i++) {\n-         if (-i == remainder)\n-           bind(entry_point);\n-         str(zr, Address(rscratch1, i * wordSize));\n-       }\n-       if (remainder == 0)\n-         bind(entry_point);\n-       add(rscratch1, rscratch1, unroll * wordSize);\n-       cbnz(index, loop);\n-\n+       con_size_in_bytes -= hdr_size_in_bytes;\n+       lea(t1, Address(obj, hdr_size_in_bytes));\n+       zero_words(t1, con_size_in_bytes \/ BytesPerWord);\n@@ -309,2 +282,1 @@\n-  const Register len_zero = len;\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, len_zero);\n+  initialize_body(obj, arr_size, header_size * BytesPerWord, t1, t2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":18,"deletions":46,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2015, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n@@ -51,1 +51,1 @@\n-  void initialize_body(Register obj, Register len_in_bytes, int hdr_size_in_bytes, Register t1);\n+  void initialize_body(Register obj, Register len_in_bytes, int hdr_size_in_bytes, Register t1, Register t2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n@@ -662,3 +662,3 @@\n-          Register obj_size = r2;\n-          Register t1       = r19;\n-          Register t2       = r4;\n+          Register obj_size = r19;\n+          Register t1       = r10;\n+          Register t2       = r11;\n@@ -799,3 +799,3 @@\n-          Register arr_size = r4;\n-          Register t1       = r2;\n-          Register t2       = r5;\n+          Register arr_size = r5;\n+          Register t1       = r10;\n+          Register t2       = r11;\n@@ -831,1 +831,1 @@\n-          __ initialize_body(t1, arr_size, 0, t2);\n+          __ initialize_body(t1, arr_size, 0, t1, t2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4426,62 +4426,0 @@\n-\/\/ Zero words; len is in bytes\n-\/\/ Destroys all registers except addr\n-\/\/ len must be a nonzero multiple of wordSize\n-void MacroAssembler::zero_memory(Register addr, Register len, Register t1) {\n-  assert_different_registers(addr, len, t1, rscratch1, rscratch2);\n-\n-#ifdef ASSERT\n-  { Label L;\n-    tst(len, BytesPerWord - 1);\n-    br(Assembler::EQ, L);\n-    stop(\"len is not a multiple of BytesPerWord\");\n-    bind(L);\n-  }\n-#endif\n-\n-#ifndef PRODUCT\n-  block_comment(\"zero memory\");\n-#endif\n-\n-  Label loop;\n-  Label entry;\n-\n-\/\/  Algorithm:\n-\/\/\n-\/\/    scratch1 = cnt & 7;\n-\/\/    cnt -= scratch1;\n-\/\/    p += scratch1;\n-\/\/    switch (scratch1) {\n-\/\/      do {\n-\/\/        cnt -= 8;\n-\/\/          p[-8] = 0;\n-\/\/        case 7:\n-\/\/          p[-7] = 0;\n-\/\/        case 6:\n-\/\/          p[-6] = 0;\n-\/\/          \/\/ ...\n-\/\/        case 1:\n-\/\/          p[-1] = 0;\n-\/\/        case 0:\n-\/\/          p += 8;\n-\/\/      } while (cnt);\n-\/\/    }\n-\n-  const int unroll = 8; \/\/ Number of str(zr) instructions we'll unroll\n-\n-  lsr(len, len, LogBytesPerWord);\n-  andr(rscratch1, len, unroll - 1);  \/\/ tmp1 = cnt % unroll\n-  sub(len, len, rscratch1);      \/\/ cnt -= unroll\n-  \/\/ t1 always points to the end of the region we're about to zero\n-  add(t1, addr, rscratch1, Assembler::LSL, LogBytesPerWord);\n-  adr(rscratch2, entry);\n-  sub(rscratch2, rscratch2, rscratch1, Assembler::LSL, 2);\n-  br(rscratch2);\n-  bind(loop);\n-  sub(len, len, unroll);\n-  for (int i = -unroll; i < 0; i++)\n-    Assembler::str(zr, Address(t1, i * wordSize));\n-  bind(entry);\n-  add(t1, t1, unroll * wordSize);\n-  cbnz(len, loop);\n-}\n-\n@@ -5066,4 +5004,5 @@\n-\/\/ zero_words() is used by C2 ClearArray patterns.  It is as small as\n-\/\/ possible, handling small word counts locally and delegating\n-\/\/ anything larger to the zero_blocks stub.  It is expanded many times\n-\/\/ in compiled code, so it is important to keep it short.\n+\/\/ zero_words() is used by C2 ClearArray patterns and by\n+\/\/ C1_MacroAssembler.  It is as small as possible, handling small word\n+\/\/ counts locally and delegating anything larger to the zero_blocks\n+\/\/ stub.  It is expanded many times in compiled code, so it is\n+\/\/ important to keep it short.\n@@ -5078,1 +5017,0 @@\n-  assert(ptr == r10 && cnt == r11, \"mismatch in register usage\");\n@@ -5081,1 +5019,5 @@\n-  cmp(cnt, (u1)zero_words_block_size);\n+  assert(ptr == r10 && cnt == r11, \"mismatch in register usage\");\n+  RuntimeAddress zero_blocks = RuntimeAddress(StubRoutines::aarch64::zero_blocks());\n+  assert(zero_blocks.target() != NULL, \"zero_blocks stub has not been generated\");\n+\n+  subs(rscratch1, cnt, zero_words_block_size);\n@@ -5087,1 +5029,9 @@\n-    if (StubRoutines::aarch64::complete()) {\n+    \/\/ Make sure this is a C2 compilation. C1 allocates space only for\n+    \/\/ trampoline stubs generated by Call LIR ops, and in any case it\n+    \/\/ makes sense for a C1 compilation task to proceed as quickly as\n+    \/\/ possible.\n+    CompileTask* task;\n+    if (StubRoutines::aarch64::complete()\n+        && Thread::current()->is_Compiler_thread()\n+        && (task = ciEnv::current()->task())\n+        && is_c2_compile(task->comp_level())) {\n@@ -5091,1 +5041,1 @@\n-        postcond(pc() == badAddress);\n+        assert(false, \"failed to allocate space for trampoline\");\n@@ -5095,1 +5045,1 @@\n-      bl(zero_blocks);\n+      far_call(zero_blocks);\n@@ -5099,0 +5049,3 @@\n+\n+  \/\/ We have a few words left to do. zero_blocks has adjusted r10 and r11\n+  \/\/ for us.\n@@ -5103,1 +5056,1 @@\n-      stp(zr, zr, post(ptr, 16));\n+      stp(zr, zr, post(ptr, 2 * BytesPerWord));\n@@ -5113,0 +5066,1 @@\n+\n@@ -5114,1 +5068,0 @@\n-  postcond(pc() != badAddress);\n@@ -5120,1 +5073,2 @@\n-#define SmallArraySize (18 * BytesPerLong)\n+\/\/\n+\/\/ r10, r11, rscratch1, and rscratch2 are clobbered.\n@@ -5123,5 +5077,31 @@\n-  BLOCK_COMMENT(\"zero_words {\");\n-  int i = cnt & 1;  \/\/ store any odd word to start\n-  if (i) str(zr, Address(base));\n-\n-  if (cnt <= SmallArraySize \/ BytesPerLong) {\n+  guarantee(zero_words_block_size < BlockZeroingLowLimit,\n+            \"increase BlockZeroingLowLimit\");\n+  if (cnt <= (uint64_t)BlockZeroingLowLimit \/ BytesPerWord) {\n+#ifndef PRODUCT\n+    {\n+      char buf[64];\n+      snprintf(buf, sizeof buf, \"zero_words (count = %\" PRIu64 \") {\", cnt);\n+      BLOCK_COMMENT(buf);\n+    }\n+#endif\n+    if (cnt >= 16) {\n+      uint64_t loops = cnt\/16;\n+      if (loops > 1) {\n+        mov(rscratch2, loops - 1);\n+      }\n+      {\n+        Label loop;\n+        bind(loop);\n+        for (int i = 0; i < 16; i += 2) {\n+          stp(zr, zr, Address(base, i * BytesPerWord));\n+        }\n+        add(base, base, 16 * BytesPerWord);\n+        if (loops > 1) {\n+          subs(rscratch2, rscratch2, 1);\n+          br(GE, loop);\n+        }\n+      }\n+    }\n+    cnt %= 16;\n+    int i = cnt & 1;  \/\/ store any odd word to start\n+    if (i) str(zr, Address(base));\n@@ -5131,0 +5111,1 @@\n+    BLOCK_COMMENT(\"} zero_words\");\n@@ -5132,19 +5113,2 @@\n-    const int unroll = 4; \/\/ Number of stp(zr, zr) instructions we'll unroll\n-    int remainder = cnt % (2 * unroll);\n-    for (; i < remainder; i += 2) {\n-      stp(zr, zr, Address(base, i * wordSize));\n-    }\n-    Label loop;\n-    Register cnt_reg = rscratch1;\n-    Register loop_base = rscratch2;\n-    cnt = cnt - remainder;\n-    mov(cnt_reg, cnt);\n-    \/\/ adjust base and prebias by -2 * wordSize so we can pre-increment\n-    add(loop_base, base, (remainder - 2) * wordSize);\n-    bind(loop);\n-    sub(cnt_reg, cnt_reg, 2 * unroll);\n-    for (i = 1; i < unroll; i++) {\n-      stp(zr, zr, Address(loop_base, 2 * i * wordSize));\n-    }\n-    stp(zr, zr, Address(pre(loop_base, 2 * unroll * wordSize)));\n-    cbnz(cnt_reg, loop);\n+    mov(r10, base); mov(r11, cnt);\n+    zero_words(r10, r11);\n@@ -5152,1 +5116,0 @@\n-  BLOCK_COMMENT(\"} zero_words\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":62,"deletions":99,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -949,1 +949,0 @@\n-  void zero_memory(Register addr, Register len, Register t1);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -68,0 +69,16 @@\n+#ifdef _LP64\n+\n+bool VM_Version::supports_clflush() {\n+  \/\/ clflush should always be available on x86_64\n+  \/\/ if not we are in real trouble because we rely on it\n+  \/\/ to flush the code cache.\n+  \/\/ Unfortunately, Assembler::clflush is currently called as part\n+  \/\/ of generation of the code cache flush routine. This happens\n+  \/\/ under Universe::init before the processor features are set\n+  \/\/ up. Assembler::flush calls this routine to check that clflush\n+  \/\/ is allowed. So, we give the caller a free pass if Universe init\n+  \/\/ is still in progress.\n+  assert ((!Universe::is_fully_initialized() || (_features & CPU_FLUSH) != 0), \"clflush should be available\");\n+  return true;\n+}\n+#endif\n@@ -1792,0 +1809,4 @@\n+  case 0xA5:\n+    \/\/ Not in Intel documentation.\n+    \/\/ 06_A5H |    | 10th Generation Intel® Core™ Processor Family based on microarchitecture code name Comet Lake S\/H\n+    return true;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -11720,1 +11720,1 @@\n-  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -11735,1 +11735,1 @@\n-  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -11750,1 +11750,1 @@\n-  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -11765,1 +11765,1 @@\n-  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -11780,1 +11780,1 @@\n-  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n@@ -11795,1 +11795,1 @@\n-  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n@@ -11810,1 +11810,1 @@\n-  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n@@ -11825,1 +11825,1 @@\n-  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n@@ -11841,1 +11841,1 @@\n-  predicate(UseAVX <= 2);\n+  predicate(!VM_Version::supports_avx512vlbw());\n@@ -11857,1 +11857,1 @@\n-  predicate(UseAVX > 2);\n+  predicate(VM_Version::supports_avx512vlbw());\n@@ -12035,1 +12035,1 @@\n-  predicate(UseAVX <= 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate(!VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -12052,1 +12052,1 @@\n-  predicate(UseAVX > 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate(VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -12069,1 +12069,1 @@\n-  predicate(UseAVX <= 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(!VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -12086,1 +12086,1 @@\n-  predicate(UseAVX > 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -12103,1 +12103,1 @@\n-  predicate(UseAVX <= 2);\n+  predicate(!VM_Version::supports_avx512vlbw() || !VM_Version::supports_bmi2());\n@@ -12119,1 +12119,1 @@\n-  predicate(UseAVX > 2);\n+  predicate(VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2());\n@@ -12136,1 +12136,1 @@\n-  predicate(UseAVX <= 2);\n+  predicate(!VM_Version::supports_avx512vlbw() || !VM_Version::supports_bmi2());\n@@ -12152,1 +12152,1 @@\n-  predicate(UseAVX > 2);\n+  predicate(VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2());\n@@ -12169,1 +12169,1 @@\n-  predicate(UseAVX <= 2);\n+  predicate(!VM_Version::supports_avx512vlbw() || !VM_Version::supports_bmi2());\n@@ -12183,1 +12183,1 @@\n-  predicate(UseAVX > 2);\n+  predicate(VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2());\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -11525,1 +11525,1 @@\n-  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -11541,1 +11541,1 @@\n-  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -11557,1 +11557,1 @@\n-  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -11573,1 +11573,1 @@\n-  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -11589,1 +11589,1 @@\n-  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n@@ -11605,1 +11605,1 @@\n-  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n@@ -11621,1 +11621,1 @@\n-  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  predicate(!VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n@@ -11637,1 +11637,1 @@\n-  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  predicate(VM_Version::supports_avx512vlbw() && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n@@ -11820,1 +11820,1 @@\n-  predicate(UseAVX <= 2);\n+  predicate(!VM_Version::supports_avx512vlbw());\n@@ -11836,1 +11836,1 @@\n-  predicate(UseAVX > 2);\n+  predicate(VM_Version::supports_avx512vlbw());\n@@ -11853,1 +11853,1 @@\n-  predicate(UseAVX <= 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate(!VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -11869,1 +11869,1 @@\n-  predicate(UseAVX > 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate(VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -11885,1 +11885,1 @@\n-  predicate(UseAVX <= 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(!VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -11901,1 +11901,1 @@\n-  predicate(UseAVX > 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(VM_Version::supports_avx512vlbw() && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -11917,1 +11917,1 @@\n-  predicate(UseAVX <= 2);\n+  predicate(!VM_Version::supports_avx512vlbw() || !VM_Version::supports_bmi2());\n@@ -11933,1 +11933,1 @@\n-  predicate(UseAVX > 2);\n+  predicate(VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2());\n@@ -11949,1 +11949,1 @@\n-  predicate(UseAVX <= 2);\n+  predicate(!VM_Version::supports_avx512vlbw() || !VM_Version::supports_bmi2());\n@@ -11966,1 +11966,1 @@\n-  predicate(UseAVX > 2);\n+  predicate(VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2());\n@@ -11983,1 +11983,1 @@\n-  predicate(UseAVX <= 2);\n+  predicate(!VM_Version::supports_avx512vlbw() || !VM_Version::supports_bmi2());\n@@ -11997,1 +11997,1 @@\n-  predicate(UseAVX > 2);\n+  predicate(VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2());\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -606,0 +606,3 @@\n+  \/\/ simulate crash during compilation\n+  assert(CICrashAt < 0 || (uintx)_env->compile_id() != (uintx)CICrashAt, \"just as planned\");\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2227,0 +2227,1 @@\n+                            256, ResourceObj::RESOURCE_AREA, mtInternal,\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,2 +278,1 @@\n-typedef ResourceHashtable<int, sig_as_verification_types*,\n-                          primitive_hash<int>, primitive_equals<int>, 1007>\n+typedef ResourceHashtable<int, sig_as_verification_types*, 1007>\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2254,2 +2254,4 @@\n-  typedef ResourceHashtable<DependencySignature, int, &DependencySignature::hash,\n-                            &DependencySignature::equals, 11027> DepTable;\n+  typedef ResourceHashtable<DependencySignature, int, 11027,\n+                            ResourceObj::RESOURCE_AREA, mtInternal,\n+                            &DependencySignature::hash,\n+                            &DependencySignature::equals> DepTable;\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2129,2 +2129,0 @@\n-  \/\/ simulate crash during compilation\n-  assert(task->compile_id() != CICrashAt, \"just as planned\");\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -488,0 +488,3 @@\n+  \/\/ simulate crash during compilation\n+  assert(CICrashAt < 0 || _compile->compile_id() != CICrashAt, \"just as planned\");\n+\n@@ -2576,4 +2579,0 @@\n-  \/\/ Now that all inlining is over, cut edge from root to loop\n-  \/\/ safepoints\n-  remove_root_to_sfpts_edges(igvn);\n-\n@@ -2616,0 +2615,4 @@\n+  \/\/ Now that all inlining is over and no PhaseRemoveUseless will run, cut edge from root to loop\n+  \/\/ safepoints\n+  remove_root_to_sfpts_edges(igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -117,4 +117,5 @@\n-  Node *r = iff->in(0);\n-  if( !r->is_Region() ) return NULL;\n-  if (r->is_Loop()) return NULL;\n-  if( phi->region() != r ) return NULL;\n+  Node* r = iff->in(0);\n+  if (!r->is_Region() || r->is_Loop() || phi->region() != r || r->as_Region()->is_copy()) {\n+    return NULL;\n+  }\n+\n@@ -246,0 +247,2 @@\n+      \/\/ Bail out if splitting through a region with a predicate input (could\n+      \/\/ also be a loop header before loop opts creates a LoopNode for it).\n@@ -252,1 +255,9 @@\n-  if((r->req() - req_c) == 1) {\n+  if ((r->req() - req_c) == 1) {\n+    return NULL;\n+  }\n+\n+  \/\/ At this point we know that we can apply the split if optimization. If the region is still on the worklist,\n+  \/\/ we should wait until it is processed. The region might be removed which makes this optimization redundant.\n+  \/\/ This also avoids the creation of dead data loops when rewiring data nodes below when a region is dying.\n+  if (igvn->_worklist.member(r)) {\n+    igvn->_worklist.push(iff); \/\/ retry split if later again\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2290,0 +2290,3 @@\n+  Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(wbclass));\n+  const char* klass_name = klass->external_name();\n+\n@@ -2305,2 +2308,2 @@\n-          tty->print_cr(\"Warning: 'NoSuchMethodError' on register of sun.hotspot.WhiteBox::%s%s\",\n-              method_array[i].name, method_array[i].signature);\n+          tty->print_cr(\"Warning: 'NoSuchMethodError' on register of %s::%s%s\",\n+              klass_name, method_array[i].name, method_array[i].signature);\n@@ -2310,2 +2313,2 @@\n-        tty->print_cr(\"Warning: unexpected error on register of sun.hotspot.WhiteBox::%s%s. All methods will be unregistered\",\n-            method_array[i].name, method_array[i].signature);\n+        tty->print_cr(\"Warning: unexpected error on register of %s::%s%s. All methods will be unregistered\",\n+            klass_name, method_array[i].name, method_array[i].signature);\n@@ -2526,1 +2529,1 @@\n-      CC\"(Ljava\/lang\/String;C[Lsun\/hotspot\/parser\/DiagnosticCommand;)[Ljava\/lang\/Object;\",\n+      CC\"(Ljava\/lang\/String;C[Ljdk\/test\/whitebox\/parser\/DiagnosticCommand;)[Ljava\/lang\/Object;\",\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-#include \"services\/memTracker.hpp\"\n+#include \"services\/nmtCommon.hpp\"\n@@ -1994,11 +1994,0 @@\n-  if (PrintNMTStatistics) {\n-#if INCLUDE_NMT\n-    if (MemTracker::tracking_level() == NMT_off) {\n-#endif \/\/ INCLUDE_NMT\n-      warning(\"PrintNMTStatistics is disabled, because native memory tracking is not enabled\");\n-      PrintNMTStatistics = false;\n-#if INCLUDE_NMT\n-    }\n-#endif\n-  }\n-\n@@ -3739,23 +3728,0 @@\n-    if (match_option(option, \"-XX:NativeMemoryTracking\", &tail)) {\n-#if INCLUDE_NMT\n-      \/\/ The launcher did not setup nmt environment variable properly.\n-      if (!MemTracker::check_launcher_nmt_support(tail)) {\n-        warning(\"Native Memory Tracking did not setup properly, using wrong launcher?\");\n-      }\n-\n-      \/\/ Verify if nmt option is valid.\n-      if (MemTracker::verify_nmt_option()) {\n-        \/\/ Late initialization, still in single-threaded mode.\n-        if (MemTracker::tracking_level() >= NMT_summary) {\n-          MemTracker::init();\n-        }\n-      } else {\n-        vm_exit_during_initialization(\"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", NULL);\n-      }\n-      continue;\n-#else\n-      jio_fprintf(defaultStream::error_stream(),\n-        \"Native Memory Tracking is not supported in this VM\\n\");\n-      return JNI_ERR;\n-#endif\n-    }\n@@ -4013,0 +3979,20 @@\n+#if INCLUDE_NMT\n+  \/\/ Verify NMT arguments\n+  const NMT_TrackingLevel lvl = NMTUtil::parse_tracking_level(NativeMemoryTracking);\n+  if (lvl == NMT_unknown) {\n+    jio_fprintf(defaultStream::error_stream(),\n+                \"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", NULL);\n+    return JNI_ERR;\n+  }\n+  if (PrintNMTStatistics && lvl == NMT_off) {\n+    warning(\"PrintNMTStatistics is disabled, because native memory tracking is not enabled\");\n+    FLAG_SET_DEFAULT(PrintNMTStatistics, false);\n+  }\n+#else\n+  if (!FLAG_IS_DEFAULT(NativeMemoryTracking) || PrintNMTStatistics) {\n+    warning(\"Native Memory Tracking is not supported in this VM\");\n+    FLAG_SET_DEFAULT(NativeMemoryTracking, \"off\");\n+    FLAG_SET_DEFAULT(PrintNMTStatistics, false);\n+  }\n+#endif \/\/ INCLUDE_NMT\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":21,"deletions":35,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -709,0 +709,1 @@\n+  assert(is_a_block_safe_state(state), \"Illegal threadstate encountered: %d\", state);\n@@ -712,12 +713,2 @@\n-  \/\/ Check that we have a valid thread_state at this point\n-  switch(state) {\n-    case _thread_in_vm_trans:\n-    case _thread_in_Java:        \/\/ From compiled code\n-    case _thread_in_native_trans:\n-    case _thread_blocked_trans:\n-    case _thread_new_trans:\n-\n-      \/\/ We have no idea where the VMThread is, it might even be at next safepoint.\n-      \/\/ So we can miss this poll, but stop at next.\n-      \/\/ Load dependent store, it must not pass loading of safepoint_id.\n-      thread->safepoint_state()->set_safepoint_id(safepoint_id); \/\/ Release store\n+  \/\/ We have no idea where the VMThread is, it might even be at next safepoint.\n+  \/\/ So we can miss this poll, but stop at next.\n@@ -726,4 +717,2 @@\n-      \/\/ This part we can skip if we notice we miss or are in a future safepoint.\n-      OrderAccess::storestore();\n-      \/\/ Load in wait barrier should not float up\n-      thread->set_thread_state_fence(_thread_blocked);\n+  \/\/ Load dependent store, it must not pass loading of safepoint_id.\n+  thread->safepoint_state()->set_safepoint_id(safepoint_id); \/\/ Release store\n@@ -731,2 +720,4 @@\n-      _wait_barrier->wait(static_cast<int>(safepoint_id));\n-      assert(_state != _synchronized, \"Can't be\");\n+  \/\/ This part we can skip if we notice we miss or are in a future safepoint.\n+  OrderAccess::storestore();\n+  \/\/ Load in wait barrier should not float up\n+  thread->set_thread_state_fence(_thread_blocked);\n@@ -734,3 +725,2 @@\n-      \/\/ If barrier is disarmed stop store from floating above loads in barrier.\n-      OrderAccess::loadstore();\n-      thread->set_thread_state(state);\n+  _wait_barrier->wait(static_cast<int>(safepoint_id));\n+  assert(_state != _synchronized, \"Can't be\");\n@@ -738,2 +728,3 @@\n-      \/\/ Then we reset the safepoint id to inactive.\n-      thread->safepoint_state()->reset_safepoint_id(); \/\/ Release store\n+  \/\/ If barrier is disarmed stop store from floating above loads in barrier.\n+  OrderAccess::loadstore();\n+  thread->set_thread_state(state);\n@@ -741,1 +732,2 @@\n-      OrderAccess::fence();\n+  \/\/ Then we reset the safepoint id to inactive.\n+  thread->safepoint_state()->reset_safepoint_id(); \/\/ Release store\n@@ -743,1 +735,1 @@\n-      break;\n+  OrderAccess::fence();\n@@ -745,3 +737,0 @@\n-    default:\n-     fatal(\"Illegal threadstate encountered: %d\", state);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":17,"deletions":28,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -98,1 +98,0 @@\n-#include \"runtime\/prefetch.inline.hpp\"\n@@ -2482,22 +2481,0 @@\n-static inline void *prefetch_and_load_ptr(void **addr, intx prefetch_interval) {\n-  Prefetch::read((void*)addr, prefetch_interval);\n-  return *addr;\n-}\n-\n-\/\/ Possibly the ugliest for loop the world has seen. C++ does not allow\n-\/\/ multiple types in the declaration section of the for loop. In this case\n-\/\/ we are only dealing with pointers and hence can cast them. It looks ugly\n-\/\/ but macros are ugly and therefore it's fine to make things absurdly ugly.\n-#define DO_JAVA_THREADS(LIST, X)                                                                                          \\\n-    for (JavaThread *MACRO_scan_interval = (JavaThread*)(uintptr_t)PrefetchScanIntervalInBytes,                           \\\n-             *MACRO_list = (JavaThread*)(LIST),                                                                           \\\n-             **MACRO_end = ((JavaThread**)((ThreadsList*)MACRO_list)->threads()) + ((ThreadsList*)MACRO_list)->length(),  \\\n-             **MACRO_current_p = (JavaThread**)((ThreadsList*)MACRO_list)->threads(),                                     \\\n-             *X = (JavaThread*)prefetch_and_load_ptr((void**)MACRO_current_p, (intx)MACRO_scan_interval);                 \\\n-         MACRO_current_p != MACRO_end;                                                                                    \\\n-         MACRO_current_p++,                                                                                               \\\n-             X = (JavaThread*)prefetch_and_load_ptr((void**)MACRO_current_p, (intx)MACRO_scan_interval))\n-\n-\/\/ All JavaThreads\n-#define ALL_JAVA_THREADS(X) DO_JAVA_THREADS(ThreadsSMRSupport::get_java_thread_list(), X)\n-\n@@ -2512,0 +2489,4 @@\n+\/\/ All JavaThreads\n+#define ALL_JAVA_THREADS(X) \\\n+  for (JavaThread* X : *ThreadsSMRSupport::get_java_thread_list())\n+\n@@ -2730,0 +2711,5 @@\n+#if INCLUDE_NMT\n+  \/\/ Initialize NMT right after argument parsing to keep the pre-NMT-init window small.\n+  MemTracker::initialize();\n+#endif \/\/ INCLUDE_NMT\n+\n@@ -3645,1 +3631,1 @@\n-  DO_JAVA_THREADS(t_list, p) {\n+  for (JavaThread* p : *t_list) {\n@@ -3666,1 +3652,1 @@\n-  DO_JAVA_THREADS(t_list, p) {\n+  for (JavaThread* p : *t_list) {\n@@ -3681,1 +3667,1 @@\n-  DO_JAVA_THREADS(t_list, q) {\n+  for (JavaThread* q : *t_list) {\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":12,"deletions":26,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-    return \"Print a list of all loaded classes, indented to show the class hiearchy. \"\n+    return \"Print a list of all loaded classes, indented to show the class hierarchy. \"\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,24 @@\n+const char* NMTUtil::tracking_level_to_string(NMT_TrackingLevel lvl) {\n+  switch(lvl) {\n+    case NMT_unknown: return \"unknown\"; break;\n+    case NMT_off:     return \"off\"; break;\n+    case NMT_minimal: return \"minimal\"; break;\n+    case NMT_summary: return \"summary\"; break;\n+    case NMT_detail:  return \"detail\"; break;\n+    default:          return \"invalid\"; break;\n+  }\n+}\n+\n+\/\/ Returns the parsed level; NMT_unknown if string is invalid\n+NMT_TrackingLevel NMTUtil::parse_tracking_level(const char* s) {\n+  if (s != NULL) {\n+    if (strcmp(s, \"summary\") == 0) {\n+      return NMT_summary;\n+    } else if (strcmp(s, \"detail\") == 0) {\n+      return NMT_detail;\n+    } else if (strcmp(s, \"off\") == 0) {\n+      return NMT_off;\n+    }\n+  }\n+  return NMT_unknown;\n+}\n","filename":"src\/hotspot\/share\/services\/nmtCommon.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -236,3 +236,13 @@\n-        return (isPrimitiveClass() ? \"primitive \" : \"\")\n-               + (isInterface() ? \"interface \" : (isPrimitive() ? \"\" : \"class \"))\n-               + getName() + (isPrimitiveClass() && isPrimaryType() ? \".ref\" : \"\");\n+        String s = isPrimitive() ? \"\" : \"class \";\n+        if (isInterface()) {\n+            s = \"interface \";\n+        }\n+        if (isPrimitiveClass()) {\n+            s = \"primitive \";\n+        }\n+        \/\/ Avoid invokedynamic based String concat, might be not available\n+        s = s.concat(getName());\n+        if (isPrimitiveClass() && isPrimaryType()) {\n+            s.concat(\".ref\");\n+        }\n+        return s;\n@@ -622,1 +632,1 @@\n-        throw new UnsupportedOperationException(this.getName() + \" is not a primitive class\");\n+        throw new UnsupportedOperationException(this.getName().concat(\" is not a primitive class\"));\n@@ -1019,1 +1029,1 @@\n-        ClassLoader cl = getClassLoader0();\n+        ClassLoader cl = classLoader;\n@@ -1168,1 +1178,1 @@\n-        ClassLoader cl = getClassLoader0();\n+        ClassLoader cl = classLoader;\n@@ -1782,1 +1792,1 @@\n-            return getComponentType().getSimpleName() + \"[]\";\n+            return getComponentType().getSimpleName().concat(\"[]\");\n@@ -1807,1 +1817,1 @@\n-                return cl.getTypeName() + \"[]\".repeat(dimensions);\n+                return cl.getTypeName().concat(\"[]\".repeat(dimensions));\n@@ -1812,1 +1822,1 @@\n-            return isPrimaryType() ? getName() + \".ref\" : getName();\n+            return isPrimaryType() ? getName().concat(\".ref\") : getName();\n@@ -1847,1 +1857,1 @@\n-                return canonicalName + \"[]\";\n+                return canonicalName.concat(\"[]\");\n@@ -2953,1 +2963,1 @@\n-            ClassLoader cl = getClassLoader0();\n+            ClassLoader cl = classLoader;\n@@ -2973,1 +2983,1 @@\n-        ClassLoader cl = getClassLoader0();\n+        ClassLoader cl = classLoader;\n@@ -3049,1 +3059,1 @@\n-            ClassLoader cl = getClassLoader0();\n+            ClassLoader cl = classLoader;\n@@ -3062,1 +3072,1 @@\n-        ClassLoader cl = getClassLoader0();\n+        ClassLoader cl = classLoader;\n@@ -3176,1 +3186,1 @@\n-            final ClassLoader cl = getClassLoader0();\n+            final ClassLoader cl = classLoader;\n@@ -3193,1 +3203,1 @@\n-        final ClassLoader cl = getClassLoader0();\n+        final ClassLoader cl = classLoader;\n@@ -3222,1 +3232,1 @@\n-        final ClassLoader cl = subClasses[0].getClassLoader0();\n+        final ClassLoader cl = subClasses[0].classLoader;\n@@ -3847,1 +3857,1 @@\n-        ClassLoader loader = getClassLoader0();\n+        ClassLoader loader = classLoader;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-        if (sm != null) sm.checkPermission(ACCESS_PERMISSION);\n+        if (sm != null) sm.checkPermission(SecurityConstants.ACCESS_PERMISSION);\n@@ -446,1 +446,1 @@\n-        if (smgr != null)  smgr.checkPermission(ACCESS_PERMISSION);\n+        if (smgr != null)  smgr.checkPermission(SecurityConstants.ACCESS_PERMISSION);\n@@ -450,3 +450,0 @@\n-    \/\/ Copied from AccessibleObject, as used by Method.setAccessible, etc.:\n-    private static final java.security.Permission ACCESS_PERMISSION =\n-        new ReflectPermission(\"suppressAccessChecks\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -530,1 +530,1 @@\n-                    throw new InternalError(\"ununamed module: \" + m);\n+                    throw new InternalError(\"unnamed module: \" + m);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import java.util.LinkedList;\n@@ -248,1 +247,1 @@\n-        LinkedList<Class<?>> uncoveredReturnTypes = new LinkedList<>();\n+        List<Class<?>> uncoveredReturnTypes = new ArrayList<>(1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,3 +122,0 @@\n-        dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,\n-            names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,\n-            names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER, names.MODULE };\n@@ -163,0 +160,1 @@\n+        allowModules = Feature.MODULES.allowedInSource(source);\n@@ -196,0 +194,4 @@\n+    \/** Are modules allowed\n+     *\/\n+    private final boolean allowModules;\n+\n@@ -3467,14 +3469,1 @@\n-            Set<Name> targets = new HashSet<>();\n-            targets.add(names.ANNOTATION_TYPE);\n-            targets.add(names.CONSTRUCTOR);\n-            targets.add(names.FIELD);\n-            if (allowRecords) {\n-                targets.add(names.RECORD_COMPONENT);\n-            }\n-            targets.add(names.LOCAL_VARIABLE);\n-            targets.add(names.METHOD);\n-            targets.add(names.PACKAGE);\n-            targets.add(names.PARAMETER);\n-            targets.add(names.TYPE);\n-\n-            defaultTargets = java.util.Collections.unmodifiableSet(targets);\n+            defaultTargets = Set.of(defaultTargetMetaInfo());\n@@ -3680,1 +3669,1 @@\n-    public final Name[] dfltTargetMeta;\n+    private Name[] dfltTargetMeta;\n@@ -3682,0 +3671,18 @@\n+        if (dfltTargetMeta == null) {\n+            ArrayList<Name> defaultTargets = new ArrayList<>();\n+            defaultTargets.add(names.PACKAGE);\n+            defaultTargets.add(names.TYPE);\n+            defaultTargets.add(names.FIELD);\n+            defaultTargets.add(names.METHOD);\n+            defaultTargets.add(names.CONSTRUCTOR);\n+            defaultTargets.add(names.ANNOTATION_TYPE);\n+            defaultTargets.add(names.LOCAL_VARIABLE);\n+            defaultTargets.add(names.PARAMETER);\n+            if (allowRecords) {\n+              defaultTargets.add(names.RECORD_COMPONENT);\n+            }\n+            if (allowModules) {\n+              defaultTargets.add(names.MODULE);\n+            }\n+            dfltTargetMeta = defaultTargets.toArray(new Name[0]);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062 macosx-x64\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062,8270326 macosx-x64,macosx-aarch64\n@@ -121,2 +121,0 @@\n-serviceability\/dcmd\/gc\/HeapDumpAllTest.java 8270341 generic-x64\n-\n@@ -151,1 +149,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,1 +108,2 @@\n-  gtest\/LargePageGtests.java\n+  gtest\/LargePageGtests.java \\\n+  gtest\/NMTGtests.java \\\n@@ -318,1 +319,0 @@\n- -runtime\/NMT \\\n@@ -497,1 +497,2 @@\n-  runtime\/NMT\n+  runtime\/NMT \\\n+  gtest\/NMTGtests.java\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,4 +47,4 @@\n-import sun.hotspot.code.Compiler;\n-import sun.hotspot.cpuinfo.CPUInfo;\n-import sun.hotspot.gc.GC;\n-import sun.hotspot.WhiteBox;\n+import jdk.test.whitebox.code.Compiler;\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n+import jdk.test.whitebox.gc.GC;\n+import jdk.test.whitebox.WhiteBox;\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import sun.hotspot.parser.DiagnosticCommand;\n+import jdk.test.whitebox.parser.DiagnosticCommand;\n@@ -37,0 +37,1 @@\n+@Deprecated\n@@ -61,1 +62,1 @@\n-      sm.checkPermission(new WhiteBoxPermission(\"getInstance\"));\n+      throw new SecurityException(\"can't use old whitebox with SecurityManager, please switch to jdk.test.whitebox.WhiteBox\");\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}