{"files":[{"patch":"@@ -1051,1 +1051,1 @@\n-        linux_aarch64: \"gcc11.2.0-OL7.6+1.0\",\n+        linux_aarch64: input.build_cpu == \"x64\" ? \"gcc11.2.0-OL7.6+1.1\" : \"gcc11.2.0-OL7.6+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1194,0 +1194,4 @@\n+\n+  \/\/ Convert BootTest condition to Assembler condition.\n+  \/\/ Replicate the logic of cmpOpOper::ccode() and cmpOpUOper::ccode().\n+  Assembler::Condition to_assembler_cond(BoolTest::mask cond);\n@@ -2531,0 +2535,44 @@\n+\/\/ Convert BootTest condition to Assembler condition.\n+\/\/ Replicate the logic of cmpOpOper::ccode() and cmpOpUOper::ccode().\n+Assembler::Condition to_assembler_cond(BoolTest::mask cond) {\n+  Assembler::Condition result;\n+  switch(cond) {\n+    case BoolTest::eq:\n+      result = Assembler::EQ; break;\n+    case BoolTest::ne:\n+      result = Assembler::NE; break;\n+    case BoolTest::le:\n+      result = Assembler::LE; break;\n+    case BoolTest::ge:\n+      result = Assembler::GE; break;\n+    case BoolTest::lt:\n+      result = Assembler::LT; break;\n+    case BoolTest::gt:\n+      result = Assembler::GT; break;\n+    case BoolTest::ule:\n+      result = Assembler::LS; break;\n+    case BoolTest::uge:\n+      result = Assembler::HS; break;\n+    case BoolTest::ult:\n+      result = Assembler::LO; break;\n+    case BoolTest::ugt:\n+      result = Assembler::HI; break;\n+    case BoolTest::overflow:\n+      result = Assembler::VS; break;\n+    case BoolTest::no_overflow:\n+      result = Assembler::VC; break;\n+    default:\n+      ShouldNotReachHere();\n+      return Assembler::Condition(-1);\n+  }\n+\n+  \/\/ Check conversion\n+  if (cond & BoolTest::unsigned_compare) {\n+    assert(cmpOpUOper((BoolTest::mask)((int)cond & ~(BoolTest::unsigned_compare))).ccode() == result, \"Invalid conversion\");\n+  } else {\n+    assert(cmpOpOper(cond).ccode() == result, \"Invalid conversion\");\n+  }\n+\n+  return result;\n+}\n+\n@@ -4305,0 +4353,11 @@\n+\/\/ BoolTest condition for signed compare\n+operand immI_cmp_cond()\n+%{\n+  predicate(n->get_int() < (int)(BoolTest::unsigned_compare));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -8994,2 +9053,1 @@\n-\/\/ This section is generated from aarch64_ad_cas.m4\n-\n+\/\/ This section is generated from cas.m4\n@@ -9001,1 +9059,0 @@\n-\n@@ -9020,1 +9077,0 @@\n-\n@@ -9039,1 +9095,0 @@\n-\n@@ -9057,1 +9112,0 @@\n-\n@@ -9075,1 +9129,0 @@\n-\n@@ -9221,1 +9274,0 @@\n-\n@@ -9241,1 +9293,0 @@\n-\n@@ -9261,1 +9312,0 @@\n-\n@@ -9281,1 +9331,0 @@\n-\n@@ -9301,1 +9350,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":60,"deletions":12,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -66,12 +66,0 @@\n-RangeCheckStub::RangeCheckStub(CodeEmitInfo* info, LIR_Opr index, LIR_Opr array)\n-  : _index(index), _array(array), _throw_index_out_of_bounds_exception(false) {\n-  assert(info != NULL, \"must have info\");\n-  _info = new CodeEmitInfo(info);\n-}\n-\n-RangeCheckStub::RangeCheckStub(CodeEmitInfo* info, LIR_Opr index)\n-  : _index(index), _array(), _throw_index_out_of_bounds_exception(true) {\n-  assert(info != NULL, \"must have info\");\n-  _info = new CodeEmitInfo(info);\n-}\n-\n@@ -284,13 +272,0 @@\n-\/\/ Implementation of MonitorAccessStubs\n-\n-MonitorEnterStub::MonitorEnterStub(LIR_Opr obj_reg, LIR_Opr lock_reg, CodeEmitInfo* info,  CodeStub* throw_imse_stub, LIR_Opr scratch_reg)\n-: MonitorAccessStub(obj_reg, lock_reg)\n-{\n-  _info = new CodeEmitInfo(info);\n-  _scratch_reg = scratch_reg;\n-  _throw_imse_stub = throw_imse_stub;\n-  if (_throw_imse_stub != NULL) {\n-    assert(_scratch_reg != LIR_OprFact::illegalOpr, \"must be\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -951,1 +951,1 @@\n-        notr(dst, T16B, dst);\n+        notr(dst, isQ ? T16B : T8B, dst);\n@@ -967,1 +967,1 @@\n-        notr(dst, T16B, dst);\n+        notr(dst, isQ ? T16B : T8B, dst);\n@@ -985,0 +985,20 @@\n+void C2_MacroAssembler::neon_compare_zero(FloatRegister dst, BasicType bt, FloatRegister src,\n+                                          Condition cond, bool isQ) {\n+  SIMD_Arrangement size = esize2arrangement((unsigned)type2aelembytes(bt), isQ);\n+  if (bt == T_FLOAT || bt == T_DOUBLE) {\n+    if (cond == Assembler::NE) {\n+      fcm(Assembler::EQ, dst, size, src);\n+      notr(dst, isQ ? T16B : T8B, dst);\n+    } else {\n+      fcm(cond, dst, size, src);\n+    }\n+  } else {\n+    if (cond == Assembler::NE) {\n+      cm(Assembler::EQ, dst, size, src);\n+      notr(dst, isQ ? T16B : T8B, dst);\n+    } else {\n+      cm(cond, dst, size, src);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,3 @@\n+  void neon_compare_zero(FloatRegister dst, BasicType bt, FloatRegister src,\n+                         Condition cond, bool isQ);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -152,0 +152,105 @@\n+void BarrierSetAssembler::copy_load_at(MacroAssembler* masm,\n+                                       DecoratorSet decorators,\n+                                       BasicType type,\n+                                       size_t bytes,\n+                                       Register dst1,\n+                                       Register dst2,\n+                                       Address src,\n+                                       Register tmp) {\n+  if (bytes == 1) {\n+    assert(dst2 == noreg, \"invariant\");\n+    __ ldrb(dst1, src);\n+  } else if (bytes == 2) {\n+    assert(dst2 == noreg, \"invariant\");\n+    __ ldrh(dst1, src);\n+  } else if (bytes == 4) {\n+    assert(dst2 == noreg, \"invariant\");\n+    __ ldrw(dst1, src);\n+  } else if (bytes == 8) {\n+    assert(dst2 == noreg, \"invariant\");\n+    __ ldr(dst1, src);\n+  } else if (bytes == 16) {\n+    assert(dst2 != noreg, \"invariant\");\n+    assert(dst2 != dst1, \"invariant\");\n+    __ ldp(dst1, dst2, src);\n+  } else {\n+    \/\/ Not the right size\n+    ShouldNotReachHere();\n+  }\n+  if ((decorators & ARRAYCOPY_CHECKCAST) != 0 && UseCompressedOops) {\n+    __ decode_heap_oop(dst1);\n+  }\n+}\n+\n+void BarrierSetAssembler::copy_store_at(MacroAssembler* masm,\n+                                        DecoratorSet decorators,\n+                                        BasicType type,\n+                                        size_t bytes,\n+                                        Address dst,\n+                                        Register src1,\n+                                        Register src2,\n+                                        Register tmp1,\n+                                        Register tmp2,\n+                                        Register tmp3) {\n+  if ((decorators & ARRAYCOPY_CHECKCAST) != 0 && UseCompressedOops) {\n+    __ encode_heap_oop(src1);\n+  }\n+  if (bytes == 1) {\n+    assert(src2 == noreg, \"invariant\");\n+    __ strb(src1, dst);\n+  } else if (bytes == 2) {\n+    assert(src2 == noreg, \"invariant\");\n+    __ strh(src1, dst);\n+  } else if (bytes == 4) {\n+    assert(src2 == noreg, \"invariant\");\n+    __ strw(src1, dst);\n+  } else if (bytes == 8) {\n+    assert(src2 == noreg, \"invariant\");\n+    __ str(src1, dst);\n+  } else if (bytes == 16) {\n+    assert(src2 != noreg, \"invariant\");\n+    assert(src2 != src1, \"invariant\");\n+    __ stp(src1, src2, dst);\n+  } else {\n+    \/\/ Not the right size\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void BarrierSetAssembler::copy_load_at(MacroAssembler* masm,\n+                                       DecoratorSet decorators,\n+                                       BasicType type,\n+                                       size_t bytes,\n+                                       FloatRegister dst1,\n+                                       FloatRegister dst2,\n+                                       Address src,\n+                                       Register tmp1,\n+                                       Register tmp2,\n+                                       FloatRegister vec_tmp) {\n+  if (bytes == 32) {\n+    __ ldpq(dst1, dst2, src);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void BarrierSetAssembler::copy_store_at(MacroAssembler* masm,\n+                                        DecoratorSet decorators,\n+                                        BasicType type,\n+                                        size_t bytes,\n+                                        Address dst,\n+                                        FloatRegister src1,\n+                                        FloatRegister src2,\n+                                        Register tmp1,\n+                                        Register tmp2,\n+                                        Register tmp3,\n+                                        FloatRegister vec_tmp1,\n+                                        FloatRegister vec_tmp2,\n+                                        FloatRegister vec_tmp3) {\n+  if (bytes == 32) {\n+    __ stpq(src1, src2, dst);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -51,0 +51,46 @@\n+\n+  virtual void copy_load_at(MacroAssembler* masm,\n+                            DecoratorSet decorators,\n+                            BasicType type,\n+                            size_t bytes,\n+                            Register dst1,\n+                            Register dst2,\n+                            Address src,\n+                            Register tmp);\n+\n+  virtual void copy_store_at(MacroAssembler* masm,\n+                             DecoratorSet decorators,\n+                             BasicType type,\n+                             size_t bytes,\n+                             Address dst,\n+                             Register src1,\n+                             Register src2,\n+                             Register tmp1,\n+                             Register tmp2,\n+                             Register tmp3);\n+\n+  virtual void copy_load_at(MacroAssembler* masm,\n+                            DecoratorSet decorators,\n+                            BasicType type,\n+                            size_t bytes,\n+                            FloatRegister dst1,\n+                            FloatRegister dst2,\n+                            Address src,\n+                            Register tmp1,\n+                            Register tmp2,\n+                            FloatRegister vec_tmp);\n+\n+  virtual void copy_store_at(MacroAssembler* masm,\n+                             DecoratorSet decorators,\n+                             BasicType type,\n+                             size_t bytes,\n+                             Address dst,\n+                             FloatRegister src1,\n+                             FloatRegister src2,\n+                             Register tmp1,\n+                             Register tmp2,\n+                             Register tmp3,\n+                             FloatRegister vec_tmp1,\n+                             FloatRegister vec_tmp2,\n+                             FloatRegister vec_tmp3);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,0 +94,2 @@\n+  product(bool, UseCryptoPmullForCRC32, false,                          \\\n+          \"Use Crypto PMULL instructions for CRC32 computation\")        \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3769,0 +3769,59 @@\n+void MacroAssembler::kernel_crc32_using_crypto_pmull(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2, Register tmp3) {\n+    Label CRC_by4_loop, CRC_by1_loop, CRC_less128, CRC_by128_pre, CRC_by32_loop, CRC_less32, L_exit;\n+    assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2);\n+\n+    subs(tmp0, len, 384);\n+    mvnw(crc, crc);\n+    br(Assembler::GE, CRC_by128_pre);\n+  BIND(CRC_less128);\n+    subs(len, len, 32);\n+    br(Assembler::GE, CRC_by32_loop);\n+  BIND(CRC_less32);\n+    adds(len, len, 32 - 4);\n+    br(Assembler::GE, CRC_by4_loop);\n+    adds(len, len, 4);\n+    br(Assembler::GT, CRC_by1_loop);\n+    b(L_exit);\n+\n+  BIND(CRC_by32_loop);\n+    ldp(tmp0, tmp1, Address(buf));\n+    crc32x(crc, crc, tmp0);\n+    ldp(tmp2, tmp3, Address(buf, 16));\n+    crc32x(crc, crc, tmp1);\n+    add(buf, buf, 32);\n+    crc32x(crc, crc, tmp2);\n+    subs(len, len, 32);\n+    crc32x(crc, crc, tmp3);\n+    br(Assembler::GE, CRC_by32_loop);\n+    cmn(len, (u1)32);\n+    br(Assembler::NE, CRC_less32);\n+    b(L_exit);\n+\n+  BIND(CRC_by4_loop);\n+    ldrw(tmp0, Address(post(buf, 4)));\n+    subs(len, len, 4);\n+    crc32w(crc, crc, tmp0);\n+    br(Assembler::GE, CRC_by4_loop);\n+    adds(len, len, 4);\n+    br(Assembler::LE, L_exit);\n+  BIND(CRC_by1_loop);\n+    ldrb(tmp0, Address(post(buf, 1)));\n+    subs(len, len, 1);\n+    crc32b(crc, crc, tmp0);\n+    br(Assembler::GT, CRC_by1_loop);\n+    b(L_exit);\n+\n+  BIND(CRC_by128_pre);\n+    kernel_crc32_common_fold_using_crypto_pmull(crc, buf, len, tmp0, tmp1, tmp2,\n+      4*256*sizeof(juint) + 8*sizeof(juint));\n+    mov(crc, 0);\n+    crc32x(crc, crc, tmp0);\n+    crc32x(crc, crc, tmp1);\n+\n+    cbnz(len, CRC_less128);\n+\n+  BIND(L_exit);\n+    mvnw(crc, crc);\n+}\n+\n@@ -3880,0 +3939,5 @@\n+  if (UseCryptoPmullForCRC32) {\n+      kernel_crc32_using_crypto_pmull(crc, buf, len, table0, table1, table2, table3);\n+      return;\n+  }\n+\n@@ -4070,0 +4134,58 @@\n+void MacroAssembler::kernel_crc32c_using_crypto_pmull(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2, Register tmp3) {\n+    Label CRC_by4_loop, CRC_by1_loop, CRC_less128, CRC_by128_pre, CRC_by32_loop, CRC_less32, L_exit;\n+    assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2);\n+\n+    subs(tmp0, len, 384);\n+    br(Assembler::GE, CRC_by128_pre);\n+  BIND(CRC_less128);\n+    subs(len, len, 32);\n+    br(Assembler::GE, CRC_by32_loop);\n+  BIND(CRC_less32);\n+    adds(len, len, 32 - 4);\n+    br(Assembler::GE, CRC_by4_loop);\n+    adds(len, len, 4);\n+    br(Assembler::GT, CRC_by1_loop);\n+    b(L_exit);\n+\n+  BIND(CRC_by32_loop);\n+    ldp(tmp0, tmp1, Address(buf));\n+    crc32cx(crc, crc, tmp0);\n+    ldr(tmp2, Address(buf, 16));\n+    crc32cx(crc, crc, tmp1);\n+    ldr(tmp3, Address(buf, 24));\n+    crc32cx(crc, crc, tmp2);\n+    add(buf, buf, 32);\n+    subs(len, len, 32);\n+    crc32cx(crc, crc, tmp3);\n+    br(Assembler::GE, CRC_by32_loop);\n+    cmn(len, (u1)32);\n+    br(Assembler::NE, CRC_less32);\n+    b(L_exit);\n+\n+  BIND(CRC_by4_loop);\n+    ldrw(tmp0, Address(post(buf, 4)));\n+    subs(len, len, 4);\n+    crc32cw(crc, crc, tmp0);\n+    br(Assembler::GE, CRC_by4_loop);\n+    adds(len, len, 4);\n+    br(Assembler::LE, L_exit);\n+  BIND(CRC_by1_loop);\n+    ldrb(tmp0, Address(post(buf, 1)));\n+    subs(len, len, 1);\n+    crc32cb(crc, crc, tmp0);\n+    br(Assembler::GT, CRC_by1_loop);\n+    b(L_exit);\n+\n+  BIND(CRC_by128_pre);\n+    kernel_crc32_common_fold_using_crypto_pmull(crc, buf, len, tmp0, tmp1, tmp2,\n+      4*256*sizeof(juint) + 8*sizeof(juint) + 0x50);\n+    mov(crc, 0);\n+    crc32cx(crc, crc, tmp0);\n+    crc32cx(crc, crc, tmp1);\n+\n+    cbnz(len, CRC_less128);\n+\n+  BIND(L_exit);\n+}\n+\n@@ -4176,1 +4298,5 @@\n-  kernel_crc32c_using_crc32c(crc, buf, len, table0, table1, table2, table3);\n+  if (UseCryptoPmullForCRC32) {\n+    kernel_crc32c_using_crypto_pmull(crc, buf, len, table0, table1, table2, table3);\n+  } else {\n+    kernel_crc32c_using_crc32c(crc, buf, len, table0, table1, table2, table3);\n+  }\n@@ -4179,0 +4305,117 @@\n+void MacroAssembler::kernel_crc32_common_fold_using_crypto_pmull(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2, size_t table_offset) {\n+    Label CRC_by128_loop;\n+    assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2);\n+\n+    sub(len, len, 256);\n+    Register table = tmp0;\n+    {\n+      uint64_t offset;\n+      adrp(table, ExternalAddress(StubRoutines::crc_table_addr()), offset);\n+      add(table, table, offset);\n+    }\n+    add(table, table, table_offset);\n+\n+    sub(buf, buf, 0x10);\n+    ldrq(v1, Address(buf, 0x10));\n+    ldrq(v2, Address(buf, 0x20));\n+    ldrq(v3, Address(buf, 0x30));\n+    ldrq(v4, Address(buf, 0x40));\n+    ldrq(v5, Address(buf, 0x50));\n+    ldrq(v6, Address(buf, 0x60));\n+    ldrq(v7, Address(buf, 0x70));\n+    ldrq(v8, Address(pre(buf, 0x80)));\n+\n+    movi(v25, T4S, 0);\n+    mov(v25, S, 0, crc);\n+    eor(v1, T16B, v1, v25);\n+\n+    ldrq(v0, Address(table));\n+    b(CRC_by128_loop);\n+\n+    align(OptoLoopAlignment);\n+  BIND(CRC_by128_loop);\n+    pmull (v9,  T1Q, v1, v0, T1D);\n+    pmull2(v10, T1Q, v1, v0, T2D);\n+    ldrq(v1, Address(buf, 0x10));\n+    eor3(v1, T16B, v9,  v10, v1);\n+\n+    pmull (v11, T1Q, v2, v0, T1D);\n+    pmull2(v12, T1Q, v2, v0, T2D);\n+    ldrq(v2, Address(buf, 0x20));\n+    eor3(v2, T16B, v11, v12, v2);\n+\n+    pmull (v13, T1Q, v3, v0, T1D);\n+    pmull2(v14, T1Q, v3, v0, T2D);\n+    ldrq(v3, Address(buf, 0x30));\n+    eor3(v3, T16B, v13, v14, v3);\n+\n+    pmull (v15, T1Q, v4, v0, T1D);\n+    pmull2(v16, T1Q, v4, v0, T2D);\n+    ldrq(v4, Address(buf, 0x40));\n+    eor3(v4, T16B, v15, v16, v4);\n+\n+    pmull (v17, T1Q, v5, v0, T1D);\n+    pmull2(v18, T1Q, v5, v0, T2D);\n+    ldrq(v5, Address(buf, 0x50));\n+    eor3(v5, T16B, v17, v18, v5);\n+\n+    pmull (v19, T1Q, v6, v0, T1D);\n+    pmull2(v20, T1Q, v6, v0, T2D);\n+    ldrq(v6, Address(buf, 0x60));\n+    eor3(v6, T16B, v19, v20, v6);\n+\n+    pmull (v21, T1Q, v7, v0, T1D);\n+    pmull2(v22, T1Q, v7, v0, T2D);\n+    ldrq(v7, Address(buf, 0x70));\n+    eor3(v7, T16B, v21, v22, v7);\n+\n+    pmull (v23, T1Q, v8, v0, T1D);\n+    pmull2(v24, T1Q, v8, v0, T2D);\n+    ldrq(v8, Address(pre(buf, 0x80)));\n+    eor3(v8, T16B, v23, v24, v8);\n+\n+    subs(len, len, 0x80);\n+    br(Assembler::GE, CRC_by128_loop);\n+\n+    \/\/ fold into 512 bits\n+    ldrq(v0, Address(table, 0x10));\n+\n+    pmull (v10,  T1Q, v1, v0, T1D);\n+    pmull2(v11, T1Q, v1, v0, T2D);\n+    eor3(v1, T16B, v10, v11, v5);\n+\n+    pmull (v12, T1Q, v2, v0, T1D);\n+    pmull2(v13, T1Q, v2, v0, T2D);\n+    eor3(v2, T16B, v12, v13, v6);\n+\n+    pmull (v14, T1Q, v3, v0, T1D);\n+    pmull2(v15, T1Q, v3, v0, T2D);\n+    eor3(v3, T16B, v14, v15, v7);\n+\n+    pmull (v16, T1Q, v4, v0, T1D);\n+    pmull2(v17, T1Q, v4, v0, T2D);\n+    eor3(v4, T16B, v16, v17, v8);\n+\n+    \/\/ fold into 128 bits\n+    ldrq(v5, Address(table, 0x20));\n+    pmull (v10, T1Q, v1, v5, T1D);\n+    pmull2(v11, T1Q, v1, v5, T2D);\n+    eor3(v4, T16B, v4, v10, v11);\n+\n+    ldrq(v6, Address(table, 0x30));\n+    pmull (v12, T1Q, v2, v6, T1D);\n+    pmull2(v13, T1Q, v2, v6, T2D);\n+    eor3(v4, T16B, v4, v12, v13);\n+\n+    ldrq(v7, Address(table, 0x40));\n+    pmull (v14, T1Q, v3, v7, T1D);\n+    pmull2(v15, T1Q, v3, v7, T2D);\n+    eor3(v1, T16B, v4, v14, v15);\n+\n+    add(len, len, 0x80);\n+    add(buf, buf, 0x10);\n+\n+    mov(tmp0, v1, D, 0);\n+    mov(tmp1, v1, D, 1);\n+}\n@@ -4254,0 +4497,5 @@\n+void MacroAssembler::load_klass_check_null(Register dst, Register src) {\n+  null_check(src, oopDesc::klass_offset_in_bytes());\n+  load_klass(dst, src);\n+}\n+\n@@ -5729,1 +5977,1 @@\n-    umov(chk, vhix, D, 1);      ASCII(cmlt(vlox, T16B, vlox));\n+    umov(chk, vhix, D, 1);      ASCII(cm(LT, vlox, T16B, vlox));\n@@ -5755,1 +6003,1 @@\n-                                ASCII(cmlt(vtmp2, T16B, vlo));\n+                                ASCII(cm(LT, vtmp2, T16B, vlo));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":251,"deletions":3,"binary":false,"changes":254,"status":"modified"},{"patch":"@@ -884,0 +884,1 @@\n+  void load_klass_check_null(Register dst, Register src);\n@@ -1506,0 +1507,3 @@\n+  void kernel_crc32_using_crypto_pmull(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2,\n+        Register tmp3);\n@@ -1509,0 +1513,3 @@\n+  void kernel_crc32c_using_crypto_pmull(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2,\n+        Register tmp3);\n@@ -1512,0 +1519,3 @@\n+  void kernel_crc32_common_fold_using_crypto_pmull(Register crc, Register buf,\n+        Register len, Register tmp0, Register tmp1, Register tmp2,\n+        size_t table_offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -329,2 +329,1 @@\n-        __ null_check(receiver_reg, oopDesc::klass_offset_in_bytes());\n-        __ load_klass(temp1_recv_klass, receiver_reg);\n+        __ load_klass_check_null(temp1_recv_klass, receiver_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -717,0 +717,73 @@\n+  \/\/ Helper object to reduce noise when telling the GC barriers how to perform loads and stores\n+  \/\/ for arraycopy stubs.\n+  class ArrayCopyBarrierSetHelper : StackObj {\n+    BarrierSetAssembler* _bs_asm;\n+    MacroAssembler* _masm;\n+    DecoratorSet _decorators;\n+    BasicType _type;\n+    Register _gct1;\n+    Register _gct2;\n+    Register _gct3;\n+    FloatRegister _gcvt1;\n+    FloatRegister _gcvt2;\n+    FloatRegister _gcvt3;\n+\n+  public:\n+    ArrayCopyBarrierSetHelper(MacroAssembler* masm,\n+                              DecoratorSet decorators,\n+                              BasicType type,\n+                              Register gct1,\n+                              Register gct2,\n+                              Register gct3,\n+                              FloatRegister gcvt1,\n+                              FloatRegister gcvt2,\n+                              FloatRegister gcvt3)\n+      : _bs_asm(BarrierSet::barrier_set()->barrier_set_assembler()),\n+        _masm(masm),\n+        _decorators(decorators),\n+        _type(type),\n+        _gct1(gct1),\n+        _gct2(gct2),\n+        _gct3(gct3),\n+        _gcvt1(gcvt1),\n+        _gcvt2(gcvt2),\n+        _gcvt3(gcvt3) {\n+    }\n+\n+    void copy_load_at_32(FloatRegister dst1, FloatRegister dst2, Address src) {\n+      _bs_asm->copy_load_at(_masm, _decorators, _type, 32,\n+                            dst1, dst2, src,\n+                            _gct1, _gct2, _gcvt1);\n+    }\n+\n+    void copy_store_at_32(Address dst, FloatRegister src1, FloatRegister src2) {\n+      _bs_asm->copy_store_at(_masm, _decorators, _type, 32,\n+                             dst, src1, src2,\n+                             _gct1, _gct2, _gct3, _gcvt1, _gcvt2, _gcvt3);\n+    }\n+\n+    void copy_load_at_16(Register dst1, Register dst2, Address src) {\n+      _bs_asm->copy_load_at(_masm, _decorators, _type, 16,\n+                            dst1, dst2, src,\n+                            _gct1);\n+    }\n+\n+    void copy_store_at_16(Address dst, Register src1, Register src2) {\n+      _bs_asm->copy_store_at(_masm, _decorators, _type, 16,\n+                             dst, src1, src2,\n+                             _gct1, _gct2, _gct3);\n+    }\n+\n+    void copy_load_at_8(Register dst, Address src) {\n+      _bs_asm->copy_load_at(_masm, _decorators, _type, 8,\n+                            dst, noreg, src,\n+                            _gct1);\n+    }\n+\n+    void copy_store_at_8(Address dst, Register src) {\n+      _bs_asm->copy_store_at(_masm, _decorators, _type, 8,\n+                             dst, src, noreg,\n+                             _gct1, _gct2, _gct3);\n+    }\n+  };\n+\n@@ -730,1 +803,1 @@\n-  void generate_copy_longs(Label &start, Register s, Register d, Register count,\n+  void generate_copy_longs(DecoratorSet decorators, BasicType type, Label &start, Register s, Register d, Register count,\n@@ -736,2 +809,5 @@\n-      t4 = r7, t5 = r10, t6 = r11, t7 = r12;\n-    const Register stride = r13;\n+      t4 = r7, t5 = r11, t6 = r12, t7 = r13;\n+    const Register stride = r14;\n+    const Register gct1 = rscratch1, gct2 = rscratch2, gct3 = r10;\n+    const FloatRegister gcvt1 = v6, gcvt2 = v7, gcvt3 = v8;\n+    ArrayCopyBarrierSetHelper bs(_masm, decorators, type, gct1, gct2, gct3, gcvt1, gcvt2, gcvt3);\n@@ -739,2 +815,2 @@\n-    assert_different_registers(rscratch1, t0, t1, t2, t3, t4, t5, t6, t7);\n-    assert_different_registers(s, d, count, rscratch1);\n+    assert_different_registers(rscratch1, rscratch2, t0, t1, t2, t3, t4, t5, t6, t7);\n+    assert_different_registers(s, d, count, rscratch1, rscratch2);\n@@ -778,2 +854,2 @@\n-      __ ldpq(v0, v1, Address(s, 4 * unit));\n-      __ ldpq(v2, v3, Address(__ pre(s, 8 * unit)));\n+      bs.copy_load_at_32(v0, v1, Address(s, 4 * unit));\n+      bs.copy_load_at_32(v2, v3, Address(__ pre(s, 8 * unit)));\n@@ -781,4 +857,4 @@\n-      __ ldp(t0, t1, Address(s, 2 * unit));\n-      __ ldp(t2, t3, Address(s, 4 * unit));\n-      __ ldp(t4, t5, Address(s, 6 * unit));\n-      __ ldp(t6, t7, Address(__ pre(s, 8 * unit)));\n+      bs.copy_load_at_16(t0, t1, Address(s, 2 * unit));\n+      bs.copy_load_at_16(t2, t3, Address(s, 4 * unit));\n+      bs.copy_load_at_16(t4, t5, Address(s, 6 * unit));\n+      bs.copy_load_at_16(t6, t7, Address(__ pre(s, 8 * unit)));\n@@ -804,4 +880,4 @@\n-      __ stpq(v0, v1, Address(d, 4 * unit));\n-      __ ldpq(v0, v1, Address(s, 4 * unit));\n-      __ stpq(v2, v3, Address(__ pre(d, 8 * unit)));\n-      __ ldpq(v2, v3, Address(__ pre(s, 8 * unit)));\n+      bs.copy_store_at_32(Address(d, 4 * unit), v0, v1);\n+      bs.copy_load_at_32(v0, v1, Address(s, 4 * unit));\n+      bs.copy_store_at_32(Address(__ pre(d, 8 * unit)), v2, v3);\n+      bs.copy_load_at_32(v2, v3, Address(__ pre(s, 8 * unit)));\n@@ -809,8 +885,8 @@\n-      __ stp(t0, t1, Address(d, 2 * unit));\n-      __ ldp(t0, t1, Address(s, 2 * unit));\n-      __ stp(t2, t3, Address(d, 4 * unit));\n-      __ ldp(t2, t3, Address(s, 4 * unit));\n-      __ stp(t4, t5, Address(d, 6 * unit));\n-      __ ldp(t4, t5, Address(s, 6 * unit));\n-      __ stp(t6, t7, Address(__ pre(d, 8 * unit)));\n-      __ ldp(t6, t7, Address(__ pre(s, 8 * unit)));\n+      bs.copy_store_at_16(Address(d, 2 * unit), t0, t1);\n+      bs.copy_load_at_16(t0, t1, Address(s, 2 * unit));\n+      bs.copy_store_at_16(Address(d, 4 * unit), t2, t3);\n+      bs.copy_load_at_16(t2, t3, Address(s, 4 * unit));\n+      bs.copy_store_at_16(Address(d, 6 * unit), t4, t5);\n+      bs.copy_load_at_16(t4, t5, Address(s, 6 * unit));\n+      bs.copy_store_at_16(Address(__ pre(d, 8 * unit)), t6, t7);\n+      bs.copy_load_at_16(t6, t7, Address(__ pre(s, 8 * unit)));\n@@ -825,2 +901,2 @@\n-      __ stpq(v0, v1, Address(d, 4 * unit));\n-      __ stpq(v2, v3, Address(__ pre(d, 8 * unit)));\n+      bs.copy_store_at_32(Address(d, 4 * unit), v0, v1);\n+      bs.copy_store_at_32(Address(__ pre(d, 8 * unit)), v2, v3);\n@@ -828,4 +904,4 @@\n-      __ stp(t0, t1, Address(d, 2 * unit));\n-      __ stp(t2, t3, Address(d, 4 * unit));\n-      __ stp(t4, t5, Address(d, 6 * unit));\n-      __ stp(t6, t7, Address(__ pre(d, 8 * unit)));\n+      bs.copy_store_at_16(Address(d, 2 * unit), t0, t1);\n+      bs.copy_store_at_16(Address(d, 4 * unit), t2, t3);\n+      bs.copy_store_at_16(Address(d, 6 * unit), t4, t5);\n+      bs.copy_store_at_16(Address(__ pre(d, 8 * unit)), t6, t7);\n@@ -838,2 +914,2 @@\n-        __ ldpq(v0, v1, Address(__ pre(s, 4 * unit)));\n-        __ stpq(v0, v1, Address(__ pre(d, 4 * unit)));\n+        bs.copy_load_at_32(v0, v1, Address(__ pre(s, 4 * unit)));\n+        bs.copy_store_at_32(Address(__ pre(d, 4 * unit)), v0, v1);\n@@ -841,4 +917,4 @@\n-        __ ldp(t0, t1, Address(s, 2 * unit));\n-        __ ldp(t2, t3, Address(__ pre(s, 4 * unit)));\n-        __ stp(t0, t1, Address(d, 2 * unit));\n-        __ stp(t2, t3, Address(__ pre(d, 4 * unit)));\n+        bs.copy_load_at_16(t0, t1, Address(s, 2 * unit));\n+        bs.copy_load_at_16(t2, t3, Address(__ pre(s, 4 * unit)));\n+        bs.copy_store_at_16(Address(d, 2 * unit), t0, t1);\n+        bs.copy_store_at_16(Address(__ pre(d, 4 * unit)), t2, t3);\n@@ -854,2 +930,2 @@\n-      __ ldp(t0, t1, Address(__ adjust(s, 2 * unit, direction == copy_backwards)));\n-      __ stp(t0, t1, Address(__ adjust(d, 2 * unit, direction == copy_backwards)));\n+      bs.copy_load_at_16(t0, t1, Address(__ adjust(s, 2 * unit, direction == copy_backwards)));\n+      bs.copy_store_at_16(Address(__ adjust(d, 2 * unit, direction == copy_backwards)), t0, t1);\n@@ -914,4 +990,4 @@\n-      __ ldp(t0, t1, Address(s, 2 * unit));\n-      __ ldp(t2, t3, Address(s, 4 * unit));\n-      __ ldp(t4, t5, Address(s, 6 * unit));\n-      __ ldp(t6, t7, Address(__ pre(s, 8 * unit)));\n+      bs.copy_load_at_16(t0, t1, Address(s, 2 * unit));\n+      bs.copy_load_at_16(t2, t3, Address(s, 4 * unit));\n+      bs.copy_load_at_16(t4, t5, Address(s, 6 * unit));\n+      bs.copy_load_at_16(t6, t7, Address(__ pre(s, 8 * unit)));\n@@ -946,9 +1022,9 @@\n-        __ str(t0, Address(d, 1 * unit));\n-        __ stp(t1, t2, Address(d, 2 * unit));\n-        __ ldp(t0, t1, Address(s, 2 * unit));\n-        __ stp(t3, t4, Address(d, 4 * unit));\n-        __ ldp(t2, t3, Address(s, 4 * unit));\n-        __ stp(t5, t6, Address(d, 6 * unit));\n-        __ ldp(t4, t5, Address(s, 6 * unit));\n-        __ str(t7, Address(__ pre(d, 8 * unit)));\n-        __ ldp(t6, t7, Address(__ pre(s, 8 * unit)));\n+        bs.copy_store_at_8(Address(d, 1 * unit), t0);\n+        bs.copy_store_at_16(Address(d, 2 * unit), t1, t2);\n+        bs.copy_load_at_16(t0, t1, Address(s, 2 * unit));\n+        bs.copy_store_at_16(Address(d, 4 * unit), t3, t4);\n+        bs.copy_load_at_16(t2, t3, Address(s, 4 * unit));\n+        bs.copy_store_at_16(Address(d, 6 * unit), t5, t6);\n+        bs.copy_load_at_16(t4, t5, Address(s, 6 * unit));\n+        bs.copy_store_at_8(Address(__ pre(d, 8 * unit)), t7);\n+        bs.copy_load_at_16(t6, t7, Address(__ pre(s, 8 * unit)));\n@@ -969,9 +1045,9 @@\n-        __ str(t1, Address(d, 1 * unit));\n-        __ stp(t3, t0, Address(d, 3 * unit));\n-        __ ldp(t0, t1, Address(s, 2 * unit));\n-        __ stp(t5, t2, Address(d, 5 * unit));\n-        __ ldp(t2, t3, Address(s, 4 * unit));\n-        __ stp(t7, t4, Address(d, 7 * unit));\n-        __ ldp(t4, t5, Address(s, 6 * unit));\n-        __ str(t6, Address(__ pre(d, 8 * unit)));\n-        __ ldp(t6, t7, Address(__ pre(s, 8 * unit)));\n+        bs.copy_store_at_8(Address(d, 1 * unit), t1);\n+        bs.copy_store_at_16(Address(d, 3 * unit), t3, t0);\n+        bs.copy_load_at_16(t0, t1, Address(s, 2 * unit));\n+        bs.copy_store_at_16(Address(d, 5 * unit), t5, t2);\n+        bs.copy_load_at_16(t2, t3, Address(s, 4 * unit));\n+        bs.copy_store_at_16(Address(d, 7 * unit), t7, t4);\n+        bs.copy_load_at_16(t4, t5, Address(s, 6 * unit));\n+        bs.copy_store_at_8(Address(__ pre(d, 8 * unit)), t6);\n+        bs.copy_load_at_16(t6, t7, Address(__ pre(s, 8 * unit)));\n@@ -989,5 +1065,5 @@\n-        __ str(t0, Address(d, 1 * unit));\n-        __ stp(t1, t2, Address(d, 2 * unit));\n-        __ stp(t3, t4, Address(d, 4 * unit));\n-        __ stp(t5, t6, Address(d, 6 * unit));\n-        __ str(t7, Address(__ pre(d, 8 * unit)));\n+        bs.copy_store_at_8(Address(d, 1 * unit), t0);\n+        bs.copy_store_at_16(Address(d, 2 * unit), t1, t2);\n+        bs.copy_store_at_16(Address(d, 4 * unit), t3, t4);\n+        bs.copy_store_at_16(Address(d, 6 * unit), t5, t6);\n+        bs.copy_store_at_8(Address(__ pre(d, 8 * unit)), t7);\n@@ -995,5 +1071,5 @@\n-        __ str(t1, Address(d, 1 * unit));\n-        __ stp(t3, t0, Address(d, 3 * unit));\n-        __ stp(t5, t2, Address(d, 5 * unit));\n-        __ stp(t7, t4, Address(d, 7 * unit));\n-        __ str(t6, Address(__ pre(d, 8 * unit)));\n+        bs.copy_store_at_8(Address(d, 1 * unit), t1);\n+        bs.copy_store_at_16(Address(d, 3 * unit), t3, t0);\n+        bs.copy_store_at_16(Address(d, 5 * unit), t5, t2);\n+        bs.copy_store_at_16(Address(d, 7 * unit), t7, t4);\n+        bs.copy_store_at_8(Address(__ pre(d, 8 * unit)), t6);\n@@ -1012,2 +1088,2 @@\n-        __ ldp(t0, t1, Address(s, 2 * unit));\n-        __ ldp(t2, t3, Address(__ pre(s, 4 * unit)));\n+        bs.copy_load_at_16(t0, t1, Address(s, 2 * unit));\n+        bs.copy_load_at_16(t2, t3, Address(__ pre(s, 4 * unit)));\n@@ -1015,3 +1091,3 @@\n-          __ str(t0, Address(d, 1 * unit));\n-          __ stp(t1, t2, Address(d, 2 * unit));\n-          __ str(t3, Address(__ pre(d, 4 * unit)));\n+          bs.copy_store_at_8(Address(d, 1 * unit), t0);\n+          bs.copy_store_at_16(Address(d, 2 * unit), t1, t2);\n+          bs.copy_store_at_8(Address(__ pre(d, 4 * unit)), t3);\n@@ -1019,3 +1095,3 @@\n-          __ str(t1, Address(d, 1 * unit));\n-          __ stp(t3, t0, Address(d, 3 * unit));\n-          __ str(t2, Address(__ pre(d, 4 * unit)));\n+          bs.copy_store_at_8(Address(d, 1 * unit), t1);\n+          bs.copy_store_at_16(Address(d, 3 * unit), t3, t0);\n+          bs.copy_store_at_8(Address(__ pre(d, 4 * unit)), t2);\n@@ -1030,1 +1106,1 @@\n-        __ ldp(t0, t1, Address(__ pre(s, 2 * unit)));\n+        bs.copy_load_at_16(t0, t1, Address(__ pre(s, 2 * unit)));\n@@ -1032,2 +1108,2 @@\n-          __ str(t0, Address(d, 1 * unit));\n-          __ str(t1, Address(__ pre(d, 2 * unit)));\n+          bs.copy_store_at_8(Address(d, 1 * unit), t0);\n+          bs.copy_store_at_8(Address(__ pre(d, 2 * unit)), t1);\n@@ -1035,2 +1111,2 @@\n-          __ str(t1, Address(d, 1 * unit));\n-          __ str(t0, Address(__ pre(d, 2 * unit)));\n+          bs.copy_store_at_8(Address(d, 1 * unit), t1);\n+          bs.copy_store_at_8(Address(__ pre(d, 2 * unit)), t0);\n@@ -1059,1 +1135,1 @@\n-  void copy_memory_small(Register s, Register d, Register count, Register tmp, int step) {\n+  void copy_memory_small(DecoratorSet decorators, BasicType type, Register s, Register d, Register count, int step) {\n@@ -1063,1 +1139,0 @@\n-    int unit = wordSize * direction;\n@@ -1070,1 +1145,3 @@\n-    const Register t0 = r3, t1 = r4, t2 = r5, t3 = r6;\n+    const Register t0 = r3;\n+    const Register gct1 = rscratch1, gct2 = rscratch2, gct3 = r10;\n+    ArrayCopyBarrierSetHelper bs(_masm, decorators, type, gct1, gct2, gct3, fnoreg, fnoreg, fnoreg);\n@@ -1078,2 +1155,2 @@\n-    __ ldr(tmp, Address(__ adjust(s, unit, is_backwards)));\n-    __ str(tmp, Address(__ adjust(d, unit, is_backwards)));\n+    bs.copy_load_at_8(t0, Address(__ adjust(s, direction * wordSize, is_backwards)));\n+    bs.copy_store_at_8(Address(__ adjust(d, direction * wordSize, is_backwards)), t0);\n@@ -1084,2 +1161,2 @@\n-      __ ldrw(tmp, Address(__ adjust(s, sizeof (jint) * direction, is_backwards)));\n-      __ strw(tmp, Address(__ adjust(d, sizeof (jint) * direction, is_backwards)));\n+      __ ldrw(t0, Address(__ adjust(s, sizeof (jint) * direction, is_backwards)));\n+      __ strw(t0, Address(__ adjust(d, sizeof (jint) * direction, is_backwards)));\n@@ -1091,2 +1168,2 @@\n-      __ ldrh(tmp, Address(__ adjust(s, sizeof (jshort) * direction, is_backwards)));\n-      __ strh(tmp, Address(__ adjust(d, sizeof (jshort) * direction, is_backwards)));\n+      __ ldrh(t0, Address(__ adjust(s, sizeof (jshort) * direction, is_backwards)));\n+      __ strh(t0, Address(__ adjust(d, sizeof (jshort) * direction, is_backwards)));\n@@ -1098,2 +1175,2 @@\n-      __ ldrb(tmp, Address(__ adjust(s, sizeof (jbyte) * direction, is_backwards)));\n-      __ strb(tmp, Address(__ adjust(d, sizeof (jbyte) * direction, is_backwards)));\n+      __ ldrb(t0, Address(__ adjust(s, sizeof (jbyte) * direction, is_backwards)));\n+      __ strb(t0, Address(__ adjust(d, sizeof (jbyte) * direction, is_backwards)));\n@@ -1105,0 +1182,2 @@\n+  Label copy_obj_f, copy_obj_b;\n+  Label copy_obj_uninit_f, copy_obj_uninit_b;\n@@ -1113,2 +1192,2 @@\n-  void copy_memory(bool is_aligned, Register s, Register d,\n-                   Register count, Register tmp, int step) {\n+  void copy_memory(DecoratorSet decorators, BasicType type, bool is_aligned,\n+                   Register s, Register d, Register count, int step) {\n@@ -1123,2 +1202,2 @@\n-    const Register t2 = r5, t3 = r6, t4 = r7, t5 = r8;\n-    const Register t6 = r9, t7 = r10, t8 = r11, t9 = r12;\n+    const Register t2 = r5, t3 = r6, t4 = r7, t5 = r11;\n+    const Register t6 = r12, t7 = r13, t8 = r14, t9 = r15;\n@@ -1126,0 +1205,3 @@\n+    const Register gct1 = rscratch1, gct2 = rscratch2, gct3 = r10;\n+    const FloatRegister gcvt1 = v6, gcvt2 = v7, gcvt3 = v8;\n+    ArrayCopyBarrierSetHelper bs(_masm, decorators, type, gct1, gct2, gct3, gcvt1, gcvt2, gcvt3);\n@@ -1146,4 +1228,4 @@\n-      __ ldpq(v0, v1, Address(s, 0));\n-      __ ldpq(v2, v3, Address(send, -32));\n-      __ stpq(v0, v1, Address(d, 0));\n-      __ stpq(v2, v3, Address(dend, -32));\n+      bs.copy_load_at_32(v0, v1, Address(s, 0));\n+      bs.copy_load_at_32(v2, v3, Address(send, -32));\n+      bs.copy_store_at_32(Address(d, 0), v0, v1);\n+      bs.copy_store_at_32(Address(dend, -32), v2, v3);\n@@ -1151,9 +1233,9 @@\n-      __ ldp(t0, t1, Address(s, 0));\n-      __ ldp(t2, t3, Address(s, 16));\n-      __ ldp(t4, t5, Address(send, -32));\n-      __ ldp(t6, t7, Address(send, -16));\n-\n-      __ stp(t0, t1, Address(d, 0));\n-      __ stp(t2, t3, Address(d, 16));\n-      __ stp(t4, t5, Address(dend, -32));\n-      __ stp(t6, t7, Address(dend, -16));\n+      bs.copy_load_at_16(t0, t1, Address(s, 0));\n+      bs.copy_load_at_16(t2, t3, Address(s, 16));\n+      bs.copy_load_at_16(t4, t5, Address(send, -32));\n+      bs.copy_load_at_16(t6, t7, Address(send, -16));\n+\n+      bs.copy_store_at_16(Address(d, 0), t0, t1);\n+      bs.copy_store_at_16(Address(d, 16), t2, t3);\n+      bs.copy_store_at_16(Address(dend, -32), t4, t5);\n+      bs.copy_store_at_16(Address(dend, -16), t6, t7);\n@@ -1165,4 +1247,5 @@\n-    __ ldp(t0, t1, Address(s, 0));\n-    __ ldp(t2, t3, Address(send, -16));\n-    __ stp(t0, t1, Address(d, 0));\n-    __ stp(t2, t3, Address(dend, -16));\n+    bs.copy_load_at_16(t0, t1, Address(s, 0));\n+    bs.copy_load_at_16(t6, t7, Address(send, -16));\n+\n+    bs.copy_store_at_16(Address(d, 0), t0, t1);\n+    bs.copy_store_at_16(Address(dend, -16), t6, t7);\n@@ -1175,2 +1258,2 @@\n-      __ ldpq(v0, v1, Address(s, 0));\n-      __ ldpq(v2, v3, Address(s, 32));\n+      bs.copy_load_at_32(v0, v1, Address(s, 0));\n+      bs.copy_load_at_32(v2, v3, Address(s, 32));\n@@ -1188,1 +1271,4 @@\n-        __ ldp(t0, t1, Address(send, -16));\n+        bs.copy_load_at_16(t0, t1, Address(send, -16));\n+\n+        bs.copy_store_at_32(Address(d, 0), v0, v1);\n+        bs.copy_store_at_32(Address(d, 32), v2, v3);\n@@ -1190,3 +1276,1 @@\n-        __ stpq(v0, v1, Address(d, 0));\n-        __ stpq(v2, v3, Address(d, 32));\n-        __ stp(t0, t1, Address(dend, -16));\n+        bs.copy_store_at_16(Address(dend, -16), t0, t1);\n@@ -1197,1 +1281,1 @@\n-      __ ldpq(v4, v5, Address(send, -32));\n+      bs.copy_load_at_32(v4, v5, Address(send, -32));\n@@ -1199,3 +1283,4 @@\n-      __ stpq(v0, v1, Address(d, 0));\n-      __ stpq(v2, v3, Address(d, 32));\n-      __ stpq(v4, v5, Address(dend, -32));\n+      bs.copy_store_at_32(Address(d, 0), v0, v1);\n+      bs.copy_store_at_32(Address(d, 32), v2, v3);\n+\n+      bs.copy_store_at_32(Address(dend, -32), v4, v5);\n@@ -1203,11 +1288,11 @@\n-      __ ldp(t0, t1, Address(s, 0));\n-      __ ldp(t2, t3, Address(s, 16));\n-      __ ldp(t4, t5, Address(s, 32));\n-      __ ldp(t6, t7, Address(s, 48));\n-      __ ldp(t8, t9, Address(send, -16));\n-\n-      __ stp(t0, t1, Address(d, 0));\n-      __ stp(t2, t3, Address(d, 16));\n-      __ stp(t4, t5, Address(d, 32));\n-      __ stp(t6, t7, Address(d, 48));\n-      __ stp(t8, t9, Address(dend, -16));\n+      bs.copy_load_at_16(t0, t1, Address(s, 0));\n+      bs.copy_load_at_16(t2, t3, Address(s, 16));\n+      bs.copy_load_at_16(t4, t5, Address(s, 32));\n+      bs.copy_load_at_16(t6, t7, Address(s, 48));\n+      bs.copy_load_at_16(t8, t9, Address(send, -16));\n+\n+      bs.copy_store_at_16(Address(d, 0), t0, t1);\n+      bs.copy_store_at_16(Address(d, 16), t2, t3);\n+      bs.copy_store_at_16(Address(d, 32), t4, t5);\n+      bs.copy_store_at_16(Address(d, 48), t6, t7);\n+      bs.copy_store_at_16(Address(dend, -16), t8, t9);\n@@ -1223,4 +1308,4 @@\n-    __ ldr(t0, Address(s, 0));\n-    __ ldr(t1, Address(send, -8));\n-    __ str(t0, Address(d, 0));\n-    __ str(t1, Address(dend, -8));\n+    bs.copy_load_at_8(t0, Address(s, 0));\n+    bs.copy_load_at_8(t1, Address(send, -8));\n+    bs.copy_store_at_8(Address(d, 0), t0);\n+    bs.copy_store_at_8(Address(dend, -8), t1);\n@@ -1273,0 +1358,5 @@\n+    \/\/ Here we will materialize a count in r15, which is used by copy_memory_small\n+    \/\/ and the various generate_copy_longs stubs that we use for 2 word aligned bytes.\n+    \/\/ Up until here, we have used t9, which aliases r15, but from here on, that register\n+    \/\/ can not be used as a temp register, as it contains the count.\n+\n@@ -1278,2 +1368,2 @@\n-      __ ldr(tmp, Address(__ adjust(s, direction * wordSize, is_backwards)));\n-      __ str(tmp, Address(__ adjust(d, direction * wordSize, is_backwards)));\n+      bs.copy_load_at_8(t0, Address(__ adjust(s, direction * wordSize, is_backwards)));\n+      bs.copy_store_at_8(Address(__ adjust(d, direction * wordSize, is_backwards)), t0);\n@@ -1283,1 +1373,1 @@\n-        __ andr(rscratch2, s, 2 * wordSize - 1);\n+        __ andr(r15, s, 2 * wordSize - 1);\n@@ -1285,2 +1375,2 @@\n-        __ neg(rscratch2, s);\n-        __ andr(rscratch2, rscratch2, 2 * wordSize - 1);\n+        __ neg(r15, s);\n+        __ andr(r15, r15, 2 * wordSize - 1);\n@@ -1288,2 +1378,2 @@\n-      \/\/ rscratch2 is the byte adjustment needed to align s.\n-      __ cbz(rscratch2, aligned);\n+      \/\/ r15 is the byte adjustment needed to align s.\n+      __ cbz(r15, aligned);\n@@ -1291,2 +1381,2 @@\n-      if (shift)  __ lsr(rscratch2, rscratch2, shift);\n-      __ sub(count, count, rscratch2);\n+      if (shift)  __ lsr(r15, r15, shift);\n+      __ sub(count, count, r15);\n@@ -1304,2 +1394,2 @@\n-        __ sub(s, s, rscratch2);\n-        __ sub(d, d, rscratch2);\n+        __ sub(s, s, r15);\n+        __ sub(d, d, r15);\n@@ -1307,2 +1397,2 @@\n-        __ add(s, s, rscratch2);\n-        __ add(d, d, rscratch2);\n+        __ add(s, s, r15);\n+        __ add(d, d, r15);\n@@ -1311,1 +1401,1 @@\n-      copy_memory_small(s, d, rscratch2, rscratch1, step);\n+      copy_memory_small(decorators, type, s, d, r15, step);\n@@ -1321,5 +1411,18 @@\n-    __ lsr(rscratch2, count, exact_log2(wordSize\/granularity));\n-    if (direction == copy_forwards)\n-      __ bl(copy_f);\n-    else\n-      __ bl(copy_b);\n+    __ lsr(r15, count, exact_log2(wordSize\/granularity));\n+    if (direction == copy_forwards) {\n+      if (type != T_OBJECT) {\n+        __ bl(copy_f);\n+      } else if ((decorators & IS_DEST_UNINITIALIZED) != 0) {\n+        __ bl(copy_obj_uninit_f);\n+      } else {\n+        __ bl(copy_obj_f);\n+      }\n+    } else {\n+      if (type != T_OBJECT) {\n+        __ bl(copy_b);\n+      } else if ((decorators & IS_DEST_UNINITIALIZED) != 0) {\n+        __ bl(copy_obj_uninit_b);\n+      } else {\n+        __ bl(copy_obj_b);\n+      }\n+    }\n@@ -1328,1 +1431,1 @@\n-    copy_memory_small(s, d, count, tmp, step);\n+    copy_memory_small(decorators, type, s, d, count, step);\n@@ -1423,1 +1526,1 @@\n-      copy_memory(aligned, s, d, count, rscratch1, size);\n+      copy_memory(decorators, is_oop ? T_OBJECT : T_BYTE, aligned, s, d, count, size);\n@@ -1494,1 +1597,1 @@\n-      copy_memory(aligned, s, d, count, rscratch1, -size);\n+      copy_memory(decorators, is_oop ? T_OBJECT : T_BYTE, aligned, s, d, count, -size);\n@@ -1785,0 +1888,3 @@\n+    \/\/ Registers used as gc temps (r5, r6, r7 are save-on-call)\n+    const Register gct1 = r5, gct2 = r6, gct3 = r7;\n+\n@@ -1837,0 +1943,1 @@\n+    int element_size = UseCompressedOops ? 4 : 8;\n@@ -1862,1 +1969,3 @@\n-    __ store_heap_oop(__ post(to, UseCompressedOops ? 4 : 8), copied_oop, noreg, noreg, noreg, AS_RAW);  \/\/ store the oop\n+    bs->copy_store_at(_masm, decorators, T_OBJECT, element_size,\n+                      __ post(to, element_size), copied_oop, noreg,\n+                      gct1, gct2, gct3);\n@@ -1868,1 +1977,3 @@\n-    __ load_heap_oop(copied_oop, __ post(from, UseCompressedOops ? 4 : 8), noreg, noreg, AS_RAW); \/\/ load the oop\n+    bs->copy_load_at(_masm, decorators, T_OBJECT, element_size,\n+                     copied_oop, noreg, __ post(from, element_size),\n+                     gct1);\n@@ -2473,2 +2584,8 @@\n-    generate_copy_longs(copy_f, r0, r1, rscratch2, copy_forwards);\n-    generate_copy_longs(copy_b, r0, r1, rscratch2, copy_backwards);\n+    generate_copy_longs(IN_HEAP | IS_ARRAY, T_BYTE, copy_f, r0, r1, r15, copy_forwards);\n+    generate_copy_longs(IN_HEAP | IS_ARRAY, T_BYTE, copy_b, r0, r1, r15, copy_backwards);\n+\n+    generate_copy_longs(IN_HEAP | IS_ARRAY, T_OBJECT, copy_obj_f, r0, r1, r15, copy_forwards);\n+    generate_copy_longs(IN_HEAP | IS_ARRAY, T_OBJECT, copy_obj_b, r0, r1, r15, copy_backwards);\n+\n+    generate_copy_longs(IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, T_OBJECT, copy_obj_uninit_f, r0, r1, r15, copy_forwards);\n+    generate_copy_longs(IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, T_OBJECT, copy_obj_uninit_b, r0, r1, r15, copy_backwards);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":282,"deletions":165,"binary":false,"changes":447,"status":"modified"},{"patch":"@@ -3532,2 +3532,1 @@\n-  __ null_check(recv, oopDesc::klass_offset_in_bytes());\n-  __ load_klass(r0, recv);\n+  __ load_klass_check_null(r0, recv);\n@@ -3622,2 +3621,1 @@\n-  __ null_check(r2, oopDesc::klass_offset_in_bytes());\n-  __ load_klass(r3, r2);\n+  __ load_klass_check_null(r3, r2);\n@@ -3639,2 +3637,1 @@\n-  __ null_check(r2, oopDesc::klass_offset_in_bytes());\n-  __ load_klass(r3, r2);\n+  __ load_klass_check_null(r3, r2);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,1 +203,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -243,1 +243,1 @@\n-  MonitorExitStub* stub = NULL;\n+  MonitorExitStub* stub = nullptr;\n@@ -256,1 +256,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -266,1 +266,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -405,1 +405,1 @@\n-  assert((src->as_constant_ptr()->type() == T_OBJECT && src->as_constant_ptr()->as_jobject() == NULL),\"cannot handle otherwise\");\n+  assert((src->as_constant_ptr()->type() == T_OBJECT && src->as_constant_ptr()->as_jobject() == nullptr),\"cannot handle otherwise\");\n@@ -411,1 +411,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -499,1 +499,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -550,1 +550,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -559,1 +559,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -568,1 +568,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -608,1 +608,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -612,1 +612,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -701,1 +701,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -705,1 +705,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -759,1 +759,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -768,1 +768,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -777,1 +777,1 @@\n-        if (patch != NULL) {\n+        if (patch != nullptr) {\n@@ -817,1 +817,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -864,4 +864,4 @@\n-  assert(op->block() == NULL || op->block()->label() == op->label(), \"wrong label\");\n-  if (op->block() != NULL)  _branch_target_blocks.append(op->block());\n-  if (op->ublock() != NULL) _branch_target_blocks.append(op->ublock());\n-  assert(op->info() == NULL, \"CodeEmitInfo?\");\n+  assert(op->block() == nullptr || op->block()->label() == op->label(), \"wrong label\");\n+  if (op->block() != nullptr)  _branch_target_blocks.append(op->block());\n+  if (op->ublock() != nullptr) _branch_target_blocks.append(op->ublock());\n+  assert(op->info() == nullptr, \"CodeEmitInfo?\");\n@@ -1024,1 +1024,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -1026,1 +1026,1 @@\n-  assert(data != NULL,       \"need data for checkcast\");\n+  assert(data != nullptr,       \"need data for checkcast\");\n@@ -1039,1 +1039,1 @@\n-  assert(method != NULL, \"Should have method\");\n+  assert(method != nullptr, \"Should have method\");\n@@ -1514,1 +1514,1 @@\n-  assert(info == NULL, \"unused on this code path\");\n+  assert(info == nullptr, \"unused on this code path\");\n@@ -1791,1 +1791,1 @@\n-          assert(opr2->as_constant_ptr()->as_jobject() == NULL, \"cannot handle otherwise\");\n+          assert(opr2->as_constant_ptr()->as_jobject() == nullptr, \"cannot handle otherwise\");\n@@ -1796,1 +1796,1 @@\n-          assert(opr2->as_constant_ptr()->as_metadata() == NULL, \"cannot handle otherwise\");\n+          assert(opr2->as_constant_ptr()->as_metadata() == nullptr, \"cannot handle otherwise\");\n@@ -1944,1 +1944,1 @@\n-  if (stub == NULL) {\n+  if (stub == nullptr) {\n@@ -1950,1 +1950,1 @@\n-  InlinedMetadata metadata_literal(NULL);\n+  InlinedMetadata metadata_literal(nullptr);\n@@ -2104,1 +2104,1 @@\n-  BasicType basic_type = default_type != NULL ? default_type->element_type()->basic_type() : T_ILLEGAL;\n+  BasicType basic_type = default_type != nullptr ? default_type->element_type()->basic_type() : T_ILLEGAL;\n@@ -2108,1 +2108,1 @@\n-  if (default_type == NULL) {\n+  if (default_type == nullptr) {\n@@ -2117,1 +2117,1 @@\n-    assert(copyfunc_addr != NULL, \"generic arraycopy stub required\");\n+    assert(copyfunc_addr != nullptr, \"generic arraycopy stub required\");\n@@ -2142,1 +2142,1 @@\n-  assert(default_type != NULL && default_type->is_array_klass() && default_type->is_loaded(),\n+  assert(default_type != nullptr && default_type->is_array_klass() && default_type->is_loaded(),\n@@ -2147,1 +2147,1 @@\n-  \/\/ Check for NULL\n+  \/\/ Check for null\n@@ -2255,1 +2255,1 @@\n-      __ check_klass_subtype_fast_path(tmp, tmp2, R6, altFP_7_11, &cont, copyfunc_addr == NULL ? stub->entry() : &slow, NULL);\n+      __ check_klass_subtype_fast_path(tmp, tmp2, R6, altFP_7_11, &cont, copyfunc_addr == nullptr ? stub->entry() : &slow, nullptr);\n@@ -2266,1 +2266,1 @@\n-      if (copyfunc_addr != NULL) { \/\/ use stub if available\n+      if (copyfunc_addr != nullptr) { \/\/ use stub if available\n@@ -2435,1 +2435,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2443,1 +2443,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -2459,1 +2459,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2477,1 +2477,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -2479,1 +2479,1 @@\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for calls\");\n+  assert(data != nullptr && data->is_CounterData(), \"need CounterData for calls\");\n@@ -2505,1 +2505,1 @@\n-    if (C1OptimizeVirtualCallProfiling && known_klass != NULL) {\n+    if (C1OptimizeVirtualCallProfiling && known_klass != nullptr) {\n@@ -2534,1 +2534,1 @@\n-        if (receiver == NULL) {\n+        if (receiver == nullptr) {\n@@ -2641,1 +2641,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2686,1 +2686,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2753,1 +2753,1 @@\n-        assert(cmp != NULL, \"cmp LIR instruction is not an op2\");\n+        assert(cmp != nullptr, \"cmp LIR instruction is not an op2\");\n@@ -2757,1 +2757,1 @@\n-          if (cmove != NULL && cmove->code() == lir_cmove) {\n+          if (cmove != nullptr && cmove->code() == lir_cmove) {\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -58,0 +58,5 @@\n+void InterpreterMacroAssembler::load_klass_check_null_throw(Register dst, Register src, Register temp_reg) {\n+  null_check_throw(src, oopDesc::klass_offset_in_bytes(), temp_reg);\n+  load_klass(dst, src);\n+}\n+\n@@ -893,1 +898,0 @@\n-  verify_thread();\n@@ -1132,1 +1136,0 @@\n-    verify_thread();\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,0 @@\n-  \/\/ verify_thread(); \/\/ Too slow. We will just verify on method entry & exit.\n@@ -957,1 +956,0 @@\n-  verify_thread();\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,12 +120,0 @@\n-RangeCheckStub::RangeCheckStub(CodeEmitInfo* info, LIR_Opr index, LIR_Opr array)\n-  : _index(index), _array(array), _throw_index_out_of_bounds_exception(false) {\n-  assert(info != NULL, \"must have info\");\n-  _info = new CodeEmitInfo(info);\n-}\n-\n-RangeCheckStub::RangeCheckStub(CodeEmitInfo* info, LIR_Opr index)\n-  : _index(index), _array(), _throw_index_out_of_bounds_exception(true) {\n-  assert(info != NULL, \"must have info\");\n-  _info = new CodeEmitInfo(info);\n-}\n-\n@@ -338,15 +326,0 @@\n-\n-\/\/ Implementation of MonitorAccessStubs\n-\n-MonitorEnterStub::MonitorEnterStub(LIR_Opr obj_reg, LIR_Opr lock_reg, CodeEmitInfo* info, CodeStub* throw_imse_stub, LIR_Opr scratch_reg)\n-: MonitorAccessStub(obj_reg, lock_reg)\n-{\n-  _info = new CodeEmitInfo(info);\n-  _throw_imse_stub = throw_imse_stub;\n-  _scratch_reg = scratch_reg;\n-  if (_throw_imse_stub != NULL) {\n-    assert(_scratch_reg != LIR_OprFact::illegalOpr, \"must be\");\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -71,2 +71,5 @@\n-  \/\/ unextended sp must be within the stack and above or equal sp\n-  if (!thread->is_in_stack_range_incl(unextended_sp, sp)) {\n+  \/\/ unextended sp must be within the stack\n+  \/\/ Note: sp can be greater than unextended_sp in the case of\n+  \/\/ interpreted -> interpreted calls that go through a method handle linker,\n+  \/\/ since those pop the last argument (the appendix) from the stack.\n+  if (!thread->is_in_stack_range_incl(unextended_sp, sp - Interpreter::stackElementSize)) {\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -215,0 +215,107 @@\n+void BarrierSetAssembler::copy_load_at(MacroAssembler* masm,\n+                                       DecoratorSet decorators,\n+                                       BasicType type,\n+                                       size_t bytes,\n+                                       Register dst,\n+                                       Address src,\n+                                       Register tmp) {\n+  assert(bytes <= 8, \"can only deal with non-vector registers\");\n+  switch (bytes) {\n+  case 1:\n+    __ movb(dst, src);\n+    break;\n+  case 2:\n+    __ movw(dst, src);\n+    break;\n+  case 4:\n+    __ movl(dst, src);\n+    break;\n+  case 8:\n+#ifdef _LP64\n+    __ movq(dst, src);\n+#else\n+    fatal(\"No support for 8 bytes copy\");\n+#endif\n+    break;\n+  default:\n+    fatal(\"Unexpected size\");\n+  }\n+#ifdef _LP64\n+  if ((decorators & ARRAYCOPY_CHECKCAST) != 0 && UseCompressedOops) {\n+    __ decode_heap_oop(dst);\n+  }\n+#endif\n+}\n+\n+void BarrierSetAssembler::copy_store_at(MacroAssembler* masm,\n+                                        DecoratorSet decorators,\n+                                        BasicType type,\n+                                        size_t bytes,\n+                                        Address dst,\n+                                        Register src,\n+                                        Register tmp) {\n+#ifdef _LP64\n+  if ((decorators & ARRAYCOPY_CHECKCAST) != 0 && UseCompressedOops) {\n+    __ encode_heap_oop(src);\n+  }\n+#endif\n+  assert(bytes <= 8, \"can only deal with non-vector registers\");\n+  switch (bytes) {\n+  case 1:\n+    __ movb(dst, src);\n+    break;\n+  case 2:\n+    __ movw(dst, src);\n+    break;\n+  case 4:\n+    __ movl(dst, src);\n+    break;\n+  case 8:\n+#ifdef _LP64\n+    __ movq(dst, src);\n+#else\n+    fatal(\"No support for 8 bytes copy\");\n+#endif\n+    break;\n+  default:\n+    fatal(\"Unexpected size\");\n+  }\n+}\n+\n+void BarrierSetAssembler::copy_load_at(MacroAssembler* masm,\n+                                       DecoratorSet decorators,\n+                                       BasicType type,\n+                                       size_t bytes,\n+                                       XMMRegister dst,\n+                                       Address src,\n+                                       Register tmp,\n+                                       XMMRegister xmm_tmp) {\n+  assert(bytes > 8, \"can only deal with vector registers\");\n+  if (bytes == 16) {\n+    __ movdqu(dst, src);\n+  } else if (bytes == 32) {\n+    __ vmovdqu(dst, src);\n+  } else {\n+    fatal(\"No support for >32 bytes copy\");\n+  }\n+}\n+\n+void BarrierSetAssembler::copy_store_at(MacroAssembler* masm,\n+                                        DecoratorSet decorators,\n+                                        BasicType type,\n+                                        size_t bytes,\n+                                        Address dst,\n+                                        XMMRegister src,\n+                                        Register tmp1,\n+                                        Register tmp2,\n+                                        XMMRegister xmm_tmp) {\n+  assert(bytes > 8, \"can only deal with vector registers\");\n+  if (bytes == 16) {\n+    __ movdqu(dst, src);\n+  } else if (bytes == 32) {\n+    __ vmovdqu(dst, src);\n+  } else {\n+    fatal(\"No support for >32 bytes copy\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":107,"deletions":0,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -55,0 +55,40 @@\n+  \/\/ The copy_[load\/store]_at functions are used by arraycopy stubs. Be careful to only use\n+  \/\/ r10 (aka rscratch1) in a context where restore_arg_regs_using_thread has been used instead\n+  \/\/ of the looser setup_arg_regs. Currently this is done when using type T_OBJECT.\n+  virtual void copy_load_at(MacroAssembler* masm,\n+                            DecoratorSet decorators,\n+                            BasicType type,\n+                            size_t bytes,\n+                            Register dst,\n+                            Address src,\n+                            Register tmp);\n+\n+  virtual void copy_store_at(MacroAssembler* masm,\n+                             DecoratorSet decorators,\n+                             BasicType type,\n+                             size_t bytes,\n+                             Address dst,\n+                             Register src,\n+                             Register tmp);\n+\n+  virtual void copy_load_at(MacroAssembler* masm,\n+                            DecoratorSet decorators,\n+                            BasicType type,\n+                            size_t bytes,\n+                            XMMRegister dst,\n+                            Address src,\n+                            Register tmp,\n+                            XMMRegister xmm_tmp);\n+\n+  virtual void copy_store_at(MacroAssembler* masm,\n+                             DecoratorSet decorators,\n+                             BasicType type,\n+                             size_t bytes,\n+                             Address dst,\n+                             XMMRegister src,\n+                             Register tmp1,\n+                             Register tmp2,\n+                             XMMRegister xmm_tmp);\n+\n+  virtual bool supports_avx3_masked_arraycopy() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -5470,0 +5470,5 @@\n+void MacroAssembler::load_klass_check_null(Register dst, Register src, Register tmp) {\n+  null_check(src, oopDesc::klass_offset_in_bytes());\n+  load_klass(dst, src, tmp);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -387,0 +387,1 @@\n+  void load_klass_check_null(Register dst, Register src, Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -386,2 +386,1 @@\n-        __ null_check(receiver_reg, oopDesc::klass_offset_in_bytes());\n-        __ load_klass(temp1_recv_klass, receiver_reg, temp2);\n+        __ load_klass_check_null(temp1_recv_klass, receiver_reg, temp2);\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1183,1 +1183,1 @@\n-  if (nargs >= 4)\n+  if (nargs == 4) {\n@@ -1185,0 +1185,1 @@\n+  }\n@@ -1190,1 +1191,1 @@\n-  if (nargs >= 4)\n+  if (nargs == 4) {\n@@ -1192,0 +1193,1 @@\n+  }\n@@ -1213,1 +1215,1 @@\n-void StubGenerator::setup_arg_regs_using_thread() {\n+void StubGenerator::setup_arg_regs_using_thread(int nargs) {\n@@ -1215,0 +1217,1 @@\n+  assert(nargs == 3 || nargs == 4, \"else fix\");\n@@ -1216,0 +1219,3 @@\n+  if (nargs == 4) {\n+    __ mov(rax, r9);       \/\/ r9 is also saved_r15\n+  }\n@@ -1226,0 +1232,3 @@\n+  if (nargs == 4) {\n+    __ mov(rcx, rax); \/\/ c_rarg3 (via rax)\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  void setup_arg_regs_using_thread();\n+  void setup_arg_regs_using_thread(int nargs = 3);\n@@ -149,2 +149,4 @@\n-                          Register qword_count, Register to,\n-                          Label& L_copy_bytes, Label& L_copy_8_bytes);\n+                          Register qword_count, Register tmp1,\n+                          Register tmp2, Label& L_copy_bytes,\n+                          Label& L_copy_8_bytes, DecoratorSet decorators,\n+                          BasicType type);\n@@ -154,2 +156,4 @@\n-                           Register qword_count, Register to,\n-                           Label& L_copy_bytes, Label& L_copy_8_bytes);\n+                           Register qword_count, Register tmp1,\n+                           Register tmp2, Label& L_copy_bytes,\n+                           Label& L_copy_8_bytes, DecoratorSet decorators,\n+                           BasicType type);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-\/\/   to           - scratch\n+\/\/   tmp1         - scratch\n@@ -239,2 +239,5 @@\n-                                       Register qword_count, Register to,\n-                                       Label& L_copy_bytes, Label& L_copy_8_bytes) {\n+                                       Register qword_count, Register tmp1,\n+                                       Register tmp2, Label& L_copy_bytes,\n+                                       Label& L_copy_8_bytes, DecoratorSet decorators,\n+                                       BasicType type) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n@@ -248,4 +251,13 @@\n-      __ vmovdqu(xmm0, Address(end_from, qword_count, Address::times_8, -56));\n-      __ vmovdqu(Address(end_to, qword_count, Address::times_8, -56), xmm0);\n-      __ vmovdqu(xmm1, Address(end_from, qword_count, Address::times_8, -24));\n-      __ vmovdqu(Address(end_to, qword_count, Address::times_8, -24), xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 32,\n+                       xmm0, Address(end_from, qword_count, Address::times_8, -56),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 32,\n+                        Address(end_to, qword_count, Address::times_8, -56), xmm0,\n+                        tmp1, tmp2, xmm1);\n+\n+      bs->copy_load_at(_masm, decorators, type, 32,\n+                       xmm0, Address(end_from, qword_count, Address::times_8, -24),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 32,\n+                        Address(end_to, qword_count, Address::times_8, -24), xmm0,\n+                        tmp1, tmp2, xmm1);\n@@ -253,8 +265,24 @@\n-      __ movdqu(xmm0, Address(end_from, qword_count, Address::times_8, -56));\n-      __ movdqu(Address(end_to, qword_count, Address::times_8, -56), xmm0);\n-      __ movdqu(xmm1, Address(end_from, qword_count, Address::times_8, -40));\n-      __ movdqu(Address(end_to, qword_count, Address::times_8, -40), xmm1);\n-      __ movdqu(xmm2, Address(end_from, qword_count, Address::times_8, -24));\n-      __ movdqu(Address(end_to, qword_count, Address::times_8, -24), xmm2);\n-      __ movdqu(xmm3, Address(end_from, qword_count, Address::times_8, - 8));\n-      __ movdqu(Address(end_to, qword_count, Address::times_8, - 8), xmm3);\n+      bs->copy_load_at(_masm, decorators, type, 16,\n+                       xmm0, Address(end_from, qword_count, Address::times_8, -56),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 16,\n+                        Address(end_to, qword_count, Address::times_8, -56), xmm0,\n+                        tmp1, tmp2, xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 16,\n+                       xmm0, Address(end_from, qword_count, Address::times_8, -40),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 16,\n+                        Address(end_to, qword_count, Address::times_8, -40), xmm0,\n+                        tmp1, tmp2, xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 16,\n+                       xmm0, Address(end_from, qword_count, Address::times_8, -24),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 16,\n+                        Address(end_to, qword_count, Address::times_8, -24), xmm0,\n+                        tmp1, tmp2, xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 16,\n+                       xmm0, Address(end_from, qword_count, Address::times_8, -8),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 16,\n+                        Address(end_to, qword_count, Address::times_8, -8), xmm0,\n+                        tmp1, tmp2, xmm1);\n@@ -267,1 +295,1 @@\n-    __ jccb(Assembler::greater, L_end);\n+    __ jcc(Assembler::greater, L_end);\n@@ -270,2 +298,6 @@\n-      __ vmovdqu(xmm0, Address(end_from, qword_count, Address::times_8, -24));\n-      __ vmovdqu(Address(end_to, qword_count, Address::times_8, -24), xmm0);\n+      bs->copy_load_at(_masm, decorators, type, 32,\n+                       xmm0, Address(end_from, qword_count, Address::times_8, -24),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 32,\n+                        Address(end_to, qword_count, Address::times_8, -24), xmm0,\n+                        tmp1, tmp2, xmm1);\n@@ -273,4 +305,12 @@\n-      __ movdqu(xmm0, Address(end_from, qword_count, Address::times_8, -24));\n-      __ movdqu(Address(end_to, qword_count, Address::times_8, -24), xmm0);\n-      __ movdqu(xmm1, Address(end_from, qword_count, Address::times_8, - 8));\n-      __ movdqu(Address(end_to, qword_count, Address::times_8, - 8), xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 16,\n+                       xmm0, Address(end_from, qword_count, Address::times_8, -24),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 16,\n+                        Address(end_to, qword_count, Address::times_8, -24), xmm0,\n+                        tmp1, tmp2, xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 16,\n+                       xmm0, Address(end_from, qword_count, Address::times_8, -8),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 16,\n+                        Address(end_to, qword_count, Address::times_8, -8), xmm0,\n+                        tmp1, tmp2, xmm1);\n@@ -283,8 +323,24 @@\n-    __ movq(to, Address(end_from, qword_count, Address::times_8, -24));\n-    __ movq(Address(end_to, qword_count, Address::times_8, -24), to);\n-    __ movq(to, Address(end_from, qword_count, Address::times_8, -16));\n-    __ movq(Address(end_to, qword_count, Address::times_8, -16), to);\n-    __ movq(to, Address(end_from, qword_count, Address::times_8, - 8));\n-    __ movq(Address(end_to, qword_count, Address::times_8, - 8), to);\n-    __ movq(to, Address(end_from, qword_count, Address::times_8, - 0));\n-    __ movq(Address(end_to, qword_count, Address::times_8, - 0), to);\n+    bs->copy_load_at(_masm, decorators, type, 8,\n+                     tmp1, Address(end_from, qword_count, Address::times_8, -24),\n+                     tmp2);\n+    bs->copy_store_at(_masm, decorators, type, 8,\n+                      Address(end_to, qword_count, Address::times_8, -24), tmp1,\n+                      tmp2);\n+    bs->copy_load_at(_masm, decorators, type, 8,\n+                     tmp1, Address(end_from, qword_count, Address::times_8, -16),\n+                     tmp2);\n+    bs->copy_store_at(_masm, decorators, type, 8,\n+                      Address(end_to, qword_count, Address::times_8, -16), tmp1,\n+                      tmp2);\n+    bs->copy_load_at(_masm, decorators, type, 8,\n+                     tmp1, Address(end_from, qword_count, Address::times_8, -8),\n+                     tmp2);\n+    bs->copy_store_at(_masm, decorators, type, 8,\n+                      Address(end_to, qword_count, Address::times_8, -8), tmp1,\n+                      tmp2);\n+    bs->copy_load_at(_masm, decorators, type, 8,\n+                     tmp1, Address(end_from, qword_count, Address::times_8, 0),\n+                     tmp2);\n+    bs->copy_store_at(_masm, decorators, type, 8,\n+                      Address(end_to, qword_count, Address::times_8, 0), tmp1,\n+                      tmp2);\n@@ -307,1 +363,1 @@\n-\/\/   to           - scratch\n+\/\/   tmp1         - scratch\n@@ -312,2 +368,5 @@\n-                                        Register qword_count, Register to,\n-                                        Label& L_copy_bytes, Label& L_copy_8_bytes) {\n+                                        Register qword_count, Register tmp1,\n+                                        Register tmp2, Label& L_copy_bytes,\n+                                        Label& L_copy_8_bytes, DecoratorSet decorators,\n+                                        BasicType type) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n@@ -321,4 +380,12 @@\n-      __ vmovdqu(xmm0, Address(from, qword_count, Address::times_8, 32));\n-      __ vmovdqu(Address(dest, qword_count, Address::times_8, 32), xmm0);\n-      __ vmovdqu(xmm1, Address(from, qword_count, Address::times_8,  0));\n-      __ vmovdqu(Address(dest, qword_count, Address::times_8,  0), xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 32,\n+                       xmm0, Address(from, qword_count, Address::times_8, 32),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 32,\n+                        Address(dest, qword_count, Address::times_8, 32), xmm0,\n+                        tmp1, tmp2, xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 32,\n+                       xmm0, Address(from, qword_count, Address::times_8, 0),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 32,\n+                        Address(dest, qword_count, Address::times_8, 0), xmm0,\n+                        tmp1, tmp2, xmm1);\n@@ -326,8 +393,24 @@\n-      __ movdqu(xmm0, Address(from, qword_count, Address::times_8, 48));\n-      __ movdqu(Address(dest, qword_count, Address::times_8, 48), xmm0);\n-      __ movdqu(xmm1, Address(from, qword_count, Address::times_8, 32));\n-      __ movdqu(Address(dest, qword_count, Address::times_8, 32), xmm1);\n-      __ movdqu(xmm2, Address(from, qword_count, Address::times_8, 16));\n-      __ movdqu(Address(dest, qword_count, Address::times_8, 16), xmm2);\n-      __ movdqu(xmm3, Address(from, qword_count, Address::times_8,  0));\n-      __ movdqu(Address(dest, qword_count, Address::times_8,  0), xmm3);\n+      bs->copy_load_at(_masm, decorators, type, 16,\n+                       xmm0, Address(from, qword_count, Address::times_8, 48),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 16,\n+                        Address(dest, qword_count, Address::times_8, 48), xmm0,\n+                        tmp1, tmp2, xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 16,\n+                       xmm0, Address(from, qword_count, Address::times_8, 32),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 16,\n+                        Address(dest, qword_count, Address::times_8, 32), xmm0,\n+                        tmp1, tmp2, xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 16,\n+                       xmm0, Address(from, qword_count, Address::times_8, 16),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 16,\n+                        Address(dest, qword_count, Address::times_8, 16), xmm0,\n+                        tmp1, tmp2, xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 16,\n+                       xmm0, Address(from, qword_count, Address::times_8, 0),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 16,\n+                        Address(dest, qword_count, Address::times_8, 0), xmm0,\n+                        tmp1, tmp2, xmm1);\n@@ -341,1 +424,1 @@\n-    __ jccb(Assembler::less, L_end);\n+    __ jcc(Assembler::less, L_end);\n@@ -344,2 +427,6 @@\n-      __ vmovdqu(xmm0, Address(from, qword_count, Address::times_8, 0));\n-      __ vmovdqu(Address(dest, qword_count, Address::times_8, 0), xmm0);\n+      bs->copy_load_at(_masm, decorators, type, 32,\n+                       xmm0, Address(from, qword_count, Address::times_8, 0),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 32,\n+                        Address(dest, qword_count, Address::times_8, 0), xmm0,\n+                        tmp1, tmp2, xmm1);\n@@ -347,4 +434,12 @@\n-      __ movdqu(xmm0, Address(from, qword_count, Address::times_8, 16));\n-      __ movdqu(Address(dest, qword_count, Address::times_8, 16), xmm0);\n-      __ movdqu(xmm1, Address(from, qword_count, Address::times_8,  0));\n-      __ movdqu(Address(dest, qword_count, Address::times_8,  0), xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 16,\n+                       xmm0, Address(from, qword_count, Address::times_8, 16),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 16,\n+                        Address(dest, qword_count, Address::times_8, 16), xmm0,\n+                        tmp1, tmp2, xmm1);\n+      bs->copy_load_at(_masm, decorators, type, 16,\n+                       xmm0, Address(from, qword_count, Address::times_8, 0),\n+                       tmp1, xmm1);\n+      bs->copy_store_at(_masm, decorators, type, 16,\n+                        Address(dest, qword_count, Address::times_8, 0), xmm0,\n+                        tmp1, tmp2, xmm1);\n@@ -357,8 +452,24 @@\n-    __ movq(to, Address(from, qword_count, Address::times_8, 24));\n-    __ movq(Address(dest, qword_count, Address::times_8, 24), to);\n-    __ movq(to, Address(from, qword_count, Address::times_8, 16));\n-    __ movq(Address(dest, qword_count, Address::times_8, 16), to);\n-    __ movq(to, Address(from, qword_count, Address::times_8,  8));\n-    __ movq(Address(dest, qword_count, Address::times_8,  8), to);\n-    __ movq(to, Address(from, qword_count, Address::times_8,  0));\n-    __ movq(Address(dest, qword_count, Address::times_8,  0), to);\n+    bs->copy_load_at(_masm, decorators, type, 8,\n+                     tmp1, Address(from, qword_count, Address::times_8, 24),\n+                     tmp2);\n+    bs->copy_store_at(_masm, decorators, type, 8,\n+                      Address(dest, qword_count, Address::times_8, 24), tmp1,\n+                      tmp2);\n+    bs->copy_load_at(_masm, decorators, type, 8,\n+                     tmp1, Address(from, qword_count, Address::times_8, 16),\n+                     tmp2);\n+    bs->copy_store_at(_masm, decorators, type, 8,\n+                      Address(dest, qword_count, Address::times_8, 16), tmp1,\n+                      tmp2);\n+    bs->copy_load_at(_masm, decorators, type, 8,\n+                     tmp1, Address(from, qword_count, Address::times_8, 8),\n+                     tmp2);\n+    bs->copy_store_at(_masm, decorators, type, 8,\n+                      Address(dest, qword_count, Address::times_8, 8), tmp1,\n+                      tmp2);\n+    bs->copy_load_at(_masm, decorators, type, 8,\n+                     tmp1, Address(from, qword_count, Address::times_8, 0),\n+                     tmp2);\n+    bs->copy_store_at(_masm, decorators, type, 8,\n+                      Address(dest, qword_count, Address::times_8, 0), tmp1,\n+                      tmp2);\n@@ -1027,0 +1138,1 @@\n+  DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_DISJOINT;\n@@ -1111,1 +1223,1 @@\n-    copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+    copy_bytes_forward(end_from, end_to, qword_count, rax, r10, L_copy_bytes, L_copy_8_bytes, decorators, T_BYTE);\n@@ -1144,0 +1256,1 @@\n+  DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n@@ -1214,1 +1327,1 @@\n-    copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+    copy_bytes_backward(from, to, qword_count, rax, r10, L_copy_bytes, L_copy_8_bytes, decorators, T_BYTE);\n@@ -1257,0 +1370,1 @@\n+  DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_DISJOINT;\n@@ -1333,1 +1447,1 @@\n-    copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+    copy_bytes_forward(end_from, end_to, qword_count, rax, r10, L_copy_bytes, L_copy_8_bytes, decorators, T_SHORT);\n@@ -1391,0 +1505,1 @@\n+  DecoratorSet decorators = IN_HEAP | IS_ARRAY;\n@@ -1453,1 +1568,1 @@\n-    copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+    copy_bytes_backward(from, to, qword_count, rax, r10, L_copy_bytes, L_copy_8_bytes, decorators, T_SHORT);\n@@ -1487,0 +1602,1 @@\n+  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n@@ -1488,1 +1604,1 @@\n-  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n+  if ((!is_oop || bs->supports_avx3_masked_arraycopy()) && VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n@@ -1530,1 +1646,0 @@\n-  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n@@ -1573,1 +1688,1 @@\n-    copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+    copy_bytes_forward(end_from, end_to, qword_count, rax, r10, L_copy_bytes, L_copy_8_bytes, decorators, is_oop ? T_OBJECT : T_INT);\n@@ -1599,0 +1714,1 @@\n+  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n@@ -1600,1 +1716,1 @@\n-  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n+  if ((!is_oop || bs->supports_avx3_masked_arraycopy()) && VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n@@ -1638,1 +1754,0 @@\n-  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n@@ -1680,1 +1795,1 @@\n-    copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+    copy_bytes_backward(from, to, qword_count, rax, r10, L_copy_bytes, L_copy_8_bytes, decorators, is_oop ? T_OBJECT : T_INT);\n@@ -1713,0 +1828,1 @@\n+  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n@@ -1714,1 +1830,1 @@\n-  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n+  if ((!is_oop || bs->supports_avx3_masked_arraycopy()) && VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize >= 32) {\n@@ -1756,1 +1872,0 @@\n-  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n@@ -1770,2 +1885,6 @@\n-    __ movq(rax, Address(end_from, qword_count, Address::times_8, 8));\n-    __ movq(Address(end_to, qword_count, Address::times_8, 8), rax);\n+    bs->copy_load_at(_masm, decorators, type, 8,\n+                     rax, Address(end_from, qword_count, Address::times_8, 8),\n+                     r10);\n+    bs->copy_store_at(_masm, decorators, type, 8,\n+                      Address(end_to, qword_count, Address::times_8, 8), rax,\n+                      r10);\n@@ -1790,1 +1909,1 @@\n-    copy_bytes_forward(end_from, end_to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+    copy_bytes_forward(end_from, end_to, qword_count, rax, r10, L_copy_bytes, L_copy_8_bytes, decorators, is_oop ? T_OBJECT : T_LONG);\n@@ -1822,0 +1941,1 @@\n+  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n@@ -1823,1 +1943,1 @@\n-  if (VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n+  if ((!is_oop || bs->supports_avx3_masked_arraycopy()) && VM_Version::supports_avx512vlbw() && VM_Version::supports_bmi2() && MaxVectorSize  >= 32) {\n@@ -1861,1 +1981,0 @@\n-  BarrierSetAssembler *bs = BarrierSet::barrier_set()->barrier_set_assembler();\n@@ -1871,2 +1990,6 @@\n-    __ movq(rax, Address(from, qword_count, Address::times_8, -8));\n-    __ movq(Address(to, qword_count, Address::times_8, -8), rax);\n+    bs->copy_load_at(_masm, decorators, type, 8,\n+                     rax, Address(from, qword_count, Address::times_8, -8),\n+                     r10);\n+    bs->copy_store_at(_masm, decorators, type, 8,\n+                      Address(to, qword_count, Address::times_8, -8), rax,\n+                      r10);\n@@ -1891,1 +2014,1 @@\n-    copy_bytes_backward(from, to, qword_count, rax, L_copy_bytes, L_copy_8_bytes);\n+    copy_bytes_backward(from, to, qword_count, rax, r10, L_copy_bytes, L_copy_8_bytes, decorators, is_oop ? T_OBJECT : T_LONG);\n@@ -1990,3 +2113,3 @@\n-  setup_arg_regs(4); \/\/ from => rdi, to => rsi, length => rdx\n-                     \/\/ ckoff => rcx, ckval => r8\n-                     \/\/ r9 and r10 may be used to save non-volatile registers\n+  setup_arg_regs_using_thread(4); \/\/ from => rdi, to => rsi, length => rdx\n+                                  \/\/ ckoff => rcx, ckval => r8\n+                                  \/\/ r9 is used to save r15_thread\n@@ -2055,0 +2178,2 @@\n+  size_t element_size = UseCompressedOops ? 4 : 8;\n+\n@@ -2078,1 +2203,7 @@\n-  __ store_heap_oop(to_element_addr, rax_oop, noreg, noreg, noreg, AS_RAW);  \/\/ store the oop\n+  bs->copy_store_at(_masm,\n+                    decorators,\n+                    type,\n+                    element_size,\n+                    to_element_addr,\n+                    rax_oop,\n+                    r10);\n@@ -2084,1 +2215,7 @@\n-  __ load_heap_oop(rax_oop, from_element_addr, noreg, noreg, AS_RAW); \/\/ load the oop\n+  bs->copy_load_at(_masm,\n+                   decorators,\n+                   type,\n+                   element_size,\n+                   rax_oop,\n+                   from_element_addr,\n+                   r10);\n@@ -2116,1 +2253,1 @@\n-  restore_arg_regs();\n+  restore_arg_regs_using_thread();\n@@ -2556,1 +2693,1 @@\n-    setup_arg_regs(4);\n+    setup_arg_regs_using_thread(4);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":224,"deletions":87,"binary":false,"changes":311,"status":"modified"},{"patch":"@@ -4017,2 +4017,1 @@\n-  __ null_check(recv, oopDesc::klass_offset_in_bytes());\n-  __ load_klass(rax, recv, rscratch1);\n+  __ load_klass_check_null(rax, recv, rscratch1);\n@@ -4109,2 +4108,1 @@\n-  __ null_check(rcx, oopDesc::klass_offset_in_bytes());\n-  __ load_klass(rlocals, rcx, rscratch1);\n+  __ load_klass_check_null(rlocals, rcx, rscratch1);\n@@ -4132,2 +4130,1 @@\n-  __ null_check(rcx, oopDesc::klass_offset_in_bytes());\n-  __ load_klass(rdx, rcx, rscratch1);\n+  __ load_klass_check_null(rdx, rcx, rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,0 +113,2 @@\n+    FrameMap* f = Compilation::current()->frame_map();\n+    f->update_reserved_argument_area_size(2 * BytesPerWord);\n@@ -169,1 +171,7 @@\n-  RangeCheckStub(CodeEmitInfo* info, LIR_Opr index, LIR_Opr array);\n+  RangeCheckStub(CodeEmitInfo* info, LIR_Opr index, LIR_Opr array)\n+    : _index(index), _array(array), _throw_index_out_of_bounds_exception(false) {\n+    assert(info != NULL, \"must have info\");\n+    _info = new CodeEmitInfo(info);\n+    FrameMap* f = Compilation::current()->frame_map();\n+    f->update_reserved_argument_area_size(2 * BytesPerWord);\n+  }\n@@ -171,1 +179,7 @@\n-  RangeCheckStub(CodeEmitInfo* info, LIR_Opr index);\n+  RangeCheckStub(CodeEmitInfo* info, LIR_Opr index)\n+    : _index(index), _array(), _throw_index_out_of_bounds_exception(true) {\n+    assert(info != NULL, \"must have info\");\n+    _info = new CodeEmitInfo(info);\n+    FrameMap* f = Compilation::current()->frame_map();\n+    f->update_reserved_argument_area_size(2 * BytesPerWord);\n+  }\n@@ -417,1 +431,12 @@\n-  MonitorEnterStub(LIR_Opr obj_reg, LIR_Opr lock_reg, CodeEmitInfo* info, CodeStub* throw_imse_stub = NULL, LIR_Opr scratch_reg = LIR_OprFact::illegalOpr);\n+  MonitorEnterStub(LIR_Opr obj_reg, LIR_Opr lock_reg, CodeEmitInfo* info,\n+                   CodeStub* throw_imse_stub = NULL, LIR_Opr scratch_reg = LIR_OprFact::illegalOpr)\n+    : MonitorAccessStub(obj_reg, lock_reg) {\n+    _info = new CodeEmitInfo(info);\n+    _scratch_reg = scratch_reg;\n+    _throw_imse_stub = throw_imse_stub;\n+    if (_throw_imse_stub != NULL) {\n+      assert(_scratch_reg != LIR_OprFact::illegalOpr, \"must be\");\n+    }\n+    FrameMap* f = Compilation::current()->frame_map();\n+    f->update_reserved_argument_area_size(2 * BytesPerWord);\n+  }\n@@ -561,1 +586,4 @@\n-    _info(new CodeEmitInfo(info)), _trap_request(Deoptimization::make_trap_request(reason, action)) {}\n+    _info(new CodeEmitInfo(info)), _trap_request(Deoptimization::make_trap_request(reason, action)) {\n+    FrameMap* f = Compilation::current()->frame_map();\n+    f->update_reserved_argument_area_size(2 * BytesPerWord);\n+  }\n@@ -584,0 +612,2 @@\n+    FrameMap* f = Compilation::current()->frame_map();\n+    f->update_reserved_argument_area_size(2 * BytesPerWord);\n@@ -619,1 +649,4 @@\n-  ArrayCopyStub(LIR_OpArrayCopy* op): _op(op) { }\n+  ArrayCopyStub(LIR_OpArrayCopy* op): _op(op) {\n+    FrameMap* f = Compilation::current()->frame_map();\n+    f->update_reserved_argument_area_size(arraycopystub_reserved_argument_area_size * BytesPerWord);\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":39,"deletions":6,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -401,1 +401,1 @@\n-    _frame_map = new FrameMap(method(), hir()->number_of_locks(), MAX2(4, hir()->max_stack()));\n+    _frame_map = new FrameMap(method(), hir()->number_of_locks(), hir()->max_stack());\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,1 +165,5 @@\n-  _reserved_argument_area_size = MAX2(4, reserved_argument_area_size) * BytesPerWord;\n+\n+  \/\/ reserved_argument_area_size does not include stack space that needs to be occupied in the stub\n+  \/\/ and the stub will modify the value through update_reserved_argument_area_size(int size) if needed.\n+  \/\/ see the constructor of class CounterOverflowStub for example.\n+  _reserved_argument_area_size = reserved_argument_area_size * BytesPerWord;\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,0 +80,5 @@\n+  void update_reserved_argument_area_size (int size) {\n+    assert(size >= 0, \"check\");\n+    _reserved_argument_area_size = MAX2(_reserved_argument_area_size, size);\n+  }\n+\n@@ -125,5 +130,0 @@\n-  void update_reserved_argument_area_size (int size) {\n-    assert(size >= 0, \"check\");\n-    _reserved_argument_area_size = MAX2(_reserved_argument_area_size, size);\n-  }\n-\n@@ -136,1 +136,0 @@\n-\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1332,4 +1332,3 @@\n-    ResourceBitMap live = block->live_out();\n-    int size = (int)live.size();\n-    for (int number = (int)live.get_next_one_offset(0, size); number < size; number = (int)live.get_next_one_offset(number + 1, size)) {\n-      assert(live.at(number), \"should not stop here otherwise\");\n+    ResourceBitMap& live = block->live_out();\n+    auto updater = [&](BitMap::idx_t index) {\n+      int number = static_cast<int>(index);\n@@ -1350,1 +1349,2 @@\n-    }\n+    };\n+    live.iterate(updater);\n@@ -1741,4 +1741,3 @@\n-  const int size = live_set_size();\n-  const ResourceBitMap live_at_edge = to_block->live_in();\n-\n-  for (int r = (int)live_at_edge.get_next_one_offset(0, size); r < size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {\n+  const ResourceBitMap& live_at_edge = to_block->live_in();\n+  auto visitor = [&](BitMap::idx_t index) {\n+    int r = static_cast<int>(index);\n@@ -1756,1 +1755,2 @@\n-  }\n+  };\n+  live_at_edge.iterate(visitor, 0, live_set_size());\n@@ -1916,2 +1916,2 @@\n-  int size = live_set_size();\n-  for (int r = (int)block->live_in().get_next_one_offset(0, size); r < size; r = (int)block->live_in().get_next_one_offset(r + 1, size)) {\n+  auto resolver = [&](BitMap::idx_t index) {\n+    int r = static_cast<int>(index);\n@@ -1919,1 +1919,2 @@\n-  }\n+  };\n+  block->live_in().iterate(resolver, 0, live_set_size());\n@@ -1989,2 +1990,2 @@\n-  int size = live_set_size();\n-  for (int r = (int)block->live_in().get_next_one_offset(0, size); r < size; r = (int)block->live_in().get_next_one_offset(r + 1, size)) {\n+  auto resolver = [&](BitMap::idx_t index) {\n+    int r = static_cast<int>(index);\n@@ -1992,1 +1993,2 @@\n-  }\n+  };\n+  block->live_in().iterate(resolver, 0, live_set_size());\n@@ -3469,1 +3471,1 @@\n-    ResourceBitMap live_at_edge = block->live_in();\n+    ResourceBitMap& live_at_edge = block->live_in();\n@@ -3472,1 +3474,2 @@\n-    for (int r = (int)live_at_edge.get_next_one_offset(0, size); r < size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {\n+    auto visitor = [&](BitMap::idx_t index) {\n+      int r = static_cast<int>(index);\n@@ -3481,1 +3484,2 @@\n-    }\n+    };\n+    live_at_edge.iterate(visitor, 0, size);\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -106,38 +106,0 @@\n-\n-\/\/ Complain and continue.  Recoverable errors during the reading of the\n-\/\/ archive file may continue (with sharing disabled).\n-\/\/\n-\/\/ If we continue, then disable shared spaces and close the file.\n-\n-void FileMapInfo::fail_continue(const char *msg, ...) {\n-  va_list ap;\n-  va_start(ap, msg);\n-  fail_continue_impl(LogLevel::Info, msg, ap);\n-  va_end(ap);\n-}\n-\n-void FileMapInfo::fail_continue(LogLevelType level, const char *msg, ...) {\n-  va_list ap;\n-  va_start(ap, msg);\n-  fail_continue_impl(level, msg, ap);\n-  va_end(ap);\n-}\n-\n-void FileMapInfo::fail_continue_impl(LogLevelType level, const char *msg, va_list ap) {\n-  if (PrintSharedArchiveAndExit && _validating_shared_path_table) {\n-    \/\/ If we are doing PrintSharedArchiveAndExit and some of the classpath entries\n-    \/\/ do not validate, we can still continue \"limping\" to validate the remaining\n-    \/\/ entries. No need to quit.\n-    tty->print(\"[\");\n-    tty->vprint(msg, ap);\n-    tty->print_cr(\"]\");\n-  } else {\n-    if (RequireSharedSpaces) {\n-      fail_exit(msg, ap);\n-    } else {\n-      LogMessage(cds) lm;\n-      lm.vwrite(level, msg, ap);\n-    }\n-  }\n-}\n-\n@@ -181,1 +143,1 @@\n-    FileMapInfo::fail_continue(\"%s\", ss.as_string()); \\\n+    log_info(cds)(\"%s\", ss.as_string()); \\\n@@ -534,1 +496,1 @@\n-    FileMapInfo::fail_continue(\"Required classpath entry does not exist: %s\", name);\n+    log_warning(cds)(\"Required classpath entry does not exist: %s\", name);\n@@ -538,1 +500,1 @@\n-      FileMapInfo::fail_continue(\"directory is not empty: %s\", name);\n+      log_warning(cds)(\"directory is not empty: %s\", name);\n@@ -545,1 +507,1 @@\n-      FileMapInfo::fail_continue(_timestamp != st.st_mtime ?\n+      log_warning(cds)(_timestamp != st.st_mtime ?\n@@ -550,1 +512,1 @@\n-      FileMapInfo::fail_continue(\"%s %s\", bad_jar_msg, name);\n+      log_warning(cds)(\"%s %s\", bad_jar_msg, name);\n@@ -1205,1 +1167,5 @@\n-      fail_continue(LogLevel::Warning, \"%s%s\", mismatch_msg, hint_msg);\n+      if (RequireSharedSpaces) {\n+        fail_stop(\"%s%s\", mismatch_msg, hint_msg);\n+      } else {\n+        log_warning(cds)(\"%s%s\", mismatch_msg, hint_msg);\n+      }\n@@ -1283,1 +1249,1 @@\n-      FileMapInfo::fail_continue(\"Specified shared archive not found (%s)\", _archive_name);\n+      log_info(cds)(\"Specified shared archive not found (%s)\", _archive_name);\n@@ -1299,1 +1265,1 @@\n-      FileMapInfo::fail_continue(\"Unable to read generic CDS file map header from shared archive\");\n+      log_warning(cds)(\"Unable to read generic CDS file map header from shared archive\");\n@@ -1305,1 +1271,1 @@\n-      FileMapInfo::fail_continue(\"The shared archive file has a bad magic number: %#x\", gen_header._magic);\n+      log_warning(cds)(\"The shared archive file has a bad magic number: %#x\", gen_header._magic);\n@@ -1310,1 +1276,1 @@\n-      FileMapInfo::fail_continue(\"Cannot handle shared archive file version 0x%x. Must be at least 0x%x.\",\n+      log_warning(cds)(\"Cannot handle shared archive file version 0x%x. Must be at least 0x%x.\",\n@@ -1316,1 +1282,1 @@\n-      FileMapInfo::fail_continue(\"The shared archive file version 0x%x does not match the required version 0x%x.\",\n+      log_warning(cds)(\"The shared archive file version 0x%x does not match the required version 0x%x.\",\n@@ -1322,1 +1288,1 @@\n-      FileMapInfo::fail_continue(\"Archive file header larger than archive file\");\n+      log_warning(cds)(\"Archive file header larger than archive file\");\n@@ -1332,1 +1298,1 @@\n-      FileMapInfo::fail_continue(\"Unable to read actual CDS file map header from shared archive\");\n+      log_warning(cds)(\"Unable to read actual CDS file map header from shared archive\");\n@@ -1336,1 +1302,1 @@\n-    if (!check_crc()) {\n+    if (!check_header_crc()) {\n@@ -1360,1 +1326,1 @@\n-  bool check_crc() {\n+  bool check_header_crc() const {\n@@ -1367,1 +1333,1 @@\n-        FileMapInfo::fail_continue(\"Header checksum verification failed.\");\n+        log_warning(cds)(\"Header checksum verification failed.\");\n@@ -1380,1 +1346,1 @@\n-      FileMapInfo::fail_continue(\"base_archive_name offset\/size overflow: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n+      log_warning(cds)(\"base_archive_name offset\/size overflow: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n@@ -1386,1 +1352,1 @@\n-        FileMapInfo::fail_continue(\"static shared archive must have zero _base_archive_name_offset\");\n+        log_warning(cds)(\"static shared archive must have zero _base_archive_name_offset\");\n@@ -1390,1 +1356,1 @@\n-        FileMapInfo::fail_continue(\"static shared archive must have zero _base_archive_name_size\");\n+        log_warning(cds)(\"static shared archive must have zero _base_archive_name_size\");\n@@ -1398,1 +1364,1 @@\n-        FileMapInfo::fail_continue(\"Invalid base_archive_name offset\/size: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n+        log_warning(cds)(\"Invalid base_archive_name offset\/size: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n@@ -1404,1 +1370,1 @@\n-          FileMapInfo::fail_continue(\"Invalid base_archive_name offset\/size (out of range): \"\n+          log_warning(cds)(\"Invalid base_archive_name offset\/size (out of range): \"\n@@ -1411,1 +1377,1 @@\n-          FileMapInfo::fail_continue(\"Base archive name is damaged\");\n+          log_warning(cds)(\"Base archive name is damaged\");\n@@ -1415,1 +1381,1 @@\n-          FileMapInfo::fail_continue(\"Base archive %s does not exist\", name);\n+          log_warning(cds)(\"Base archive %s does not exist\", name);\n@@ -1465,1 +1431,1 @@\n-    fail_continue(\"Unable to read the file header.\");\n+    log_warning(cds)(\"Unable to read the file header.\");\n@@ -1472,1 +1438,1 @@\n-      FileMapInfo::fail_continue(\"Not a base shared archive: %s\", _full_path);\n+      log_warning(cds)(\"Not a base shared archive: %s\", _full_path);\n@@ -1477,1 +1443,1 @@\n-      FileMapInfo::fail_continue(\"Not a top shared archive: %s\", _full_path);\n+      log_warning(cds)(\"Not a top shared archive: %s\", _full_path);\n@@ -1487,1 +1453,1 @@\n-    fail_continue(\"Failed to read file header from the top archive file\\n\");\n+    log_warning(cds)(\"Failed to read file header from the top archive file\\n\");\n@@ -1494,1 +1460,1 @@\n-    fail_continue(\"The shared archive file has the wrong version.\");\n+    log_warning(cds)(\"The shared archive file has the wrong version.\");\n@@ -1500,1 +1466,1 @@\n-      FileMapInfo::fail_continue(\"common app classpath prefix len < 0\");\n+      log_warning(cds)(\"common app classpath prefix len < 0\");\n@@ -1513,1 +1479,1 @@\n-      FileMapInfo::fail_continue(\"The shared archive file has an incorrect header size.\");\n+      log_warning(cds)(\"The shared archive file has an incorrect header size.\");\n@@ -1521,1 +1487,1 @@\n-    FileMapInfo::fail_continue(\"JVM version identifier is corrupted.\");\n+    log_warning(cds)(\"JVM version identifier is corrupted.\");\n@@ -1530,1 +1496,1 @@\n-    FileMapInfo::fail_continue(\"The shared archive file was created by a different\"\n+    log_warning(cds)(\"The shared archive file was created by a different\"\n@@ -1542,1 +1508,1 @@\n-      fail_continue(\"The shared archive file has been truncated.\");\n+      log_warning(cds)(\"The shared archive file has been truncated.\");\n@@ -1569,1 +1535,1 @@\n-      fail_continue(\"Specified shared archive not found (%s)\", _full_path);\n+      log_info(cds)(\"Specified shared archive not found (%s)\", _full_path);\n@@ -1571,1 +1537,1 @@\n-      fail_continue(\"Failed to open shared archive file (%s)\",\n+      log_warning(cds)(\"Failed to open shared archive file (%s)\",\n@@ -1667,0 +1633,18 @@\n+bool FileMapRegion::check_region_crc() const {\n+  \/\/ This function should be called after the region has been properly\n+  \/\/ loaded into memory via FileMapInfo::map_region() or FileMapInfo::read_region().\n+  \/\/ I.e., this->mapped_base() must be valid.\n+  size_t sz = used();\n+  if (sz == 0) {\n+    return true;\n+  }\n+\n+  assert(mapped_base() != nullptr, \"must be initialized\");\n+  int crc = ClassLoader::crc32(0, mapped_base(), (jint)sz);\n+  if (crc != this->crc()) {\n+    log_warning(cds)(\"Checksum verification failed.\");\n+    return false;\n+  }\n+  return true;\n+}\n+\n@@ -1922,1 +1906,1 @@\n-  char *addr = region_addr(idx);\n+  char *addr = r->mapped_base();\n@@ -1996,1 +1980,4 @@\n-  if (VerifySharedSpaces && !region_crc_check(base, r->used(), r->crc())) {\n+  r->set_mapped_from_file(false);\n+  r->set_mapped_base(base);\n+\n+  if (VerifySharedSpaces && !r->check_region_crc()) {\n@@ -2034,0 +2021,2 @@\n+    } else {\n+      assert(r->mapped_base() != nullptr, \"must be initialized\");\n@@ -2049,0 +2038,1 @@\n+    r->set_mapped_base(requested_addr);\n@@ -2050,2 +2040,1 @@\n-  r->set_mapped_base(requested_addr);\n-  if (VerifySharedSpaces && !verify_region_checksum(i)) {\n+  if (VerifySharedSpaces && !r->check_region_crc()) {\n@@ -2074,1 +2063,2 @@\n-  if (VerifySharedSpaces && !region_crc_check(bitmap_base, r->used(), r->crc())) {\n+  r->set_mapped_base(bitmap_base);\n+  if (VerifySharedSpaces && !r->check_region_crc()) {\n@@ -2082,1 +2072,0 @@\n-  r->set_mapped_base(bitmap_base);\n@@ -2500,1 +2489,2 @@\n-    if (VerifySharedSpaces && !region_crc_check(addr, regions[i].byte_size(), r->crc())) {\n+    r->set_mapped_base(base);\n+    if (VerifySharedSpaces && !r->check_region_crc()) {\n@@ -2506,2 +2496,0 @@\n-\n-    r->set_mapped_base(base);\n@@ -2595,20 +2583,0 @@\n-bool FileMapInfo::region_crc_check(char* buf, size_t size, int expected_crc) {\n-  int crc = ClassLoader::crc32(0, buf, (jint)size);\n-  if (crc != expected_crc) {\n-    fail_continue(\"Checksum verification failed.\");\n-    return false;\n-  }\n-  return true;\n-}\n-\n-bool FileMapInfo::verify_region_checksum(int i) {\n-  assert(VerifySharedSpaces, \"sanity\");\n-  size_t sz = region_at(i)->used();\n-\n-  if (sz == 0) {\n-    return true; \/\/ no data\n-  } else {\n-    return region_crc_check(region_addr(i), sz, region_at(i)->crc());\n-  }\n-}\n-\n@@ -2667,3 +2635,2 @@\n-\/\/ information (version, boot classpath, etc.).  If initialization\n-\/\/ fails, shared spaces are disabled and the file is closed. [See\n-\/\/ fail_continue.]\n+\/\/ information (version, boot classpath, etc.). If initialization\n+\/\/ fails, shared spaces are disabled and the file is closed.\n@@ -2684,1 +2651,1 @@\n-    FileMapInfo::fail_continue(\"CDS is disabled because early JVMTI ClassFileLoadHook is in use.\");\n+    log_info(cds)(\"CDS is disabled because early JVMTI ClassFileLoadHook is in use.\");\n@@ -2689,1 +2656,1 @@\n-    FileMapInfo::fail_continue(\"The shared archive file cannot be used with an exploded module build.\");\n+    log_info(cds)(\"The shared archive file cannot be used with an exploded module build.\");\n@@ -2695,1 +2662,1 @@\n-      FileMapInfo::fail_continue(\"Initialize static archive failed.\");\n+      log_info(cds)(\"Initialize static archive failed.\");\n@@ -2698,1 +2665,1 @@\n-      FileMapInfo::fail_continue(\"Initialize dynamic archive failed.\");\n+      log_info(cds)(\"Initialize dynamic archive failed.\");\n@@ -2710,6 +2677,0 @@\n-char* FileMapInfo::region_addr(int idx) {\n-  assert(UseSharedSpaces, \"must be\");\n-  FileMapRegion* r = region_at(idx);\n-  return r->mapped_base();\n-}\n-\n@@ -2741,1 +2702,1 @@\n-    FileMapInfo::fail_continue(\"The shared archive file's ObjectAlignmentInBytes of %d\"\n+    log_info(cds)(\"The shared archive file's ObjectAlignmentInBytes of %d\"\n@@ -2747,1 +2708,1 @@\n-    FileMapInfo::fail_continue(\"The shared archive file's CompactStrings setting (%s)\"\n+    log_info(cds)(\"The shared archive file's CompactStrings setting (%s)\"\n@@ -2767,1 +2728,1 @@\n-    FileMapInfo::fail_continue(\"The shared archive file's BytecodeVerificationLocal setting (%s)\"\n+    log_info(cds)(\"The shared archive file's BytecodeVerificationLocal setting (%s)\"\n@@ -2779,1 +2740,1 @@\n-    FileMapInfo::fail_continue(\"The shared archive file was created with less restrictive \"\n+    log_info(cds)(\"The shared archive file was created with less restrictive \"\n@@ -2791,1 +2752,1 @@\n-    FileMapInfo::fail_continue(\"The setting of the AllowArchivingWithJavaAgent is different \"\n+    log_warning(cds)(\"The setting of the AllowArchivingWithJavaAgent is different \"\n@@ -2804,1 +2765,1 @@\n-    FileMapInfo::fail_continue(\"Unable to use shared archive.\\nThe saved state of UseCompressedOops and UseCompressedClassPointers is \"\n+    log_info(cds)(\"Unable to use shared archive.\\nThe saved state of UseCompressedOops and UseCompressedClassPointers is \"\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":82,"deletions":121,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+  bool check_region_crc() const;\n@@ -510,1 +511,0 @@\n-  bool  verify_region_checksum(int i);\n@@ -521,3 +521,0 @@\n-  static void fail_continue(const char *msg, ...) ATTRIBUTE_PRINTF(1, 2);\n-  static void fail_continue(LogLevelType level, const char *msg, ...) ATTRIBUTE_PRINTF(2, 3);\n-  static void fail_continue_impl(LogLevelType level, const char *msg, va_list ap) ATTRIBUTE_PRINTF(2, 0);\n@@ -563,2 +560,0 @@\n-  char* region_addr(int idx);\n-\n@@ -612,1 +607,0 @@\n-  bool  region_crc_check(char* buf, size_t size, int expected_crc) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -952,1 +952,1 @@\n-    FileMapInfo::fail_continue(\"Unable to map shared spaces\");\n+    log_info(cds)(\"Unable to map shared spaces\");\n@@ -955,0 +955,2 @@\n+    } else if (RequireSharedSpaces) {\n+      FileMapInfo::fail_stop(\"Unable to map shared spaces\");\n@@ -958,0 +960,2 @@\n+  \/\/ If mapping failed and -XShare:on, the vm should exit\n+  bool has_failed = false;\n@@ -959,0 +963,1 @@\n+    has_failed = true;\n@@ -962,0 +967,1 @@\n+    has_failed = true;\n@@ -964,0 +970,3 @@\n+  if (RequireSharedSpaces && has_failed) {\n+      FileMapInfo::fail_stop(\"Unable to map shared spaces\");\n+  }\n@@ -989,0 +998,3 @@\n+    if (RequireSharedSpaces) {\n+      FileMapInfo::fail_stop(\"Failed to initialize dynamic archive\");\n+    }\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-\/\/ ciArrayKlass::base_element_type\n+\/\/ ciArrayKlass::make\n@@ -104,1 +104,1 @@\n-\/\/ What type is obtained when this array is indexed as many times as possible?\n+\/\/ Make an array klass of the specified element type.\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -356,0 +356,1 @@\n+  friend class JVMCIVMStructs;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  do_klass(BasicVirtualThread_klass,                    java_lang_BaseVirtualThread                           ) \\\n+  do_klass(BaseVirtualThread_klass,                     java_lang_BaseVirtualThread                           ) \\\n@@ -94,0 +94,1 @@\n+  do_klass(BoundVirtualThread_klass,                    java_lang_BoundVirtualThread                          ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -205,2 +205,2 @@\n-  \/* Special flavor of dsqrt intrinsic to handle the \"native\" method in StrictMath. Otherwise the same as in Math. *\/   \\\n-  do_intrinsic(_dsqrt_strict,             java_lang_StrictMath,   sqrt_name,          double_double_signature,   F_SN)  \\\n+  \/* Additional dsqrt intrinsic to directly handle the sqrt method in StrictMath. Otherwise the same as in Math. *\/     \\\n+  do_intrinsic(_dsqrt_strict,             java_lang_StrictMath,   sqrt_name,          double_double_signature,   F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+  template(java_lang_BoundVirtualThread,              \"java\/lang\/ThreadBuilders$BoundVirtualThread\") \\\n@@ -760,0 +761,1 @@\n+  template(decodeAndThrowThrowable_signature,          \"(JZ)V\")                                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -341,0 +341,2 @@\n+\n+  \/\/ Returns NULL if CodeBuffer::expand fails\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -907,0 +907,15 @@\n+static bool trace_compiler_threads() {\n+  LogTarget(Debug, jit, thread) lt;\n+  return TraceCompilerThreads || lt.is_enabled();\n+}\n+\n+static void print_compiler_threads(stringStream& msg) {\n+  if (TraceCompilerThreads) {\n+    tty->print_cr(\"%7d %s\", (int)tty->time_stamp().milliseconds(), msg.as_string());\n+  }\n+  LogTarget(Debug, jit, thread) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print_cr(\"%s\", msg.as_string());\n+  }\n+}\n@@ -946,1 +961,1 @@\n-      if (TraceCompilerThreads) {\n+      if (trace_compiler_threads()) {\n@@ -950,1 +965,3 @@\n-        tty->print_cr(\"Added initial compiler thread %s\", ct->name());\n+        stringStream msg;\n+        msg.print(\"Added initial compiler thread %s\", ct->name());\n+        print_compiler_threads(msg);\n@@ -967,1 +984,1 @@\n-      if (TraceCompilerThreads) {\n+      if (trace_compiler_threads()) {\n@@ -971,1 +988,3 @@\n-        tty->print_cr(\"Added initial compiler thread %s\", ct->name());\n+        stringStream msg;\n+        msg.print(\"Added initial compiler thread %s\", ct->name());\n+        print_compiler_threads(msg);\n@@ -1029,1 +1048,1 @@\n-          if (TraceCompilerThreads) {\n+          if (trace_compiler_threads()) {\n@@ -1031,2 +1050,4 @@\n-            tty->print_cr(\"JVMCI compiler thread creation failed:\");\n-            PENDING_EXCEPTION->print();\n+            stringStream msg;\n+            msg.print_cr(\"JVMCI compiler thread creation failed:\");\n+            PENDING_EXCEPTION->print_on(&msg);\n+            print_compiler_threads(msg);\n@@ -1047,1 +1068,1 @@\n-      if (TraceCompilerThreads) {\n+      if (trace_compiler_threads()) {\n@@ -1051,2 +1072,4 @@\n-        tty->print_cr(\"Added compiler thread %s (available memory: %dMB, available non-profiled code cache: %dMB)\",\n-                      ct->name(), (int)(available_memory\/M), (int)(available_cc_np\/M));\n+        stringStream msg;\n+        msg.print(\"Added compiler thread %s (available memory: %dMB, available non-profiled code cache: %dMB)\",\n+                  ct->name(), (int)(available_memory\/M), (int)(available_cc_np\/M));\n+        print_compiler_threads(msg);\n@@ -1068,1 +1091,1 @@\n-      if (TraceCompilerThreads) {\n+      if (trace_compiler_threads()) {\n@@ -1072,2 +1095,4 @@\n-        tty->print_cr(\"Added compiler thread %s (available memory: %dMB, available profiled code cache: %dMB)\",\n-                      ct->name(), (int)(available_memory\/M), (int)(available_cc_p\/M));\n+        stringStream msg;\n+        msg.print(\"Added compiler thread %s (available memory: %dMB, available profiled code cache: %dMB)\",\n+                  ct->name(), (int)(available_memory\/M), (int)(available_cc_p\/M));\n+        print_compiler_threads(msg);\n@@ -1888,3 +1913,6 @@\n-          if (TraceCompilerThreads) {\n-            tty->print_cr(\"Removing compiler thread %s after \" JLONG_FORMAT \" ms idle time\",\n-                          thread->name(), thread->idle_time_millis());\n+          if (trace_compiler_threads()) {\n+            ResourceMark rm;\n+            stringStream msg;\n+            msg.print(\"Removing compiler thread %s after \" JLONG_FORMAT \" ms idle time\",\n+                      thread->name(), thread->idle_time_millis());\n+            print_compiler_threads(msg);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":44,"deletions":16,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/machnode.hpp\"\n@@ -309,0 +310,6 @@\n+\n+#ifndef PRODUCT\n+  virtual void dump_barrier_data(const MachNode* mach, outputStream* st) const {\n+    st->print(\"%x\", mach->barrier_data());\n+  };\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -450,0 +450,6 @@\n+  \/\/ GCs are free to represent the bit representation for null differently in memory,\n+  \/\/ which is typically not observable when using the Access API. However, if for\n+  \/\/ some reason a context doesn't allow using the Access API, then this function\n+  \/\/ explicitly checks if the given memory location contains a null value.\n+  virtual bool contains_null(const oop* p) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  \/\/ Causes all refs in \"mr\" to be assumed to be modified.\n+  \/\/ Causes all refs in \"mr\" to be assumed to be modified (by this JavaThread).\n@@ -56,1 +56,2 @@\n-  virtual void write_region(MemRegion mr) = 0;\n+  \/\/ Causes all refs in \"mr\" to be assumed to be modified by the given JavaThread.\n+  virtual void write_region(JavaThread* thread, MemRegion mr) = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/thread.hpp\"\n@@ -155,1 +156,1 @@\n-  bs->write_region(MemRegion((HeapWord*)(void*)dst, size));\n+  bs->invalidate(MemRegion((HeapWord*)(void*)dst, size));\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -567,0 +567,17 @@\n+\n+#ifndef PRODUCT\n+void ZBarrierSetC2::dump_barrier_data(const MachNode* mach, outputStream* st) const {\n+  if ((mach->barrier_data() & ZLoadBarrierStrong) != 0) {\n+    st->print(\"strong \");\n+  }\n+  if ((mach->barrier_data() & ZLoadBarrierWeak) != 0) {\n+    st->print(\"weak \");\n+  }\n+  if ((mach->barrier_data() & ZLoadBarrierPhantom) != 0) {\n+    st->print(\"phantom \");\n+  }\n+  if ((mach->barrier_data() & ZLoadBarrierNoKeepalive) != 0) {\n+    st->print(\"nokeepalive \");\n+  }\n+}\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -657,2 +657,2 @@\n-      st->print(\"  %d\", mdo->dp_to_di(data->dp()));\n-      st->fill_to(6);\n+      st->print(\"  %d \", mdo->dp_to_di(data->dp()));\n+      st->fill_to(7);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1389,4 +1389,0 @@\n-  if (java_lang_VirtualThread::notify_jvmti_events()) {\n-    JvmtiExport::check_vthread_and_suspend_at_safepoint(current);\n-  }\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1182,1 +1182,3 @@\n-      CompiledStaticCall::emit_to_interp_stub(buffer, _instructions->start() + pc_offset);\n+      if (CompiledStaticCall::emit_to_interp_stub(buffer, _instructions->start() + pc_offset) == nullptr) {\n+        JVMCI_ERROR(\"could not emit to_interp stub - code cache is full\");\n+      }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -320,0 +320,1 @@\n+  static_field(StubRoutines,                _poly1305_processBlocks,                          address)                               \\\n@@ -345,0 +346,9 @@\n+  JFR_ONLY(nonstatic_field(Thread,          _jfr_thread_local,                                JfrThreadLocal))                       \\\n+                                                                                                                                     \\\n+  static_field(java_lang_Thread,            _tid_offset,                                      int)                                   \\\n+  JFR_ONLY(static_field(java_lang_Thread,   _jfr_epoch_offset,                                int))                                  \\\n+                                                                                                                                     \\\n+  JFR_ONLY(nonstatic_field(JfrThreadLocal,  _vthread_id,                                      traceid))                              \\\n+  JFR_ONLY(nonstatic_field(JfrThreadLocal,  _vthread_epoch,                                   u2))                                   \\\n+  JFR_ONLY(nonstatic_field(JfrThreadLocal,  _vthread_excluded,                                bool))                                 \\\n+  JFR_ONLY(nonstatic_field(JfrThreadLocal,  _vthread,                                         bool))                                 \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -241,1 +241,0 @@\n-class CompactibleSpace;\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -129,2 +129,2 @@\n-  st->print(\"bci: %d\", bci());\n-  st->fill_to(tab_width_one);\n+  st->print(\"bci: %d \", bci());\n+  st->fill_to(tab_width_one + 1);\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,10 @@\n+void oopDesc::print_name_on(outputStream* st) const {\n+  if (*((juint*)this) == badHeapWordVal) {\n+    st->print_cr(\"BAD WORD\");\n+  } else if (*((juint*)this) == badMetaWordVal) {\n+    st->print_cr(\"BAD META WORD\");\n+  } else {\n+    st->print_cr(\"%s\", klass()->external_name());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -243,2 +243,2 @@\n-  void print_on(outputStream* st) const;        \/\/ First level print\n-  void print_value_on(outputStream* st) const;  \/\/ Second level print.\n+  void print_on(outputStream* st) const;         \/\/ First level print\n+  void print_value_on(outputStream* st) const;   \/\/ Second level print.\n@@ -246,0 +246,1 @@\n+  void print_name_on(outputStream* st) const;    \/\/ External name printing.\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -68,32 +68,5 @@\n-void* Symbol::operator new(size_t sz, int len) throw() {\n-#if INCLUDE_CDS\n- if (DumpSharedSpaces) {\n-   MutexLocker ml(DumpRegion_lock, Mutex::_no_safepoint_check_flag);\n-   \/\/ To get deterministic output from -Xshare:dump, we ensure that Symbols are allocated in\n-   \/\/ increasing addresses. When the symbols are copied into the archive, we preserve their\n-   \/\/ relative address order (sorted, see ArchiveBuilder::gather_klasses_and_symbols).\n-   \/\/\n-   \/\/ We cannot use arena because arena chunks are allocated by the OS. As a result, for example,\n-   \/\/ the archived symbol of \"java\/lang\/Object\" may sometimes be lower than \"java\/lang\/String\", and\n-   \/\/ sometimes be higher. This would cause non-deterministic contents in the archive.\n-   DEBUG_ONLY(static void* last = 0);\n-   void* p = (void*)MetaspaceShared::symbol_space_alloc(size(len)*wordSize);\n-   assert(p > last, \"must increase monotonically\");\n-   DEBUG_ONLY(last = p);\n-   return p;\n- }\n-#endif\n-  int alloc_size = size(len)*wordSize;\n-  address res = (address) AllocateHeap(alloc_size, mtSymbol);\n-  return res;\n-}\n-\n-void* Symbol::operator new(size_t sz, int len, Arena* arena) throw() {\n-  int alloc_size = size(len)*wordSize;\n-  address res = (address)arena->AmallocWords(alloc_size);\n-  return res;\n-}\n-\n-void Symbol::operator delete(void *p) {\n-  assert(((Symbol*)p)->refcount() == 0, \"should not call this\");\n-  FreeHeap(p);\n+\/\/ This copies the symbol when it is added to the ConcurrentHashTable.\n+Symbol::Symbol(const Symbol& s1) {\n+  _hash_and_refcount = s1._hash_and_refcount;\n+  _length = s1._length;\n+  memcpy(_body, s1._body, _length);\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":5,"deletions":32,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -134,4 +134,0 @@\n-  void* operator new(size_t size, int len) throw();\n-  void* operator new(size_t size, int len, Arena* arena) throw();\n-\n-  void  operator delete(void* p);\n@@ -146,0 +142,2 @@\n+  Symbol(const Symbol& s1);\n+\n@@ -149,2 +147,4 @@\n-  int size()                { return size(utf8_length()); }\n-  int byte_size()           { return byte_size(utf8_length()); }\n+  int size()      const     { return size(utf8_length()); }\n+  int byte_size() const     { return byte_size(utf8_length()); };\n+  \/\/ length without the _body\n+  size_t effective_length() const { return (size_t)byte_size() - sizeof(Symbol); }\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -440,1 +440,0 @@\n-  assert(status != RegionNode::LoopStatus::NeverIrreducibleEntry, \"do not set this\");\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -965,1 +965,2 @@\n-  inline void       record_for_igvn(Node* n);   \/\/ Body is after class Unique_Node_List.\n+  inline void       record_for_igvn(Node* n);   \/\/ Body is after class Unique_Node_List in node.hpp.\n+  inline void       remove_for_igvn(Node* n);   \/\/ Body is after class Unique_Node_List in node.hpp.\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -750,0 +750,23 @@\n+\/\/-----------------------------destruct_map_clone------------------------------\n+\/\/\n+\/\/ Order of destruct is important to increase the likelyhood that memory can be re-used. We need\n+\/\/ to destruct\/free\/delete in the exact opposite order as clone_map().\n+void GraphKit::destruct_map_clone(SafePointNode* sfp) {\n+  if (sfp == nullptr) return;\n+\n+  Node* mem = sfp->memory();\n+  JVMState* jvms = sfp->jvms();\n+\n+  if (jvms != nullptr) {\n+    delete jvms;\n+  }\n+\n+  remove_for_igvn(sfp);\n+  gvn().clear_type(sfp);\n+  sfp->destruct(&_gvn);\n+\n+  if (mem != nullptr) {\n+    gvn().clear_type(mem);\n+    mem->destruct(&_gvn);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  void remove_for_igvn(Node* n) const { C->remove_for_igvn(n); }\n@@ -182,0 +183,5 @@\n+  \/\/ Reverses the work done by clone_map(). Should only be used when the node returned by\n+  \/\/ clone_map() is ultimately not used. Calling Node::destruct directly in the previously\n+  \/\/ mentioned circumstance instead of this method may result in use-after-free.\n+  void destruct_map_clone(SafePointNode* sfp);\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1312,1 +1312,1 @@\n-  Node* tgt         = argument(1); \/\/ tgt is int ch\n+  Node* int_ch      = argument(1);\n@@ -1324,0 +1324,9 @@\n+\n+  \/\/ Check for int_ch >= 0\n+  Node* int_ch_cmp = _gvn.transform(new CmpINode(int_ch, intcon(0)));\n+  Node* int_ch_bol = _gvn.transform(new BoolNode(int_ch_cmp, BoolTest::ge));\n+  {\n+    BuildCutout unless(this, int_ch_bol, PROB_MAX);\n+    uncommon_trap(Deoptimization::Reason_intrinsic,\n+                  Deoptimization::Action_maybe_recompile);\n+  }\n@@ -1331,1 +1340,1 @@\n-  Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, tgt, ae);\n+  Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, int_ch, ae);\n@@ -1659,1 +1668,1 @@\n-  old_map->destruct(&_gvn);\n+  destruct_map_clone(old_map);\n@@ -2485,1 +2494,1 @@\n-  old_map->destruct(&_gvn);\n+  destruct_map_clone(old_map);\n@@ -2811,1 +2820,1 @@\n-  old_map->destruct(&_gvn);\n+  destruct_map_clone(old_map);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -537,1 +537,1 @@\n-          register_new_node(add1, n_loop->_head->in(LoopNode::EntryControl));\n+          register_new_node(add1, n_loop->_head->as_Loop()->skip_strip_mined(1)->in(LoopNode::EntryControl));\n@@ -558,1 +558,1 @@\n-          register_new_node(add1, n_loop->_head->in(LoopNode::EntryControl));\n+          register_new_node(add1, n_loop->_head->as_Loop()->skip_strip_mined(1)->in(LoopNode::EntryControl));\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n@@ -554,0 +556,5 @@\n+  if (barrier_data() != 0) {\n+    st->print(\" barrier(\");\n+    BarrierSet::barrier_set()->barrier_set_c2()->dump_barrier_data(this, st);\n+    st->print(\")\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -623,26 +623,0 @@\n-  \/\/ See if the input array was allocated just prior to the object\n-  int edge_size = _max*sizeof(void*);\n-  int out_edge_size = _outmax*sizeof(void*);\n-  char *edge_end = ((char*)_in) + edge_size;\n-  char *out_array = (char*)(_out == NO_OUT_ARRAY? NULL: _out);\n-  int node_size = size_of();\n-  \/\/ Free the output edge array\n-  if (out_edge_size > 0) {\n-    compile->node_arena()->Afree(out_array, out_edge_size);\n-  }\n-\n-  \/\/ Free the input edge array and the node itself\n-  if( edge_end == (char*)this ) {\n-    \/\/ It was; free the input array and object all in one hit\n-#ifndef ASSERT\n-    compile->node_arena()->Afree(_in,edge_size+node_size);\n-#endif\n-  } else {\n-    \/\/ Free just the input array\n-    compile->node_arena()->Afree(_in,edge_size);\n-\n-    \/\/ Free just the object\n-#ifndef ASSERT\n-    compile->node_arena()->Afree(this,node_size);\n-#endif\n-  }\n@@ -675,0 +649,9 @@\n+\n+  \/\/ See if the input array was allocated just prior to the object\n+  int edge_size = _max*sizeof(void*);\n+  int out_edge_size = _outmax*sizeof(void*);\n+  char *in_array = ((char*)_in);\n+  char *edge_end = in_array + edge_size;\n+  char *out_array = (char*)(_out == NO_OUT_ARRAY? NULL: _out);\n+  int node_size = size_of();\n+\n@@ -677,0 +660,1 @@\n+  compile->remove_modified_node(this);\n@@ -680,1 +664,21 @@\n-  compile->remove_modified_node(this);\n+\n+  \/\/ Free the output edge array\n+  if (out_edge_size > 0) {\n+    compile->node_arena()->Afree(out_array, out_edge_size);\n+  }\n+\n+  \/\/ Free the input edge array and the node itself\n+  if( edge_end == (char*)this ) {\n+    \/\/ It was; free the input array and object all in one hit\n+#ifndef ASSERT\n+    compile->node_arena()->Afree(in_array, edge_size+node_size);\n+#endif\n+  } else {\n+    \/\/ Free just the input array\n+    compile->node_arena()->Afree(in_array, edge_size);\n+\n+    \/\/ Free just the object\n+#ifndef ASSERT\n+    compile->node_arena()->Afree(this, node_size);\n+#endif\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":31,"deletions":27,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1689,0 +1689,5 @@\n+\/\/ Inline definition of Compile::remove_for_igvn must be deferred to this point.\n+inline void Compile::remove_for_igvn(Node* n) {\n+  _for_igvn->remove(n);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -641,2 +641,0 @@\n-  C->set_default_node_notes(caller_nn);\n-\n@@ -653,0 +651,4 @@\n+  \/\/ Only reset this now, to make sure that debug information emitted\n+  \/\/ for exiting control flow still refers to the inlined method.\n+  C->set_default_node_notes(caller_nn);\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -472,0 +472,8 @@\n+  GrowableArray<Node_Notes*>* old_node_note_array = C->node_note_array();\n+  if (old_node_note_array != nullptr) {\n+    int new_size = (_useful.size() >> 8) + 1; \/\/ The node note array uses blocks, see C->_log2_node_notes_block_size\n+    new_size = MAX2(8, new_size);\n+    C->set_node_note_array(new (C->comp_arena()) GrowableArray<Node_Notes*> (C->comp_arena(), new_size, 0, nullptr));\n+    C->grow_node_notes(C->node_note_array(), new_size);\n+  }\n+\n@@ -487,0 +495,5 @@\n+    if (old_node_note_array != nullptr) {\n+      Node_Notes* nn = C->locate_node_notes(old_node_note_array, n->_idx);\n+      C->set_node_notes_at(current_idx, nn);\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -242,0 +242,5 @@\n+  void    clear_type(const Node* n) {\n+    if (n->_idx < _types.Size()) {\n+      _types.map(n->_idx, NULL);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -640,8 +640,0 @@\n-  size_table_field = C->env()->Integer_klass()->get_field_by_name(ciSymbol::make(\"sizeTable\"),\n-                                                                  ciSymbols::int_array_signature(), true);\n-  if (size_table_field == NULL) {\n-    \/\/ Something wrong so give up.\n-    assert(false, \"why can't we find Integer.sizeTable?\");\n-    return;\n-  }\n-\n@@ -1171,31 +1163,1 @@\n-Node* PhaseStringOpts::fetch_static_field(GraphKit& kit, ciField* field) {\n-  const TypeInstPtr* mirror_type = TypeInstPtr::make(field->holder()->java_mirror());\n-  Node* klass_node = __ makecon(mirror_type);\n-  BasicType bt = field->layout_type();\n-  ciType* field_klass = field->type();\n-\n-  const Type *type;\n-  if( bt == T_OBJECT ) {\n-    if (!field->type()->is_loaded()) {\n-      type = TypeInstPtr::BOTTOM;\n-    } else if (field->is_static_constant()) {\n-      \/\/ This can happen if the constant oop is non-perm.\n-      ciObject* con = field->constant_value().as_object();\n-      \/\/ Do not \"join\" in the previous type; it doesn't add value,\n-      \/\/ and may yield a vacuous result if the field is of interface type.\n-      type = TypeOopPtr::make_from_constant(con, true)->isa_oopptr();\n-      assert(type != NULL, \"field singleton type must be consistent\");\n-      return __ makecon(type);\n-    } else {\n-      type = TypeOopPtr::make_from_klass(field_klass->as_klass());\n-    }\n-  } else {\n-    type = Type::get_const_basic_type(bt);\n-  }\n-\n-  return kit.make_load(NULL, kit.basic_plus_adr(klass_node, field->offset_in_bytes()),\n-                       type, T_OBJECT,\n-                       C->get_alias_index(mirror_type->add_offset(field->offset_in_bytes())),\n-                       MemNode::unordered);\n-}\n-\n+\/\/ Mirror of Integer.stringSize() method, return the count of digits in integer,\n@@ -1204,9 +1166,5 @@\n-    \/\/ Constant integer. Compute constant length using Integer.sizeTable\n-    int arg_val = arg->get_int();\n-    int count = 1;\n-    if (arg_val < 0) {\n-      \/\/ Special case for min_jint - it can't be negated.\n-      if (arg_val == min_jint) {\n-        return __ intcon(11);\n-      }\n-\n+    \/\/ Constant integer. Compute constant length\n+    jint arg_val = arg->get_int();\n+    jint d = 1;\n+    if (arg_val >= 0) {\n+      d = 0;\n@@ -1214,7 +1172,4 @@\n-      count++;\n-\n-    ciArray* size_table = (ciArray*)size_table_field->constant_value().as_object();\n-    for (int i = 0; i < size_table->length(); i++) {\n-      if (arg_val <= size_table->element_value(i).as_int()) {\n-        count += i;\n-        break;\n+    jint p = -10;\n+    for (int i = 1; i < 10; i++) {\n+      if (arg_val > p) {\n+        return __ intcon(i + d);\n@@ -1223,0 +1178,1 @@\n+      p = 10 * p;\n@@ -1224,1 +1180,1 @@\n-    return __ intcon(count);\n+    return __ intcon(10 + d);\n@@ -1227,4 +1183,11 @@\n-  RegionNode *final_merge = new RegionNode(3);\n-  kit.gvn().set_type(final_merge, Type::CONTROL);\n-  Node* final_size = new PhiNode(final_merge, TypeInt::INT);\n-  kit.gvn().set_type(final_size, TypeInt::INT);\n+  \/\/ int d = 1;\n+  \/\/ if (x >= 0) {\n+  \/\/     d = 0;\n+  \/\/     x = -x;\n+  \/\/ }\n+  RegionNode* sign_merge = new RegionNode(3);\n+  kit.gvn().set_type(sign_merge, Type::CONTROL);\n+  Node* digit_cnt = new PhiNode(sign_merge, TypeInt::INT);\n+  kit.gvn().set_type(digit_cnt, TypeInt::INT);\n+  Node* val = new PhiNode(sign_merge, TypeInt::INT);\n+  kit.gvn().set_type(val, TypeInt::INT);\n@@ -1233,1 +1196,1 @@\n-                                      __ Bool(__ CmpI(arg, __ intcon(0x80000000)), BoolTest::ne),\n+                                      __ Bool(__ CmpI(arg, __ intcon(0)), BoolTest::ge),\n@@ -1235,69 +1198,18 @@\n-  Node* is_min = __ IfFalse(iff);\n-  final_merge->init_req(1, is_min);\n-  final_size->init_req(1, __ intcon(11));\n-\n-  kit.set_control(__ IfTrue(iff));\n-  if (kit.stopped()) {\n-    final_merge->init_req(2, C->top());\n-    final_size->init_req(2, C->top());\n-  } else {\n-\n-    \/\/ int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);\n-    RegionNode *r = new RegionNode(3);\n-    kit.gvn().set_type(r, Type::CONTROL);\n-    Node *phi = new PhiNode(r, TypeInt::INT);\n-    kit.gvn().set_type(phi, TypeInt::INT);\n-    Node *size = new PhiNode(r, TypeInt::INT);\n-    kit.gvn().set_type(size, TypeInt::INT);\n-    Node* chk = __ CmpI(arg, __ intcon(0));\n-    Node* p = __ Bool(chk, BoolTest::lt);\n-    IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_FAIR, COUNT_UNKNOWN);\n-    Node* lessthan = __ IfTrue(iff);\n-    Node* greaterequal = __ IfFalse(iff);\n-    r->init_req(1, lessthan);\n-    phi->init_req(1, __ SubI(__ intcon(0), arg));\n-    size->init_req(1, __ intcon(1));\n-    r->init_req(2, greaterequal);\n-    phi->init_req(2, arg);\n-    size->init_req(2, __ intcon(0));\n-    kit.set_control(r);\n-    C->record_for_igvn(r);\n-    C->record_for_igvn(phi);\n-    C->record_for_igvn(size);\n-\n-    \/\/ for (int i=0; ; i++)\n-    \/\/   if (x <= sizeTable[i])\n-    \/\/     return i+1;\n-\n-    \/\/ Add loop predicate first.\n-    kit.add_empty_predicates();\n-    C->set_has_loops(true);\n-\n-    RegionNode *loop = new RegionNode(3);\n-    loop->init_req(1, kit.control());\n-    kit.gvn().set_type(loop, Type::CONTROL);\n-\n-    Node *index = new PhiNode(loop, TypeInt::INT);\n-    index->init_req(1, __ intcon(0));\n-    kit.gvn().set_type(index, TypeInt::INT);\n-    kit.set_control(loop);\n-    Node* sizeTable = fetch_static_field(kit, size_table_field);\n-\n-    Node* value = kit.load_array_element(sizeTable, index, TypeAryPtr::INTS, \/* set_ctrl *\/ false);\n-    C->record_for_igvn(value);\n-    Node* limit = __ CmpI(phi, value);\n-    Node* limitb = __ Bool(limit, BoolTest::le);\n-    IfNode* iff2 = kit.create_and_map_if(kit.control(), limitb, PROB_MIN, COUNT_UNKNOWN);\n-    Node* lessEqual = __ IfTrue(iff2);\n-    Node* greater = __ IfFalse(iff2);\n-\n-    loop->init_req(2, greater);\n-    index->init_req(2, __ AddI(index, __ intcon(1)));\n-\n-    kit.set_control(lessEqual);\n-    C->record_for_igvn(loop);\n-    C->record_for_igvn(index);\n-\n-    final_merge->init_req(2, kit.control());\n-    final_size->init_req(2, __ AddI(__ AddI(index, size), __ intcon(1)));\n-  }\n+  sign_merge->init_req(1, __ IfTrue(iff));\n+  sign_merge->init_req(2, __ IfFalse(iff));\n+  digit_cnt->init_req(1, __ intcon(0));\n+  digit_cnt->init_req(2, __ intcon(1));\n+  val->init_req(1, __ SubI(__ intcon(0), arg));\n+  val->init_req(2, arg);\n+  kit.set_control(sign_merge);\n+\n+  \/\/ int p = -10;\n+  \/\/ for (int i = 1; i < 10; i++) {\n+  \/\/     if (x > p)\n+  \/\/         return i + d;\n+  \/\/     p = 10 * p;\n+  \/\/ }\n+  RegionNode* final_merge = new RegionNode(3);\n+  kit.gvn().set_type(final_merge, Type::CONTROL);\n+  Node* final_size = new PhiNode(final_merge, TypeInt::INT);\n+  kit.gvn().set_type(final_size, TypeInt::INT);\n@@ -1305,0 +1217,35 @@\n+  kit.add_empty_predicates();\n+  C->set_has_loops(true);\n+\n+  RegionNode* loop = new RegionNode(3);\n+  kit.gvn().set_type(loop, Type::CONTROL);\n+  Node* index = new PhiNode(loop, TypeInt::INT);\n+  kit.gvn().set_type(index, TypeInt::INT);\n+  Node* temp = new PhiNode(loop, TypeInt::INT);\n+  kit.gvn().set_type(temp, TypeInt::INT);\n+\n+  loop->init_req(1, kit.control());\n+  index->init_req(1, __ intcon(1));\n+  temp->init_req(1, __ intcon(-10));\n+  kit.set_control(loop);\n+\n+  Node* limit = __ CmpI(index, __ intcon(10));\n+  Node* limitb = __ Bool(limit, BoolTest::lt);\n+  IfNode* iff2 = kit.create_and_map_if(kit.control(), limitb, PROB_MIN, COUNT_UNKNOWN);\n+  Node* limit_less = __ IfTrue(iff2);\n+  kit.set_control(limit_less);\n+\n+  Node* cmp = __ CmpI(val, temp);\n+  Node* cmpb = __ Bool(cmp, BoolTest::gt);\n+  IfNode* iff3 = kit.create_and_map_if(kit.control(), cmpb, PROB_MIN, COUNT_UNKNOWN);\n+  Node* cmp_le = __ IfFalse(iff3);\n+  kit.set_control(cmp_le);\n+\n+  loop->init_req(2, kit.control());\n+  index->init_req(2, __ AddI(index, __ intcon(1)));\n+  temp->init_req(2, __ MulI(temp, __ intcon(10)));\n+\n+  final_merge->init_req(1, __ IfFalse(iff2));\n+  final_merge->init_req(2, __ IfTrue(iff3));\n+  final_size->init_req(1, __ AddI(digit_cnt, __ intcon(10)));\n+  final_size->init_req(2, __ AddI(digit_cnt, index));\n@@ -1306,0 +1253,4 @@\n+\n+  C->record_for_igvn(sign_merge);\n+  C->record_for_igvn(digit_cnt);\n+  C->record_for_igvn(val);\n@@ -1308,1 +1259,3 @@\n-\n+  C->record_for_igvn(loop);\n+  C->record_for_igvn(index);\n+  C->record_for_igvn(temp);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":85,"deletions":132,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -5330,0 +5330,5 @@\n+      if (above_centerline(ptr) || ptr == Constant) {\n+        ptr = NotNull;\n+        res_xk = false;\n+        return NOT_SUBTYPE;\n+      }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3219,1 +3219,1 @@\n-  if (thread_obj != nullptr && thread_obj->is_a(vmClasses::BasicVirtualThread_klass())) {\n+  if (thread_obj != nullptr && thread_obj->is_a(vmClasses::BaseVirtualThread_klass())) {\n@@ -4072,7 +4072,0 @@\n-  \/\/ No JVM TI with --enable-preview and no continuations support.\n-  if (!VMContinuations && Arguments::enable_preview() && JvmtiExport::is_jvmti_version(version)) {\n-    *penv = nullptr;\n-    ret = JNI_EVERSION;\n-    return ret;\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -931,0 +931,2 @@\n+  HandleMark hm(current);\n+  Handle self_tobj;\n@@ -933,2 +935,0 @@\n-  JavaThread* java_thread = nullptr;\n-  oop thread_oop = nullptr;\n@@ -938,0 +938,2 @@\n+    JavaThread* java_thread = nullptr;\n+    oop thread_oop = nullptr;\n@@ -949,0 +951,2 @@\n+    \/\/ protect thread_oop as a safepoint can be reached in disabler destructor\n+    self_tobj = Handle(current, thread_oop);\n@@ -951,1 +955,1 @@\n-  err = suspend_thread(thread_oop, current, \/* single_suspend *\/ true, nullptr);\n+  err = suspend_thread(self_tobj(), current, \/* single_suspend *\/ true, nullptr);\n@@ -963,1 +967,1 @@\n-  Handle self_tobj = Handle(current, nullptr);\n+  Handle self_tobj;\n@@ -1011,3 +1015,0 @@\n-  if (!Continuations::enabled()) {\n-    return JVMTI_ERROR_NONE; \/\/ Nothing to do when there are no virtual threads;\n-  }\n@@ -1016,1 +1017,1 @@\n-  Handle self_tobj = Handle(current, nullptr);\n+  Handle self_tobj;\n@@ -1029,1 +1030,1 @@\n-    \/\/ Collect threads from except_list for which resumed status must be restored.\n+    \/\/ Collect threads from except_list for which resumed status must be restored (only for VirtualThread case)\n@@ -1033,1 +1034,1 @@\n-      if (!JvmtiVTSuspender::is_vthread_suspended(thread_oop)) {\n+      if (java_lang_VirtualThread::is_instance(thread_oop) && !JvmtiVTSuspender::is_vthread_suspended(thread_oop)) {\n@@ -1045,3 +1046,4 @@\n-          java_lang_VirtualThread::is_instance(vt_oop) &&\n-          JvmtiEnvBase::is_vthread_alive(vt_oop) &&\n-          !JvmtiVTSuspender::is_vthread_suspended(vt_oop) &&\n+          ((java_lang_VirtualThread::is_instance(vt_oop) &&\n+            JvmtiEnvBase::is_vthread_alive(vt_oop) &&\n+            !JvmtiVTSuspender::is_vthread_suspended(vt_oop)) ||\n+            (vt_oop->is_a(vmClasses::BoundVirtualThread_klass()) && !java_thread->is_suspended())) &&\n@@ -1131,3 +1133,0 @@\n-  if (!Continuations::enabled()) {\n-    return JVMTI_ERROR_NONE; \/\/ Nothing to do when there are no virtual threads;\n-  }\n@@ -1142,1 +1141,1 @@\n-  \/\/ Collect threads from except_list for which suspended status must be restored.\n+  \/\/ Collect threads from except_list for which suspended status must be restored (only for VirtualThread case)\n@@ -1146,1 +1145,1 @@\n-    if (JvmtiVTSuspender::is_vthread_suspended(thread_oop)) {\n+    if (java_lang_VirtualThread::is_instance(thread_oop) && JvmtiVTSuspender::is_vthread_suspended(thread_oop)) {\n@@ -1158,3 +1157,4 @@\n-        java_lang_VirtualThread::is_instance(vt_oop) &&\n-        JvmtiEnvBase::is_vthread_alive(vt_oop) &&\n-        JvmtiVTSuspender::is_vthread_suspended(vt_oop) &&\n+        ((java_lang_VirtualThread::is_instance(vt_oop) &&\n+          JvmtiEnvBase::is_vthread_alive(vt_oop) &&\n+          JvmtiVTSuspender::is_vthread_suspended(vt_oop)) ||\n+          (vt_oop->is_a(vmClasses::BoundVirtualThread_klass()) && java_thread->is_suspended())) &&\n@@ -1193,1 +1193,1 @@\n-  if (thread_oop != nullptr && java_lang_VirtualThread::is_instance(thread_oop)) {\n+  if (thread_oop != nullptr && thread_oop->is_a(vmClasses::BaseVirtualThread_klass())) {\n@@ -1563,0 +1563,4 @@\n+  if (thread_oop->is_a(vmClasses::BaseVirtualThread_klass())) {\n+    \/\/ No support for virtual threads.\n+    return JVMTI_ERROR_UNSUPPORTED_OPERATION;\n+  }\n@@ -1567,4 +1571,0 @@\n-  if (java_lang_VirtualThread::is_instance(thread_oop)) {\n-    \/\/ No support for virtual threads.\n-    return JVMTI_ERROR_UNSUPPORTED_OPERATION;\n-  }\n@@ -1887,1 +1887,1 @@\n-  if (thread_obj != nullptr && java_lang_VirtualThread::is_instance(thread_obj)) {\n+  if (thread_obj != nullptr && thread_obj->is_a(vmClasses::BaseVirtualThread_klass())) {\n@@ -3901,1 +3901,1 @@\n-      \/\/ No support for virtual threads (yet).\n+      \/\/ No support for a VirtualThread (yet).\n@@ -3928,1 +3928,1 @@\n-  if (thread_oop != nullptr && java_lang_VirtualThread::is_instance(thread_oop)) {\n+  if (thread_oop != nullptr && thread_oop->is_a(vmClasses::BaseVirtualThread_klass())) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1277,16 +1277,0 @@\n-void JvmtiExport::check_vthread_and_suspend_at_safepoint(JavaThread *thread) {\n-  oop vt = thread->jvmti_vthread();\n-\n-  if (vt != nullptr && java_lang_VirtualThread::is_instance(vt)) {\n-    int64_t id = java_lang_Thread::thread_id(vt);\n-\n-    ThreadBlockInVM tbivm(thread);\n-    MonitorLocker ml(JvmtiVTMSTransition_lock, Mutex::_no_safepoint_check_flag);\n-\n-    \/\/ block while vthread is externally suspended\n-    while (JvmtiVTSuspender::is_vthread_suspended(id)) {\n-      ml.wait();\n-    }\n-  }\n-}\n-\n@@ -1471,0 +1455,8 @@\n+  if (JvmtiExport::can_support_virtual_threads() && thread->threadObj()->is_a(vmClasses::BoundVirtualThread_klass())) {\n+    \/\/ Check for VirtualThreadStart event instead.\n+    HandleMark hm(thread);\n+    Handle vthread(thread, thread->threadObj());\n+    JvmtiExport::post_vthread_start((jthread)vthread.raw_value());\n+    return;\n+  }\n+\n@@ -1507,0 +1499,8 @@\n+  if (JvmtiExport::can_support_virtual_threads() && thread->threadObj()->is_a(vmClasses::BoundVirtualThread_klass())) {\n+    \/\/ Check for VirtualThreadEnd event instead.\n+    HandleMark hm(thread);\n+    Handle vthread(thread, thread->threadObj());\n+    JvmtiExport::post_vthread_end((jthread)vthread.raw_value());\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3568,1 +3568,2 @@\n-    if (os::same_files((const char*)get_default_shared_archive_path(), ArchiveClassesAtExit)) {\n+    char* shared_archive_path = get_default_shared_archive_path();\n+    if (os::same_files(shared_archive_path, ArchiveClassesAtExit)) {\n@@ -3570,1 +3571,1 @@\n-        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", get_default_shared_archive_path());\n+        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", shared_archive_path);\n@@ -3572,0 +3573,1 @@\n+    FREE_C_HEAP_ARRAY(char, shared_archive_path);\n@@ -4364,75 +4366,0 @@\n-\n-bool Arguments::parse_malloc_limit_size(const char* s, size_t* out) {\n-  julong limit = 0;\n-  Arguments::ArgsRange range = parse_memory_size(s, &limit, 1, SIZE_MAX);\n-  switch (range) {\n-  case ArgsRange::arg_in_range:\n-    *out = (size_t)limit;\n-    return true;\n-  case ArgsRange::arg_too_big: \/\/ only possible on 32-bit\n-    vm_exit_during_initialization(\"MallocLimit: too large\", s);\n-    break;\n-  case ArgsRange::arg_too_small:\n-    vm_exit_during_initialization(\"MallocLimit: limit must be > 0\");\n-    break;\n-  default:\n-    break;\n-  }\n-  return false;\n-}\n-\n-\/\/ Helper for parse_malloc_limits\n-void Arguments::parse_single_category_limit(char* expression, size_t limits[mt_number_of_types]) {\n-  \/\/ <category>:<limit>\n-  char* colon = ::strchr(expression, ':');\n-  if (colon == nullptr) {\n-    vm_exit_during_initialization(\"MallocLimit: colon missing\", expression);\n-  }\n-  *colon = '\\0';\n-  MEMFLAGS f = NMTUtil::string_to_flag(expression);\n-  if (f == mtNone) {\n-    vm_exit_during_initialization(\"MallocLimit: invalid nmt category\", expression);\n-  }\n-  if (parse_malloc_limit_size(colon + 1, limits + (int)f) == false) {\n-    vm_exit_during_initialization(\"Invalid MallocLimit size\", colon + 1);\n-  }\n-}\n-\n-void Arguments::parse_malloc_limits(size_t* total_limit, size_t limits[mt_number_of_types]) {\n-\n-  \/\/ Reset output to 0\n-  *total_limit = 0;\n-  for (int i = 0; i < mt_number_of_types; i ++) {\n-    limits[i] = 0;\n-  }\n-\n-  \/\/ We are done if the option is not given.\n-  if (MallocLimit == nullptr) {\n-    return;\n-  }\n-\n-  \/\/ Global form?\n-  if (parse_malloc_limit_size(MallocLimit, total_limit)) {\n-    return;\n-  }\n-\n-  \/\/ No. So it must be in category-specific form: MallocLimit=<nmt category>:<size>[,<nmt category>:<size> ..]\n-  char* copy = os::strdup(MallocLimit);\n-  if (copy == nullptr) {\n-    vm_exit_out_of_memory(strlen(MallocLimit), OOM_MALLOC_ERROR, \"MallocLimit\");\n-  }\n-\n-  char* p = copy, *q;\n-  do {\n-    q = p;\n-    p = ::strchr(q, ',');\n-    if (p != nullptr) {\n-      *p = '\\0';\n-      p ++;\n-    }\n-    parse_single_category_limit(q, limits);\n-  } while (p != nullptr);\n-\n-  os::free(copy);\n-\n-}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":77,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -481,4 +481,0 @@\n-  \/\/ Helpers for parse_malloc_limits\n-  static bool parse_malloc_limit_size(const char* s, size_t* out);\n-  static void parse_single_category_limit(char* expression, size_t limits[mt_number_of_types]);\n-\n@@ -657,10 +653,0 @@\n-  \/\/ Parse diagnostic NMT switch \"MallocLimit\" and return the found limits.\n-  \/\/ 1) If option is not given, it will set all limits to 0 (aka \"no limit\").\n-  \/\/ 2) If option is given in the global form (-XX:MallocLimit=<size>), it\n-  \/\/    will return the size in *total_limit.\n-  \/\/ 3) If option is given in its per-NMT-category form (-XX:MallocLimit=<category>:<size>[,<category>:<size>]),\n-  \/\/    it will return all found limits in the limits array.\n-  \/\/ 4) If option is malformed, it will exit the VM.\n-  \/\/ For (2) and (3), limits not affected by the switch will be set to 0.\n-  static void parse_malloc_limits(size_t* total_limit, size_t limits[mt_number_of_types]);\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1207,3 +1207,0 @@\n-  develop(bool, VerifyThread, false,                                        \\\n-          \"Watch the thread register for corruption (SPARC only)\")          \\\n-                                                                            \\\n@@ -1362,7 +1359,2 @@\n-  product(uintx, MallocMaxTestWords,     0, DIAGNOSTIC,                     \\\n-          \"If non-zero, maximum number of words that malloc\/realloc can \"   \\\n-          \"allocate (for testing only)\")                                    \\\n-          range(0, max_uintx)                                               \\\n-                                                                            \\\n-          \"Limit malloc allocation size from VM. Reaching the limit will \"  \\\n-          \"trigger a fatal error. This feature requires \"                   \\\n+          \"Limit malloc allocation size from VM. Reaching a limit will \"    \\\n+          \"trigger an action (see flag). This feature requires \"            \\\n@@ -1372,4 +1364,11 @@\n-          \"- MallocLimit=<size> to set a total limit. \"                     \\\n-          \"- MallocLimit=<NMT category>:<size>[,<NMT category>:<size>...] \" \\\n-          \"  to set one or more category-specific limits.\"                  \\\n-          \"Example: -XX:MallocLimit=compiler:500m\")                         \\\n+          \"\\\"-XX:MallocLimit=<size>[:<flag>]\\\" sets a total limit.\"         \\\n+          \"\\\"-XX:MallocLimit=<category>:<size>[:<flag>][,<category>:<size>[:<flag>] ...]\\\"\" \\\n+          \"sets one or more category-specific limits.\"                      \\\n+          \"<flag> defines the action upon reaching the limit:\"              \\\n+          \"\\\"fatal\\\": end VM with a fatal error at the allocation site\"     \\\n+          \"\\\"oom\\\"  : will mimic a native OOM\"                              \\\n+          \"If <flag> is omitted, \\\"fatal\\\" is the default.\"                 \\\n+          \"Examples:\\n\"                                                     \\\n+          \"-XX:MallocLimit=2g\"                                              \\\n+          \"-XX:MallocLimit=2g:oom\"                                          \\\n+          \"-XX:MallocLimit=compiler:200m:oom,code:100m\")                    \\\n@@ -1442,1 +1441,1 @@\n-          \"options: balanced, aggressive, none\")                            \\\n+          \"options: balanced, aggressive\")                                  \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  _jvmti_vthread = OopHandle(_thread_oop_storage, nullptr);\n+  _jvmti_vthread = OopHandle(_thread_oop_storage, p->is_a(vmClasses::BoundVirtualThread_klass()) ? p : nullptr);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"services\/nmtDCmd.hpp\"\n@@ -66,0 +67,1 @@\n+#include \"mallocInfoDcmd.hpp\"\n@@ -82,1 +84,1 @@\n-void DCmdRegistrant::register_dcmds(){\n+void DCmd::register_dcmds(){\n@@ -130,0 +132,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<MallocInfoDcmd>(full_export, true, false));\n@@ -154,4 +157,1 @@\n-}\n-#ifndef HAVE_EXTRA_DCMD\n-void DCmdRegistrant::register_dcmds_ext(){\n-   \/\/ Do nothing here\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<NMTDCmd>(full_export, true, false));\n@@ -160,2 +160,0 @@\n-#endif\n-\n@@ -808,1 +806,2 @@\n-          output()->print_cr(\"%s\", out);\n+          \/\/ Avoid using print_cr() because length maybe longer than O_BUFLEN\n+          output()->print_raw_cr(out);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -318,2 +318,2 @@\n-        static final int PROXY_INTERFACE_LIMIT = Math.max(0, Math.min(65535, GetIntegerAction\n-                .privilegedGetProperty(\"jdk.serialProxyInterfaceLimit\", 65535)));\n+        static final int PROXY_INTERFACE_LIMIT = Math.clamp(GetIntegerAction\n+                .privilegedGetProperty(\"jdk.serialProxyInterfaceLimit\", 65535), 0, 65535);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1906,0 +1906,3 @@\n+     * @implNote\n+     * The initiation of the shutdown sequence is logged by {@link Runtime#exit(int)}.\n+     *\n@@ -2479,1 +2482,1 @@\n-                return String.newStringUTF8NoRepl(bytes, off, len);\n+                return String.newStringUTF8NoRepl(bytes, off, len, true);\n@@ -2686,0 +2689,4 @@\n+\n+            public String getLoaderNameID(ClassLoader loader) {\n+                return loader.nameAndId();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-    \/\/ Used to ensure that each spun class name is unique\n+    \/\/ Used to ensure that dumped class files for failed definitions have a unique class name\n@@ -124,1 +124,1 @@\n-    private final String lambdaClassName;            \/\/ Generated name for the generated class \"X$$Lambda$1\"\n+    private final String lambdaClassName;            \/\/ Generated name for the generated class \"X$$Lambda\"\n@@ -214,1 +214,1 @@\n-        return name.replace('.', '\/') + \"$$Lambda$\" + counter.incrementAndGet();\n+        return name.replace('.', '\/') + \"$$Lambda\";\n@@ -306,1 +306,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -378,13 +377,0 @@\n-        \/\/ If requested, dump out to a file for debugging purposes\n-        if (dumper != null) {\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                @Override\n-                public Void run() {\n-                    dumper.dumpClass(lambdaClassName, classBytes);\n-                    return null;\n-                }\n-            }, null,\n-            new FilePermission(\"<<ALL FILES>>\", \"read, write\"),\n-            \/\/ createDirectories may need it\n-            new PropertyPermission(\"user.dir\", \"read\"));\n-        }\n@@ -393,6 +379,23 @@\n-            Lookup lookup;\n-            if (useImplMethodHandle) {\n-                lookup = caller.defineHiddenClassWithClassData(classBytes, implementation, !disableEagerInitialization,\n-                                                               NESTMATE, STRONG);\n-            } else {\n-                lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n+            Lookup lookup = null;\n+            try {\n+                if (useImplMethodHandle) {\n+                    lookup = caller.defineHiddenClassWithClassData(classBytes, implementation, !disableEagerInitialization,\n+                                                                   NESTMATE, STRONG);\n+                } else {\n+                    lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);\n+                }\n+                return lookup.lookupClass();\n+            } finally {\n+                \/\/ If requested, dump out to a file for debugging purposes\n+                if (dumper != null) {\n+                    String name;\n+                    if (lookup != null) {\n+                        String definedName = lookup.lookupClass().getName();\n+                        int suffixIdx = definedName.lastIndexOf('\/');\n+                        assert suffixIdx != -1;\n+                        name = lambdaClassName + '.' + definedName.substring(suffixIdx + 1);\n+                    } else {\n+                        name = lambdaClassName + \".failed-\" + counter.incrementAndGet();\n+                    }\n+                    doDump(name, classBytes);\n+                }\n@@ -400,1 +403,0 @@\n-            return lookup.lookupClass();\n@@ -408,0 +410,14 @@\n+    @SuppressWarnings(\"removal\")\n+    private void doDump(final String className, final byte[] classBytes) {\n+        AccessController.doPrivileged(new PrivilegedAction<>() {\n+            @Override\n+            public Void run() {\n+                dumper.dumpClass(className, classBytes);\n+                return null;\n+            }\n+        }, null,\n+        new FilePermission(\"<<ALL FILES>>\", \"read, write\"),\n+        \/\/ createDirectories may need it\n+        new PropertyPermission(\"user.dir\", \"read\"));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":41,"deletions":25,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2338,1 +2338,1 @@\n-         * {@bytes} denotes a class in a different package than the lookup class\n+         * {@code bytes} denotes a class in a different package than the lookup class\n@@ -2356,1 +2356,1 @@\n-         * {@bytes} denotes a class in a different package than the lookup class\n+         * {@code bytes} denotes a class in a different package than the lookup class\n@@ -2377,1 +2377,1 @@\n-         * {@bytes} denotes a class in a different package than the lookup class\n+         * {@code bytes} denotes a class in a different package than the lookup class\n@@ -5222,1 +5222,1 @@\n-     * @throws IllegalArgumentException if (@code pos) is less than {@code 0} or greater than\n+     * @throws IllegalArgumentException if {@code pos} is less than {@code 0} or greater than\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -335,1 +336,1 @@\n-        long size = Wrapper.forPrimitiveType(carrier).bitWidth() \/ 8;\n+        long size = Utils.byteWidthOfPrimitive(carrier);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -882,1 +882,1 @@\n-                        \" referenced from a method is not visible from class loader\");\n+                        \" referenced from a method is not visible from class loader: \" + JLA.getLoaderNameID(ld));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -607,0 +607,5 @@\n+    \/**\n+     * Returns '<loader-name>' @<id> if classloader has a name\n+     * explicitly set otherwise <qualified-class-name> @<id>\n+     *\/\n+    String getLoaderNameID(ClassLoader loader);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -492,1 +492,1 @@\n-     * @returnss the {@code writeReplace} MethodHandle or {@code null} if not found\n+     * @return the {@code writeReplace} MethodHandle or {@code null} if not found\n@@ -502,1 +502,1 @@\n-     * @returns the {@code writeReplace} MethodHandle or {@code null} if not found\n+     * @return the {@code writeReplace} MethodHandle or {@code null} if not found\n@@ -513,1 +513,1 @@\n-     * @returns a MethodHandle for the method or {@code null} if not found or\n+     * @return a MethodHandle for the method or {@code null} if not found or\n@@ -580,1 +580,1 @@\n-     * @returns the eof constructor for OptionalDataException\n+     * @return the eof constructor for OptionalDataException\n@@ -744,1 +744,1 @@\n-     * @returns true if the two classes are in the same classloader and package\n+     * @return true if the two classes are in the same classloader and package\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-     * Flag that marks potentially ambiguous overloads\n+     * Currently available: Bit 48.\n@@ -313,1 +313,0 @@\n-    public static final long POTENTIALLY_AMBIGUOUS = 1L<<48;\n@@ -577,1 +576,1 @@\n-        POTENTIALLY_AMBIGUOUS(Flags.POTENTIALLY_AMBIGUOUS),\n+        \/\/ Bit 48 is currently available\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -667,1 +667,1 @@\n-     * {@see IntersectionClassType} and (ii) union types {@see UnionClassType}.\n+     * {@link IntersectionClassType} and (ii) union types {@link UnionClassType}.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;\n@@ -184,1 +183,1 @@\n-    public AnnotationType annotationTargetType(Attribute.Compound a, Symbol s) {\n+    public AnnotationType annotationTargetType(JCTree pos, Attribute.Compound a, Symbol s) {\n@@ -192,1 +191,1 @@\n-                        .map(attr -> targetToAnnotationType(attr, s))\n+                        .map(attr -> targetToAnnotationType(pos, a, attr, s))\n@@ -208,1 +207,1 @@\n-    private AnnotationType targetToAnnotationType(Attribute a, Symbol s) {\n+    private AnnotationType targetToAnnotationType(JCTree pos, Attribute.Compound anno, Attribute a, Symbol s) {\n@@ -258,2 +257,1 @@\n-            Assert.error(\"annotationTargetType(): unrecognized Attribute name \" + e.value.name +\n-                    \" (\" + e.value.name.getClass() + \")\");\n+            \/\/ there is an erroneous target, an error should have been reported already\n@@ -309,2 +307,2 @@\n-        private void separateAnnotationsKinds(JCTree typetree, Type type,\n-                                              Symbol sym, TypeAnnotationPosition pos)\n+        private void separateAnnotationsKinds(JCTree pos, JCTree typetree, Type type,\n+                                              Symbol sym, TypeAnnotationPosition typeAnnotationPosition)\n@@ -318,1 +316,1 @@\n-                switch (annotationTargetType(a, sym)) {\n+                switch (annotationTargetType(pos, a, sym)) {\n@@ -324,1 +322,1 @@\n-                        Attribute.TypeCompound ta = toTypeCompound(a, pos);\n+                        Attribute.TypeCompound ta = toTypeCompound(a, typeAnnotationPosition);\n@@ -329,1 +327,1 @@\n-                        Attribute.TypeCompound ta = toTypeCompound(a, pos);\n+                        Attribute.TypeCompound ta = toTypeCompound(a, typeAnnotationPosition);\n@@ -359,1 +357,1 @@\n-                typeWithAnnotations(typetree, type, typeAnnotations, typeAnnotations, pos);\n+                typeWithAnnotations(typetree, type, typeAnnotations, typeAnnotations, typeAnnotationPosition);\n@@ -368,1 +366,1 @@\n-            type = typeWithAnnotations(typetree, type, typeAnnotations, onlyTypeAnnos.toList(), pos);\n+            type = typeWithAnnotations(typetree, type, typeAnnotations, onlyTypeAnnos.toList(), typeAnnotationPosition);\n@@ -451,1 +449,1 @@\n-                return rewriteArrayType((ArrayType)type, annotations, pos);\n+                return rewriteArrayType(typetree, (ArrayType)type, annotations, onlyTypeAnnotations, pos);\n@@ -560,43 +558,3 @@\n-        private Type rewriteArrayType(ArrayType type, List<TypeCompound> annotations, TypeAnnotationPosition pos) {\n-            ArrayType tomodify = new ArrayType(type);\n-            if (type.isVarargs()) {\n-                tomodify = tomodify.makeVarargs();\n-            }\n-            ArrayType res = tomodify;\n-\n-            List<TypePathEntry> loc = List.nil();\n-\n-            \/\/ peel one and update loc\n-            Type tmpType = type.elemtype;\n-            loc = loc.prepend(TypePathEntry.ARRAY);\n-\n-            while (tmpType.hasTag(TypeTag.ARRAY)) {\n-                ArrayType arr = (ArrayType)tmpType;\n-\n-                \/\/ Update last type with new element type\n-                ArrayType tmp = new ArrayType(arr);\n-                tomodify.elemtype = tmp;\n-                tomodify = tmp;\n-\n-                tmpType = arr.elemtype;\n-                loc = loc.prepend(TypePathEntry.ARRAY);\n-            }\n-\n-            \/\/ Fix innermost element type\n-            Type elemType;\n-            if (tmpType.getMetadata() != null) {\n-                List<TypeCompound> tcs;\n-                if (tmpType.getAnnotationMirrors().isEmpty()) {\n-                    tcs = annotations;\n-                } else {\n-                    \/\/ Special case, lets prepend\n-                    tcs =  annotations.appendList(tmpType.getAnnotationMirrors());\n-                }\n-                elemType = tmpType.cloneWithMetadata(tmpType\n-                        .getMetadata()\n-                        .without(Kind.ANNOTATIONS)\n-                        .combine(new TypeMetadata.Annotations(tcs)));\n-            } else {\n-                elemType = tmpType.cloneWithMetadata(new TypeMetadata(new TypeMetadata.Annotations(annotations)));\n-            }\n-            tomodify.elemtype = elemType;\n+        private Type rewriteArrayType(JCTree typetree, ArrayType type, List<TypeCompound> annotations,\n+                                      List<Attribute.TypeCompound> onlyTypeAnnotations, TypeAnnotationPosition pos) {\n+            ArrayType res = new ArrayType(type);\n@@ -605,1 +563,1 @@\n-            pos.location = loc;\n+            pos.location = pos.location.append(TypePathEntry.ARRAY);\n@@ -607,0 +565,1 @@\n+            res.elemtype = typeWithAnnotations(arrayElemTypeTree(typetree), type.elemtype, annotations, onlyTypeAnnotations, pos);\n@@ -610,0 +569,7 @@\n+        private JCTree arrayElemTypeTree(JCTree typetree) {\n+            if (typetree.getKind() == JCTree.Kind.ANNOTATED_TYPE) {\n+                typetree = ((JCAnnotatedType) typetree).underlyingType;\n+            }\n+            return ((JCArrayTypeTree) typetree).elemtype;\n+        }\n+\n@@ -1170,1 +1136,1 @@\n-                        separateAnnotationsKinds(tree, null, tree.sym, pos);\n+                        separateAnnotationsKinds(tree, tree, null, tree.sym, pos);\n@@ -1174,1 +1140,1 @@\n-                        separateAnnotationsKinds(tree.restype,\n+                        separateAnnotationsKinds(tree, tree.restype,\n@@ -1187,1 +1153,1 @@\n-                        separateAnnotationsKinds(tree.recvparam.vartype, tree.recvparam.sym.type, tree.recvparam.sym, pos);\n+                        separateAnnotationsKinds(tree, tree.recvparam.vartype, tree.recvparam.sym.type, tree.recvparam.sym, pos);\n@@ -1200,1 +1166,1 @@\n-                            separateAnnotationsKinds(param.vartype, param.sym.type, param.sym, pos);\n+                            separateAnnotationsKinds(param, param.vartype, param.sym.type, param.sym, pos);\n@@ -1242,1 +1208,1 @@\n-                                separateAnnotationsKinds(param.vartype, param.sym.type, param.sym, pos);\n+                                separateAnnotationsKinds(param, param.vartype, param.sym.type, param.sym, pos);\n@@ -1275,1 +1241,1 @@\n-                    separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);\n+                    separateAnnotationsKinds(tree, tree.vartype, tree.sym.type, tree.sym, pos);\n@@ -1282,1 +1248,1 @@\n-                    separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);\n+                    separateAnnotationsKinds(tree, tree.vartype, tree.sym.type, tree.sym, pos);\n@@ -1288,1 +1254,1 @@\n-                separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);\n+                separateAnnotationsKinds(tree, tree.vartype, tree.sym.type, tree.sym, pos);\n@@ -1293,1 +1259,1 @@\n-                separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);\n+                separateAnnotationsKinds(tree, tree.vartype, tree.sym.type, tree.sym, pos);\n@@ -1298,1 +1264,1 @@\n-                separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);\n+                separateAnnotationsKinds(tree, tree.vartype, tree.sym.type, tree.sym, pos);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":34,"deletions":68,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2995,1 +2995,1 @@\n-     * of all the other signatures and whose return type is more specific {@see MostSpecificReturnCheck}.\n+     * of all the other signatures and whose return type is more specific {@link MostSpecificReturnCheck}.\n@@ -3856,1 +3856,1 @@\n-     * Collect types into a new closure (using a @code{ClosureHolder})\n+     * Collect types into a new closure (using a {@code ClosureHolder})\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-        JCFieldAccess s = (JCFieldAccess)tree.qualid;\n+        JCFieldAccess s = tree.qualid;\n@@ -515,1 +515,1 @@\n-         * Should {@link Attr#attribTree} use the {@ArgumentAttr} visitor instead of this one?\n+         * Should {@link Attr#attribTree} use the {@code ArgumentAttr} visitor instead of this one?\n@@ -517,1 +517,1 @@\n-         * @return true if {@ArgumentAttr} should be used.\n+         * @return true if {@code ArgumentAttr} should be used.\n@@ -5674,0 +5674,1 @@\n+            chk.checkPotentiallyAmbiguousOverloads(tree, c.type);\n@@ -5770,1 +5771,1 @@\n-            chk.validateTypeAnnotation(tree, false);\n+            chk.validateTypeAnnotation(tree, null, false);\n@@ -5779,1 +5780,1 @@\n-            chk.validateTypeAnnotations(tree.annotations, true);\n+            chk.validateTypeAnnotations(tree.annotations, tree.type.tsym, true);\n@@ -5977,1 +5978,1 @@\n-                        typeAnnotations.annotationTargetType(ai.attribute, sym) == TypeAnnotations.AnnotationType.DECLARATION) {\n+                        typeAnnotations.annotationTargetType(ai, ai.attribute, sym) == TypeAnnotations.AnnotationType.DECLARATION) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.function.BiPredicate;\n+import java.util.function.Consumer;\n@@ -32,0 +34,3 @@\n+import java.util.function.ToIntBiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n@@ -71,0 +76,1 @@\n+import static com.sun.tools.javac.code.Scope.LookupKind.RECURSIVE;\n@@ -93,0 +99,4 @@\n+    \/\/ Flag bits indicating which item(s) chosen from a pair of items\n+    private static final int FIRST = 0x01;\n+    private static final int SECOND = 0x02;\n+\n@@ -2670,1 +2680,1 @@\n-     *  @returns        True if the check completed on all attributed classes\n+     *  @return        True if the check completed on all attributed classes\n@@ -2811,2 +2821,0 @@\n-        List<MethodSymbol> potentiallyAmbiguousList = List.nil();\n-        boolean overridesAny = false;\n@@ -2817,7 +2825,0 @@\n-                if (m1 == sym) {\n-                    continue;\n-                }\n-\n-                if (!overridesAny) {\n-                    potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);\n-                }\n@@ -2827,5 +2828,0 @@\n-            if (m1 != sym) {\n-                overridesAny = true;\n-                potentiallyAmbiguousList = List.nil();\n-            }\n-\n@@ -2861,6 +2857,0 @@\n-\n-        if (!overridesAny) {\n-            for (MethodSymbol m: potentiallyAmbiguousList) {\n-                checkPotentiallyAmbiguousOverloads(pos, site, sym, m);\n-            }\n-        }\n@@ -2887,2 +2877,0 @@\n-                } else {\n-                    checkPotentiallyAmbiguousOverloads(pos, site, sym, (MethodSymbol)s);\n@@ -2977,0 +2965,189 @@\n+    \/** Report warnings for potentially ambiguous method declarations in the given site. *\/\n+    void checkPotentiallyAmbiguousOverloads(JCClassDecl tree, Type site) {\n+\n+        \/\/ Skip if warning not enabled\n+        if (!lint.isEnabled(LintCategory.OVERLOADS))\n+            return;\n+\n+        \/\/ Gather all of site's methods, including overridden methods, grouped by name (except Object methods)\n+        List<java.util.List<MethodSymbol>> methodGroups = methodsGroupedByName(site,\n+            new PotentiallyAmbiguousFilter(site), ArrayList::new);\n+\n+        \/\/ Build the predicate that determines if site is responsible for an ambiguity\n+        BiPredicate<MethodSymbol, MethodSymbol> responsible = buildResponsiblePredicate(site, methodGroups);\n+\n+        \/\/ Now remove overridden methods from each group, leaving only site's actual members\n+        methodGroups.forEach(list -> removePreempted(list, (m1, m2) -> m1.overrides(m2, site.tsym, types, false)));\n+\n+        \/\/ Allow site's own declared methods (only) to apply @SuppressWarnings(\"overloads\")\n+        methodGroups.forEach(list -> list.removeIf(\n+            m -> m.owner == site.tsym && !lint.augment(m).isEnabled(LintCategory.OVERLOADS)));\n+\n+        \/\/ Warn about ambiguous overload method pairs for which site is responsible\n+        methodGroups.forEach(list -> compareAndRemove(list, (m1, m2) -> {\n+\n+            \/\/ See if this is an ambiguous overload for which \"site\" is responsible\n+            if (!potentiallyAmbiguousOverload(site, m1, m2) || !responsible.test(m1, m2))\n+                return 0;\n+\n+            \/\/ Locate the warning at one of the methods, if possible\n+            DiagnosticPosition pos =\n+                m1.owner == site.tsym ? TreeInfo.diagnosticPositionFor(m1, tree) :\n+                m2.owner == site.tsym ? TreeInfo.diagnosticPositionFor(m2, tree) :\n+                tree.pos();\n+\n+            \/\/ Log the warning\n+            log.warning(LintCategory.OVERLOADS, pos,\n+                Warnings.PotentiallyAmbiguousOverload(\n+                    m1.asMemberOf(site, types), m1.location(),\n+                    m2.asMemberOf(site, types), m2.location()));\n+\n+            \/\/ Don't warn again for either of these two methods\n+            return FIRST | SECOND;\n+        }));\n+    }\n+\n+    \/** Build a predicate that determines, given two methods that are members of the given class,\n+     *  whether the class should be held \"responsible\" if the methods are potentially ambiguous.\n+     *\n+     *  Sometimes ambiguous methods are unavoidable because they're inherited from a supertype.\n+     *  For example, any subtype of Spliterator.OfInt will have ambiguities for both\n+     *  forEachRemaining() and tryAdvance() (in both cases the overloads are IntConsumer and\n+     *  Consumer&lt;? super Integer&gt;). So we only want to \"blame\" a class when that class is\n+     *  itself responsible for creating the ambiguity. We declare that a class C is \"responsible\"\n+     *  for the ambiguity between two methods m1 and m2 if there is no direct supertype T of C\n+     *  such that m1 and m2, or some overrides thereof, both exist in T and are ambiguous in T.\n+     *  As an optimization, we first check if either method is declared in C and does not override\n+     *  any other methods; in this case the class is definitely responsible.\n+     *\/\n+    BiPredicate<MethodSymbol, MethodSymbol> buildResponsiblePredicate(Type site,\n+        List<? extends Collection<MethodSymbol>> methodGroups) {\n+\n+        \/\/ Define the \"overrides\" predicate\n+        BiPredicate<MethodSymbol, MethodSymbol> overrides = (m1, m2) -> m1.overrides(m2, site.tsym, types, false);\n+\n+        \/\/ Map each method declared in site to a list of the supertype method(s) it directly overrides\n+        HashMap<MethodSymbol, ArrayList<MethodSymbol>> overriddenMethodsMap = new HashMap<>();\n+        methodGroups.forEach(list -> {\n+            for (MethodSymbol m : list) {\n+\n+                \/\/ Skip methods not declared in site\n+                if (m.owner != site.tsym)\n+                    continue;\n+\n+                \/\/ Gather all supertype methods overridden by m, directly or indirectly\n+                ArrayList<MethodSymbol> overriddenMethods = list.stream()\n+                  .filter(m2 -> m2 != m && overrides.test(m, m2))\n+                  .collect(Collectors.toCollection(ArrayList::new));\n+\n+                \/\/ Eliminate non-direct overrides\n+                removePreempted(overriddenMethods, overrides);\n+\n+                \/\/ Add to map\n+                overriddenMethodsMap.put(m, overriddenMethods);\n+            }\n+        });\n+\n+        \/\/ Build the predicate\n+        return (m1, m2) -> {\n+\n+            \/\/ Get corresponding supertype methods (if declared in site)\n+            java.util.List<MethodSymbol> overriddenMethods1 = overriddenMethodsMap.get(m1);\n+            java.util.List<MethodSymbol> overriddenMethods2 = overriddenMethodsMap.get(m2);\n+\n+            \/\/ Quick check for the case where a method was added by site itself\n+            if (overriddenMethods1 != null && overriddenMethods1.isEmpty())\n+                return true;\n+            if (overriddenMethods2 != null && overriddenMethods2.isEmpty())\n+                return true;\n+\n+            \/\/ Get each method's corresponding method(s) from supertypes of site\n+            java.util.List<MethodSymbol> supertypeMethods1 = overriddenMethods1 != null ?\n+              overriddenMethods1 : Collections.singletonList(m1);\n+            java.util.List<MethodSymbol> supertypeMethods2 = overriddenMethods2 != null ?\n+              overriddenMethods2 : Collections.singletonList(m2);\n+\n+            \/\/ See if we can blame some direct supertype instead\n+            return types.directSupertypes(site).stream()\n+              .filter(stype -> stype != syms.objectType)\n+              .map(stype -> stype.tsym.type)                \/\/ view supertype in its original form\n+              .noneMatch(stype -> {\n+                for (MethodSymbol sm1 : supertypeMethods1) {\n+                    if (!types.isSubtype(types.erasure(stype), types.erasure(sm1.owner.type)))\n+                        continue;\n+                    for (MethodSymbol sm2 : supertypeMethods2) {\n+                        if (!types.isSubtype(types.erasure(stype), types.erasure(sm2.owner.type)))\n+                            continue;\n+                        if (potentiallyAmbiguousOverload(stype, sm1, sm2))\n+                            return true;\n+                    }\n+                }\n+                return false;\n+            });\n+        };\n+    }\n+\n+    \/** Gather all of site's methods, including overridden methods, grouped and sorted by name,\n+     *  after applying the given filter.\n+     *\/\n+    <C extends Collection<MethodSymbol>> List<C> methodsGroupedByName(Type site,\n+            Predicate<Symbol> filter, Supplier<? extends C> groupMaker) {\n+        Iterable<Symbol> symbols = types.membersClosure(site, false).getSymbols(filter, RECURSIVE);\n+        return StreamSupport.stream(symbols.spliterator(), false)\n+          .map(MethodSymbol.class::cast)\n+          .collect(Collectors.groupingBy(m -> m.name, Collectors.toCollection(groupMaker)))\n+          .entrySet()\n+          .stream()\n+          .sorted(Comparator.comparing(e -> e.getKey().toString()))\n+          .map(Map.Entry::getValue)\n+          .collect(List.collector());\n+    }\n+\n+    \/** Compare elements in a list pair-wise in order to remove some of them.\n+     *  @param list mutable list of items\n+     *  @param comparer returns flag bit(s) to remove FIRST and\/or SECOND\n+     *\/\n+    <T> void compareAndRemove(java.util.List<T> list, ToIntBiFunction<? super T, ? super T> comparer) {\n+        for (int index1 = 0; index1 < list.size() - 1; index1++) {\n+            T item1 = list.get(index1);\n+            for (int index2 = index1 + 1; index2 < list.size(); index2++) {\n+                T item2 = list.get(index2);\n+                int flags = comparer.applyAsInt(item1, item2);\n+                if ((flags & SECOND) != 0)\n+                    list.remove(index2--);          \/\/ remove item2\n+                if ((flags & FIRST) != 0) {\n+                    list.remove(index1--);          \/\/ remove item1\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Remove elements in a list that are preempted by some other element in the list.\n+     *  @param list mutable list of items\n+     *  @param preempts decides if one item preempts another, causing the second one to be removed\n+     *\/\n+    <T> void removePreempted(java.util.List<T> list, BiPredicate<? super T, ? super T> preempts) {\n+        compareAndRemove(list, (item1, item2) -> {\n+            int flags = 0;\n+            if (preempts.test(item1, item2))\n+                flags |= SECOND;\n+            if (preempts.test(item2, item1))\n+                flags |= FIRST;\n+            return flags;\n+        });\n+    }\n+\n+    \/** Filters method candidates for the \"potentially ambiguous method\" check *\/\n+    class PotentiallyAmbiguousFilter extends ClashFilter {\n+\n+        PotentiallyAmbiguousFilter(Type site) {\n+            super(site);\n+        }\n+\n+        @Override\n+        boolean shouldSkip(Symbol s) {\n+            return s.owner.type.tsym == syms.objectType.tsym || super.shouldSkip(s);\n+        }\n+    }\n+\n@@ -2981,1 +3158,1 @@\n-      * lambda would be ambiguous).\n+      * lambda would be ambiguous). This assumes they already have the same name.\n@@ -2983,32 +3160,30 @@\n-    void checkPotentiallyAmbiguousOverloads(DiagnosticPosition pos, Type site,\n-            MethodSymbol msym1, MethodSymbol msym2) {\n-        if (msym1 != msym2 &&\n-                lint.isEnabled(LintCategory.OVERLOADS) &&\n-                (msym1.flags() & POTENTIALLY_AMBIGUOUS) == 0 &&\n-                (msym2.flags() & POTENTIALLY_AMBIGUOUS) == 0) {\n-            Type mt1 = types.memberType(site, msym1);\n-            Type mt2 = types.memberType(site, msym2);\n-            \/\/if both generic methods, adjust type variables\n-            if (mt1.hasTag(FORALL) && mt2.hasTag(FORALL) &&\n-                    types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {\n-                mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);\n-            }\n-            \/\/expand varargs methods if needed\n-            int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());\n-            List<Type> args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);\n-            List<Type> args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);\n-            \/\/if arities don't match, exit\n-            if (args1.length() != args2.length()) return;\n-            boolean potentiallyAmbiguous = false;\n-            while (args1.nonEmpty() && args2.nonEmpty()) {\n-                Type s = args1.head;\n-                Type t = args2.head;\n-                if (!types.isSubtype(t, s) && !types.isSubtype(s, t)) {\n-                    if (types.isFunctionalInterface(s) && types.isFunctionalInterface(t) &&\n-                            types.findDescriptorType(s).getParameterTypes().length() > 0 &&\n-                            types.findDescriptorType(s).getParameterTypes().length() ==\n-                            types.findDescriptorType(t).getParameterTypes().length()) {\n-                        potentiallyAmbiguous = true;\n-                    } else {\n-                        return;\n-                    }\n+    boolean potentiallyAmbiguousOverload(Type site, MethodSymbol msym1, MethodSymbol msym2) {\n+        Assert.check(msym1.name == msym2.name);\n+        if (msym1 == msym2)\n+            return false;\n+        Type mt1 = types.memberType(site, msym1);\n+        Type mt2 = types.memberType(site, msym2);\n+        \/\/if both generic methods, adjust type variables\n+        if (mt1.hasTag(FORALL) && mt2.hasTag(FORALL) &&\n+                types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {\n+            mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);\n+        }\n+        \/\/expand varargs methods if needed\n+        int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());\n+        List<Type> args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);\n+        List<Type> args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);\n+        \/\/if arities don't match, exit\n+        if (args1.length() != args2.length())\n+            return false;\n+        boolean potentiallyAmbiguous = false;\n+        while (args1.nonEmpty() && args2.nonEmpty()) {\n+            Type s = args1.head;\n+            Type t = args2.head;\n+            if (!types.isSubtype(t, s) && !types.isSubtype(s, t)) {\n+                if (types.isFunctionalInterface(s) && types.isFunctionalInterface(t) &&\n+                        types.findDescriptorType(s).getParameterTypes().length() > 0 &&\n+                        types.findDescriptorType(s).getParameterTypes().length() ==\n+                        types.findDescriptorType(t).getParameterTypes().length()) {\n+                    potentiallyAmbiguous = true;\n+                } else {\n+                    return false;\n@@ -3016,12 +3191,2 @@\n-                args1 = args1.tail;\n-                args2 = args2.tail;\n-            }\n-            if (potentiallyAmbiguous) {\n-                \/\/we found two incompatible functional interfaces with same arity\n-                \/\/this means a call site passing an implicit lambda would be ambiguous\n-                msym1.flags_field |= POTENTIALLY_AMBIGUOUS;\n-                msym2.flags_field |= POTENTIALLY_AMBIGUOUS;\n-                log.warning(LintCategory.OVERLOADS, pos,\n-                            Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),\n-                                                                  msym2, msym2.location()));\n-                return;\n+            args1 = args1.tail;\n+            args2 = args2.tail;\n@@ -3030,0 +3195,1 @@\n+        return potentiallyAmbiguous;\n@@ -3213,1 +3379,1 @@\n-    public void validateTypeAnnotations(List<JCAnnotation> annotations, boolean isTypeParameter) {\n+    public void validateTypeAnnotations(List<JCAnnotation> annotations, Symbol s, boolean isTypeParameter) {\n@@ -3215,1 +3381,1 @@\n-            validateTypeAnnotation(a, isTypeParameter);\n+            validateTypeAnnotation(a, s, isTypeParameter);\n@@ -3384,1 +3550,1 @@\n-    public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {\n+    public void validateTypeAnnotation(JCAnnotation a, Symbol s, boolean isTypeParameter) {\n@@ -3386,0 +3552,2 @@\n+        \/\/ we just want to validate that the anotation doesn't have any wrong target\n+        if (s != null) getApplicableTargets(a, s);\n@@ -3714,3 +3882,4 @@\n-            } else\n-                return Optional.empty(); \/\/ Unknown ElementType. This should be an error at declaration site,\n-                                         \/\/ assume applicable.\n+            } else {\n+                log.error(a, Errors.AnnotationUnrecognizedAttributeName(a.type, target));\n+                return Optional.empty(); \/\/ Unknown ElementType\n+            }\n@@ -4322,1 +4491,1 @@\n-            final JCFieldAccess select = (JCFieldAccess) imp.qualid;\n+            final JCFieldAccess select = imp.qualid;\n@@ -4345,1 +4514,1 @@\n-                TypeSymbol tsym = ((JCFieldAccess)imp.qualid).selected.type.tsym;\n+                TypeSymbol tsym = imp.qualid.selected.type.tsym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":245,"deletions":76,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -659,1 +659,1 @@\n-     * (@code expressionType}), and a given record ({@code patternTypeSymbol}),\n+     * ({@code expressionType}), and a given record ({@code patternTypeSymbol}),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3363,1 +3363,1 @@\n-     * {@code ReferenceLookupResult} objects into a (@code Symbol), which is then regarded as the\n+     * {@code ReferenceLookupResult} objects into a {@code Symbol}, which is then regarded as the\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -358,1 +358,2 @@\n-                importAll(make.at(tree.pos()).Import(make.QualIdent(javaLang), false), javaLang, env);\n+                importAll(make.at(tree.pos()).Import(make.Select(make.QualIdent(javaLang.owner), javaLang), false),\n+                    javaLang, env);\n@@ -411,1 +412,1 @@\n-            JCFieldAccess imp = (JCFieldAccess)tree.qualid;\n+            JCFieldAccess imp = tree.qualid;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+import com.sun.tools.javac.util.ByteBuffer.UnderflowException;\n@@ -343,1 +344,6 @@\n-        char res = buf.getChar(bp);\n+        char res;\n+        try {\n+            res = buf.getChar(bp);\n+        } catch (UnderflowException e) {\n+            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n@@ -351,1 +357,5 @@\n-        return buf.getByte(bp++) & 0xFF;\n+        try {\n+            return buf.getByte(bp++) & 0xFF;\n+        } catch (UnderflowException e) {\n+            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n@@ -357,1 +367,6 @@\n-        int res = buf.getInt(bp);\n+        int res;\n+        try {\n+            res = buf.getInt(bp);\n+        } catch (UnderflowException e) {\n+            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n@@ -822,2 +837,3 @@\n-                        int code_length = buf.getInt(bp + 4);\n-                        if ((code_length == 1 && buf.getByte(bp + 8) == (byte) ByteCodes.return_) ||\n+                        try {\n+                            int code_length = buf.getInt(bp + 4);\n+                            if ((code_length == 1 && buf.getByte(bp + 8) == (byte) ByteCodes.return_) ||\n@@ -828,0 +844,3 @@\n+                            }\n+                        } catch (UnderflowException e) {\n+                            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n@@ -1529,1 +1548,6 @@\n-        int numParameters = buf.getByte(bp++) & 0xFF;\n+        int numParameters;\n+        try {\n+            numParameters = buf.getByte(bp++) & 0xFF;\n+        } catch (UnderflowException e) {\n+            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n@@ -1818,1 +1842,6 @@\n-        char c = (char) buf.getByte(bp++);\n+        char c;\n+        try {\n+            c = (char)buf.getByte(bp++);\n+        } catch (UnderflowException e) {\n+            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -4121,1 +4121,1 @@\n-        return toP(F.at(pos).Import(pid, importStatic));\n+        return toP(F.at(pos).Import((JCFieldAccess)pid, importStatic));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -158,0 +158,4 @@\n+# 0: type, 1: name\n+compiler.err.annotation.unrecognized.attribute.name=\\\n+    annotation @{0} has an unknown attribute named ''{1}''\n+\n@@ -2440,0 +2444,3 @@\n+compiler.misc.bad.class.truncated.at.offset=\\\n+    class file truncated at offset {0}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-        public JCTree qualid;\n+        public JCFieldAccess qualid;\n@@ -680,1 +680,1 @@\n-        protected JCImport(JCTree qualid, boolean importStatic) {\n+        protected JCImport(JCFieldAccess qualid, boolean importStatic) {\n@@ -690,1 +690,1 @@\n-        public JCTree getQualifiedIdentifier() { return qualid; }\n+        public JCFieldAccess getQualifiedIdentifier() { return qualid; }\n@@ -3477,1 +3477,1 @@\n-        JCImport Import(JCTree qualid, boolean staticImport);\n+        JCImport Import(JCFieldAccess qualid, boolean staticImport);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -135,0 +135,6 @@\n+    \/** Print character. Should be only used internally for known ASCII characters.\n+     *\/\n+    private void print(char c) throws IOException {\n+        out.write(c);\n+    }\n+\n@@ -250,2 +256,2 @@\n-        if ((flags & ExtendedStandardFlags) != 0) print(\" \");\n-        if ((flags & ANNOTATION) != 0) print(\"@\");\n+        if ((flags & ExtendedStandardFlags) != 0) print(' ');\n+        if ((flags & ANNOTATION) != 0) print('@');\n@@ -265,1 +271,1 @@\n-            print(\" \");\n+            print(' ');\n@@ -282,1 +288,1 @@\n-                    if (pos < dc.length() && dc.charAt(pos) > ' ') print(\" \");\n+                    if (pos < dc.length() && dc.charAt(pos) > ' ') print(' ');\n@@ -304,1 +310,1 @@\n-            print(\"<\");\n+            print('<');\n@@ -306,1 +312,1 @@\n-            print(\">\");\n+            print('>');\n@@ -313,1 +319,1 @@\n-        print(\"{\");\n+        print('{');\n@@ -319,1 +325,1 @@\n-        print(\"}\");\n+        print('}');\n@@ -325,1 +331,1 @@\n-        print(\"{\");\n+        print('{');\n@@ -332,1 +338,1 @@\n-                    print(\",\");\n+                    print(',');\n@@ -340,1 +346,1 @@\n-        print(\";\");\n+        print(';');\n@@ -351,1 +357,1 @@\n-        print(\"}\");\n+        print('}');\n@@ -432,1 +438,1 @@\n-                print(\";\");\n+                print(';');\n@@ -451,1 +457,1 @@\n-                print(\";\");\n+                print(';');\n@@ -453,1 +459,1 @@\n-                print(\" \");\n+                print(' ');\n@@ -471,1 +477,1 @@\n-            print(\";\");\n+            print(';');\n@@ -486,1 +492,1 @@\n-            print(\";\");\n+            print(';');\n@@ -499,1 +505,1 @@\n-            print(\";\");\n+            print(';');\n@@ -514,1 +520,1 @@\n-            print(\";\");\n+            print(';');\n@@ -525,1 +531,1 @@\n-            print(\";\");\n+            print(';');\n@@ -536,1 +542,1 @@\n-            print(\";\");\n+            print(';');\n@@ -552,1 +558,2 @@\n-                print(\"interface \" + tree.name);\n+                print(\"interface \");\n+                print(tree.name);\n@@ -564,1 +571,1 @@\n-                    print(\"enum \" + tree.name);\n+                    print(\"enum \");\n@@ -566,1 +573,2 @@\n-                    print(\"class \" + tree.name);\n+                    print(\"class \");\n+                print(tree.name);\n@@ -581,1 +589,1 @@\n-            print(\" \");\n+            print(' ');\n@@ -607,1 +615,2 @@\n-                print(\" \" + tree.name);\n+                print(' ');\n+                print(tree.name);\n@@ -609,1 +618,1 @@\n-            print(\"(\");\n+            print('(');\n@@ -617,1 +626,1 @@\n-            print(\")\");\n+            print(')');\n@@ -627,1 +636,1 @@\n-                print(\" \");\n+                print(' ');\n@@ -630,1 +639,1 @@\n-                print(\";\");\n+                print(';');\n@@ -652,1 +661,1 @@\n-                                print(\"(\");\n+                                print('(');\n@@ -654,1 +663,1 @@\n-                                print(\")\");\n+                                print(')');\n@@ -657,1 +666,1 @@\n-                                print(\" \");\n+                                print(' ');\n@@ -668,1 +677,1 @@\n-                            print(\"(\");\n+                            print('(');\n@@ -670,1 +679,1 @@\n-                            print(\")\");\n+                            print(')');\n@@ -674,1 +683,1 @@\n-                                print(\"(\");\n+                                print('(');\n@@ -676,1 +685,1 @@\n-                                print(\")\");\n+                                print(')');\n@@ -679,1 +688,1 @@\n-                                print(\" \");\n+                                print(' ');\n@@ -703,1 +712,2 @@\n-                    print(\"... \" + tree.name);\n+                    print(\"... \");\n+                    print(tree.name);\n@@ -706,1 +716,2 @@\n-                    print(\" \" + tree.name);\n+                    print(' ');\n+                    print(tree.name);\n@@ -712,1 +723,1 @@\n-                if (prec == TreeInfo.notExpression) print(\";\");\n+                if (prec == TreeInfo.notExpression) print(';');\n@@ -721,1 +732,1 @@\n-            print(\";\");\n+            print(';');\n@@ -754,1 +765,1 @@\n-                print(\"(\");\n+                print('(');\n@@ -756,1 +767,1 @@\n-                print(\")\");\n+                print(')');\n@@ -758,1 +769,1 @@\n-            print(\";\");\n+            print(';');\n@@ -770,1 +781,1 @@\n-                print(\"(\");\n+                print('(');\n@@ -772,1 +783,1 @@\n-                print(\")\");\n+                print(')');\n@@ -774,1 +785,1 @@\n-            print(\" \");\n+            print(' ');\n@@ -801,1 +812,2 @@\n-                        print(\", \" + vdef.name);\n+                        print(\", \");\n+                        print(vdef.name);\n@@ -837,1 +849,2 @@\n-            print(tree.label + \": \");\n+            print(tree.label);\n+            print(\": \");\n@@ -850,1 +863,1 @@\n-                print(\"(\");\n+                print('(');\n@@ -852,1 +865,1 @@\n-                print(\")\");\n+                print(')');\n@@ -858,1 +871,1 @@\n-            print(\"}\");\n+            print('}');\n@@ -873,1 +886,1 @@\n-                print(\":\");\n+                print(':');\n@@ -929,1 +942,1 @@\n-                print(\"(\");\n+                print('(');\n@@ -931,1 +944,1 @@\n-                print(\")\");\n+                print(')');\n@@ -937,1 +950,1 @@\n-            print(\"}\");\n+            print('}');\n@@ -954,1 +967,1 @@\n-            print(\"(\");\n+            print('(');\n@@ -956,1 +969,1 @@\n-            print(\")\");\n+            print(')');\n@@ -966,1 +979,1 @@\n-            print(\"(\");\n+            print('(');\n@@ -968,1 +981,1 @@\n-            print(\")\");\n+            print(')');\n@@ -980,1 +993,1 @@\n-                print(\"(\");\n+                print('(');\n@@ -982,1 +995,1 @@\n-                print(\")\");\n+                print(')');\n@@ -984,1 +997,1 @@\n-            print(\" \");\n+            print(' ');\n@@ -995,1 +1008,1 @@\n-                print(\"(\");\n+                print('(');\n@@ -1051,1 +1064,1 @@\n-                print(\"(\");\n+                print('(');\n@@ -1053,1 +1066,1 @@\n-                print(\")\");\n+                print(')');\n@@ -1055,1 +1068,1 @@\n-            print(\" \");\n+            print(' ');\n@@ -1069,1 +1082,1 @@\n-            if (prec == TreeInfo.notExpression) print(\";\");\n+            if (prec == TreeInfo.notExpression) print(';');\n@@ -1078,2 +1091,5 @@\n-            if (tree.label != null) print(\" \" + tree.label);\n-            print(\";\");\n+            if (tree.label != null) {\n+                print(' ');\n+                print(tree.label);\n+            }\n+            print(';');\n@@ -1088,1 +1104,1 @@\n-            print(\" \");\n+            print(' ');\n@@ -1090,1 +1106,1 @@\n-            print(\";\");\n+            print(';');\n@@ -1099,2 +1115,5 @@\n-            if (tree.label != null) print(\" \" + tree.label);\n-            print(\";\");\n+            if (tree.label != null) {\n+                print(' ');\n+                print(tree.label);\n+            }\n+            print(';');\n@@ -1110,1 +1129,1 @@\n-                print(\" \");\n+                print(' ');\n@@ -1113,1 +1132,1 @@\n-            print(\";\");\n+            print(';');\n@@ -1123,1 +1142,1 @@\n-            print(\";\");\n+            print(';');\n@@ -1137,1 +1156,1 @@\n-            print(\";\");\n+            print(';');\n@@ -1151,1 +1170,2 @@\n-                    print(\">\" + left.name);\n+                    print('>');\n+                    print(left.name);\n@@ -1153,1 +1173,1 @@\n-                    print(\"<\");\n+                    print('<');\n@@ -1155,1 +1175,1 @@\n-                    print(\">\");\n+                    print('>');\n@@ -1161,1 +1181,1 @@\n-            print(\"(\");\n+            print('(');\n@@ -1163,1 +1183,1 @@\n-            print(\")\");\n+            print(')');\n@@ -1173,1 +1193,1 @@\n-                print(\".\");\n+                print('.');\n@@ -1177,1 +1197,1 @@\n-                print(\"<\");\n+                print('<');\n@@ -1179,1 +1199,1 @@\n-                print(\">\");\n+                print('>');\n@@ -1185,1 +1205,1 @@\n-            print(\"(\");\n+            print('(');\n@@ -1187,1 +1207,1 @@\n-            print(\")\");\n+            print(')');\n@@ -1225,1 +1245,1 @@\n-                    print(\"[\");\n+                    print('[');\n@@ -1228,1 +1248,1 @@\n-                    print(\"]\");\n+                    print(']');\n@@ -1233,1 +1253,1 @@\n-                print(\"{\");\n+                print('{');\n@@ -1235,1 +1255,1 @@\n-                print(\"}\");\n+                print('}');\n@@ -1244,1 +1264,1 @@\n-            print(\"(\");\n+            print('(');\n@@ -1264,1 +1284,1 @@\n-            print(\"(\");\n+            print('(');\n@@ -1266,1 +1286,1 @@\n-            print(\")\");\n+            print(')');\n@@ -1322,1 +1342,3 @@\n-            print(\" \" + operatorName(tree.getTag().noAssignOp()) + \"= \");\n+            print(' ');\n+            print(operatorName(tree.getTag().noAssignOp()));\n+            print(\"= \");\n@@ -1354,1 +1376,3 @@\n-            print(\" \" + opname + \" \");\n+            print(' ');\n+            print(opname);\n+            print(' ');\n@@ -1365,1 +1389,1 @@\n-            print(\"(\");\n+            print('(');\n@@ -1367,1 +1391,1 @@\n-            print(\")\");\n+            print(')');\n@@ -1394,1 +1418,1 @@\n-            print(\"[\");\n+            print('[');\n@@ -1396,1 +1420,1 @@\n-            print(\"]\");\n+            print(']');\n@@ -1405,1 +1429,2 @@\n-            print(\".\" + tree.name);\n+            print('.');\n+            print(tree.name);\n@@ -1416,1 +1441,1 @@\n-                print(\"<\");\n+                print('<');\n@@ -1418,1 +1443,1 @@\n-                print(\">\");\n+                print('>');\n@@ -1441,1 +1466,2 @@\n-                    print(tree.value + \"L\");\n+                    print(tree.value);\n+                    print('L');\n@@ -1444,1 +1470,2 @@\n-                    print(tree.value + \"F\");\n+                    print(tree.value);\n+                    print('F');\n@@ -1450,4 +1477,3 @@\n-                    print(\"\\'\" +\n-                            Convert.quote(\n-                            String.valueOf((char)((Number)tree.value).intValue())) +\n-                            \"\\'\");\n+                    print('\\'');\n+                    print(Convert.quote(String.valueOf((char)((Number)tree.value).intValue())));\n+                    print('\\'');\n@@ -1462,1 +1488,3 @@\n-                    print(\"\\\"\" + Convert.quote(tree.value.toString()) + \"\\\"\");\n+                    print('\"');\n+                    print(Convert.quote(tree.value.toString()));\n+                    print('\"');\n@@ -1548,1 +1576,1 @@\n-            print(\"<\");\n+            print('<');\n@@ -1550,1 +1578,1 @@\n-            print(\">\");\n+            print('>');\n@@ -1617,1 +1645,5 @@\n-            print(\"(let \" + tree.defs + \" in \" + tree.expr + \")\");\n+            print(\"(let \");\n+            print(tree.defs);\n+            print(\" in \");\n+            print(tree.expr);\n+            print(')');\n@@ -1634,1 +1666,1 @@\n-            print(\"@\");\n+            print('@');\n@@ -1637,1 +1669,1 @@\n-                print(\"(\");\n+                print('(');\n@@ -1639,1 +1671,1 @@\n-                print(\")\");\n+                print(')');\n@@ -1651,1 +1683,1 @@\n-                print(\".\");\n+                print('.');\n@@ -1668,1 +1700,3 @@\n-            print(\"(UNKNOWN: \" + tree.getTag() + \")\");\n+            print(\"(UNKNOWN: \");\n+            print(tree.getTag());\n+            print(')');\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":154,"deletions":120,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-        JCTree qualid = copy(t.qualid, p);\n+        JCFieldAccess qualid = copy(t.qualid, p);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-    public JCImport Import(JCTree qualid, boolean importStatic) {\n+    public JCImport Import(JCFieldAccess qualid, boolean importStatic) {\n@@ -738,2 +738,2 @@\n-    public JCExpression Select(JCExpression base, Symbol sym) {\n-        return new JCFieldAccess(base, sym.name, sym).setPos(pos).setType(sym.type);\n+    public JCFieldAccess Select(JCExpression base, Symbol sym) {\n+        return (JCFieldAccess)new JCFieldAccess(base, sym.name, sym).setPos(pos).setType(sym.type);\n@@ -871,1 +871,1 @@\n-                        JCFieldAccess f = (JCFieldAccess) Select(((JCTypeApply) vp).clazz, t.tsym);\n+                        JCFieldAccess f = Select(((JCTypeApply) vp).clazz, t.tsym);\n@@ -875,1 +875,1 @@\n-                        JCFieldAccess f = (JCFieldAccess) Select(vp, t.tsym);\n+                        JCFieldAccess f = Select(vp, t.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethodData.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotMethodData.java","status":"renamed"},{"patch":"","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethodDataAccessor.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotMethodDataAccessor.java","status":"renamed"},{"patch":"","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotModifiers.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotModifiers.java","status":"renamed"},{"patch":"","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","status":"renamed"},{"patch":"","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","status":"renamed"},{"patch":"@@ -246,0 +246,1 @@\n+        jvmtiDeallocate(groups);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+compiler\/loopopts\/TestUnreachableInnerLoop.java 8288981 linux-s390x\n@@ -89,1 +90,0 @@\n-runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndCP_JFR.java 8253437 windows-x64\n@@ -177,0 +177,1 @@\n+vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002a\/TestDescription.java 8277573 generic-all\n@@ -181,1 +182,0 @@\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002a\/TestDescription.java 8277812 generic-all\n@@ -199,3 +199,0 @@\n-vmTestbase\/nsk\/stress\/strace\/strace002.java 8288912 macosx-x64,windows-x64\n-vmTestbase\/nsk\/stress\/strace\/strace003.java 8297824 macosx-x64,windows-x64\n-vmTestbase\/nsk\/stress\/strace\/strace004.java 8297824 macosx-x64,windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -158,0 +158,2 @@\n+  compiler\/memoryinitialization\/ZeroTLABTest.java \\\n+  compiler\/classUnloading\/methodUnloading\/TestOverloadCompileQueues.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1301,0 +1301,20 @@\n+    public static final String VMASK_CMP_ZERO_I_NEON = PREFIX + \"VMASK_CMP_ZERO_I_NEON\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMASK_CMP_ZERO_I_NEON, \"vmaskcmp_zeroI_neon\");\n+    }\n+\n+    public static final String VMASK_CMP_ZERO_L_NEON = PREFIX + \"VMASK_CMP_ZERO_L_NEON\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMASK_CMP_ZERO_L_NEON, \"vmaskcmp_zeroL_neon\");\n+    }\n+\n+    public static final String VMASK_CMP_ZERO_F_NEON = PREFIX + \"VMASK_CMP_ZERO_F_NEON\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMASK_CMP_ZERO_F_NEON, \"vmaskcmp_zeroF_neon\");\n+    }\n+\n+    public static final String VMASK_CMP_ZERO_D_NEON = PREFIX + \"VMASK_CMP_ZERO_D_NEON\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VMASK_CMP_ZERO_D_NEON, \"vmaskcmp_zeroD_neon\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-     * Use the associated add methods ({@link #addFlags(String...)}, @link #addScenarios(Scenario...)},\n+     * Use the associated add methods ({@link #addFlags(String...)}, {@link #addScenarios(Scenario...)},\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,1 +129,0 @@\n-javax\/swing\/dnd\/7171812\/bug7171812.java 8041447 macosx-all\n@@ -742,0 +741,2 @@\n+jdk\/incubator\/concurrent\/ScopedValue\/StressStackOverflow.java   8303498 linux-s390x\n+\n@@ -747,1 +748,0 @@\n-jdk\/jfr\/event\/os\/TestThreadContextSwitches.java                 8247776 windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.io.File;\n+import java.nio.charset.Charset;\n@@ -34,0 +36,1 @@\n+import java.time.Instant;\n@@ -90,0 +93,1 @@\n+        log(\"Entering call()\");\n@@ -130,0 +134,1 @@\n+        log(\"Leaving call()\");\n@@ -477,0 +482,2 @@\n+        log(\"Entering dockerSupport()\");\n+\n@@ -495,0 +502,2 @@\n+        log(\"dockerSupport(): platform check: isSupported = \" + isSupported);\n+\n@@ -503,0 +512,1 @@\n+        log(\"dockerSupport(): returning isSupported = \" + isSupported);\n@@ -506,0 +516,34 @@\n+    \/\/ Configures process builder to redirect process stdout and stderr to a file.\n+    \/\/ Returns file names for stdout and stderr.\n+    private Map<String, String> redirectOutputToLogFile(String msg, ProcessBuilder pb, String fileNameBase) {\n+        Map<String, String> result = new HashMap<>();\n+        String timeStamp = Instant.now().toString().replace(\":\", \"-\").replace(\".\", \"-\");\n+\n+        String stdoutFileName = String.format(\".\/%s-stdout--%s.log\", fileNameBase, timeStamp);\n+        pb.redirectOutput(new File(stdoutFileName));\n+        log(msg + \": child process stdout redirected to \" + stdoutFileName);\n+        result.put(\"stdout\", stdoutFileName);\n+\n+        String stderrFileName = String.format(\".\/%s-stderr--%s.log\", fileNameBase, timeStamp);\n+        pb.redirectError(new File(stderrFileName));\n+        log(msg + \": child process stderr redirected to \" + stderrFileName);\n+        result.put(\"stderr\", stderrFileName);\n+\n+        return result;\n+    }\n+\n+    private void printLogfileContent(Map<String, String> logFileNames) {\n+        logFileNames.entrySet().stream()\n+            .forEach(entry ->\n+                {\n+                    log(\"------------- \" + entry.getKey());\n+                    try {\n+                        Files.lines(Path.of(entry.getValue()))\n+                            .forEach(line -> log(line));\n+                    } catch (IOException ie) {\n+                        log(\"Exception while reading file: \" + ie);\n+                    }\n+                    log(\"-------------\");\n+                });\n+    }\n+\n@@ -507,0 +551,1 @@\n+        log(\"checkDockerSupport(): entering\");\n@@ -508,0 +553,2 @@\n+        Map<String, String> logFileNames = redirectOutputToLogFile(\"checkDockerSupport(): <container> ps\",\n+                                                      pb, \"container-ps\");\n@@ -510,0 +557,6 @@\n+        int exitValue = p.exitValue();\n+\n+        log(String.format(\"checkDockerSupport(): exitValue = %s, pid = %s\", exitValue, p.pid()));\n+        if (exitValue != 0) {\n+            printLogfileContent(logFileNames);\n+        }\n@@ -511,1 +564,1 @@\n-        return (p.exitValue() == 0);\n+        return (exitValue == 0);\n@@ -626,0 +679,34 @@\n+    \/**\n+     * Log diagnostic message.\n+     *\n+     * @param msg\n+     *\/\n+    protected static void log(String msg) {\n+        \/\/ Always log to a file.\n+        logToFile(msg);\n+\n+        \/\/ Also log to stderr; guarded by property to avoid excessive verbosity.\n+        \/\/ By jtreg design stderr produced here will be visible\n+        \/\/ in the output of a parent process. Note: stdout should not be used\n+        \/\/ for logging as jtreg parses that output directly and only echoes it\n+        \/\/ in the event of a failure.\n+        if (Boolean.getBoolean(\"jtreg.log.vmprops\")) {\n+            System.err.println(\"VMProps: \" + msg);\n+        }\n+    }\n+\n+    \/**\n+     * Log diagnostic message to a file.\n+     *\n+     * @param msg\n+     *\/\n+    protected static void logToFile(String msg) {\n+        String fileName = \".\/vmprops.log\";\n+        try {\n+            Files.writeString(Paths.get(fileName), msg + \"\\n\", Charset.forName(\"ISO-8859-1\"),\n+                    StandardOpenOption.APPEND, StandardOpenOption.CREATE);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to log into '\" + fileName + \"'\", e);\n+        }\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":89,"deletions":2,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -212,2 +212,1 @@\n-        DataInputStream in = new DataInputStream(new FileInputStream(f));\n-        try {\n+        try (DataInputStream in = new DataInputStream(new FileInputStream(f))) {\n@@ -215,2 +214,0 @@\n-        } finally {\n-            in.close();\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckExamples.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -492,2 +492,1 @@\n-        InputStream in = fo.openInputStream();\n-        try {\n+        try (InputStream in = fo.openInputStream()) {\n@@ -503,2 +502,0 @@\n-        } finally {\n-            in.close();\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckResourceKeys.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+compiler.misc.bad.class.truncated.at.offset             # bad class file\n@@ -213,0 +214,3 @@\n+# this one needs a forged class file to be reproduced\n+compiler.err.annotation.unrecognized.attribute.name\n+\n@@ -219,1 +223,2 @@\n-compiler.err.generic.parameterization.with.primitive.class\n+compiler.err.generic.parameterization.with.primitive.class\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-                \"Test.java:1:57: compiler.err.cant.access: test.Broken, (compiler.misc.bad.class.file.header: Broken.class, (compiler.misc.class.file.wrong.class: java.lang.AutoCloseable))\",\n+                \"Test.java:1:57: compiler.err.cant.access: test.Broken, (compiler.misc.bad.class.file.header: Broken.class, (compiler.misc.bad.class.truncated.at.offset: 0))\",\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/completionfailure\/NoAbortForBadClassFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}