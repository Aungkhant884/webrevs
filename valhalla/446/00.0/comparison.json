{"files":[{"patch":"@@ -74,1 +74,1 @@\n-        run: \"echo JTREG_REF=jtreg${{ fromJson(steps.check_deps.outputs.dependencies).JTREG_VERSION }}-${{ fromJson(steps.check_deps.outputs.dependencies).JTREG_BUILD }} >> $GITHUB_ENV\"\n+        run: \"echo JTREG_REF=jtreg-${{ fromJson(steps.check_deps.outputs.dependencies).JTREG_VERSION }}+${{ fromJson(steps.check_deps.outputs.dependencies).JTREG_BUILD }} >> $GITHUB_ENV\"\n@@ -94,1 +94,1 @@\n-        run: sh make\/build-all.sh ${JAVA_HOME_8_X64}\n+        run: bash make\/build.sh --jdk ${JAVA_HOME_8_X64}\n","filename":".github\/workflows\/submit.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -336,0 +336,6 @@\n+  # Add summary pages for new\/deprecated APIs in recent releases\n+  $1_OPTIONS += --since $(call CommaList, \\\n+      $(filter-out $(VERSION_DOCS_API_SINCE), \\\n+          $(call sequence, $(VERSION_DOCS_API_SINCE), $(VERSION_FEATURE))))\n+  $1_OPTIONS += --since-label \"New API since JDK $(VERSION_DOCS_API_SINCE)\"\n+\n","filename":"make\/Docs.gmk","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -399,1 +399,1 @@\n-        common.boot_jdk_build_number = \"19\";\n+        common.boot_jdk_build_number = \"24\";\n@@ -494,0 +494,2 @@\n+                \"--with-zlib=system\",\n+                \"--disable-dtrace\",\n@@ -1072,3 +1074,9 @@\n-\n-    var boot_jdk_platform = (input.build_os == \"macosx\" ? \"osx\" : input.build_os)\n-        + \"-\" + input.build_cpu;\n+    var boot_jdk_os = input.build_os;\n+    if (input.build_os == \"macosx\") {\n+        if (input.build_cpu == \"aarch64\") {\n+            boot_jdk_os = \"macos\";\n+        } else {\n+            boot_jdk_os = \"osx\";\n+        }\n+    }\n+    var boot_jdk_platform = boot_jdk_os + \"-\" + input.build_cpu;\n@@ -1136,4 +1144,3 @@\n-            version: \"5.1\",\n-            build_number: \"b01\",\n-            checksum_file: \"MD5_VALUES\",\n-            file: \"bundles\/jtreg_bin-5.1.zip\",\n+            version: \"6\",\n+            build_number: \"1\",\n+            file: \"bundles\/jtreg-6+1.zip\",\n","filename":"make\/conf\/jib-profiles.js","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-DEFAULT_VERSION_FEATURE=17\n+DEFAULT_VERSION_FEATURE=18\n@@ -36,2 +36,2 @@\n-DEFAULT_VERSION_DATE=2021-09-14\n-DEFAULT_VERSION_CLASSFILE_MAJOR=61  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n+DEFAULT_VERSION_DATE=2022-03-15\n+DEFAULT_VERSION_CLASSFILE_MAJOR=62  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n@@ -39,2 +39,3 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"16 17\"\n-DEFAULT_JDK_SOURCE_TARGET_VERSION=17\n+DEFAULT_VERSION_DOCS_API_SINCE=11\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"16 17 18\"\n+DEFAULT_JDK_SOURCE_TARGET_VERSION=18\n","filename":"make\/conf\/version-numbers.conf","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2436,4 +2436,0 @@\n-const bool Matcher::has_predicated_vectors(void) {\n-  return UseSVE > 0;\n-}\n-\n@@ -2448,2 +2444,3 @@\n-bool Matcher::supports_vector_variable_shifts(void) {\n-  return true;\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n@@ -2452,2 +2449,3 @@\n-bool Matcher::supports_vector_variable_rotates(void) {\n-  return false; \/\/ not supported\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n@@ -2470,11 +2468,0 @@\n-const bool Matcher::isSimpleConstant64(jlong value) {\n-  \/\/ Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.\n-  \/\/ Probably always true, even if a temp register is required.\n-  return true;\n-}\n-\n-\/\/ true just means we have fast l2f conversion\n-const bool Matcher::convL2FSupported(void) {\n-  return true;\n-}\n-\n@@ -2516,4 +2503,0 @@\n-const bool Matcher::supports_scalable_vector() {\n-  return UseSVE > 0;\n-}\n-\n@@ -2541,29 +2524,0 @@\n-\/\/ aarch64 supports misaligned vectors store\/load.\n-const bool Matcher::misaligned_vectors_ok() {\n-  return true;\n-}\n-\n-\/\/ false => size gets scaled to BytesPerLong, ok.\n-const bool Matcher::init_array_count_is_in_bytes = false;\n-\n-\/\/ Use conditional move (CMOVL)\n-const int Matcher::long_cmove_cost() {\n-  \/\/ long cmoves are no more expensive than int cmoves\n-  return 0;\n-}\n-\n-const int Matcher::float_cmove_cost() {\n-  \/\/ float cmoves are no more expensive than int cmoves\n-  return 0;\n-}\n-\n-\/\/ Does the CPU require late expand (see block.cpp for description of late expand)?\n-const bool Matcher::require_postalloc_expand = false;\n-\n-\/\/ Do we need to mask the count passed to shift instructions or does\n-\/\/ the cpu only look at the lower 5\/6 bits anyway?\n-const bool Matcher::need_masked_shift_count = false;\n-\n-\/\/ No support for generic vector operands.\n-const bool Matcher::supports_generic_vector_operands  = false;\n-\n@@ -2585,56 +2539,0 @@\n-\/\/ This affects two different things:\n-\/\/  - how Decode nodes are matched\n-\/\/  - how ImplicitNullCheck opportunities are recognized\n-\/\/ If true, the matcher will try to remove all Decodes and match them\n-\/\/ (as operands) into nodes. NullChecks are not prepared to deal with\n-\/\/ Decodes by final_graph_reshaping().\n-\/\/ If false, final_graph_reshaping() forces the decode behind the Cmp\n-\/\/ for a NullCheck. The matcher matches the Decode node into a register.\n-\/\/ Implicit_null_check optimization moves the Decode along with the\n-\/\/ memory operation back up before the NullCheck.\n-bool Matcher::narrow_oop_use_complex_address() {\n-  return CompressedOops::shift() == 0;\n-}\n-\n-bool Matcher::narrow_klass_use_complex_address() {\n-\/\/ TODO\n-\/\/ decide whether we need to set this to true\n-  return false;\n-}\n-\n-bool Matcher::const_oop_prefer_decode() {\n-  \/\/ Prefer ConN+DecodeN over ConP in simple compressed oops mode.\n-  return CompressedOops::base() == NULL;\n-}\n-\n-bool Matcher::const_klass_prefer_decode() {\n-  \/\/ Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.\n-  return CompressedKlassPointers::base() == NULL;\n-}\n-\n-\/\/ Is it better to copy float constants, or load them directly from\n-\/\/ memory?  Intel can load a float constant from a direct address,\n-\/\/ requiring no extra registers.  Most RISCs will have to materialize\n-\/\/ an address into a register first, so they would do better to copy\n-\/\/ the constant from stack.\n-const bool Matcher::rematerialize_float_constants = false;\n-\n-\/\/ If CPU can load and store mis-aligned doubles directly then no\n-\/\/ fixup is needed.  Else we split the double into 2 integer pieces\n-\/\/ and move it piece-by-piece.  Only happens when passing doubles into\n-\/\/ C code as the Java calling convention forces doubles to be aligned.\n-const bool Matcher::misaligned_doubles_ok = true;\n-\n-\/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-const bool Matcher::strict_fp_requires_explicit_rounding = false;\n-\n-\/\/ Are floats converted to double when stored to stack during\n-\/\/ deoptimization?\n-bool Matcher::float_in_double() { return false; }\n-\n-\/\/ Do ints take an entire long register or just half?\n-\/\/ The relevant question is how the int is callee-saved:\n-\/\/ the whole long is written but de-opt'ing will have to extract\n-\/\/ the relevant 32 bits.\n-const bool Matcher::int_in_long = true;\n-\n@@ -2717,2 +2615,0 @@\n-const bool Matcher::convi2l_type_required = false;\n-\n@@ -2769,3 +2665,0 @@\n-void Compile::reshape_address(AddPNode* addp) {\n-}\n-\n@@ -8889,0 +8782,55 @@\n+instruct castFF(vRegF dst)\n+%{\n+  match(Set dst (CastFF dst));\n+\n+  size(0);\n+  format %{ \"# castFF of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct castDD(vRegD dst)\n+%{\n+  match(Set dst (CastDD dst));\n+\n+  size(0);\n+  format %{ \"# castDD of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct castVVD(vecD dst)\n+%{\n+  match(Set dst (CastVV dst));\n+\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct castVVX(vecX dst)\n+%{\n+  match(Set dst (CastVV dst));\n+\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct castVV(vReg dst)\n+%{\n+  match(Set dst (CastVV dst));\n+\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":61,"deletions":113,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -1978,2 +1978,0 @@\n-    case lir_mul_strictfp: \/\/ fall through\n-    case lir_div_strictfp: \/\/ fall through\n@@ -1991,2 +1989,0 @@\n-      case lir_mul_strictfp: \/\/ fall through\n-      case lir_div_strictfp: \/\/ fall through\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -438,5 +438,1 @@\n-  LIR_Opr tmp = LIR_OprFact::illegalOpr;\n-  if (x->is_strictfp() && (x->op() == Bytecodes::_dmul || x->op() == Bytecodes::_ddiv)) {\n-    tmp = new_register(T_DOUBLE);\n-  }\n-  arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), x->is_strictfp());\n+  arithmetic_op_fpu(x->op(), reg, left.result(), right.result());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -163,0 +163,5 @@\n+enum return_state_t {\n+  does_not_return, requires_return\n+};\n+\n+\n@@ -168,0 +173,1 @@\n+  bool _return_state;\n@@ -170,1 +176,1 @@\n-  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments);\n+  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, return_state_t return_state=requires_return);\n@@ -188,1 +194,1 @@\n-StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments) {\n+StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, return_state_t return_state) {\n@@ -190,0 +196,1 @@\n+  _return_state = return_state;\n@@ -199,2 +206,5 @@\n-\n-  __ epilogue();\n+  if (_return_state == requires_return) {\n+    __ epilogue();\n+  } else {\n+    __ should_not_reach_here();\n+  }\n@@ -348,2 +358,0 @@\n-\n-  __ should_not_reach_here();\n@@ -398,3 +406,1 @@\n-  default:\n-    __ should_not_reach_here();\n-    break;\n+  default: ShouldNotReachHere();\n@@ -455,3 +461,0 @@\n-    \/\/ Pop the return address.\n-    __ leave();\n-    __ ret(lr);  \/\/ jump to exception handler\n@@ -623,1 +626,1 @@\n-      { StubFrame f(sasm, \"throw_div0_exception\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"throw_div0_exception\", dont_gc_arguments, does_not_return);\n@@ -629,1 +632,1 @@\n-      { StubFrame f(sasm, \"throw_null_pointer_exception\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"throw_null_pointer_exception\", dont_gc_arguments, does_not_return);\n@@ -990,1 +993,1 @@\n-      { StubFrame f(sasm, \"throw_class_cast_exception\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"throw_class_cast_exception\", dont_gc_arguments, does_not_return);\n@@ -996,1 +999,1 @@\n-      { StubFrame f(sasm, \"throw_incompatible_class_change_error\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"throw_incompatible_class_change_error\", dont_gc_arguments, does_not_return);\n@@ -1096,1 +1099,1 @@\n-        StubFrame f(sasm, \"deoptimize\", dont_gc_arguments);\n+        StubFrame f(sasm, \"deoptimize\", dont_gc_arguments, does_not_return);\n@@ -1112,1 +1115,1 @@\n-      { StubFrame f(sasm, \"range_check_failed\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"range_check_failed\", dont_gc_arguments, does_not_return);\n@@ -1126,1 +1129,1 @@\n-      { StubFrame f(sasm, \"access_field_patching\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"access_field_patching\", dont_gc_arguments, does_not_return);\n@@ -1133,1 +1136,1 @@\n-      { StubFrame f(sasm, \"load_klass_patching\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"load_klass_patching\", dont_gc_arguments, does_not_return);\n@@ -1140,1 +1143,1 @@\n-      { StubFrame f(sasm, \"load_mirror_patching\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"load_mirror_patching\", dont_gc_arguments, does_not_return);\n@@ -1147,1 +1150,1 @@\n-      { StubFrame f(sasm, \"load_appendix_patching\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"load_appendix_patching\", dont_gc_arguments, does_not_return);\n@@ -1167,1 +1170,1 @@\n-      { StubFrame f(sasm, \"index_range_check_failed\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"index_range_check_failed\", dont_gc_arguments, does_not_return);\n@@ -1173,1 +1176,1 @@\n-      { StubFrame f(sasm, \"throw_array_store_exception\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"throw_array_store_exception\", dont_gc_arguments, does_not_return);\n@@ -1182,1 +1185,1 @@\n-        StubFrame f(sasm, \"predicate_failed_trap\", dont_gc_arguments);\n+        StubFrame f(sasm, \"predicate_failed_trap\", dont_gc_arguments, does_not_return);\n@@ -1212,1 +1215,1 @@\n-      { StubFrame f(sasm, \"unimplemented entry\", dont_gc_arguments);\n+      { StubFrame f(sasm, \"unimplemented entry\", dont_gc_arguments, does_not_return);\n@@ -1215,1 +1218,0 @@\n-        __ should_not_reach_here();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":29,"deletions":27,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -278,0 +278,3 @@\n+\n+  \/\/ Only generated code frames should be patched, therefore the return address will not be signed.\n+  assert(pauth_ptr_is_raw(*pc_addr), \"cannot be signed\");\n@@ -365,0 +368,10 @@\n+JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n+frame frame::sender_for_optimized_entry_frame(RegisterMap* map) const {\n+  ShouldNotCallThis();\n+  return {};\n+}\n+\n@@ -442,1 +455,3 @@\n-  return frame(sender_sp, unextended_sp, link(), sender_pc());\n+  \/\/ Use the raw version of pc - the interpreter should not have signed it.\n+\n+  return frame(sender_sp, unextended_sp, link(), sender_pc_maybe_signed());\n@@ -534,0 +549,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+  inline address  sender_pc_maybe_signed() const;\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-  RegSet saved = RegSet::of(store_addr, new_val);\n+  RegSet saved = RegSet::of(store_addr);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -245,1 +245,8 @@\n-  __ tbz(rscratch2, ShenandoahHeap::HAS_FORWARDED_BITPOS, heap_stable);\n+  if (is_strong) {\n+    __ tbz(rscratch2, ShenandoahHeap::HAS_FORWARDED_BITPOS, heap_stable);\n+  } else {\n+    Label lrb;\n+    __ tbnz(rscratch2, ShenandoahHeap::WEAK_ROOTS_BITPOS, lrb);\n+    __ tbz(rscratch2, ShenandoahHeap::HAS_FORWARDED_BITPOS, heap_stable);\n+    __ bind(lrb);\n+  }\n@@ -689,3 +696,1 @@\n-  __ mov(rscratch2, ShenandoahHeap::MARKING);\n-  __ tst(tmp, rscratch2);\n-  __ br(Assembler::EQ, done);\n+  __ tbz(tmp, ShenandoahHeap::MARKING_BITPOS, done);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -684,0 +684,5 @@\n+  \/\/ lr could be poisoned with PAC signature during throw_pending_exception\n+  \/\/ if it was tail-call optimized by compiler, since lr is not callee-saved\n+  \/\/ reload it with proper value\n+  adr(lr, l);\n+\n@@ -6059,0 +6064,43 @@\n+void MacroAssembler::neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1,\n+                                  FloatRegister src2, int cond, bool isQ) {\n+  SIMD_Arrangement size = esize2arrangement(type2aelembytes(bt), isQ);\n+  if (bt == T_FLOAT || bt == T_DOUBLE) {\n+    switch (cond) {\n+      case BoolTest::eq: fcmeq(dst, size, src1, src2); break;\n+      case BoolTest::ne: {\n+        fcmeq(dst, size, src1, src2);\n+        notr(dst, T16B, dst);\n+        break;\n+      }\n+      case BoolTest::ge: fcmge(dst, size, src1, src2); break;\n+      case BoolTest::gt: fcmgt(dst, size, src1, src2); break;\n+      case BoolTest::le: fcmge(dst, size, src2, src1); break;\n+      case BoolTest::lt: fcmgt(dst, size, src2, src1); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  } else {\n+    switch (cond) {\n+      case BoolTest::eq: cmeq(dst, size, src1, src2); break;\n+      case BoolTest::ne: {\n+        cmeq(dst, size, src1, src2);\n+        notr(dst, T16B, dst);\n+        break;\n+      }\n+      case BoolTest::ge: cmge(dst, size, src1, src2); break;\n+      case BoolTest::gt: cmgt(dst, size, src1, src2); break;\n+      case BoolTest::le: cmge(dst, size, src2, src1); break;\n+      case BoolTest::lt: cmgt(dst, size, src2, src1); break;\n+      case BoolTest::uge: cmhs(dst, size, src1, src2); break;\n+      case BoolTest::ugt: cmhi(dst, size, src1, src2); break;\n+      case BoolTest::ult: cmhi(dst, size, src2, src1); break;\n+      case BoolTest::ule: cmhs(dst, size, src2, src1); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1119,0 +1119,3 @@\n+\n+  \/\/ SIMD&FP comparison\n+  void neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1, FloatRegister src2, int cond, bool isQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1139,0 +1139,7 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2684,1 +2684,1 @@\n-    assert(UseAES, \"need AES instructions and misaligned SSE support\");\n+    assert(UseAES, \"need AES cryptographic extension support\");\n@@ -2791,1 +2791,1 @@\n-    assert(UseAES, \"need AES instructions and misaligned SSE support\");\n+    assert(UseAES, \"need AES cryptographic extension support\");\n@@ -2895,1 +2895,1 @@\n-    assert(UseAES, \"need AES instructions and misaligned SSE support\");\n+    assert(UseAES, \"need AES cryptographic extension support\");\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"asm\/assembler.inline.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"assembler_aarch64.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/vtableStubs_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1631,2 +1631,0 @@\n-      case lir_mul_strictfp: \/\/ fall through\n-      case lir_div_strictfp: \/\/ fall through\n@@ -1646,2 +1644,0 @@\n-      case lir_mul_strictfp: \/\/ fall through\n-      case lir_div_strictfp: \/\/ fall through\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1630,4 +1630,2 @@\n-          case lir_mul: \/\/ fall through\n-          case lir_mul_strictfp: __ fmuls(res, lreg, rreg); break;\n-          case lir_div: \/\/ fall through\n-          case lir_div_strictfp: __ fdivs(res, lreg, rreg); break;\n+          case lir_mul: __ fmuls(res, lreg, rreg); break;\n+          case lir_div: __ fdivs(res, lreg, rreg); break;\n@@ -1643,4 +1641,2 @@\n-          case lir_mul: \/\/ fall through\n-          case lir_mul_strictfp: __ fmul(res, lreg, rreg); break;\n-          case lir_div: \/\/ fall through\n-          case lir_div_strictfp: __ fdiv(res, lreg, rreg); break;\n+          case lir_mul: __ fmul(res, lreg, rreg); break;\n+          case lir_div: __ fdiv(res, lreg, rreg); break;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1613,2 +1613,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -1623,2 +1621,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -1648,2 +1644,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -1658,2 +1652,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1615,1 +1615,1 @@\n-        __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));\n+        __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_trunc()));\n@@ -1618,1 +1618,1 @@\n-        __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));\n+        __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n@@ -2378,2 +2378,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2397,2 +2395,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2414,2 +2410,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2433,2 +2427,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2467,2 +2459,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2478,1 +2468,1 @@\n-    if (code == lir_mul_strictfp || code == lir_div_strictfp) {\n+    if (code == lir_mul || code == lir_div) {\n@@ -2480,1 +2470,1 @@\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n@@ -2504,2 +2494,0 @@\n-        case lir_mul_strictfp: \/\/ fall through\n-        case lir_div_strictfp: \/\/ fall through\n@@ -2512,1 +2500,1 @@\n-    if (code == lir_mul_strictfp || code == lir_div_strictfp) {\n+    if (code == lir_mul || code == lir_div) {\n@@ -2514,1 +2502,1 @@\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n@@ -2589,1 +2577,0 @@\n-    case lir_mul_strictfp: \/\/ fall through\n@@ -2596,1 +2583,0 @@\n-    case lir_div_strictfp: \/\/ fall through\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":6,"deletions":20,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -416,1 +416,1 @@\n-  if (x->is_strictfp() && (x->op() == Bytecodes::_dmul || x->op() == Bytecodes::_ddiv)) {\n+  if (x->op() == Bytecodes::_dmul || x->op() == Bytecodes::_ddiv) {\n@@ -452,1 +452,1 @@\n-    arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), x->is_strictfp(), tmp);\n+    arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), tmp);\n@@ -472,1 +472,1 @@\n-    arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), x->is_strictfp(), tmp);\n+    arithmetic_op_fpu(x->op(), reg, left.result(), right.result(), tmp);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-      __ cmpw(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size), StubRoutines::fpu_cntrl_wrd_std());\n+      __ cmpw(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size), StubRoutines::x86::fpu_cntrl_wrd_std());\n@@ -457,1 +457,1 @@\n-      __ movw(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size), StubRoutines::fpu_cntrl_wrd_std());\n+      __ movw(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size), StubRoutines::x86::fpu_cntrl_wrd_std());\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1931,1 +1931,1 @@\n-  assert(ArrayCopyPartialInlineSize <= 64,\"\");\n+  assert(ArrayOperationPartialInlineSize > 0 && ArrayOperationPartialInlineSize <= 64, \"invalid\");\n@@ -2148,0 +2148,24 @@\n+void C2_MacroAssembler::evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, XMMRegister src2, int comparison, int vector_len) {\n+  switch(typ) {\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      evpcmpb(kdmask, ksmask, src1, src2, comparison, \/*signed*\/ true, vector_len);\n+      break;\n+    case T_SHORT:\n+    case T_CHAR:\n+      evpcmpw(kdmask, ksmask, src1, src2, comparison, \/*signed*\/ true, vector_len);\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      evpcmpd(kdmask, ksmask, src1, src2, comparison, \/*signed*\/ true, vector_len);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      evpcmpq(kdmask, ksmask, src1, src2, comparison, \/*signed*\/ true, vector_len);\n+      break;\n+    default:\n+      assert(false,\"Should not reach here.\");\n+      break;\n+  }\n+}\n+\n@@ -2150,0 +2174,1 @@\n+    case T_BOOLEAN:\n@@ -2151,1 +2176,1 @@\n-      evpcmpb(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpb(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2153,0 +2178,1 @@\n+    case T_CHAR:\n@@ -2154,1 +2180,1 @@\n-      evpcmpw(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpw(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2158,1 +2184,1 @@\n-      evpcmpd(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpd(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2162,1 +2188,1 @@\n-      evpcmpq(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpq(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2170,0 +2196,78 @@\n+void C2_MacroAssembler::vpcmpu(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison,\n+                            int vlen_in_bytes, XMMRegister vtmp1, XMMRegister vtmp2, Register scratch) {\n+  int vlen_enc = vector_length_encoding(vlen_in_bytes*2);\n+  switch (typ) {\n+  case T_BYTE:\n+    vpmovzxbw(vtmp1, src1, vlen_enc);\n+    vpmovzxbw(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n+    vpacksswb(dst, dst, dst, vlen_enc);\n+    break;\n+  case T_SHORT:\n+    vpmovzxwd(vtmp1, src1, vlen_enc);\n+    vpmovzxwd(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::D, vlen_enc, scratch);\n+    vpackssdw(dst, dst, dst, vlen_enc);\n+    break;\n+  case T_INT:\n+    vpmovzxdq(vtmp1, src1, vlen_enc);\n+    vpmovzxdq(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::Q, vlen_enc, scratch);\n+    vpermilps(dst, dst, 8, vlen_enc);\n+    break;\n+  default:\n+    assert(false, \"Should not reach here\");\n+  }\n+  if (vlen_in_bytes == 16) {\n+    vpermpd(dst, dst, 0x8, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpcmpu32(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n+                              XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3, Register scratch) {\n+  int vlen_enc = vector_length_encoding(vlen_in_bytes);\n+  switch (typ) {\n+  case T_BYTE:\n+    vpmovzxbw(vtmp1, src1, vlen_enc);\n+    vpmovzxbw(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n+    vextracti128(vtmp1, src1, 1);\n+    vextracti128(vtmp2, src2, 1);\n+    vpmovzxbw(vtmp1, vtmp1, vlen_enc);\n+    vpmovzxbw(vtmp2, vtmp2, vlen_enc);\n+    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n+    vpacksswb(dst, dst, vtmp3, vlen_enc);\n+    vpermpd(dst, dst, 0xd8, vlen_enc);\n+    break;\n+  case T_SHORT:\n+    vpmovzxwd(vtmp1, src1, vlen_enc);\n+    vpmovzxwd(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::D, vlen_enc, scratch);\n+    vextracti128(vtmp1, src1, 1);\n+    vextracti128(vtmp2, src2, 1);\n+    vpmovzxwd(vtmp1, vtmp1, vlen_enc);\n+    vpmovzxwd(vtmp2, vtmp2, vlen_enc);\n+    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::D,  vlen_enc, scratch);\n+    vpackssdw(dst, dst, vtmp3, vlen_enc);\n+    vpermpd(dst, dst, 0xd8, vlen_enc);\n+    break;\n+  case T_INT:\n+    vpmovzxdq(vtmp1, src1, vlen_enc);\n+    vpmovzxdq(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::Q, vlen_enc, scratch);\n+    vpshufd(dst, dst, 8, vlen_enc);\n+    vpermq(dst, dst, 8, vlen_enc);\n+    vextracti128(vtmp1, src1, 1);\n+    vextracti128(vtmp2, src2, 1);\n+    vpmovzxdq(vtmp1, vtmp1, vlen_enc);\n+    vpmovzxdq(vtmp2, vtmp2, vlen_enc);\n+    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::Q,  vlen_enc, scratch);\n+    vpshufd(vtmp3, vtmp3, 8, vlen_enc);\n+    vpermq(vtmp3, vtmp3, 0x80, vlen_enc);\n+    vpblendd(dst, dst, vtmp3, 0xf0, vlen_enc);\n+    break;\n+  default:\n+    assert(false, \"Should not reach here\");\n+  }\n+}\n+\n@@ -3758,0 +3862,51 @@\n+\n+#ifdef _LP64\n+void C2_MacroAssembler::vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp,\n+                                              Register tmp, KRegister ktmp, int masklen, int vec_enc) {\n+  assert(VM_Version::supports_avx512vlbw(), \"\");\n+  vpxor(xtmp, xtmp, xtmp, vec_enc);\n+  vpsubb(xtmp, xtmp, mask, vec_enc);\n+  evpmovb2m(ktmp, xtmp, vec_enc);\n+  kmovql(tmp, ktmp);\n+  switch(opc) {\n+    case Op_VectorMaskTrueCount:\n+      popcntq(dst, tmp);\n+      break;\n+    case Op_VectorMaskLastTrue:\n+      mov64(dst, -1);\n+      bsrq(tmp, tmp);\n+      cmov(Assembler::notZero, dst, tmp);\n+      break;\n+    case Op_VectorMaskFirstTrue:\n+      mov64(dst, masklen);\n+      bsfq(tmp, tmp);\n+      cmov(Assembler::notZero, dst, tmp);\n+      break;\n+    default: assert(false, \"Unhandled mask operation\");\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp,\n+                                              XMMRegister xtmp1, Register tmp, int masklen, int vec_enc) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  vpxor(xtmp, xtmp, xtmp, vec_enc);\n+  vpsubb(xtmp, xtmp, mask, vec_enc);\n+  vpmovmskb(tmp, xtmp, vec_enc);\n+  switch(opc) {\n+    case Op_VectorMaskTrueCount:\n+      popcntq(dst, tmp);\n+      break;\n+    case Op_VectorMaskLastTrue:\n+      mov64(dst, -1);\n+      bsrq(tmp, tmp);\n+      cmov(Assembler::notZero, dst, tmp);\n+      break;\n+    case Op_VectorMaskFirstTrue:\n+      mov64(dst, masklen);\n+      bsfq(tmp, tmp);\n+      cmov(Assembler::notZero, dst, tmp);\n+      break;\n+    default: assert(false, \"Unhandled mask operation\");\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":160,"deletions":5,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -105,0 +105,2 @@\n+    } else if (is_optimized_entry_frame()) {\n+      return fp_safe;\n@@ -205,0 +207,2 @@\n+    } else if (sender_blob->is_optimized_entry_blob()) {\n+      return false;\n@@ -355,0 +359,26 @@\n+JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+  \/\/ need unextended_sp here, since normal sp is wrong for interpreter callees\n+  return reinterpret_cast<JavaFrameAnchor*>(reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(jfa_sp_offset()));\n+}\n+\n+frame frame::sender_for_optimized_entry_frame(RegisterMap* map) const {\n+  assert(map != NULL, \"map must be set\");\n+  OptimizedEntryBlob* blob = _cb->as_optimized_entry_blob();\n+  \/\/ Java frame called from C; skip all C frames and return top C\n+  \/\/ frame of that chunk as the sender\n+  JavaFrameAnchor* jfa = blob->jfa_for_frame(*this);\n+  assert(jfa->last_Java_sp() > sp(), \"must be above this frame on stack\");\n+  \/\/ Since we are walking the stack now this nested anchor is obviously walkable\n+  \/\/ even if it wasn't when it was stacked.\n+  if (!jfa->walkable()) {\n+    \/\/ Capture _last_Java_pc (if needed) and mark anchor walkable.\n+    jfa->capture_last_Java_pc();\n+  }\n+  map->clear();\n+  assert(map->include_argument_oops(), \"should be set by clear\");\n+  vmassert(jfa->last_Java_pc() != NULL, \"not walkable\");\n+  frame fr(jfa->last_Java_sp(), jfa->last_Java_fp(), jfa->last_Java_pc());\n+\n+  return fr;\n+}\n+\n@@ -519,2 +549,3 @@\n-  if (is_entry_frame())       return sender_for_entry_frame(map);\n-  if (is_interpreted_frame()) return sender_for_interpreter_frame(map);\n+  if (is_entry_frame())        return sender_for_entry_frame(map);\n+  if (is_optimized_entry_frame()) return sender_for_optimized_entry_frame(map);\n+  if (is_interpreted_frame())  return sender_for_interpreter_frame(map);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -922,0 +922,215 @@\n+\/\/ The java_calling_convention describes stack locations as ideal slots on\n+\/\/ a frame with no abi restrictions. Since we must observe abi restrictions\n+\/\/ (like the placement of the register window) the slots must be biased by\n+\/\/ the following value.\n+static int reg2offset_in(VMReg r) {\n+  \/\/ Account for saved rbp and return address\n+  \/\/ This should really be in_preserve_stack_slots\n+  return (r->reg2stack() + 4) * VMRegImpl::stack_slot_size;\n+}\n+\n+static int reg2offset_out(VMReg r) {\n+  return (r->reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;\n+}\n+\n+\/\/ A long move\n+void MacroAssembler::long_move(VMRegPair src, VMRegPair dst) {\n+\n+  \/\/ The calling conventions assures us that each VMregpair is either\n+  \/\/ all really one physical register or adjacent stack slots.\n+\n+  if (src.is_single_phys_reg() ) {\n+    if (dst.is_single_phys_reg()) {\n+      if (dst.first() != src.first()) {\n+        mov(dst.first()->as_Register(), src.first()->as_Register());\n+      }\n+    } else {\n+      assert(dst.is_single_reg(), \"not a stack pair\");\n+      movq(Address(rsp, reg2offset_out(dst.first())), src.first()->as_Register());\n+    }\n+  } else if (dst.is_single_phys_reg()) {\n+    assert(src.is_single_reg(),  \"not a stack pair\");\n+    movq(dst.first()->as_Register(), Address(rbp, reg2offset_out(src.first())));\n+  } else {\n+    assert(src.is_single_reg() && dst.is_single_reg(), \"not stack pairs\");\n+    movq(rax, Address(rbp, reg2offset_in(src.first())));\n+    movq(Address(rsp, reg2offset_out(dst.first())), rax);\n+  }\n+}\n+\n+\/\/ A double move\n+void MacroAssembler::double_move(VMRegPair src, VMRegPair dst) {\n+\n+  \/\/ The calling conventions assures us that each VMregpair is either\n+  \/\/ all really one physical register or adjacent stack slots.\n+\n+  if (src.is_single_phys_reg() ) {\n+    if (dst.is_single_phys_reg()) {\n+      \/\/ In theory these overlap but the ordering is such that this is likely a nop\n+      if ( src.first() != dst.first()) {\n+        movdbl(dst.first()->as_XMMRegister(), src.first()->as_XMMRegister());\n+      }\n+    } else {\n+      assert(dst.is_single_reg(), \"not a stack pair\");\n+      movdbl(Address(rsp, reg2offset_out(dst.first())), src.first()->as_XMMRegister());\n+    }\n+  } else if (dst.is_single_phys_reg()) {\n+    assert(src.is_single_reg(),  \"not a stack pair\");\n+    movdbl(dst.first()->as_XMMRegister(), Address(rbp, reg2offset_out(src.first())));\n+  } else {\n+    assert(src.is_single_reg() && dst.is_single_reg(), \"not stack pairs\");\n+    movq(rax, Address(rbp, reg2offset_in(src.first())));\n+    movq(Address(rsp, reg2offset_out(dst.first())), rax);\n+  }\n+}\n+\n+\n+\/\/ A float arg may have to do float reg int reg conversion\n+void MacroAssembler::float_move(VMRegPair src, VMRegPair dst) {\n+  assert(!src.second()->is_valid() && !dst.second()->is_valid(), \"bad float_move\");\n+\n+  \/\/ The calling conventions assures us that each VMregpair is either\n+  \/\/ all really one physical register or adjacent stack slots.\n+\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      movl(rax, Address(rbp, reg2offset_in(src.first())));\n+      movptr(Address(rsp, reg2offset_out(dst.first())), rax);\n+    } else {\n+      \/\/ stack to reg\n+      assert(dst.first()->is_XMMRegister(), \"only expect xmm registers as parameters\");\n+      movflt(dst.first()->as_XMMRegister(), Address(rbp, reg2offset_in(src.first())));\n+    }\n+  } else if (dst.first()->is_stack()) {\n+    \/\/ reg to stack\n+    assert(src.first()->is_XMMRegister(), \"only expect xmm registers as parameters\");\n+    movflt(Address(rsp, reg2offset_out(dst.first())), src.first()->as_XMMRegister());\n+  } else {\n+    \/\/ reg to reg\n+    \/\/ In theory these overlap but the ordering is such that this is likely a nop\n+    if ( src.first() != dst.first()) {\n+      movdbl(dst.first()->as_XMMRegister(),  src.first()->as_XMMRegister());\n+    }\n+  }\n+}\n+\n+\/\/ On 64 bit we will store integer like items to the stack as\n+\/\/ 64 bits items (x86_32\/64 abi) even though java would only store\n+\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n+\/\/ So this routine will do 32->32 on 32bit and 32->64 on 64bit\n+void MacroAssembler::move32_64(VMRegPair src, VMRegPair dst) {\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      \/\/ stack to stack\n+      movslq(rax, Address(rbp, reg2offset_in(src.first())));\n+      movq(Address(rsp, reg2offset_out(dst.first())), rax);\n+    } else {\n+      \/\/ stack to reg\n+      movslq(dst.first()->as_Register(), Address(rbp, reg2offset_in(src.first())));\n+    }\n+  } else if (dst.first()->is_stack()) {\n+    \/\/ reg to stack\n+    \/\/ Do we really have to sign extend???\n+    \/\/ __ movslq(src.first()->as_Register(), src.first()->as_Register());\n+    movq(Address(rsp, reg2offset_out(dst.first())), src.first()->as_Register());\n+  } else {\n+    \/\/ Do we really have to sign extend???\n+    \/\/ __ movslq(dst.first()->as_Register(), src.first()->as_Register());\n+    if (dst.first() != src.first()) {\n+      movq(dst.first()->as_Register(), src.first()->as_Register());\n+    }\n+  }\n+}\n+\n+void MacroAssembler::move_ptr(VMRegPair src, VMRegPair dst) {\n+  if (src.first()->is_stack()) {\n+    if (dst.first()->is_stack()) {\n+      \/\/ stack to stack\n+      movq(rax, Address(rbp, reg2offset_in(src.first())));\n+      movq(Address(rsp, reg2offset_out(dst.first())), rax);\n+    } else {\n+      \/\/ stack to reg\n+      movq(dst.first()->as_Register(), Address(rbp, reg2offset_in(src.first())));\n+    }\n+  } else if (dst.first()->is_stack()) {\n+    \/\/ reg to stack\n+    movq(Address(rsp, reg2offset_out(dst.first())), src.first()->as_Register());\n+  } else {\n+    if (dst.first() != src.first()) {\n+      movq(dst.first()->as_Register(), src.first()->as_Register());\n+    }\n+  }\n+}\n+\n+\/\/ An oop arg. Must pass a handle not the oop itself\n+void MacroAssembler::object_move(OopMap* map,\n+                        int oop_handle_offset,\n+                        int framesize_in_slots,\n+                        VMRegPair src,\n+                        VMRegPair dst,\n+                        bool is_receiver,\n+                        int* receiver_offset) {\n+\n+  \/\/ must pass a handle. First figure out the location we use as a handle\n+\n+  Register rHandle = dst.first()->is_stack() ? rax : dst.first()->as_Register();\n+\n+  \/\/ See if oop is NULL if it is we need no handle\n+\n+  if (src.first()->is_stack()) {\n+\n+    \/\/ Oop is already on the stack as an argument\n+    int offset_in_older_frame = src.first()->reg2stack() + SharedRuntime::out_preserve_stack_slots();\n+    map->set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));\n+    if (is_receiver) {\n+      *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;\n+    }\n+\n+    cmpptr(Address(rbp, reg2offset_in(src.first())), (int32_t)NULL_WORD);\n+    lea(rHandle, Address(rbp, reg2offset_in(src.first())));\n+    \/\/ conditionally move a NULL\n+    cmovptr(Assembler::equal, rHandle, Address(rbp, reg2offset_in(src.first())));\n+  } else {\n+\n+    \/\/ Oop is in an a register we must store it to the space we reserve\n+    \/\/ on the stack for oop_handles and pass a handle if oop is non-NULL\n+\n+    const Register rOop = src.first()->as_Register();\n+    int oop_slot;\n+    if (rOop == j_rarg0)\n+      oop_slot = 0;\n+    else if (rOop == j_rarg1)\n+      oop_slot = 1;\n+    else if (rOop == j_rarg2)\n+      oop_slot = 2;\n+    else if (rOop == j_rarg3)\n+      oop_slot = 3;\n+    else if (rOop == j_rarg4)\n+      oop_slot = 4;\n+    else {\n+      assert(rOop == j_rarg5, \"wrong register\");\n+      oop_slot = 5;\n+    }\n+\n+    oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;\n+    int offset = oop_slot*VMRegImpl::stack_slot_size;\n+\n+    map->set_oop(VMRegImpl::stack2reg(oop_slot));\n+    \/\/ Store oop in handle area, may be NULL\n+    movptr(Address(rsp, offset), rOop);\n+    if (is_receiver) {\n+      *receiver_offset = offset;\n+    }\n+\n+    cmpptr(rOop, (int32_t)NULL_WORD);\n+    lea(rHandle, Address(rsp, offset));\n+    \/\/ conditionally move a NULL from the handle area where it was just stored\n+    cmovptr(Assembler::equal, rHandle, Address(rsp, offset));\n+  }\n+\n+  \/\/ If arg is on the stack then place it otherwise it is already in correct reg.\n+  if (dst.first()->is_stack()) {\n+    movptr(Address(rsp, reg2offset_out(dst.first())), rHandle);\n+  }\n+}\n+\n@@ -3283,1 +3498,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3285,1 +3500,1 @@\n-    Assembler::evpcmpd(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpd(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3288,1 +3503,1 @@\n-    Assembler::evpcmpd(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpd(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3293,1 +3508,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3295,1 +3510,1 @@\n-    Assembler::evpcmpq(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpq(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3298,1 +3513,1 @@\n-    Assembler::evpcmpq(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpq(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3303,1 +3518,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3305,1 +3520,1 @@\n-    Assembler::evpcmpb(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpb(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3308,1 +3523,1 @@\n-    Assembler::evpcmpb(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpb(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3313,1 +3528,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3315,1 +3530,1 @@\n-    Assembler::evpcmpw(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpw(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3318,1 +3533,1 @@\n-    Assembler::evpcmpw(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpw(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3369,1 +3584,1 @@\n-void MacroAssembler::vpmovmskb(Register dst, XMMRegister src) {\n+void MacroAssembler::vpmovmskb(Register dst, XMMRegister src, int vector_len) {\n@@ -3371,1 +3586,1 @@\n-  Assembler::vpmovmskb(dst, src);\n+  Assembler::vpmovmskb(dst, src, vector_len);\n@@ -3384,0 +3599,10 @@\n+void MacroAssembler::vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {\n+  assert((UseAVX > 0), \"AVX support is needed\");\n+  if (reachable(src)) {\n+    Assembler::vpmulld(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(scratch_reg, src);\n+    Assembler::vpmulld(dst, nds, Address(scratch_reg, 0), vector_len);\n+  }\n+}\n+\n@@ -4695,1 +4920,1 @@\n-  assert((fs->_control_word._value & 0xffff) == StubRoutines::_fpu_cntrl_wrd_std,\n+  assert((fs->_control_word._value & 0xffff) == StubRoutines::x86::fpu_cntrl_wrd_std(),\n@@ -4761,1 +4986,1 @@\n-      ldmxcsr(ExternalAddress(StubRoutines::addr_mxcsr_std()));\n+      ldmxcsr(ExternalAddress(StubRoutines::x86::addr_mxcsr_std()));\n@@ -5341,1 +5566,1 @@\n-    fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));\n+    fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_24()));\n@@ -8545,1 +8770,1 @@\n-    evpcmpuw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    evpcmpw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, \/*signed*\/ false, Assembler::AVX_512bit);\n@@ -8595,1 +8820,1 @@\n-    evpcmpuw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    evpcmpw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, \/*signed*\/ false, Assembler::AVX_512bit);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":244,"deletions":19,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"code\/vmreg.inline.hpp\"\n+#include \"compiler\/oopMap.hpp\"\n@@ -243,0 +245,16 @@\n+#ifdef _LP64\n+  \/\/ Support for argument shuffling\n+\n+  void move32_64(VMRegPair src, VMRegPair dst);\n+  void long_move(VMRegPair src, VMRegPair dst);\n+  void float_move(VMRegPair src, VMRegPair dst);\n+  void double_move(VMRegPair src, VMRegPair dst);\n+  void move_ptr(VMRegPair src, VMRegPair dst);\n+  void object_move(OopMap* map,\n+                   int oop_handle_offset,\n+                   int framesize_in_slots,\n+                   VMRegPair src,\n+                   VMRegPair dst,\n+                   bool is_receiver,\n+                   int* receiver_offset);\n+#endif \/\/ _LP64\n@@ -1340,1 +1358,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpd(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpd(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1342,1 +1360,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1344,1 +1362,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpq(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpq(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1346,1 +1364,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1348,1 +1366,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpb(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpb(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1350,1 +1368,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1352,1 +1370,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpw(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpw(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1354,1 +1372,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1364,1 +1382,1 @@\n-  void vpmovmskb(Register dst, XMMRegister src);\n+  void vpmovmskb(Register dst, XMMRegister src, int vector_len = Assembler::AVX_256bit);\n@@ -1368,0 +1386,7 @@\n+  void vpmulld(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+    Assembler::vpmulld(dst, nds, src, vector_len);\n+  };\n+  void vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+    Assembler::vpmulld(dst, nds, src, vector_len);\n+  }\n+  void vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg);\n@@ -1840,0 +1865,1 @@\n+  void updateBytesAdler32(Register adler32, Register buf, Register length, XMMRegister shuf0, XMMRegister shuf1, ExternalAddress scale);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":35,"deletions":9,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    __ cmpw(Address(rsp, 0), StubRoutines::fpu_cntrl_wrd_std());\n+    __ cmpw(Address(rsp, 0), StubRoutines::x86::fpu_cntrl_wrd_std());\n@@ -188,1 +188,1 @@\n-    __ movw(Address(rsp, 0), StubRoutines::fpu_cntrl_wrd_std());\n+    __ movw(Address(rsp, 0), StubRoutines::x86::fpu_cntrl_wrd_std());\n@@ -195,1 +195,1 @@\n-    __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));\n+    __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n@@ -1064,0 +1064,7 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  Unimplemented();\n+  return 0;\n+}\n+\n@@ -1952,1 +1959,1 @@\n-    __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));\n+    __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n@@ -2431,1 +2438,1 @@\n-  __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));\n+  __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -462,14 +462,0 @@\n-\/\/ The java_calling_convention describes stack locations as ideal slots on\n-\/\/ a frame with no abi restrictions. Since we must observe abi restrictions\n-\/\/ (like the placement of the register window) the slots must be biased by\n-\/\/ the following value.\n-static int reg2offset_in(VMReg r) {\n-  \/\/ Account for saved rbp and return address\n-  \/\/ This should really be in_preserve_stack_slots\n-  return (r->reg2stack() + 4) * VMRegImpl::stack_slot_size;\n-}\n-\n-static int reg2offset_out(VMReg r) {\n-  return (r->reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;\n-}\n-\n@@ -1421,152 +1407,12 @@\n-\/\/ On 64 bit we will store integer like items to the stack as\n-\/\/ 64 bits items (x86_32\/64 abi) even though java would only store\n-\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n-\/\/ So this routine will do 32->32 on 32bit and 32->64 on 64bit\n-static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      \/\/ stack to stack\n-      __ movslq(rax, Address(rbp, reg2offset_in(src.first())));\n-      __ movq(Address(rsp, reg2offset_out(dst.first())), rax);\n-    } else {\n-      \/\/ stack to reg\n-      __ movslq(dst.first()->as_Register(), Address(rbp, reg2offset_in(src.first())));\n-    }\n-  } else if (dst.first()->is_stack()) {\n-    \/\/ reg to stack\n-    \/\/ Do we really have to sign extend???\n-    \/\/ __ movslq(src.first()->as_Register(), src.first()->as_Register());\n-    __ movq(Address(rsp, reg2offset_out(dst.first())), src.first()->as_Register());\n-  } else {\n-    \/\/ Do we really have to sign extend???\n-    \/\/ __ movslq(dst.first()->as_Register(), src.first()->as_Register());\n-    if (dst.first() != src.first()) {\n-      __ movq(dst.first()->as_Register(), src.first()->as_Register());\n-    }\n-  }\n-}\n-\n-static void move_ptr(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      \/\/ stack to stack\n-      __ movq(rax, Address(rbp, reg2offset_in(src.first())));\n-      __ movq(Address(rsp, reg2offset_out(dst.first())), rax);\n-    } else {\n-      \/\/ stack to reg\n-      __ movq(dst.first()->as_Register(), Address(rbp, reg2offset_in(src.first())));\n-    }\n-  } else if (dst.first()->is_stack()) {\n-    \/\/ reg to stack\n-    __ movq(Address(rsp, reg2offset_out(dst.first())), src.first()->as_Register());\n-  } else {\n-    if (dst.first() != src.first()) {\n-      __ movq(dst.first()->as_Register(), src.first()->as_Register());\n-    }\n-  }\n-}\n-\n-\/\/ An oop arg. Must pass a handle not the oop itself\n-static void object_move(MacroAssembler* masm,\n-                        OopMap* map,\n-                        int oop_handle_offset,\n-                        int framesize_in_slots,\n-                        VMRegPair src,\n-                        VMRegPair dst,\n-                        bool is_receiver,\n-                        int* receiver_offset) {\n-\n-  \/\/ must pass a handle. First figure out the location we use as a handle\n-\n-  Register rHandle = dst.first()->is_stack() ? rax : dst.first()->as_Register();\n-\n-  \/\/ See if oop is NULL if it is we need no handle\n-\n-  if (src.first()->is_stack()) {\n-\n-    \/\/ Oop is already on the stack as an argument\n-    int offset_in_older_frame = src.first()->reg2stack() + SharedRuntime::out_preserve_stack_slots();\n-    map->set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));\n-    if (is_receiver) {\n-      *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;\n-    }\n-\n-    __ cmpptr(Address(rbp, reg2offset_in(src.first())), (int32_t)NULL_WORD);\n-    __ lea(rHandle, Address(rbp, reg2offset_in(src.first())));\n-    \/\/ conditionally move a NULL\n-    __ cmovptr(Assembler::equal, rHandle, Address(rbp, reg2offset_in(src.first())));\n-  } else {\n-\n-    \/\/ Oop is in an a register we must store it to the space we reserve\n-    \/\/ on the stack for oop_handles and pass a handle if oop is non-NULL\n-\n-    const Register rOop = src.first()->as_Register();\n-    int oop_slot;\n-    if (rOop == j_rarg0)\n-      oop_slot = 0;\n-    else if (rOop == j_rarg1)\n-      oop_slot = 1;\n-    else if (rOop == j_rarg2)\n-      oop_slot = 2;\n-    else if (rOop == j_rarg3)\n-      oop_slot = 3;\n-    else if (rOop == j_rarg4)\n-      oop_slot = 4;\n-    else {\n-      assert(rOop == j_rarg5, \"wrong register\");\n-      oop_slot = 5;\n-    }\n-\n-    oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;\n-    int offset = oop_slot*VMRegImpl::stack_slot_size;\n-\n-    map->set_oop(VMRegImpl::stack2reg(oop_slot));\n-    \/\/ Store oop in handle area, may be NULL\n-    __ movptr(Address(rsp, offset), rOop);\n-    if (is_receiver) {\n-      *receiver_offset = offset;\n-    }\n-\n-    __ cmpptr(rOop, (int32_t)NULL_WORD);\n-    __ lea(rHandle, Address(rsp, offset));\n-    \/\/ conditionally move a NULL from the handle area where it was just stored\n-    __ cmovptr(Assembler::equal, rHandle, Address(rsp, offset));\n-  }\n-\n-  \/\/ If arg is on the stack then place it otherwise it is already in correct reg.\n-  if (dst.first()->is_stack()) {\n-    __ movptr(Address(rsp, reg2offset_out(dst.first())), rHandle);\n-  }\n-}\n-\n-\/\/ A float arg may have to do float reg int reg conversion\n-static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n-  assert(!src.second()->is_valid() && !dst.second()->is_valid(), \"bad float_move\");\n-\n-  \/\/ The calling conventions assures us that each VMregpair is either\n-  \/\/ all really one physical register or adjacent stack slots.\n-\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      __ movl(rax, Address(rbp, reg2offset_in(src.first())));\n-      __ movptr(Address(rsp, reg2offset_out(dst.first())), rax);\n-    } else {\n-      \/\/ stack to reg\n-      assert(dst.first()->is_XMMRegister(), \"only expect xmm registers as parameters\");\n-      __ movflt(dst.first()->as_XMMRegister(), Address(rbp, reg2offset_in(src.first())));\n-    }\n-  } else if (dst.first()->is_stack()) {\n-    \/\/ reg to stack\n-    assert(src.first()->is_XMMRegister(), \"only expect xmm registers as parameters\");\n-    __ movflt(Address(rsp, reg2offset_out(dst.first())), src.first()->as_XMMRegister());\n-  } else {\n-    \/\/ reg to reg\n-    \/\/ In theory these overlap but the ordering is such that this is likely a nop\n-    if ( src.first() != dst.first()) {\n-      __ movdbl(dst.first()->as_XMMRegister(),  src.first()->as_XMMRegister());\n-    }\n-  }\n-}\n-\n-\/\/ A long move\n-static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(num_bits == 64 || num_bits == 128 || num_bits == 256 || num_bits == 512,\n+         \"only certain vector sizes are supported for now\");\n+\n+  static const XMMRegister VEC_ArgReg[32] = {\n+     xmm0,  xmm1,  xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,\n+     xmm8,  xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,\n+    xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,\n+    xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31\n+  };\n@@ -1574,2 +1420,2 @@\n-  \/\/ The calling conventions assures us that each VMregpair is either\n-  \/\/ all really one physical register or adjacent stack slots.\n+  uint stk_args = 0;\n+  uint fp_args = 0;\n@@ -1577,16 +1423,4 @@\n-  if (src.is_single_phys_reg() ) {\n-    if (dst.is_single_phys_reg()) {\n-      if (dst.first() != src.first()) {\n-        __ mov(dst.first()->as_Register(), src.first()->as_Register());\n-      }\n-    } else {\n-      assert(dst.is_single_reg(), \"not a stack pair\");\n-      __ movq(Address(rsp, reg2offset_out(dst.first())), src.first()->as_Register());\n-    }\n-  } else if (dst.is_single_phys_reg()) {\n-    assert(src.is_single_reg(),  \"not a stack pair\");\n-    __ movq(dst.first()->as_Register(), Address(rbp, reg2offset_out(src.first())));\n-  } else {\n-    assert(src.is_single_reg() && dst.is_single_reg(), \"not stack pairs\");\n-    __ movq(rax, Address(rbp, reg2offset_in(src.first())));\n-    __ movq(Address(rsp, reg2offset_out(dst.first())), rax);\n+  for (uint i = 0; i < total_args_passed; i++) {\n+    VMReg vmreg = VEC_ArgReg[fp_args++]->as_VMReg();\n+    int next_val = num_bits == 64 ? 1 : (num_bits == 128 ? 3 : (num_bits  == 256 ? 7 : 15));\n+    regs[i].set_pair(vmreg->next(next_val), vmreg);\n@@ -1594,25 +1428,1 @@\n-}\n-\n-\/\/ A double move\n-static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n-  \/\/ The calling conventions assures us that each VMregpair is either\n-  \/\/ all really one physical register or adjacent stack slots.\n-\n-  if (src.is_single_phys_reg() ) {\n-    if (dst.is_single_phys_reg()) {\n-      \/\/ In theory these overlap but the ordering is such that this is likely a nop\n-      if ( src.first() != dst.first()) {\n-        __ movdbl(dst.first()->as_XMMRegister(), src.first()->as_XMMRegister());\n-      }\n-    } else {\n-      assert(dst.is_single_reg(), \"not a stack pair\");\n-      __ movdbl(Address(rsp, reg2offset_out(dst.first())), src.first()->as_XMMRegister());\n-    }\n-  } else if (dst.is_single_phys_reg()) {\n-    assert(src.is_single_reg(),  \"not a stack pair\");\n-    __ movdbl(dst.first()->as_XMMRegister(), Address(rbp, reg2offset_out(src.first())));\n-  } else {\n-    assert(src.is_single_reg() && dst.is_single_reg(), \"not stack pairs\");\n-    __ movq(rax, Address(rbp, reg2offset_in(src.first())));\n-    __ movq(Address(rsp, reg2offset_out(dst.first())), rax);\n-  }\n+  return stk_args;\n@@ -1622,1 +1432,0 @@\n-\n@@ -1696,1 +1505,1 @@\n-    move_ptr(masm, reg, tmp);\n+    __ move_ptr(reg, tmp);\n@@ -1702,1 +1511,1 @@\n-  move_ptr(masm, tmp, body_arg);\n+  __ move_ptr(tmp, body_arg);\n@@ -1706,1 +1515,1 @@\n-  move32_64(masm, tmp, length_arg);\n+  __ move32_64(tmp, length_arg);\n@@ -1711,2 +1520,2 @@\n-  move_ptr(masm, tmp, body_arg);\n-  move32_64(masm, tmp, length_arg);\n+  __ move_ptr(tmp, body_arg);\n+  __ move32_64(tmp, length_arg);\n@@ -1799,2 +1608,2 @@\n-  ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,\n-                    BasicType* in_sig_bt, GrowableArray<int>& arg_order, VMRegPair tmp_vmreg) {\n+  ComputeMoveOrder(int total_in_args, const VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,\n+                  const BasicType* in_sig_bt, GrowableArray<int>& arg_order, VMRegPair tmp_vmreg) {\n@@ -2397,1 +2206,1 @@\n-        object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],\n+        __ object_move(map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],\n@@ -2405,1 +2214,1 @@\n-        float_move(masm, in_regs[i], out_regs[c_arg]);\n+        __ float_move(in_regs[i], out_regs[c_arg]);\n@@ -2412,1 +2221,1 @@\n-        double_move(masm, in_regs[i], out_regs[c_arg]);\n+        __ double_move(in_regs[i], out_regs[c_arg]);\n@@ -2416,1 +2225,1 @@\n-        long_move(masm, in_regs[i], out_regs[c_arg]);\n+        __ long_move(in_regs[i], out_regs[c_arg]);\n@@ -2422,1 +2231,1 @@\n-        move32_64(masm, in_regs[i], out_regs[c_arg]);\n+        __ move32_64(in_regs[i], out_regs[c_arg]);\n@@ -4464,0 +4273,10 @@\n+\n+void SharedRuntime::compute_move_order(const BasicType* in_sig_bt,\n+                                       int total_in_args, const VMRegPair* in_regs,\n+                                       int total_out_args, VMRegPair* out_regs,\n+                                       GrowableArray<int>& arg_order,\n+                                       VMRegPair tmp_vmreg) {\n+  ComputeMoveOrder order(total_in_args, in_regs,\n+                         total_out_args, out_regs,\n+                         in_sig_bt, arg_order, tmp_vmreg);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":41,"deletions":222,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-      ExternalAddress mxcsr_std(StubRoutines::addr_mxcsr_std());\n+      ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n@@ -620,1 +620,1 @@\n-      ExternalAddress mxcsr_std(StubRoutines::addr_mxcsr_std());\n+      ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n@@ -5832,0 +5832,41 @@\n+\n+  \/***\n+   *  Arguments:\n+   *\n+   *  Inputs:\n+   *   c_rarg0   - int   adler\n+   *   c_rarg1   - byte* buff\n+   *   c_rarg2   - int   len\n+   *\n+   * Output:\n+   *   rax   - int adler result\n+   *\/\n+\n+  address generate_updateBytesAdler32() {\n+      assert(UseAdler32Intrinsics, \"need AVX2\");\n+\n+      __ align(CodeEntryAlignment);\n+      StubCodeMark mark(this, \"StubRoutines\", \"updateBytesAdler32\");\n+\n+      address start = __ pc();\n+\n+      const Register data = r9;\n+      const Register size = r10;\n+\n+      const XMMRegister yshuf0 = xmm6;\n+      const XMMRegister yshuf1 = xmm7;\n+      assert_different_registers(c_rarg0, c_rarg1, c_rarg2, data, size);\n+\n+      BLOCK_COMMENT(\"Entry:\");\n+      __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+      __ vmovdqu(yshuf0, ExternalAddress((address) StubRoutines::x86::_adler32_shuf0_table), r9);\n+      __ vmovdqu(yshuf1, ExternalAddress((address) StubRoutines::x86::_adler32_shuf1_table), r9);\n+      __ movptr(data, c_rarg1); \/\/data\n+      __ movl(size, c_rarg2); \/\/length\n+      __ updateBytesAdler32(c_rarg0, data, size, yshuf0, yshuf1, ExternalAddress((address) StubRoutines::x86::_adler32_ascale_table));\n+      __ leave();\n+      __ ret(0);\n+      return start;\n+  }\n+\n@@ -6714,17 +6755,1 @@\n-    \/\/ Round to nearest, 53-bit mode, exceptions masked\n-    StubRoutines::_fpu_cntrl_wrd_std   = 0x027F;\n-    \/\/ Round to zero, 53-bit mode, exception mased\n-    StubRoutines::_fpu_cntrl_wrd_trunc = 0x0D7F;\n-    \/\/ Round to nearest, 24-bit mode, exceptions masked\n-    StubRoutines::_fpu_cntrl_wrd_24    = 0x007F;\n-    StubRoutines::_mxcsr_std           = 0x1F80;\n-    \/\/ Note: the following two constants are 80-bit values\n-    \/\/       layout is critical for correct loading by FPU.\n-    \/\/ Bias for strict fp multiply\/divide\n-    StubRoutines::_fpu_subnormal_bias1[0]= 0x00000000; \/\/ 2^(-15360) == 0x03ff 8000 0000 0000 0000\n-    StubRoutines::_fpu_subnormal_bias1[1]= 0x80000000;\n-    StubRoutines::_fpu_subnormal_bias1[2]= 0x03ff;\n-    \/\/ Un-Bias for strict fp multiply\/divide\n-    StubRoutines::_fpu_subnormal_bias2[0]= 0x00000000; \/\/ 2^(+15360) == 0x7bff 8000 0000 0000 0000\n-    StubRoutines::_fpu_subnormal_bias2[1]= 0x80000000;\n-    StubRoutines::_fpu_subnormal_bias2[2]= 0x7bff;\n+    StubRoutines::x86::_mxcsr_std = 0x1F80;\n@@ -6942,0 +6967,5 @@\n+\n+    if (UseAdler32Intrinsics) {\n+       StubRoutines::_updateBytesAdler32 = generate_updateBytesAdler32();\n+    }\n+\n@@ -7154,0 +7184,61 @@\n+\n+    \/\/ Get svml stub routine addresses\n+    void *libsvml = NULL;\n+    char ebuf[1024];\n+    libsvml = os::dll_load(JNI_LIB_PREFIX \"svml\" JNI_LIB_SUFFIX, ebuf, sizeof ebuf);\n+    if (libsvml != NULL) {\n+      \/\/ SVML method naming convention\n+      \/\/   All the methods are named as __svml_op<T><N>_ha_<VV>\n+      \/\/   Where:\n+      \/\/      ha stands for high accuracy\n+      \/\/      <T> is optional to indicate float\/double\n+      \/\/              Set to f for vector float operation\n+      \/\/              Omitted for vector double operation\n+      \/\/      <N> is the number of elements in the vector\n+      \/\/              1, 2, 4, 8, 16\n+      \/\/              e.g. 128 bit float vector has 4 float elements\n+      \/\/      <VV> indicates the avx\/sse level:\n+      \/\/              z0 is AVX512, l9 is AVX2, e9 is AVX1 and ex is for SSE2\n+      \/\/      e.g. __svml_expf16_ha_z0 is the method for computing 16 element vector float exp using AVX 512 insns\n+      \/\/           __svml_exp8_ha_z0 is the method for computing 8 element vector double exp using AVX 512 insns\n+\n+      log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"svml\" JNI_LIB_SUFFIX, p2i(libsvml));\n+      if (UseAVX > 2) {\n+        for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n+          int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+          if ((!VM_Version::supports_avx512dq()) &&\n+              (vop == VectorSupport::VECTOR_OP_LOG || vop == VectorSupport::VECTOR_OP_LOG10 || vop == VectorSupport::VECTOR_OP_POW)) {\n+            continue;\n+          }\n+          snprintf(ebuf, sizeof(ebuf), \"__svml_%sf16_ha_z0\", VectorSupport::svmlname[op]);\n+          StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_512][op] = (address)os::dll_lookup(libsvml, ebuf);\n+\n+          snprintf(ebuf, sizeof(ebuf), \"__svml_%s8_ha_z0\", VectorSupport::svmlname[op]);\n+          StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_512][op] = (address)os::dll_lookup(libsvml, ebuf);\n+        }\n+      }\n+      const char* avx_sse_str = (UseAVX >= 2) ? \"l9\" : ((UseAVX == 1) ? \"e9\" : \"ex\");\n+      for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n+        int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+        if (vop == VectorSupport::VECTOR_OP_POW) {\n+          continue;\n+        }\n+        snprintf(ebuf, sizeof(ebuf), \"__svml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libsvml, ebuf);\n+\n+        snprintf(ebuf, sizeof(ebuf), \"__svml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libsvml, ebuf);\n+\n+        snprintf(ebuf, sizeof(ebuf), \"__svml_%sf8_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_256][op] = (address)os::dll_lookup(libsvml, ebuf);\n+\n+        snprintf(ebuf, sizeof(ebuf), \"__svml_%s1_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+        StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libsvml, ebuf);\n+\n+        snprintf(ebuf, sizeof(ebuf), \"__svml_%s2_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+        StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libsvml, ebuf);\n+\n+        snprintf(ebuf, sizeof(ebuf), \"__svml_%s4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+        StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_256][op] = (address)os::dll_lookup(libsvml, ebuf);\n+      }\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":110,"deletions":19,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -1059,1 +1059,1 @@\n-    __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));\n+    __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1712,11 +1712,2 @@\n-      Label L_strict;\n-      Label L_join;\n-      const Address access_flags      (rcx, Method::access_flags_offset());\n-      __ get_method(rcx);\n-      __ movl(rcx, access_flags);\n-      __ testl(rcx, JVM_ACC_STRICT);\n-      __ jccb(Assembler::notZero, L_strict);\n-      __ fmul_d (at_rsp());\n-      __ jmpb(L_join);\n-      __ bind(L_strict);\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));\n+      \/\/ strict semantics\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n@@ -1725,1 +1716,1 @@\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n@@ -1727,1 +1718,0 @@\n-      __ bind(L_join);\n@@ -1731,11 +1721,2 @@\n-      Label L_strict;\n-      Label L_join;\n-      const Address access_flags      (rcx, Method::access_flags_offset());\n-      __ get_method(rcx);\n-      __ movl(rcx, access_flags);\n-      __ testl(rcx, JVM_ACC_STRICT);\n-      __ jccb(Assembler::notZero, L_strict);\n-      __ fdivr_d(at_rsp());\n-      __ jmp(L_join);\n-      __ bind(L_strict);\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));\n+      \/\/ strict semantics\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n@@ -1744,1 +1725,1 @@\n-      __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));\n+      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n@@ -1746,1 +1727,0 @@\n-      __ bind(L_join);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -901,0 +901,18 @@\n+#ifdef _LP64\n+  if (supports_avx2()) {\n+    if (FLAG_IS_DEFAULT(UseAdler32Intrinsics)) {\n+      UseAdler32Intrinsics = true;\n+    }\n+  } else if (UseAdler32Intrinsics) {\n+    if (!FLAG_IS_DEFAULT(UseAdler32Intrinsics)) {\n+      warning(\"Adler32 Intrinsics requires avx2 instructions (not available on this CPU)\");\n+    }\n+    FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);\n+  }\n+#else\n+  if (UseAdler32Intrinsics) {\n+    warning(\"Adler32Intrinsics not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);\n+  }\n+#endif\n+\n@@ -996,5 +1014,0 @@\n-  if (UseAdler32Intrinsics) {\n-    warning(\"Adler32Intrinsics not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);\n-  }\n-\n@@ -1409,6 +1422,6 @@\n-      if (FLAG_IS_DEFAULT(ArrayCopyPartialInlineSize) ||\n-          (!FLAG_IS_DEFAULT(ArrayCopyPartialInlineSize) &&\n-           ArrayCopyPartialInlineSize != 0 &&\n-           ArrayCopyPartialInlineSize != 32 &&\n-           ArrayCopyPartialInlineSize != 16 &&\n-           ArrayCopyPartialInlineSize != 64)) {\n+      if (FLAG_IS_DEFAULT(ArrayOperationPartialInlineSize) ||\n+          (!FLAG_IS_DEFAULT(ArrayOperationPartialInlineSize) &&\n+           ArrayOperationPartialInlineSize != 0 &&\n+           ArrayOperationPartialInlineSize != 16 &&\n+           ArrayOperationPartialInlineSize != 32 &&\n+           ArrayOperationPartialInlineSize != 64)) {\n@@ -1423,2 +1436,2 @@\n-        if(!FLAG_IS_DEFAULT(ArrayCopyPartialInlineSize)) {\n-          warning(\"Setting ArrayCopyPartialInlineSize as %d\", inline_size);\n+        if(!FLAG_IS_DEFAULT(ArrayOperationPartialInlineSize)) {\n+          warning(\"Setting ArrayOperationPartialInlineSize as %d\", inline_size);\n@@ -1426,1 +1439,1 @@\n-        ArrayCopyPartialInlineSize = inline_size;\n+        ArrayOperationPartialInlineSize = inline_size;\n@@ -1429,4 +1442,4 @@\n-      if (ArrayCopyPartialInlineSize > MaxVectorSize) {\n-        ArrayCopyPartialInlineSize = MaxVectorSize >= 16 ? MaxVectorSize : 0;\n-        if (ArrayCopyPartialInlineSize) {\n-          warning(\"Setting ArrayCopyPartialInlineSize as MaxVectorSize\" INTX_FORMAT \")\", MaxVectorSize);\n+      if (ArrayOperationPartialInlineSize > MaxVectorSize) {\n+        ArrayOperationPartialInlineSize = MaxVectorSize >= 16 ? MaxVectorSize : 0;\n+        if (ArrayOperationPartialInlineSize) {\n+          warning(\"Setting ArrayOperationPartialInlineSize as MaxVectorSize\" INTX_FORMAT \")\", MaxVectorSize);\n@@ -1434,1 +1447,1 @@\n-          warning(\"Setting ArrayCopyPartialInlineSize as \" INTX_FORMAT, ArrayCopyPartialInlineSize);\n+          warning(\"Setting ArrayOperationPartialInlineSize as \" INTX_FORMAT, ArrayOperationPartialInlineSize);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1277,0 +1277,4 @@\n+static inline bool is_unsigned_booltest_pred(int bt) {\n+  return  ((bt & BoolTest::unsigned_compare) == BoolTest::unsigned_compare);\n+}\n+\n@@ -1577,0 +1581,1 @@\n+    case Op_VectorCmpMasked:\n@@ -1584,0 +1589,7 @@\n+    case Op_VectorMaskFirstTrue:\n+    case Op_VectorMaskLastTrue:\n+    case Op_VectorMaskTrueCount:\n+      if (!is_LP64 || UseAVX < 1) {\n+         return false;\n+      }\n+      break;\n@@ -1670,0 +1682,1 @@\n+    case Op_VectorCmpMasked:\n@@ -1699,0 +1712,5 @@\n+    case Op_CallLeafVector:\n+      if (size_in_bits == 512 && !VM_Version::supports_avx512vlbwdq()) {\n+        return false;\n+      }\n+      break;\n@@ -1824,3 +1842,0 @@\n-\/\/ x86 supports generic vector operands: vec and legVec.\n-const bool Matcher::supports_generic_vector_operands = true;\n-\n@@ -1878,17 +1893,0 @@\n-bool Matcher::supports_vector_variable_shifts(void) {\n-  return (UseAVX >= 2);\n-}\n-\n-bool Matcher::supports_vector_variable_rotates(void) {\n-  return true;\n-}\n-\n-const bool Matcher::has_predicated_vectors(void) {\n-  bool ret_value = false;\n-  if (UseAVX > 2) {\n-    ret_value = VM_Version::supports_avx512vl();\n-  }\n-\n-  return ret_value;\n-}\n-\n@@ -1966,0 +1964,4 @@\n+  \/\/ Support for calling svml double64 vectors\n+  if (bt == T_DOUBLE) {\n+    size = 1;\n+  }\n@@ -1969,4 +1971,0 @@\n-const bool Matcher::supports_scalable_vector() {\n-  return false;\n-}\n-\n@@ -1991,8 +1989,0 @@\n-\/\/ x86 supports misaligned vectors store\/load.\n-const bool Matcher::misaligned_vectors_ok() {\n-  return true;\n-}\n-\n-\n-const bool Matcher::convi2l_type_required = true;\n-\n@@ -2180,3 +2170,0 @@\n-void Compile::reshape_address(AddPNode* addp) {\n-}\n-\n@@ -2185,6 +2172,16 @@\n-    case BoolTest::eq: return Assembler::eq;\n-    case BoolTest::ne: return Assembler::neq;\n-    case BoolTest::le: return Assembler::le;\n-    case BoolTest::ge: return Assembler::nlt;\n-    case BoolTest::lt: return Assembler::lt;\n-    case BoolTest::gt: return Assembler::nle;\n+    case BoolTest::eq:\n+      return Assembler::eq;\n+    case BoolTest::ne:\n+      return Assembler::neq;\n+    case BoolTest::le:\n+    case BoolTest::ule:\n+      return Assembler::le;\n+    case BoolTest::ge:\n+    case BoolTest::uge:\n+      return Assembler::nlt;\n+    case BoolTest::lt:\n+    case BoolTest::ult:\n+      return Assembler::lt;\n+    case BoolTest::gt:\n+    case BoolTest::ugt:\n+      return Assembler::nle;\n@@ -6910,1 +6907,3 @@\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+  predicate((UseAVX <= 2 || !VM_Version::supports_avx512vl()) &&\n+            !is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n@@ -6925,2 +6924,23 @@\n-instruct evcmp(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) == 64 && \/\/ src1\n+instruct vcmpu(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n+  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) &&\n+            is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+            vector_length_in_bytes(n->in(1)->in(1)) <= 16 && \/\/ src1\n+            is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n+  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    Assembler::ComparisonPredicate cmp = booltest_pred_to_comparison_pred($cond$$constant);\n+    BasicType bt = vector_element_basic_type(this, $src1);\n+    __ vpcmpu(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n+              $vtmp2$$XMMRegister, $scratch$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcmpu32(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, legVec vtmp3, rRegP scratch) %{\n+  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) &&\n+            is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) == 32 && \/\/ src1\n@@ -6929,0 +6949,18 @@\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP scratch);\n+  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    Assembler::ComparisonPredicate cmp = booltest_pred_to_comparison_pred($cond$$constant);\n+    BasicType bt = vector_element_basic_type(this, $src1);\n+    __ vpcmpu32(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n+                $vtmp2$$XMMRegister, $vtmp3$$XMMRegister, $scratch$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct evcmp(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n+  predicate(UseAVX > 2 &&\n+            (VM_Version::supports_avx512vl() ||\n+             vector_length_in_bytes(n->in(1)->in(1)) == 64) && \/\/ src1\n+             is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n@@ -6934,1 +6972,1 @@\n-    int vlen_enc = Assembler::AVX_512bit;\n+    int vlen_enc = vector_length_encoding(this, $src1);\n@@ -6936,0 +6974,1 @@\n+    bool is_unsigned = is_unsigned_booltest_pred($cond$$constant);\n@@ -6942,1 +6981,1 @@\n-        __ evpcmpb($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpb($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6947,1 +6986,1 @@\n-        __ evpcmpw($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpw($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6952,1 +6991,1 @@\n-        __ evpcmpd($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpd($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6957,1 +6996,1 @@\n-        __ evpcmpq($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpq($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6961,1 +7000,0 @@\n-\n@@ -8063,1 +8101,28 @@\n-\/\/ ---------------------------------- Masked Block Copy ------------------------------------\n+\/\/ ---------------------------------- Masked Operations ------------------------------------\n+\n+instruct vmask_cmp_node(rRegI dst, vec src1, vec src2, kReg mask, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n+  match(Set dst (VectorCmpMasked src1 (Binary src2 mask)));\n+  effect(TEMP_DEF dst, TEMP ktmp1, TEMP ktmp2, KILL cr);\n+  format %{ \"vector_mask_cmp $src1, $src2, $mask \\t! vector mask comparison\" %}\n+  ins_encode %{\n+    assert(vector_length_encoding(this, $src1) == vector_length_encoding(this, $src2), \"mismatch\");\n+    assert(vector_element_basic_type(this, $src1) == vector_element_basic_type(this, $src2), \"mismatch\");\n+\n+    Label DONE;\n+    int vlen_enc = vector_length_encoding(this, $src1);\n+    BasicType elem_bt = vector_element_basic_type(this, $src1);\n+\n+    __ knotql($ktmp2$$KRegister, $mask$$KRegister);\n+    __ mov64($dst$$Register, -1L);\n+    __ evpcmp(elem_bt, $ktmp1$$KRegister, $mask$$KRegister, $src1$$XMMRegister, $src2$$XMMRegister, Assembler::eq, vlen_enc);\n+    __ kortestql($ktmp2$$KRegister, $ktmp1$$KRegister);\n+    __ jccb(Assembler::carrySet, DONE);\n+    __ kmovql($dst$$Register, $ktmp1$$KRegister);\n+    __ notq($dst$$Register);\n+    __ tzcntq($dst$$Register, $dst$$Register);\n+    __ bind(DONE);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n@@ -8107,0 +8172,62 @@\n+\n+instruct vmask_truecount_evex(rRegI dst, vec mask, rRegL tmp, kReg ktmp, vec xtmp) %{\n+  predicate(VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorMaskTrueCount mask));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP ktmp, TEMP xtmp);\n+  format %{ \"vector_truecount_evex $mask \\t! vector mask true count\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    int mask_len = vector_length(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $tmp$$Register, $ktmp$$KRegister, mask_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_first_or_last_true_evex(rRegI dst, vec mask, rRegL tmp, kReg ktmp, vec xtmp, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorMaskFirstTrue mask));\n+  match(Set dst (VectorMaskLastTrue mask));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP ktmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_evex $mask \\t! vector first\/last true location\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    int mask_len = vector_length(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $tmp$$Register, $ktmp$$KRegister, mask_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_truecount_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, vec xtmp1) %{\n+  predicate(!VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorMaskTrueCount mask));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, TEMP xtmp1);\n+  format %{ \"vector_truecount_avx $mask \\t! vector mask true count\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    int mask_len = vector_length(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $xtmp1$$XMMRegister, $tmp$$Register, mask_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_first_or_last_true_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, vec xtmp1, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorMaskFirstTrue mask));\n+  match(Set dst (VectorMaskLastTrue mask));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, TEMP xtmp1, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_avx $mask \\t! vector first\/last true location\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    int mask_len = vector_length(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $xtmp1$$XMMRegister, $tmp$$Register, mask_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -8108,0 +8235,22 @@\n+\n+instruct castVV(vec dst)\n+%{\n+  match(Set dst (CastVV dst));\n+\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n+instruct castVVLeg(legVec dst)\n+%{\n+  match(Set dst (CastVV dst));\n+\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":200,"deletions":51,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -688,1 +688,1 @@\n-    _masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));\n+    _masm.fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n@@ -1398,3 +1398,8 @@\n-\/\/ This is UltraSparc specific, true just means we have fast l2f conversion\n-const bool Matcher::convL2FSupported(void) {\n-  return true;\n+\/\/ Vector calling convention not supported.\n+const bool Matcher::supports_vector_calling_convention() {\n+  return false;\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n@@ -1420,63 +1425,0 @@\n-const bool Matcher::isSimpleConstant64(jlong value) {\n-  \/\/ Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.\n-  return false;\n-}\n-\n-\/\/ The ecx parameter to rep stos for the ClearArray node is in dwords.\n-const bool Matcher::init_array_count_is_in_bytes = false;\n-\n-\/\/ Needs 2 CMOV's for longs.\n-const int Matcher::long_cmove_cost() { return 1; }\n-\n-\/\/ No CMOVF\/CMOVD with SSE\/SSE2\n-const int Matcher::float_cmove_cost() { return (UseSSE>=1) ? ConditionalMoveLimit : 0; }\n-\n-\/\/ Does the CPU require late expand (see block.cpp for description of late expand)?\n-const bool Matcher::require_postalloc_expand = false;\n-\n-\/\/ Do we need to mask the count passed to shift instructions or does\n-\/\/ the cpu only look at the lower 5\/6 bits anyway?\n-const bool Matcher::need_masked_shift_count = false;\n-\n-bool Matcher::narrow_oop_use_complex_address() {\n-  ShouldNotCallThis();\n-  return true;\n-}\n-\n-bool Matcher::narrow_klass_use_complex_address() {\n-  ShouldNotCallThis();\n-  return true;\n-}\n-\n-bool Matcher::const_oop_prefer_decode() {\n-  ShouldNotCallThis();\n-  return true;\n-}\n-\n-bool Matcher::const_klass_prefer_decode() {\n-  ShouldNotCallThis();\n-  return true;\n-}\n-\n-\/\/ Is it better to copy float constants, or load them directly from memory?\n-\/\/ Intel can load a float constant from a direct address, requiring no\n-\/\/ extra registers.  Most RISCs will have to materialize an address into a\n-\/\/ register first, so they would do better to copy the constant from stack.\n-const bool Matcher::rematerialize_float_constants = true;\n-\n-\/\/ If CPU can load and store mis-aligned doubles directly then no fixup is\n-\/\/ needed.  Else we split the double into 2 integer pieces and move it\n-\/\/ piece-by-piece.  Only happens when passing doubles into C code as the\n-\/\/ Java calling convention forces doubles to be aligned.\n-const bool Matcher::misaligned_doubles_ok = true;\n-\n-\/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-const bool Matcher::strict_fp_requires_explicit_rounding = true;\n-\n-\/\/ Are floats conerted to double when stored to stack during deoptimization?\n-\/\/ On x32 it is stored with convertion only when FPU is used for floats.\n-bool Matcher::float_in_double() { return (UseSSE == 0); }\n-\n-\/\/ Do ints take an entire long register or just half?\n-const bool Matcher::int_in_long = false;\n-\n@@ -1836,1 +1778,1 @@\n-      __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));\n+      __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n@@ -1850,1 +1792,1 @@\n-      masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));\n+      masm.fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_24()));\n@@ -2403,1 +2345,1 @@\n-    emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias1() );\n+    emit_d32( cbuf, (int)StubRoutines::x86::addr_fpu_subnormal_bias1() );\n@@ -2411,1 +2353,1 @@\n-    emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias2() );\n+    emit_d32( cbuf, (int)StubRoutines::x86::addr_fpu_subnormal_bias2() );\n@@ -2946,1 +2888,1 @@\n-    emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());\n+    emit_d32(cbuf,(int)StubRoutines::x86::addr_fpu_cntrl_wrd_trunc());\n@@ -2960,2 +2902,2 @@\n-        ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()\n-        : (int)StubRoutines::addr_fpu_cntrl_wrd_std());\n+        ? (int)StubRoutines::x86::addr_fpu_cntrl_wrd_24()\n+        : (int)StubRoutines::x86::addr_fpu_cntrl_wrd_std());\n@@ -2975,1 +2917,1 @@\n-    emit_d32_reloc(cbuf, (StubRoutines::d2i_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    emit_d32_reloc(cbuf, (StubRoutines::x86::d2i_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n@@ -2982,1 +2924,1 @@\n-    emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());\n+    emit_d32(cbuf,(int)StubRoutines::x86::addr_fpu_cntrl_wrd_trunc());\n@@ -2996,2 +2938,2 @@\n-        ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()\n-        : (int)StubRoutines::addr_fpu_cntrl_wrd_std());\n+        ? (int)StubRoutines::x86::addr_fpu_cntrl_wrd_24()\n+        : (int)StubRoutines::x86::addr_fpu_cntrl_wrd_std());\n@@ -3017,1 +2959,1 @@\n-    emit_d32_reloc(cbuf, (StubRoutines::d2l_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    emit_d32_reloc(cbuf, (StubRoutines::x86::d2l_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n@@ -7246,0 +7188,16 @@\n+instruct castFF( regF dst ) %{\n+  match(Set dst (CastFF dst));\n+  format %{ \"#castFF of $dst\" %}\n+  ins_encode( \/*empty encoding*\/ );\n+  ins_cost(0);\n+  ins_pipe( empty );\n+%}\n+\n+instruct castDD( regD dst ) %{\n+  match(Set dst (CastDD dst));\n+  format %{ \"#castDD of $dst\" %}\n+  ins_encode( \/*empty encoding*\/ );\n+  ins_cost(0);\n+  ins_pipe( empty );\n+%}\n+\n@@ -9845,1 +9803,1 @@\n-  predicate( UseSSE<=1 && Compile::current()->has_method() && Compile::current()->method()->is_strict() );\n+  predicate( UseSSE<=1 && Compile::current()->has_method() );\n@@ -9847,1 +9805,1 @@\n-  ins_cost(1);   \/\/ Select this instruction for all strict FP double multiplies\n+  ins_cost(1);   \/\/ Select this instruction for all FP double multiplies\n@@ -9849,1 +9807,1 @@\n-  format %{ \"FLD    StubRoutines::_fpu_subnormal_bias1\\n\\t\"\n+  format %{ \"FLD    StubRoutines::x86::_fpu_subnormal_bias1\\n\\t\"\n@@ -9853,1 +9811,1 @@\n-            \"FLD    StubRoutines::_fpu_subnormal_bias2\\n\\t\"\n+            \"FLD    StubRoutines::x86::_fpu_subnormal_bias2\\n\\t\"\n@@ -9964,1 +9922,1 @@\n-  predicate( UseSSE<=1 && Compile::current()->has_method() && Compile::current()->method()->is_strict() );\n+  predicate( UseSSE<=1 && Compile::current()->has_method() );\n@@ -9967,1 +9925,1 @@\n-  format %{ \"FLD    StubRoutines::_fpu_subnormal_bias1\\n\\t\"\n+  format %{ \"FLD    StubRoutines::x86::_fpu_subnormal_bias1\\n\\t\"\n@@ -9971,1 +9929,1 @@\n-            \"FLD    StubRoutines::_fpu_subnormal_bias2\\n\\t\"\n+            \"FLD    StubRoutines::x86::_fpu_subnormal_bias2\\n\\t\"\n@@ -9981,14 +9939,0 @@\n-instruct divDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{\n-  predicate( UseSSE<=1 && !(Compile::current()->has_method() && Compile::current()->method()->is_strict()) );\n-  match(Set dst (RoundDouble (DivD src1 src2)));\n-\n-  format %{ \"FLD    $src1\\n\\t\"\n-            \"FDIV   ST,$src2\\n\\t\"\n-            \"FSTP_D $dst\\t# D-round\" %}\n-  opcode(0xD8, 0x6); \/* D8 F0+i or D8 \/6 *\/\n-  ins_encode( Push_Reg_DPR(src1),\n-              OpcP, RegOpc(src2), Pop_Mem_DPR(dst) );\n-  ins_pipe( fpu_mem_reg_reg );\n-%}\n-\n-\n@@ -10846,1 +10790,1 @@\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_wrapper())));\n@@ -10902,1 +10846,1 @@\n-    __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));\n+    __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_trunc()));\n@@ -10906,1 +10850,1 @@\n-      __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));\n+      __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_24()));\n@@ -10908,1 +10852,1 @@\n-      __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));\n+      __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n@@ -10921,1 +10865,1 @@\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_wrapper())));\n@@ -10976,1 +10920,1 @@\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_wrapper())));\n@@ -11033,1 +10977,1 @@\n-    __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));\n+    __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_trunc()));\n@@ -11037,1 +10981,1 @@\n-      __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));\n+      __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_24()));\n@@ -11039,1 +10983,1 @@\n-      __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));\n+      __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n@@ -11052,1 +10996,1 @@\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_wrapper())));\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":54,"deletions":110,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -470,1 +470,3 @@\n-  offset += clear_avx_size();\n+  if (this->ideal_Opcode() != Op_CallLeafVector) {\n+    offset += clear_avx_size();\n+  }\n@@ -1694,3 +1696,15 @@\n-\/\/ This is UltraSparc specific, true just means we have fast l2f conversion\n-const bool Matcher::convL2FSupported(void) {\n-  return true;\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  if (EnableVectorSupport && UseVectorStubs) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  int lo = XMM0_num;\n+  int hi = XMM0b_num;\n+  if (ideal_reg == Op_VecX) hi = XMM0d_num;\n+  else if (ideal_reg == Op_VecY) hi = XMM0h_num;\n+  else if (ideal_reg == Op_VecZ) hi = XMM0p_num;\n+  return OptoRegPair(hi, lo);\n@@ -1716,67 +1730,0 @@\n-const bool Matcher::isSimpleConstant64(jlong value) {\n-  \/\/ Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.\n-  \/\/return value == (int) value;  \/\/ Cf. storeImmL and immL32.\n-\n-  \/\/ Probably always true, even if a temp register is required.\n-  return true;\n-}\n-\n-\/\/ The ecx parameter to rep stosq for the ClearArray node is in words.\n-const bool Matcher::init_array_count_is_in_bytes = false;\n-\n-\/\/ No additional cost for CMOVL.\n-const int Matcher::long_cmove_cost() { return 0; }\n-\n-\/\/ No CMOVF\/CMOVD with SSE2\n-const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }\n-\n-\/\/ Does the CPU require late expand (see block.cpp for description of late expand)?\n-const bool Matcher::require_postalloc_expand = false;\n-\n-\/\/ Do we need to mask the count passed to shift instructions or does\n-\/\/ the cpu only look at the lower 5\/6 bits anyway?\n-const bool Matcher::need_masked_shift_count = false;\n-\n-bool Matcher::narrow_oop_use_complex_address() {\n-  assert(UseCompressedOops, \"only for compressed oops code\");\n-  return (LogMinObjAlignmentInBytes <= 3);\n-}\n-\n-bool Matcher::narrow_klass_use_complex_address() {\n-  assert(UseCompressedClassPointers, \"only for compressed klass code\");\n-  return (LogKlassAlignmentInBytes <= 3);\n-}\n-\n-bool Matcher::const_oop_prefer_decode() {\n-  \/\/ Prefer ConN+DecodeN over ConP.\n-  return true;\n-}\n-\n-bool Matcher::const_klass_prefer_decode() {\n-  \/\/ Prefer ConP over ConNKlass+DecodeNKlass.\n-  return false;\n-}\n-\n-\/\/ Is it better to copy float constants, or load them directly from\n-\/\/ memory?  Intel can load a float constant from a direct address,\n-\/\/ requiring no extra registers.  Most RISCs will have to materialize\n-\/\/ an address into a register first, so they would do better to copy\n-\/\/ the constant from stack.\n-const bool Matcher::rematerialize_float_constants = true; \/\/ XXX\n-\n-\/\/ If CPU can load and store mis-aligned doubles directly then no\n-\/\/ fixup is needed.  Else we split the double into 2 integer pieces\n-\/\/ and move it piece-by-piece.  Only happens when passing doubles into\n-\/\/ C code as the Java calling convention forces doubles to be aligned.\n-const bool Matcher::misaligned_doubles_ok = true;\n-\n-\/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-const bool Matcher::strict_fp_requires_explicit_rounding = false;\n-\n-\/\/ Are floats conerted to double when stored to stack during deoptimization?\n-\/\/ On x64 it is stored without convertion so we can use normal access.\n-bool Matcher::float_in_double() { return false; }\n-\n-\/\/ Do ints take an entire long register or just half?\n-const bool Matcher::int_in_long = true;\n-\n@@ -1956,0 +1903,3 @@\n+    MacroAssembler _masm(&cbuf);\n+    Label normal;\n+    Label done;\n@@ -1958,5 +1908,1 @@\n-    emit_opcode(cbuf, 0x3d);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x80);\n+    __ cmp(as_Register(RAX_enc), 0x80000000);\n@@ -1965,2 +1911,1 @@\n-    emit_opcode(cbuf, 0x75);\n-    emit_d8(cbuf, $div$$reg < 8 ? 0x07 : 0x08);\n+    __ jccb(Assembler::notEqual, normal);\n@@ -1969,2 +1914,1 @@\n-    emit_opcode(cbuf, 0x33);\n-    emit_d8(cbuf, 0xD2);\n+    __ xorl(as_Register(RDX_enc), as_Register(RDX_enc));\n@@ -1973,6 +1917,1 @@\n-    if ($div$$reg >= 8) {\n-      emit_opcode(cbuf, Assembler::REX_B);\n-    }\n-    emit_opcode(cbuf, 0x83);\n-    emit_rm(cbuf, 0x3, 0x7, $div$$reg & 7);\n-    emit_d8(cbuf, 0xFF);\n+    __ cmpl($div$$Register, -1);\n@@ -1981,2 +1920,1 @@\n-    emit_opcode(cbuf, 0x74);\n-    emit_d8(cbuf, $div$$reg < 8 ? 0x03 : 0x04);\n+    __ jccb(Assembler::equal, done);\n@@ -1986,1 +1924,2 @@\n-    emit_opcode(cbuf, 0x99);\n+    __ bind(normal);\n+    __ cdql();\n@@ -1988,1 +1927,1 @@\n-    \/\/ idivl (note: must be emitted by the user of this rule)\n+    \/\/ idivl\n@@ -1990,0 +1929,2 @@\n+    __ idivl($div$$Register);\n+    __ bind(done);\n@@ -2018,0 +1959,3 @@\n+    MacroAssembler _masm(&cbuf);\n+    Label normal;\n+    Label done;\n@@ -2020,10 +1964,1 @@\n-    emit_opcode(cbuf, Assembler::REX_W);\n-    emit_opcode(cbuf, 0xBA);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x00);\n-    emit_d8(cbuf, 0x80);\n+    __ mov64(as_Register(RDX_enc), 0x8000000000000000);\n@@ -2032,3 +1967,1 @@\n-    emit_opcode(cbuf, Assembler::REX_W);\n-    emit_opcode(cbuf, 0x39);\n-    emit_d8(cbuf, 0xD0);\n+    __ cmpq(as_Register(RAX_enc), as_Register(RDX_enc));\n@@ -2037,2 +1970,1 @@\n-    emit_opcode(cbuf, 0x75);\n-    emit_d8(cbuf, 0x08);\n+    __ jccb(Assembler::notEqual, normal);\n@@ -2041,2 +1973,1 @@\n-    emit_opcode(cbuf, 0x33);\n-    emit_d8(cbuf, 0xD2);\n+    __ xorl(as_Register(RDX_enc), as_Register(RDX_enc));\n@@ -2045,4 +1976,1 @@\n-    emit_opcode(cbuf, $div$$reg < 8 ? Assembler::REX_W : Assembler::REX_WB);\n-    emit_opcode(cbuf, 0x83);\n-    emit_rm(cbuf, 0x3, 0x7, $div$$reg & 7);\n-    emit_d8(cbuf, 0xFF);\n+    __ cmpq($div$$Register, -1);\n@@ -2051,2 +1979,1 @@\n-    emit_opcode(cbuf, 0x74);\n-    emit_d8(cbuf, 0x05);\n+    __ jccb(Assembler::equal, done);\n@@ -2056,2 +1983,2 @@\n-    emit_opcode(cbuf, Assembler::REX_W);\n-    emit_opcode(cbuf, 0x99);\n+    __ bind(normal);\n+    __ cdqq();\n@@ -2061,0 +1988,2 @@\n+    __ idivq($div$$Register);\n+    __ bind(done);\n@@ -5229,2 +5158,3 @@\n-  opcode(0x8B);\n-  ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ movl($dst$$Register, $mem$$Address);\n+  %}\n@@ -5242,2 +5172,3 @@\n-  opcode(0x8B);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ movq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5268,2 +5199,3 @@\n-  opcode(0x8B);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ movq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5564,2 +5496,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5575,2 +5508,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5580,11 +5514,0 @@\n-\/\/ instruct leaPIdx(rRegP dst, indIndex mem)\n-\/\/ %{\n-\/\/   match(Set dst mem);\n-\n-\/\/   ins_cost(110);\n-\/\/   format %{ \"leaq    $dst, $mem\\t# ptr idx\" %}\n-\/\/   opcode(0x8D);\n-\/\/   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n-\/\/   ins_pipe(ialu_reg_reg_fat);\n-\/\/ %}\n-\n@@ -5597,2 +5520,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5608,2 +5532,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5619,2 +5544,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5630,2 +5556,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5641,2 +5568,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5652,2 +5580,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5665,2 +5594,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5677,2 +5607,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5689,2 +5620,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5701,2 +5633,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5713,2 +5646,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5725,2 +5659,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5737,2 +5672,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5749,2 +5685,3 @@\n-  opcode(0x8D);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ leaq($dst$$Register, $mem$$Address);\n+  %}\n@@ -5759,1 +5696,3 @@\n-  ins_encode(load_immI(dst, src));\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$constant);\n+  %}\n@@ -5770,2 +5709,3 @@\n-  opcode(0x33); \/* + rd *\/\n-  ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));\n+  ins_encode %{\n+    __ xorl($dst$$Register, $dst$$Register);\n+  %}\n@@ -5781,1 +5721,3 @@\n-  ins_encode(load_immL(dst, src));\n+  ins_encode %{\n+    __ mov64($dst$$Register, $src$$constant);\n+  %}\n@@ -5792,2 +5734,3 @@\n-  opcode(0x33); \/* + rd *\/\n-  ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));\n+  ins_encode %{\n+    __ xorl($dst$$Register, $dst$$Register);\n+  %}\n@@ -5803,1 +5746,3 @@\n-  ins_encode(load_immUL32(dst, src));\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$constant);\n+  %}\n@@ -5813,1 +5758,3 @@\n-  ins_encode(load_immL32(dst, src));\n+  ins_encode %{\n+    __ movq($dst$$Register, $src$$constant);\n+  %}\n@@ -5821,1 +5768,3 @@\n-  ins_encode(load_immP(dst, con));\n+  ins_encode %{\n+    __ mov64($dst$$Register, $con$$constant, $con->constant_reloc(), RELOC_IMM64);\n+  %}\n@@ -5832,2 +5781,3 @@\n-  opcode(0x33); \/* + rd *\/\n-  ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));\n+  ins_encode %{\n+    __ xorl($dst$$Register, $dst$$Register);\n+  %}\n@@ -5844,1 +5794,3 @@\n-  ins_encode(load_immP31(dst, src));\n+  ins_encode %{\n+    __ movl($dst$$Register, $src$$constant);\n+  %}\n@@ -6053,2 +6005,3 @@\n-  opcode(0x88);\n-  ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));\n+  ins_encode %{\n+    __ movb($mem$$Address, $src$$Register);\n+  %}\n@@ -6065,2 +6018,3 @@\n-  opcode(0x89);\n-  ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));\n+  ins_encode %{\n+    __ movw($mem$$Address, $src$$Register);\n+  %}\n@@ -6077,2 +6031,3 @@\n-  opcode(0x89);\n-  ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));\n+  ins_encode %{\n+    __ movl($mem$$Address, $src$$Register);\n+  %}\n@@ -6089,2 +6044,3 @@\n-  opcode(0x89);\n-  ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));\n+  ins_encode %{\n+    __ movq($mem$$Address, $src$$Register);\n+  %}\n@@ -6101,2 +6057,3 @@\n-  opcode(0x89);\n-  ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));\n+  ins_encode %{\n+    __ movq($mem$$Address, $src$$Register);\n+  %}\n@@ -6126,2 +6083,3 @@\n-  opcode(0xC7); \/* C7 \/0 *\/\n-  ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));\n+  ins_encode %{\n+    __ movq($mem$$Address, $src$$constant);\n+  %}\n@@ -6218,2 +6176,3 @@\n-  opcode(0xC7); \/* C7 \/0 *\/\n-  ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));\n+  ins_encode %{\n+    __ movl($mem$$Address, $src$$constant);\n+  %}\n@@ -6243,2 +6202,3 @@\n-  opcode(0xC7); \/* C7 \/0 *\/\n-  ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));\n+  ins_encode %{\n+    __ movq($mem$$Address, $src$$constant);\n+  %}\n@@ -6269,2 +6229,3 @@\n-  opcode(0xC7); \/* C7 \/0 Same as 32 store immediate with prefix *\/\n-  ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));\n+  ins_encode %{\n+    __ movw($mem$$Address, $src$$constant);\n+  %}\n@@ -6294,2 +6255,3 @@\n-  opcode(0xC6); \/* C6 \/0 *\/\n-  ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));\n+  ins_encode %{\n+    __ movb($mem$$Address, $src$$constant);\n+  %}\n@@ -6319,2 +6281,3 @@\n-  opcode(0xC6); \/* C6 \/0 *\/\n-  ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));\n+  ins_encode %{\n+    __ movb($mem$$Address, $src$$constant);\n+  %}\n@@ -6357,2 +6320,3 @@\n-  opcode(0xC7); \/* C7 \/0 *\/\n-  ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));\n+  ins_encode %{\n+    __ movl($mem$$Address, jint_cast($src$$constant));\n+  %}\n@@ -6383,2 +6347,3 @@\n-  opcode(0xC7); \/* C7 \/0 *\/\n-  ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));\n+  ins_encode %{\n+    __ movq($mem$$Address, $src$$constant);\n+  %}\n@@ -6504,2 +6469,3 @@\n-  opcode(0x0F, 0xC8);  \/*Opcode 0F \/C8 *\/\n-  ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );\n+  ins_encode %{\n+    __ bswapl($dst$$Register);\n+  %}\n@@ -6513,2 +6479,3 @@\n-  opcode(0x0F, 0xC8); \/* Opcode 0F \/C8 *\/\n-  ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );\n+  ins_encode %{\n+    __ bswapq($dst$$Register);\n+  %}\n@@ -7045,2 +7012,3 @@\n-  opcode(0x0F, 0x40);\n-  ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));\n+  ins_encode %{\n+    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n@@ -7055,2 +7023,3 @@\n-  opcode(0x0F, 0x40);\n-  ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));\n+  ins_encode %{\n+    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n@@ -7074,2 +7043,3 @@\n-  opcode(0x0F, 0x40);\n-  ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));\n+  ins_encode %{\n+    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Address);\n+  %}\n@@ -7086,2 +7056,3 @@\n-  opcode(0x0F, 0x40);\n-  ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));\n+  ins_encode %{\n+    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Address);\n+  %}\n@@ -7106,2 +7077,3 @@\n-  opcode(0x0F, 0x40);\n-  ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));\n+  ins_encode %{\n+    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n@@ -7118,2 +7090,3 @@\n-  opcode(0x0F, 0x40);\n-  ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));\n+  ins_encode %{\n+    __ cmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n@@ -7138,2 +7111,3 @@\n-  opcode(0x0F, 0x40);\n-  ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));\n+  ins_encode %{\n+    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n@@ -7150,2 +7124,3 @@\n-  opcode(0x0F, 0x40);\n-  ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));\n+  ins_encode %{\n+    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n@@ -7196,2 +7171,3 @@\n-  opcode(0x0F, 0x40);\n-  ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));\n+  ins_encode %{\n+    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n@@ -7207,2 +7183,3 @@\n-  opcode(0x0F, 0x40);\n-  ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));\n+  ins_encode %{\n+    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Address);\n+  %}\n@@ -7218,2 +7195,3 @@\n-  opcode(0x0F, 0x40);\n-  ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));\n+  ins_encode %{\n+    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+  %}\n@@ -7237,2 +7215,3 @@\n-  opcode(0x0F, 0x40);\n-  ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));\n+  ins_encode %{\n+    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Address);\n+  %}\n@@ -7359,2 +7338,3 @@\n-  opcode(0x03);\n-  ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ addl($dst$$Register, $src$$Register);\n+  %}\n@@ -7370,2 +7350,3 @@\n-  opcode(0x81, 0x00); \/* \/0 id *\/\n-  ins_encode(OpcSErm(dst, src), Con8or32(src));\n+  ins_encode %{\n+    __ addl($dst$$Register, $src$$constant);\n+  %}\n@@ -7382,2 +7363,3 @@\n-  opcode(0x03);\n-  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ addl($dst$$Register, $src$$Address);\n+  %}\n@@ -7394,2 +7376,3 @@\n-  opcode(0x01); \/* Opcode 01 \/r *\/\n-  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ addl($dst$$Address, $src$$Register);\n+  %}\n@@ -7406,2 +7389,3 @@\n-  opcode(0x81); \/* Opcode 81 \/0 id *\/\n-  ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));\n+  ins_encode %{\n+    __ addl($dst$$Address, $src$$constant);\n+  %}\n@@ -7418,2 +7402,3 @@\n-  opcode(0xFF, 0x00); \/\/ FF \/0\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ incrementl($dst$$Register);\n+  %}\n@@ -7431,2 +7416,3 @@\n-  opcode(0xFF); \/* Opcode FF \/0 *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));\n+  ins_encode %{\n+    __ incrementl($dst$$Address);\n+  %}\n@@ -7444,2 +7430,3 @@\n-  opcode(0xFF, 0x01); \/\/ FF \/1\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ decrementl($dst$$Register);\n+  %}\n@@ -7458,2 +7445,3 @@\n-  opcode(0xFF); \/* Opcode FF \/1 *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));\n+  ins_encode %{\n+    __ decrementl($dst$$Address);\n+  %}\n@@ -7469,2 +7457,3 @@\n-  opcode(0x8D); \/* 0x8D \/r *\/\n-  ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); \/\/ XXX\n+  ins_encode %{\n+    __ leal($dst$$Register, Address($src0$$Register, $src1$$constant));\n+  %}\n@@ -7480,2 +7469,3 @@\n-  opcode(0x03);\n-  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ addq($dst$$Register, $src$$Register);\n+  %}\n@@ -7491,2 +7481,3 @@\n-  opcode(0x81, 0x00); \/* \/0 id *\/\n-  ins_encode(OpcSErm_wide(dst, src), Con8or32(src));\n+  ins_encode %{\n+    __ addq($dst$$Register, $src$$constant);\n+  %}\n@@ -7503,2 +7494,3 @@\n-  opcode(0x03);\n-  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ addq($dst$$Register, $src$$Address);\n+  %}\n@@ -7515,2 +7507,3 @@\n-  opcode(0x01); \/* Opcode 01 \/r *\/\n-  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ addq($dst$$Address, $src$$Register);\n+  %}\n@@ -7527,3 +7520,3 @@\n-  opcode(0x81); \/* Opcode 81 \/0 id *\/\n-  ins_encode(REX_mem_wide(dst),\n-             OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));\n+  ins_encode %{\n+    __ addq($dst$$Address, $src$$constant);\n+  %}\n@@ -7540,2 +7533,3 @@\n-  opcode(0xFF, 0x00); \/\/ FF \/0\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ incrementq($dst$$Register);\n+  %}\n@@ -7553,2 +7547,3 @@\n-  opcode(0xFF); \/* Opcode FF \/0 *\/\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));\n+  ins_encode %{\n+    __ incrementq($dst$$Address);\n+  %}\n@@ -7566,2 +7561,3 @@\n-  opcode(0xFF, 0x01); \/\/ FF \/1\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ decrementq($dst$$Register);\n+  %}\n@@ -7580,2 +7576,3 @@\n-  opcode(0xFF); \/* Opcode FF \/1 *\/\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));\n+  ins_encode %{\n+    __ decrementq($dst$$Address);\n+  %}\n@@ -7591,2 +7588,3 @@\n-  opcode(0x8D); \/* 0x8D \/r *\/\n-  ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); \/\/ XXX\n+  ins_encode %{\n+    __ leaq($dst$$Register, Address($src0$$Register, $src1$$constant));\n+  %}\n@@ -7602,2 +7600,3 @@\n-  opcode(0x03);\n-  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ addq($dst$$Register, $src$$Register);\n+  %}\n@@ -7613,2 +7612,3 @@\n-  opcode(0x81, 0x00); \/* \/0 id *\/\n-  ins_encode(OpcSErm_wide(dst, src), Con8or32(src));\n+  ins_encode %{\n+    __ addq($dst$$Register, $src$$constant);\n+  %}\n@@ -7626,2 +7626,3 @@\n-  opcode(0x8D); \/* 0x8D \/r *\/\n-  ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));\/\/ XXX\n+  ins_encode %{\n+    __ leaq($dst$$Register, Address($src0$$Register, $src1$$constant));\n+  %}\n@@ -7673,0 +7674,22 @@\n+instruct castFF(regF dst)\n+%{\n+  match(Set dst (CastFF dst));\n+\n+  size(0);\n+  format %{ \"# castFF of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n+instruct castDD(regD dst)\n+%{\n+  match(Set dst (CastDD dst));\n+\n+  size(0);\n+  format %{ \"# castDD of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n@@ -7680,2 +7703,3 @@\n-  opcode(0x8B);\n-  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));\n+  ins_encode %{\n+    __ movq($dst$$Register, $mem$$Address);\n+  %}\n@@ -7698,5 +7722,4 @@\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             REX_reg_mem_wide(newval, heap_top_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, heap_top_ptr));\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgq($newval$$Register, $heap_top_ptr$$Address);\n+  %}\n@@ -7730,5 +7753,4 @@\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             REX_reg_mem_wide(newval, mem),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem));\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgq($newval$$Register, $mem$$Address);\n+  %}\n@@ -7754,8 +7776,6 @@\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             REX_reg_mem_wide(newval, mem_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem_ptr),\n-             REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), \/\/ sete\n-             REX_reg_breg(res, res), \/\/ movzbl\n-             Opcode(0xF), Opcode(0xB6), reg_reg(res, res));\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgq($newval$$Register, $mem_ptr$$Address);\n+    __ sete($res$$Register);\n+    __ movzbl($res$$Register, $res$$Register);\n+  %}\n@@ -7779,8 +7799,6 @@\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             REX_reg_mem_wide(newval, mem_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem_ptr),\n-             REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), \/\/ sete\n-             REX_reg_breg(res, res), \/\/ movzbl\n-             Opcode(0xF), Opcode(0xB6), reg_reg(res, res));\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgq($newval$$Register, $mem_ptr$$Address);\n+    __ sete($res$$Register);\n+    __ movzbl($res$$Register, $res$$Register);\n+  %}\n@@ -7803,8 +7821,6 @@\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             REX_reg_mem(newval, mem_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem_ptr),\n-             REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), \/\/ sete\n-             REX_reg_breg(res, res), \/\/ movzbl\n-             Opcode(0xF), Opcode(0xB6), reg_reg(res, res));\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgl($newval$$Register, $mem_ptr$$Address);\n+    __ sete($res$$Register);\n+    __ movzbl($res$$Register, $res$$Register);\n+  %}\n@@ -7827,8 +7843,6 @@\n-  opcode(0x0F, 0xB0);\n-  ins_encode(lock_prefix,\n-             REX_breg_mem(newval, mem_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem_ptr),\n-             REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), \/\/ sete\n-             REX_reg_breg(res, res), \/\/ movzbl\n-             Opcode(0xF), Opcode(0xB6), reg_reg(res, res));\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgb($newval$$Register, $mem_ptr$$Address);\n+    __ sete($res$$Register);\n+    __ movzbl($res$$Register, $res$$Register);\n+  %}\n@@ -7851,9 +7865,6 @@\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             SizePrefix,\n-             REX_reg_mem(newval, mem_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem_ptr),\n-             REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), \/\/ sete\n-             REX_reg_breg(res, res), \/\/ movzbl\n-             Opcode(0xF), Opcode(0xB6), reg_reg(res, res));\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgw($newval$$Register, $mem_ptr$$Address);\n+    __ sete($res$$Register);\n+    __ movzbl($res$$Register, $res$$Register);\n+  %}\n@@ -7875,8 +7886,6 @@\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             REX_reg_mem(newval, mem_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem_ptr),\n-             REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), \/\/ sete\n-             REX_reg_breg(res, res), \/\/ movzbl\n-             Opcode(0xF), Opcode(0xB6), reg_reg(res, res));\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgl($newval$$Register, $mem_ptr$$Address);\n+    __ sete($res$$Register);\n+    __ movzbl($res$$Register, $res$$Register);\n+  %}\n@@ -7896,6 +7905,4 @@\n-  opcode(0x0F, 0xB0);\n-  ins_encode(lock_prefix,\n-             REX_breg_mem(newval, mem_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem_ptr) \/\/ lock cmpxchg\n-             );\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgb($newval$$Register, $mem_ptr$$Address);\n+  %}\n@@ -7915,7 +7922,4 @@\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             SizePrefix,\n-             REX_reg_mem(newval, mem_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem_ptr) \/\/ lock cmpxchg\n-             );\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgw($newval$$Register, $mem_ptr$$Address);\n+  %}\n@@ -7935,6 +7939,4 @@\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             REX_reg_mem(newval, mem_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem_ptr) \/\/ lock cmpxchg\n-             );\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgl($newval$$Register, $mem_ptr$$Address);\n+  %}\n@@ -7955,6 +7957,4 @@\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             REX_reg_mem_wide(newval, mem_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem_ptr)  \/\/ lock cmpxchg\n-            );\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgq($newval$$Register, $mem_ptr$$Address);\n+  %}\n@@ -7973,6 +7973,4 @@\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             REX_reg_mem(newval, mem_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem_ptr)  \/\/ lock cmpxchg\n-          );\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgl($newval$$Register, $mem_ptr$$Address);\n+  %}\n@@ -7993,6 +7991,4 @@\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             REX_reg_mem_wide(newval, mem_ptr),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem_ptr)  \/\/ lock cmpxchg\n-          );\n+  ins_encode %{\n+    __ lock();\n+    __ cmpxchgq($newval$$Register, $mem_ptr$$Address);\n+  %}\n@@ -8204,2 +8200,3 @@\n-  opcode(0x2B);\n-  ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ subl($dst$$Register, $src$$Register);\n+  %}\n@@ -8215,2 +8212,3 @@\n-  opcode(0x81, 0x05);  \/* Opcode 81 \/5 *\/\n-  ins_encode(OpcSErm(dst, src), Con8or32(src));\n+  ins_encode %{\n+    __ subl($dst$$Register, $src$$constant);\n+  %}\n@@ -8227,2 +8225,3 @@\n-  opcode(0x2B);\n-  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ subl($dst$$Register, $src$$Address);\n+  %}\n@@ -8239,2 +8238,3 @@\n-  opcode(0x29); \/* Opcode 29 \/r *\/\n-  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ subl($dst$$Address, $src$$Register);\n+  %}\n@@ -8251,2 +8251,3 @@\n-  opcode(0x81); \/* Opcode 81 \/5 id *\/\n-  ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));\n+  ins_encode %{\n+    __ subl($dst$$Address, $src$$constant);\n+  %}\n@@ -8262,2 +8263,3 @@\n-  opcode(0x2B);\n-  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ subq($dst$$Register, $src$$Register);\n+  %}\n@@ -8273,2 +8275,3 @@\n-  opcode(0x81, 0x05);  \/* Opcode 81 \/5 *\/\n-  ins_encode(OpcSErm_wide(dst, src), Con8or32(src));\n+  ins_encode %{\n+    __ subq($dst$$Register, $src$$constant);\n+  %}\n@@ -8285,2 +8288,3 @@\n-  opcode(0x2B);\n-  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ subq($dst$$Register, $src$$Address);\n+  %}\n@@ -8297,2 +8301,3 @@\n-  opcode(0x29); \/* Opcode 29 \/r *\/\n-  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ subq($dst$$Address, $src$$Register);\n+  %}\n@@ -8309,3 +8314,3 @@\n-  opcode(0x81); \/* Opcode 81 \/5 id *\/\n-  ins_encode(REX_mem_wide(dst),\n-             OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));\n+  ins_encode %{\n+    __ subq($dst$$Address, $src$$constant);\n+  %}\n@@ -8334,2 +8339,3 @@\n-  opcode(0xF7, 0x03);  \/\/ Opcode F7 \/3\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ negl($dst$$Register);\n+  %}\n@@ -8357,2 +8363,3 @@\n-  opcode(0xF7, 0x03);  \/\/ Opcode F7 \/3\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ negl($dst$$Address);\n+  %}\n@@ -8368,2 +8375,3 @@\n-  opcode(0xF7, 0x03);  \/\/ Opcode F7 \/3\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ negq($dst$$Register);\n+  %}\n@@ -8391,2 +8399,3 @@\n-  opcode(0xF7, 0x03);  \/\/ Opcode F7 \/3\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ negq($dst$$Address);\n+  %}\n@@ -8407,2 +8416,3 @@\n-  opcode(0x0F, 0xAF);\n-  ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));\n+  ins_encode %{\n+    __ imull($dst$$Register, $src$$Register);\n+  %}\n@@ -8419,3 +8429,3 @@\n-  opcode(0x69); \/* 69 \/r id *\/\n-  ins_encode(REX_reg_reg(dst, src),\n-             OpcSE(imm), reg_reg(dst, src), Con8or32(imm));\n+  ins_encode %{\n+    __ imull($dst$$Register, $src$$Register, $imm$$constant);\n+  %}\n@@ -8432,2 +8442,3 @@\n-  opcode(0x0F, 0xAF);\n-  ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));\n+  ins_encode %{\n+    __ imull($dst$$Register, $src$$Address);\n+  %}\n@@ -8444,3 +8455,3 @@\n-  opcode(0x69); \/* 69 \/r id *\/\n-  ins_encode(REX_reg_mem(dst, src),\n-             OpcSE(imm), reg_mem(dst, src), Con8or32(imm));\n+  ins_encode %{\n+    __ imull($dst$$Register, $src$$Address, $imm$$constant);\n+  %}\n@@ -8467,2 +8478,3 @@\n-  opcode(0x0F, 0xAF);\n-  ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));\n+  ins_encode %{\n+    __ imulq($dst$$Register, $src$$Register);\n+  %}\n@@ -8479,3 +8491,3 @@\n-  opcode(0x69); \/* 69 \/r id *\/\n-  ins_encode(REX_reg_reg_wide(dst, src),\n-             OpcSE(imm), reg_reg(dst, src), Con8or32(imm));\n+  ins_encode %{\n+    __ imulq($dst$$Register, $src$$Register, $imm$$constant);\n+  %}\n@@ -8492,2 +8504,3 @@\n-  opcode(0x0F, 0xAF);\n-  ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));\n+  ins_encode %{\n+    __ imulq($dst$$Register, $src$$Address);\n+  %}\n@@ -8504,3 +8517,3 @@\n-  opcode(0x69); \/* 69 \/r id *\/\n-  ins_encode(REX_reg_mem_wide(dst, src),\n-             OpcSE(imm), reg_mem(dst, src), Con8or32(imm));\n+  ins_encode %{\n+    __ imulq($dst$$Register, $src$$Address, $imm$$constant);\n+  %}\n@@ -8517,2 +8530,3 @@\n-  opcode(0xF7, 0x5); \/* Opcode F7 \/5 *\/\n-  ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));\n+  ins_encode %{\n+    __ imulq($src$$Register);\n+  %}\n@@ -8537,2 +8551,1 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));\n+  ins_encode(cdql_enc(div));\n@@ -8558,2 +8571,1 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));\n+  ins_encode(cdqq_enc(div));\n@@ -8579,2 +8591,1 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));\n+  ins_encode(cdql_enc(div));\n@@ -8601,2 +8612,1 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));\n+  ins_encode(cdqq_enc(div));\n@@ -8624,2 +8634,3 @@\n-  opcode(0xF7, 0x5); \/* Opcode F7 \/5 *\/\n-  ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));\n+  ins_encode %{\n+    __ imulq($src$$Register);\n+  %}\n@@ -8634,2 +8645,3 @@\n-  opcode(0xC1, 0x7); \/* C1 \/7 ib *\/\n-  ins_encode(reg_opc_imm_wide(dst, 0x3F));\n+  ins_encode %{\n+    __ sarq($dst$$Register, 63);\n+  %}\n@@ -8644,2 +8656,3 @@\n-  opcode(0xC1, 0x7); \/* C1 \/7 ib *\/\n-  ins_encode(reg_opc_imm_wide(dst, 0x2));\n+  ins_encode %{\n+    __ sarq($dst$$Register, 2);\n+  %}\n@@ -8682,2 +8695,1 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));\n+  ins_encode(cdql_enc(div));\n@@ -8703,2 +8715,1 @@\n-  opcode(0xF7, 0x7);  \/* Opcode F7 \/7 *\/\n-  ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));\n+  ins_encode(cdqq_enc(div));\n@@ -8716,2 +8727,3 @@\n-  opcode(0xD1, 0x4); \/* D1 \/4 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ sall($dst$$Register, $shift$$constant);\n+  %}\n@@ -8728,2 +8740,3 @@\n-  opcode(0xD1, 0x4); \/* D1 \/4 *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ sall($dst$$Address, $shift$$constant);\n+  %}\n@@ -8740,2 +8753,3 @@\n-  opcode(0xC1, 0x4); \/* C1 \/4 ib *\/\n-  ins_encode(reg_opc_imm(dst, shift));\n+  ins_encode %{\n+    __ sall($dst$$Register, $shift$$constant);\n+  %}\n@@ -8752,2 +8766,3 @@\n-  opcode(0xC1, 0x4); \/* C1 \/4 ib *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));\n+  ins_encode %{\n+    __ sall($dst$$Address, $shift$$constant);\n+  %}\n@@ -8764,2 +8779,3 @@\n-  opcode(0xD3, 0x4); \/* D3 \/4 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ sall($dst$$Register);\n+  %}\n@@ -8776,2 +8792,3 @@\n-  opcode(0xD3, 0x4); \/* D3 \/4 *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ sall($dst$$Address);\n+  %}\n@@ -8788,2 +8805,3 @@\n-  opcode(0xD1, 0x7); \/* D1 \/7 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ sarl($dst$$Register, $shift$$constant);\n+  %}\n@@ -8800,2 +8818,3 @@\n-  opcode(0xD1, 0x7); \/* D1 \/7 *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ sarl($dst$$Address, $shift$$constant);\n+  %}\n@@ -8812,2 +8831,3 @@\n-  opcode(0xC1, 0x7); \/* C1 \/7 ib *\/\n-  ins_encode(reg_opc_imm(dst, shift));\n+  ins_encode %{\n+    __ sarl($dst$$Register, $shift$$constant);\n+  %}\n@@ -8824,2 +8844,3 @@\n-  opcode(0xC1, 0x7); \/* C1 \/7 ib *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));\n+  ins_encode %{\n+    __ sarl($dst$$Address, $shift$$constant);\n+  %}\n@@ -8834,3 +8855,3 @@\n-\n-  opcode(0xD3, 0x7); \/* D3 \/7 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ sarl($dst$$Register);\n+  %}\n@@ -8848,2 +8869,3 @@\n-  opcode(0xD3, 0x7); \/* D3 \/7 *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ sarl($dst$$Address);\n+  %}\n@@ -8860,2 +8882,3 @@\n-  opcode(0xD1, 0x5); \/* D1 \/5 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ shrl($dst$$Register, $shift$$constant);\n+  %}\n@@ -8872,2 +8895,3 @@\n-  opcode(0xD1, 0x5); \/* D1 \/5 *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ shrl($dst$$Address, $shift$$constant);\n+  %}\n@@ -8884,2 +8908,3 @@\n-  opcode(0xC1, 0x5); \/* C1 \/5 ib *\/\n-  ins_encode(reg_opc_imm(dst, shift));\n+  ins_encode %{\n+    __ shrl($dst$$Register, $shift$$constant);\n+  %}\n@@ -8896,2 +8921,3 @@\n-  opcode(0xC1, 0x5); \/* C1 \/5 ib *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));\n+  ins_encode %{\n+    __ shrl($dst$$Address, $shift$$constant);\n+  %}\n@@ -8908,2 +8934,3 @@\n-  opcode(0xD3, 0x5); \/* D3 \/5 *\/\n-  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ shrl($dst$$Register);\n+  %}\n@@ -8920,2 +8947,3 @@\n-  opcode(0xD3, 0x5); \/* D3 \/5 *\/\n-  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ shrl($dst$$Address);\n+  %}\n@@ -8933,2 +8961,3 @@\n-  opcode(0xD1, 0x4); \/* D1 \/4 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ salq($dst$$Register, $shift$$constant);\n+  %}\n@@ -8945,2 +8974,3 @@\n-  opcode(0xD1, 0x4); \/* D1 \/4 *\/\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ salq($dst$$Address, $shift$$constant);\n+  %}\n@@ -8957,2 +8987,3 @@\n-  opcode(0xC1, 0x4); \/* C1 \/4 ib *\/\n-  ins_encode(reg_opc_imm_wide(dst, shift));\n+  ins_encode %{\n+    __ salq($dst$$Register, $shift$$constant);\n+  %}\n@@ -8969,3 +9000,3 @@\n-  opcode(0xC1, 0x4); \/* C1 \/4 ib *\/\n-  ins_encode(REX_mem_wide(dst), OpcP,\n-             RM_opc_mem(secondary, dst), Con8or32(shift));\n+  ins_encode %{\n+    __ salq($dst$$Address, $shift$$constant);\n+  %}\n@@ -8982,2 +9013,3 @@\n-  opcode(0xD3, 0x4); \/* D3 \/4 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ salq($dst$$Register);\n+  %}\n@@ -8994,2 +9026,3 @@\n-  opcode(0xD3, 0x4); \/* D3 \/4 *\/\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ salq($dst$$Address);\n+  %}\n@@ -9006,2 +9039,3 @@\n-  opcode(0xD1, 0x7); \/* D1 \/7 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ sarq($dst$$Register, $shift$$constant);\n+  %}\n@@ -9018,2 +9052,3 @@\n-  opcode(0xD1, 0x7); \/* D1 \/7 *\/\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ sarq($dst$$Address, $shift$$constant);\n+  %}\n@@ -9030,2 +9065,3 @@\n-  opcode(0xC1, 0x7); \/* C1 \/7 ib *\/\n-  ins_encode(reg_opc_imm_wide(dst, shift));\n+  ins_encode %{\n+    __ sarq($dst$$Register, (unsigned char)($shift$$constant & 0x3F));\n+  %}\n@@ -9042,3 +9078,3 @@\n-  opcode(0xC1, 0x7); \/* C1 \/7 ib *\/\n-  ins_encode(REX_mem_wide(dst), OpcP,\n-             RM_opc_mem(secondary, dst), Con8or32(shift));\n+  ins_encode %{\n+    __ sarq($dst$$Address, (unsigned char)($shift$$constant & 0x3F));\n+  %}\n@@ -9055,2 +9091,3 @@\n-  opcode(0xD3, 0x7); \/* D3 \/7 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ sarq($dst$$Register);\n+  %}\n@@ -9067,2 +9104,3 @@\n-  opcode(0xD3, 0x7); \/* D3 \/7 *\/\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ sarq($dst$$Address);\n+  %}\n@@ -9079,2 +9117,3 @@\n-  opcode(0xD1, 0x5); \/* D1 \/5 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));\n+  ins_encode %{\n+    __ shrq($dst$$Register, $shift$$constant);\n+  %}\n@@ -9091,2 +9130,3 @@\n-  opcode(0xD1, 0x5); \/* D1 \/5 *\/\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ shrq($dst$$Address, $shift$$constant);\n+  %}\n@@ -9103,2 +9143,3 @@\n-  opcode(0xC1, 0x5); \/* C1 \/5 ib *\/\n-  ins_encode(reg_opc_imm_wide(dst, shift));\n+  ins_encode %{\n+    __ shrq($dst$$Register, $shift$$constant);\n+  %}\n@@ -9108,1 +9149,0 @@\n-\n@@ -9116,3 +9156,3 @@\n-  opcode(0xC1, 0x5); \/* C1 \/5 ib *\/\n-  ins_encode(REX_mem_wide(dst), OpcP,\n-             RM_opc_mem(secondary, dst), Con8or32(shift));\n+  ins_encode %{\n+    __ shrq($dst$$Address, $shift$$constant);\n+  %}\n@@ -9129,2 +9169,3 @@\n-  opcode(0xD3, 0x5); \/* D3 \/5 *\/\n-  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));\n+  ins_encode %{\n+    __ shrq($dst$$Register);\n+  %}\n@@ -9141,2 +9182,3 @@\n-  opcode(0xD3, 0x5); \/* D3 \/5 *\/\n-  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));\n+  ins_encode %{\n+    __ shrq($dst$$Address);\n+  %}\n@@ -9153,2 +9195,3 @@\n-  opcode(0x0F, 0xBE);\n-  ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));\n+  ins_encode %{\n+    __ movsbl($dst$$Register, $src$$Register);\n+  %}\n@@ -9165,2 +9208,3 @@\n-  opcode(0x0F, 0xBF);\n-  ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));\n+  ins_encode %{\n+    __ movswl($dst$$Register, $src$$Register);\n+  %}\n@@ -9316,2 +9360,3 @@\n-  opcode(0x23);\n-  ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ andl($dst$$Register, $src$$Register);\n+  %}\n@@ -9327,2 +9372,3 @@\n-  opcode(0x0F, 0xB6);\n-  ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));\n+  ins_encode %{\n+    __ movzbl($dst$$Register, $dst$$Register);\n+  %}\n@@ -9338,2 +9384,3 @@\n-  opcode(0x0F, 0xB6);\n-  ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));\n+  ins_encode %{\n+    __ movzbl($dst$$Register, $src$$Register);\n+  %}\n@@ -9349,2 +9396,3 @@\n-  opcode(0x0F, 0xB7);\n-  ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));\n+  ins_encode %{\n+    __ movzwl($dst$$Register, $dst$$Register);\n+  %}\n@@ -9360,2 +9408,3 @@\n-  opcode(0x0F, 0xB7);\n-  ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));\n+  ins_encode %{\n+    __ movzwl($dst$$Register, $src$$Register);\n+  %}\n@@ -9387,2 +9436,3 @@\n-  opcode(0x81, 0x04); \/* Opcode 81 \/4 *\/\n-  ins_encode(OpcSErm(dst, src), Con8or32(src));\n+  ins_encode %{\n+    __ andl($dst$$Register, $src$$constant);\n+  %}\n@@ -9400,2 +9450,3 @@\n-  opcode(0x23);\n-  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ andl($dst$$Register, $src$$Address);\n+  %}\n@@ -9413,2 +9464,3 @@\n-  opcode(0x20);\n-  ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ andb($dst$$Address, $src$$Register);\n+  %}\n@@ -9425,2 +9477,3 @@\n-  opcode(0x21); \/* Opcode 21 \/r *\/\n-  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ andl($dst$$Address, $src$$Register);\n+  %}\n@@ -9438,3 +9491,3 @@\n-  opcode(0x81, 0x4); \/* Opcode 81 \/4 id *\/\n-  ins_encode(REX_mem(dst), OpcSE(src),\n-             RM_opc_mem(secondary, dst), Con8or32(src));\n+  ins_encode %{\n+    __ andl($dst$$Address, $src$$constant);\n+  %}\n@@ -9568,2 +9621,3 @@\n-  opcode(0x0B);\n-  ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ orl($dst$$Register, $src$$Register);\n+  %}\n@@ -9580,2 +9634,3 @@\n-  opcode(0x81, 0x01); \/* Opcode 81 \/1 id *\/\n-  ins_encode(OpcSErm(dst, src), Con8or32(src));\n+  ins_encode %{\n+    __ orl($dst$$Register, $src$$constant);\n+  %}\n@@ -9593,2 +9648,3 @@\n-  opcode(0x0B);\n-  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ orl($dst$$Register, $src$$Address);\n+  %}\n@@ -9606,2 +9662,3 @@\n-  opcode(0x08);\n-  ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ orb($dst$$Address, $src$$Register);\n+  %}\n@@ -9618,2 +9675,3 @@\n-  opcode(0x09); \/* Opcode 09 \/r *\/\n-  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ orl($dst$$Address, $src$$Register);\n+  %}\n@@ -9631,3 +9689,3 @@\n-  opcode(0x81, 0x1); \/* Opcode 81 \/1 id *\/\n-  ins_encode(REX_mem(dst), OpcSE(src),\n-             RM_opc_mem(secondary, dst), Con8or32(src));\n+  ins_encode %{\n+    __ orl($dst$$Address, $src$$constant);\n+  %}\n@@ -9645,2 +9703,3 @@\n-  opcode(0x33);\n-  ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ xorl($dst$$Register, $src$$Register);\n+  %}\n@@ -9668,2 +9727,3 @@\n-  opcode(0x81, 0x06); \/* Opcode 81 \/6 id *\/\n-  ins_encode(OpcSErm(dst, src), Con8or32(src));\n+  ins_encode %{\n+    __ xorl($dst$$Register, $src$$constant);\n+  %}\n@@ -9681,2 +9741,3 @@\n-  opcode(0x33);\n-  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ xorl($dst$$Register, $src$$Address);\n+  %}\n@@ -9694,2 +9755,3 @@\n-  opcode(0x30);\n-  ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ xorb($dst$$Address, $src$$Register);\n+  %}\n@@ -9706,2 +9768,3 @@\n-  opcode(0x31); \/* Opcode 31 \/r *\/\n-  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ xorl($dst$$Address, $src$$Register);\n+  %}\n@@ -9719,3 +9782,3 @@\n-  opcode(0x81, 0x6); \/* Opcode 81 \/6 id *\/\n-  ins_encode(REX_mem(dst), OpcSE(src),\n-             RM_opc_mem(secondary, dst), Con8or32(src));\n+  ins_encode %{\n+    __ xorl($dst$$Address, $src$$constant);\n+  %}\n@@ -9736,2 +9799,3 @@\n-  opcode(0x23);\n-  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ andq($dst$$Register, $src$$Register);\n+  %}\n@@ -9747,2 +9811,3 @@\n-  opcode(0x0F, 0xB6);\n-  ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));\n+  ins_encode %{\n+    __ movzbq($dst$$Register, $dst$$Register);\n+  %}\n@@ -9758,2 +9823,3 @@\n-  opcode(0x0F, 0xB7);\n-  ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));\n+  ins_encode %{\n+    __ movzwq($dst$$Register, $dst$$Register);\n+  %}\n@@ -9770,2 +9836,3 @@\n-  opcode(0x81, 0x04); \/* Opcode 81 \/4 *\/\n-  ins_encode(OpcSErm_wide(dst, src), Con8or32(src));\n+  ins_encode %{\n+    __ andq($dst$$Register, $src$$constant);\n+  %}\n@@ -9783,2 +9850,3 @@\n-  opcode(0x23);\n-  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ andq($dst$$Register, $src$$Address);\n+  %}\n@@ -9796,2 +9864,3 @@\n-  opcode(0x21); \/* Opcode 21 \/r *\/\n-  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ andq($dst$$Address, $src$$Register);\n+  %}\n@@ -9809,3 +9878,3 @@\n-  opcode(0x81, 0x4); \/* Opcode 81 \/4 id *\/\n-  ins_encode(REX_mem_wide(dst), OpcSE(src),\n-             RM_opc_mem(secondary, dst), Con8or32(src));\n+  ins_encode %{\n+    __ andq($dst$$Address, $src$$constant);\n+  %}\n@@ -9956,2 +10025,3 @@\n-  opcode(0x0B);\n-  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ orq($dst$$Register, $src$$Register);\n+  %}\n@@ -9967,2 +10037,3 @@\n-  opcode(0x0B);\n-  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ orq($dst$$Register, $src$$Register);\n+  %}\n@@ -9980,2 +10051,3 @@\n-  opcode(0x81, 0x01); \/* Opcode 81 \/1 id *\/\n-  ins_encode(OpcSErm_wide(dst, src), Con8or32(src));\n+  ins_encode %{\n+    __ orq($dst$$Register, $src$$constant);\n+  %}\n@@ -9993,2 +10065,3 @@\n-  opcode(0x0B);\n-  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ orq($dst$$Register, $src$$Address);\n+  %}\n@@ -10006,2 +10079,3 @@\n-  opcode(0x09); \/* Opcode 09 \/r *\/\n-  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ orq($dst$$Address, $src$$Register);\n+  %}\n@@ -10019,3 +10093,3 @@\n-  opcode(0x81, 0x1); \/* Opcode 81 \/1 id *\/\n-  ins_encode(REX_mem_wide(dst), OpcSE(src),\n-             RM_opc_mem(secondary, dst), Con8or32(src));\n+  ins_encode %{\n+    __ orq($dst$$Address, $src$$constant);\n+  %}\n@@ -10050,2 +10124,3 @@\n-  opcode(0x33);\n-  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));\n+  ins_encode %{\n+    __ xorq($dst$$Register, $src$$Register);\n+  %}\n@@ -10073,2 +10148,3 @@\n-  opcode(0x81, 0x06); \/* Opcode 81 \/6 id *\/\n-  ins_encode(OpcSErm_wide(dst, src), Con8or32(src));\n+  ins_encode %{\n+    __ xorq($dst$$Register, $src$$constant);\n+  %}\n@@ -10086,2 +10162,3 @@\n-  opcode(0x33);\n-  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));\n+  ins_encode %{\n+    __ xorq($dst$$Register, $src$$Address);\n+  %}\n@@ -10099,2 +10176,3 @@\n-  opcode(0x31); \/* Opcode 31 \/r *\/\n-  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));\n+  ins_encode %{\n+    __ xorq($dst$$Address, $src$$Register);\n+  %}\n@@ -10112,3 +10190,3 @@\n-  opcode(0x81, 0x6); \/* Opcode 81 \/6 id *\/\n-  ins_encode(REX_mem_wide(dst), OpcSE(src),\n-             RM_opc_mem(secondary, dst), Con8or32(src));\n+  ins_encode %{\n+    __ xorq($dst$$Address, $src$$constant);\n+  %}\n@@ -10127,4 +10205,5 @@\n-  ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), \/\/ testl\n-             setNZ_reg(dst),\n-             REX_reg_breg(dst, dst), \/\/ movzbl\n-             Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));\n+  ins_encode %{\n+    __ testl($src$$Register, $src$$Register);\n+    __ set_byte_if_not_zero($dst$$Register);\n+    __ movzbl($dst$$Register, $dst$$Register);\n+  %}\n@@ -10143,4 +10222,5 @@\n-  ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), \/\/ testq\n-             setNZ_reg(dst),\n-             REX_reg_breg(dst, dst), \/\/ movzbl\n-             Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));\n+  ins_encode %{\n+    __ testq($src$$Register, $src$$Register);\n+    __ set_byte_if_not_zero($dst$$Register);\n+    __ movzbl($dst$$Register, $dst$$Register);\n+  %}\n@@ -10160,5 +10240,6 @@\n-  ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), \/\/ cmpl\n-             setLT_reg(dst),\n-             REX_reg_breg(dst, dst), \/\/ movzbl\n-             Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),\n-             neg_reg(dst));\n+  ins_encode %{\n+    __ cmpl($p$$Register, $q$$Register);\n+    __ setl($dst$$Register);\n+    __ movzbl($dst$$Register, $dst$$Register);\n+    __ negl($dst$$Register);\n+  %}\n@@ -10176,1 +10257,1 @@\n-  __ sarl($dst$$Register, 31);\n+    __ sarl($dst$$Register, 31);\n@@ -12106,2 +12187,3 @@\n-  opcode(0x3B);  \/* Opcode 3B \/r *\/\n-  ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$Register);\n+  %}\n@@ -12116,2 +12198,3 @@\n-  opcode(0x81, 0x07); \/* Opcode 81 \/7 *\/\n-  ins_encode(OpcSErm(op1, op2), Con8or32(op2));\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$constant);\n+  %}\n@@ -12127,2 +12210,3 @@\n-  opcode(0x3B); \/* Opcode 3B \/r *\/\n-  ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$Address);\n+  %}\n@@ -12137,2 +12221,3 @@\n-  opcode(0x85);\n-  ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));\n+  ins_encode %{\n+    __ testl($src$$Register, $src$$Register);\n+  %}\n@@ -12147,2 +12232,3 @@\n-  opcode(0xF7, 0x00);\n-  ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));\n+  ins_encode %{\n+    __ testl($src$$Register, $con$$constant);\n+  %}\n@@ -12157,2 +12243,3 @@\n-  opcode(0x85);\n-  ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));\n+  ins_encode %{\n+    __ testl($src$$Register, $mem$$Address);\n+  %}\n@@ -12169,2 +12256,3 @@\n-  opcode(0x3B); \/* Opcode 3B \/r *\/\n-  ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$Register);\n+  %}\n@@ -12179,2 +12267,3 @@\n-  opcode(0x81,0x07); \/* Opcode 81 \/7 *\/\n-  ins_encode(OpcSErm(op1, op2), Con8or32(op2));\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$constant);\n+  %}\n@@ -12190,2 +12279,3 @@\n-  opcode(0x3B); \/* Opcode 3B \/r *\/\n-  ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));\n+  ins_encode %{\n+    __ cmpl($op1$$Register, $op2$$Address);\n+  %}\n@@ -12211,2 +12301,3 @@\n-  opcode(0x85);\n-  ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));\n+  ins_encode %{\n+    __ testl($src$$Register, $src$$Register);\n+  %}\n@@ -12221,2 +12312,3 @@\n-  opcode(0x3B); \/* Opcode 3B \/r *\/\n-  ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Register);\n+  %}\n@@ -12233,2 +12325,3 @@\n-  opcode(0x3B); \/* Opcode 3B \/r *\/\n-  ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Address);\n+  %}\n@@ -12260,2 +12353,3 @@\n-  opcode(0x3B); \/* Opcode 3B \/r *\/\n-  ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Address);\n+  %}\n@@ -12272,2 +12366,3 @@\n-  opcode(0x85);\n-  ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));\n+  ins_encode %{\n+    __ testq($src$$Register, $src$$Register);\n+  %}\n@@ -12287,3 +12382,3 @@\n-  opcode(0xF7); \/* Opcode F7 \/0 *\/\n-  ins_encode(REX_mem_wide(op),\n-             OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));\n+  ins_encode %{\n+    __ testq($op$$Address, 0xFFFFFFFF);\n+  %}\n@@ -12409,2 +12504,3 @@\n-  opcode(0x3B);  \/* Opcode 3B \/r *\/\n-  ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Register);\n+  %}\n@@ -12419,2 +12515,3 @@\n-  opcode(0x81, 0x07); \/* Opcode 81 \/7 *\/\n-  ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$constant);\n+  %}\n@@ -12429,2 +12526,3 @@\n-  opcode(0x3B); \/* Opcode 3B \/r *\/\n-  ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Address);\n+  %}\n@@ -12439,2 +12537,3 @@\n-  opcode(0x85);\n-  ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));\n+  ins_encode %{\n+    __ testq($src$$Register, $src$$Register);\n+  %}\n@@ -12449,2 +12548,3 @@\n-  opcode(0xF7, 0x00);\n-  ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));\n+  ins_encode %{\n+    __ testq($src$$Register, $con$$constant);\n+  %}\n@@ -12459,2 +12559,3 @@\n-  opcode(0x85);\n-  ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));\n+  ins_encode %{\n+    __ testq($src$$Register, $mem$$Address);\n+  %}\n@@ -12469,2 +12570,3 @@\n-  opcode(0x85);\n-  ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));\n+  ins_encode %{\n+    __ testq($src$$Register, $mem$$Address);\n+  %}\n@@ -12488,1 +12590,9 @@\n-  ins_encode(cmpl3_flag(src1, src2, dst));\n+  ins_encode %{\n+    Label done;\n+    __ cmpq($src1$$Register, $src2$$Register);\n+    __ movl($dst$$Register, -1);\n+    __ jccb(Assembler::less, done);\n+    __ setne($dst$$Register);\n+    __ movzbl($dst$$Register, $dst$$Register);\n+    __ bind(done);\n+  %}\n@@ -12499,2 +12609,3 @@\n-  opcode(0x3B);  \/* Opcode 3B \/r *\/\n-  ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Register);\n+  %}\n@@ -12509,2 +12620,3 @@\n-  opcode(0x81, 0x07); \/* Opcode 81 \/7 *\/\n-  ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$constant);\n+  %}\n@@ -12519,2 +12631,3 @@\n-  opcode(0x3B); \/* Opcode 3B \/r *\/\n-  ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));\n+  ins_encode %{\n+    __ cmpq($op1$$Register, $op2$$Address);\n+  %}\n@@ -12529,2 +12642,3 @@\n-  opcode(0x85);\n-  ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));\n+  ins_encode %{\n+    __ testq($src$$Register, $src$$Register);\n+  %}\n@@ -12572,2 +12686,3 @@\n-  opcode(0x0F, 0x4F);\n-  ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));\n+  ins_encode %{\n+    __ cmovl(Assembler::greater, $dst$$Register, $src$$Register);\n+  %}\n@@ -12595,2 +12710,3 @@\n-  opcode(0x0F, 0x4C);\n-  ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));\n+  ins_encode %{\n+    __ cmovl(Assembler::less, $dst$$Register, $src$$Register);\n+  %}\n@@ -13146,0 +13262,12 @@\n+\/\/ Call runtime without safepoint and with vector arguments\n+instruct CallLeafDirectVector(method meth)\n+%{\n+  match(CallLeafVector);\n+  effect(USE meth);\n+\n+  ins_cost(300);\n+  format %{ \"call_leaf,vector \" %}\n+  ins_encode(Java_To_Runtime(meth));\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -13195,2 +13323,3 @@\n-  opcode(0xC3);\n-  ins_encode(OpcP);\n+  ins_encode %{\n+    __ ret(0);\n+  %}\n@@ -13210,2 +13339,3 @@\n-  opcode(0xFF, 0x4); \/* Opcode FF \/4 *\/\n-  ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));\n+  ins_encode %{\n+    __ jmp($jump_target$$Register);\n+  %}\n@@ -13224,3 +13354,4 @@\n-  opcode(0xFF, 0x4); \/* Opcode FF \/4 *\/\n-  ins_encode(Opcode(0x5a), \/\/ popq rdx\n-             REX_reg(jump_target), OpcP, reg_opc(jump_target));\n+  ins_encode %{\n+    __ popq(as_Register(RDX_enc));\n+    __ jmp($jump_target$$Register);\n+  %}\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":821,"deletions":690,"binary":false,"changes":1511,"status":"modified"},{"patch":"@@ -422,0 +422,2 @@\n+  if(_matrule->find_type(\"CallLeafVector\",idx))   return Form::JAVA_LEAF;\n+  idx = 0;\n@@ -767,0 +769,5 @@\n+       !strcmp(_matrule->_rChild->_opType,\"CastDD\")       ||\n+       !strcmp(_matrule->_rChild->_opType,\"CastFF\")       ||\n+       !strcmp(_matrule->_rChild->_opType,\"CastII\")       ||\n+       !strcmp(_matrule->_rChild->_opType,\"CastLL\")       ||\n+       !strcmp(_matrule->_rChild->_opType,\"CastVV\")       ||\n@@ -785,0 +792,1 @@\n+       !strcmp(_matrule->_rChild->_opType,\"VectorCmpMasked\")||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-  AD.generate_needs_clone_jvms(AD._CPP_file._fp);\n+  AD.generate_needs_deep_clone_jvms(AD._CPP_file._fp);\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -471,2 +471,0 @@\n-void Canonicalizer::do_IfInstanceOf(IfInstanceOf*    x) {}\n-\n@@ -551,0 +549,16 @@\n+  case vmIntrinsics::_getModifiers: {\n+    assert(x->number_of_arguments() == 1, \"wrong type\");\n+\n+    \/\/ Optimize for Foo.class.getModifier()\n+    InstanceConstant* c = x->argument_at(0)->type()->as_InstanceConstant();\n+    if (c != NULL && !c->value()->is_null_object()) {\n+      ciType* t = c->value()->java_mirror_type();\n+      if (t->is_klass()) {\n+        set_constant(t->as_klass()->modifier_flags());\n+      } else {\n+        assert(t->is_primitive_type(), \"should be a primitive type\");\n+        set_constant(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n+      }\n+    }\n+    break;\n+  }\n@@ -802,17 +816,0 @@\n-    } else if (l->as_InstanceOf() != NULL) {\n-      \/\/ NOTE: Code permanently disabled for now since it leaves the old InstanceOf\n-      \/\/       instruction in the graph (it is pinned). Need to fix this at some point.\n-      \/\/       It should also be left in the graph when generating a profiled method version or Goto\n-      \/\/       has to know that it was an InstanceOf.\n-      return;\n-      \/\/ pattern: If ((obj instanceof klass) cond rc) => simplify to: IfInstanceOf or: Goto\n-      InstanceOf* inst = l->as_InstanceOf();\n-      BlockBegin* is_inst_sux = x->sux_for(is_true(1, x->cond(), rc)); \/\/ successor for instanceof == 1\n-      BlockBegin* no_inst_sux = x->sux_for(is_true(0, x->cond(), rc)); \/\/ successor for instanceof == 0\n-      if (is_inst_sux == no_inst_sux && inst->is_loaded()) {\n-        \/\/ both successors identical and klass is loaded => simplify to: Goto\n-        set_canonical(new Goto(is_inst_sux, x->state_before(), x->is_safepoint()));\n-      } else {\n-        \/\/ successors differ => simplify to: IfInstanceOf\n-        set_canonical(new IfInstanceOf(inst->klass(), inst->obj(), true, inst->state_before()->bci(), is_inst_sux, no_inst_sux));\n-      }\n@@ -843,17 +840,0 @@\n-  } else if (x->number_of_sux() == 1) {\n-    \/\/ NOTE: Code permanently disabled for now since the switch statement's\n-    \/\/       tag expression may produce side-effects in which case it must\n-    \/\/       be executed.\n-    return;\n-    \/\/ simplify to Goto\n-    set_canonical(new Goto(x->default_sux(), x->state_before(), x->is_safepoint()));\n-  } else if (x->number_of_sux() == 2) {\n-    \/\/ NOTE: Code permanently disabled for now since it produces two new nodes\n-    \/\/       (Constant & If) and the Canonicalizer cannot return them correctly\n-    \/\/       yet. For now we copied the corresponding code directly into the\n-    \/\/       GraphBuilder (i.e., we should never reach here).\n-    return;\n-    \/\/ simplify to If\n-    assert(x->lo_key() == x->hi_key(), \"keys must be the same\");\n-    Constant* key = new Constant(new IntConstant(x->lo_key()));\n-    set_canonical(new If(x->tag(), If::eql, true, key, x->sux_at(0), x->default_sux(), x->state_before(), x->is_safepoint()));\n@@ -874,17 +854,0 @@\n-  } else if (x->number_of_sux() == 1) {\n-    \/\/ NOTE: Code permanently disabled for now since the switch statement's\n-    \/\/       tag expression may produce side-effects in which case it must\n-    \/\/       be executed.\n-    return;\n-    \/\/ simplify to Goto\n-    set_canonical(new Goto(x->default_sux(), x->state_before(), x->is_safepoint()));\n-  } else if (x->number_of_sux() == 2) {\n-    \/\/ NOTE: Code permanently disabled for now since it produces two new nodes\n-    \/\/       (Constant & If) and the Canonicalizer cannot return them correctly\n-    \/\/       yet. For now we copied the corresponding code directly into the\n-    \/\/       GraphBuilder (i.e., we should never reach here).\n-    return;\n-    \/\/ simplify to If\n-    assert(x->length() == 1, \"length must be the same\");\n-    Constant* key = new Constant(new IntConstant(x->key_at(0)));\n-    set_canonical(new If(x->tag(), If::eql, true, key, x->sux_at(0), x->default_sux(), x->state_before(), x->is_safepoint()));\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":16,"deletions":53,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-  virtual void do_IfInstanceOf   (IfInstanceOf*    x);\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1246,3 +1246,1 @@\n-  \/\/ NOTE: strictfp can be queried from current method since we don't\n-  \/\/ inline methods with differing strictfp bits\n-  Value res = new ArithmeticOp(code, x, y, method()->is_strict(), state_before);\n+  Value res = new ArithmeticOp(code, x, y, state_before);\n@@ -1251,3 +1249,1 @@\n-  if (method()->is_strict()) {\n-    res = round_fp(res);\n-  }\n+  res = round_fp(res);\n@@ -2227,3 +2223,1 @@\n-    ciInstanceKlass* sender_klass =\n-          calling_klass->is_unsafe_anonymous() ? calling_klass->unsafe_anonymous_host() :\n-                                                 calling_klass;\n+    ciInstanceKlass* sender_klass = calling_klass;\n@@ -2346,2 +2340,1 @@\n-      if (singleton != NULL &&\n-          (!target->is_default_method() || target->is_overpass()) \/* CHA doesn't support default methods yet. *\/ ) {\n+      if (singleton != NULL) {\n@@ -2382,1 +2375,1 @@\n-      dependency_recorder()->assert_unique_concrete_method(actual_recv, cha_monomorphic_target);\n+      dependency_recorder()->assert_unique_concrete_method(actual_recv, cha_monomorphic_target, callee_holder, target);\n@@ -2388,3 +2381,1 @@\n-  if (!PatchALot && Inline && target->is_loaded() &&\n-      (klass->is_initialized() || (klass->is_interface() && target->holder()->is_initialized()))\n-      && !patch_for_appendix) {\n+  if (!PatchALot && Inline && target->is_loaded() && callee_holder->is_linked() && !patch_for_appendix) {\n@@ -2392,1 +2383,1 @@\n-    if (code == Bytecodes::_invokestatic  ||\n+    if ((code == Bytecodes::_invokestatic && callee_holder->is_initialized()) || \/\/ invokestatic involves an initialization barrier on resolved klass\n@@ -2396,2 +2387,3 @@\n-      ciMethod* inline_target = (cha_monomorphic_target != NULL) ? cha_monomorphic_target : target;\n-      bool success = try_inline(inline_target, (cha_monomorphic_target != NULL) || (exact_target != NULL), false, code, better_receiver);\n+      ciMethod* inline_target = (cha_monomorphic_target != NULL) ? cha_monomorphic_target : target;\n+      bool holder_known = (cha_monomorphic_target != NULL) || (exact_target != NULL);\n+      bool success = try_inline(inline_target, holder_known, false \/* ignore_return *\/, code, better_receiver);\n@@ -2486,5 +2478,1 @@\n-    if (method()->is_strict()) {\n-      push(result_type, round_fp(result));\n-    } else {\n-      push(result_type, result);\n-    }\n+    push(result_type, round_fp(result));\n@@ -3452,1 +3440,3 @@\n-  \/\/ can increment the interpreter_invocation_count.\n+  \/\/ can increment the the counters.\n+  \/\/ In addition, with range check elimination, we may need a valid block\n+  \/\/ that dominates all the rest to insert range predicates.\n@@ -3454,1 +3444,1 @@\n-  if (std_entry->number_of_preds() > 0 || count_invocations() || count_backedges()) {\n+  if (std_entry->number_of_preds() > 0 || count_invocations() || count_backedges() || RangeCheckElimination) {\n@@ -4156,1 +4146,3 @@\n-  if (!callee->holder()->is_initialized()) INLINE_BAILOUT(\"callee's klass not initialized yet\");\n+  if (!callee->holder()->is_linked())      INLINE_BAILOUT(\"callee's klass not linked yet\");\n+  if (bc == Bytecodes::_invokestatic &&\n+      !callee->holder()->is_initialized()) INLINE_BAILOUT(\"callee's klass not initialized yet\");\n@@ -4162,13 +4154,0 @@\n-  if (strict_fp_requires_explicit_rounding &&\n-      method()->is_strict() != callee->is_strict()) {\n-#ifdef IA32\n-    \/\/ If explicit rounding is required, do not inline strict code into non-strict code (or the reverse).\n-    \/\/ When SSE2 is present, no special handling is needed.\n-    if (UseSSE < 2) {\n-      INLINE_BAILOUT(\"caller and callee have different strict fp requirements\");\n-    }\n-#else\n-    Unimplemented();\n-#endif \/\/ IA32\n-  }\n-\n@@ -4238,0 +4217,2 @@\n+  assert(bc != Bytecodes::_invokestatic || callee->holder()->is_initialized(), \"required\");\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":20,"deletions":39,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -463,1 +463,0 @@\n-  set_flag(TargetIsStrictfpFlag, target_is_loaded() && target->is_strict());\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-class       IfInstanceOf;\n@@ -196,1 +195,0 @@\n-  virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;\n@@ -387,1 +385,0 @@\n-    IsStrictfpFlag,\n@@ -393,1 +390,0 @@\n-    TargetIsStrictfpFlag,\n@@ -602,1 +598,0 @@\n-  virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }\n@@ -1128,1 +1123,1 @@\n-  ArithmeticOp(Bytecodes::Code op, Value x, Value y, bool is_strictfp, ValueStack* state_before)\n+  ArithmeticOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)\n@@ -1131,1 +1126,0 @@\n-    set_flag(IsStrictfpFlag, is_strictfp);\n@@ -1135,3 +1129,0 @@\n-  \/\/ accessors\n-  bool        is_strictfp() const                { return check_flag(IsStrictfpFlag); }\n-\n@@ -1338,2 +1329,0 @@\n-  \/\/ Returns false if target is not loaded\n-  bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }\n@@ -2181,54 +2170,0 @@\n-LEAF(IfInstanceOf, BlockEnd)\n- private:\n-  ciKlass* _klass;\n-  Value    _obj;\n-  bool     _test_is_instance;                    \/\/ jump if instance\n-  int      _instanceof_bci;\n-\n- public:\n-  IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)\n-  : BlockEnd(illegalType, NULL, false) \/\/ temporary set to false\n-  , _klass(klass)\n-  , _obj(obj)\n-  , _test_is_instance(test_is_instance)\n-  , _instanceof_bci(instanceof_bci)\n-  {\n-    ASSERT_VALUES\n-    assert(instanceof_bci >= 0, \"illegal bci\");\n-    BlockList* s = new BlockList(2);\n-    s->append(tsux);\n-    s->append(fsux);\n-    set_sux(s);\n-  }\n-\n-  \/\/ accessors\n-  \/\/\n-  \/\/ Note 1: If test_is_instance() is true, IfInstanceOf tests if obj *is* an\n-  \/\/         instance of klass; otherwise it tests if it is *not* and instance\n-  \/\/         of klass.\n-  \/\/\n-  \/\/ Note 2: IfInstanceOf instructions are created by combining an InstanceOf\n-  \/\/         and an If instruction. The IfInstanceOf bci() corresponds to the\n-  \/\/         bci that the If would have had; the (this->) instanceof_bci() is\n-  \/\/         the bci of the original InstanceOf instruction.\n-  ciKlass* klass() const                         { return _klass; }\n-  Value obj() const                              { return _obj; }\n-  int instanceof_bci() const                     { return _instanceof_bci; }\n-  bool test_is_instance() const                  { return _test_is_instance; }\n-  BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }\n-  BlockBegin* tsux() const                       { return sux_for(true); }\n-  BlockBegin* fsux() const                       { return sux_for(false); }\n-\n-  \/\/ manipulation\n-  void swap_sux() {\n-    assert(number_of_sux() == 2, \"wrong number of successors\");\n-    BlockList* s = sux();\n-    BlockBegin* t = s->at(0); s->at_put(0, s->at(1)); s->at_put(1, t);\n-    _test_is_instance = !_test_is_instance;\n-  }\n-\n-  \/\/ generic\n-  virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f->visit(&_obj); }\n-};\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":1,"deletions":66,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -758,5 +758,0 @@\n-void InstructionPrinter::do_IfInstanceOf(IfInstanceOf* x) {\n-  output()->print(\"<IfInstanceOf>\");\n-}\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-  virtual void do_IfInstanceOf   (IfInstanceOf*    x);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -218,2 +218,0 @@\n-    case lir_mul_strictfp:\n-    case lir_div_strictfp:\n@@ -604,2 +602,0 @@\n-    case lir_mul:\n-    case lir_div:\n@@ -663,2 +659,2 @@\n-    case lir_mul_strictfp:\n-    case lir_div_strictfp:\n+    case lir_mul:\n+    case lir_div:\n@@ -1853,2 +1849,0 @@\n-     case lir_mul_strictfp:          s = \"mul_strictfp\";  break;\n-     case lir_div_strictfp:          s = \"div_strictfp\";  break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -943,2 +943,0 @@\n-      , lir_mul_strictfp\n-      , lir_div_strictfp\n@@ -2299,1 +2297,1 @@\n-  void mul_strictfp (LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_mul_strictfp, left, right, res, tmp)); }\n+  void mul (LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_mul, left, right, res, tmp)); }\n@@ -2301,1 +2299,1 @@\n-  void div_strictfp (LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_div_strictfp, left, right, res, tmp)); }\n+  void div (LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp) { append(new LIR_Op2(lir_div, left, right, res, tmp)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -846,2 +846,0 @@\n-    case lir_mul_strictfp:\n-    case lir_div_strictfp:\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -508,1 +508,1 @@\n-void LIRGenerator::arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp_op, CodeEmitInfo* info) {\n+void LIRGenerator::arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp_op, CodeEmitInfo* info) {\n@@ -527,9 +527,1 @@\n-    case Bytecodes::_dmul:\n-      {\n-        if (is_strictfp) {\n-          __ mul_strictfp(left_op, right_op, result_op, tmp_op); break;\n-        } else {\n-          __ mul(left_op, right_op, result_op); break;\n-        }\n-      }\n-      break;\n+    case Bytecodes::_dmul:  __ mul(left_op, right_op, result_op, tmp_op); break;\n@@ -566,9 +558,1 @@\n-    case Bytecodes::_ddiv:\n-      {\n-        if (is_strictfp) {\n-          __ div_strictfp (left_op, right_op, result_op, tmp_op); break;\n-        } else {\n-          __ div (left_op, right_op, result_op); break;\n-        }\n-      }\n-      break;\n+    case Bytecodes::_ddiv: __ div(left_op, right_op, result_op, tmp_op); break;\n@@ -585,1 +569,1 @@\n-  arithmetic_op(code, result, left, right, false, tmp);\n+  arithmetic_op(code, result, left, right, tmp);\n@@ -590,1 +574,1 @@\n-  arithmetic_op(code, result, left, right, false, LIR_OprFact::illegalOpr, info);\n+  arithmetic_op(code, result, left, right, LIR_OprFact::illegalOpr, info);\n@@ -594,2 +578,2 @@\n-void LIRGenerator::arithmetic_op_fpu(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp) {\n-  arithmetic_op(code, result, left, right, is_strictfp, tmp);\n+void LIRGenerator::arithmetic_op_fpu(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp) {\n+  arithmetic_op(code, result, left, right, tmp);\n@@ -1209,5 +1193,0 @@\n-void LIRGenerator::do_IfInstanceOf(IfInstanceOf* x) {\n-  Unimplemented();\n-}\n-\n-\n@@ -1334,0 +1313,28 @@\n+\/\/ Example: Foo.class.getModifiers()\n+void LIRGenerator::do_getModifiers(Intrinsic* x) {\n+  assert(x->number_of_arguments() == 1, \"wrong type\");\n+\n+  LIRItem receiver(x->argument_at(0), this);\n+  receiver.load_item();\n+  LIR_Opr result = rlock_result(x);\n+\n+  CodeEmitInfo* info = NULL;\n+  if (x->needs_null_check()) {\n+    info = state_for(x);\n+  }\n+\n+  LabelObj* L_not_prim = new LabelObj();\n+  LabelObj* L_done = new LabelObj();\n+\n+  LIR_Opr klass = new_register(T_METADATA);\n+  \/\/ Checking if it's a java mirror of primitive type\n+  __ move(new LIR_Address(receiver.result(), java_lang_Class::klass_offset(), T_ADDRESS), klass, info);\n+  __ cmp(lir_cond_notEqual, klass, LIR_OprFact::metadataConst(0));\n+  __ branch(lir_cond_notEqual, L_not_prim->label());\n+  __ move(LIR_OprFact::intConst(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC), result);\n+  __ branch(lir_cond_always, L_done->label());\n+\n+  __ branch_destination(L_not_prim->label());\n+  __ move(new LIR_Address(klass, in_bytes(Klass::modifier_flags_offset()), T_INT), result);\n+  __ branch_destination(L_done->label());\n+}\n@@ -3425,11 +3432,0 @@\n-  if (x->type()->is_float() || x->type()->is_double()) {\n-    \/\/ Force rounding of results from non-strictfp when in strictfp\n-    \/\/ scope (or when we don't know the strictness of the callee, to\n-    \/\/ be safe.)\n-    if (method()->is_strict()) {\n-      if (!x->target_is_loaded() || !x->target_is_strictfp()) {\n-        result_register = round_item(result_register);\n-      }\n-    }\n-  }\n-\n@@ -3544,27 +3540,0 @@\n-void LIRGenerator::do_ClassIDIntrinsic(Intrinsic* x) {\n-  CodeEmitInfo* info = state_for(x);\n-  CodeEmitInfo* info2 = new CodeEmitInfo(info); \/\/ Clone for the second null check\n-\n-  assert(info != NULL, \"must have info\");\n-  LIRItem arg(x->argument_at(0), this);\n-\n-  arg.load_item();\n-  LIR_Opr klass = new_register(T_METADATA);\n-  __ move(new LIR_Address(arg.result(), java_lang_Class::klass_offset(), T_ADDRESS), klass, info);\n-  LIR_Opr id = new_register(T_LONG);\n-  ByteSize offset = KLASS_TRACE_ID_OFFSET;\n-  LIR_Address* trace_id_addr = new LIR_Address(klass, in_bytes(offset), T_LONG);\n-\n-  __ move(trace_id_addr, id);\n-  __ logical_or(id, LIR_OprFact::longConst(0x01l), id);\n-  __ store(id, trace_id_addr);\n-\n-#ifdef TRACE_ID_META_BITS\n-  __ logical_and(id, LIR_OprFact::longConst(~TRACE_ID_META_BITS), id);\n-#endif\n-#ifdef TRACE_ID_SHIFT\n-  __ unsigned_shift_right(id, TRACE_ID_SHIFT, id);\n-#endif\n-\n-  __ move(id, rlock_result(x));\n-}\n@@ -3620,3 +3589,0 @@\n-  case vmIntrinsics::_getClassId:\n-    do_ClassIDIntrinsic(x);\n-    break;\n@@ -3642,0 +3608,1 @@\n+  case vmIntrinsics::_getModifiers:   do_getModifiers(x);  break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":36,"deletions":69,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -257,0 +257,1 @@\n+  void do_getModifiers(Intrinsic* x);\n@@ -357,2 +358,1 @@\n-  \/\/ is_strictfp is only needed for mul and div (and only generates different code on i486)\n-  void arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp, CodeEmitInfo* info = NULL);\n+  void arithmetic_op(Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp, CodeEmitInfo* info = NULL);\n@@ -373,1 +373,1 @@\n-  void arithmetic_op_fpu  (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, bool is_strictfp, LIR_Opr tmp = LIR_OprFact::illegalOpr);\n+  void arithmetic_op_fpu  (Bytecodes::Code code, LIR_Opr result, LIR_Opr left, LIR_Opr right, LIR_Opr tmp = LIR_OprFact::illegalOpr);\n@@ -603,1 +603,0 @@\n-  virtual void do_IfInstanceOf   (IfInstanceOf*    x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6717,2 +6717,0 @@\n-        case lir_mul_strictfp:\n-        case lir_div_strictfp:\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -529,1 +529,0 @@\n-  void do_IfInstanceOf   (IfInstanceOf*    x);\n@@ -720,1 +719,0 @@\n-void NullCheckVisitor::do_IfInstanceOf   (IfInstanceOf*    x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,3 +107,0 @@\n-\n-  private:\n-    void init();\n@@ -160,1 +157,0 @@\n-    void do_IfInstanceOf   (IfInstanceOf*    x) { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -520,1 +520,1 @@\n-  Thread* THREAD = current;\n+  JavaThread* THREAD = current;\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -321,1 +321,0 @@\n-  void set_invariant(Value v) const    { _gvn->set_processed(v); }\n@@ -370,1 +369,0 @@\n-\n@@ -391,0 +389,6 @@\n+    } else if (cur->as_NegateOp() != NULL) {\n+      NegateOp* neg = (NegateOp*)cur->as_NegateOp();\n+      cur_invariant = is_invariant(neg->x());\n+    } else if (cur->as_Convert() != NULL) {\n+      Convert* cvt = (Convert*)cur->as_Convert();\n+      cur_invariant = is_invariant(cvt->value());\n@@ -415,0 +419,1 @@\n+      TRACE_VALUE_NUMBERING(cur->print_line());\n@@ -424,1 +429,0 @@\n-\n@@ -590,1 +594,1 @@\n-    TRACE_VALUE_NUMBERING(tty->print_cr(\"substitution for %d set to %d\", instr->id(), subst->id()));\n+    TRACE_VALUE_NUMBERING(tty->print_cr(\"substitution for %c%d set to %c%d\", instr->type()->tchar(), instr->id(), subst->type()->tchar(), subst->id()));\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -202,1 +202,0 @@\n-  void do_IfInstanceOf   (IfInstanceOf*    x) { \/* nothing to do *\/ }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -914,2 +914,2 @@\n-  static void write_klass(Klass* k, address runtime_dest, const char* type_name, int bytes, Thread* THREAD) {\n-    ResourceMark rm(THREAD);\n+  static void write_klass(Klass* k, address runtime_dest, const char* type_name, int bytes, Thread* current) {\n+    ResourceMark rm(current);\n@@ -919,2 +919,2 @@\n-  static void write_method(Method* m, address runtime_dest, const char* type_name, int bytes, Thread* THREAD) {\n-    ResourceMark rm(THREAD);\n+  static void write_method(Method* m, address runtime_dest, const char* type_name, int bytes, Thread* current) {\n+    ResourceMark rm(current);\n@@ -930,1 +930,1 @@\n-    Thread* THREAD = Thread::current();\n+    Thread* current = Thread::current();\n@@ -944,1 +944,1 @@\n-        write_klass((Klass*)src, runtime_dest, type_name, bytes, THREAD);\n+        write_klass((Klass*)src, runtime_dest, type_name, bytes, current);\n@@ -948,1 +948,1 @@\n-                    runtime_dest, type_name, bytes, THREAD);\n+                    runtime_dest, type_name, bytes, current);\n@@ -952,1 +952,1 @@\n-                    runtime_dest, type_name, bytes, THREAD);\n+                    runtime_dest, type_name, bytes, current);\n@@ -955,1 +955,1 @@\n-        write_method((Method*)src, runtime_dest, type_name, bytes, THREAD);\n+        write_method((Method*)src, runtime_dest, type_name, bytes, current);\n@@ -958,1 +958,1 @@\n-        write_method(((ConstMethod*)src)->method(), runtime_dest, type_name, bytes, THREAD);\n+        write_method(((ConstMethod*)src)->method(), runtime_dest, type_name, bytes, current);\n@@ -962,1 +962,1 @@\n-          ResourceMark rm(THREAD);\n+          ResourceMark rm(current);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-ClassListParser::ClassListParser(const char* file) {\n+ClassListParser::ClassListParser(const char* file) : _id2klass_table(INITIAL_TABLE_SIZE) {\n@@ -574,1 +574,1 @@\n-void ClassListParser::resolve_indy(Thread* current, Symbol* class_name_symbol) {\n+void ClassListParser::resolve_indy(JavaThread* current, Symbol* class_name_symbol) {\n@@ -576,1 +576,1 @@\n-  Thread* THREAD = current; \/\/ For exception macros.\n+  JavaThread* THREAD = current; \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -688,1 +688,1 @@\n-void HeapShared::resolve_classes(Thread* THREAD) {\n+void HeapShared::resolve_classes(JavaThread* THREAD) {\n@@ -704,1 +704,1 @@\n-                                               int num, Thread* THREAD) {\n+                                               int num, JavaThread* THREAD) {\n@@ -714,1 +714,1 @@\n-void HeapShared::resolve_classes_for_subgraph_of(Klass* k, Thread* THREAD) {\n+void HeapShared::resolve_classes_for_subgraph_of(Klass* k, JavaThread* THREAD) {\n@@ -726,1 +726,1 @@\n-void HeapShared::initialize_from_archived_subgraph(Klass* k, Thread* THREAD) {\n+void HeapShared::initialize_from_archived_subgraph(Klass* k, JavaThread* THREAD) {\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-void MetaspaceShared::read_extra_data(Thread* current, const char* filename) {\n+void MetaspaceShared::read_extra_data(JavaThread* current, const char* filename) {\n@@ -294,1 +294,1 @@\n-      Thread* THREAD = current; \/\/ For exception macros.\n+      JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -395,1 +395,1 @@\n-    if (!is_old_class(ik)) {\n+    if (!ik->can_be_verified_at_dumptime()) {\n@@ -483,7 +483,0 @@\n-  \/\/ We should no longer allocate anything from the metaspace, so that:\n-  \/\/\n-  \/\/ (1) Metaspace::allocate might trigger GC if we have run out of\n-  \/\/     committed metaspace, but we can't GC because we're running\n-  \/\/     in the VM thread.\n-  \/\/ (2) ArchiveBuilder needs to work with a stable set of MetaspaceObjs.\n-  Metaspace::freeze();\n@@ -501,0 +494,1 @@\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n@@ -582,21 +576,0 @@\n-\/\/ Check if a class or its super class\/interface is old.\n-bool MetaspaceShared::is_old_class(InstanceKlass* ik) {\n-  if (ik == NULL) {\n-    return false;\n-  }\n-  if (ik->major_version() < 50 \/*JAVA_6_VERSION*\/) {\n-    return true;\n-  }\n-  if (is_old_class(ik->java_super())) {\n-    return true;\n-  }\n-  Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n-  int len = interfaces->length();\n-  for (int i = 0; i < len; i++) {\n-    if (is_old_class(interfaces->at(i))) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n@@ -606,1 +579,1 @@\n-  return DumpSharedSpaces ? !MetaspaceShared::is_old_class(ik) : !ik->is_shared_unregistered_class();\n+  return DumpSharedSpaces ? !ik->can_be_verified_at_dumptime() : !ik->is_shared_unregistered_class();\n@@ -627,0 +600,2 @@\n+\n+  LambdaFormInvokers::regenerate_holder_classes(CHECK);\n@@ -663,1 +638,1 @@\n-  ClassLoader::initialize_shared_path(Thread::current());\n+  ClassLoader::initialize_shared_path(JavaThread::current());\n@@ -747,6 +722,0 @@\n-  if (LambdaFormInvokers::lambdaform_lines() != NULL) {\n-    log_info(cds)(\"Regenerate MethodHandle Holder classes...\");\n-    LambdaFormInvokers::regenerate_holder_classes(CHECK);\n-    log_info(cds)(\"Regenerate MethodHandle Holder classes done.\");\n-  }\n-\n@@ -782,1 +751,1 @@\n-bool MetaspaceShared::try_link_class(Thread* current, InstanceKlass* ik) {\n+bool MetaspaceShared::try_link_class(JavaThread* current, InstanceKlass* ik) {\n@@ -784,1 +753,1 @@\n-  Thread* THREAD = current; \/\/ For exception macros.\n+  JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -786,1 +755,1 @@\n-  if (ik->is_loaded() && !ik->is_linked() && !MetaspaceShared::is_old_class(ik) &&\n+  if (ik->is_loaded() && !ik->is_linked() && !ik->can_be_verified_at_dumptime() &&\n@@ -1404,15 +1373,0 @@\n-\/\/ For -XX:PrintSharedArchiveAndExit\n-class CountSharedStrings : public OopClosure {\n- private:\n-  int _count;\n- public:\n-  CountSharedStrings() : _count(0) {}\n-  void do_oop(oop* p) {\n-    _count++;\n-  }\n-  void do_oop(narrowOop* p) {\n-    _count++;\n-  }\n-  int total() { return _count; }\n-};\n-\n@@ -1479,3 +1433,1 @@\n-    CountSharedStrings cs;\n-    StringTable::shared_oops_do(&cs);\n-    tty->print_cr(\"Number of shared strings: %d\", cs.total());\n+    tty->print_cr(\"Number of shared strings: %zu\", StringTable::shared_entry_count());\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":12,"deletions":60,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -191,4 +191,0 @@\n-void BCEscapeAnalyzer::set_dirty(ArgumentMap vars) {\n-  clear_bits(vars, _dirty);\n-}\n-\n@@ -349,0 +345,3 @@\n+        _dependencies.append(callee_holder);\n+        _dependencies.append(target);\n+        assert(callee_holder->is_interface() == (code == Bytecodes::_invokeinterface), \"sanity\");\n@@ -490,1 +489,0 @@\n-          set_dirty(array);\n@@ -1470,1 +1468,0 @@\n-    , _dirty(_arena)\n@@ -1482,1 +1479,0 @@\n-    _dirty.clear();\n@@ -1517,4 +1513,6 @@\n-  for (int i = 0; i < _dependencies.length(); i+=2) {\n-    ciKlass *k = _dependencies.at(i)->as_klass();\n-    ciMethod *m = _dependencies.at(i+1)->as_method();\n-    deps->assert_unique_concrete_method(k, m);\n+  for (int i = 0; i < _dependencies.length(); i+=4) {\n+    ciKlass*  recv_klass      = _dependencies.at(i+0)->as_klass();\n+    ciMethod* target          = _dependencies.at(i+1)->as_method();\n+    ciKlass*  resolved_klass  = _dependencies.at(i+2)->as_klass();\n+    ciMethod* resolved_method = _dependencies.at(i+3)->as_method();\n+    deps->assert_unique_concrete_method(recv_klass, target, resolved_klass, resolved_method);\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -670,9 +670,5 @@\n-    if (cpool->is_pseudo_string_at(index)) {\n-      string = cpool->pseudo_string_at(index, cache_index);\n-    } else {\n-      string = cpool->string_at(index, cache_index, THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        CLEAR_PENDING_EXCEPTION;\n-        record_out_of_memory_failure();\n-        return ciConstant();\n-      }\n+    string = cpool->string_at(index, cache_index, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      CLEAR_PENDING_EXCEPTION;\n+      record_out_of_memory_failure();\n+      return ciConstant();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -254,2 +254,1 @@\n-  \/\/ Trust hidden classes and VM unsafe anonymous classes. They are created via\n-  \/\/ Lookup.defineHiddenClass or the private jdk.internal.misc.Unsafe API and\n+  \/\/ Trust hidden classes. They are created via Lookup.defineHiddenClass and\n@@ -257,1 +256,1 @@\n-  if (holder->is_hidden() || holder->is_unsafe_anonymous())\n+  if (holder->is_hidden())\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  bool is_strict               () const { return (_flags & JVM_ACC_STRICT                    ) != 0; }\n","filename":"src\/hotspot\/share\/ci\/ciFlags.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-  _is_unsafe_anonymous = ik->is_unsafe_anonymous();\n@@ -86,1 +85,1 @@\n-    \/\/ non-strong hidden classes and VM unsafe anonymous classes alive (loader == NULL). Klass holder should\n+    \/\/ non-strong hidden classes alive (loader == NULL). Klass holder should\n@@ -90,1 +89,1 @@\n-    assert(holder != NULL, \"holder of hidden or unsafe anonymous class is the mirror which is never null\");\n+    assert(holder != NULL, \"holder of hidden class is the mirror which is never null\");\n@@ -134,1 +133,0 @@\n-  _is_unsafe_anonymous = false;\n@@ -722,10 +720,0 @@\n-ciInstanceKlass* ciInstanceKlass::unsafe_anonymous_host() {\n-  assert(is_loaded(), \"must be loaded\");\n-  if (is_unsafe_anonymous()) {\n-    VM_ENTRY_MARK\n-    Klass* unsafe_anonymous_host = get_instanceKlass()->unsafe_anonymous_host();\n-    return CURRENT_ENV->get_instance_klass(unsafe_anonymous_host);\n-  }\n-  return NULL;\n-}\n-\n@@ -869,1 +857,1 @@\n-    if (sub->is_instance_klass() && !sub->is_hidden() && !InstanceKlass::cast(sub)->is_unsafe_anonymous()) {\n+    if (sub->is_instance_klass() && !sub->is_hidden()) {\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-  bool                   _is_unsafe_anonymous;\n@@ -157,7 +156,6 @@\n-    if (_has_subklass == subklass_unknown ||\n-        (_is_shared && _has_subklass == subklass_false)) {\n-      if (flags().is_final()) {\n-        return false;\n-      } else {\n-        return compute_shared_has_subklass();\n-      }\n+    \/\/ Ignore cached subklass_false case.\n+    \/\/ It could be invalidated by concurrent class loading and\n+    \/\/ can result in type paradoxes during compilation when\n+    \/\/ a subclass is observed, but has_subklass() returns false.\n+    if (_has_subklass == subklass_true) {\n+      return true;\n@@ -165,1 +163,4 @@\n-    return _has_subklass == subklass_true;\n+    if (flags().is_final()) {\n+      return false;\n+    }\n+    return compute_shared_has_subklass();\n@@ -167,0 +168,1 @@\n+\n@@ -198,4 +200,0 @@\n-  bool is_unsafe_anonymous() const {\n-    return _is_unsafe_anonymous;\n-  }\n-\n@@ -299,2 +297,0 @@\n-  ciInstanceKlass* unsafe_anonymous_host();\n-\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -78,4 +78,2 @@\n-  VM_ENTRY_MARK;\n-  Klass* this_klass = get_Klass();\n-  Klass* that_klass = that->get_Klass();\n-  bool result = this_klass->is_subtype_of(that_klass);\n+  bool is_subtype;\n+  GUARDED_VM_ENTRY(is_subtype = get_Klass()->is_subtype_of(that->get_Klass());)\n@@ -83,1 +81,6 @@\n-  return result;\n+  \/\/ Ensure consistency with ciInstanceKlass::has_subklass().\n+  assert(!that->is_instance_klass() || \/\/ array klasses are irrelevant\n+          that->is_interface()      || \/\/ has_subklass is always false for interfaces\n+         !is_subtype || that->as_instance_klass()->has_subklass(), \"inconsistent\");\n+\n+  return is_subtype;\n@@ -92,1 +95,14 @@\n-  GUARDED_VM_ENTRY(return get_Klass()->is_subclass_of(that->get_Klass());)\n+  \/\/ Check to see if the klasses are identical.\n+  if (this == that) {\n+    return true;\n+  }\n+\n+  bool is_subclass;\n+  GUARDED_VM_ENTRY(is_subclass = get_Klass()->is_subclass_of(that->get_Klass());)\n+\n+  \/\/ Ensure consistency with ciInstanceKlass::has_subklass().\n+  assert(!that->is_instance_klass() || \/\/ array klasses are irrelevant\n+          that->is_interface()      || \/\/ has_subklass is always false for interfaces\n+         !is_subclass || that->as_instance_klass()->has_subklass(), \"inconsistent\");\n+\n+  return is_subclass;\n@@ -154,0 +170,1 @@\n+    assert(this->is_subtype_of(that), \"sanity\");\n@@ -157,0 +174,1 @@\n+    assert(that->is_subtype_of(this), \"sanity\");\n@@ -164,0 +182,1 @@\n+  assert(this->is_subtype_of(result) && that->is_subtype_of(result), \"sanity\");\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -712,1 +712,1 @@\n-  ciMethod* root_m = resolve_invoke(caller, actual_recv, check_access);\n+  ciMethod* root_m = resolve_invoke(caller, actual_recv, check_access, true \/* allow_abstract *\/);\n@@ -717,1 +717,0 @@\n-  assert(!root_m->is_abstract(), \"resolve_invoke promise\");\n@@ -723,0 +722,1 @@\n+    assert(!root_m->is_abstract(), \"sanity\");\n@@ -729,0 +729,3 @@\n+    if (root_m->is_abstract()) {\n+      return NULL;\n+    }\n@@ -742,5 +745,0 @@\n-  \/\/ Disable CHA for default methods for now\n-  if (root_m->is_default_method()) {\n-    return NULL;\n-  }\n-\n@@ -751,1 +749,12 @@\n-    target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context, root_m->get_Method()));\n+    if (UseVtableBasedCHA) {\n+      target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context,\n+                                                                              root_m->get_Method(),\n+                                                                              callee_holder->get_Klass(),\n+                                                                              this->get_Method()));\n+    } else {\n+      if (root_m->is_abstract()) {\n+        return NULL; \/\/ not supported\n+      }\n+      target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context, root_m->get_Method()));\n+    }\n+    assert(target() == NULL || !target()->is_abstract(), \"not allowed\");\n@@ -782,1 +791,0 @@\n-  assert(!target()->is_abstract(), \"not allowed\");\n@@ -799,43 +807,41 @@\n-ciMethod* ciMethod::resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access) {\n-   check_is_loaded();\n-   VM_ENTRY_MARK;\n-\n-   Klass* caller_klass = caller->get_Klass();\n-   Klass* recv         = exact_receiver->get_Klass();\n-   Klass* resolved     = holder()->get_Klass();\n-   Symbol* h_name      = name()->get_symbol();\n-   Symbol* h_signature = signature()->get_symbol();\n-\n-   LinkInfo link_info(resolved, h_name, h_signature, caller_klass,\n-                      check_access ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip,\n-                      check_access ? LinkInfo::LoaderConstraintCheck::required : LinkInfo::LoaderConstraintCheck::skip);\n-   Method* m = NULL;\n-   \/\/ Only do exact lookup if receiver klass has been linked.  Otherwise,\n-   \/\/ the vtable has not been setup, and the LinkResolver will fail.\n-   if (recv->is_array_klass()\n-        ||\n-       (InstanceKlass::cast(recv)->is_linked() && !exact_receiver->is_interface())) {\n-     if (holder()->is_interface()) {\n-       m = LinkResolver::resolve_interface_call_or_null(recv, link_info);\n-     } else {\n-       m = LinkResolver::resolve_virtual_call_or_null(recv, link_info);\n-     }\n-   }\n-\n-   if (m == NULL) {\n-     \/\/ Return NULL only if there was a problem with lookup (uninitialized class, etc.)\n-     return NULL;\n-   }\n-\n-   ciMethod* result = this;\n-   if (m != get_Method()) {\n-     result = CURRENT_THREAD_ENV->get_method(m);\n-   }\n-\n-   \/\/ Don't return abstract methods because they aren't\n-   \/\/ optimizable or interesting.\n-   if (result->is_abstract()) {\n-     return NULL;\n-   } else {\n-     return result;\n-   }\n+ciMethod* ciMethod::resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access, bool allow_abstract) {\n+  check_is_loaded();\n+  VM_ENTRY_MARK;\n+\n+  Klass* caller_klass = caller->get_Klass();\n+  Klass* recv         = exact_receiver->get_Klass();\n+  Klass* resolved     = holder()->get_Klass();\n+  Symbol* h_name      = name()->get_symbol();\n+  Symbol* h_signature = signature()->get_symbol();\n+\n+  LinkInfo link_info(resolved, h_name, h_signature, caller_klass,\n+                     check_access ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip,\n+                     check_access ? LinkInfo::LoaderConstraintCheck::required : LinkInfo::LoaderConstraintCheck::skip);\n+  Method* m = NULL;\n+  \/\/ Only do exact lookup if receiver klass has been linked.  Otherwise,\n+  \/\/ the vtable has not been setup, and the LinkResolver will fail.\n+  if (recv->is_array_klass()\n+       ||\n+      (InstanceKlass::cast(recv)->is_linked() && !exact_receiver->is_interface())) {\n+    if (holder()->is_interface()) {\n+      m = LinkResolver::resolve_interface_call_or_null(recv, link_info);\n+    } else {\n+      m = LinkResolver::resolve_virtual_call_or_null(recv, link_info);\n+    }\n+  }\n+\n+  if (m == NULL) {\n+    \/\/ Return NULL only if there was a problem with lookup (uninitialized class, etc.)\n+    return NULL;\n+  }\n+\n+  ciMethod* result = this;\n+  if (m != get_Method()) {\n+    result = CURRENT_THREAD_ENV->get_method(m);\n+  }\n+\n+  if (result->is_abstract() && !allow_abstract) {\n+    \/\/ Don't return abstract methods because they aren't optimizable or interesting.\n+    return NULL;\n+  }\n+  return result;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":58,"deletions":52,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -307,1 +307,1 @@\n-  ciMethod* resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access = true);\n+  ciMethod* resolve_invoke(ciKlass* caller, ciKlass* exact_receiver, bool check_access = true, bool allow_abstract = false);\n@@ -349,1 +349,0 @@\n-  bool is_strict      () const                   { return flags().is_strict(); }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -844,1 +844,1 @@\n-        Thread* THREAD = Thread::current();\n+        JavaThread* THREAD = Thread::current()->as_Java_thread();\n@@ -857,1 +857,1 @@\n-          oop value = vk->allocate_instance(Thread::current());\n+          oop value = vk->allocate_instance(Thread::current()->as_Java_thread());\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -143,1 +143,4 @@\n-#define CONSTANT_CLASS_DESCRIPTORS        61\n+#define JAVA_18_VERSION                   62\n+\n+#define CONSTANT_CLASS_DESCRIPTORS        62\n+\n@@ -330,12 +333,0 @@\n-        if (has_cp_patch_at(index)) {\n-          Handle patch = clear_cp_patch_at(index);\n-          guarantee_property(java_lang_String::is_instance(patch()),\n-                             \"Illegal utf8 patch at %d in class file %s\",\n-                             index,\n-                             CHECK);\n-          const char* const str = java_lang_String::as_utf8_string(patch());\n-          \/\/ (could use java_lang_String::as_symbol instead, but might as well batch them)\n-          utf8_buffer = (const u1*) str;\n-          utf8_length = (u2) strlen(str);\n-        }\n-\n@@ -631,31 +622,1 @@\n-  _first_patched_klass_resolved_index = num_klasses;\n-  cp->allocate_resolved_klasses(_loader_data, num_klasses + _max_num_patched_klasses, CHECK);\n-\n-  if (_cp_patches != NULL) {\n-    \/\/ need to treat this_class specially...\n-\n-    \/\/ Add dummy utf8 entries in the space reserved for names of patched classes. We'll use \"*\"\n-    \/\/ for now. These will be replaced with actual names of the patched classes in patch_class().\n-    Symbol* s = vmSymbols::star_name();\n-    for (int n=_orig_cp_size; n<cp->length(); n++) {\n-      cp->symbol_at_put(n, s);\n-    }\n-\n-    int this_class_index;\n-    {\n-      stream->guarantee_more(8, CHECK);  \/\/ flags, this_class, super_class, infs_len\n-      const u1* const mark = stream->current();\n-      stream->skip_u2_fast(1); \/\/ skip flags\n-      this_class_index = stream->get_u2_fast();\n-      stream->set_current(mark);  \/\/ revert to mark\n-    }\n-\n-    for (index = 1; index < length; index++) {          \/\/ Index 0 is unused\n-      if (has_cp_patch_at(index)) {\n-        guarantee_property(index != this_class_index,\n-          \"Illegal constant pool patch to self at %d in class file %s\",\n-          index, CHECK);\n-        patch_constant_pool(cp, index, cp_patch_at(index), CHECK);\n-      }\n-    }\n-  }\n+  cp->allocate_resolved_klasses(_loader_data, num_klasses, CHECK);\n@@ -674,1 +635,1 @@\n-        \/\/ check the name, even if _cp_patches will overwrite it\n+        \/\/ check the name\n@@ -825,82 +786,0 @@\n-Handle ClassFileParser::clear_cp_patch_at(int index) {\n-  Handle patch = cp_patch_at(index);\n-  _cp_patches->at_put(index, Handle());\n-  assert(!has_cp_patch_at(index), \"\");\n-  return patch;\n-}\n-\n-void ClassFileParser::patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name) {\n-  int name_index = _orig_cp_size + _num_patched_klasses;\n-  int resolved_klass_index = _first_patched_klass_resolved_index + _num_patched_klasses;\n-\n-  cp->klass_at_put(class_index, name_index, resolved_klass_index, k, name);\n-  _num_patched_klasses ++;\n-}\n-\n-void ClassFileParser::patch_constant_pool(ConstantPool* cp,\n-                                          int index,\n-                                          Handle patch,\n-                                          TRAPS) {\n-  assert(cp != NULL, \"invariant\");\n-\n-  BasicType patch_type = T_VOID;\n-\n-  switch (cp->tag_at(index).value()) {\n-\n-    case JVM_CONSTANT_UnresolvedClass: {\n-      \/\/ Patching a class means pre-resolving it.\n-      \/\/ The name in the constant pool is ignored.\n-      if (java_lang_Class::is_instance(patch())) {\n-        guarantee_property(!java_lang_Class::is_primitive(patch()),\n-                           \"Illegal class patch at %d in class file %s\",\n-                           index, CHECK);\n-        Klass* k = java_lang_Class::as_Klass(patch());\n-        patch_class(cp, index, k, k->name());\n-      } else {\n-        guarantee_property(java_lang_String::is_instance(patch()),\n-                           \"Illegal class patch at %d in class file %s\",\n-                           index, CHECK);\n-        Symbol* const name = java_lang_String::as_symbol(patch());\n-        patch_class(cp, index, NULL, name);\n-      }\n-      break;\n-    }\n-\n-    case JVM_CONSTANT_String: {\n-      \/\/ skip this patch and don't clear it.  Needs the oop array for resolved\n-      \/\/ references to be created first.\n-      return;\n-    }\n-    case JVM_CONSTANT_Integer: patch_type = T_INT;    goto patch_prim;\n-    case JVM_CONSTANT_Float:   patch_type = T_FLOAT;  goto patch_prim;\n-    case JVM_CONSTANT_Long:    patch_type = T_LONG;   goto patch_prim;\n-    case JVM_CONSTANT_Double:  patch_type = T_DOUBLE; goto patch_prim;\n-    patch_prim:\n-    {\n-      jvalue value;\n-      BasicType value_type = java_lang_boxing_object::get_value(patch(), &value);\n-      guarantee_property(value_type == patch_type,\n-                         \"Illegal primitive patch at %d in class file %s\",\n-                         index, CHECK);\n-      switch (value_type) {\n-        case T_INT:    cp->int_at_put(index,   value.i); break;\n-        case T_FLOAT:  cp->float_at_put(index, value.f); break;\n-        case T_LONG:   cp->long_at_put(index,  value.j); break;\n-        case T_DOUBLE: cp->double_at_put(index, value.d); break;\n-        default:       assert(false, \"\");\n-      }\n-    } \/\/ end patch_prim label\n-    break;\n-\n-    default: {\n-      \/\/ %%% TODO: put method handles into CONSTANT_InterfaceMethodref, etc.\n-      guarantee_property(!has_cp_patch_at(index),\n-                         \"Illegal unexpected patch at %d in class file %s\",\n-                         index, CHECK);\n-      return;\n-    }\n-  } \/\/ end of switch(tag)\n-\n-  \/\/ On fall-through, mark the patch as used.\n-  clear_cp_patch_at(index);\n-}\n@@ -2505,1 +2384,1 @@\n-      flags &= JVM_ACC_STATIC | JVM_ACC_STRICT;\n+      flags &= JVM_ACC_STATIC | (_major_version <= JAVA_16_VERSION ? JVM_ACC_STRICT : 0);\n@@ -3814,5 +3693,0 @@\n-bool ClassFileParser::supports_sealed_types() {\n-  \/\/ temporarily disable the sealed type preview feature check\n-  return _major_version == JVM_CLASSFILE_MAJOR_VERSION;\n-}\n-\n@@ -4075,2 +3949,2 @@\n-          } else if (tag == vmSymbols::tag_permitted_subclasses()) {\n-            if (supports_sealed_types()) {\n+          } else if (_major_version >= JAVA_17_VERSION) {\n+            if (tag == vmSymbols::tag_permitted_subclasses()) {\n@@ -4091,1 +3965,1 @@\n-          \/\/ Skip attribute_length for any attribute where major_verson >= JAVA_16_VERSION\n+          \/\/ Skip attribute_length for any attribute where major_verson >= JAVA_17_VERSION\n@@ -4481,1 +4355,1 @@\n-        Thread *THREAD = Thread::current();\n+        JavaThread *THREAD = Thread::current()->as_Java_thread();\n@@ -4997,0 +4871,1 @@\n+  const bool major_gte_17    = _major_version >= JAVA_17_VERSION;\n@@ -5016,1 +4891,1 @@\n-          (is_abstract && (is_private || is_static || is_strict))) {\n+          (is_abstract && (is_private || is_static || (!major_gte_17 && is_strict)))) {\n@@ -5056,1 +4931,1 @@\n-                (major_gte_1_5 && (is_synchronized || is_strict)))) {\n+                (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n@@ -5748,1 +5623,1 @@\n-  if (_is_hidden || is_unsafe_anonymous()) {\n+  if (_is_hidden) {\n@@ -5750,3 +5625,3 @@\n-    \/\/ hidden or anonymous class itself. If this class needs to refer to its own\n-    \/\/ methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference\n-    \/\/ _this_class_index. However, because this class is hidden or anonymous (it's\n+    \/\/ hidden class itself. If this class needs to refer to its own methods\n+    \/\/ or fields, it would use a CONSTANT_MethodRef, etc, which would reference\n+    \/\/ _this_class_index. However, because this class is hidden (it's\n@@ -5767,4 +5642,0 @@\n-  if (_unsafe_anonymous_host != NULL) {\n-    assert (ik->is_unsafe_anonymous(), \"should be the same\");\n-    ik->set_unsafe_anonymous_host(_unsafe_anonymous_host);\n-  }\n@@ -5983,51 +5854,0 @@\n-\/\/ For an unsafe anonymous class that is in the unnamed package, move it to its host class's\n-\/\/ package by prepending its host class's package name to its class name and setting\n-\/\/ its _class_name field.\n-void ClassFileParser::prepend_host_package_name(Thread* current, const InstanceKlass* unsafe_anonymous_host) {\n-  ResourceMark rm(current);\n-  assert(strrchr(_class_name->as_C_string(), JVM_SIGNATURE_SLASH) == NULL,\n-         \"Unsafe anonymous class should not be in a package\");\n-  TempNewSymbol host_pkg_name =\n-    ClassLoader::package_from_class_name(unsafe_anonymous_host->name());\n-\n-  if (host_pkg_name != NULL) {\n-    int host_pkg_len = host_pkg_name->utf8_length();\n-    int class_name_len = _class_name->utf8_length();\n-    int symbol_len = host_pkg_len + 1 + class_name_len;\n-    char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);\n-    int n = os::snprintf(new_anon_name, symbol_len + 1, \"%.*s\/%.*s\",\n-                         host_pkg_len, host_pkg_name->base(), class_name_len, _class_name->base());\n-    assert(n == symbol_len, \"Unexpected number of characters in string\");\n-\n-    \/\/ Decrement old _class_name to avoid leaking.\n-    _class_name->decrement_refcount();\n-\n-    \/\/ Create a symbol and update the anonymous class name.\n-    \/\/ The new class name is created with a refcount of one. When installed into the InstanceKlass,\n-    \/\/ it'll be two and when the ClassFileParser destructor runs, it'll go back to one and get deleted\n-    \/\/ when the class is unloaded.\n-    _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);\n-  }\n-}\n-\n-\/\/ If the host class and the anonymous class are in the same package then do\n-\/\/ nothing.  If the anonymous class is in the unnamed package then move it to its\n-\/\/ host's package.  If the classes are in different packages then throw an IAE\n-\/\/ exception.\n-void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {\n-  assert(_unsafe_anonymous_host != NULL, \"Expected an unsafe anonymous class\");\n-\n-  const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name->base(),\n-                                               _class_name->utf8_length(), JVM_SIGNATURE_SLASH);\n-  if (anon_last_slash == NULL) {  \/\/ Unnamed package\n-    prepend_host_package_name(THREAD, _unsafe_anonymous_host);\n-  } else {\n-    if (!_unsafe_anonymous_host->is_same_class_package(_unsafe_anonymous_host->class_loader(), _class_name)) {\n-      ResourceMark rm(THREAD);\n-      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n-        err_msg(\"Host class %s and anonymous class %s are in different packages\",\n-        _unsafe_anonymous_host->name()->as_C_string(), _class_name->as_C_string()));\n-    }\n-  }\n-}\n-\n@@ -6054,2 +5874,0 @@\n-  _unsafe_anonymous_host(cl_info->unsafe_anonymous_host()),\n-  _cp_patches(cl_info->cp_patches()),\n@@ -6058,3 +5876,0 @@\n-  _num_patched_klasses(0),\n-  _max_num_patched_klasses(0),\n-  _first_patched_klass_resolved_index(0),\n@@ -6130,1 +5945,0 @@\n-  assert(THREAD->is_Java_thread(), \"invariant\");\n@@ -6150,19 +5964,0 @@\n-  if (_cp_patches != NULL) {\n-    int len = _cp_patches->length();\n-    for (int i=0; i<len; i++) {\n-      if (has_cp_patch_at(i)) {\n-        Handle patch = cp_patch_at(i);\n-        if (java_lang_String::is_instance(patch()) || java_lang_Class::is_instance(patch())) {\n-          \/\/ We need to append the names of the patched classes to the end of the constant pool,\n-          \/\/ because a patched class may have a Utf8 name that's not already included in the\n-          \/\/ original constant pool. These class names are used when patch_constant_pool()\n-          \/\/ calls patch_class().\n-          \/\/\n-          \/\/ Note that a String in cp_patch_at(i) may be used to patch a Utf8, a String, or a Class.\n-          \/\/ At this point, we don't know the tag for index i yet, because we haven't parsed the\n-          \/\/ constant pool. So we can only assume the worst -- every String is used to patch a Class.\n-          _max_num_patched_klasses++;\n-        }\n-      }\n-    }\n-  }\n@@ -6298,6 +6093,0 @@\n-    assert(_max_num_patched_klasses == 0, \"Sanity check\");\n-  } else {\n-    if (int(cp_size) + _max_num_patched_klasses > 0xffff) {\n-      THROW_MSG(vmSymbols::java_lang_InternalError(), \"not enough space for patched classes\");\n-    }\n-    cp_size += _max_num_patched_klasses;\n@@ -6372,5 +6161,0 @@\n-  assert(!(_is_hidden && (_unsafe_anonymous_host != NULL)), \"mutually exclusive variants\");\n-\n-  if (_unsafe_anonymous_host != NULL) {\n-    assert(_class_name == vmSymbols::unknown_class_name(), \"A named anonymous class???\");\n-  }\n@@ -6382,2 +6166,1 @@\n-  \/\/ Update the _class_name as needed depending on whether this is a named,\n-  \/\/ un-named, hidden or unsafe-anonymous class.\n+  \/\/ Update the _class_name as needed depending on whether this is a named, un-named, or hidden class.\n@@ -6393,10 +6176,0 @@\n-  \/\/ NOTE: !_is_hidden does not imply \"findable\" as it could be an old-style\n-  \/\/       \"hidden\" unsafe-anonymous class\n-\n-  \/\/ If this is an anonymous class fix up its name if it is in the unnamed\n-  \/\/ package.  Otherwise, throw IAE if it is in a different package than\n-  \/\/ its host class.\n-  } else if (_unsafe_anonymous_host != NULL) {\n-    update_class_name(class_name_in_cp);\n-    fix_unsafe_anonymous_class_name(CHECK);\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":19,"deletions":246,"binary":false,"changes":265,"status":"modified"},{"patch":"@@ -118,2 +118,0 @@\n-  const InstanceKlass* _unsafe_anonymous_host;\n-  GrowableArray<Handle>* _cp_patches; \/\/ overrides for CP entries\n@@ -122,3 +120,0 @@\n-  int _num_patched_klasses;\n-  int _max_num_patched_klasses;\n-  int _first_patched_klass_resolved_index;\n@@ -233,3 +228,0 @@\n-  void prepend_host_package_name(Thread* current, const InstanceKlass* unsafe_anonymous_host);\n-  void fix_unsafe_anonymous_class_name(TRAPS);\n-\n@@ -367,3 +359,0 @@\n-  bool supports_sealed_types();\n-  bool supports_records();\n-\n@@ -529,20 +518,0 @@\n-  bool has_cp_patch_at(int index) const {\n-    assert(index >= 0, \"oob\");\n-    return (_cp_patches != NULL\n-            && index < _cp_patches->length()\n-            && _cp_patches->adr_at(index)->not_null());\n-  }\n-\n-  Handle cp_patch_at(int index) const {\n-    assert(has_cp_patch_at(index), \"oob\");\n-    return _cp_patches->at(index);\n-  }\n-\n-  Handle clear_cp_patch_at(int index);\n-\n-  void patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name);\n-  void patch_constant_pool(ConstantPool* cp,\n-                           int index,\n-                           Handle patch,\n-                           TRAPS);\n-\n@@ -620,1 +589,0 @@\n-  bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }\n@@ -634,2 +602,0 @@\n-  const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }\n-  const GrowableArray<Handle>* cp_patches() const { return _cp_patches; }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-ClassFileStream* ClassPathDirEntry::open_stream(Thread* current, const char* name) {\n+ClassFileStream* ClassPathDirEntry::open_stream(JavaThread* current, const char* name) {\n@@ -289,1 +289,1 @@\n-u1* ClassPathZipEntry::open_entry(Thread* current, const char* name, jint* filesize, bool nul_terminate) {\n+u1* ClassPathZipEntry::open_entry(JavaThread* current, const char* name, jint* filesize, bool nul_terminate) {\n@@ -291,1 +291,1 @@\n-  ThreadToNativeFromVM ttn(current->as_Java_thread());\n+  ThreadToNativeFromVM ttn(current);\n@@ -317,1 +317,1 @@\n-ClassFileStream* ClassPathZipEntry::open_stream(Thread* current, const char* name) {\n+ClassFileStream* ClassPathZipEntry::open_stream(JavaThread* current, const char* name) {\n@@ -375,1 +375,1 @@\n-ClassFileStream* ClassPathImageEntry::open_stream(Thread* current, const char* name) {\n+ClassFileStream* ClassPathImageEntry::open_stream(JavaThread* current, const char* name) {\n@@ -386,1 +386,1 @@\n-ClassFileStream* ClassPathImageEntry::open_stream_for_loader(Thread* current, const char* name, ClassLoaderData* loader_data) {\n+ClassFileStream* ClassPathImageEntry::open_stream_for_loader(JavaThread* current, const char* name, ClassLoaderData* loader_data) {\n@@ -502,1 +502,1 @@\n-void ClassLoader::setup_bootstrap_search_path(Thread* current) {\n+void ClassLoader::setup_bootstrap_search_path(JavaThread* current) {\n@@ -515,1 +515,1 @@\n-void ClassLoader::setup_app_search_path(Thread* current, const char *class_path) {\n+void ClassLoader::setup_app_search_path(JavaThread* current, const char *class_path) {\n@@ -543,1 +543,1 @@\n-void ClassLoader::setup_module_search_path(Thread* current, const char* path) {\n+void ClassLoader::setup_module_search_path(JavaThread* current, const char* path) {\n@@ -572,1 +572,1 @@\n-  Thread* THREAD = Thread::current();\n+  JavaThread* current = JavaThread::current();\n@@ -586,1 +586,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -594,1 +594,1 @@\n-        ClassPathEntry* new_entry = create_class_path_entry(THREAD, path, &st, false, false);\n+        ClassPathEntry* new_entry = create_class_path_entry(current, path, &st, false, false);\n@@ -626,1 +626,1 @@\n-void ClassLoader::setup_bootstrap_search_path_impl(Thread* current, const char *class_path) {\n+void ClassLoader::setup_bootstrap_search_path_impl(JavaThread* current, const char *class_path) {\n@@ -678,1 +678,1 @@\n-void ClassLoader::add_to_exploded_build_list(Thread* current, Symbol* module_sym) {\n+void ClassLoader::add_to_exploded_build_list(JavaThread* current, Symbol* module_sym) {\n@@ -721,1 +721,1 @@\n-ClassPathEntry* ClassLoader::create_class_path_entry(Thread* current,\n+ClassPathEntry* ClassLoader::create_class_path_entry(JavaThread* current,\n@@ -725,1 +725,0 @@\n-  JavaThread* thread = current->as_Java_thread();\n@@ -728,1 +727,1 @@\n-    ResourceMark rm(thread);\n+    ResourceMark rm(current);\n@@ -731,1 +730,1 @@\n-    const char* canonical_path = get_canonical_path(path, thread);\n+    const char* canonical_path = get_canonical_path(path, current);\n@@ -736,1 +735,1 @@\n-    jzfile* zip = open_zip_file(canonical_path, &error_msg, thread);\n+    jzfile* zip = open_zip_file(canonical_path, &error_msg, current);\n@@ -740,0 +739,3 @@\n+#if INCLUDE_CDS\n+      ClassLoaderExt::set_has_non_jar_in_classpath();\n+#endif\n@@ -797,1 +799,1 @@\n-void ClassLoader::add_to_app_classpath_entries(Thread* current,\n+void ClassLoader::add_to_app_classpath_entries(JavaThread* current,\n@@ -830,1 +832,1 @@\n-bool ClassLoader::update_class_path_entry_list(Thread* current,\n+bool ClassLoader::update_class_path_entry_list(JavaThread* current,\n@@ -1077,1 +1079,1 @@\n-ClassFileStream* ClassLoader::search_module_entries(Thread* current,\n+ClassFileStream* ClassLoader::search_module_entries(JavaThread* current,\n@@ -1133,1 +1135,0 @@\n-  assert(THREAD->is_Java_thread(), \"must be a JavaThread\");\n@@ -1255,1 +1256,1 @@\n-void ClassLoader::record_result(Thread* current, InstanceKlass* ik, const ClassFileStream* stream) {\n+void ClassLoader::record_result(JavaThread* current, InstanceKlass* ik, const ClassFileStream* stream) {\n@@ -1259,2 +1260,2 @@\n-  if (ik->is_hidden() || ik->is_unsafe_anonymous()) {\n-    \/\/ We do not archive hidden or unsafe anonymous classes.\n+  if (ik->is_hidden()) {\n+    \/\/ We do not archive hidden classes.\n@@ -1437,1 +1438,1 @@\n-void ClassLoader::initialize_shared_path(Thread* current) {\n+void ClassLoader::initialize_shared_path(JavaThread* current) {\n@@ -1510,1 +1511,1 @@\n-void ClassLoader::classLoader_init2(Thread* current) {\n+void ClassLoader::classLoader_init2(JavaThread* current) {\n@@ -1554,1 +1555,1 @@\n-  Thread* THREAD = Thread::current();\n+  JavaThread* current = JavaThread::current();\n@@ -1567,1 +1568,1 @@\n-    MutexLocker ml(THREAD, Module_lock);\n+    MutexLocker ml(current, Module_lock);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":31,"deletions":30,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -107,2 +107,1 @@\n-  Thread* THREAD = Thread::current();\n-  ResourceMark rm(THREAD);\n+  ResourceMark rm;\n@@ -142,2 +141,2 @@\n-  \/\/ An unsafe anonymous class loader data doesn't have anything to keep\n-  \/\/ it from being unloaded during parsing of the unsafe anonymous class.\n+  \/\/ A non-strong hidden class loader data doesn't have anything to keep\n+  \/\/ it from being unloaded during parsing of the non-strong hidden class.\n@@ -161,1 +160,1 @@\n-    \/\/ The holder is initialized later for non-strong hidden classes and unsafe anonymous classes,\n+    \/\/ The holder is initialized later for non-strong hidden classes,\n@@ -165,3 +164,2 @@\n-    \/\/ A ClassLoaderData created solely for a non-strong hidden class or unsafe anonymous class should\n-    \/\/ never have a ModuleEntryTable or PackageEntryTable created for it. The defining package\n-    \/\/ and module for an unsafe anonymous class will be found in its host class.\n+    \/\/ A ClassLoaderData created solely for a non-strong hidden class should never\n+    \/\/ have a ModuleEntryTable or PackageEntryTable created for it.\n@@ -301,1 +299,1 @@\n-\/\/ Weak hidden and unsafe anonymous classes have their own ClassLoaderData that is marked to keep alive\n+\/\/ Non-strong hidden classes have their own ClassLoaderData that is marked to keep alive\n@@ -303,2 +301,2 @@\n-\/\/ Due to the uniqueness that no other class shares the hidden or unsafe anonymous class' name or\n-\/\/ ClassLoaderData, no other non-GC thread has knowledge of the hidden or unsafe anonymous class while\n+\/\/ Due to the uniqueness that no other class shares the hidden class' name or\n+\/\/ ClassLoaderData, no other non-GC thread has knowledge of the hidden class while\n@@ -440,2 +438,2 @@\n-    \/\/ Just return if a non-strong hidden class or unsafe anonymous class is attempting to record a dependency\n-    \/\/ to itself.  (Note that every non-strong hidden class or unsafe anonymous class has its own unique class\n+    \/\/ Just return if a non-strong hidden class class is attempting to record a dependency\n+    \/\/ to itself.  (Note that every non-strong hidden class has its own unique class\n@@ -446,1 +444,1 @@\n-    \/\/ Hidden and unsafe anonymous class dependencies are through the mirror.\n+    \/\/ Hidden class dependencies are through the mirror.\n@@ -642,1 +640,1 @@\n-  bool alive = keep_alive()         \/\/ null class loader and incomplete non-strong hidden class or unsafe anonymous class.\n+  bool alive = keep_alive()         \/\/ null class loader and incomplete non-strong hidden class.\n@@ -712,6 +710,11 @@\n-  \/\/ Clear all the JNI handles for methods\n-  \/\/ These aren't deallocated and are going to look like a leak, but that's\n-  \/\/ needed because we can't really get rid of jmethodIDs because we don't\n-  \/\/ know when native code is going to stop using them.  The spec says that\n-  \/\/ they're \"invalid\" but existing programs likely rely on their being\n-  \/\/ NULL after class unloading.\n+  \/\/ Method::clear_jmethod_ids only sets the jmethod_ids to NULL without\n+  \/\/ releasing the memory for related JNIMethodBlocks and JNIMethodBlockNodes.\n+  \/\/ This is done intentionally because native code (e.g. JVMTI agent) holding\n+  \/\/ jmethod_ids may access them after the associated classes and class loader\n+  \/\/ are unloaded. The Java Native Interface Specification says \"method ID\n+  \/\/ does not prevent the VM from unloading the class from which the ID has\n+  \/\/ been derived. After the class is unloaded, the method or field ID becomes\n+  \/\/ invalid\". In real world usages, the native code may rely on jmethod_ids\n+  \/\/ being NULL after class unloading. Hence, it is unsafe to free the memory\n+  \/\/ from the VM side without knowing when native code is going to stop using\n+  \/\/ them.\n@@ -754,1 +757,1 @@\n-\/\/ loader data is for a non-strong hidden class or unsafe anonymous class then it may\n+\/\/ loader data is for a non-strong hidden class then it may\n@@ -764,1 +767,1 @@\n-\/\/ class loaders and not the CLD for a non-strong hidden class or unsafe anonymous class.\n+\/\/ class loaders and not the CLD for a non-strong hidden class.\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":26,"deletions":23,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-                                 \/\/ the CLDs lifecycle.  For example, a non-strong hidden class or an\n-                                 \/\/ unsafe anonymous class.  Arrays of these classes are also assigned\n+                                 \/\/ the CLDs lifecycle.  For example, a non-strong hidden class.\n+                                 \/\/ Arrays of these classes are also assigned\n@@ -128,1 +128,1 @@\n-                           \/\/ Used for non-strong hidden classes, unsafe anonymous classes and the\n+                           \/\/ Used for non-strong hidden classes and the\n@@ -130,2 +130,1 @@\n-                           \/\/ atomic since there is one unique CLD per non-strong hidden class\n-                           \/\/ or unsafe anonymous class.\n+                           \/\/ atomic since there is one unique CLD per non-strong hidden class.\n@@ -196,3 +195,0 @@\n-  \/\/ Allocate out of this class loader data\n-  MetaWord* allocate(size_t size);\n-\n@@ -242,1 +238,1 @@\n-  \/\/ (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)\n+  \/\/ (Note that the class loader data may be for a non-strong hidden class)\n@@ -246,1 +242,1 @@\n-  \/\/ (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)\n+  \/\/ (Note that the class loader data may be for a non-strong hidden class)\n@@ -250,1 +246,1 @@\n-  \/\/ (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)\n+  \/\/ (Note that the class loader data may be for a non-strong hidden class)\n@@ -271,2 +267,1 @@\n-  \/\/ Used to refcount a non-strong hidden class's or unsafe anonymous class's CLD in order to\n-  \/\/ indicate their aliveness.\n+  \/\/ Used to refcount a non-strong hidden class's s CLD in order to indicate their aliveness.\n@@ -331,0 +326,4 @@\n+  unsigned identity_hash() const {\n+    return (unsigned)((uintptr_t)this >> 3);\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -646,1 +646,1 @@\n-        Thread* THREAD = Thread::current();\n+        JavaThread* THREAD = Thread::current()->as_Java_thread();\n@@ -747,1 +747,1 @@\n-        Thread* THREAD = Thread::current();\n+        JavaThread* THREAD = Thread::current()->as_Java_thread();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -206,0 +206,1 @@\n+int java_lang_String::_flags_offset;\n@@ -213,0 +214,12 @@\n+bool java_lang_String::test_and_set_flag(oop java_string, uint8_t flag_mask) {\n+  uint8_t* addr = flags_addr(java_string);\n+  uint8_t value = Atomic::load(addr);\n+  while ((value & flag_mask) == 0) {\n+    uint8_t old_value = value;\n+    value |= flag_mask;\n+    value = Atomic::cmpxchg(addr, old_value, value);\n+    if (value == old_value) return false; \/\/ Flag bit changed from 0 to 1.\n+  }\n+  return true;                  \/\/ Flag bit is already 1.\n+}\n+\n@@ -226,0 +239,1 @@\n+  STRING_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n@@ -233,0 +247,1 @@\n+  STRING_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n@@ -420,1 +435,1 @@\n-    JavaThread* thread = THREAD->as_Java_thread();\n+    JavaThread* thread = THREAD;\n@@ -446,1 +461,1 @@\n-  { JavaThread* thread = THREAD->as_Java_thread();\n+  { JavaThread* thread = THREAD;\n@@ -526,0 +541,8 @@\n+  jchar* result = as_unicode_string_or_null(java_string, length);\n+  if (result == NULL) {\n+    THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), \"could not allocate Unicode string\");\n+  }\n+  return result;\n+}\n+\n+jchar* java_lang_String::as_unicode_string_or_null(oop java_string, int& length) {\n@@ -541,2 +564,0 @@\n-  } else {\n-    THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), \"could not allocate Unicode string\");\n@@ -1097,1 +1118,1 @@\n-    set_mirror_module_field(THREAD->as_Java_thread(), k, mirror, module);\n+    set_mirror_module_field(THREAD, k, mirror, module);\n@@ -1411,1 +1432,1 @@\n-  set_mirror_module_field(THREAD->as_Java_thread(), k, mirror, module);\n+  set_mirror_module_field(THREAD, k, mirror, module);\n@@ -2428,1 +2449,1 @@\n-  Thread* THREAD = Thread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -2493,1 +2514,1 @@\n-  JavaThread* thread = THREAD->as_Java_thread();\n+  JavaThread* thread = THREAD;\n@@ -2629,1 +2650,1 @@\n-  JavaThread* THREAD = JavaThread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -2656,1 +2677,1 @@\n-  JavaThread* THREAD = JavaThread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -2724,3 +2745,3 @@\n-  Thread* THREAD = Thread::current();\n-  objArrayHandle result(THREAD, objArrayOop(backtrace(throwable)));\n-  BacktraceIterator iter(result, THREAD);\n+  JavaThread* current = JavaThread::current();\n+  objArrayHandle result(current, objArrayOop(backtrace(throwable)));\n+  BacktraceIterator iter(result, current);\n@@ -2738,1 +2759,1 @@\n-  BacktraceElement bte = iter.next(THREAD);\n+  BacktraceElement bte = iter.next(current);\n@@ -3894,1 +3915,0 @@\n-int jdk_internal_invoke_NativeEntryPoint::_addr_offset;\n@@ -3903,1 +3923,0 @@\n-  macro(_addr_offset,            k, \"addr\",           long_signature, false); \\\n@@ -3926,4 +3945,0 @@\n-address jdk_internal_invoke_NativeEntryPoint::addr(oop entry) {\n-  return (address)entry->long_field(_addr_offset);\n-}\n-\n@@ -4087,1 +4102,1 @@\n-  \/\/ Add a reference to the loader (actually mirror because unsafe anonymous classes will not have\n+  \/\/ Add a reference to the loader (actually mirror because hidden classes may not have\n@@ -5033,1 +5048,1 @@\n-      \/\/ regular Java code. The implementation of java.lang.invoke uses generated anonymous classes\n+      \/\/ regular Java code. The implementation of java.lang.invoke uses generated hidden classes\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":37,"deletions":22,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -99,0 +99,5 @@\n+\/\/ The flags field is a collection of bits representing boolean values used\n+\/\/ internally by the VM.\n+#define STRING_INJECTED_FIELDS(macro) \\\n+  macro(java_lang_String, flags, byte_signature, false)\n+\n@@ -105,0 +110,1 @@\n+  static int _flags_offset;\n@@ -112,0 +118,13 @@\n+  \/\/ Bitmasks for values in the injected flags field.\n+  static const uint8_t _deduplication_forbidden_mask = 1 << 0;\n+  static const uint8_t _deduplication_requested_mask = 1 << 1;\n+\n+  static int flags_offset() { CHECK_INIT(_flags_offset); }\n+  \/\/ Return the address of the injected flags field.\n+  static inline uint8_t* flags_addr(oop java_string);\n+  \/\/ Test whether the designated bit of the injected flags field is set.\n+  static inline bool is_flag_set(oop java_string, uint8_t flag_mask);\n+  \/\/ Atomically test and set the designated bit of the injected flags field,\n+  \/\/ returning true if the bit was already set.\n+  static bool test_and_set_flag(oop java_string, uint8_t flag_mask);\n+\n@@ -140,0 +159,13 @@\n+  \/\/ Set the deduplication_forbidden flag true.  This flag is sticky; once\n+  \/\/ set it never gets cleared.  This is set when a String is interned in\n+  \/\/ the StringTable, to prevent string deduplication from changing the\n+  \/\/ String's value array.\n+  static inline void set_deduplication_forbidden(oop java_string);\n+\n+  \/\/ Test and set the deduplication_requested flag.  Returns the old value\n+  \/\/ of the flag.  This flag is sticky; once set it never gets cleared.\n+  \/\/ Some GCs may use this flag when deciding whether to request\n+  \/\/ deduplication of a String, to avoid multiple requests for the same\n+  \/\/ object.\n+  static inline bool test_and_set_deduplication_requested(oop java_string);\n+\n@@ -145,0 +177,2 @@\n+  static inline bool deduplication_forbidden(oop java_string);\n+  static inline bool deduplication_requested(oop java_string);\n@@ -160,0 +194,1 @@\n+  static jchar* as_unicode_string_or_null(oop java_string, int& length);\n@@ -1010,1 +1045,0 @@\n-  static int _addr_offset;  \/\/ type is jlong\n@@ -1024,1 +1058,0 @@\n-  static address    addr(oop entry);\n@@ -1040,1 +1073,0 @@\n-  static int addr_offset_in_bytes()            { return _addr_offset;            }\n@@ -1736,0 +1768,1 @@\n+  STRING_INJECTED_FIELDS(macro)             \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -673,1 +673,1 @@\n-  ObjectLocker ol(lockObject, THREAD->as_Java_thread());\n+  ObjectLocker ol(lockObject, THREAD);\n@@ -736,1 +736,1 @@\n-        loaded_class = handle_parallel_loading(THREAD->as_Java_thread(),\n+        loaded_class = handle_parallel_loading(THREAD,\n@@ -872,1 +872,1 @@\n-\/\/ Handles Lookup.defineClass hidden and unsafe_DefineAnonymousClass.\n+\/\/ Handles Lookup.defineClass hidden.\n@@ -882,3 +882,0 @@\n-  bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;\n-  \/\/ - for unsafe anonymous class: create a new CLD whith a class holder that uses\n-  \/\/                               the same class loader as the unsafe_anonymous_host.\n@@ -889,4 +886,2 @@\n-  assert (is_unsafe_anon_class || cl_info.is_hidden(), \"only used for hidden classes\");\n-  guarantee(!is_unsafe_anon_class || cl_info.unsafe_anonymous_host()->class_loader() == class_loader(),\n-              \"should be NULL or the same\");\n-  bool create_mirror_cld = is_unsafe_anon_class || !cl_info.is_strong_hidden();\n+  assert (cl_info.is_hidden(), \"only used for hidden classes\");\n+  bool create_mirror_cld = !cl_info.is_strong_hidden();\n@@ -906,4 +901,3 @@\n-  \/\/ Hidden classes that are not strong and unsafe anonymous classes must update\n-  \/\/ ClassLoaderData holder so that they can be unloaded when the mirror is no\n-  \/\/ longer referenced.\n-  if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {\n+  \/\/ Hidden classes that are not strong must update ClassLoaderData holder\n+  \/\/ so that they can be unloaded when the mirror is no longer referenced.\n+  if (!cl_info.is_strong_hidden()) {\n@@ -920,9 +914,0 @@\n-  \/\/ Rewrite and patch constant pool here.\n-  if (cl_info.cp_patches() != NULL) {\n-    k->constants()->patch_resolved_references(cl_info.cp_patches());\n-  }\n-\n-  \/\/ If it's anonymous, initialize it now, since nobody else will.\n-  if (is_unsafe_anon_class) {\n-    k->eager_initialize(CHECK_NULL);\n-  }\n@@ -933,1 +918,1 @@\n-    JvmtiExport::post_class_load(THREAD->as_Java_thread(), k);\n+    JvmtiExport::post_class_load(THREAD, k);\n@@ -939,3 +924,0 @@\n-  assert(is_unsafe_anon_class || NULL == cl_info.cp_patches(),\n-         \"cp_patches only found with unsafe_anonymous_host\");\n-\n@@ -965,1 +947,1 @@\n-  ObjectLocker ol(lockObject, THREAD->as_Java_thread());\n+  ObjectLocker ol(lockObject, THREAD);\n@@ -1019,2 +1001,1 @@\n-  bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;\n-  if (cl_info.is_hidden() || is_unsafe_anon_class) {\n+  if (cl_info.is_hidden()) {\n@@ -1029,13 +1010,0 @@\n-\/\/ Load a class for boot loader from the shared spaces. This also\n-\/\/ forces the superclass and all interfaces to be loaded.\n-InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,\n-                                                        PackageEntry* pkg_entry,\n-                                                        TRAPS) {\n-  assert(UseSharedSpaces, \"Sanity check\");\n-  InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);\n-  if (ik != NULL && ik->is_shared_boot_class()) {\n-    return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);\n-  }\n-  return NULL;\n-}\n-\n@@ -1255,1 +1223,1 @@\n-  \/\/ CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).\n+  \/\/ CFLH check is skipped for VM hidden classes (see KlassFactory::create_from_stream).\n@@ -1282,1 +1250,1 @@\n-    ObjectLocker ol(lockObject, THREAD->as_Java_thread());\n+    ObjectLocker ol(lockObject, THREAD);\n@@ -1387,1 +1355,5 @@\n-      k = load_shared_boot_class(class_name, pkg_entry, THREAD);\n+      InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);\n+      if (ik != NULL && ik->is_shared_boot_class() && !ik->shared_loading_failed()) {\n+        SharedClassLoadingMark slm(THREAD, ik);\n+        k = load_shared_class(ik, class_loader, Handle(), NULL,  pkg_entry, CHECK_NULL);\n+      }\n@@ -1399,0 +1371,1 @@\n+      CDS_ONLY(SharedClassLoadingMark slm(THREAD, k);)\n@@ -1406,1 +1379,1 @@\n-    JavaThread* jt = THREAD->as_Java_thread();\n+    JavaThread* jt = THREAD;\n@@ -1483,1 +1456,1 @@\n-      JvmtiExport::post_class_load(THREAD->as_Java_thread(), loaded_class);\n+      JvmtiExport::post_class_load(THREAD, loaded_class);\n@@ -1509,1 +1482,1 @@\n-    assert(ObjectSynchronizer::current_thread_holds_lock(THREAD->as_Java_thread(),\n+    assert(ObjectSynchronizer::current_thread_holds_lock(THREAD,\n@@ -1556,1 +1529,1 @@\n-    JvmtiExport::post_class_load(THREAD->as_Java_thread(), k);\n+    JvmtiExport::post_class_load(THREAD, k);\n@@ -1697,1 +1670,0 @@\n-\/\/ Note: anonymous classes are not in the SD.\n@@ -2001,2 +1973,5 @@\n-    if (entry != NULL) {\n-      assert(entry->nest_host_error() == NULL, \"Nest host error message already set!\");\n+    if (entry != NULL && entry->nest_host_error() == NULL) {\n+      \/\/ An existing entry means we had a true resolution failure (LinkageError) with our nest host, but we\n+      \/\/ still want to add the error message for the higher-level access checks to report. We should\n+      \/\/ only reach here under the same error condition, so we can ignore the potential race with setting\n+      \/\/ the message. If we see it is already set then we can ignore it.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":28,"deletions":53,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -122,2 +122,2 @@\n-  \/\/ Parse the stream to create an unsafe anonymous or hidden class.\n-  \/\/ Used by Unsafe_DefineAnonymousClass and jvm_lookup_define_class.\n+  \/\/ Parse the stream to create a hidden class.\n+  \/\/ Used by jvm_lookup_define_class.\n@@ -386,3 +386,0 @@\n-  static InstanceKlass* load_shared_boot_class(Symbol* class_name,\n-                                               PackageEntry* pkg_entry,\n-                                               TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-  JavaThread* jt = THREAD->as_Java_thread();\n+  JavaThread* jt = THREAD;\n@@ -305,1 +305,1 @@\n-  JavaThread* thread = THREAD->as_Java_thread();\n+  JavaThread* thread = THREAD;\n@@ -1939,0 +1939,6 @@\n+      \/\/ If the catch type is Throwable pre-resolve it now as the assignable check won't\n+      \/\/ do that, and we need to avoid a runtime resolution in case we are trying to\n+      \/\/ catch OutOfMemoryError.\n+      if (cp->klass_name_at(catch_type_index) == vmSymbols::java_lang_Throwable()) {\n+        cp->klass_at(catch_type_index, CHECK);\n+      }\n@@ -2208,3 +2214,1 @@\n-  if (tag.is_string() && cp->is_pseudo_string_at(index)) {\n-    current_frame->push_stack(object_type(), CHECK_VERIFY(this));\n-  } else if (tag.is_string()) {\n+  if (tag.is_string()) {\n@@ -2948,15 +2952,2 @@\n-    if (!current_class()->is_unsafe_anonymous()) {\n-      subtype = ref_class_type.is_assignable_from(\n-                 current_type(), this, false, CHECK_VERIFY(this));\n-    } else {\n-      InstanceKlass* unsafe_host = current_class()->unsafe_anonymous_host();\n-      VerificationType unsafe_anonymous_host_type = reference_or_inline_type(unsafe_host);\n-      subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));\n-\n-      \/\/ If invokespecial of IMR, need to recheck for same or\n-      \/\/ direct interface relative to the host class\n-      have_imr_indirect = (have_imr_indirect &&\n-                           !is_same_or_direct_interface(\n-                             unsafe_host,\n-                             unsafe_anonymous_host_type, ref_class_type));\n-    }\n+    subtype = ref_class_type.is_assignable_from(\n+               current_type(), this, false, CHECK_VERIFY(this));\n@@ -2998,19 +2989,1 @@\n-        if (!current_class()->is_unsafe_anonymous()) {\n-          current_frame->pop_stack(current_type(), CHECK_VERIFY(this));\n-        } else {\n-          \/\/ anonymous class invokespecial calls: check if the\n-          \/\/ objectref is a subtype of the unsafe_anonymous_host of the current class\n-          \/\/ to allow an anonymous class to reference methods in the unsafe_anonymous_host\n-          VerificationType top = current_frame->pop_stack(CHECK_VERIFY(this));\n-\n-          InstanceKlass* unsafe_host = current_class()->unsafe_anonymous_host();\n-          VerificationType host_type = reference_or_inline_type(unsafe_host);\n-          bool subtype = host_type.is_assignable_from(top, this, false, CHECK_VERIFY(this));\n-          if (!subtype) {\n-            verify_error( ErrorContext::bad_type(current_frame->offset(),\n-              current_frame->stack_top_ctx(),\n-              TypeOrigin::implicit(top)),\n-              \"Bad type on operand stack\");\n-            return;\n-          }\n-        }\n+        current_frame->pop_stack(current_type(), CHECK_VERIFY(this));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":12,"deletions":39,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+  case vmIntrinsics::_updateBytesAdler32:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -938,1 +938,5 @@\n-                                                                                                                               \\\n+  do_intrinsic(_VectorMaskOp, jdk_internal_vm_vector_VectorSupport, vector_mask_oper_name, vector_mask_oper_sig, F_S)                          \\\n+    do_signature(vector_mask_oper_sig, \"(ILjava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;\"                                               \\\n+                                        \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMaskOp;)I\")                                               \\\n+    do_name(vector_mask_oper_name, \"maskReductionCoerced\")                                                                                     \\\n+                                                                                                                                               \\\n@@ -1047,1 +1051,1 @@\n-  LAST_COMPILER_INLINE = _VectorScatterOp,\n+  LAST_COMPILER_INLINE = _VectorMaskOp,\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-  \/* Panama Support *\/                                                                                          \\\n+  \/* Foreign API Support *\/                                                                                          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -741,0 +741,27 @@\n+\n+\/\/ Implementation of OptimizedEntryBlob\n+\n+OptimizedEntryBlob::OptimizedEntryBlob(const char* name, int size, CodeBuffer* cb, intptr_t exception_handler_offset,\n+                     jobject receiver, ByteSize jfa_sp_offset) :\n+  BufferBlob(name, sizeof(OptimizedEntryBlob), size, cb),\n+  _exception_handler_offset(exception_handler_offset),\n+  _receiver(receiver),\n+  _jfa_sp_offset(jfa_sp_offset) {\n+  CodeCache::commit(this);\n+}\n+\n+OptimizedEntryBlob* OptimizedEntryBlob::create(const char* name, CodeBuffer* cb, intptr_t exception_handler_offset,\n+                             jobject receiver, ByteSize jfa_sp_offset) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  OptimizedEntryBlob* blob = nullptr;\n+  unsigned int size = CodeBlob::allocation_size(cb, sizeof(OptimizedEntryBlob));\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) OptimizedEntryBlob(name, size, cb, exception_handler_offset, receiver, jfa_sp_offset);\n+  }\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+\n+  return blob;\n+}\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+\/\/    OptimizedEntryBlob : Used for upcalls from native code\n@@ -78,0 +79,2 @@\n+class OptimizedEntryBlob; \/\/ for as_optimized_entry_blob()\n+class JavaFrameAnchor; \/\/ for EntryBlob::jfa_for_frame\n@@ -140,0 +143,1 @@\n+  virtual bool is_optimized_entry_blob() const                  { return false; }\n@@ -153,0 +157,1 @@\n+  OptimizedEntryBlob* as_optimized_entry_blob() const             { assert(is_optimized_entry_blob(), \"must be entry blob\"); return (OptimizedEntryBlob*) this; }\n@@ -384,0 +389,1 @@\n+  friend class OptimizedEntryBlob;\n@@ -752,0 +758,29 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\n+\/\/ For optimized upcall stubs\n+class OptimizedEntryBlob: public BufferBlob {\n+ private:\n+  intptr_t _exception_handler_offset;\n+  jobject _receiver;\n+  ByteSize _jfa_sp_offset;\n+\n+  OptimizedEntryBlob(const char* name, int size, CodeBuffer* cb, intptr_t exception_handler_offset,\n+            jobject receiver, ByteSize jfa_sp_offset);\n+\n+ public:\n+  \/\/ Creation\n+  static OptimizedEntryBlob* create(const char* name, CodeBuffer* cb,\n+                           intptr_t exception_handler_offset, jobject receiver,\n+                           ByteSize jfa_sp_offset);\n+\n+  address exception_handler() { return code_begin() + _exception_handler_offset; }\n+  jobject receiver() { return _receiver; }\n+  ByteSize jfa_sp_offset() const { return _jfa_sp_offset; }\n+\n+  \/\/ defined in frame_ARCH.cpp\n+  JavaFrameAnchor* jfa_for_frame(const frame& frame) const;\n+\n+  \/\/ Typing\n+  virtual bool is_optimized_entry_blob() const override { return true; }\n+};\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -519,1 +519,1 @@\n-  if (method_code != NULL && method_code->is_in_use()) {\n+  if (method_code != NULL && method_code->is_in_use() && !method_code->is_unloading()) {\n@@ -648,1 +648,1 @@\n-  if (m_code != NULL && m_code->is_in_use()) {\n+  if (m_code != NULL && m_code->is_in_use() && !m_code->is_unloading()) {\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1784,1 +1784,0 @@\n-  uint8_t state_unloading_cycle = IsUnloadingState::unloading_cycle(state);\n@@ -1788,0 +1787,1 @@\n+  uint8_t state_unloading_cycle = IsUnloadingState::unloading_cycle(state);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -630,1 +630,1 @@\n-void CompileBroker::compilation_init_phase1(Thread* THREAD) {\n+void CompileBroker::compilation_init_phase1(JavaThread* THREAD) {\n@@ -876,1 +876,1 @@\n-JavaThread* CompileBroker::make_thread(ThreadType type, jobject thread_handle, CompileQueue* queue, AbstractCompiler* comp, Thread* THREAD) {\n+JavaThread* CompileBroker::make_thread(ThreadType type, jobject thread_handle, CompileQueue* queue, AbstractCompiler* comp, JavaThread* THREAD) {\n@@ -942,1 +942,1 @@\n-        new_thread->as_CompilerThread()->set_compiler(comp);\n+        CompilerThread::cast(new_thread)->set_compiler(comp);\n@@ -1063,1 +1063,1 @@\n-void CompileBroker::possibly_add_compiler_threads(Thread* THREAD) {\n+void CompileBroker::possibly_add_compiler_threads(JavaThread* THREAD) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"classfile\/vmClasses.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -79,3 +79,1 @@\n-    _string_klass_or_null(G1StringDedup::is_enabled()\n-                          ? vmClasses::String_klass()\n-                          : nullptr),\n+    _string_dedup_requests(),\n@@ -86,4 +84,0 @@\n-  \/\/ Verify klass comparison with _string_klass_or_null is sufficient\n-  \/\/ to determine whether dedup is enabled and the object is a String.\n-  assert(vmClasses::String_klass()->is_final(), \"precondition\");\n-\n@@ -521,14 +515,8 @@\n-    \/\/ StringDedup::is_enabled() and java_lang_String::is_instance_inline\n-    \/\/ test of the obj, combined into a single comparison, using the klass\n-    \/\/ already in hand and avoiding the null check in is_instance.\n-    if (klass == _string_klass_or_null) {\n-      const bool is_from_young = region_attr.is_young();\n-      const bool is_to_young = dest_attr.is_young();\n-      assert(is_from_young == from_region->is_young(),\n-             \"sanity\");\n-      assert(is_to_young == _g1h->heap_region_containing(obj)->is_young(),\n-             \"sanity\");\n-      G1StringDedup::enqueue_from_evacuation(is_from_young,\n-                                             is_to_young,\n-                                             _worker_id,\n-                                             obj);\n+    \/\/ Check for deduplicating young Strings.\n+    if (G1StringDedup::is_candidate_from_evacuation(klass,\n+                                                    region_attr,\n+                                                    dest_attr,\n+                                                    age)) {\n+      \/\/ Record old; request adds a new weak reference, which reference\n+      \/\/ processing expects to refer to a from-space object.\n+      _string_dedup_requests.add(old);\n@@ -621,2 +609,1 @@\n-    if (r->set_evacuation_failed()) {\n-      _g1h->notify_region_failed_evacuation();\n+    if (_g1h->notify_region_failed_evacuation(r->hrm_index())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2000,1 +2000,1 @@\n-static void steal_marking_work(TaskTerminator& terminator, uint worker_id) {\n+void steal_marking_work(TaskTerminator& terminator, uint worker_id) {\n@@ -2021,1 +2021,0 @@\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n@@ -2060,4 +2059,1 @@\n-class PCRefProcTask : public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  ProcessTask& _task;\n-  uint _ergo_workers;\n+class ParallelCompactRefProcProxyTask : public RefProcProxyTask {\n@@ -2067,10 +2063,3 @@\n-  PCRefProcTask(ProcessTask& task, uint ergo_workers) :\n-      AbstractGangTask(\"PCRefProcTask\"),\n-      _task(task),\n-      _ergo_workers(ergo_workers),\n-      _terminator(_ergo_workers, ParCompactionManager::oop_task_queues()) {\n-  }\n-\n-  virtual void work(uint worker_id) {\n-    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-    assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n+  ParallelCompactRefProcProxyTask(uint max_workers)\n+    : RefProcProxyTask(\"ParallelCompactRefProcProxyTask\", max_workers),\n+      _terminator(_max_workers, ParCompactionManager::oop_task_queues()) {}\n@@ -2078,8 +2067,6 @@\n-    ParCompactionManager* cm =\n-      ParCompactionManager::gc_thread_compaction_manager(worker_id);\n-    PCMarkAndPushClosure mark_and_push_closure(cm);\n-    ParCompactionManager::FollowStackClosure follow_stack_closure(cm);\n-    _task.work(worker_id, *PSParallelCompact::is_alive_closure(),\n-               mark_and_push_closure, follow_stack_closure);\n-\n-    steal_marking_work(_terminator, worker_id);\n+  void work(uint worker_id) override {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    ParCompactionManager* cm = (_tm == RefProcThreadModel::Single) ? ParCompactionManager::get_vmthread_cm() : ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+    PCMarkAndPushClosure keep_alive(cm);\n+    ParCompactionManager::FollowStackClosure complete_gc(cm, (_tm == RefProcThreadModel::Single) ? nullptr : &_terminator, worker_id);\n+    _rp_task->rp_work(worker_id, PSParallelCompact::is_alive_closure(), &keep_alive, &complete_gc);\n@@ -2087,9 +2074,2 @@\n-};\n-\n-class RefProcTaskExecutor: public AbstractRefProcTaskExecutor {\n-  void execute(ProcessTask& process_task, uint ergo_workers) {\n-    assert(ParallelScavengeHeap::heap()->workers().active_workers() == ergo_workers,\n-           \"Ergonomically chosen workers (%u) must be equal to active workers (%u)\",\n-           ergo_workers, ParallelScavengeHeap::heap()->workers().active_workers());\n-    PCRefProcTask task(process_task, ergo_workers);\n-    ParallelScavengeHeap::heap()->workers().run_task(&task);\n+  void prepare_run_task_hook() override {\n+    _terminator.reset_for_reuse(_queue_count);\n@@ -2106,1 +2086,0 @@\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n@@ -2109,3 +2088,0 @@\n-  PCMarkAndPushClosure mark_and_push_closure(cm);\n-  ParCompactionManager::FollowStackClosure follow_stack_closure(cm);\n-\n@@ -2129,12 +2105,3 @@\n-    if (ref_processor()->processing_is_mt()) {\n-      ref_processor()->set_active_mt_degree(active_gc_threads);\n-\n-      RefProcTaskExecutor task_executor;\n-      stats = ref_processor()->process_discovered_references(\n-        is_alive_closure(), &mark_and_push_closure, &follow_stack_closure,\n-        &task_executor, &pt);\n-    } else {\n-      stats = ref_processor()->process_discovered_references(\n-        is_alive_closure(), &mark_and_push_closure, &follow_stack_closure, NULL,\n-        &pt);\n-    }\n+    ref_processor()->set_active_mt_degree(active_gc_threads);\n+    ParallelCompactRefProcProxyTask task(ref_processor()->max_num_queues());\n+    stats = ref_processor()->process_discovered_references(task, pt);\n@@ -2151,1 +2118,4 @@\n-    WeakProcessor::weak_oops_do(is_alive_closure(), &do_nothing_cl);\n+    WeakProcessor::weak_oops_do(&ParallelScavengeHeap::heap()->workers(),\n+                                is_alive_closure(),\n+                                &do_nothing_cl,\n+                                1);\n@@ -2527,1 +2497,0 @@\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":20,"deletions":51,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-#include \"classfile\/classLoaderData.inline.hpp\"\n+\n+#include \"classfile\/classLoaderData.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+\n@@ -55,1 +56,1 @@\n-      throw_array_null_pointer_store_exception(src_obj, dst_obj, Thread::current());\n+      throw_array_null_pointer_store_exception(src_obj, dst_obj, Thread::current()->as_Java_thread());\n@@ -60,1 +61,1 @@\n-      throw_array_store_exception(src_obj, dst_obj, Thread::current());\n+      throw_array_store_exception(src_obj, dst_obj, Thread::current()->as_Java_thread());\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-  virtual bool array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const { return false; }\n+  virtual bool array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, bool is_clone_instance, ArrayCopyPhase phase) const { return false; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-bool CardTableBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {\n+bool CardTableBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, bool is_clone_instance, ArrayCopyPhase phase) const {\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  virtual bool array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const;\n+  virtual bool array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, bool is_clone_instance, ArrayCopyPhase phase) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -485,3 +485,0 @@\n-  \/\/ Deduplicate the string, iff the GC supports string deduplication.\n-  virtual void deduplicate_string(oop str);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  Thread*             _thread;\n+  JavaThread*         _thread;\n@@ -58,1 +58,0 @@\n-  void notify_allocation_jvmti_allocation_event();\n@@ -73,1 +72,1 @@\n-      _thread(Thread::current()),\n+      _thread(JavaThread::current()),\n@@ -99,1 +98,1 @@\n-  PreserveObj(Thread* thread, oop* obj_ptr)\n+  PreserveObj(JavaThread* thread, oop* obj_ptr)\n@@ -117,1 +116,1 @@\n-  Thread* THREAD = _thread;\n+  JavaThread* THREAD = _thread; \/\/ For exception macros.\n@@ -125,1 +124,1 @@\n-  if (!THREAD->in_retryable_allocation()) {\n+  if (!_thread->in_retryable_allocation()) {\n@@ -146,1 +145,1 @@\n-  Thread* THREAD = _thread;\n+  JavaThread* THREAD = _thread; \/\/ For exception macros.\n@@ -176,1 +175,0 @@\n-  assert(_thread->is_Java_thread(), \"non Java threads shouldn't allocate on the Heap\");\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-#include \"gc\/shared\/barrierSet.hpp\"\n+\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -132,1 +133,1 @@\n-        throw_array_null_pointer_store_exception(src_obj, dst_obj, Thread::current());\n+        throw_array_null_pointer_store_exception(src_obj, dst_obj, Thread::current()->as_Java_thread());\n@@ -138,1 +139,1 @@\n-        throw_array_store_exception(src_obj, dst_obj, Thread::current());\n+        throw_array_store_exception(src_obj, dst_obj, Thread::current()->as_Java_thread());\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -766,1 +766,1 @@\n-bool ShenandoahBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const {\n+bool ShenandoahBarrierSetC2::array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, bool is_clone_instance, ArrayCopyPhase phase) const {\n@@ -1071,6 +1071,1 @@\n-    PhaseIterGVN* igvn = phase->is_IterGVN();\n-      if (igvn != NULL) {\n-        n->set_req_X(1, in1, igvn);\n-      } else {\n-        n->set_req(1, in1);\n-      }\n+      n->set_req_X(1, in1, phase);\n@@ -1082,5 +1077,1 @@\n-      if (igvn != NULL) {\n-        n->set_req_X(2, in2, igvn);\n-      } else {\n-        n->set_req(2, in2);\n-      }\n+      n->set_req_X(2, in2, phase);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  virtual bool array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, ArrayCopyPhase phase) const;\n+  virtual bool array_copy_requires_gc_barriers(bool tightly_coupled_alloc, BasicType type, bool is_clone, bool is_clone_instance, ArrayCopyPhase phase) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -695,1 +695,1 @@\n-    assert(alias = Compile::AliasIdxRaw, \"following raw memory can't lead to a barrier\");\n+    assert(alias == Compile::AliasIdxRaw, \"following raw memory can't lead to a barrier\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n+\n@@ -30,1 +32,0 @@\n-#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n@@ -103,0 +104,3 @@\n+  if (obj == NULL) {\n+    return NULL;\n+  }\n@@ -105,1 +109,1 @@\n-  if (HasDecorator<decorators, ON_PHANTOM_OOP_REF>::value && obj != NULL &&\n+  if (HasDecorator<decorators, ON_PHANTOM_OOP_REF>::value &&\n@@ -113,1 +117,1 @@\n-      obj != NULL && _heap->is_concurrent_weak_root_in_progress() &&\n+      _heap->is_concurrent_weak_root_in_progress() &&\n@@ -120,1 +124,1 @@\n-  if (HasDecorator<decorators, AS_NO_KEEPALIVE>::value && obj != NULL &&\n+  if (HasDecorator<decorators, AS_NO_KEEPALIVE>::value &&\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -227,1 +227,9 @@\n-                                                    bool is_clone, ArrayCopyPhase phase) const {\n+                                                    bool is_clone, bool is_clone_instance,\n+                                                    ArrayCopyPhase phase) const {\n+  if (phase == ArrayCopyPhase::Parsing) {\n+    return false;\n+  }\n+  if (phase == ArrayCopyPhase::Optimization) {\n+    return is_clone_instance;\n+  }\n+  \/\/ else ArrayCopyPhase::Expansion\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+  static const bool GCThread    = true;\n+  static const bool AnyThread   = false;\n+\n@@ -59,1 +62,1 @@\n-  template <bool follow, bool finalizable, bool publish> static uintptr_t mark(uintptr_t addr);\n+  template <bool gc_thread, bool follow, bool finalizable, bool publish> static uintptr_t mark(uintptr_t addr);\n@@ -73,0 +76,1 @@\n+  static uintptr_t keep_alive_barrier_on_oop_slow_path(uintptr_t addr);\n@@ -108,0 +112,1 @@\n+  static void keep_alive_barrier_on_oop(oop o);\n@@ -111,1 +116,0 @@\n-  static void keep_alive_barrier_on_oop(oop o);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"gc\/z\/zBarrierSet.hpp\"\n+\n@@ -29,1 +31,0 @@\n-#include \"gc\/z\/zBarrierSet.hpp\"\n@@ -197,1 +198,1 @@\n-      throw_array_null_pointer_store_exception(src_obj, dst_obj, Thread::current());\n+      throw_array_null_pointer_store_exception(src_obj, dst_obj, Thread::current()->as_Java_thread());\n@@ -203,1 +204,1 @@\n-      throw_array_store_exception(src_obj, dst_obj, Thread::current());\n+      throw_array_store_exception(src_obj, dst_obj, Thread::current()->as_Java_thread());\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -552,1 +552,1 @@\n-      JavaThread* THREAD = current; \/\/ for exception macros\n+      JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -896,1 +896,1 @@\n-    Thread* THREAD = current;  \/\/ for exception macros\n+    JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -1075,1 +1075,1 @@\n-    Thread* THREAD = current;  \/\/ for exception macros\n+    JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -1115,2 +1115,2 @@\n-  \/\/ Get sender or sender's unsafe_anonymous_host, and only set cpCache entry to resolved if\n-  \/\/ it is not an interface.  The receiver for invokespecial calls within interface\n+  \/\/ Get sender and only set cpCache entry to resolved if it is not an\n+  \/\/ interface.  The receiver for invokespecial calls within interface\n@@ -1119,1 +1119,0 @@\n-  sender = sender->is_unsafe_anonymous() ? sender->unsafe_anonymous_host() : sender;\n@@ -1156,1 +1155,1 @@\n-    Thread* THREAD = current;  \/\/ for exception macros\n+    JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -1177,1 +1176,1 @@\n-    Thread* THREAD = current;  \/\/ for exception macros\n+    JavaThread* THREAD = current; \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1172,4 +1172,1 @@\n-    InstanceKlass* ck = InstanceKlass::cast(current_klass);\n-    InstanceKlass *klass_to_check = !ck->is_unsafe_anonymous() ?\n-                                    ck :\n-                                    ck->unsafe_anonymous_host();\n+    InstanceKlass* klass_to_check = InstanceKlass::cast(current_klass);\n@@ -1265,1 +1262,0 @@\n-    sender = sender->is_unsafe_anonymous() ? sender->unsafe_anonymous_host() : sender;\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -574,1 +574,1 @@\n-    assert(MetaspaceShared::is_old_class(klass), \"only shared old classes aren't rewritten\");\n+    assert(klass->can_be_verified_at_dumptime(), \"only shared old classes aren't rewritten\");\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/compilerThread.hpp\"\n@@ -439,1 +440,1 @@\n-  CompilerThread* compilerThread = thread->is_Compiler_thread() ? thread->as_CompilerThread() : NULL;\n+  CompilerThread* compilerThread = thread->is_Compiler_thread() ? CompilerThread::cast(thread) : NULL;\n@@ -482,0 +483,1 @@\n+    nmethodLocker& nmethod_handle,\n@@ -539,2 +541,1 @@\n-    nmethod* nm = NULL;\n-    result = runtime()->register_method(jvmci_env(), method, nm, entry_bci, &_offsets, _orig_pc_offset, &buffer,\n+    result = runtime()->register_method(jvmci_env(), method, nmethod_handle, entry_bci, &_offsets, _orig_pc_offset, &buffer,\n@@ -545,6 +546,9 @@\n-    cb = nm->as_codeblob_or_null();\n-    if (nm != NULL && compile_state == NULL) {\n-      \/\/ This compile didn't come through the CompileBroker so perform the printing here\n-      DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler);\n-      nm->maybe_print_nmethod(directive);\n-      DirectivesStack::release(directive);\n+    if (result == JVMCI::ok) {\n+      nmethod* nm = nmethod_handle.code()->as_nmethod_or_null();\n+      cb = nm;\n+      if (compile_state == NULL) {\n+        \/\/ This compile didn't come through the CompileBroker so perform the printing here\n+        DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler);\n+        nm->maybe_print_nmethod(directive);\n+        DirectivesStack::release(directive);\n+      }\n@@ -807,1 +811,1 @@\n-    JavaThread* THREAD = JavaThread::current();\n+    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  assert(THREAD->is_Java_thread(), \"must be\");\n@@ -103,1 +102,1 @@\n-      THREAD->as_Java_thread()->sleep(100);\n+      THREAD->sleep(100);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-  Thread* THREAD = thread;                                        \\\n+  JavaThread* THREAD = thread;                                        \\\n@@ -830,1 +830,5 @@\n-  return Dependencies::find_finalizable_subclass(klass) != NULL;\n+  if (!klass->is_instance_klass()) {\n+    return false;\n+  }\n+  InstanceKlass* iklass = InstanceKlass::cast(klass);\n+  return Dependencies::find_finalizable_subclass(iklass) != NULL;\n@@ -880,0 +884,1 @@\n+  nmethodLocker nmethod_handle;\n@@ -885,0 +890,1 @@\n+      nmethod_handle,\n@@ -1572,8 +1578,0 @@\n-C2V_VMENTRY_NULL(jobject, getHostClass, (JNIEnv* env, jobject, jobject jvmci_type))\n-  InstanceKlass* k = InstanceKlass::cast(JVMCIENV->asKlass(jvmci_type));\n-  InstanceKlass* host = k->unsafe_anonymous_host();\n-  JVMCIKlassHandle handle(THREAD, host);\n-  JVMCIObject result = JVMCIENV->get_jvmci_type(handle, JVMCI_CHECK_NULL);\n-  return JVMCIENV->get_jobject(result);\n-C2V_END\n-\n@@ -2676,1 +2674,0 @@\n-  {CC \"getHostClass\",                                 CC \"(\" HS_RESOLVED_KLASS \")\" HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+  nonstatic_field(JavaThread,                  _stack_overflow_state._stack_overflow_limit,   address)                               \\\n@@ -344,1 +345,0 @@\n-  nonstatic_field(ThreadLocalAllocBuffer,   _fast_refill_waste,                               unsigned)                              \\\n@@ -589,1 +589,0 @@\n-  declare_constant(InstanceKlass::_misc_is_unsafe_anonymous)              \\\n@@ -596,4 +595,7 @@\n-  declare_preprocessor_constant(\"JVMCI::ok\",                   JVMCI::ok)                      \\\n-  declare_preprocessor_constant(\"JVMCI::dependencies_failed\",  JVMCI::dependencies_failed)     \\\n-  declare_preprocessor_constant(\"JVMCI::cache_full\",           JVMCI::cache_full)              \\\n-  declare_preprocessor_constant(\"JVMCI::code_too_large\",       JVMCI::code_too_large)          \\\n+  declare_preprocessor_constant(\"JVMCI::ok\",                      JVMCI::ok)                      \\\n+  declare_preprocessor_constant(\"JVMCI::dependencies_failed\",     JVMCI::dependencies_failed)     \\\n+  declare_preprocessor_constant(\"JVMCI::cache_full\",              JVMCI::cache_full)              \\\n+  declare_preprocessor_constant(\"JVMCI::code_too_large\",          JVMCI::code_too_large)          \\\n+  declare_preprocessor_constant(\"JVMCI::nmethod_reclaimed\",       JVMCI::nmethod_reclaimed)       \\\n+  declare_preprocessor_constant(\"JVMCI::first_permanent_bailout\", JVMCI::first_permanent_bailout) \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  DEBUG_ONLY(LOG_TAG(foreign)) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class JavaThread;\n@@ -146,0 +147,1 @@\n+  f(mtStringDedup,    \"String Deduplication\")                                        \\\n@@ -265,0 +267,15 @@\n+  \/\/ There are functions that all subtypes of MetaspaceObj are expected\n+  \/\/ to implement, so that templates which are defined for this class hierarchy\n+  \/\/ can work uniformly. Within the sub-hierarchy of Metadata, these are virtuals.\n+  \/\/ Elsewhere in the hierarchy of MetaspaceObj, type(), size(), and\/or on_stack()\n+  \/\/ can be static if constant.\n+  \/\/\n+  \/\/ The following functions are required by MetaspaceClosure:\n+  \/\/   void metaspace_pointers_do(MetaspaceClosure* it) { <walk my refs> }\n+  \/\/   int size() const { return align_up(sizeof(<This>), wordSize) \/ wordSize; }\n+  \/\/   MetaspaceObj::Type type() const { return <This>Type; }\n+  \/\/\n+  \/\/ The following functions are required by MetadataFactory::free_metadata():\n+  \/\/   bool on_stack() { return false; }\n+  \/\/   void deallocate_contents(ClassLoaderData* loader_data);\n+\n@@ -347,1 +364,1 @@\n-                     Type type, Thread* thread) throw();\n+                     Type type, JavaThread* thread) throw();\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-#include \"classfile\/classLoaderData.hpp\"\n+\n+#include \"classfile\/classLoaderData.hpp\"\n@@ -210,0 +211,2 @@\n+  typedef void (*FunctionType)(OopClosureType*, oop, Klass*);\n+\n@@ -246,1 +249,1 @@\n-    void (*_function[KLASS_ID_COUNT])(OopClosureType*, oop, Klass*);\n+    FunctionType _function[KLASS_ID_COUNT];\n@@ -262,1 +265,1 @@\n-  static void (*function(Klass* klass))(OopClosureType*, oop, Klass*) {\n+  static FunctionType function(Klass* klass) {\n@@ -274,0 +277,2 @@\n+  typedef void (*FunctionType)(OopClosureType*, oop, Klass*, MemRegion);\n+\n@@ -307,1 +312,1 @@\n-    void (*_function[KLASS_ID_COUNT])(OopClosureType*, oop, Klass*, MemRegion);\n+    FunctionType _function[KLASS_ID_COUNT];\n@@ -323,1 +328,1 @@\n-  static void (*function(Klass* klass))(OopClosureType*, oop, Klass*, MemRegion) {\n+  static FunctionType function(Klass* klass) {\n@@ -335,0 +340,2 @@\n+  typedef void (*FunctionType)(OopClosureType*, oop, Klass*);\n+\n@@ -368,1 +375,1 @@\n-    void (*_function[KLASS_ID_COUNT])(OopClosureType*, oop, Klass*);\n+    FunctionType _function[KLASS_ID_COUNT];\n@@ -384,1 +391,1 @@\n-  static void (*function(Klass* klass))(OopClosureType*, oop, Klass*) {\n+  static FunctionType function(Klass* klass) {\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -553,12 +554,0 @@\n-static void reinitialize_vtable_of(Klass* ko) {\n-  \/\/ init vtable of k and all subclasses\n-  ko->vtable().initialize_vtable();\n-  if (ko->is_instance_klass()) {\n-    for (Klass* sk = ko->subklass();\n-         sk != NULL;\n-         sk = sk->next_sibling()) {\n-      reinitialize_vtable_of(sk);\n-    }\n-  }\n-}\n-\n@@ -569,2 +558,4 @@\n-  Klass* ok = vmClasses::Object_klass();\n-  reinitialize_vtable_of(ok);\n+  for (ClassHierarchyIterator iter(vmClasses::Object_klass()); !iter.done(); iter.next()) {\n+    Klass* sub = iter.klass();\n+    sub->vtable().initialize_vtable();\n+  }\n@@ -665,2 +656,2 @@\n-    Thread* THREAD = Thread::current();\n-    Handle default_err_h(THREAD, default_err);\n+    JavaThread* current = JavaThread::current();\n+    Handle default_err_h(current, default_err);\n@@ -669,1 +660,1 @@\n-    Handle exc(THREAD, preallocated_out_of_memory_errors()->obj_at(next));\n+    Handle exc(current, preallocated_out_of_memory_errors()->obj_at(next));\n@@ -790,1 +781,0 @@\n-  CompressedClassSpaceCounters::initialize_performance_counters();\n@@ -1118,0 +1108,2 @@\n+    } else if (strcmp(token, \"stringdedup\") == 0) {\n+      verify_flags |= Verify_StringDedup;\n@@ -1170,1 +1162,0 @@\n-  {\n@@ -1175,1 +1166,0 @@\n-  }\n@@ -1200,0 +1190,4 @@\n+  if (should_verify_subset(Verify_StringDedup)) {\n+    log_debug(gc, verify)(\"String Deduplication\");\n+    StringDedup::verify();\n+  }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -366,0 +366,1 @@\n+    Verify_StringDedup = 2048,\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"oops\/access.hpp\"\n+\n@@ -30,1 +32,0 @@\n-#include \"oops\/access.hpp\"\n","filename":"src\/hotspot\/share\/oops\/access.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-#include \"oops\/access.hpp\"\n+\n+#include \"oops\/access.hpp\"\n","filename":"src\/hotspot\/share\/oops\/accessBackend.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-  \/\/ Copy class version\n@@ -242,24 +241,1 @@\n-\/\/ Unsafe anonymous class support:\n-void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {\n-  assert(is_within_bounds(class_index), \"index out of bounds\");\n-  assert(is_within_bounds(name_index), \"index out of bounds\");\n-  assert((resolved_klass_index & 0xffff0000) == 0, \"must be\");\n-  *int_at_addr(class_index) =\n-    build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);\n-\n-  symbol_at_put(name_index, name);\n-  name->increment_refcount();\n-  Klass** adr = resolved_klasses()->adr_at(resolved_klass_index);\n-  Atomic::release_store(adr, k);\n-\n-  \/\/ The interpreter assumes when the tag is stored, the klass is resolved\n-  \/\/ and the Klass* non-NULL, so we need hardware store ordering here.\n-  jbyte qdesc_bit = (name->is_Q_signature()) ? (jbyte) JVM_CONSTANT_QDescBit : 0;\n-  if (k != NULL) {\n-    release_tag_at_put(class_index, JVM_CONSTANT_Class | qdesc_bit);\n-  } else {\n-    release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n-  }\n-}\n-\n-\/\/ Unsafe anonymous class support:\n+\/\/ Hidden class support:\n@@ -336,1 +312,1 @@\n-    if (tag_at(index).is_string() && !cp->is_pseudo_string_at(index)) {\n+    if (tag_at(index).is_string()) {\n@@ -503,1 +479,1 @@\n-  JavaThread* javaThread = THREAD->as_Java_thread();\n+  JavaThread* javaThread = THREAD;\n@@ -643,1 +619,1 @@\n-    Thread *thread = Thread::current();\n+    Thread* current = Thread::current();\n@@ -647,2 +623,2 @@\n-    Handle h_prot (thread, protection_domain);\n-    Handle h_loader (thread, loader);\n+    Handle h_prot (current, protection_domain);\n+    Handle h_loader (current, loader);\n@@ -651,2 +627,2 @@\n-    \/\/ Avoid constant pool verification at a safepoint, which takes the Module_lock.\n-    if (k != NULL && !SafepointSynchronize::is_at_safepoint()) {\n+    \/\/ Avoid constant pool verification at a safepoint, as it takes the Module_lock.\n+    if (k != NULL && current->is_Java_thread()) {\n@@ -654,2 +630,2 @@\n-      ExceptionMark em(thread);\n-      Thread* THREAD = thread; \/\/ For exception macros.\n+      JavaThread* THREAD = current->as_Java_thread(); \/\/ For exception macros.\n+      ExceptionMark em(THREAD);\n@@ -1108,4 +1084,0 @@\n-    if (this_cp->is_pseudo_string_at(index)) {\n-      result_oop = this_cp->pseudo_string_at(index, cache_index);\n-      break;\n-    }\n@@ -2314,32 +2286,0 @@\n-\/\/ JSR 292 support for patching constant pool oops after the class is linked and\n-\/\/ the oop array for resolved references are created.\n-\/\/ We can't do this during classfile parsing, which is how the other indexes are\n-\/\/ patched.  The other patches are applied early for some error checking\n-\/\/ so only defer the pseudo_strings.\n-void ConstantPool::patch_resolved_references(GrowableArray<Handle>* cp_patches) {\n-  for (int index = 1; index < cp_patches->length(); index++) { \/\/ Index 0 is unused\n-    Handle patch = cp_patches->at(index);\n-    if (patch.not_null()) {\n-      assert (tag_at(index).is_string(), \"should only be string left\");\n-      \/\/ Patching a string means pre-resolving it.\n-      \/\/ The spelling in the constant pool is ignored.\n-      \/\/ The constant reference may be any object whatever.\n-      \/\/ If it is not a real interned string, the constant is referred\n-      \/\/ to as a \"pseudo-string\", and must be presented to the CP\n-      \/\/ explicitly, because it may require scavenging.\n-      int obj_index = cp_to_object_index(index);\n-      pseudo_string_at_put(index, obj_index, patch());\n-     DEBUG_ONLY(cp_patches->at_put(index, Handle());)\n-    }\n-  }\n-#ifdef ASSERT\n-  \/\/ Ensure that all the patches have been used.\n-  for (int index = 0; index < cp_patches->length(); index++) {\n-    assert(cp_patches->at(index).is_null(),\n-           \"Unused constant pool patch at %d in class file %s\",\n-           index,\n-           pool_holder()->external_name());\n-  }\n-#endif \/\/ ASSERT\n-}\n-\n@@ -2398,7 +2338,1 @@\n-      if (is_pseudo_string_at(index)) {\n-        oop anObj = pseudo_string_at(index);\n-        anObj->print_value_on(st);\n-        st->print(\" {\" PTR_FORMAT \"}\", p2i(anObj));\n-      } else {\n-        unresolved_string_at(index)->print_value_on(st);\n-      }\n+      unresolved_string_at(index)->print_value_on(st);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":11,"deletions":77,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/thread.hpp\"\n@@ -61,1 +62,0 @@\n-  bool is_pseudo_string() { return (_ptr & _pseudo_bit) != 0; }\n@@ -313,2 +313,1 @@\n-  \/\/ Unsafe anonymous class support:\n-  void klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name);\n+  \/\/ Hidden class support:\n@@ -497,20 +496,0 @@\n-  \/\/ A \"pseudo-string\" is an non-string oop that has found its way into\n-  \/\/ a String entry.\n-  \/\/ This can happen if the user patches a live\n-  \/\/ object into a CONSTANT_String entry of an unsafe anonymous class.\n-  \/\/ Methods internally created for method handles may also\n-  \/\/ use pseudo-strings to link themselves to related metaobjects.\n-\n-  bool is_pseudo_string_at(int which);\n-\n-  oop pseudo_string_at(int which, int obj_index);\n-\n-  oop pseudo_string_at(int which);\n-\n-  void pseudo_string_at_put(int which, int obj_index, oop x) {\n-    assert(tag_at(which).is_string(), \"Corrupted constant pool\");\n-    Symbol* sym = unresolved_string_at(which);\n-    slot_at_put(which, CPSlot(sym, CPSlot::_pseudo_bit));\n-    string_at_put(which, obj_index, x);    \/\/ this works just fine\n-  }\n-\n@@ -866,3 +845,0 @@\n-  \/\/ patch JSR 292 resolved references after the class is linked.\n-  void patch_resolved_references(GrowableArray<Handle>* cp_patches);\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":2,"deletions":26,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -408,1 +408,1 @@\n-    Thread* THREAD = Thread::current();\n+    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -491,1 +491,1 @@\n-  JavaThread* current = THREAD->as_Java_thread();\n+  JavaThread* current = THREAD;\n@@ -738,1 +738,1 @@\n-  Thread* THREAD = Thread::current();\n+  Thread* current = Thread::current();\n@@ -743,1 +743,1 @@\n-    RawBytecodeStream bcs(methodHandle(THREAD, m));\n+    RawBytecodeStream bcs(methodHandle(current, m));\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -911,1 +910,1 @@\n-void GenerateOopMap::do_interpretation(Thread* thread)\n+void GenerateOopMap::do_interpretation()\n@@ -913,0 +912,2 @@\n+  \/\/ \"i\" is just for debugging, so we can detect cases where this loop is\n+  \/\/ iterated more than once.\n@@ -915,8 +916,0 @@\n-    if (i != 0 && thread->is_Java_thread()) {\n-      JavaThread* jt = thread->as_Java_thread();\n-      if (jt->thread_state() == _thread_in_vm) {\n-        \/\/ Since this JavaThread has looped at least once and is _thread_in_vm,\n-        \/\/ we honor any pending blocking request.\n-        ThreadBlockInVM tbivm(jt);\n-      }\n-    }\n@@ -2173,1 +2166,1 @@\n-    do_interpretation(current);\n+    do_interpretation();\n@@ -2196,1 +2189,3 @@\n-    _exception = Exceptions::new_exception(current, vmSymbols::java_lang_LinkageError(), msg_buffer2);\n+    _exception = Exceptions::new_exception(current->as_Java_thread(),\n+                                           vmSymbols::java_lang_LinkageError(),\n+                                           msg_buffer2);\n@@ -2474,1 +2469,1 @@\n-  Thread *THREAD = Thread::current();  \/\/ Could really have TRAPS argument.\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -382,1 +382,1 @@\n-  void  do_interpretation                   (Thread* thread);\n+  void  do_interpretation                   ();\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,5 +40,0 @@\n-  InstanceKlass** adr_host = adr_unsafe_anonymous_host();\n-  if (adr_host != NULL) {\n-    return (InlineKlassFixedBlock*)(adr_host + 1);\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -169,1 +170,1 @@\n-bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {\n+bool InstanceKlass::has_nest_member(JavaThread* current, InstanceKlass* k) const {\n@@ -173,1 +174,1 @@\n-      ResourceMark rm(THREAD);\n+      ResourceMark rm(current);\n@@ -181,1 +182,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -186,2 +187,2 @@\n-  \/\/ Check for a resolved cp entry , else fall back to a name check.\n-  \/\/ We don't want to resolve any class other than the one being checked.\n+  \/\/ Check for the named class in _nest_members.\n+  \/\/ We don't resolve, or load, any classes.\n@@ -190,33 +191,4 @@\n-    if (_constants->tag_at(cp_index).is_klass()) {\n-      Klass* k2 = _constants->klass_at(cp_index, THREAD);\n-      assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass()),\n-             \"Exceptions should not be possible here\");\n-      if (k2 == k) {\n-        log_trace(class, nestmates)(\"- class is listed at nest_members[%d] => cp[%d]\", i, cp_index);\n-        return true;\n-      }\n-    }\n-    else {\n-      Symbol* name = _constants->klass_name_at(cp_index);\n-      if (name == k->name()) {\n-        log_trace(class, nestmates)(\"- Found it at nest_members[%d] => cp[%d]\", i, cp_index);\n-\n-        \/\/ Names match so check actual klass. This may trigger class loading if\n-        \/\/ it doesn't match though that should be impossible as it means one classloader\n-        \/\/ has defined two different classes with the same name! A compiler thread won't be\n-        \/\/ able to perform that loading but we can't exclude the compiler threads from\n-        \/\/ executing this logic. But it should actually be impossible to trigger loading here.\n-        Klass* k2 = _constants->klass_at(cp_index, THREAD);\n-        assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass()),\n-               \"Exceptions should not be possible here\");\n-        if (k2 == k) {\n-          log_trace(class, nestmates)(\"- class is listed as a nest member\");\n-          return true;\n-        }\n-        else {\n-          \/\/ same name but different klass!\n-          log_trace(class, nestmates)(\" - klass comparison failed!\");\n-          \/\/ can't have two names the same, so we're done\n-          return false;\n-        }\n-      }\n+    Symbol* name = _constants->klass_name_at(cp_index);\n+    if (name == k->name()) {\n+      log_trace(class, nestmates)(\"- named class found at nest_members[%d] => cp[%d]\", i, cp_index);\n+      return true;\n@@ -231,1 +203,1 @@\n-  Thread* THREAD = Thread::current();\n+  Thread* current = Thread::current();\n@@ -237,1 +209,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -244,1 +216,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -251,1 +223,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -293,1 +265,2 @@\n-    if (!THREAD->can_call_java() && !_constants->tag_at(_nest_host_index).is_klass()) {\n+    bool can_resolve = THREAD->can_call_java();\n+    if (!can_resolve && !_constants->tag_at(_nest_host_index).is_klass()) {\n@@ -331,12 +304,7 @@\n-          bool is_member = nest_host_k->has_nest_member(this, THREAD);\n-          \/\/ exception is rare, perhaps impossible\n-          if (!HAS_PENDING_EXCEPTION) {\n-            if (is_member) {\n-              _nest_host = nest_host_k; \/\/ save resolved nest-host value\n-\n-              log_trace(class, nestmates)(\"Resolved nest-host of %s to %s\",\n-                                          this->external_name(), k->external_name());\n-              return nest_host_k;\n-            } else {\n-              error = \"current type is not listed as a nest member\";\n-            }\n+          bool is_member = nest_host_k->has_nest_member(THREAD, this);\n+          if (is_member) {\n+            _nest_host = nest_host_k; \/\/ save resolved nest-host value\n+\n+            log_trace(class, nestmates)(\"Resolved nest-host of %s to %s\",\n+                                        this->external_name(), k->external_name());\n+            return nest_host_k;\n@@ -344,7 +312,1 @@\n-            if (PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass())) {\n-              return NULL; \/\/ propagate VMEs\n-            }\n-            stringStream ss;\n-            ss.print(\"exception on member check: \");\n-            java_lang_Throwable::print(PENDING_EXCEPTION, &ss);\n-            error = ss.as_string();\n+            error = \"current type is not listed as a nest member\";\n@@ -467,1 +429,0 @@\n-  bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();\n@@ -472,1 +433,0 @@\n-                                       parser.is_unsafe_anonymous(),\n@@ -584,1 +544,0 @@\n-  set_is_unsafe_anonymous(parser.is_unsafe_anonymous());\n@@ -858,1 +817,1 @@\n-  ObjectLocker ol(h_init_lock, THREAD->as_Java_thread());\n+  ObjectLocker ol(h_init_lock, THREAD);\n@@ -947,1 +906,1 @@\n-  JavaThread* jt = THREAD->as_Java_thread();\n+  JavaThread* jt = THREAD;\n@@ -1103,0 +1062,3 @@\n+      if (UseVtableBasedCHA) {\n+        MutexLocker ml(THREAD, Compile_lock);\n+        set_init_state(linked);\n@@ -1104,1 +1066,7 @@\n-      set_init_state(linked);\n+        \/\/ Now flush all code that assume the class is not linked.\n+        if (Universe::is_fully_initialized()) {\n+          CodeCache::flush_dependents_on(this);\n+        }\n+      } else {\n+        set_init_state(linked);\n+      }\n@@ -1106,1 +1074,1 @@\n-        JvmtiExport::post_class_prepare(THREAD->as_Java_thread(), this);\n+        JvmtiExport::post_class_prepare(THREAD, this);\n@@ -1170,1 +1138,1 @@\n-  JavaThread* jt = THREAD->as_Java_thread();\n+  JavaThread* jt = THREAD;\n@@ -1345,1 +1313,1 @@\n-    ObjectLocker ol(h_init_lock, THREAD->as_Java_thread());\n+    ObjectLocker ol(h_init_lock, THREAD);\n@@ -1570,1 +1538,1 @@\n-    JavaThread *jt = THREAD->as_Java_thread();\n+    JavaThread *jt = THREAD;\n@@ -2547,1 +2515,5 @@\n-  it->push(&_default_vtable_indices);\n+  if (!is_rewritten()) {\n+    it->push(&_default_vtable_indices, MetaspaceClosure::_writable);\n+  } else {\n+    it->push(&_default_vtable_indices);\n+  }\n@@ -2581,1 +2553,1 @@\n-  if (MetaspaceShared::is_old_class(this)) {\n+  if (can_be_verified_at_dumptime()) {\n@@ -2683,0 +2655,1 @@\n+  assert(!shared_loading_failed(), \"Must not try to load failed class again\");\n@@ -2732,0 +2705,22 @@\n+\/\/ Check if a class or any of its supertypes has a version older than 50.\n+\/\/ CDS will not perform verification of old classes during dump time because\n+\/\/ without changing the old verifier, the verification constraint cannot be\n+\/\/ retrieved during dump time.\n+\/\/ Verification of archived old classes will be performed during run time.\n+bool InstanceKlass::can_be_verified_at_dumptime() const {\n+  if (major_version() < 50 \/*JAVA_6_VERSION*\/) {\n+    return true;\n+  }\n+  if (java_super() != NULL && java_super()->can_be_verified_at_dumptime()) {\n+    return true;\n+  }\n+  Array<InstanceKlass*>* interfaces = local_interfaces();\n+  int len = interfaces->length();\n+  for (int i = 0; i < len; i++) {\n+    if (interfaces->at(i)->can_be_verified_at_dumptime()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -2879,7 +2874,0 @@\n-  \/\/ If this is an unsafe anonymous class, append a hash to make the name unique\n-  if (is_unsafe_anonymous()) {\n-    intptr_t hash = (java_mirror() != NULL) ? java_mirror()->identity_hash() : 0;\n-    jio_snprintf(hash_buf, sizeof(hash_buf), \"\/\" UINTX_FORMAT, (uintx)hash);\n-    hash_len = (int)strlen(hash_buf);\n-  }\n-\n@@ -2922,6 +2910,0 @@\n-  \/\/ For an unsafe anonymous class return the host class' module\n-  if (is_unsafe_anonymous()) {\n-    assert(unsafe_anonymous_host() != NULL, \"unsafe anonymous class must have a host class\");\n-    return unsafe_anonymous_host()->module();\n-  }\n-\n@@ -3033,3 +3015,3 @@\n-\/\/ Function set_classpath_index checks if the package of the InstanceKlass is in the\n-\/\/ boot loader's package entry table.  If so, then it sets the classpath_index\n-\/\/ in the package entry record.\n+\/\/ Function set_classpath_index ensures that for a non-null _package_entry\n+\/\/ of the InstanceKlass, the entry is in the boot loader's package entry table.\n+\/\/ It then sets the classpath_index in the package entry record.\n@@ -3196,1 +3178,1 @@\n-      \/\/ It may be a local or anonymous class; try for that.\n+      \/\/ It may be a local class; try for that.\n@@ -3488,2 +3470,0 @@\n-#ifndef PRODUCT\n-\n@@ -3595,1 +3575,0 @@\n-  st->print(BULLET\"unsafe anonymous host class:        \"); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st->cr();\n@@ -3664,2 +3643,0 @@\n-#endif \/\/PRODUCT\n-\n@@ -3672,2 +3649,0 @@\n-#ifndef PRODUCT\n-\n@@ -3731,0 +3706,2 @@\n+#ifndef PRODUCT\n+\n@@ -3832,5 +3809,4 @@\n-      Thread* THREAD = Thread::current();\n-      Klass* caller =\n-            THREAD->is_Java_thread()\n-                ? THREAD->as_Java_thread()->security_get_caller_class(1)\n-                : NULL;\n+      Thread* current = Thread::current();\n+      Klass* caller = current->is_Java_thread() ?\n+        current->as_Java_thread()->security_get_caller_class(1):\n+        NULL;\n@@ -4021,4 +3997,0 @@\n-  const Klass* anonymous_host = unsafe_anonymous_host();\n-  if (anonymous_host != NULL) {\n-    guarantee(anonymous_host->is_klass(), \"should be klass\");\n-  }\n@@ -4356,1 +4328,1 @@\n-  if (is_hidden() || unsafe_anonymous_host() != NULL) {\n+  if (is_hidden()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":80,"deletions":108,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-\/\/    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)\n@@ -84,1 +83,0 @@\n-#ifndef PRODUCT\n@@ -94,1 +92,0 @@\n-#endif  \/\/ !PRODUCT\n@@ -234,4 +231,3 @@\n-  int             _static_field_size;    \/\/ number words used by static fields (oop and non-oop) in this klass\n-\n-  int             _nonstatic_oop_map_size;\/\/ size in words of nonstatic oop map blocks\n-  int             _itable_len;           \/\/ length of Java itable (in words)\n+  int             _static_field_size;       \/\/ number words used by static fields (oop and non-oop) in this klass\n+  int             _nonstatic_oop_map_size;  \/\/ size in words of nonstatic oop map blocks\n+  int             _itable_len;              \/\/ length of Java itable (in words)\n@@ -242,4 +238,3 @@\n-  u2              _this_class_index;              \/\/ constant pool entry\n-\n-  u2              _static_oop_field_count;\/\/ number of static oop fields in this klass\n-  u2              _java_fields_count;    \/\/ The number of declared Java fields\n+  u2              _this_class_index;        \/\/ constant pool entry\n+  u2              _static_oop_field_count;  \/\/ number of static oop fields in this klass\n+  u2              _java_fields_count;       \/\/ The number of declared Java fields\n@@ -247,1 +242,1 @@\n-  volatile u2     _idnum_allocated_count;         \/\/ JNI\/JVMTI: increments with the addition of methods, old ids don't change\n+  volatile u2     _idnum_allocated_count;   \/\/ JNI\/JVMTI: increments with the addition of methods, old ids don't change\n@@ -251,1 +246,1 @@\n-  bool            _is_marked_dependent;  \/\/ used for marking during flushing and deoptimization\n+  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n@@ -256,1 +251,1 @@\n-  u1              _init_state;                    \/\/ state of class\n+  u1              _init_state;              \/\/ state of class\n@@ -273,1 +268,1 @@\n-    _misc_is_unsafe_anonymous                 = 1 << 3,  \/\/ has embedded _unsafe_anonymous_host field\n+    _misc_unused                              = 1 << 3,  \/\/ not currently used\n@@ -278,1 +273,1 @@\n-    _unused                                   = 1 << 8,  \/\/\n+    _misc_shared_loading_failed               = 1 << 8,  \/\/ class has been loaded from shared archive\n@@ -371,7 +366,0 @@\n-  \/\/ embedded unsafe_anonymous_host klass follows here\n-  \/\/   The embedded host klass only exists in an unsafe anonymous class for\n-  \/\/   dynamic language support (JSR 292 enabled). The host class grants\n-  \/\/   its access privileges to this class also. The host class is either\n-  \/\/   named, or a previously loaded unsafe anonymous class. A non-anonymous class\n-  \/\/   or an anonymous class loaded through normal classloading does not\n-  \/\/   have this embedded field.\n@@ -407,0 +395,12 @@\n+  bool shared_loading_failed() const {\n+    return (_misc_flags & _misc_shared_loading_failed) != 0;\n+  }\n+\n+  void set_shared_loading_failed() {\n+    _misc_flags |= _misc_shared_loading_failed;\n+  }\n+\n+  void clear_shared_loading_failed() {\n+    _misc_flags &= ~_misc_shared_loading_failed;\n+  }\n+\n@@ -596,2 +596,3 @@\n-  \/\/ Called to verify that k is a member of this nest - does not look at k's nest-host\n-  bool has_nest_member(InstanceKlass* k, TRAPS) const;\n+  \/\/ Called to verify that k is a member of this nest - does not look at k's nest-host,\n+  \/\/ nor does it resolve any CP entries or load any classes.\n+  bool has_nest_member(JavaThread* current, InstanceKlass* k) const;\n@@ -807,14 +808,0 @@\n-  \/\/ host class\n-  inline InstanceKlass* unsafe_anonymous_host() const;\n-  inline void set_unsafe_anonymous_host(const InstanceKlass* host);\n-  bool is_unsafe_anonymous() const                {\n-    return (_misc_flags & _misc_is_unsafe_anonymous) != 0;\n-  }\n-  void set_is_unsafe_anonymous(bool value)        {\n-    if (value) {\n-      _misc_flags |= _misc_is_unsafe_anonymous;\n-    } else {\n-      _misc_flags &= ~_misc_is_unsafe_anonymous;\n-    }\n-  }\n-\n@@ -1170,1 +1157,1 @@\n-                  bool is_interface, bool is_unsafe_anonymous,\n+                  bool is_interface,\n@@ -1177,1 +1164,0 @@\n-           (is_unsafe_anonymous ? (int)sizeof(Klass*)\/wordSize : 0) +\n@@ -1181,0 +1167,1 @@\n+\n@@ -1185,1 +1172,0 @@\n-                                               is_unsafe_anonymous(),\n@@ -1190,0 +1176,1 @@\n+\n@@ -1200,1 +1187,0 @@\n-  inline InstanceKlass** adr_unsafe_anonymous_host() const;\n@@ -1388,0 +1374,1 @@\n+  bool can_be_verified_at_dumptime() const;\n@@ -1399,2 +1386,0 @@\n-#ifndef PRODUCT\n-#endif\n@@ -1406,1 +1391,0 @@\n-#ifndef PRODUCT\n@@ -1409,0 +1393,1 @@\n+#ifndef PRODUCT\n@@ -1565,1 +1550,0 @@\n-    assert(!root->is_interface(), \"no subclasses\");\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":31,"deletions":47,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"oops\/instanceKlass.hpp\"\n+\n@@ -32,1 +34,0 @@\n-#include \"oops\/instanceKlass.hpp\"\n@@ -40,21 +41,0 @@\n-inline InstanceKlass* InstanceKlass::unsafe_anonymous_host() const {\n-  InstanceKlass** hk = adr_unsafe_anonymous_host();\n-  if (hk == NULL) {\n-    assert(!is_unsafe_anonymous(), \"Unsafe anonymous classes have host klasses\");\n-    return NULL;\n-  } else {\n-    assert(*hk != NULL, \"host klass should always be set if the address is not null\");\n-    assert(is_unsafe_anonymous(), \"Only unsafe anonymous classes have host klasses\");\n-    return *hk;\n-  }\n-}\n-\n-inline void InstanceKlass::set_unsafe_anonymous_host(const InstanceKlass* host) {\n-  assert(is_unsafe_anonymous(), \"not unsafe anonymous\");\n-  const InstanceKlass** addr = (const InstanceKlass **)adr_unsafe_anonymous_host();\n-  assert(addr != NULL, \"no reversed space\");\n-  if (addr != NULL) {\n-    *addr = host;\n-  }\n-}\n-\n@@ -85,13 +65,0 @@\n-inline InstanceKlass** InstanceKlass::adr_unsafe_anonymous_host() const {\n-  if (is_unsafe_anonymous()) {\n-    InstanceKlass** adr_impl = (InstanceKlass**)adr_implementor();\n-    if (adr_impl != NULL) {\n-      return adr_impl + 1;\n-    } else {\n-      return (InstanceKlass **)end_of_nonstatic_oop_maps();\n-    }\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n@@ -100,5 +67,0 @@\n-    InstanceKlass** adr_host = adr_unsafe_anonymous_host();\n-    if (adr_host != NULL) {\n-      return (address)(adr_host + 1);\n-    }\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":2,"deletions":40,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -680,13 +680,1 @@\n-    if (ik->is_unsafe_anonymous()) {\n-      char addr_buf[20];\n-      jio_snprintf(addr_buf, 20, \"\/\" INTPTR_FORMAT, p2i(ik));\n-      size_t addr_len = strlen(addr_buf);\n-      size_t name_len = name()->utf8_length();\n-      char*  result   = NEW_RESOURCE_ARRAY(char, name_len + addr_len + 1);\n-      name()->as_klass_external_name(result, (int) name_len + 1);\n-      assert(strlen(result) == name_len, \"\");\n-      strcpy(result + name_len, addr_buf);\n-      assert(strlen(result) == name_len + addr_len, \"\");\n-      return result;\n-\n-    } else if (ik->is_hidden()) {\n+    if (ik->is_hidden()) {\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-#include \"classfile\/classLoaderData.inline.hpp\"\n+\n+#include \"classfile\/classLoaderData.inline.hpp\"\n@@ -46,1 +47,1 @@\n-\/\/ Iff the class loader (or mirror for unsafe anonymous classes) is alive the\n+\/\/ Iff the class loader (or mirror for non-strong hidden classes) is alive the\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1091,1 +1091,1 @@\n-void itableMethodEntry::initialize(Method* m) {\n+void itableMethodEntry::initialize(InstanceKlass* klass, Method* m) {\n@@ -1097,1 +1097,2 @@\n-     !MetaspaceShared::is_old_class(m->method_holder())) {\n+     !m->method_holder()->can_be_verified_at_dumptime() &&\n+     !klass->can_be_verified_at_dumptime()) {\n@@ -1101,0 +1102,2 @@\n+    \/\/ For a shared old class which was not linked during dump time, we can't compare the dumptime\n+    \/\/ itable method entry with the runtime entry.\n@@ -1340,1 +1343,1 @@\n-            initialize(Universe::throw_illegal_access_error());\n+            initialize(_klass, Universe::throw_illegal_access_error());\n@@ -1353,1 +1356,1 @@\n-      itableOffsetEntry::method_entry(_klass, method_table_offset)[ime_num].initialize(target);\n+      itableOffsetEntry::method_entry(_klass, method_table_offset)[ime_num].initialize(_klass, target);\n@@ -1385,1 +1388,1 @@\n-    ime->initialize(new_method);\n+    ime->initialize(_klass, new_method);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-  void initialize(Method* method);\n+  void initialize(InstanceKlass* klass, Method* method);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -359,2 +359,1 @@\n-  template <typename KlassProxy>\n-  inline bool must_be_preserved(KlassProxy klass) const;\n+  inline bool must_be_preserved(const oopDesc* obj) const;\n@@ -379,2 +378,1 @@\n-  template <typename KlassProxy>\n-  inline bool must_be_preserved_for_promotion_failure(KlassProxy klass) const;\n+  inline bool must_be_preserved_for_promotion_failure(const oopDesc* obj) const;\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-#include \"oops\/klass.hpp\"\n+\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n@@ -33,2 +35,1 @@\n-template <typename KlassProxy>\n-inline bool markWord::must_be_preserved(KlassProxy klass) const {\n+inline bool markWord::must_be_preserved(const oopDesc* obj) const {\n@@ -41,1 +42,1 @@\n-    markWord prototype_header = prototype_for_klass(klass);\n+    markWord prototype_header = prototype_for_klass(obj->klass());\n@@ -52,2 +53,1 @@\n-template <typename KlassProxy>\n-inline bool markWord::must_be_preserved_for_promotion_failure(KlassProxy klass) const {\n+inline bool markWord::must_be_preserved_for_promotion_failure(const oopDesc* obj) const {\n@@ -64,1 +64,1 @@\n-    if (has_bias_pattern() || prototype_for_klass(klass).has_bias_pattern()) {\n+    if (has_bias_pattern() || prototype_for_klass(obj->klass()).has_bias_pattern()) {\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -239,0 +239,5 @@\n+  if (log_is_enabled(Debug, exceptions)) {\n+    ResourceMark rm(THREAD);\n+    log_debug(exceptions)(\"Looking for catch handler for exception of type \\\"%s\\\" in method \\\"%s\\\"\",\n+                          ex_klass == NULL ? \"NULL\" : ex_klass->external_name(), mh->name()->as_C_string());\n+  }\n@@ -251,0 +256,3 @@\n+    log_debug(exceptions)(\"  - checking exception table entry for BCI %d to %d\",\n+                         beg_bci, end_bci);\n+\n@@ -253,0 +261,2 @@\n+      log_debug(exceptions)(\"    - entry covers throw point BCI %d\", throw_bci);\n+\n@@ -256,0 +266,5 @@\n+        if (log_is_enabled(Info, exceptions)) {\n+          ResourceMark rm(THREAD);\n+          log_info(exceptions)(\"Found catch-all handler for exception of type \\\"%s\\\" in method \\\"%s\\\" at BCI: %d\",\n+                               ex_klass == NULL ? \"NULL\" : ex_klass->external_name(), mh->name()->as_C_string(), handler_bci);\n+        }\n@@ -258,0 +273,6 @@\n+        \/\/ Is this even possible?\n+        if (log_is_enabled(Info, exceptions)) {\n+          ResourceMark rm(THREAD);\n+          log_info(exceptions)(\"NULL exception class is implicitly caught by handler in method \\\"%s\\\" at BCI: %d\",\n+                               mh()->name()->as_C_string(), handler_bci);\n+        }\n@@ -260,0 +281,5 @@\n+        if (log_is_enabled(Debug, exceptions)) {\n+          ResourceMark rm(THREAD);\n+          log_debug(exceptions)(\"    - resolving catch type \\\"%s\\\"\",\n+                               pool->klass_name_at(klass_index)->as_C_string());\n+        }\n@@ -263,1 +289,9 @@\n-        Klass* k = pool->klass_at(klass_index, CHECK_(handler_bci));\n+        Klass* k = pool->klass_at(klass_index, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          if (log_is_enabled(Debug, exceptions)) {\n+            ResourceMark rm(THREAD);\n+            log_debug(exceptions)(\"    - exception \\\"%s\\\" occurred resolving catch type\",\n+                                 PENDING_EXCEPTION->klass()->external_name());\n+          }\n+          return handler_bci;\n+        }\n@@ -266,0 +300,5 @@\n+          if (log_is_enabled(Info, exceptions)) {\n+            ResourceMark rm(THREAD);\n+            log_info(exceptions)(\"Found matching handler for exception of type \\\"%s\\\" in method \\\"%s\\\" at BCI: %d\",\n+                                 ex_klass == NULL ? \"NULL\" : ex_klass->external_name(), mh->name()->as_C_string(), handler_bci);\n+          }\n@@ -272,0 +311,6 @@\n+  if (log_is_enabled(Debug, exceptions)) {\n+    ResourceMark rm(THREAD);\n+    log_debug(exceptions)(\"No catch handler found for exception of type \\\"%s\\\" in method \\\"%s\\\"\",\n+                          ex_klass->external_name(), mh->name()->as_C_string());\n+  }\n+\n@@ -581,1 +626,1 @@\n-    Thread* THREAD = current;\n+    JavaThread* THREAD = current->as_Java_thread(); \/\/ For exception macros.\n@@ -646,1 +691,1 @@\n-    k = ss.as_klass(class_loader, protection_domain, SignatureStream::ReturnNull, thread);\n+    k = ss.as_klass(class_loader, protection_domain, SignatureStream::ReturnNull, thread->as_Java_thread());\n@@ -651,4 +696,0 @@\n-bool Method::is_empty_method() const {\n-  return  code_size() == 1\n-      && *code_base() == Bytecodes::_return;\n-}\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":48,"deletions":7,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -601,1 +601,0 @@\n-  bool is_strict() const                         { return access_flags().is_strict();      }\n@@ -686,1 +685,1 @@\n-  void log_touched(TRAPS);\n+  void log_touched(Thread* current);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -94,0 +95,5 @@\n+inline bool Method::is_empty_method() const {\n+  return  code_size() == 1\n+      && *code_base() == Bytecodes::_return;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-  THREAD->as_Java_thread()->check_possible_safepoint();\n+  THREAD->check_possible_safepoint();\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  Thread* THREAD = Thread::current();\n+  JavaThread* current = Thread::current()->as_Java_thread();\n@@ -96,3 +96,3 @@\n-  HandleMark hm(THREAD);\n-  Handle object(THREAD, this);\n-  return ObjectSynchronizer::FastHashCode(THREAD, object());\n+  HandleMark hm(current);\n+  Handle object(current, this);\n+  return ObjectSynchronizer::FastHashCode(current, object());\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -276,1 +276,0 @@\n-  inline oop forwardee_acquire() const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"oops\/oop.hpp\"\n+\n@@ -34,1 +36,0 @@\n-#include \"oops\/oop.hpp\"\n@@ -322,7 +323,0 @@\n-\/\/ Note that the forwardee is not the same thing as the displaced_mark.\n-\/\/ The forwardee is used when copying during scavenge and mark-sweep.\n-\/\/ It does need to clear the low two locking- and GC-related bits.\n-oop oopDesc::forwardee_acquire() const {\n-  return cast_to_oop(Atomic::load_acquire(&_mark).decode_pointer());\n-}\n-\n@@ -414,13 +408,0 @@\n-\/\/ Supports deferred calling of obj->klass().\n-class DeferredObjectToKlass {\n-  const oopDesc* _obj;\n-\n-public:\n-  DeferredObjectToKlass(const oopDesc* obj) : _obj(obj) {}\n-\n-  \/\/ Implicitly convertible to const Klass*.\n-  operator const Klass*() const {\n-    return _obj->klass();\n-  }\n-};\n-\n@@ -432,6 +413,1 @@\n-  \/\/ There's a circular dependency between oop.inline.hpp and\n-  \/\/ markWord.inline.hpp because markWord::must_be_preserved wants to call\n-  \/\/ oopDesc::klass(). This could be solved by calling klass() here. However,\n-  \/\/ not all paths inside must_be_preserved calls klass(). Defer the call until\n-  \/\/ the klass is actually needed.\n-  return m.must_be_preserved(DeferredObjectToKlass(this));\n+  return m.must_be_preserved(this);\n@@ -441,1 +417,1 @@\n-  return m.must_be_preserved_for_promotion_failure(DeferredObjectToKlass(this));\n+  return m.must_be_preserved_for_promotion_failure(this);\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":4,"deletions":28,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-    JavaThread *jt = THREAD->as_Java_thread();\n+    JavaThread *jt = THREAD;\n@@ -201,1 +201,1 @@\n-  THREAD->as_Java_thread()->check_possible_safepoint();\n+  THREAD->check_possible_safepoint();\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-static bool commute(Node *add, bool con_left, bool con_right) {\n+static bool commute(PhaseGVN* phase, Node* add) {\n@@ -69,0 +69,25 @@\n+  \/\/ convert \"max(a,b) + min(a,b)\" into \"a+b\".\n+  if ((in1->Opcode() == add->as_Add()->max_opcode() && in2->Opcode() == add->as_Add()->min_opcode())\n+      || (in1->Opcode() == add->as_Add()->min_opcode() && in2->Opcode() == add->as_Add()->max_opcode())) {\n+    Node *in11 = in1->in(1);\n+    Node *in12 = in1->in(2);\n+\n+    Node *in21 = in2->in(1);\n+    Node *in22 = in2->in(2);\n+\n+    if ((in11 == in21 && in12 == in22) ||\n+        (in11 == in22 && in12 == in21)) {\n+      add->set_req(1, in11);\n+      add->set_req(2, in12);\n+      PhaseIterGVN* igvn = phase->is_IterGVN();\n+      if (igvn) {\n+        igvn->_worklist.push(in1);\n+        igvn->_worklist.push(in2);\n+      }\n+      return true;\n+    }\n+  }\n+\n+  bool con_left = phase->type(in1)->singleton();\n+  bool con_right = phase->type(in2)->singleton();\n+\n@@ -118,1 +143,1 @@\n-  if (commute(this, con_left, con_right)) return this;\n+  if (commute(phase, this)) return this;\n@@ -433,1 +458,1 @@\n-    if( op2 == Op_SubL && in1->in(1) == in1->in(2) ) {\n+    if( op2 == Op_SubL && in1->in(1) == in2->in(2) ) {\n@@ -444,1 +469,1 @@\n-  if( op1 == Op_SubL && phase->type(in1->in(1)) == TypeInt::ZERO )\n+  if( op1 == Op_SubL && phase->type(in1->in(1)) == TypeLong::ZERO )\n@@ -447,10 +472,0 @@\n-  \/\/ Convert \"X+X+X+X+X...+X+Y\" into \"k*X+Y\" or really convert \"X+(X+Y)\"\n-  \/\/ into \"(X<<1)+Y\" and let shift-folding happen.\n-  if( op2 == Op_AddL &&\n-      in2->in(1) == in1 &&\n-      op1 != Op_ConL &&\n-      0 ) {\n-    Node *shift = phase->transform(new LShiftLNode(in1,phase->intcon(1)));\n-    return new AddLNode(shift,in2->in(2));\n-  }\n-\n@@ -547,7 +562,1 @@\n-  if( IdealizedNumerics && !phase->C->method()->is_strict() ) {\n-    return AddNode::Ideal(phase, can_reshape); \/\/ commutative and associative transforms\n-  }\n-\n-  return commute(this,\n-                 phase->type( in(1) )->singleton(),\n-                 phase->type( in(2) )->singleton() ) ? this : NULL;\n+  return commute(phase, this) ? this : NULL;\n@@ -584,7 +593,1 @@\n-  if( IdealizedNumerics && !phase->C->method()->is_strict() ) {\n-    return AddNode::Ideal(phase, can_reshape); \/\/ commutative and associative transforms\n-  }\n-\n-  return commute(this,\n-                 phase->type( in(1) )->singleton(),\n-                 phase->type( in(2) )->singleton() ) ? this : NULL;\n+  return commute(phase, this) ? this : NULL;\n@@ -924,0 +927,13 @@\n+  \/\/ result of xor can only have bits sets where any of the\n+  \/\/ inputs have bits set. lo can always become 0.\n+  const TypeInt* t1i = t1->is_int();\n+  const TypeInt* t2i = t2->is_int();\n+  if ((t1i->_lo >= 0) &&\n+      (t1i->_hi > 0)  &&\n+      (t2i->_lo >= 0) &&\n+      (t2i->_hi > 0)) {\n+    \/\/ hi - set all bits below the highest bit. Using round_down to avoid overflow.\n+    const TypeInt* t1x = TypeInt::make(0, round_down_power_of_2(t1i->_hi) + (round_down_power_of_2(t1i->_hi) - 1), t1i->_widen);\n+    const TypeInt* t2x = TypeInt::make(0, round_down_power_of_2(t2i->_hi) + (round_down_power_of_2(t2i->_hi) - 1), t2i->_widen);\n+    return t1x->meet(t2x);\n+  }\n@@ -927,0 +943,1 @@\n+\n@@ -974,0 +991,13 @@\n+  \/\/ result of xor can only have bits sets where any of the\n+  \/\/ inputs have bits set. lo can always become 0.\n+  const TypeLong* t1l = t1->is_long();\n+  const TypeLong* t2l = t2->is_long();\n+  if ((t1l->_lo >= 0) &&\n+      (t1l->_hi > 0)  &&\n+      (t2l->_lo >= 0) &&\n+      (t2l->_hi > 0)) {\n+    \/\/ hi - set all bits below the highest bit. Using round_down to avoid overflow.\n+    const TypeLong* t1x = TypeLong::make(0, round_down_power_of_2(t1l->_hi) + (round_down_power_of_2(t1l->_hi) - 1), t1l->_widen);\n+    const TypeLong* t2x = TypeLong::make(0, round_down_power_of_2(t2l->_hi) + (round_down_power_of_2(t2l->_hi) - 1), t2l->_widen);\n+    return t1x->meet(t2x);\n+  }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":58,"deletions":28,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-    if (bs->array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization) ||\n+    if (bs->array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, false, BarrierSetC2::Optimization) ||\n@@ -293,1 +293,1 @@\n-         bs->array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), T_OBJECT, false, BarrierSetC2::Optimization))) {\n+         bs->array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), T_OBJECT, false, false, BarrierSetC2::Optimization))) {\n@@ -341,1 +341,1 @@\n-    if (bs->array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization) ||\n+    if (bs->array_copy_requires_gc_barriers(true, elem, true, is_clone_inst(), BarrierSetC2::Optimization) ||\n@@ -343,1 +343,1 @@\n-         bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization))) {\n+         bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, is_clone_inst(), BarrierSetC2::Optimization))) {\n@@ -421,1 +421,1 @@\n-      assert(!bs->array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), bt, false, BarrierSetC2::Optimization), \"GC barriers required\");\n+      assert(!bs->array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), bt, false, false, BarrierSetC2::Optimization), \"GC barriers required\");\n@@ -503,1 +503,1 @@\n-        assert(bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization), \"can only happen with card marking\");\n+        assert(bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, is_clone_inst(), BarrierSetC2::Optimization), \"can only happen with card marking\");\n@@ -544,1 +544,1 @@\n-      assert(!is_clonebasic() || bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization) ||\n+      assert(!is_clonebasic() || bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, is_clone_inst(), BarrierSetC2::Optimization) ||\n@@ -835,1 +835,1 @@\n-  int lane_count = ArrayCopyPartialInlineSize\/type2aelembytes(type);\n+  int lane_count = ArrayOperationPartialInlineSize\/type2aelembytes(type);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -85,3 +85,4 @@\n-  product(intx, ArrayCopyPartialInlineSize, -1, DIAGNOSTIC,                 \\\n-          \"Partial inline size used for array copy acceleration.\")          \\\n-          range(-1, 64)                                                     \\\n+  product(intx, ArrayOperationPartialInlineSize, 0, DIAGNOSTIC,             \\\n+          \"Partial inline size used for small array operations\"             \\\n+          \"(e.g. copy,cmp) acceleration.\")                                  \\\n+          range(0, 64)                                                      \\\n@@ -130,4 +131,0 @@\n-  develop(bool, IdealizedNumerics, false,                                   \\\n-          \"Check performance difference allowing FP \"                       \\\n-          \"associativity and commutativity...\")                             \\\n-                                                                            \\\n@@ -161,3 +158,0 @@\n-  develop(bool, OptoRemoveUseless, true,                                    \\\n-          \"Remove useless nodes after parsing\")                             \\\n-                                                                            \\\n@@ -731,0 +725,3 @@\n+  product(bool, UseVectorStubs, false, EXPERIMENTAL,                        \\\n+          \"Use stubs for vector transcendental operations\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -683,0 +683,1 @@\n+  case vmIntrinsics::_VectorMaskOp:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -441,2 +441,3 @@\n-  CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), allow_inline, _input_not_const);\n-  assert(!_input_not_const, \"sanity\"); \/\/ shouldn't have been scheduled for inlining in the first place\n+  bool input_not_const = true;\n+  CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), allow_inline, input_not_const);\n+  assert(!input_not_const, \"sanity\"); \/\/ shouldn't have been scheduled for inlining in the first place\n@@ -1193,0 +1194,1 @@\n+  address _call_addr;\n@@ -1195,2 +1197,2 @@\n-  NativeCallGenerator(ciMethod* m, ciNativeEntryPoint* nep)\n-   : CallGenerator(m), _nep(nep) {}\n+  NativeCallGenerator(ciMethod* m, address call_addr, ciNativeEntryPoint* nep)\n+   : CallGenerator(m), _call_addr(call_addr), _nep(nep) {}\n@@ -1204,1 +1206,1 @@\n-  Node* call = kit.make_native_call(tf(), method()->arg_size(), _nep); \/\/ -fallback, - nep\n+  Node* call = kit.make_native_call(_call_addr, tf(), method()->arg_size(), _nep); \/\/ -fallback, - nep\n@@ -1208,2 +1210,1 @@\n-  address addr = _nep->entry_point();\n-    kit.C->log()->elem(\"l2n_intrinsification_success bci='%d' entry_point='\" INTPTR_FORMAT \"'\", jvms->bci(), p2i(addr));\n+    kit.C->log()->elem(\"l2n_intrinsification_success bci='%d' entry_point='\" INTPTR_FORMAT \"'\", jvms->bci(), p2i(_call_addr));\n@@ -1333,2 +1334,4 @@\n-      Node* nep = kit.argument(callee->arg_size() - 1);\n-      if (nep->Opcode() == Op_ConP) {\n+      Node* addr_n = kit.argument(1); \/\/ target address\n+      Node* nep_n = kit.argument(callee->arg_size() - 1); \/\/ NativeEntryPoint\n+      \/\/ This check needs to be kept in sync with the one in CallStaticJavaNode::Ideal\n+      if (addr_n->Opcode() == Op_ConL && nep_n->Opcode() == Op_ConP) {\n@@ -1336,3 +1339,5 @@\n-        const TypeOopPtr* oop_ptr = nep->bottom_type()->is_oopptr();\n-        ciNativeEntryPoint* nep = oop_ptr->const_oop()->as_native_entry_point();\n-        return new NativeCallGenerator(callee, nep);\n+        const TypeLong* addr_t = addr_n->bottom_type()->is_long();\n+        const TypeOopPtr* nep_t = nep_n->bottom_type()->is_oopptr();\n+        address addr = (address) addr_t->get_con();\n+        ciNativeEntryPoint* nep = nep_t->const_oop()->as_native_entry_point();\n+        return new NativeCallGenerator(callee, addr, nep);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -741,1 +741,3 @@\n-        OptoRegPair regs = match->c_return_value(ideal_reg);\n+        OptoRegPair regs = Opcode() == Op_CallLeafVector\n+          ? match->vector_return_value(ideal_reg)      \/\/ Calls into assembly vector routine\n+          : match->c_return_value(ideal_reg);\n@@ -743,0 +745,12 @@\n+\n+        if (Opcode() == Op_CallLeafVector) {\n+          \/\/ If the return is in vector, compute appropriate regmask taking into account the whole range\n+          if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n+            if(OptoReg::is_valid(regs.second())) {\n+              for (OptoReg::Name r = regs.first(); r <= regs.second(); r = OptoReg::add(r, 1)) {\n+                rm.Insert(r);\n+              }\n+            }\n+          }\n+        }\n+\n@@ -1120,0 +1134,6 @@\n+    } else if (iid == vmIntrinsics::_linkToNative) {\n+      if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP \/* NEP *\/\n+          && in(TypeFunc::Parms + 1)->Opcode() == Op_ConL \/* address *\/) {\n+        phase->C->prepend_late_inline(cg);\n+        set_generator(NULL);\n+      }\n@@ -1386,0 +1406,5 @@\n+uint CallLeafVectorNode::size_of() const { return sizeof(*this); }\n+bool CallLeafVectorNode::cmp( const Node &n ) const {\n+  CallLeafVectorNode &call = (CallLeafVectorNode&)n;\n+  return CallLeafNode::cmp(call) && _num_bits == call._num_bits;\n+}\n@@ -1464,0 +1489,15 @@\n+void CallLeafVectorNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {\n+#ifdef ASSERT\n+  assert(tf()->range_sig()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte == _num_bits,\n+         \"return vector size must match\");\n+  const TypeTuple* d = tf()->domain_sig();\n+  for (uint i = TypeFunc::Parms; i < d->cnt(); i++) {\n+    Node* arg = in(i);\n+    assert(arg->bottom_type()->is_vect()->length_in_bytes() * BitsPerByte == _num_bits,\n+           \"vector argument size must match\");\n+  }\n+#endif\n+\n+  SharedRuntime::vector_calling_convention(parm_regs, _num_bits, argcnt);\n+}\n+\n@@ -1566,0 +1606,1 @@\n+  assert(_jvms == NULL || ((uintptr_t)_jvms->map() & 1) || _jvms->map() == this, \"inconsistent JVMState\");\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+class         CallLeafVectorNode;\n@@ -354,0 +355,12 @@\n+  virtual bool needs_deep_clone_jvms(Compile* C) { return false; }\n+  void clone_jvms(Compile* C) {\n+    if (jvms() != NULL) {\n+      if (needs_deep_clone_jvms(C)) {\n+        set_jvms(jvms()->clone_deep(C));\n+        jvms()->set_map_deep(this);\n+      } else {\n+        jvms()->clone_shallow(C)->bind_map(this);\n+      }\n+    }\n+  }\n+\n@@ -635,8 +648,2 @@\n-  \/\/ the node the JVMState must be cloned. Default is not to clone.\n-  virtual bool needs_clone_jvms(Compile* C) { return C->needs_clone_jvms(); }\n-  void clone_jvms(Compile* C) {\n-    if ((jvms() != NULL) && needs_clone_jvms(C)) {\n-      set_jvms(jvms()->clone_deep(C));\n-      jvms()->set_map_deep(this);\n-    }\n-  }\n+  \/\/ the node the JVMState must be deep cloned. Default is to shallow clone.\n+  virtual bool needs_deep_clone_jvms(Compile* C) { return C->needs_deep_clone_jvms(); }\n@@ -772,1 +779,1 @@\n-  \/\/ Late inlining modifies the JVMState, so we need to clone it\n+  \/\/ Late inlining modifies the JVMState, so we need to deep clone it\n@@ -774,2 +781,2 @@\n-  virtual bool needs_clone_jvms(Compile* C) {\n-    return is_boxing_method() || CallNode::needs_clone_jvms(C);\n+  virtual bool needs_deep_clone_jvms(Compile* C) {\n+    return is_boxing_method() || CallNode::needs_deep_clone_jvms(C);\n@@ -798,1 +805,1 @@\n-  \/\/ Late inlining modifies the JVMState, so we need to clone it\n+  \/\/ Late inlining modifies the JVMState, so we need to deep clone it\n@@ -800,2 +807,2 @@\n-  virtual bool needs_clone_jvms(Compile* C) {\n-    return IncrementalInlineVirtual || CallNode::needs_clone_jvms(C);\n+  virtual bool needs_deep_clone_jvms(Compile* C) {\n+    return IncrementalInlineVirtual || CallNode::needs_deep_clone_jvms(C);\n@@ -815,0 +822,1 @@\n+protected:\n@@ -903,0 +911,18 @@\n+\/\/------------------------------CallLeafVectorNode-------------------------------\n+\/\/ CallLeafNode but calling with vector calling convention instead.\n+class CallLeafVectorNode : public CallLeafNode {\n+private:\n+  uint _num_bits;\n+protected:\n+  virtual bool cmp( const Node &n ) const;\n+  virtual uint size_of() const; \/\/ Size is bigger\n+public:\n+  CallLeafVectorNode(const TypeFunc* tf, address addr, const char* name,\n+                   const TypePtr* adr_type, uint num_bits)\n+    : CallLeafNode(tf, addr, name, adr_type), _num_bits(num_bits)\n+  {\n+  }\n+  virtual int   Opcode() const;\n+  virtual void  calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;\n+};\n+\n@@ -962,2 +988,2 @@\n-  \/\/ Expansion modifies the JVMState, so we need to clone it\n-  virtual bool needs_clone_jvms(Compile* C) { return true; }\n+  \/\/ Expansion modifies the JVMState, so we need to deep clone it\n+  virtual bool needs_deep_clone_jvms(Compile* C) { return true; }\n@@ -1176,2 +1202,2 @@\n-  \/\/ Expansion modifies the JVMState, so we need to clone it\n-  virtual bool needs_clone_jvms(Compile* C) { return true; }\n+  \/\/ Expansion modifies the JVMState, so we need to deep clone it\n+  virtual bool needs_deep_clone_jvms(Compile* C) { return true; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":44,"deletions":18,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -112,0 +112,15 @@\n+  case Op_CastFF: {\n+    Node* cast = new CastFFNode(n, t, carry_dependency);\n+    cast->set_req(0, c);\n+    return cast;\n+  }\n+  case Op_CastDD: {\n+    Node* cast = new CastDDNode(n, t, carry_dependency);\n+    cast->set_req(0, c);\n+    return cast;\n+  }\n+  case Op_CastVV: {\n+    Node* cast = new CastVVNode(n, t, carry_dependency);\n+    cast->set_req(0, c);\n+    return cast;\n+  }\n@@ -591,0 +606,18 @@\n+\n+Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type) {\n+  Node* cast= NULL;\n+  if (type->isa_int()) {\n+    cast = make_cast(Op_CastII, c, in, type, true);\n+  } else if (type->isa_long()) {\n+    cast = make_cast(Op_CastLL, c, in, type, true);\n+  } else if (type->isa_float()) {\n+    cast = make_cast(Op_CastFF, c, in, type, true);\n+  } else if (type->isa_double()) {\n+    cast = make_cast(Op_CastDD, c, in, type, true);\n+  } else if (type->isa_vect()) {\n+    cast = make_cast(Op_CastVV, c, in, type, true);\n+  } else if (type->isa_ptr()) {\n+    cast = make_cast(Op_CastPP, c, in, type, true);\n+  }\n+  return cast;\n+}\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+\n+  static Node* make_cast_for_type(Node* c, Node* in, const Type* type);\n@@ -81,0 +83,5 @@\n+  CastIINode(Node* ctrl, Node* n, const Type* t, bool carry_dependency = false, bool range_check_dependency = false)\n+    : ConstraintCastNode(n, t, carry_dependency), _range_check_dependency(range_check_dependency) {\n+    init_class_id(Class_CastII);\n+    init_req(0, ctrl);\n+  }\n@@ -106,0 +113,5 @@\n+  CastLLNode(Node* ctrl, Node* n, const Type* t, bool carry_dependency = false)\n+    : ConstraintCastNode(n, t, carry_dependency) {\n+    init_class_id(Class_CastLL);\n+    init_req(0, ctrl);\n+  }\n@@ -118,0 +130,31 @@\n+class CastFFNode: public ConstraintCastNode {\n+public:\n+  CastFFNode(Node* n, const Type* t, bool carry_dependency = false)\n+          : ConstraintCastNode(n, t, carry_dependency){\n+    init_class_id(Class_CastFF);\n+  }\n+  virtual int Opcode() const;\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+};\n+\n+class CastDDNode: public ConstraintCastNode {\n+public:\n+  CastDDNode(Node* n, const Type* t, bool carry_dependency = false)\n+          : ConstraintCastNode(n, t, carry_dependency){\n+    init_class_id(Class_CastDD);\n+  }\n+  virtual int Opcode() const;\n+  virtual uint ideal_reg() const { return Op_RegD; }\n+};\n+\n+class CastVVNode: public ConstraintCastNode {\n+public:\n+  CastVVNode(Node* n, const Type* t, bool carry_dependency = false)\n+          : ConstraintCastNode(n, t, carry_dependency){\n+    init_class_id(Class_CastVV);\n+  }\n+  virtual int Opcode() const;\n+  virtual uint ideal_reg() const { return in(1)->ideal_reg(); }\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2009,1 +2009,0 @@\n-      assert(phi_type->isa_int() || phi_type->isa_ptr() || phi_type->isa_long(), \"bad phi type\");\n@@ -2013,5 +2012,1 @@\n-      if (phi_type->isa_int()) {\n-        cast = ConstraintCastNode::make_cast(Op_CastII, r, uin, phi_type, true);\n-      } else if (phi_type->isa_long()) {\n-        cast = ConstraintCastNode::make_cast(Op_CastLL, r, uin, phi_type, true);\n-      } else {\n+      if (phi_type->isa_ptr()) {\n@@ -2048,0 +2043,2 @@\n+      } else {\n+        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -816,1 +816,1 @@\n-          if (ireg == Op_VecA) {\n+          if (Matcher::implements_scalable_vector && ireg == Op_VecA) {\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+macro(CallLeafVector)\n@@ -65,0 +66,2 @@\n+macro(CastDD)\n+macro(CastFF)\n@@ -67,0 +70,1 @@\n+macro(CastVV)\n@@ -419,0 +423,1 @@\n+macro(VectorCmpMasked)\n@@ -420,0 +425,4 @@\n+macro(VectorMaskOp)\n+macro(VectorMaskTrueCount)\n+macro(VectorMaskFirstTrue)\n+macro(VectorMaskLastTrue)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -544,1 +544,0 @@\n-                  _save_argument_registers(false),\n@@ -841,1 +840,0 @@\n-                  bool save_arg_registers,\n@@ -846,1 +844,0 @@\n-    _save_argument_registers(save_arg_registers),\n@@ -3451,0 +3448,1 @@\n+  case Op_CallLeafVector:\n@@ -3628,2 +3626,0 @@\n-    \/\/ platform dependent reshaping of the address expression\n-    reshape_address(n->as_AddP());\n@@ -3910,0 +3906,1 @@\n+  case Op_VectorCmpMasked:\n@@ -4567,0 +4564,1 @@\n+  ciType* subelem = subk;\n@@ -4568,1 +4566,0 @@\n-    ciArrayKlass* ak = superelem->as_array_klass();\n@@ -4571,0 +4568,3 @@\n+  if (subelem->is_array_klass()) {\n+    subelem = subelem->as_array_klass()->base_element_type();\n+  }\n@@ -4577,0 +4577,1 @@\n+        !(subelem->is_klass() && subelem->as_klass()->is_interface()) &&\n@@ -4578,1 +4579,1 @@\n-      return SSC_always_false;\n+      return SSC_always_false;  \/\/ (2) true path dead; no dynamic test needed\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -249,1 +249,0 @@\n-  const bool            _save_argument_registers; \/\/ save\/restore arg regs for trampolines\n@@ -490,2 +489,0 @@\n-  void reshape_address(AddPNode* n);\n-\n@@ -519,1 +516,0 @@\n-  bool              save_argument_registers() const { return _save_argument_registers; }\n@@ -821,1 +817,1 @@\n-  bool                      needs_clone_jvms();\n+  bool                      needs_deep_clone_jvms();\n@@ -906,1 +902,1 @@\n-  ciMethod* optimize_inlining(ciMethod* caller, ciInstanceKlass* klass,\n+  ciMethod* optimize_inlining(ciMethod* caller, ciInstanceKlass* klass, ciKlass* holder,\n@@ -1055,1 +1051,1 @@\n-          bool save_arg_registers, bool return_pc, DirectiveSet* directive);\n+          bool return_pc, DirectiveSet* directive);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -780,4 +780,8 @@\n-#if defined(IA32)\n-  if (!phase->C->method()->is_strict())\n-    \/\/ Can't trust native compilers to properly fold strict double\n-    \/\/ division with round-to-zero on this platform.\n+  \/\/ IA32 would only execute this for non-strict FP, which is never the\n+  \/\/ case now.\n+#if ! defined(IA32)\n+  \/\/ If divisor is a constant and not zero, divide them numbers\n+  if( t1->base() == Type::DoubleCon &&\n+      t2->base() == Type::DoubleCon &&\n+      t2->getd() != 0.0 ) \/\/ could be negative zero\n+    return TypeD::make( t1->getd()\/t2->getd() );\n@@ -785,7 +789,0 @@\n-    {\n-      \/\/ If divisor is a constant and not zero, divide them numbers\n-      if( t1->base() == Type::DoubleCon &&\n-          t2->base() == Type::DoubleCon &&\n-          t2->getd() != 0.0 ) \/\/ could be negative zero\n-        return TypeD::make( t1->getd()\/t2->getd() );\n-    }\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -118,2 +118,0 @@\n-  \/\/ We do this before the strict f.p. check below because the\n-  \/\/ intrinsics handle strict f.p. correctly.\n@@ -156,6 +154,0 @@\n-  \/\/ If explicit rounding is required, do not inline strict into non-strict code (or the reverse).\n-  if (Matcher::strict_fp_requires_explicit_rounding &&\n-      caller->is_strict() != callee->is_strict()) {\n-    allow_inline = false;\n-  }\n-\n@@ -307,2 +299,1 @@\n-      if (singleton != NULL &&\n-          (!callee->is_default_method() || callee->is_overpass()) \/* CHA doesn't support default methods yet *\/) {\n+      if (singleton != NULL) {\n@@ -328,1 +319,1 @@\n-            dependencies()->assert_unique_concrete_method(declared_interface, cha_monomorphic_target);\n+            dependencies()->assert_unique_concrete_method(declared_interface, cha_monomorphic_target, declared_interface, callee);\n@@ -571,3 +562,1 @@\n-    ciInstanceKlass* sender_klass =\n-        calling_klass->is_unsafe_anonymous() ? calling_klass->unsafe_anonymous_host() :\n-                                               calling_klass;\n+    ciInstanceKlass* sender_klass = calling_klass;\n@@ -692,3 +681,0 @@\n-    \/\/ Round double result after a call from strict to non-strict code\n-    round_double_result(cg->method());\n-\n@@ -1092,1 +1078,1 @@\n-  ciMethod* optimized_virtual_method = optimize_inlining(caller, klass, callee,\n+  ciMethod* optimized_virtual_method = optimize_inlining(caller, klass, holder, callee,\n@@ -1107,1 +1093,1 @@\n-ciMethod* Compile::optimize_inlining(ciMethod* caller, ciInstanceKlass* klass,\n+ciMethod* Compile::optimize_inlining(ciMethod* caller, ciInstanceKlass* klass, ciKlass* holder,\n@@ -1120,0 +1106,4 @@\n+  if (receiver_type == NULL) {\n+    return NULL; \/\/ no receiver type info\n+  }\n+\n@@ -1123,8 +1113,7 @@\n-  if (receiver_type != NULL) {\n-    \/\/ Array methods are all inherited from Object, and are monomorphic.\n-    \/\/ finalize() call on array is not allowed.\n-    if (receiver_type->isa_aryptr() &&\n-        callee->holder() == env()->Object_klass() &&\n-        callee->name() != ciSymbols::finalize_method_name()) {\n-      return callee;\n-    }\n+  \/\/ Array methods are all inherited from Object, and are monomorphic.\n+  \/\/ finalize() call on array is not allowed.\n+  if (receiver_type->isa_aryptr() &&\n+      callee->holder() == env()->Object_klass() &&\n+      callee->name() != ciSymbols::finalize_method_name()) {\n+    return callee;\n+  }\n@@ -1132,4 +1121,4 @@\n-    \/\/ All other interesting cases are instance klasses.\n-    if (!receiver_type->isa_instptr()) {\n-      return NULL;\n-    }\n+  \/\/ All other interesting cases are instance klasses.\n+  if (!receiver_type->isa_instptr()) {\n+    return NULL;\n+  }\n@@ -1137,9 +1126,8 @@\n-    ciInstanceKlass *ikl = receiver_type->klass()->as_instance_klass();\n-    if (ikl->is_loaded() && ikl->is_initialized() && !ikl->is_interface() &&\n-        (ikl == actual_receiver || ikl->is_subtype_of(actual_receiver))) {\n-      \/\/ ikl is a same or better type than the original actual_receiver,\n-      \/\/ e.g. static receiver from bytecodes.\n-      actual_receiver = ikl;\n-      \/\/ Is the actual_receiver exact?\n-      actual_receiver_is_exact = receiver_type->klass_is_exact();\n-    }\n+  ciInstanceKlass *ikl = receiver_type->klass()->as_instance_klass();\n+  if (ikl->is_loaded() && ikl->is_initialized() && !ikl->is_interface() &&\n+      (ikl == actual_receiver || ikl->is_subtype_of(actual_receiver))) {\n+    \/\/ ikl is a same or better type than the original actual_receiver,\n+    \/\/ e.g. static receiver from bytecodes.\n+    actual_receiver = ikl;\n+    \/\/ Is the actual_receiver exact?\n+    actual_receiver_is_exact = receiver_type->klass_is_exact();\n@@ -1150,0 +1138,2 @@\n+\n+  \/\/ Validate receiver info against target method.\n@@ -1151,20 +1141,5 @@\n-    assert(!cha_monomorphic_target->is_abstract(), \"\");\n-    \/\/ Look at the method-receiver type.  Does it add \"too much information\"?\n-    ciKlass*    mr_klass = cha_monomorphic_target->holder();\n-    const Type* mr_type  = TypeInstPtr::make(TypePtr::BotPTR, mr_klass);\n-    if (receiver_type == NULL || !receiver_type->higher_equal(mr_type)) {\n-      \/\/ Calling this method would include an implicit cast to its holder.\n-      \/\/ %%% Not yet implemented.  Would throw minor asserts at present.\n-      \/\/ %%% The most common wins are already gained by +UseUniqueSubclasses.\n-      \/\/ To fix, put the higher_equal check at the call of this routine,\n-      \/\/ and add a CheckCastPP to the receiver.\n-      if (TraceDependencies) {\n-        tty->print_cr(\"found unique CHA method, but could not cast up\");\n-        tty->print(\"  method  = \");\n-        cha_monomorphic_target->print();\n-        tty->cr();\n-      }\n-      if (log() != NULL) {\n-        log()->elem(\"missed_CHA_opportunity klass='%d' method='%d'\",\n-                       log()->identify(klass),\n-                       log()->identify(cha_monomorphic_target));\n+    bool has_receiver = !cha_monomorphic_target->is_static();\n+    bool is_interface_holder = cha_monomorphic_target->holder()->is_interface();\n+    if (has_receiver && !is_interface_holder) {\n+      if (!cha_monomorphic_target->holder()->is_subtype_of(receiver_type->klass())) {\n+        cha_monomorphic_target = NULL; \/\/ not a subtype\n@@ -1172,1 +1147,0 @@\n-      cha_monomorphic_target = NULL;\n@@ -1186,1 +1160,1 @@\n-      dependencies()->assert_unique_concrete_method(actual_receiver, cha_monomorphic_target);\n+      dependencies()->assert_unique_concrete_method(actual_receiver, cha_monomorphic_target, holder, callee);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":36,"deletions":62,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -1055,0 +1055,1 @@\n+    case Op_CallLeafVector:\n@@ -1143,1 +1144,2 @@\n-                  strcmp(call->as_CallLeaf()->_name, \"vectorizedMismatch\") == 0)\n+                  strcmp(call->as_CallLeaf()->_name, \"vectorizedMismatch\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"get_class_id_intrinsic\") == 0)\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2432,17 +2432,0 @@\n-void GraphKit::round_double_result(ciMethod* dest_method) {\n-  if (Matcher::strict_fp_requires_explicit_rounding) {\n-    \/\/ If a strict caller invokes a non-strict callee, round a double result.\n-    \/\/ A non-strict method may return a double value which has an extended exponent,\n-    \/\/ but this must not be visible in a caller which is strict.\n-    BasicType result_type = dest_method->return_type()->basic_type();\n-    assert(method() != NULL, \"must have caller context\");\n-    if( result_type == T_DOUBLE && method()->is_strict() && !dest_method->is_strict() ) {\n-      \/\/ Destination method's return value is on top of stack\n-      \/\/ dstore_rounding() does gvn.transform\n-      Node *result = pop_pair();\n-      result = dstore_rounding(result);\n-      push_pair(result);\n-    }\n-  }\n-}\n-\n@@ -2471,1 +2454,1 @@\n-    if (_method->flags().is_strict() && UseSSE == 0) {\n+    if (UseSSE == 0) {\n@@ -2485,1 +2468,1 @@\n-    if (_method->flags().is_strict() && UseSSE < 2) {\n+    if (UseSSE < 2) {\n@@ -2617,0 +2600,3 @@\n+  } else  if (flags & RC_VECTOR){\n+    uint num_bits = call_type->range_sig()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte;\n+    call = new CallLeafVectorNode(call_type, call_addr, call_name, adr_type, num_bits);\n@@ -2696,2 +2682,7 @@\n-Node* GraphKit::make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {\n-  uint n_filtered_args = nargs - 2; \/\/ -fallback, -nep;\n+Node* GraphKit::make_native_call(address call_addr, const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {\n+  \/\/ Select just the actual call args to pass on\n+  \/\/ [MethodHandle fallback, long addr, HALF addr, ... args , NativeEntryPoint nep]\n+  \/\/                                             |          |\n+  \/\/                                             V          V\n+  \/\/                                             [ ... args ]\n+  uint n_filtered_args = nargs - 4; \/\/ -fallback, -addr (2), -nep;\n@@ -2707,1 +2698,1 @@\n-      uint vm_unfiltered_arg_pos = vm_arg_pos + 1; \/\/ +1 to skip fallback handle argument\n+      uint vm_unfiltered_arg_pos = vm_arg_pos + 3; \/\/ +3 to skip fallback handle argument and addr (2 since long)\n@@ -2743,1 +2734,0 @@\n-  address call_addr = nep->entry_point();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":13,"deletions":23,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -810,1 +810,0 @@\n-  void round_double_result(ciMethod* dest_method);\n@@ -835,1 +834,1 @@\n-  Node* make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep);\n+  Node* make_native_call(address call_addr, const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep);\n@@ -844,0 +843,1 @@\n+    RC_VECTOR = 64,             \/\/ CallLeafVectorNode\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -356,1 +356,2 @@\n-                     bool require_atomic_access) {\n+                     bool require_atomic_access,\n+                     MemNode::MemOrd mo) {\n@@ -364,1 +365,1 @@\n-    ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, MemNode::unordered);\n+    ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, mo);\n@@ -366,1 +367,1 @@\n-    ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, MemNode::unordered);\n+    ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,1 +224,1 @@\n-             bool require_atomic_access = false);\n+             bool require_atomic_access = false, MemNode::MemOrd mo = MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -440,1 +440,2 @@\n-  if (best->in(0) == not_null_block->head()) {\n+  Node* ctrl = best->in(0);\n+  if (get_block_for_node(ctrl) == not_null_block) {\n@@ -897,0 +898,1 @@\n+    case Op_CallLeafVector:\n@@ -907,1 +909,1 @@\n-      \/\/ We use the c reg save policy here since Panama\n+      \/\/ We use the c reg save policy here since Foreign Linker\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,0 +61,4 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n+\n@@ -645,0 +649,2 @@\n+  case vmIntrinsics::_VectorMaskOp:\n+    return inline_vector_mask_operation();\n@@ -2977,5 +2983,17 @@\n-\/*\n-* oop -> myklass\n-* myklass->trace_id |= USED\n-* return myklass->trace_id & ~0x3\n-*\/\n+\/**\n+ * if oop->klass != null\n+ *   \/\/ normal class\n+ *   epoch = _epoch_state ? 2 : 1\n+ *   if oop->klass->trace_id & ((epoch << META_SHIFT) | epoch)) != epoch {\n+ *     ... \/\/ enter slow path when the klass is first recorded or the epoch of JFR shifts\n+ *   }\n+ *   id = oop->klass->trace_id >> TRACE_ID_SHIFT \/\/ normal class path\n+ * else\n+ *   \/\/ primitive class\n+ *   if oop->array_klass != null\n+ *     id = (oop->array_klass->trace_id >> TRACE_ID_SHIFT) + 1 \/\/ primitive class path\n+ *   else\n+ *     id = LAST_TYPE_ID + 1 \/\/ void class path\n+ *   if (!signaled)\n+ *     signaled = true\n+ *\/\n@@ -2983,12 +3001,1 @@\n-  Node* cls = null_check(argument(0), T_OBJECT);\n-  Node* kls = load_klass_from_mirror(cls, false, NULL, 0);\n-  kls = null_check(kls, T_OBJECT);\n-\n-  ByteSize offset = KLASS_TRACE_ID_OFFSET;\n-  Node* insp = basic_plus_adr(kls, in_bytes(offset));\n-  Node* tvalue = make_load(NULL, insp, TypeLong::LONG, T_LONG, MemNode::unordered);\n-\n-  Node* clsused = longcon(0x01l); \/\/ set the class bit\n-  Node* orl = _gvn.transform(new OrLNode(tvalue, clsused));\n-  const TypePtr *adr_type = _gvn.type(insp)->isa_ptr();\n-  store_to_memory(control(), insp, orl, T_LONG, adr_type, MemNode::unordered);\n+  Node* cls = argument(0);\n@@ -2996,10 +3003,56 @@\n-#ifdef TRACE_ID_META_BITS\n-  Node* mbits = longcon(~TRACE_ID_META_BITS);\n-  tvalue = _gvn.transform(new AndLNode(tvalue, mbits));\n-#endif\n-#ifdef TRACE_ID_SHIFT\n-  Node* cbits = intcon(TRACE_ID_SHIFT);\n-  tvalue = _gvn.transform(new URShiftLNode(tvalue, cbits));\n-#endif\n-\n-  set_result(tvalue);\n+  IdealKit ideal(this);\n+#define __ ideal.\n+  IdealVariable result(ideal); __ declarations_done();\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+                                                 basic_plus_adr(cls, java_lang_Class::klass_offset()),\n+                                                 TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+\n+\n+  __ if_then(kls, BoolTest::ne, null()); {\n+    Node* kls_trace_id_addr = basic_plus_adr(kls, in_bytes(KLASS_TRACE_ID_OFFSET));\n+    Node* kls_trace_id_raw = ideal.load(ideal.ctrl(), kls_trace_id_addr,TypeLong::LONG, T_LONG, Compile::AliasIdxRaw);\n+\n+    Node* epoch_address = makecon(TypeRawPtr::make(Jfr::epoch_address()));\n+    Node* epoch = ideal.load(ideal.ctrl(), epoch_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n+    epoch = _gvn.transform(new LShiftLNode(longcon(1), epoch));\n+    Node* mask = _gvn.transform(new LShiftLNode(epoch, intcon(META_SHIFT)));\n+    mask = _gvn.transform(new OrLNode(mask, epoch));\n+    Node* kls_trace_id_raw_and_mask = _gvn.transform(new AndLNode(kls_trace_id_raw, mask));\n+\n+    float unlikely  = PROB_UNLIKELY(0.999);\n+    __ if_then(kls_trace_id_raw_and_mask, BoolTest::ne, epoch, unlikely); {\n+      sync_kit(ideal);\n+      make_runtime_call(RC_LEAF,\n+                        OptoRuntime::get_class_id_intrinsic_Type(),\n+                        CAST_FROM_FN_PTR(address, Jfr::get_class_id_intrinsic),\n+                        \"get_class_id_intrinsic\",\n+                        TypePtr::BOTTOM,\n+                        kls);\n+      ideal.sync_kit(this);\n+    } __ end_if();\n+\n+    ideal.set(result,  _gvn.transform(new URShiftLNode(kls_trace_id_raw, ideal.ConI(TRACE_ID_SHIFT))));\n+  } __ else_(); {\n+    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+                                                   basic_plus_adr(cls, java_lang_Class::array_klass_offset()),\n+                                                   TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+    __ if_then(array_kls, BoolTest::ne, null()); {\n+      Node* array_kls_trace_id_addr = basic_plus_adr(array_kls, in_bytes(KLASS_TRACE_ID_OFFSET));\n+      Node* array_kls_trace_id_raw = ideal.load(ideal.ctrl(), array_kls_trace_id_addr, TypeLong::LONG, T_LONG, Compile::AliasIdxRaw);\n+      Node* array_kls_trace_id = _gvn.transform(new URShiftLNode(array_kls_trace_id_raw, ideal.ConI(TRACE_ID_SHIFT)));\n+      ideal.set(result, _gvn.transform(new AddLNode(array_kls_trace_id, longcon(1))));\n+    } __ else_(); {\n+      \/\/ void class case\n+      ideal.set(result, _gvn.transform(longcon(LAST_TYPE_ID + 1)));\n+    } __ end_if();\n+\n+    Node* signaled_flag_address = makecon(TypeRawPtr::make(Jfr::signal_address()));\n+    Node* signaled = ideal.load(ideal.ctrl(), signaled_flag_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw, true, MemNode::acquire);\n+    __ if_then(signaled, BoolTest::ne, ideal.ConI(1)); {\n+      ideal.store(ideal.ctrl(), signaled_flag_address, ideal.ConI(1), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::release, true);\n+    } __ end_if();\n+  } __ end_if();\n+\n+  final_sync(ideal);\n+  set_result(ideal.value(result));\n+#undef __\n@@ -3007,1 +3060,0 @@\n-\n@@ -3744,1 +3796,1 @@\n-    bool exclude_flat = UseFlatArray && bs->array_copy_requires_gc_barriers(true, T_OBJECT, false, BarrierSetC2::Parsing) &&\n+    bool exclude_flat = UseFlatArray && bs->array_copy_requires_gc_barriers(true, T_OBJECT, false, false, BarrierSetC2::Parsing) &&\n@@ -4489,1 +4541,1 @@\n-      if (UseFlatArray && bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing) &&\n+      if (UseFlatArray && bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, false, BarrierSetC2::Parsing) &&\n@@ -4503,1 +4555,1 @@\n-        if (bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing)) {\n+        if (bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, false, BarrierSetC2::Parsing)) {\n@@ -5526,1 +5578,1 @@\n-  assert(UseVectorizedMismatchIntrinsic, \"not implementated on this platform\");\n+  assert(UseVectorizedMismatchIntrinsic, \"not implemented on this platform\");\n@@ -5528,6 +5580,6 @@\n-  address stubAddr = StubRoutines::vectorizedMismatch();\n-  if (stubAddr == NULL) {\n-    return false; \/\/ Intrinsic's stub is not implemented on this platform\n-  }\n-  const char* stubName = \"vectorizedMismatch\";\n-  int size_l = callee()->signature()->size();\n+  Node* obja    = argument(0); \/\/ Object\n+  Node* aoffset = argument(1); \/\/ long\n+  Node* objb    = argument(3); \/\/ Object\n+  Node* boffset = argument(4); \/\/ long\n+  Node* length  = argument(6); \/\/ int\n+  Node* scale   = argument(7); \/\/ int\n@@ -5536,15 +5588,6 @@\n-  Node* obja = argument(0);\n-  Node* aoffset = argument(1);\n-  Node* objb = argument(3);\n-  Node* boffset = argument(4);\n-  Node* length = argument(6);\n-  Node* scale = argument(7);\n-\n-  const Type* a_type = obja->Value(&_gvn);\n-  const Type* b_type = objb->Value(&_gvn);\n-  const TypeAryPtr* top_a = a_type->isa_aryptr();\n-  const TypeAryPtr* top_b = b_type->isa_aryptr();\n-  if (top_a == NULL || top_a->klass() == NULL ||\n-    top_b == NULL || top_b->klass() == NULL) {\n-    \/\/ failed array check\n-    return false;\n+  const TypeAryPtr* obja_t = _gvn.type(obja)->isa_aryptr();\n+  const TypeAryPtr* objb_t = _gvn.type(objb)->isa_aryptr();\n+  if (obja_t == NULL || obja_t->klass() == NULL ||\n+      objb_t == NULL || objb_t->klass() == NULL ||\n+      scale == top()) {\n+    return false; \/\/ failed input validation\n@@ -5553,3 +5596,0 @@\n-  Node* call;\n-  jvms()->set_should_reexecute(true);\n-\n@@ -5559,4 +5599,106 @@\n-  call = make_runtime_call(RC_LEAF,\n-    OptoRuntime::vectorizedMismatch_Type(),\n-    stubAddr, stubName, TypePtr::BOTTOM,\n-    obja_adr, objb_adr, length, scale);\n+  \/\/ Partial inlining handling for inputs smaller than ArrayOperationPartialInlineSize bytes in size.\n+  \/\/\n+  \/\/    inline_limit = ArrayOperationPartialInlineSize \/ element_size;\n+  \/\/    if (length <= inline_limit) {\n+  \/\/      inline_path:\n+  \/\/        vmask   = VectorMaskGen length\n+  \/\/        vload1  = LoadVectorMasked obja, vmask\n+  \/\/        vload2  = LoadVectorMasked objb, vmask\n+  \/\/        result1 = VectorCmpMasked vload1, vload2, vmask\n+  \/\/    } else {\n+  \/\/      call_stub_path:\n+  \/\/        result2 = call vectorizedMismatch_stub(obja, objb, length, scale)\n+  \/\/    }\n+  \/\/    exit_block:\n+  \/\/      return Phi(result1, result2);\n+  \/\/\n+  enum { inline_path = 1,  \/\/ input is small enough to process it all at once\n+         stub_path   = 2,  \/\/ input is too large; call into the VM\n+         PATH_LIMIT  = 3\n+  };\n+\n+  Node* exit_block = new RegionNode(PATH_LIMIT);\n+  Node* result_phi = new PhiNode(exit_block, TypeInt::INT);\n+  Node* memory_phi = new PhiNode(exit_block, Type::MEMORY, TypePtr::BOTTOM);\n+\n+  Node* call_stub_path = control();\n+\n+  BasicType elem_bt = T_ILLEGAL;\n+\n+  const TypeInt* scale_t = _gvn.type(scale)->is_int();\n+  if (scale_t->is_con()) {\n+    switch (scale_t->get_con()) {\n+      case 0: elem_bt = T_BYTE;  break;\n+      case 1: elem_bt = T_SHORT; break;\n+      case 2: elem_bt = T_INT;   break;\n+      case 3: elem_bt = T_LONG;  break;\n+\n+      default: elem_bt = T_ILLEGAL; break; \/\/ not supported\n+    }\n+  }\n+\n+  int inline_limit = 0;\n+  bool do_partial_inline = false;\n+\n+  if (elem_bt != T_ILLEGAL && ArrayOperationPartialInlineSize > 0) {\n+    inline_limit = ArrayOperationPartialInlineSize \/ type2aelembytes(elem_bt);\n+    do_partial_inline = inline_limit >= 16;\n+  }\n+\n+  if (do_partial_inline) {\n+    assert(elem_bt != T_ILLEGAL, \"sanity\");\n+\n+    const TypeVect* vt = TypeVect::make(elem_bt, inline_limit);\n+\n+    if (Matcher::match_rule_supported_vector(Op_VectorMaskGen,    inline_limit, elem_bt) &&\n+        Matcher::match_rule_supported_vector(Op_LoadVectorMasked, inline_limit, elem_bt) &&\n+        Matcher::match_rule_supported_vector(Op_VectorCmpMasked,  inline_limit, elem_bt)) {\n+\n+      Node* cmp_length = _gvn.transform(new CmpINode(length, intcon(inline_limit)));\n+      Node* bol_gt     = _gvn.transform(new BoolNode(cmp_length, BoolTest::gt));\n+\n+      call_stub_path = generate_guard(bol_gt, NULL, PROB_MIN);\n+\n+      if (!stopped()) {\n+        Node* casted_length = _gvn.transform(new CastIINode(control(), length, TypeInt::make(0, inline_limit, Type::WidenMin)));\n+\n+        const TypePtr* obja_adr_t = _gvn.type(obja_adr)->isa_ptr();\n+        const TypePtr* objb_adr_t = _gvn.type(objb_adr)->isa_ptr();\n+        Node* obja_adr_mem = memory(C->get_alias_index(obja_adr_t));\n+        Node* objb_adr_mem = memory(C->get_alias_index(objb_adr_t));\n+\n+        Node* vmask      = _gvn.transform(new VectorMaskGenNode(ConvI2X(casted_length), TypeVect::VECTMASK, elem_bt));\n+        Node* vload_obja = _gvn.transform(new LoadVectorMaskedNode(control(), obja_adr_mem, obja_adr, obja_adr_t, vt, vmask));\n+        Node* vload_objb = _gvn.transform(new LoadVectorMaskedNode(control(), objb_adr_mem, objb_adr, objb_adr_t, vt, vmask));\n+        Node* result     = _gvn.transform(new VectorCmpMaskedNode(vload_obja, vload_objb, vmask, TypeInt::INT));\n+\n+        exit_block->init_req(inline_path, control());\n+        memory_phi->init_req(inline_path, map()->memory());\n+        result_phi->init_req(inline_path, result);\n+\n+        C->set_max_vector_size(MAX2((uint)ArrayOperationPartialInlineSize, C->max_vector_size()));\n+        clear_upper_avx();\n+      }\n+    }\n+  }\n+\n+  if (call_stub_path != NULL) {\n+    set_control(call_stub_path);\n+\n+    Node* call = make_runtime_call(RC_LEAF,\n+                                   OptoRuntime::vectorizedMismatch_Type(),\n+                                   StubRoutines::vectorizedMismatch(), \"vectorizedMismatch\", TypePtr::BOTTOM,\n+                                   obja_adr, objb_adr, length, scale);\n+\n+    exit_block->init_req(stub_path, control());\n+    memory_phi->init_req(stub_path, map()->memory());\n+    result_phi->init_req(stub_path, _gvn.transform(new ProjNode(call, TypeFunc::Parms)));\n+  }\n+\n+  exit_block = _gvn.transform(exit_block);\n+  memory_phi = _gvn.transform(memory_phi);\n+  result_phi = _gvn.transform(result_phi);\n+\n+  set_control(exit_block);\n+  set_all_memory(memory_phi);\n+  set_result(result_phi);\n@@ -5564,2 +5706,0 @@\n-  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-  set_result(result);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":202,"deletions":62,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -350,0 +350,1 @@\n+  bool inline_vector_mask_operation();\n@@ -361,0 +362,1 @@\n+  Node* gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -218,0 +218,2 @@\n+  \/\/ TODO: reimplement JDK-8267151, dropped from jdk->lworld merge\n+\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -873,1 +873,2 @@\n-  Node_Array _dom_lca_tags;\n+  GrowableArray<jlong> _dom_lca_tags;\n+  uint _dom_lca_tags_round;\n@@ -875,1 +876,0 @@\n-  void   clear_dom_lca_tags();\n@@ -1069,1 +1069,0 @@\n-    _dom_lca_tags(arena()),  \/\/ Thread::resource_area\n@@ -1083,1 +1082,0 @@\n-    _dom_lca_tags(arena()),  \/\/ Thread::resource_area\n@@ -1351,0 +1349,1 @@\n+  \/\/ Return the inserted if.\n@@ -1490,1 +1489,1 @@\n-  Node *place_near_use( Node *useblock ) const;\n+  Node* place_outside_loop(Node* useblock, IdealLoopTree* loop) const;\n@@ -1620,1 +1619,9 @@\n-  bool is_safe_load_ctrl(Node* ctrl);\n+  Node* get_late_ctrl_with_anti_dep(LoadNode* n, Node* early, Node* LCA);\n+\n+  bool ctrl_of_use_out_of_loop(const Node* n, Node* n_ctrl, IdealLoopTree* n_loop, Node* ctrl);\n+\n+  bool ctrl_of_all_uses_out_of_loop(const Node* n, Node* n_ctrl, IdealLoopTree* n_loop);\n+\n+  Node* compute_early_ctrl(Node* n, Node* n_ctrl);\n+\n+  void try_sink_out_of_loop(Node* n);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1200,11 +1200,15 @@\n-\/\/------------------------------place_near_use---------------------------------\n-\/\/ Place some computation next to use but not inside inner loops.\n-\/\/ For inner loop uses move it to the preheader area.\n-Node *PhaseIdealLoop::place_near_use(Node *useblock) const {\n-  IdealLoopTree *u_loop = get_loop( useblock );\n-  if (u_loop->_irreducible) {\n-    return useblock;\n-  }\n-  if (u_loop->_child) {\n-    if (useblock == u_loop->_head && u_loop->_head->is_OuterStripMinedLoop()) {\n-      return u_loop->_head->in(LoopNode::EntryControl);\n+\/\/------------------------------place_outside_loop---------------------------------\n+\/\/ Place some computation outside of this loop on the path to the use passed as argument\n+Node* PhaseIdealLoop::place_outside_loop(Node* useblock, IdealLoopTree* loop) const {\n+  Node* head = loop->_head;\n+  assert(!loop->is_member(get_loop(useblock)), \"must be outside loop\");\n+  if (head->is_Loop() && head->as_Loop()->is_strip_mined()) {\n+    loop = loop->_parent;\n+    assert(loop->_head->is_OuterStripMinedLoop(), \"malformed strip mined loop\");\n+  }\n+\n+  \/\/ Pick control right outside the loop\n+  for (;;) {\n+    Node* dom = idom(useblock);\n+    if (loop->is_member(get_loop(dom))) {\n+      break;\n@@ -1212,1 +1216,1 @@\n-    return useblock;\n+    useblock = dom;\n@@ -1214,1 +1218,2 @@\n-  return u_loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n+  assert(find_non_split_ctrl(useblock) == useblock, \"should be non split control\");\n+  return useblock;\n@@ -1568,5 +1573,30 @@\n-  \/\/ See if a shared loop-varying computation has no loop-varying uses.\n-  \/\/ Happens if something is only used for JVM state in uncommon trap exits,\n-  \/\/ like various versions of induction variable+offset.  Clone the\n-  \/\/ computation per usage to allow it to sink out of the loop.\n-  if (has_ctrl(n) && !n->in(0)) {\/\/ n not dead and has no control edge (can float about)\n+  try_sink_out_of_loop(n);\n+\n+  try_move_store_after_loop(n);\n+\n+  \/\/ Remove multiple allocations of the same inline type\n+  if (n->is_InlineType()) {\n+    n->as_InlineType()->remove_redundant_allocations(&_igvn, this);\n+  }\n+\n+  \/\/ Check for Opaque2's who's loop has disappeared - who's input is in the\n+  \/\/ same loop nest as their output.  Remove 'em, they are no longer useful.\n+  if( n_op == Op_Opaque2 &&\n+      n->in(1) != NULL &&\n+      get_loop(get_ctrl(n)) == get_loop(get_ctrl(n->in(1))) ) {\n+    _igvn.replace_node( n, n->in(1) );\n+  }\n+}\n+\n+\/\/ See if a shared loop-varying computation has no loop-varying uses.\n+\/\/ Happens if something is only used for JVM state in uncommon trap exits,\n+\/\/ like various versions of induction variable+offset.  Clone the\n+\/\/ computation per usage to allow it to sink out of the loop.\n+void PhaseIdealLoop::try_sink_out_of_loop(Node* n) {\n+  if (has_ctrl(n) &&\n+      !n->is_Phi() &&\n+      !n->is_Bool() &&\n+      !n->is_Proj() &&\n+      !n->is_MergeMem() &&\n+      !n->is_CMove() &&\n+      n->Opcode() != Op_Opaque4) {\n@@ -1575,47 +1605,27 @@\n-    if( n_loop != _ltree_root ) {\n-      DUIterator_Fast imax, i = n->fast_outs(imax);\n-      for (; i < imax; i++) {\n-        Node* u = n->fast_out(i);\n-        if( !has_ctrl(u) )     break; \/\/ Found control user\n-        IdealLoopTree *u_loop = get_loop(get_ctrl(u));\n-        if( u_loop == n_loop ) break; \/\/ Found loop-varying use\n-        if( n_loop->is_member( u_loop ) ) break; \/\/ Found use in inner loop\n-        if( u->Opcode() == Op_Opaque1 ) break; \/\/ Found loop limit, bugfix for 4677003\n-      }\n-      bool did_break = (i < imax);  \/\/ Did we break out of the previous loop?\n-      if (!did_break && n->outcnt() > 1) { \/\/ All uses in outer loops!\n-        Node *late_load_ctrl = NULL;\n-        if (n->is_Load()) {\n-          \/\/ If n is a load, get and save the result from get_late_ctrl(),\n-          \/\/ to be later used in calculating the control for n's clones.\n-          clear_dom_lca_tags();\n-          late_load_ctrl = get_late_ctrl(n, n_ctrl);\n-        }\n-        \/\/ If n is a load, and the late control is the same as the current\n-        \/\/ control, then the cloning of n is a pointless exercise, because\n-        \/\/ GVN will ensure that we end up where we started.\n-        if (!n->is_Load() || (late_load_ctrl != n_ctrl && is_safe_load_ctrl(late_load_ctrl))) {\n-          Node* outer_loop_clone = NULL;\n-          for (DUIterator_Last jmin, j = n->last_outs(jmin); j >= jmin; ) {\n-            Node *u = n->last_out(j); \/\/ Clone private computation per use\n-            _igvn.rehash_node_delayed(u);\n-            Node *x = n->clone(); \/\/ Clone computation\n-            Node *x_ctrl = NULL;\n-            if( u->is_Phi() ) {\n-              \/\/ Replace all uses of normal nodes.  Replace Phi uses\n-              \/\/ individually, so the separate Nodes can sink down\n-              \/\/ different paths.\n-              uint k = 1;\n-              while( u->in(k) != n ) k++;\n-              u->set_req( k, x );\n-              \/\/ x goes next to Phi input path\n-              x_ctrl = u->in(0)->in(k);\n-              --j;\n-            } else {              \/\/ Normal use\n-              \/\/ Replace all uses\n-              for( uint k = 0; k < u->req(); k++ ) {\n-                if( u->in(k) == n ) {\n-                  u->set_req( k, x );\n-                  --j;\n-                }\n-              }\n+    if (n_loop != _ltree_root && n->outcnt() > 1) {\n+      \/\/ Compute early control: needed for anti-dependence analysis. It's also possible that as a result of\n+      \/\/ previous transformations in this loop opts round, the node can be hoisted now: early control will tell us.\n+      Node* early_ctrl = compute_early_ctrl(n, n_ctrl);\n+      if (n_loop->is_member(get_loop(early_ctrl)) && \/\/ check that this one can't be hoisted now\n+          ctrl_of_all_uses_out_of_loop(n, early_ctrl, n_loop)) { \/\/ All uses in outer loops!\n+        assert(!n->is_Store() && !n->is_LoadStore(), \"no node with a side effect\");\n+        Node* outer_loop_clone = NULL;\n+        for (DUIterator_Last jmin, j = n->last_outs(jmin); j >= jmin;) {\n+          Node* u = n->last_out(j); \/\/ Clone private computation per use\n+          _igvn.rehash_node_delayed(u);\n+          Node* x = n->clone(); \/\/ Clone computation\n+          Node* x_ctrl = NULL;\n+          if (u->is_Phi()) {\n+            \/\/ Replace all uses of normal nodes.  Replace Phi uses\n+            \/\/ individually, so the separate Nodes can sink down\n+            \/\/ different paths.\n+            uint k = 1;\n+            while (u->in(k) != n) k++;\n+            u->set_req(k, x);\n+            \/\/ x goes next to Phi input path\n+            x_ctrl = u->in(0)->in(k);\n+            \/\/ Find control for 'x' next to use but not inside inner loops.\n+            x_ctrl = place_outside_loop(x_ctrl, n_loop);\n+            --j;\n+          } else {              \/\/ Normal use\n+            if (has_ctrl(u)) {\n@@ -1623,0 +1633,2 @@\n+            } else {\n+              x_ctrl = u->in(0);\n@@ -1624,42 +1636,12 @@\n-\n-            \/\/ For inner loop uses get the preheader area.\n-            x_ctrl = place_near_use(x_ctrl);\n-\n-            if (n->is_Load()) {\n-              \/\/ For loads, add a control edge to a CFG node outside of the loop\n-              \/\/ to force them to not combine and return back inside the loop\n-              \/\/ during GVN optimization (4641526).\n-              \/\/\n-              \/\/ Because we are setting the actual control input, factor in\n-              \/\/ the result from get_late_ctrl() so we respect any\n-              \/\/ anti-dependences. (6233005).\n-              x_ctrl = dom_lca(late_load_ctrl, x_ctrl);\n-\n-              \/\/ Don't allow the control input to be a CFG splitting node.\n-              \/\/ Such nodes should only have ProjNodes as outs, e.g. IfNode\n-              \/\/ should only have IfTrueNode and IfFalseNode (4985384).\n-              x_ctrl = find_non_split_ctrl(x_ctrl);\n-\n-              IdealLoopTree* x_loop = get_loop(x_ctrl);\n-              Node* x_head = x_loop->_head;\n-              if (x_head->is_Loop() && (x_head->is_OuterStripMinedLoop() || x_head->as_Loop()->is_strip_mined())) {\n-                if (is_dominator(n_ctrl, x_head) && n_ctrl != x_head) {\n-                  \/\/ Anti dependence analysis is sometimes too\n-                  \/\/ conservative: a store in the outer strip mined loop\n-                  \/\/ can prevent a load from floating out of the outer\n-                  \/\/ strip mined loop but the load may not be referenced\n-                  \/\/ from the safepoint: loop strip mining verification\n-                  \/\/ code reports a problem in that case. Make sure the\n-                  \/\/ load is not moved in the outer strip mined loop in\n-                  \/\/ that case.\n-                  x_ctrl = x_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n-                } else if (x_head->is_OuterStripMinedLoop()) {\n-                  \/\/ Do not add duplicate LoadNodes to the outer strip mined loop\n-                  if (outer_loop_clone != NULL) {\n-                    _igvn.replace_node(x, outer_loop_clone);\n-                    continue;\n-                  }\n-                  outer_loop_clone = x;\n-                }\n-              }\n-              assert(dom_depth(n_ctrl) <= dom_depth(x_ctrl), \"n is later than its clone\");\n+            x_ctrl = place_outside_loop(x_ctrl, n_loop);\n+            \/\/ Replace all uses\n+            if (u->is_ConstraintCast() && u->bottom_type()->higher_equal(_igvn.type(n)) && u->in(0) == x_ctrl) {\n+              \/\/ If we're sinking a chain of data nodes, we might have inserted a cast to pin the use which is not necessary\n+              \/\/ anymore now that we're going to pin n as well\n+              _igvn.replace_node(u, x);\n+              --j;\n+            } else {\n+              int nb = u->replace_edge(n, x, &_igvn);\n+              j -= nb;\n+            }\n+          }\n@@ -1668,1 +1650,15 @@\n-              x->set_req(0, x_ctrl);\n+          if (n->is_Load()) {\n+            \/\/ For loads, add a control edge to a CFG node outside of the loop\n+            \/\/ to force them to not combine and return back inside the loop\n+            \/\/ during GVN optimization (4641526).\n+            assert(x_ctrl == get_late_ctrl_with_anti_dep(x->as_Load(), early_ctrl, x_ctrl), \"anti-dependences were already checked\");\n+\n+            IdealLoopTree* x_loop = get_loop(x_ctrl);\n+            Node* x_head = x_loop->_head;\n+            if (x_head->is_Loop() && x_head->is_OuterStripMinedLoop()) {\n+              \/\/ Do not add duplicate LoadNodes to the outer strip mined loop\n+              if (outer_loop_clone != NULL) {\n+                _igvn.replace_node(x, outer_loop_clone);\n+                continue;\n+              }\n+              outer_loop_clone = x;\n@@ -1670,13 +1666,23 @@\n-            register_new_node(x, x_ctrl);\n-\n-            \/\/ Some institutional knowledge is needed here: 'x' is\n-            \/\/ yanked because if the optimizer runs GVN on it all the\n-            \/\/ cloned x's will common up and undo this optimization and\n-            \/\/ be forced back in the loop.\n-            \/\/ I tried setting control edges on the x's to force them to\n-            \/\/ not combine, but the matching gets worried when it tries\n-            \/\/ to fold a StoreP and an AddP together (as part of an\n-            \/\/ address expression) and the AddP and StoreP have\n-            \/\/ different controls.\n-            if (!x->is_Load() && !x->is_DecodeNarrowPtr()) {\n-              _igvn._worklist.yank(x);\n+            x->set_req(0, x_ctrl);\n+          } else if (n->in(0) != NULL){\n+            x->set_req(0, x_ctrl);\n+          }\n+          assert(dom_depth(n_ctrl) <= dom_depth(x_ctrl), \"n is later than its clone\");\n+          assert(!n_loop->is_member(get_loop(x_ctrl)), \"should have moved out of loop\");\n+          register_new_node(x, x_ctrl);\n+\n+          if (x->in(0) == NULL && !x->is_DecodeNarrowPtr()) {\n+            assert(!x->is_Load(), \"load should be pinned\");\n+            \/\/ Use a cast node to pin clone out of loop\n+            Node* cast = NULL;\n+            for (uint k = 0; k < x->req(); k++) {\n+              Node* in = x->in(k);\n+              if (in != NULL && n_loop->is_member(get_loop(get_ctrl(in)))) {\n+                const Type* in_t = _igvn.type(in);\n+                cast = ConstraintCastNode::make_cast_for_type(x_ctrl, in, in_t);\n+              }\n+              if (cast != NULL) {\n+                register_new_node(cast, x_ctrl);\n+                x->replace_edge(in, cast);\n+                break;\n+              }\n@@ -1684,0 +1690,1 @@\n+            assert(cast != NULL, \"must have added a cast to pin the node\");\n@@ -1685,1 +1692,1 @@\n-          _igvn.remove_dead_node(n);\n+        _igvn.remove_dead_node(n);\n@@ -1688,0 +1695,1 @@\n+      _dom_lca_tags_round = 0;\n@@ -1690,0 +1698,1 @@\n+}\n@@ -1691,5 +1700,29 @@\n-  try_move_store_after_loop(n);\n-\n-  \/\/ Remove multiple allocations of the same inline type\n-  if (n->is_InlineType()) {\n-    n->as_InlineType()->remove_redundant_allocations(&_igvn, this);\n+Node* PhaseIdealLoop::compute_early_ctrl(Node* n, Node* n_ctrl) {\n+  Node* early_ctrl = NULL;\n+  ResourceMark rm;\n+  Unique_Node_List wq;\n+  wq.push(n);\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* m = wq.at(i);\n+    Node* c = NULL;\n+    if (m->is_CFG()) {\n+      c = m;\n+    } else if (m->pinned()) {\n+      c = m->in(0);\n+    } else {\n+      for (uint j = 0; j < m->req(); j++) {\n+        Node* in = m->in(j);\n+        if (in == NULL) {\n+          continue;\n+        }\n+        wq.push(in);\n+      }\n+    }\n+    if (c != NULL) {\n+      assert(is_dominator(c, n_ctrl), \"\");\n+      if (early_ctrl == NULL) {\n+        early_ctrl = c;\n+      } else if (is_dominator(early_ctrl, c)) {\n+        early_ctrl = c;\n+      }\n+    }\n@@ -1697,0 +1730,3 @@\n+  assert(is_dominator(early_ctrl, n_ctrl), \"early control must dominate current control\");\n+  return early_ctrl;\n+}\n@@ -1698,6 +1734,23 @@\n-  \/\/ Check for Opaque2's who's loop has disappeared - who's input is in the\n-  \/\/ same loop nest as their output.  Remove 'em, they are no longer useful.\n-  if( n_op == Op_Opaque2 &&\n-      n->in(1) != NULL &&\n-      get_loop(get_ctrl(n)) == get_loop(get_ctrl(n->in(1))) ) {\n-    _igvn.replace_node( n, n->in(1) );\n+bool PhaseIdealLoop::ctrl_of_all_uses_out_of_loop(const Node* n, Node* n_ctrl, IdealLoopTree* n_loop) {\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* u = n->fast_out(i);\n+    if (u->Opcode() == Op_Opaque1) {\n+      return false;  \/\/ Found loop limit, bugfix for 4677003\n+    }\n+    \/\/ We can't reuse tags in PhaseIdealLoop::dom_lca_for_get_late_ctrl_internal() so make sure calls to\n+    \/\/ get_late_ctrl_with_anti_dep() use their own tag\n+    _dom_lca_tags_round++;\n+    assert(_dom_lca_tags_round != 0, \"shouldn't wrap around\");\n+\n+    if (u->is_Phi()) {\n+      for (uint j = 1; j < u->req(); ++j) {\n+        if (u->in(j) == n && !ctrl_of_use_out_of_loop(n, n_ctrl, n_loop, u->in(0)->in(j))) {\n+          return false;\n+        }\n+      }\n+    } else {\n+      Node* ctrl = has_ctrl(u) ? get_ctrl(u) : u->in(0);\n+      if (!ctrl_of_use_out_of_loop(n, n_ctrl, n_loop, ctrl)) {\n+        return false;\n+      }\n+    }\n@@ -1705,0 +1758,1 @@\n+  return true;\n@@ -1707,3 +1761,10 @@\n-bool PhaseIdealLoop::is_safe_load_ctrl(Node* ctrl) {\n-  if (ctrl->is_Proj() && ctrl->in(0)->is_Call() && ctrl->has_out_with(Op_Catch)) {\n-    return false;\n+bool PhaseIdealLoop::ctrl_of_use_out_of_loop(const Node* n, Node* n_ctrl, IdealLoopTree* n_loop, Node* ctrl) {\n+  if (n->is_Load()) {\n+    ctrl = get_late_ctrl_with_anti_dep(n->as_Load(), n_ctrl, ctrl);\n+  }\n+  IdealLoopTree *u_loop = get_loop(ctrl);\n+  if (u_loop == n_loop) {\n+    return false; \/\/ Found loop-varying use\n+  }\n+  if (n_loop->is_member(u_loop)) {\n+    return false; \/\/ Found use in inner loop\n@@ -2087,1 +2148,1 @@\n-      Node* c = phase->get_ctrl(u);\n+      Node* c = u->in(0) != NULL ? u->in(0) : phase->get_ctrl(u);\n@@ -2210,0 +2271,6 @@\n+\n+    Node* inner_out = sfpt->in(0);\n+    if (inner_out->outcnt() > 1) {\n+      clone_outer_loop_helper(inner_out, loop, outer_loop, old_new, wq, this, true);\n+    }\n+\n@@ -2215,0 +2282,3 @@\n+      if (n->in(0) != NULL) {\n+        _igvn.replace_input_of(n, 0, new_ctrl);\n+      }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":207,"deletions":137,"binary":false,"changes":344,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -182,2 +183,2 @@\n-\/\/ length(in bytes) less than ArrayCopyPartialInlineSize.\n-\/\/  if (length <= ArrayCopyPartialInlineSize) {\n+\/\/ length(in bytes) less than ArrayOperationPartialInlineSize.\n+\/\/  if (length <= ArrayOperationPartialInlineSize) {\n@@ -224,1 +225,1 @@\n-  if ( const_len > ArrayCopyPartialInlineSize ||\n+  if ( const_len > ArrayOperationPartialInlineSize ||\n@@ -231,0 +232,3 @@\n+  int inline_limit = ArrayOperationPartialInlineSize \/ type2aelembytes(type);\n+  Node* casted_length = new CastLLNode(*ctrl, length, TypeLong::make(0, inline_limit, Type::WidenMin));\n+  transform_later(casted_length);\n@@ -234,1 +238,1 @@\n-  Node* cmp_le = new CmpULNode(copy_bytes, longcon(ArrayCopyPartialInlineSize));\n+  Node* cmp_le = new CmpULNode(copy_bytes, longcon(ArrayOperationPartialInlineSize));\n@@ -241,1 +245,1 @@\n-  Node* mask_gen =  new VectorMaskGenNode(length, TypeVect::VECTMASK, Type::get_const_basic_type(type));\n+  Node* mask_gen =  new VectorMaskGenNode(casted_length, TypeVect::VECTMASK, type);\n@@ -734,1 +738,1 @@\n-    if (!bs->array_copy_requires_gc_barriers(alloc != NULL, copy_type, false, BarrierSetC2::Expansion)) {\n+    if (!bs->array_copy_requires_gc_barriers(alloc != NULL, copy_type, false, false, BarrierSetC2::Expansion)) {\n@@ -1280,1 +1284,1 @@\n-  if (ArrayCopyPartialInlineSize > 0 && is_subword_type(basic_elem_type) &&\n+  if (ArrayOperationPartialInlineSize > 0 && is_subword_type(basic_elem_type) &&\n@@ -1319,1 +1323,1 @@\n-                        bs->array_copy_requires_gc_barriers(dest_length != NULL, T_OBJECT, false, BarrierSetC2::Optimization);\n+    bs->array_copy_requires_gc_barriers(dest_length != NULL, T_OBJECT, false, false, BarrierSetC2::Optimization);\n@@ -1489,1 +1493,1 @@\n-       bs->array_copy_requires_gc_barriers(alloc != NULL, T_OBJECT, false, BarrierSetC2::Optimization))) {\n+       bs->array_copy_requires_gc_barriers(alloc != NULL, T_OBJECT, false, false, BarrierSetC2::Optimization))) {\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -763,1 +763,1 @@\n-bool Matcher::is_save_on_entry( int reg ) {\n+bool Matcher::is_save_on_entry(int reg) {\n@@ -766,3 +766,1 @@\n-    _register_save_policy[reg] == 'A' || \/\/ Save-on-entry register?\n-    \/\/ Also save argument registers in the trampolining stubs\n-    (C->save_argument_registers() && is_spillable_arg(reg));\n+    _register_save_policy[reg] == 'A'; \/\/ Save-on-entry register?\n@@ -784,6 +782,0 @@\n-  \/\/ Save argument registers in the trampolining stubs\n-  if( C->save_argument_registers() )\n-    for( i = 0; i < _last_Mach_Reg; i++ )\n-      if( is_spillable_arg(i) )\n-        soe_cnt++;\n-\n@@ -1418,2 +1410,4 @@\n-      if( !parm_regs[i].first()->is_valid() &&\n-          !parm_regs[i].second()->is_valid() ) {\n+      VMReg first = parm_regs[i].first();\n+      VMReg second = parm_regs[i].second();\n+      if(!first->is_valid() &&\n+         !second->is_valid()) {\n@@ -1422,0 +1416,9 @@\n+      \/\/ Handle case where arguments are in vector registers.\n+      if(call->in(TypeFunc::Parms + i)->bottom_type()->isa_vect()) {\n+        OptoReg::Name reg_fst = OptoReg::as_OptoReg(first);\n+        OptoReg::Name reg_snd = OptoReg::as_OptoReg(second);\n+        assert (reg_fst <= reg_snd, \"fst=%d snd=%d\", reg_fst, reg_snd);\n+        for (OptoReg::Name r = reg_fst; r <= reg_snd; r++) {\n+          rm->Insert(r);\n+        }\n+      }\n@@ -1423,1 +1426,1 @@\n-      OptoReg::Name reg1 = warp_outgoing_stk_arg(parm_regs[i].first(), begin_out_arg_area, out_arg_limit_per_call );\n+      OptoReg::Name reg1 = warp_outgoing_stk_arg(first, begin_out_arg_area, out_arg_limit_per_call );\n@@ -1428,1 +1431,1 @@\n-      OptoReg::Name reg2 = warp_outgoing_stk_arg(parm_regs[i].second(), begin_out_arg_area, out_arg_limit_per_call );\n+      OptoReg::Name reg2 = warp_outgoing_stk_arg(second, begin_out_arg_area, out_arg_limit_per_call );\n@@ -2271,0 +2274,1 @@\n+    case Op_VectorCmpMasked:\n@@ -2364,0 +2368,6 @@\n+    case Op_VectorCmpMasked: {\n+      Node* pair1 = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair1);\n+      n->del_req(3);\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/compressedOops.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -46,0 +48,3 @@\n+  \/\/ Machine-dependent definitions\n+#include CPU_HEADER(matcher)\n+\n@@ -325,2 +330,0 @@\n-  \/\/ Some microarchitectures have mask registers used on vectors\n-  static const bool has_predicated_vectors(void);\n@@ -333,4 +336,0 @@\n-  \/\/ Used to determine if we have fast l2f conversion\n-  \/\/ USII has it, USIII doesn't\n-  static const bool convL2FSupported(void);\n-\n@@ -348,1 +347,0 @@\n-  static const bool supports_scalable_vector();\n@@ -355,14 +353,0 @@\n-  \/\/ Does the CPU supports vector variable shift instructions?\n-  static bool supports_vector_variable_shifts(void);\n-\n-  \/\/ Does the CPU supports vector vairable rotate instructions?\n-  static bool supports_vector_variable_rotates(void);\n-\n-  \/\/ CPU supports misaligned vectors store\/load.\n-  static const bool misaligned_vectors_ok();\n-\n-  \/\/ Used to determine a \"low complexity\" 64-bit constant.  (Zero is simple.)\n-  \/\/ The standard of comparison is one (StoreL ConL) vs. two (StoreI ConI).\n-  \/\/ Depends on the details of 64-bit constant generation on the CPU.\n-  static const bool isSimpleConstant64(jlong con);\n-\n@@ -436,0 +420,4 @@\n+  \/\/ Java-Native vector calling convention\n+  static const bool supports_vector_calling_convention();\n+  static OptoRegPair vector_return_value(uint ideal_reg);\n+\n@@ -439,9 +427,0 @@\n-  \/\/ Optional scaling for the parameter to the ClearArray\/CopyArray node.\n-  static const bool init_array_count_is_in_bytes;\n-\n-  \/\/ Some hardware needs 2 CMOV's for longs.\n-  static const int long_cmove_cost();\n-\n-  \/\/ Some hardware have expensive CMOV for float and double.\n-  static const int float_cmove_cost();\n-\n@@ -460,6 +439,0 @@\n-  static bool narrow_oop_use_complex_address();\n-  static bool narrow_klass_use_complex_address();\n-\n-  static bool const_oop_prefer_decode();\n-  static bool const_klass_prefer_decode();\n-\n@@ -492,21 +465,0 @@\n-  \/\/ Is it better to copy float constants, or load them directly from memory?\n-  \/\/ Intel can load a float constant from a direct address, requiring no\n-  \/\/ extra registers.  Most RISCs will have to materialize an address into a\n-  \/\/ register first, so they may as well materialize the constant immediately.\n-  static const bool rematerialize_float_constants;\n-\n-  \/\/ If CPU can load and store mis-aligned doubles directly then no fixup is\n-  \/\/ needed.  Else we split the double into 2 integer pieces and move it\n-  \/\/ piece-by-piece.  Only happens when passing doubles into C code or when\n-  \/\/ calling i2c adapters as the Java calling convention forces doubles to be\n-  \/\/ aligned.\n-  static const bool misaligned_doubles_ok;\n-\n-  \/\/ Does the CPU require postalloc expand (see block.cpp for description of\n-  \/\/ postalloc expand)?\n-  static const bool require_postalloc_expand;\n-\n-  \/\/ Does the platform support generic vector operands?\n-  \/\/ Requires cleanup after selection phase.\n-  static const bool supports_generic_vector_operands;\n-\n@@ -531,16 +483,0 @@\n-  \/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-  static const bool strict_fp_requires_explicit_rounding;\n-\n-  \/\/ Are floats conerted to double when stored to stack during deoptimization?\n-  static bool float_in_double();\n-  \/\/ Do ints take an entire long register or just half?\n-  static const bool int_in_long;\n-\n-  \/\/ Do the processor's shift instructions only use the low 5\/6 bits\n-  \/\/ of the count for 32\/64 bit ints? If not we need to do the masking\n-  \/\/ ourselves.\n-  static const bool need_masked_shift_count;\n-\n-  \/\/ Whether code generation need accurate ConvI2L types.\n-  static const bool convi2l_type_required;\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":9,"deletions":73,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -1798,1 +1798,1 @@\n-      set_req(MemNode::Memory, opt_mem);\n+      set_req_X(MemNode::Memory, opt_mem, phase);\n@@ -1873,1 +1873,1 @@\n-      set_req(MemNode::Memory, prev_mem);\n+      set_req_X(MemNode::Memory, prev_mem, phase);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,25 @@\n+\n+  \/\/ convert \"max(a,b) * min(a,b)\" into \"a*b\".\n+  Node *in1 = in(1);\n+  Node *in2 = in(2);\n+  if ((in(1)->Opcode() == max_opcode() && in(2)->Opcode() == min_opcode())\n+      || (in(1)->Opcode() == min_opcode() && in(2)->Opcode() == max_opcode())) {\n+    Node *in11 = in(1)->in(1);\n+    Node *in12 = in(1)->in(2);\n+\n+    Node *in21 = in(2)->in(1);\n+    Node *in22 = in(2)->in(2);\n+\n+    if ((in11 == in21 && in12 == in22) ||\n+        (in11 == in22 && in12 == in21)) {\n+      set_req(1, in11);\n+      set_req(2, in12);\n+      PhaseIterGVN* igvn = phase->is_IterGVN();\n+      if (igvn) {\n+        igvn->_worklist.push(in1);\n+        igvn->_worklist.push(in2);\n+      }\n+      progress = this;\n+    }\n+  }\n+\n@@ -179,1 +204,1 @@\n-  if (op == Op_MulD && phase->C->method()->is_strict()) {\n+  if (op == Op_MulD) {\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -561,2 +561,0 @@\n-    \/\/ cloning CallNode may need to clone JVMState\n-    n->as_Call()->clone_jvms(C);\n@@ -575,0 +573,3 @@\n+    \/\/ Scalar replacement and macro expansion might modify the JVMState.\n+    \/\/ Clone it to make sure it's not shared between SafePointNodes.\n+    n->as_SafePoint()->clone_jvms(C);\n@@ -2222,1 +2223,1 @@\n-void Node::verify(Node* n, int verify_depth) {\n+void Node::verify(int verify_depth, VectorSet& visited, Node_List& worklist) {\n@@ -2224,6 +2225,1 @@\n-  ResourceMark rm;\n-  VectorSet old_space;\n-  VectorSet new_space;\n-  Node_List worklist;\n-  worklist.push(n);\n-  uint last_index_on_current_depth = 0;\n+  uint last_index_on_current_depth = worklist.size() - 1;\n@@ -2235,2 +2231,1 @@\n-\n-    n = worklist[list_index];\n+    Node* n = worklist[list_index];\n@@ -2246,2 +2241,3 @@\n-    for (uint i = 0; i < n->len(); i++) {\n-      Node* x = n->in(i);\n+    uint in_len = n->len();\n+    for (uint i = 0; i < in_len; i++) {\n+      Node* x = n->_in[i];\n@@ -2254,3 +2250,13 @@\n-      int cnt = 0;\n-      for (uint j = 0; j < n->len(); j++) {\n-        if (n->in(j) == x) {\n+      int cnt = 1;\n+      for (uint j = 0; j < i; j++) {\n+        if (n->_in[j] == x) {\n+          cnt++;\n+          break;\n+        }\n+      }\n+      if (cnt == 2) {\n+        \/\/ x is already checked as n's previous input, skip its duplicated def-use count checking\n+        continue;\n+      }\n+      for (uint j = i + 1; j < in_len; j++) {\n+        if (n->_in[j] == x) {\n@@ -2270,5 +2276,1 @@\n-      \/\/ Contained in new_space or old_space?\n-      VectorSet* v = C->node_arena()->contains(x) ? &new_space : &old_space;\n-      \/\/ Check for visited in the proper space. Numberings are not unique\n-      \/\/ across spaces so we need a separate VectorSet for each space.\n-      if (add_to_worklist && !v->test_set(x->_idx)) {\n+      if (add_to_worklist && !visited.test_set(x->_idx)) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -60,0 +60,3 @@\n+class CastFFNode;\n+class CastDDNode;\n+class CastVVNode;\n@@ -703,0 +706,3 @@\n+        DEFINE_CLASS_ID(CastFF, ConstraintCast, 3)\n+        DEFINE_CLASS_ID(CastDD, ConstraintCast, 4)\n+        DEFINE_CLASS_ID(CastVV, ConstraintCast, 5)\n@@ -1225,1 +1231,1 @@\n-  static void verify(Node* n, int verify_depth);\n+  static void verify(int verify_depth, VectorSet& visited, Node_List& worklist);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -546,0 +546,3 @@\n+\n+  Compile::TracePhase tp(\"shorten branches\", &timers[_t_shortenBranches]);\n+\n@@ -1322,15 +1325,0 @@\n-#if defined(IA64) && !defined(AIX)\n-  if (save_argument_registers()) {\n-    \/\/ 4815101: this is a stub with implicit and unknown precision fp args.\n-    \/\/ The usual spill mechanism can only generate stfd's in this case, which\n-    \/\/ doesn't work if the fp reg to spill contains a single-precision denorm.\n-    \/\/ Instead, we hack around the normal spill mechanism using stfspill's and\n-    \/\/ ldffill's in the MachProlog and MachEpilog emit methods.  We allocate\n-    \/\/ space here for the fp arg regs (f8-f15) we're going to thusly spill.\n-    \/\/\n-    \/\/ If we ever implement 16-byte 'registers' == stack slots, we can\n-    \/\/ get rid of this hack and have SpillCopy generate stfspill\/ldffill\n-    \/\/ instead of stfd\/stfs\/ldfd\/ldfs.\n-    _frame_slots += 8*(16\/BytesPerInt);\n-  }\n-#endif\n@@ -1431,0 +1419,2 @@\n+  Compile::TracePhase tp(\"fill buffer\", &timers[_t_fillBuffer]);\n+\n@@ -3435,2 +3425,1 @@\n-    install_stub(C->stub_name(),\n-                 C->save_argument_registers());\n+    install_stub(C->stub_name());\n@@ -3500,2 +3489,1 @@\n-void PhaseOutput::install_stub(const char* stub_name,\n-                               bool        caller_must_gc_arguments) {\n+void PhaseOutput::install_stub(const char* stub_name) {\n@@ -3520,1 +3508,1 @@\n-                                                      caller_must_gc_arguments);\n+                                                      false);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -170,2 +170,1 @@\n-  void install_stub(const char* stub_name,\n-                    bool        caller_must_gc_arguments);\n+  void install_stub(const char* stub_name);\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-    if (UseLoopSafepoints && target_bci <= bci()) {\n+    if (target_bci <= bci()) {\n@@ -506,2 +506,0 @@\n-  void do_irem();\n-\n@@ -554,1 +552,0 @@\n-  Node*   jump_if_join(Node* iffalse, Node* iftrue);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"opto\/type.hpp\"\n@@ -1258,0 +1259,36 @@\n+  \/\/ Narrow receiver type when it is too broad for the method being parsed.\n+  ciInstanceKlass* callee_holder = method()->holder();\n+  if (!method()->is_static()) {\n+    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder);\n+\n+    Node* receiver_obj = local(0);\n+    const TypeInstPtr* receiver_type = _gvn.type(receiver_obj)->isa_instptr();\n+\n+    if (receiver_type != NULL && !receiver_type->higher_equal(holder_type)) {\n+\n+#ifdef ASSERT\n+      \/\/ Perform dynamic receiver subtype check against callee holder class w\/ a halt on failure.\n+      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder));\n+      Node* not_subtype_ctrl = gen_subtype_check(receiver_obj, holder_klass);\n+      assert(!stopped(), \"not a subtype\");\n+\n+      Node* halt = _gvn.transform(new HaltNode(not_subtype_ctrl, frameptr(), \"failed receiver subtype check\"));\n+      C->root()->add_req(halt);\n+#endif \/\/ ASSERT\n+\n+      \/\/ Receiver should always be a subtype of callee holder.\n+      \/\/ But, since C2 type system doesn't properly track interfaces,\n+      \/\/ the invariant on default methods can't be expressed in the type system.\n+      \/\/ Example: for unrelated C <: I and D <: I, (C `meet` D) = Object <\/: I.\n+      \/\/ (Downcasting interface receiver type to concrete class is fine, though it doesn't happen in practice.)\n+      if (!callee_holder->is_interface()) {\n+        assert(callee_holder->is_subtype_of(receiver_type->klass()), \"sanity\");\n+        assert(!receiver_type->klass()->is_interface(), \"interface receiver type\");\n+        receiver_type = receiver_type->join_speculative(holder_type)->is_instptr(); \/\/ keep speculative part\n+        Node* casted_receiver_obj = _gvn.transform(new CheckCastPPNode(control(), receiver_obj, receiver_type));\n+        set_local(0, casted_receiver_obj);\n+      }\n+\n+    }\n+  }\n+\n@@ -1271,1 +1308,1 @@\n-    if(method()->is_static()) {\n+    if (method()->is_static()) {\n@@ -2456,1 +2493,1 @@\n-  if( OptoRemoveUseless && transformed_sfpnt->is_SafePoint() ) {\n+  if (transformed_sfpnt->is_SafePoint()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-        if (false && !bs->array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Parsing)) {\n+        if (false && !bs->array_copy_requires_gc_barriers(false, T_OBJECT, false, false, BarrierSetC2::Parsing)) {\n@@ -628,11 +628,0 @@\n-\/\/ return Region node\n-Node* Parse::jump_if_join(Node* iffalse, Node* iftrue) {\n-  Node *region  = new RegionNode(3); \/\/ 2 results\n-  record_for_igvn(region);\n-  region->init_req(1, iffalse);\n-  region->init_req(2, iftrue );\n-  _gvn.set_type(region, Type::CONTROL);\n-  region = _gvn.transform(region);\n-  set_control (region);\n-  return region;\n-}\n@@ -895,1 +884,1 @@\n-  if (makes_backward_branch && UseLoopSafepoints) {\n+  if (makes_backward_branch) {\n@@ -989,1 +978,1 @@\n-  if (makes_backward_branch && UseLoopSafepoints) {\n+  if (makes_backward_branch) {\n@@ -1568,44 +1557,0 @@\n-void Parse::do_irem() {\n-  \/\/ Must keep both values on the expression-stack during null-check\n-  zero_check_int(peek());\n-  \/\/ Compile-time detect of null-exception?\n-  if (stopped())  return;\n-\n-  Node* b = pop();\n-  Node* a = pop();\n-\n-  const Type *t = _gvn.type(b);\n-  if (t != Type::TOP) {\n-    const TypeInt *ti = t->is_int();\n-    if (ti->is_con()) {\n-      int divisor = ti->get_con();\n-      \/\/ check for positive power of 2\n-      if (divisor > 0 &&\n-          (divisor & ~(divisor-1)) == divisor) {\n-        \/\/ yes !\n-        Node *mask = _gvn.intcon((divisor - 1));\n-        \/\/ Sigh, must handle negative dividends\n-        Node *zero = _gvn.intcon(0);\n-        IfNode *ifff = jump_if_fork_int(a, zero, BoolTest::lt, PROB_FAIR, COUNT_UNKNOWN);\n-        Node *iff = _gvn.transform( new IfFalseNode(ifff) );\n-        Node *ift = _gvn.transform( new IfTrueNode (ifff) );\n-        Node *reg = jump_if_join(ift, iff);\n-        Node *phi = PhiNode::make(reg, NULL, TypeInt::INT);\n-        \/\/ Negative path; negate\/and\/negate\n-        Node *neg = _gvn.transform( new SubINode(zero, a) );\n-        Node *andn= _gvn.transform( new AndINode(neg, mask) );\n-        Node *negn= _gvn.transform( new SubINode(zero, andn) );\n-        phi->init_req(1, negn);\n-        \/\/ Fast positive case\n-        Node *andx = _gvn.transform( new AndINode(a, mask) );\n-        phi->init_req(2, andx);\n-        \/\/ Push the merge\n-        push( _gvn.transform(phi) );\n-        return;\n-      }\n-    }\n-  }\n-  \/\/ Default case\n-  push( _gvn.transform( new ModINode(control(),a,b) ) );\n-}\n-\n@@ -2998,1 +2943,7 @@\n-    do_irem();\n+    \/\/ Must keep both values on the expression-stack during null-check\n+    zero_check_int(peek());\n+    \/\/ Compile-time detect of null-exception?\n+    if (stopped())  return;\n+    b = pop();\n+    a = pop();\n+    push(_gvn.transform(new ModINode(control(), a, b)));\n@@ -3357,2 +3308,1 @@\n-    if( UseLoopSafepoints ) {\n-      switch( iter().next_bc() ) {\n+    switch (iter().next_bc()) {\n@@ -3369,1 +3319,0 @@\n-      }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":11,"deletions":62,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -410,4 +410,2 @@\n-\n-  \/\/ Implementation requires 'UseLoopSafepoints == true' and an edge from root\n-  \/\/ to each SafePointNode at a backward branch.  Inserted in add_safepoint().\n-  if( !UseLoopSafepoints || !OptoRemoveUseless ) return;\n+  \/\/ Implementation requires an edge from root to each SafePointNode\n+  \/\/ at a backward branch. Inserted in add_safepoint().\n@@ -996,2 +994,1 @@\n-      assert(!UseLoopSafepoints || !OptoRemoveUseless,\n-             \"remove_useless_nodes missed this node\");\n+      assert(false, \"remove_useless_nodes missed this node\");\n@@ -1027,0 +1024,4 @@\n+    ResourceMark rm;\n+    VectorSet visited;\n+    Node_List worklist;\n+\n@@ -1031,1 +1032,3 @@\n-      Node::verify(C->root(), -1);\n+      worklist.push(C->root());\n+      Node::verify(-1, visited, worklist);\n+      return;\n@@ -1044,1 +1047,3 @@\n-      Node::verify(n, 4);\n+      if (!visited.test_set(n->_idx)) {\n+        worklist.push(n);\n+      }\n@@ -1046,0 +1051,1 @@\n+    Node::verify(4, visited, worklist);\n@@ -1244,1 +1250,1 @@\n-   assert(!_table.find_index(n->_idx), \"found duplicate entry in table\");\n+    assert(!_table.find_index(n->_idx), \"found duplicate entry in table\");\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -129,2 +129,2 @@\n-#define gen(env, var, type_func_gen, c_func, fancy_jump, pass_tls, save_arg_regs, return_pc) \\\n-  var = generate_stub(env, type_func_gen, CAST_FROM_FN_PTR(address, c_func), #var, fancy_jump, pass_tls, save_arg_regs, return_pc); \\\n+#define gen(env, var, type_func_gen, c_func, fancy_jump, pass_tls, return_pc) \\\n+  var = generate_stub(env, type_func_gen, CAST_FROM_FN_PTR(address, c_func), #var, fancy_jump, pass_tls, return_pc); \\\n@@ -139,1 +139,1 @@\n-  \/\/   variable\/name                       type-function-gen              , runtime method                  ,fncy_jp, tls,save_args,retpc\n+  \/\/   variable\/name                       type-function-gen              , runtime method                  ,fncy_jp, tls,retpc\n@@ -141,15 +141,15 @@\n-  gen(env, _new_instance_Java              , new_instance_Type            , new_instance_C                  ,    0 , true , false, false);\n-  gen(env, _new_array_Java                 , new_array_Type               , new_array_C                     ,    0 , true , false, false);\n-  gen(env, _new_array_nozero_Java          , new_array_Type               , new_array_nozero_C              ,    0 , true , false, false);\n-  gen(env, _multianewarray2_Java           , multianewarray2_Type         , multianewarray2_C               ,    0 , true , false, false);\n-  gen(env, _multianewarray3_Java           , multianewarray3_Type         , multianewarray3_C               ,    0 , true , false, false);\n-  gen(env, _multianewarray4_Java           , multianewarray4_Type         , multianewarray4_C               ,    0 , true , false, false);\n-  gen(env, _multianewarray5_Java           , multianewarray5_Type         , multianewarray5_C               ,    0 , true , false, false);\n-  gen(env, _multianewarrayN_Java           , multianewarrayN_Type         , multianewarrayN_C               ,    0 , true , false, false);\n-  gen(env, _complete_monitor_locking_Java  , complete_monitor_enter_Type  , SharedRuntime::complete_monitor_locking_C, 0, false, false, false);\n-  gen(env, _monitor_notify_Java            , monitor_notify_Type          , monitor_notify_C                ,    0 , false, false, false);\n-  gen(env, _monitor_notifyAll_Java         , monitor_notify_Type          , monitor_notifyAll_C             ,    0 , false, false, false);\n-  gen(env, _rethrow_Java                   , rethrow_Type                 , rethrow_C                       ,    2 , true , false, true );\n-\n-  gen(env, _slow_arraycopy_Java            , slow_arraycopy_Type          , SharedRuntime::slow_arraycopy_C ,    0 , false, false, false);\n-  gen(env, _register_finalizer_Java        , register_finalizer_Type      , register_finalizer              ,    0 , false, false, false);\n+  gen(env, _new_instance_Java              , new_instance_Type            , new_instance_C                  ,    0 , true, false);\n+  gen(env, _new_array_Java                 , new_array_Type               , new_array_C                     ,    0 , true, false);\n+  gen(env, _new_array_nozero_Java          , new_array_Type               , new_array_nozero_C              ,    0 , true, false);\n+  gen(env, _multianewarray2_Java           , multianewarray2_Type         , multianewarray2_C               ,    0 , true, false);\n+  gen(env, _multianewarray3_Java           , multianewarray3_Type         , multianewarray3_C               ,    0 , true, false);\n+  gen(env, _multianewarray4_Java           , multianewarray4_Type         , multianewarray4_C               ,    0 , true, false);\n+  gen(env, _multianewarray5_Java           , multianewarray5_Type         , multianewarray5_C               ,    0 , true, false);\n+  gen(env, _multianewarrayN_Java           , multianewarrayN_Type         , multianewarrayN_C               ,    0 , true, false);\n+  gen(env, _complete_monitor_locking_Java  , complete_monitor_enter_Type  , SharedRuntime::complete_monitor_locking_C, 0, false, false);\n+  gen(env, _monitor_notify_Java            , monitor_notify_Type          , monitor_notify_C                ,    0 , false, false);\n+  gen(env, _monitor_notifyAll_Java         , monitor_notify_Type          , monitor_notifyAll_C             ,    0 , false, false);\n+  gen(env, _rethrow_Java                   , rethrow_Type                 , rethrow_C                       ,    2 , true , true );\n+\n+  gen(env, _slow_arraycopy_Java            , slow_arraycopy_Type          , SharedRuntime::slow_arraycopy_C ,    0 , false, false);\n+  gen(env, _register_finalizer_Java        , register_finalizer_Type      , register_finalizer              ,    0 , false, false);\n@@ -164,6 +164,5 @@\n-address OptoRuntime::generate_stub( ciEnv* env,\n-                                    TypeFunc_generator gen, address C_function,\n-                                    const char *name, int is_fancy_jump,\n-                                    bool pass_tls,\n-                                    bool save_argument_registers,\n-                                    bool return_pc) {\n+address OptoRuntime::generate_stub(ciEnv* env,\n+                                   TypeFunc_generator gen, address C_function,\n+                                   const char *name, int is_fancy_jump,\n+                                   bool pass_tls,\n+                                   bool return_pc) {\n@@ -174,1 +173,1 @@\n-  Compile C( env, gen, C_function, name, is_fancy_jump, pass_tls, save_argument_registers, return_pc, directive);\n+  Compile C(env, gen, C_function, name, is_fancy_jump, pass_tls, return_pc, directive);\n@@ -673,0 +672,19 @@\n+const TypeFunc *OptoRuntime::Math_Vector_Vector_Type(uint num_arg, const TypeVect* in_type, const TypeVect* out_type) {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(num_arg);\n+  \/\/ Symbol* name of class to be loaded\n+  assert(num_arg > 0, \"must have at least 1 input\");\n+  for (uint i = 0; i < num_arg; i++) {\n+    fields[TypeFunc::Parms+i] = in_type;\n+  }\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+num_arg, fields);\n+\n+  \/\/ create result type (range)\n+  const uint num_ret = 1;\n+  fields = TypeTuple::fields(num_ret);\n+  fields[TypeFunc::Parms+0] = out_type;\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+num_ret, fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n@@ -1508,0 +1526,15 @@\n+#if INCLUDE_JFR\n+const TypeFunc *OptoRuntime::get_class_id_intrinsic_Type() {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::KLASS;\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms + 0, fields);\n+\n+  return TypeFunc::make(domain,range);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":58,"deletions":25,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char *name, int is_fancy_jump, bool pass_tls, bool save_arguments, bool return_pc);\n+  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char* name, int is_fancy_jump, bool pass_tls, bool return_pc);\n@@ -259,0 +259,1 @@\n+  static const TypeFunc* Math_Vector_Vector_Type(uint num_arg, const TypeVect* in_type, const TypeVect* out_type);\n@@ -307,0 +308,2 @@\n+  JFR_ONLY(static const TypeFunc* get_class_id_intrinsic_Type();)\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1154,0 +1154,5 @@\n+      \/\/ Special case for min_jint - it can't be negated.\n+      if (arg_val == min_jint) {\n+        return __ intcon(11);\n+      }\n+\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -467,7 +467,0 @@\n-  \/\/ Not associative because of boundary conditions (infinity)\n-  if (IdealizedNumerics && !phase->C->method()->is_strict() &&\n-      in(2)->is_Add() && in(1) == in(2)->in(1)) {\n-    \/\/ Convert \"x - (x+y)\" into \"-y\"\n-    return new SubFNode(phase->makecon(TypeF::ZERO), in(2)->in(2));\n-  }\n-\n@@ -509,7 +502,0 @@\n-  \/\/ Not associative because of boundary conditions (infinity)\n-  if (IdealizedNumerics && !phase->C->method()->is_strict() &&\n-      in(2)->is_Add() && in(1) == in(2)->in(1)) {\n-    \/\/ Convert \"x - (x+y)\" into \"-y\"\n-    return new SubDNode(phase->makecon(TypeD::ZERO), in(2)->in(2));\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -328,0 +328,1 @@\n+\/\/ For vector compares, additionally, the 4th bit indicates if the compare is unsigned\n@@ -329,1 +330,5 @@\n-  enum mask { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1, overflow = 2, no_overflow = 6, never = 8, illegal = 9 };\n+  enum mask { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1, overflow = 2, no_overflow = 6, never = 8, illegal = 9,\n+              \/\/ The following values are used with vector compares\n+              \/\/ A BoolTest value should not be constructed for such values\n+              unsigned_compare = 16,\n+              ule = unsigned_compare | le, uge = unsigned_compare | ge, ult = unsigned_compare | lt, ugt = unsigned_compare | gt };\n@@ -331,1 +336,1 @@\n-  BoolTest( mask btm ) : _test(btm) {}\n+  BoolTest( mask btm ) : _test(btm) { assert((btm & unsigned_compare) == 0, \"unsupported\");}\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-Node *SubTypeCheckNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node *SubTypeCheckNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -151,8 +151,1 @@\n-#ifdef ASSERT\n-      const Type* obj_t = phase->type(obj);\n-      if (!obj_t->isa_oopptr() && obj_t != Type::TOP) {\n-        obj->dump();\n-        obj_t->dump(); tty->cr();\n-        fatal(\"only for oop input\");\n-      }\n-#endif\n+      assert(is_oop(phase, obj), \"only for oop input\");\n@@ -167,8 +160,1 @@\n-#ifdef ASSERT\n-      const Type* obj_or_subklass_t = phase->type(obj_or_subklass);\n-      if (!obj_or_subklass_t->isa_oopptr() && obj_or_subklass_t != Type::TOP) {\n-        obj_or_subklass->dump();\n-        obj_or_subklass_t->dump(); tty->cr();\n-        fatal(\"only for oop input\");\n-      }\n-#endif\n+    assert(is_oop(phase, obj_or_subklass), \"only for oop input\");\n@@ -181,3 +167,1 @@\n-#ifdef ASSERT\n-  ciKlass* superk = super_t->is_klassptr()->klass();\n-  ciKlass* subk   = sub_t->isa_klassptr() ? sub_t->is_klassptr()->klass() : sub_t->is_oopptr()->klass();\n+  assert(verify(phase), \"missing Value() optimization\");\n@@ -185,13 +169,8 @@\n-  if (super_t->singleton() && subk != NULL && phase->C->static_subtype_check(superk, subk) == Compile::SSC_easy_test) {\n-    Node* subklass = NULL;\n-    if (sub_t->isa_oopptr()) {\n-      Node* adr = phase->transform(new AddPNode(obj_or_subklass, obj_or_subklass, phase->MakeConX(oopDesc::klass_offset_in_bytes())));\n-      subklass = phase->transform(LoadKlassNode::make(*phase, NULL, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n-    } else {\n-      subklass = obj_or_subklass;\n-    }\n-    Node* res = new CmpPNode(subklass, superklass);\n-    Node* cmp = phase->transform(res);\n-    const Type* t = phase->type(cmp);\n-    if (!((Value(phase) == t) || (t != TypeInt::CC_GT && t != TypeInt::CC_EQ))) {\n-      Value(phase)->dump(); tty->cr();\n+  return NULL;\n+}\n+\n+#ifdef ASSERT\n+bool SubTypeCheckNode::is_oop(PhaseGVN* phase, Node* n) {\n+    const Type* t = phase->type(n);\n+    if (!t->isa_oopptr() && t != Type::TOP) {\n+      n->dump();\n@@ -199,10 +178,1 @@\n-      obj_or_subklass->dump();\n-      subklass->dump();\n-      superklass->dump();\n-      cmp->dump();\n-      tty->print_cr(\"==============================\");\n-      phase->C->root()->dump(9999);\n-      fatal(\"missing Value() optimization\");\n-    }\n-    if (phase->is_IterGVN()) {\n-      phase->is_IterGVN()->_worklist.push(res);\n+      return false;\n@@ -210,1 +180,6 @@\n-    return NULL;\n+    return true;\n+}\n+\n+static Node* record_for_cleanup(Node* n, PhaseGVN* phase) {\n+  if (phase->is_IterGVN()) {\n+    phase->is_IterGVN()->_worklist.push(n); \/\/ record for cleanup\n@@ -212,0 +187,5 @@\n+  return n;\n+}\n+bool SubTypeCheckNode::verify_helper(PhaseGVN* phase, Node* subklass, const Type* cached_t) {\n+  Node* cmp = phase->transform(new CmpPNode(subklass, in(SuperKlass)));\n+  record_for_cleanup(cmp, phase);\n@@ -213,6 +193,2 @@\n-  Node *p1 = phase->transform(new AddPNode(superklass, superklass, phase->MakeConX(in_bytes(Klass::super_check_offset_offset()))));\n-  Node* m = phase->C->immutable_memory();\n-  LoadINode* chk_off_ld = new LoadINode(NULL, m, p1, phase->type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered);\n-  Node *chk_off = phase->transform(chk_off_ld);\n-  int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());\n-  bool might_be_cache = (phase->find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n+  const Type* cmp_t = phase->type(cmp);\n+  const Type* t = Value(phase);\n@@ -220,5 +196,12 @@\n-  if (might_be_cache) {\n-    if (phase->is_IterGVN()) {\n-      phase->is_IterGVN()->_worklist.push(chk_off_ld);\n-    }\n-    return NULL;\n+  if (t == cmp_t ||\n+      t != cached_t || \/\/ previous observations don't hold anymore\n+      (cmp_t != TypeInt::CC_GT && cmp_t != TypeInt::CC_EQ)) {\n+    return true;\n+  } else {\n+    t->dump(); tty->cr();\n+    this->dump(2); tty->cr();\n+    cmp_t->dump(); tty->cr();\n+    subklass->dump(2); tty->cr();\n+    tty->print_cr(\"==============================\");\n+    phase->C->root()->dump(9999);\n+    return false;\n@@ -226,0 +209,7 @@\n+}\n+\n+\/\/ Verify that optimizing the subtype check to a simple code pattern when possible would not constant fold better.\n+bool SubTypeCheckNode::verify(PhaseGVN* phase) {\n+  Compile* C = phase->C;\n+  Node* obj_or_subklass = in(ObjOrSubKlass);\n+  Node* superklass = in(SuperKlass);\n@@ -227,1 +217,7 @@\n-  if (super_t->singleton() && subk != NULL && phase->C->static_subtype_check(superk, subk) == Compile::SSC_full_test) {\n+  const Type* sub_t = phase->type(obj_or_subklass);\n+  const Type* super_t = phase->type(superklass);\n+\n+  ciKlass* subk = sub_t->isa_klassptr() ? sub_t->is_klassptr()->klass() : sub_t->is_oopptr()->klass(); \/\/ can be NULL for bottom[]\n+  ciKlass* superk = super_t->is_klassptr()->klass();\n+\n+  if (super_t->singleton() && subk != NULL) {\n@@ -231,1 +227,2 @@\n-      subklass = phase->transform(LoadKlassNode::make(*phase, NULL, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+      subklass  = phase->transform(LoadKlassNode::make(*phase, NULL, C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+      record_for_cleanup(subklass, phase);\n@@ -236,1 +233,14 @@\n-    Node *chk_off_X = chk_off;\n+    const Type* cached_t = Value(phase); \/\/ cache the type to validate consistency\n+    switch (C->static_subtype_check(superk, subk)) {\n+      case Compile::SSC_easy_test: {\n+        return verify_helper(phase, subklass, cached_t);\n+      }\n+      case Compile::SSC_full_test: {\n+        Node* p1 = phase->transform(new AddPNode(superklass, superklass, phase->MakeConX(in_bytes(Klass::super_check_offset_offset()))));\n+        Node* chk_off = phase->transform(new LoadINode(NULL, C->immutable_memory(), p1, phase->type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered));\n+        record_for_cleanup(chk_off, phase);\n+\n+        int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());\n+        bool might_be_cache = (phase->find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n+        if (!might_be_cache) {\n+          Node* chk_off_X = chk_off;\n@@ -238,1 +248,1 @@\n-    chk_off_X = phase->transform(new ConvI2LNode(chk_off_X));\n+          chk_off_X = phase->transform(new ConvI2LNode(chk_off_X));\n@@ -240,3 +250,2 @@\n-    Node *p2 = phase->transform(new AddPNode(subklass,subklass,chk_off_X));\n-    Node *kmem = phase->C->immutable_memory();\n-    Node *nkls = phase->transform(LoadKlassNode::make(*phase, NULL, kmem, p2, phase->type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));\n+          Node* p2 = phase->transform(new AddPNode(subklass, subklass, chk_off_X));\n+          Node* nkls = phase->transform(LoadKlassNode::make(*phase, NULL, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));\n@@ -244,17 +253,9 @@\n-    Node* res = new CmpPNode(superklass, nkls);\n-    Node* cmp = phase->transform(res);\n-    const Type* t = phase->type(cmp);\n-    if (!((Value(phase) == t) || (t != TypeInt::CC_GT && t != TypeInt::CC_EQ))) {\n-      Value(phase)->dump(); tty->cr();\n-      t->dump(); tty->cr();\n-      obj_or_subklass->dump();\n-      subklass->dump();\n-      superklass->dump();\n-      nkls->dump();\n-      cmp->dump();\n-      tty->print_cr(\"==============================\");\n-      phase->C->root()->dump(9999);\n-      fatal(\"missing Value() optimization\");\n-    }\n-    if (phase->is_IterGVN()) {\n-      phase->is_IterGVN()->_worklist.push(res);\n+          return verify_helper(phase, nkls, cached_t);\n+        }\n+        break;\n+      }\n+      case Compile::SSC_always_false:\n+      case Compile::SSC_always_true:\n+      default: {\n+        break; \/\/ nothing to do\n+      }\n@@ -262,3 +263,1 @@\n-    return NULL;\n-#endif\n-  return NULL;\n+  return true;\n@@ -268,0 +267,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":82,"deletions":82,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -1170,0 +1170,1 @@\n+    case Type::VectorMask:\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,9 @@\n+static bool is_vector_mask(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n+}\n+\n+static bool is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n+\n@@ -241,0 +250,15 @@\n+  ciInstanceKlass* iklass = vec_box->box_type()->klass()->as_instance_klass();\n+  int n_fields = iklass->nof_nonstatic_fields();\n+  assert(n_fields == 1, \"sanity\");\n+\n+  \/\/ If a mask is feeding into safepoint[s], then its value should be\n+  \/\/ packed into a boolean\/byte vector first, this will simplify the\n+  \/\/ re-materialization logic for both predicated and non-predicated\n+  \/\/ targets.\n+  bool is_mask = is_vector_mask(iklass);\n+  if (is_mask && vec_value->Opcode() != Op_VectorStoreMask) {\n+    const TypeVect* vt = vec_value->bottom_type()->is_vect();\n+    BasicType bt = vt->element_basic_type();\n+    vec_value = gvn.transform(VectorStoreMaskNode::make(gvn, vec_value, bt, vt->length()));\n+  }\n+\n@@ -244,4 +268,0 @@\n-    ciInstanceKlass* iklass = vec_box->box_type()->klass()->as_instance_klass();\n-    int n_fields = iklass->nof_nonstatic_fields();\n-    assert(n_fields == 1, \"sanity\");\n-\n@@ -308,8 +328,0 @@\n-static bool is_vector_mask(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-}\n-\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n@@ -397,1 +409,0 @@\n-    BasicType elem_bt;\n@@ -402,3 +413,0 @@\n-      if (vec_unbox->is_shuffle_to_vector() == true) {\n-        elem_bt = bt;\n-      }\n@@ -450,7 +458,3 @@\n-    } else if (is_vector_shuffle(from_kls)) {\n-      if (vec_unbox->is_shuffle_to_vector() == false) {\n-        assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n-        vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n-      } else {\n-        vec_val_load = gvn.transform(VectorCastNode::make(Op_VectorCastB2X, vec_val_load, elem_bt, num_elem));\n-      }\n+    } else if (is_vector_shuffle(from_kls) && !vec_unbox->is_shuffle_to_vector()) {\n+      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n+      vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":27,"deletions":23,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -3714,1 +3714,1 @@\n-          JavaThread* THREAD = thread;\n+          JavaThread* THREAD = thread; \/\/ For exception macros.\n@@ -3755,1 +3755,1 @@\n-      JavaThread* THREAD = JavaThread::current();\n+      JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  JavaThread* jthread = THREAD->as_Java_thread();\n+  JavaThread* jthread = THREAD;\n@@ -425,0 +425,1 @@\n+#if INCLUDE_CDS\n@@ -427,1 +428,1 @@\n-    MetaspaceShared::link_and_cleanup_shared_classes(THREAD);\n+    DynamicArchive::prepare_for_dynamic_dumping_at_exit();\n@@ -429,0 +430,1 @@\n+#endif\n@@ -445,0 +447,2 @@\n+    EventSystemGC event;\n+    event.set_invokedConcurrent(ExplicitGCInvokesConcurrent);\n@@ -446,0 +450,1 @@\n+    event.commit();\n@@ -865,1 +870,1 @@\n-  JavaThread* jt = THREAD->as_Java_thread();\n+  JavaThread* jt = THREAD;\n@@ -986,2 +991,0 @@\n-                          NULL, \/\/ unsafe_anonymous_host\n-                          NULL, \/\/ cp_patches\n@@ -1469,1 +1472,1 @@\n-  if (!inner_is_member)  return NULL;     \/\/ a hidden or unsafe anonymous class (inside a method)\n+  if (!inner_is_member)  return NULL;     \/\/ a hidden class (inside a method)\n@@ -3027,1 +3030,1 @@\n-      Thread::send_async_exception(java_thread, java_throwable);\n+      JavaThread::send_async_exception(java_thread, java_throwable);\n@@ -3592,5 +3595,5 @@\n-                                              jstring invokedName,\n-                                              jobject invokedType,\n-                                              jobject methodType,\n-                                              jobject implMethodMember,\n-                                              jobject instantiatedMethodType,\n+                                              jstring interfaceMethodName,\n+                                              jobject factoryType,\n+                                              jobject interfaceMethodType,\n+                                              jobject implementationMember,\n+                                              jobject dynamicMethodType,\n@@ -3605,2 +3608,2 @@\n-  if (caller_ik->is_hidden() || caller_ik->is_unsafe_anonymous()) {\n-    \/\/ VM anonymous classes and hidden classes not of type lambda proxy classes are currently not being archived.\n+  if (caller_ik->is_hidden()) {\n+    \/\/ Hidden classes not of type lambda proxy classes are currently not being archived.\n@@ -3616,3 +3619,3 @@\n-  Symbol* invoked_name = NULL;\n-  if (invokedName != NULL) {\n-    invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));\n+  Symbol* interface_method_name = NULL;\n+  if (interfaceMethodName != NULL) {\n+    interface_method_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(interfaceMethodName));\n@@ -3620,2 +3623,2 @@\n-  Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));\n-  Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);\n+  Handle factory_type_oop(THREAD, JNIHandles::resolve_non_null(factoryType));\n+  Symbol* factory_type = java_lang_invoke_MethodType::as_signature(factory_type_oop(), true);\n@@ -3623,2 +3626,2 @@\n-  Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));\n-  Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);\n+  Handle interface_method_type_oop(THREAD, JNIHandles::resolve_non_null(interfaceMethodType));\n+  Symbol* interface_method_type = java_lang_invoke_MethodType::as_signature(interface_method_type_oop(), true);\n@@ -3626,3 +3629,3 @@\n-  Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));\n-  assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), \"must be\");\n-  Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());\n+  Handle implementation_member_oop(THREAD, JNIHandles::resolve_non_null(implementationMember));\n+  assert(java_lang_invoke_MemberName::is_method(implementation_member_oop()), \"must be\");\n+  Method* m = java_lang_invoke_MemberName::vmtarget(implementation_member_oop());\n@@ -3630,2 +3633,2 @@\n-  Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));\n-  Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);\n+  Handle dynamic_method_type_oop(THREAD, JNIHandles::resolve_non_null(dynamicMethodType));\n+  Symbol* dynamic_method_type = java_lang_invoke_MethodType::as_signature(dynamic_method_type_oop(), true);\n@@ -3633,2 +3636,2 @@\n-  SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, invoked_name, invoked_type,\n-                                                 method_type, m, instantiated_method_type, THREAD);\n+  SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, interface_method_name, factory_type,\n+                                                 interface_method_type, m, dynamic_method_type, THREAD);\n@@ -3640,5 +3643,5 @@\n-                                                        jstring invokedName,\n-                                                        jobject invokedType,\n-                                                        jobject methodType,\n-                                                        jobject implMethodMember,\n-                                                        jobject instantiatedMethodType))\n+                                                        jstring interfaceMethodName,\n+                                                        jobject factoryType,\n+                                                        jobject interfaceMethodType,\n+                                                        jobject implementationMember,\n+                                                        jobject dynamicMethodType))\n@@ -3647,2 +3650,2 @@\n-  if (invokedName == NULL || invokedType == NULL || methodType == NULL ||\n-      implMethodMember == NULL || instantiatedMethodType == NULL) {\n+  if (interfaceMethodName == NULL || factoryType == NULL || interfaceMethodType == NULL ||\n+      implementationMember == NULL || dynamicMethodType == NULL) {\n@@ -3659,3 +3662,3 @@\n-  Symbol* invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));\n-  Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));\n-  Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);\n+  Symbol* interface_method_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(interfaceMethodName));\n+  Handle factory_type_oop(THREAD, JNIHandles::resolve_non_null(factoryType));\n+  Symbol* factory_type = java_lang_invoke_MethodType::as_signature(factory_type_oop(), true);\n@@ -3663,2 +3666,2 @@\n-  Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));\n-  Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);\n+  Handle interface_method_type_oop(THREAD, JNIHandles::resolve_non_null(interfaceMethodType));\n+  Symbol* interface_method_type = java_lang_invoke_MethodType::as_signature(interface_method_type_oop(), true);\n@@ -3666,3 +3669,3 @@\n-  Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));\n-  assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), \"must be\");\n-  Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());\n+  Handle implementation_member_oop(THREAD, JNIHandles::resolve_non_null(implementationMember));\n+  assert(java_lang_invoke_MemberName::is_method(implementation_member_oop()), \"must be\");\n+  Method* m = java_lang_invoke_MemberName::vmtarget(implementation_member_oop());\n@@ -3670,2 +3673,2 @@\n-  Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));\n-  Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);\n+  Handle dynamic_method_type_oop(THREAD, JNIHandles::resolve_non_null(dynamicMethodType));\n+  Symbol* dynamic_method_type = java_lang_invoke_MethodType::as_signature(dynamic_method_type_oop(), true);\n@@ -3673,2 +3676,2 @@\n-  InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, invoked_name, invoked_type,\n-                                                                                   method_type, m, instantiated_method_type);\n+  InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, interface_method_name, factory_type,\n+                                                                                   interface_method_type, m, dynamic_method_type);\n@@ -3758,1 +3761,1 @@\n-  DynamicArchive::dump(archive_name, THREAD);\n+  DynamicArchive::dump(archive_name, CHECK);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":51,"deletions":48,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -793,3 +793,0 @@\n-  if (inner_classes_length > 0) {\n-    write_inner_classes_attribute(inner_classes_length);\n-  }\n@@ -802,3 +799,0 @@\n-  if (cpool()->operands() != NULL) {\n-    write_bootstrapmethod_attribute();\n-  }\n@@ -817,0 +811,6 @@\n+  if (cpool()->operands() != NULL) {\n+    write_bootstrapmethod_attribute();\n+  }\n+  if (inner_classes_length > 0) {\n+    write_inner_classes_attribute(inner_classes_length);\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -143,2 +143,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -165,2 +164,1 @@\n-\/\/ Threads_lock NOT held\n-\/\/ thread - NOT pre-checked\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -219,1 +217,1 @@\n-  JavaThread* THREAD = JavaThread::current(); \/\/ pass to macros\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -236,1 +234,1 @@\n-  JavaThread* THREAD = JavaThread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -257,1 +255,1 @@\n-  JavaThread* THREAD = JavaThread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -279,1 +277,1 @@\n-  JavaThread* THREAD = JavaThread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -300,1 +298,1 @@\n-  JavaThread* THREAD = JavaThread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -322,1 +320,1 @@\n-  JavaThread* THREAD = JavaThread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -348,1 +346,1 @@\n-  JavaThread* THREAD = JavaThread::current();\n+  JavaThread* current = JavaThread::current();\n@@ -351,1 +349,1 @@\n-  Handle h_module(THREAD, JNIHandles::resolve(module));\n+  Handle h_module(current, JNIHandles::resolve(module));\n@@ -693,1 +691,1 @@\n-    JavaThread* THREAD = JavaThread::current();\n+    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -842,2 +840,1 @@\n-\/\/ Threads_lock NOT held\n-\/\/ thread - NOT pre-checked\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -939,2 +936,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1021,2 +1017,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1074,2 +1069,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1088,2 +1082,1 @@\n-\/\/ Threads_lock NOT held\n-\/\/ thread - NOT pre-checked\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1110,2 +1103,1 @@\n-\/\/ Threads_lock NOT held\n-\/\/ thread - NOT pre-checked\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1183,2 +1175,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1233,2 +1224,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1287,2 +1277,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1309,2 +1298,1 @@\n-\/\/ Threads_lock NOT held\n-\/\/ thread - NOT pre-checked\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1524,2 +1512,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1603,2 +1590,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1630,2 +1616,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1659,3 +1644,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1683,3 +1666,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1709,2 +1690,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1719,2 +1699,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1729,2 +1708,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1739,2 +1717,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1749,2 +1726,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1759,2 +1735,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1938,3 +1913,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1961,3 +1934,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -1985,3 +1956,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -2003,3 +1972,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -2021,3 +1988,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -2039,3 +2004,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -2057,3 +2020,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -2074,3 +2035,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -2091,3 +2050,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -2108,3 +2065,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -2125,3 +2080,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n-\/\/ java_thread - unchecked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n@@ -3196,25 +3149,1 @@\n-    Thread* thread = Thread::current();\n-    if (thread->is_Java_thread()) {\n-      JavaThread* current_thread = thread->as_Java_thread();\n-\n-      \/* Transition to thread_blocked without entering vm state          *\/\n-      \/* This is really evil. Normally you can't undo _thread_blocked    *\/\n-      \/* transitions like this because it would cause us to miss a       *\/\n-      \/* safepoint but since the thread was already in _thread_in_native *\/\n-      \/* the thread is not leaving a safepoint safe state and it will    *\/\n-      \/* block when it tries to return from native. We can't safepoint   *\/\n-      \/* block in here because we could deadlock the vmthread. Blech.    *\/\n-\n-      JavaThreadState state = current_thread->thread_state();\n-      assert(state == _thread_in_native, \"Must be _thread_in_native\");\n-      \/\/ frame should already be walkable since we are in native\n-      assert(!current_thread->has_last_Java_frame() ||\n-             current_thread->frame_anchor()->walkable(), \"Must be walkable\");\n-      current_thread->set_thread_state(_thread_blocked);\n-\n-      rmonitor->raw_enter(current_thread);\n-      \/\/ restore state, still at a safepoint safe state\n-      current_thread->set_thread_state(state);\n-    } else {\n-      rmonitor->raw_enter(thread);\n-    }\n+    rmonitor->raw_enter(Thread::current());\n@@ -3398,2 +3327,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":45,"deletions":117,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -1369,2 +1369,1 @@\n-\/\/ Threads_lock NOT held, java_thread not protected by lock\n-\/\/ java_thread - pre-checked\n+\/\/ java_thread - protected by ThreadsListHandle and pre-checked\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-    \/\/ classes for primitives, arrays, hidden and vm unsafe anonymous classes\n+    \/\/ classes for primitives, arrays, and hidden classes\n@@ -345,3 +345,2 @@\n-  \/\/ Cannot redefine or retransform a hidden or an unsafe anonymous class.\n-  if (InstanceKlass::cast(k)->is_hidden() ||\n-      InstanceKlass::cast(k)->is_unsafe_anonymous()) {\n+  \/\/ Cannot redefine or retransform a hidden class.\n+  if (InstanceKlass::cast(k)->is_hidden()) {\n@@ -1392,1 +1391,1 @@\n-    Thread* THREAD = current;  \/\/ for exception processing\n+    JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -1864,3 +1863,6 @@\n-  \/\/ Save fields from the old_cp.\n-  merge_cp->copy_fields(old_cp());\n-  scratch_cp->copy_fields(old_cp());\n+  \/\/ Set dynamic constants attribute from the original CP.\n+  if (old_cp->has_dynamic_constant()) {\n+    scratch_cp->set_has_dynamic_constant();\n+  }\n+  \/\/ Copy attributes from scratch_cp to merge_cp\n+  merge_cp->copy_fields(scratch_cp());\n@@ -2120,1 +2122,1 @@\n-  Thread* THREAD = Thread::current();  \/\/ For exception processing\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -2950,1 +2952,0 @@\n-    \/\/       (including the direct superclass of an unsafe anonymous class declaration),\n@@ -4409,0 +4410,10 @@\n+  \/\/ Replace minor version number of class file\n+  u2 old_minor_version = the_class->constants()->minor_version();\n+  the_class->constants()->set_minor_version(scratch_class->constants()->minor_version());\n+  scratch_class->constants()->set_minor_version(old_minor_version);\n+\n+  \/\/ Replace major version number of class file\n+  u2 old_major_version = the_class->constants()->major_version();\n+  the_class->constants()->set_major_version(scratch_class->constants()->major_version());\n+  scratch_class->constants()->set_major_version(old_major_version);\n+\n@@ -4433,1 +4444,1 @@\n-  increment_class_counter((InstanceKlass *)the_class);\n+  increment_class_counter(the_class);\n@@ -4462,18 +4473,14 @@\n-void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik) {\n-  oop class_mirror = ik->java_mirror();\n-  Klass* class_oop = java_lang_Class::as_Klass(class_mirror);\n-  int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;\n-  java_lang_Class::set_classRedefinedCount(class_mirror, new_count);\n-\n-  if (class_oop != _the_class) {\n-    \/\/ _the_class count is printed at end of redefine_single_class()\n-    log_debug(redefine, class, subclass)(\"updated count in subclass=%s to %d\", ik->external_name(), new_count);\n-  }\n-\n-  for (Klass *subk = ik->subklass(); subk != NULL;\n-       subk = subk->next_sibling()) {\n-    if (subk->is_instance_klass()) {\n-      \/\/ Only update instanceKlasses\n-      InstanceKlass *subik = InstanceKlass::cast(subk);\n-      \/\/ recursively do subclasses of the current subclass\n-      increment_class_counter(subik);\n+void VM_RedefineClasses::increment_class_counter(InstanceKlass* ik) {\n+  for (ClassHierarchyIterator iter(ik); !iter.done(); iter.next()) {\n+    \/\/ Only update instanceKlasses\n+    Klass* sub = iter.klass();\n+    if (sub->is_instance_klass()) {\n+      oop class_mirror = InstanceKlass::cast(sub)->java_mirror();\n+      Klass* class_oop = java_lang_Class::as_Klass(class_mirror);\n+      int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;\n+      java_lang_Class::set_classRedefinedCount(class_mirror, new_count);\n+\n+      if (class_oop != _the_class) {\n+        \/\/ _the_class count is printed at end of redefine_single_class()\n+        log_debug(redefine, class, subclass)(\"updated count in subclass=%s to %d\", ik->external_name(), new_count);\n+      }\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":36,"deletions":29,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -867,177 +867,0 @@\n-\/\/ define a class but do not make it known to the class loader or system dictionary\n-\/\/ - host_class:  supplies context for linkage, access control, protection domain, and class loader\n-\/\/                if host_class is itself anonymous then it is replaced with its host class.\n-\/\/ - data:  bytes of a class file, a raw memory address (length gives the number of bytes)\n-\/\/ - cp_patches:  where non-null entries exist, they replace corresponding CP entries in data\n-\n-\/\/ When you load an anonymous class U, it works as if you changed its name just before loading,\n-\/\/ to a name that you will never use again.  Since the name is lost, no other class can directly\n-\/\/ link to any member of U.  Just after U is loaded, the only way to use it is reflectively,\n-\/\/ through java.lang.Class methods like Class.newInstance.\n-\n-\/\/ The package of an anonymous class must either match its host's class's package or be in the\n-\/\/ unnamed package.  If it is in the unnamed package then it will be put in its host class's\n-\/\/ package.\n-\/\/\n-\n-\/\/ Access checks for linkage sites within U continue to follow the same rules as for named classes.\n-\/\/ An anonymous class also has special privileges to access any member of its host class.\n-\/\/ This is the main reason why this loading operation is unsafe.  The purpose of this is to\n-\/\/ allow language implementations to simulate \"open classes\"; a host class in effect gets\n-\/\/ new code when an anonymous class is loaded alongside it.  A less convenient but more\n-\/\/ standard way to do this is with reflection, which can also be set to ignore access\n-\/\/ restrictions.\n-\n-\/\/ Access into an anonymous class is possible only through reflection.  Therefore, there\n-\/\/ are no special access rules for calling into an anonymous class.  The relaxed access\n-\/\/ rule for the host class is applied in the opposite direction:  A host class reflectively\n-\/\/ access one of its anonymous classes.\n-\n-\/\/ If you load the same bytecodes twice, you get two different classes.  You can reload\n-\/\/ the same bytecodes with or without varying CP patches.\n-\n-\/\/ By using the CP patching array, you can have a new anonymous class U2 refer to an older one U1.\n-\/\/ The bytecodes for U2 should refer to U1 by a symbolic name (doesn't matter what the name is).\n-\/\/ The CONSTANT_Class entry for that name can be patched to refer directly to U1.\n-\n-\/\/ This allows, for example, U2 to use U1 as a superclass or super-interface, or as\n-\/\/ an outer class (so that U2 is an anonymous inner class of anonymous U1).\n-\/\/ It is not possible for a named class, or an older anonymous class, to refer by\n-\/\/ name (via its CP) to a newer anonymous class.\n-\n-\/\/ CP patching may also be used to modify (i.e., hack) the names of methods, classes,\n-\/\/ or type descriptors used in the loaded anonymous class.\n-\n-\/\/ Finally, CP patching may be used to introduce \"live\" objects into the constant pool,\n-\/\/ instead of \"dead\" strings.  A compiled statement like println((Object)\"hello\") can\n-\/\/ be changed to println(greeting), where greeting is an arbitrary object created before\n-\/\/ the anonymous class is loaded.  This is useful in dynamic languages, in which\n-\/\/ various kinds of metaobjects must be introduced as constants into bytecode.\n-\/\/ Note the cast (Object), which tells the verifier to expect an arbitrary object,\n-\/\/ not just a literal string.  For such ldc instructions, the verifier uses the\n-\/\/ type Object instead of String, if the loaded constant is not in fact a String.\n-\/\/\n-\/\/ An anonymous class cannot be an inline type.\n-\n-static InstanceKlass*\n-Unsafe_DefineAnonymousClass_impl(JNIEnv *env,\n-                                 jclass host_class, jbyteArray data, jobjectArray cp_patches_jh,\n-                                 u1** temp_alloc,\n-                                 TRAPS) {\n-  assert(host_class != NULL, \"host_class must not be NULL\");\n-  assert(data != NULL, \"data must not be NULL\");\n-\n-  if (UsePerfData) {\n-    ClassLoader::unsafe_defineClassCallCounter()->inc();\n-  }\n-\n-  jint length = typeArrayOop(JNIHandles::resolve_non_null(data))->length();\n-  assert(length >= 0, \"class_bytes_length must not be negative: %d\", length);\n-\n-  int class_bytes_length = (int) length;\n-\n-  u1* class_bytes = NEW_C_HEAP_ARRAY_RETURN_NULL(u1, length, mtInternal);\n-  if (class_bytes == NULL) {\n-    THROW_0(vmSymbols::java_lang_OutOfMemoryError());\n-  }\n-\n-  \/\/ caller responsible to free it:\n-  *temp_alloc = class_bytes;\n-\n-  ArrayAccess<>::arraycopy_to_native(arrayOop(JNIHandles::resolve_non_null(data)), typeArrayOopDesc::element_offset<jbyte>(0),\n-                                     reinterpret_cast<jbyte*>(class_bytes), length);\n-\n-  objArrayHandle cp_patches_h;\n-  if (cp_patches_jh != NULL) {\n-    oop p = JNIHandles::resolve_non_null(cp_patches_jh);\n-    assert(p->is_objArray(), \"cp_patches must be an object[]\");\n-    cp_patches_h = objArrayHandle(THREAD, (objArrayOop)p);\n-  }\n-\n-  const Klass* host_klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(host_class));\n-\n-  \/\/ Make sure it's the real host class, not another anonymous class.\n-  while (host_klass != NULL && host_klass->is_instance_klass() &&\n-         InstanceKlass::cast(host_klass)->is_unsafe_anonymous()) {\n-    host_klass = InstanceKlass::cast(host_klass)->unsafe_anonymous_host();\n-  }\n-\n-  \/\/ Primitive types have NULL Klass* fields in their java.lang.Class instances.\n-  if (host_klass == NULL) {\n-    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Host class is null\");\n-  }\n-\n-  assert(host_klass->is_instance_klass(), \"Host class must be an instance class\");\n-\n-  const char* host_source = host_klass->external_name();\n-  Handle      host_loader(THREAD, host_klass->class_loader());\n-  Handle      host_domain(THREAD, host_klass->protection_domain());\n-\n-  GrowableArray<Handle>* cp_patches = NULL;\n-\n-  if (cp_patches_h.not_null()) {\n-    int alen = cp_patches_h->length();\n-\n-    for (int i = alen-1; i >= 0; i--) {\n-      oop p = cp_patches_h->obj_at(i);\n-      if (p != NULL) {\n-        Handle patch(THREAD, p);\n-\n-        if (cp_patches == NULL) {\n-          cp_patches = new GrowableArray<Handle>(i+1, i+1, Handle());\n-        }\n-\n-        cp_patches->at_put(i, patch);\n-      }\n-    }\n-  }\n-\n-  ClassFileStream st(class_bytes, class_bytes_length, host_source, ClassFileStream::verify);\n-\n-  Symbol* no_class_name = NULL;\n-  ClassLoadInfo cl_info(host_domain,\n-                        InstanceKlass::cast(host_klass),\n-                        cp_patches,\n-                        NULL,     \/\/ dynamic_nest_host\n-                        Handle(), \/\/ classData\n-                        false,    \/\/ is_hidden\n-                        false,    \/\/ is_strong_hidden\n-                        true);    \/\/ can_access_vm_annotations\n-\n-  InstanceKlass* anonk = SystemDictionary::resolve_from_stream(&st, no_class_name,\n-                                                               host_loader,\n-                                                               cl_info,\n-                                                               CHECK_NULL);\n-  assert(anonk != NULL, \"no klass created\");\n-  assert(!anonk->is_inline_klass(), \"unsafe anonymous class cannot be inline class\");\n-  return anonk;\n-}\n-\n-UNSAFE_ENTRY(jclass, Unsafe_DefineAnonymousClass0(JNIEnv *env, jobject unsafe, jclass host_class, jbyteArray data, jobjectArray cp_patches_jh)) {\n-  ResourceMark rm(THREAD);\n-\n-  jobject res_jh = NULL;\n-  u1* temp_alloc = NULL;\n-\n-  InstanceKlass* anon_klass = Unsafe_DefineAnonymousClass_impl(env, host_class, data, cp_patches_jh, &temp_alloc, THREAD);\n-  if (anon_klass != NULL) {\n-    res_jh = JNIHandles::make_local(THREAD, anon_klass->java_mirror());\n-  }\n-\n-  \/\/ try\/finally clause:\n-  FREE_C_HEAP_ARRAY(u1, temp_alloc);\n-\n-  \/\/ The anonymous class loader data has been artificially been kept alive to\n-  \/\/ this point.   The mirror and any instances of this class have to keep\n-  \/\/ it alive afterwards.\n-  if (anon_klass != NULL) {\n-    anon_klass->class_loader_data()->dec_keep_alive();\n-  }\n-\n-  \/\/ let caller initialize it as needed...\n-\n-  return (jclass) res_jh;\n-} UNSAFE_END\n-\n-\n-\n@@ -1272,2 +1095,0 @@\n-    {CC \"defineAnonymousClass0\", CC \"(\" DAC_Args \")\" CLS, FN_PTR(Unsafe_DefineAnonymousClass0)},\n-\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":0,"deletions":179,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -186,0 +186,19 @@\n+      } else if (k->is_instance_klass()) {\n+        \/\/ Need special handling for hidden classes because the JVM\n+        \/\/ appends \"+<hex-address>\" to hidden class names.\n+        InstanceKlass *ik = InstanceKlass::cast(k);\n+        if (ik->is_hidden()) {\n+          ResourceMark rm;\n+          char* k_name = ksym->as_C_string();\n+          \/\/ Find the first '+' char and truncate the string at that point.\n+          \/\/ NOTE: This will not work correctly if the original hidden class\n+          \/\/ name contains a '+'.\n+          char* plus_char = strchr(k_name, '+');\n+          if (plus_char != NULL) {\n+            *plus_char = 0;\n+            char* c_name = _name->as_C_string();\n+            if (strcmp(c_name, k_name) == 0) {\n+              _count++;\n+            }\n+          }\n+        }\n@@ -989,1 +1008,1 @@\n-bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {\n+bool WhiteBox::compile_method(Method* method, int comp_level, int bci, JavaThread* THREAD) {\n@@ -2043,1 +2062,1 @@\n-WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))\n+WB_ENTRY(jboolean, WB_IsCDSIncluded(JNIEnv* env))\n@@ -2051,1 +2070,1 @@\n-WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))\n+WB_ENTRY(jboolean, WB_isC2OrJVMCIIncluded(JNIEnv* env))\n@@ -2072,1 +2091,1 @@\n-WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))\n+WB_ENTRY(jboolean, WB_IsJFRIncluded(JNIEnv* env))\n@@ -2154,1 +2173,0 @@\n-  Thread* THREAD = Thread::current();\n@@ -2375,1 +2393,1 @@\n-WB_ENTRY(void, WB_VerifyFrames(JNIEnv* env, jobject wb, jboolean log))\n+WB_ENTRY(void, WB_VerifyFrames(JNIEnv* env, jobject wb, jboolean log, jboolean update_map))\n@@ -2381,1 +2399,1 @@\n-  for (StackFrameStream fst(JavaThread::current(), true, true); !fst.is_done(); fst.next()) {\n+  for (StackFrameStream fst(JavaThread::current(), update_map, true); !fst.is_done(); fst.next()) {\n@@ -2395,1 +2413,5 @@\n-  return INCLUDE_JVMTI ? JNI_TRUE : JNI_FALSE;\n+#if INCLUDE_JVMTI\n+  return JNI_TRUE;\n+#else\n+  return JNI_FALSE;\n+#endif\n@@ -2632,3 +2654,3 @@\n-  {CC\"isCDSIncludedInVmBuild\",            CC\"()Z\",    (void*)&WB_IsCDSIncludedInVmBuild },\n-  {CC\"isJFRIncludedInVmBuild\",            CC\"()Z\",    (void*)&WB_IsJFRIncludedInVmBuild },\n-  {CC\"isC2OrJVMCIIncludedInVmBuild\",      CC\"()Z\",    (void*)&WB_isC2OrJVMCIIncludedInVmBuild },\n+  {CC\"isCDSIncluded\",                     CC\"()Z\",    (void*)&WB_IsCDSIncluded },\n+  {CC\"isJFRIncluded\",                     CC\"()Z\",    (void*)&WB_IsJFRIncluded },\n+  {CC\"isC2OrJVMCIIncluded\",               CC\"()Z\",    (void*)&WB_isC2OrJVMCIIncluded },\n@@ -2643,1 +2665,1 @@\n-  {CC\"verifyFrames\",                CC\"(Z)V\",            (void*)&WB_VerifyFrames },\n+  {CC\"verifyFrames\",                CC\"(ZZ)V\",            (void*)&WB_VerifyFrames },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":34,"deletions":12,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -311,0 +312,2 @@\n+#define ENABLE_NATIVE_ACCESS \"enable.native.access\"\n+#define ENABLE_NATIVE_ACCESS_LEN 20\n@@ -349,1 +352,2 @@\n-        matches_property_suffix(property_suffix, UPGRADE_PATH, UPGRADE_PATH_LEN)) {\n+        matches_property_suffix(property_suffix, UPGRADE_PATH, UPGRADE_PATH_LEN) ||\n+        matches_property_suffix(property_suffix, ENABLE_NATIVE_ACCESS, ENABLE_NATIVE_ACCESS_LEN)) {\n@@ -526,1 +530,1 @@\n-  { \"CriticalJNINatives\",           JDK_Version::jdk(16), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"CriticalJNINatives\",           JDK_Version::jdk(16), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n@@ -1332,1 +1336,0 @@\n-      strcmp(key, \"jdk.module.illegalAccess\") == 0 ||\n@@ -1967,0 +1970,1 @@\n+unsigned int enable_native_access_count = 0;\n@@ -2073,2 +2077,1 @@\n-  assert(is_internal_module_property(prop_name) ||\n-         strcmp(prop_name, \"jdk.module.illegalAccess\") == 0, \"unknown module property: '%s'\", prop_name);\n+  assert(is_internal_module_property(prop_name), \"unknown module property: '%s'\", prop_name);\n@@ -2420,0 +2423,4 @@\n+    } else if (match_option(option, \"--enable-native-access=\", &tail)) {\n+      if (!create_numbered_module_property(\"jdk.module.enable.native.access\", tail, enable_native_access_count++)) {\n+        return JNI_ENOMEM;\n+      }\n@@ -2439,4 +2446,3 @@\n-      warning(\"Option --illegal-access is deprecated and will be removed in a future release.\");\n-      if (!create_module_property(\"jdk.module.illegalAccess\", tail, ExternalProperty)) {\n-        return JNI_ENOMEM;\n-      }\n+      char version[256];\n+      JDK_Version::jdk(17).to_string(version, sizeof(version));\n+      warning(\"Ignoring option %s; support was removed in %s\", option->optionString, version);\n@@ -2760,0 +2766,3 @@\n+      } else if (strcmp(tail, \":async\") == 0) {\n+        LogConfiguration::set_async_mode(true);\n+        ret = true;\n@@ -4034,0 +4043,4 @@\n+  if (!StringDedup::ergo_initialize()) {\n+    return JNI_EINVAL;\n+  }\n+\n@@ -4132,0 +4145,5 @@\n+\n+    if (!FLAG_IS_DEFAULT(UseVectorStubs) && UseVectorStubs) {\n+      warning(\"Disabling UseVectorStubs since EnableVectorSupport is turned off.\");\n+    }\n+    FLAG_SET_DEFAULT(UseVectorStubs, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":27,"deletions":9,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-      Thread* THREAD = thread;\n+      JavaThread* THREAD = thread; \/\/ For exception macros.\n@@ -1889,1 +1889,1 @@\n-  Thread* THREAD = thread;\n+  JavaThread* THREAD = thread; \/\/ For exception macros.\n@@ -1927,1 +1927,1 @@\n-      JavaThread* jt = THREAD->as_Java_thread();\n+      JavaThread* jt = THREAD;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -133,0 +133,2 @@\n+#endif \/* PRODUCT *\/\n+\n@@ -240,1 +242,0 @@\n-#endif \/* PRODUCT *\/\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,2 +118,2 @@\n-  void print_on(outputStream* st) const         PRODUCT_RETURN;\n-  void print_on_for(outputStream* st, oop obj)  PRODUCT_RETURN;\n+  void print_on(outputStream* st) const;\n+  void print_on_for(outputStream* st, oop obj);\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  \/\/ Unsafe to use the is_deoptimzed tester after changing pc\n+  \/\/ Unsafe to use the is_deoptimized tester after changing pc\n@@ -1111,0 +1111,4 @@\n+  } else if (is_optimized_entry_frame()) {\n+   \/\/ Nothing to do\n+   \/\/ receiver is a global ref\n+   \/\/ handle block is for JNI\n@@ -1149,1 +1153,3 @@\n-  oops_do_internal(&VerifyOopClosure::verify_oop, NULL, map, false, DerivedPointerIterationMode::_ignore);\n+  if (map->update_map()) { \/\/ The map has to be up-to-date for the current frame\n+    oops_do_internal(&VerifyOopClosure::verify_oop, NULL, map, false, DerivedPointerIterationMode::_ignore);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+  bool is_optimized_entry_frame()         const;\n@@ -175,0 +176,1 @@\n+  frame sender_for_optimized_entry_frame(RegisterMap* map) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -242,1 +242,2 @@\n-          \"Large page size (0 to let VM choose the page size)\")             \\\n+          \"Maximum large page size used (0 will use the default large \"     \\\n+          \"page size for the environment as the maximum)\")                  \\\n@@ -714,1 +715,1 @@\n-  product(intx, MonitorUsedDeflationThreshold, 90, EXPERIMENTAL,            \\\n+  product(intx, MonitorUsedDeflationThreshold, 90, DIAGNOSTIC,              \\\n@@ -1015,0 +1016,3 @@\n+  product(bool, UseVtableBasedCHA, true,  DIAGNOSTIC,                       \\\n+          \"Use vtable information during CHA\")                              \\\n+                                                                            \\\n@@ -1167,3 +1171,0 @@\n-  develop(bool, UseLoopSafepoints, true,                                    \\\n-          \"Generate Safepoint nodes in every loop\")                         \\\n-                                                                            \\\n@@ -1486,0 +1487,4 @@\n+  develop(size_t, CompressedClassSpaceBaseAddress, 0,                       \\\n+          \"Force the class space to be allocated at this address or \"       \\\n+          \"fails VM initialization (requires -Xshare=off.\")                 \\\n+                                                                            \\\n@@ -1961,1 +1966,1 @@\n-  product(uintx, StringDeduplicationAgeThreshold, 3,                        \\\n+  product(uint, StringDeduplicationAgeThreshold, 3,                         \\\n@@ -1966,0 +1971,23 @@\n+  product(size_t, StringDeduplicationInitialTableSize, 500, EXPERIMENTAL,   \\\n+          \"Approximate initial number of buckets in the table\")             \\\n+          range(1, 1 * G)                                                   \\\n+                                                                            \\\n+  product(double, StringDeduplicationGrowTableLoad, 14.0, EXPERIMENTAL,     \\\n+          \"Entries per bucket above which the table should be expanded\")    \\\n+          range(0.1, 1000.0)                                                \\\n+                                                                            \\\n+  product(double, StringDeduplicationShrinkTableLoad, 1.0, EXPERIMENTAL,    \\\n+          \"Entries per bucket below which the table should be shrunk\")      \\\n+          range(0.01, 100.0)                                                \\\n+                                                                            \\\n+  product(double, StringDeduplicationTargetTableLoad, 7.0, EXPERIMENTAL,    \\\n+          \"Desired entries per bucket when resizing the table\")             \\\n+          range(0.01, 1000.0)                                               \\\n+                                                                            \\\n+  product(size_t, StringDeduplicationCleanupDeadMinimum, 100, EXPERIMENTAL, \\\n+          \"Minimum number of dead table entries for cleaning the table\")    \\\n+                                                                            \\\n+  product(int, StringDeduplicationCleanupDeadPercent, 5, EXPERIMENTAL,      \\\n+          \"Minimum percentage of dead table entries for cleaning the table\") \\\n+          range(1, 100)                                                     \\\n+                                                                            \\\n@@ -1967,1 +1995,1 @@\n-          \"Force table resize every time the table is scanned\")             \\\n+          \"Force more frequent table resizing\")                             \\\n@@ -1969,2 +1997,2 @@\n-  product(bool, StringDeduplicationRehashALot, false, DIAGNOSTIC,           \\\n-          \"Force table rehash every time the table is scanned\")             \\\n+  product(uint64_t, StringDeduplicationHashSeed, 0, DIAGNOSTIC,             \\\n+          \"Seed for the table hashing function; 0 requests computed seed\")  \\\n@@ -2013,0 +2041,5 @@\n+  product(size_t, AsyncLogBufferSize, 2*M,                                  \\\n+          \"Memory budget (in bytes) for the buffer of Asynchronous \"        \\\n+          \"Logging (-Xlog:async).\")                                         \\\n+          range(100*K, 50*M)                                                \\\n+                                                                            \\\n@@ -2095,0 +2128,3 @@\n+                                                                            \\\n+  develop(bool, TraceOptimizedUpcallStubs, false,                              \\\n+                \"Trace optimized upcall stub generation\")                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":45,"deletions":9,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -127,0 +128,1 @@\n+  AsyncLogWriter::initialize();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  JavaThread* thread = THREAD->as_Java_thread();\n+  JavaThread* thread = THREAD;\n@@ -355,3 +355,2 @@\n-  \/\/ Check if we need to wrap a potential OS exception handler around thread\n-  \/\/ This is used for e.g. Win32 structured exception handlers\n-  assert(THREAD->is_Java_thread(), \"only JavaThreads can make JavaCalls\");\n+  \/\/ Check if we need to wrap a potential OS exception handler around thread.\n+  \/\/ This is used for e.g. Win32 structured exception handlers.\n@@ -359,1 +358,1 @@\n-  \/\/ stack that has installed its own exception handlers\n+  \/\/ stack that has installed its own exception handlers.\n@@ -365,1 +364,1 @@\n-  JavaThread* thread = THREAD->as_Java_thread();\n+  JavaThread* thread = THREAD;\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-      Thread* THREAD = Thread::current();\n+      JavaThread* THREAD = Thread::current()->as_Java_thread();\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"runtime\/jniHandles.hpp\"\n+\n@@ -30,1 +32,0 @@\n-#include \"runtime\/jniHandles.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -404,15 +404,0 @@\n-static bool under_unsafe_anonymous_host(const InstanceKlass* ik, const InstanceKlass* unsafe_anonymous_host) {\n-  DEBUG_ONLY(int inf_loop_check = 1000 * 1000 * 1000);\n-  for (;;) {\n-    const InstanceKlass* hc = ik->unsafe_anonymous_host();\n-    if (hc == NULL)        return false;\n-    if (hc == unsafe_anonymous_host)  return true;\n-    ik = hc;\n-\n-    \/\/ There's no way to make a host class loop short of patching memory.\n-    \/\/ Therefore there cannot be a loop here unless there's another bug.\n-    \/\/ Still, let's check for it.\n-    assert(--inf_loop_check > 0, \"no unsafe_anonymous_host loop\");\n-  }\n-}\n-\n@@ -426,6 +411,0 @@\n-  \/\/ If either is on the other's unsafe_anonymous_host chain, access is OK,\n-  \/\/ because one is inside the other.\n-  if (under_unsafe_anonymous_host(accessor_ik, accessee_ik) ||\n-    under_unsafe_anonymous_host(accessee_ik, accessor_ik))\n-    return true;\n-\n@@ -654,10 +633,1 @@\n-  const Klass* host_class = current_class;\n-  if (current_class->is_instance_klass() &&\n-      InstanceKlass::cast(current_class)->is_unsafe_anonymous()) {\n-    host_class = InstanceKlass::cast(current_class)->unsafe_anonymous_host();\n-    assert(host_class != NULL, \"Unsafe anonymous class has null host class\");\n-    assert(!(host_class->is_instance_klass() &&\n-           InstanceKlass::cast(host_class)->is_unsafe_anonymous()),\n-           \"unsafe_anonymous_host should not be unsafe anonymous itself\");\n-  }\n-  if (host_class == member_class) {\n+  if (current_class == member_class) {\n@@ -671,1 +641,1 @@\n-      if (!host_class->is_interface() && host_class->is_subclass_of(member_class)) {\n+      if (!current_class->is_interface() && current_class->is_subclass_of(member_class)) {\n@@ -675,2 +645,2 @@\n-            host_class->is_subclass_of(resolved_class) ||\n-            resolved_class->is_subclass_of(host_class)) {\n+            current_class->is_subclass_of(resolved_class) ||\n+            resolved_class->is_subclass_of(current_class)) {\n@@ -688,3 +658,2 @@\n-  \/\/ private access between different classes needs a nestmate check, but\n-  \/\/ not for unsafe anonymous classes - so check host_class\n-  if (access.is_private() && host_class == current_class) {\n+  \/\/ private access between different classes needs a nestmate check.\n+  if (access.is_private()) {\n@@ -721,1 +690,1 @@\n-\/\/ If !inner_is_member, require the inner to be hidden or unsafe anonymous (non-members).\n+\/\/ If !inner_is_member, require the inner to be hidden (non-member).\n@@ -801,1 +770,0 @@\n-\n@@ -1044,3 +1012,1 @@\n-          if (THREAD->is_Java_thread()) {\n-            JvmtiExport::clear_detected_exception(THREAD->as_Java_thread());\n-          }\n+          JvmtiExport::clear_detected_exception(THREAD);\n@@ -1158,3 +1124,1 @@\n-    if (THREAD->is_Java_thread()) {\n-      JvmtiExport::clear_detected_exception(THREAD->as_Java_thread());\n-    }\n+    JvmtiExport::clear_detected_exception(THREAD);\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":9,"deletions":45,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -905,1 +905,1 @@\n-  assert(self == Thread::current()->as_Java_thread(), \"must be self\");\n+  assert(self == JavaThread::current(), \"must be self\");\n@@ -1002,1 +1002,1 @@\n-    if (self->has_async_condition()) {\n+    if (self->has_async_exception_condition()) {\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -516,0 +516,3 @@\n+  if (blob != NULL && blob->is_optimized_entry_blob()) {\n+    return ((OptimizedEntryBlob*)blob)->exception_handler();\n+  }\n@@ -792,1 +795,1 @@\n-  Thread* THREAD = current; \/\/ For exception processing.\n+  JavaThread* THREAD = current; \/\/ For exception macros.\n@@ -1054,1 +1057,1 @@\n-  JavaThread* current = THREAD->as_Java_thread();\n+  JavaThread* current = THREAD;\n@@ -1083,1 +1086,1 @@\n-  JavaThread* current = THREAD->as_Java_thread();\n+  JavaThread* current = THREAD;\n@@ -1237,1 +1240,1 @@\n-  JavaThread* current = THREAD->as_Java_thread();\n+  JavaThread* current = THREAD;\n@@ -1385,1 +1388,1 @@\n-  JavaThread* current = THREAD->as_Java_thread();\n+  JavaThread* current = THREAD;\n@@ -1490,1 +1493,1 @@\n-  assert(!caller_frame.is_interpreted_frame() && !caller_frame.is_entry_frame(), \"unexpected frame\");\n+  assert(!caller_frame.is_interpreted_frame() && !caller_frame.is_entry_frame()  && !caller_frame.is_optimized_entry_frame(), \"unexpected frame\");\n@@ -1523,1 +1526,2 @@\n-      caller_frame.is_entry_frame()) {\n+      caller_frame.is_entry_frame() ||\n+      caller_frame.is_optimized_entry_frame()) {\n@@ -1720,1 +1724,1 @@\n-  JavaThread* current = THREAD->as_Java_thread();\n+  JavaThread* current = THREAD;\n@@ -1830,1 +1834,1 @@\n-  JavaThread* current = THREAD->as_Java_thread();\n+  JavaThread* current = THREAD;\n@@ -2882,0 +2886,3 @@\n+\n+  \/\/ TODO: Reimplement JDK-8266015, dropped from jdk->lworld merge\n+\n@@ -3673,1 +3680,1 @@\n-    Thread* THREAD = current;\n+    JavaThread* THREAD = current;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -404,0 +404,4 @@\n+  static int vector_calling_convention(VMRegPair *regs,\n+                                       uint num_bits,\n+                                       uint total_args_passed);\n+\n@@ -547,0 +551,6 @@\n+  static void compute_move_order(const BasicType* in_sig_bt,\n+                                 int total_in_args, const VMRegPair* in_regs,\n+                                 int total_out_args, VMRegPair* out_regs,\n+                                 GrowableArray<int>& arg_order,\n+                                 VMRegPair tmp_vmreg);\n+\n@@ -654,0 +664,1 @@\n+  friend class AdapterHandlerLibrary;\n@@ -687,1 +698,0 @@\n-    _saved_code = NULL;\n@@ -722,1 +732,1 @@\n-  bool compare_code(unsigned char* code, int length);\n+  bool compare_code(unsigned char* buffer, int length);\n@@ -730,0 +740,1 @@\n+  friend class SharedRuntime;\n@@ -734,0 +745,6 @@\n+  static AdapterHandlerEntry* _no_arg_handler;\n+  static AdapterHandlerEntry* _int_arg_handler;\n+  static AdapterHandlerEntry* _obj_arg_handler;\n+  static AdapterHandlerEntry* _obj_int_arg_handler;\n+  static AdapterHandlerEntry* _obj_obj_arg_handler;\n+\n@@ -736,1 +753,5 @@\n-\n+  static AdapterHandlerEntry* create_adapter(AdapterBlob*& new_adapter,\n+                                             int total_args_passed,\n+                                             BasicType* sig_bt,\n+                                             bool allocate_code_blob);\n+  static AdapterHandlerEntry* get_simple_adapter(const methodHandle& method);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -392,1 +392,1 @@\n-  Thread* THREAD = Thread::current();\n+  JavaThread* THREAD = Thread::current()->as_Java_thread();\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -75,9 +76,0 @@\n-address StubRoutines::_d2i_wrapper                              = NULL;\n-address StubRoutines::_d2l_wrapper                              = NULL;\n-\n-jint    StubRoutines::_fpu_cntrl_wrd_std                        = 0;\n-jint    StubRoutines::_fpu_cntrl_wrd_24                         = 0;\n-jint    StubRoutines::_fpu_cntrl_wrd_trunc                      = 0;\n-jint    StubRoutines::_mxcsr_std                                = 0;\n-jint    StubRoutines::_fpu_subnormal_bias1[3]                   = { 0, 0, 0 };\n-jint    StubRoutines::_fpu_subnormal_bias2[3]                   = { 0, 0, 0 };\n@@ -188,0 +180,3 @@\n+address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{NULL}, {NULL}};\n+address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{NULL}, {NULL}};\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -153,9 +154,0 @@\n-  static address _d2i_wrapper;\n-  static address _d2l_wrapper;\n-\n-  static jint    _fpu_cntrl_wrd_std;\n-  static jint    _fpu_cntrl_wrd_24;\n-  static jint    _fpu_cntrl_wrd_trunc;\n-  static jint    _mxcsr_std;\n-  static jint    _fpu_subnormal_bias1[3];\n-  static jint    _fpu_subnormal_bias2[3];\n@@ -271,0 +263,4 @@\n+  \/\/ Vector Math Routines\n+  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n+  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n+\n@@ -328,11 +324,0 @@\n-  static address d2i_wrapper()                             { return _d2i_wrapper; }\n-  static address d2l_wrapper()                             { return _d2l_wrapper; }\n-  static jint    fpu_cntrl_wrd_std()                       { return _fpu_cntrl_wrd_std;   }\n-  static address addr_fpu_cntrl_wrd_std()                  { return (address)&_fpu_cntrl_wrd_std;   }\n-  static address addr_fpu_cntrl_wrd_24()                   { return (address)&_fpu_cntrl_wrd_24;   }\n-  static address addr_fpu_cntrl_wrd_trunc()                { return (address)&_fpu_cntrl_wrd_trunc; }\n-  static address addr_mxcsr_std()                          { return (address)&_mxcsr_std; }\n-  static address addr_fpu_subnormal_bias1()                { return (address)&_fpu_subnormal_bias1; }\n-  static address addr_fpu_subnormal_bias2()                { return (address)&_fpu_subnormal_bias2; }\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -622,1 +622,1 @@\n-  JavaThread* current = THREAD->as_Java_thread();\n+  JavaThread* current = THREAD;\n@@ -666,1 +666,1 @@\n-  JavaThread* current = THREAD->as_Java_thread();\n+  JavaThread* current = THREAD;\n@@ -707,1 +707,1 @@\n-  JavaThread* current = THREAD->as_Java_thread();\n+  JavaThread* current = THREAD;\n@@ -727,1 +727,1 @@\n-  JavaThread* current = THREAD->as_Java_thread();\n+  JavaThread* current = THREAD;\n@@ -1809,1 +1809,1 @@\n-                 mid->is_busy() != 0, mark.hash() != 0, mid->owner() != NULL,\n+                 mid->is_busy(), mark.hash() != 0, mid->owner() != NULL,\n@@ -1811,1 +1811,1 @@\n-      if (mid->is_busy() != 0) {\n+      if (mid->is_busy()) {\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/dynamicArchive.hpp\"\n@@ -47,0 +48,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -54,0 +56,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -269,2 +272,0 @@\n-  _suspend_flags = 0;\n-\n@@ -545,21 +546,0 @@\n-class InstallAsyncExceptionClosure : public HandshakeClosure {\n-  Handle _throwable; \/\/ The Throwable thrown at the target Thread\n-public:\n-  InstallAsyncExceptionClosure(Handle throwable) : HandshakeClosure(\"InstallAsyncException\"), _throwable(throwable) {}\n-\n-  void do_thread(Thread* thr) {\n-    JavaThread* target = thr->as_Java_thread();\n-    \/\/ Note that this now allows multiple ThreadDeath exceptions to be\n-    \/\/ thrown at a thread.\n-    \/\/ The target thread has run and has not exited yet.\n-    target->send_thread_stop(_throwable());\n-  }\n-};\n-\n-void Thread::send_async_exception(oop java_thread, oop java_throwable) {\n-  Handle throwable(Thread::current(), java_throwable);\n-  JavaThread* target = java_lang_Thread::thread(java_thread);\n-  InstallAsyncExceptionClosure vm_stop(throwable);\n-  Handshake::execute(&vm_stop, target);\n-}\n-\n@@ -1050,1 +1030,3 @@\n-  _special_runtime_exit_condition(_no_async_condition),\n+\n+  _suspend_flags(0),\n+  _async_exception_condition(_no_async_condition),\n@@ -1610,1 +1592,2 @@\n-\/\/ JVM support.\n+\/\/ Asynchronous exceptions support\n+\/\/\n@@ -1615,2 +1598,2 @@\n-void JavaThread::check_and_handle_async_exceptions(bool check_unsafe_error) {\n-  if (has_last_Java_frame() && has_async_condition()) {\n+void JavaThread::check_and_handle_async_exceptions() {\n+  if (has_last_Java_frame() && has_async_exception_condition()) {\n@@ -1640,1 +1623,1 @@\n-  JavaThread::AsyncRequests condition = clear_special_runtime_exit_condition();\n+  AsyncExceptionCondition condition = clear_async_exception_condition();\n@@ -1672,1 +1655,2 @@\n-      clear_has_async_exception();\n+      \/\/ Clear condition from _suspend_flags since we have finished processing it.\n+      clear_suspend_flag(_has_async_exception);\n@@ -1676,2 +1660,1 @@\n-  if (check_unsafe_error &&\n-      condition == _async_unsafe_access_error && !has_pending_exception()) {\n+  if (condition == _async_unsafe_access_error && !has_pending_exception()) {\n@@ -1680,1 +1663,0 @@\n-    condition = _no_async_condition;  \/\/ done\n@@ -1704,3 +1686,1 @@\n-  assert(condition == _no_async_condition || has_pending_exception() ||\n-         (!check_unsafe_error && condition == _async_unsafe_access_error),\n-         \"must have handled the async condition, if no exception\");\n+  assert(has_pending_exception(), \"must have handled the async condition if no exception\");\n@@ -1725,0 +1705,21 @@\n+class InstallAsyncExceptionClosure : public HandshakeClosure {\n+  Handle _throwable; \/\/ The Throwable thrown at the target Thread\n+public:\n+  InstallAsyncExceptionClosure(Handle throwable) : HandshakeClosure(\"InstallAsyncException\"), _throwable(throwable) {}\n+\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = thr->as_Java_thread();\n+    \/\/ Note that this now allows multiple ThreadDeath exceptions to be\n+    \/\/ thrown at a thread.\n+    \/\/ The target thread has run and has not exited yet.\n+    target->send_thread_stop(_throwable());\n+  }\n+};\n+\n+void JavaThread::send_async_exception(oop java_thread, oop java_throwable) {\n+  Handle throwable(Thread::current(), java_throwable);\n+  JavaThread* target = java_lang_Thread::thread(java_thread);\n+  InstallAsyncExceptionClosure vm_stop(throwable);\n+  Handshake::execute(&vm_stop, target);\n+}\n+\n@@ -1879,1 +1880,1 @@\n-  if (thread->has_async_exception()) {\n+  if (thread->has_async_exception_condition(false \/* check unsafe access error *\/)) {\n@@ -1882,1 +1883,1 @@\n-    thread->check_and_handle_async_exceptions(false);\n+    thread->check_and_handle_async_exceptions();\n@@ -2901,1 +2902,1 @@\n-  Thread* THREAD = Thread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n@@ -3298,0 +3299,8 @@\n+  \/\/ We could get here with a pending exception, if so clear it now or\n+  \/\/ it will cause MetaspaceShared::link_and_cleanup_shared_classes to\n+  \/\/ fail for dynamic dump.\n+  if (this->has_pending_exception()) {\n+    this->clear_pending_exception();\n+  }\n+\n+#if INCLUDE_CDS\n@@ -3302,6 +3311,1 @@\n-    MetaspaceShared::link_and_cleanup_shared_classes(this);\n-  }\n-\n-  \/\/ We could get here with a pending exception, if so clear it now.\n-  if (this->has_pending_exception()) {\n-    this->clear_pending_exception();\n+    DynamicArchive::prepare_for_dynamic_dumping_at_exit();\n@@ -3309,0 +3313,1 @@\n+#endif\n@@ -3416,0 +3421,3 @@\n+    \/\/ Assert that the thread is terminated so that acquiring the\n+    \/\/ Heap_lock doesn't cause the terminated thread to participate in\n+    \/\/ the safepoint protocol.\n@@ -3417,1 +3425,2 @@\n-    MutexLocker ml(Heap_lock, Mutex::_no_safepoint_check_flag);\n+    assert(thread->is_terminated(), \"must be terminated here\");\n+    MutexLocker ml(Heap_lock);\n@@ -3760,0 +3769,3 @@\n+  if (StringDedup::is_enabled()) {\n+    StringDedup::threads_do(&cl);\n+  }\n@@ -3761,0 +3773,1 @@\n+  cl.do_thread(AsyncLogWriter::instance());\n@@ -3814,0 +3827,1 @@\n+  print_on_error(AsyncLogWriter::instance(), st, current, buf, buflen, &found_current);\n@@ -3820,0 +3834,5 @@\n+  if (StringDedup::is_enabled()) {\n+    PrintOnErrorClosure print_closure(st, current, buf, buflen, &found_current);\n+    StringDedup::threads_do(&print_closure);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":64,"deletions":45,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+\/\/     - LogAsyncWriter\n@@ -218,14 +219,0 @@\n-  enum SuspendFlags {\n-    \/\/ NOTE: avoid using the sign-bit as cc generates different test code\n-    \/\/       when the sign-bit is used, and sometimes incorrectly - see CR 6398077\n-\n-    _has_async_exception    = 0x00000001U, \/\/ there is a pending async exception\n-\n-    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n-    _obj_deopt              = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n-  };\n-\n-  \/\/ various suspension related flags - atomically updated\n-  \/\/ overloaded for async exception checking in check_special_condition_for_native_trans.\n-  volatile uint32_t _suspend_flags;\n-\n@@ -372,1 +359,0 @@\n-  virtual WorkerThread* as_Worker_thread() const     { return NULL; }\n@@ -399,14 +385,0 @@\n-  bool has_async_exception() const { return (_suspend_flags & _has_async_exception) != 0; }\n-\n-  inline void set_suspend_flag(SuspendFlags f);\n-  inline void clear_suspend_flag(SuspendFlags f);\n-\n-  inline void set_has_async_exception();\n-  inline void clear_has_async_exception();\n-\n-  inline void set_trace_flag();\n-  inline void clear_trace_flag();\n-\n-  inline void set_obj_deopt_flag();\n-  inline void clear_obj_deopt_flag();\n-\n@@ -443,3 +415,0 @@\n-  \/\/ Installs a pending exception to be inserted later\n-  static void send_async_exception(oop thread_oop, oop java_throwable);\n-\n@@ -481,4 +450,0 @@\n-  bool is_trace_suspend()               { return (_suspend_flags & _trace_flag) != 0; }\n-\n-  bool is_obj_deopt_suspend()           { return (_suspend_flags & _obj_deopt) != 0; }\n-\n@@ -687,0 +652,4 @@\n+\n+  void assert_wx_state(WXMode expected) {\n+    assert(_wx_state == expected, \"wrong state\");\n+  }\n@@ -781,1 +750,1 @@\n-  ObjectMonitor* _current_pending_monitor;              \/\/ ObjectMonitor this thread is waiting to lock\n+  ObjectMonitor* volatile _current_pending_monitor;     \/\/ ObjectMonitor this thread is waiting to lock\n@@ -783,1 +752,1 @@\n-  ObjectMonitor* _current_waiting_monitor;              \/\/ ObjectMonitor on which this thread called Object.wait()\n+  ObjectMonitor* volatile _current_waiting_monitor;     \/\/ ObjectMonitor on which this thread called Object.wait()\n@@ -789,1 +758,4 @@\n-    return _current_pending_monitor;\n+    \/\/ Use Atomic::load() to prevent data race between concurrent modification and\n+    \/\/ concurrent readers, e.g. ThreadService::get_current_contended_monitor().\n+    \/\/ Especially, reloading pointer from thread after NULL check must be prevented.\n+    return Atomic::load(&_current_pending_monitor);\n@@ -792,1 +764,1 @@\n-    _current_pending_monitor = monitor;\n+    Atomic::store(&_current_pending_monitor, monitor);\n@@ -801,1 +773,2 @@\n-    return _current_waiting_monitor;\n+    \/\/ See the comment in current_pending_monitor() above.\n+    return Atomic::load(&_current_waiting_monitor);\n@@ -804,1 +777,1 @@\n-    _current_waiting_monitor = monitor;\n+    Atomic::store(&_current_waiting_monitor, monitor);\n@@ -812,2 +785,26 @@\n-  \/\/ Async. requests support\n-  enum AsyncRequests {\n+  enum SuspendFlags {\n+    \/\/ NOTE: avoid using the sign-bit as cc generates different test code\n+    \/\/       when the sign-bit is used, and sometimes incorrectly - see CR 6398077\n+    _has_async_exception    = 0x00000001U, \/\/ there is a pending async exception\n+    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n+    _obj_deopt              = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n+  };\n+\n+  \/\/ various suspension related flags - atomically updated\n+  \/\/ overloaded with async exceptions so that we do a single check when transitioning from native->Java\n+  volatile uint32_t _suspend_flags;\n+\n+  inline void set_suspend_flag(SuspendFlags f);\n+  inline void clear_suspend_flag(SuspendFlags f);\n+\n+ public:\n+  inline void set_trace_flag();\n+  inline void clear_trace_flag();\n+  inline void set_obj_deopt_flag();\n+  inline void clear_obj_deopt_flag();\n+  bool is_trace_suspend()      { return (_suspend_flags & _trace_flag) != 0; }\n+  bool is_obj_deopt_suspend()  { return (_suspend_flags & _obj_deopt) != 0; }\n+\n+  \/\/ Asynchronous exceptions support\n+ private:\n+  enum AsyncExceptionCondition {\n@@ -818,2 +815,26 @@\n-  AsyncRequests _special_runtime_exit_condition; \/\/ Enum indicating pending async. request\n-  oop           _pending_async_exception;\n+  AsyncExceptionCondition _async_exception_condition;\n+  oop                     _pending_async_exception;\n+\n+  void set_async_exception_condition(AsyncExceptionCondition aec) { _async_exception_condition = aec; }\n+  AsyncExceptionCondition clear_async_exception_condition() {\n+    AsyncExceptionCondition x = _async_exception_condition;\n+    _async_exception_condition = _no_async_condition;\n+    return x;\n+  }\n+\n+ public:\n+  bool has_async_exception_condition(bool check_unsafe_access_error = true) {\n+    return check_unsafe_access_error ? _async_exception_condition != _no_async_condition\n+                                     : _async_exception_condition == _async_exception;\n+  }\n+  inline void set_pending_async_exception(oop e);\n+  void set_pending_unsafe_access_error()  {\n+    \/\/ Don't overwrite an asynchronous exception sent by another thread\n+    if (_async_exception_condition == _no_async_condition) {\n+      set_async_exception_condition(_async_unsafe_access_error);\n+    }\n+  }\n+  void check_and_handle_async_exceptions();\n+  \/\/ Installs a pending exception to be inserted later\n+  static void send_async_exception(oop thread_oop, oop java_throwable);\n+  void send_thread_stop(oop throwable);\n@@ -1132,13 +1153,0 @@\n-  \/\/ Thread.stop support\n-  void send_thread_stop(oop throwable);\n-  AsyncRequests clear_special_runtime_exit_condition() {\n-    AsyncRequests x = _special_runtime_exit_condition;\n-    _special_runtime_exit_condition = _no_async_condition;\n-    return x;\n-  }\n-\n-  \/\/ Are any async conditions present?\n-  bool has_async_condition() { return (_special_runtime_exit_condition != _no_async_condition); }\n-\n-  void check_and_handle_async_exceptions(bool check_unsafe_error = true);\n-\n@@ -1151,1 +1159,1 @@\n-    return (_special_runtime_exit_condition != _no_async_condition) ||\n+    return (_async_exception_condition != _no_async_condition) ||\n@@ -1155,4 +1163,0 @@\n-  void set_pending_unsafe_access_error()          { _special_runtime_exit_condition = _async_unsafe_access_error; }\n-\n-  inline void set_pending_async_exception(oop e);\n-\n@@ -1433,2 +1437,0 @@\n-  inline CompilerThread* as_CompilerThread();\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":68,"deletions":66,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -571,2 +571,2 @@\n-  JavaThread* THREAD = JavaThread::current();\n-  RegisterMap map(THREAD, false);\n+  JavaThread* current = JavaThread::current();\n+  RegisterMap map(current, false);\n@@ -591,2 +591,2 @@\n-      methodHandle caller(THREAD, elem->method());\n-      methodHandle callee(THREAD, element(index - 1)->method());\n+      methodHandle caller(current, elem->method());\n+      methodHandle callee(current, element(index - 1)->method());\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -411,2 +412,1 @@\n-  nonstatic_field(ThreadLocalAllocBuffer,      _fast_refill_waste,                            unsigned)                              \\\n-  nonstatic_field(ThreadLocalAllocBuffer,      _slow_refill_waste,                            unsigned)                              \\\n+  nonstatic_field(ThreadLocalAllocBuffer,      _refill_waste,                                 unsigned)                              \\\n@@ -578,0 +578,1 @@\n+     static_field(StubRoutines,                _updateBytesAdler32,                           address)                               \\\n@@ -733,1 +734,0 @@\n-  volatile_nonstatic_field(Thread,             _suspend_flags,                                uint32_t)                              \\\n@@ -743,1 +743,1 @@\n-  nonstatic_field(JavaThread,                  _current_pending_monitor,                      ObjectMonitor*)                        \\\n+  volatile_nonstatic_field(JavaThread,         _current_pending_monitor,                      ObjectMonitor*)                        \\\n@@ -745,1 +745,3 @@\n-  nonstatic_field(JavaThread,                  _current_waiting_monitor,                      ObjectMonitor*)                        \\\n+  volatile_nonstatic_field(JavaThread,         _current_waiting_monitor,                      ObjectMonitor*)                        \\\n+  volatile_nonstatic_field(JavaThread,         _suspend_flags,                                uint32_t)                              \\\n+  nonstatic_field(JavaThread,                  _async_exception_condition,                    JavaThread::AsyncExceptionCondition)   \\\n@@ -750,1 +752,0 @@\n-  nonstatic_field(JavaThread,                  _special_runtime_exit_condition,               JavaThread::AsyncRequests)             \\\n@@ -915,1 +916,0 @@\n-  c2_nonstatic_field(Compile,                  _save_argument_registers,                      const bool)                            \\\n@@ -1340,0 +1340,1 @@\n+        declare_type(AsyncLogWriter, NonJavaThread)                       \\\n@@ -1529,0 +1530,1 @@\n+  declare_c2_type(CallLeafVectorNode, CallLeafNode)                       \\\n@@ -1988,1 +1990,1 @@\n-  declare_integer_type(JavaThread::AsyncRequests)                         \\\n+  declare_integer_type(JavaThread::AsyncExceptionCondition)               \\\n@@ -2148,1 +2150,1 @@\n-  declare_constant(Thread::_has_async_exception)                          \\\n+  declare_constant(JavaThread::_has_async_exception)                      \\\n@@ -2301,1 +2303,0 @@\n-  declare_constant(InstanceKlass::_misc_is_unsafe_anonymous)              \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -499,1 +499,8 @@\n-       \"BOOLEAN\", false, \"false\") {\n+       \"BOOLEAN\", false, \"false\"),\n+  _parallel_thread_num(\"-parallel\",\n+       \"Number of parallel threads to use for heap inspection. \"\n+       \"0 (the default) means let the VM determine the number of threads to use. \"\n+       \"1 means use one thread (disable parallelism). \"\n+       \"For any other value the VM will try to use the specified number of \"\n+       \"threads, but might use fewer.\",\n+       \"INT\", false, \"0\") {\n@@ -501,0 +508,1 @@\n+  _dcmdparser.add_dcmd_option(&_parallel_thread_num);\n@@ -504,0 +512,8 @@\n+  jlong num = _parallel_thread_num.value();\n+  if (num < 0) {\n+    output()->print_cr(\"Parallel thread number out of range (>=0): \" JLONG_FORMAT, num);\n+    return;\n+  }\n+  uint parallel_thread_num = num == 0\n+      ? MAX2<uint>(1, (uint)os::initial_active_processor_count() * 3 \/ 8)\n+      : num;\n@@ -505,1 +521,2 @@\n-                              !_all.value() \/* request full gc if false *\/);\n+                              !_all.value(), \/* request full gc if false *\/\n+                              parallel_thread_num);\n@@ -1017,1 +1034,1 @@\n-  JavaThread* thread = THREAD->as_Java_thread();\n+  JavaThread* thread = THREAD;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -342,0 +342,1 @@\n+  DCmdArgument<jlong> _parallel_thread_num;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-  void writer_loop()                    { _backend.thread_loop(false); }\n+  void writer_loop()                    { _backend.thread_loop(); }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,1 +128,0 @@\n-  bool is_strict      () const         { return (_flags & JVM_ACC_STRICT      ) != 0; }\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-class Thread;\n+class JavaThread;\n@@ -108,2 +108,2 @@\n-  static bool special_exception(Thread *thread, const char* file, int line, Handle exception);\n-  static bool special_exception(Thread* thread, const char* file, int line, Symbol* name, const char* message);\n+  static bool special_exception(JavaThread* thread, const char* file, int line, Handle exception);\n+  static bool special_exception(JavaThread* thread, const char* file, int line, Symbol* name, const char* message);\n@@ -126,2 +126,2 @@\n-  static void _throw_oop(Thread* thread, const char* file, int line, oop exception);\n-  static void _throw(Thread* thread, const char* file, int line, Handle exception, const char* msg = NULL);\n+  static void _throw_oop(JavaThread* thread, const char* file, int line, oop exception);\n+  static void _throw(JavaThread* thread, const char* file, int line, Handle exception, const char* msg = NULL);\n@@ -129,2 +129,2 @@\n-  static void _throw_msg(Thread* thread, const char* file, int line, Symbol* name, const char* message);\n-  static void _throw_msg(Thread* thread, const char* file, int line, Symbol* name, const char* message,\n+  static void _throw_msg(JavaThread* thread, const char* file, int line, Symbol* name, const char* message);\n+  static void _throw_msg(JavaThread* thread, const char* file, int line, Symbol* name, const char* message,\n@@ -133,2 +133,2 @@\n-  static void _throw_msg_cause(Thread* thread, const char* file, int line, Symbol* name, const char* message, Handle h_cause);\n-  static void _throw_msg_cause(Thread* thread, const char* file, int line, Symbol* name, const char* message, Handle h_cause,\n+  static void _throw_msg_cause(JavaThread* thread, const char* file, int line, Symbol* name, const char* message, Handle h_cause);\n+  static void _throw_msg_cause(JavaThread* thread, const char* file, int line, Symbol* name, const char* message, Handle h_cause,\n@@ -137,2 +137,2 @@\n-  static void _throw_cause(Thread* thread, const char* file, int line, Symbol* name, Handle h_cause);\n-  static void _throw_cause(Thread* thread, const char* file, int line, Symbol* name, Handle h_cause,\n+  static void _throw_cause(JavaThread* thread, const char* file, int line, Symbol* name, Handle h_cause);\n+  static void _throw_cause(JavaThread* thread, const char* file, int line, Symbol* name, Handle h_cause,\n@@ -141,1 +141,1 @@\n-  static void _throw_args(Thread* thread, const char* file, int line,\n+  static void _throw_args(JavaThread* thread, const char* file, int line,\n@@ -147,1 +147,1 @@\n-  static void fthrow(Thread* thread, const char* file, int line, Symbol* name,\n+  static void fthrow(JavaThread* thread, const char* file, int line, Symbol* name,\n@@ -151,1 +151,1 @@\n-  static Handle new_exception(Thread* thread, Symbol* name,\n+  static Handle new_exception(JavaThread* thread, Symbol* name,\n@@ -155,1 +155,1 @@\n-  static Handle new_exception(Thread* thread, Symbol* name,\n+  static Handle new_exception(JavaThread* thread, Symbol* name,\n@@ -160,1 +160,1 @@\n-  static Handle new_exception(Thread* thread, Symbol* name,\n+  static Handle new_exception(JavaThread* thread, Symbol* name,\n@@ -165,1 +165,1 @@\n-  static Handle new_exception(Thread* thread, Symbol* name,\n+  static Handle new_exception(JavaThread* thread, Symbol* name,\n@@ -170,1 +170,1 @@\n-  static Handle new_exception(Thread* thread, Symbol* name,\n+  static Handle new_exception(JavaThread* thread, Symbol* name,\n@@ -174,1 +174,1 @@\n-  static void throw_stack_overflow_exception(Thread* thread, const char* file, int line, const methodHandle& method);\n+  static void throw_stack_overflow_exception(JavaThread* thread, const char* file, int line, const methodHandle& method);\n@@ -176,1 +176,1 @@\n-  static void throw_unsafe_access_internal_error(Thread* thread, const char* file, int line, const char* message);\n+  static void throw_unsafe_access_internal_error(JavaThread* thread, const char* file, int line, const char* message);\n@@ -178,1 +178,1 @@\n-  static void wrap_dynamic_exception(bool is_indy, Thread* thread);\n+  static void wrap_dynamic_exception(bool is_indy, JavaThread* thread);\n@@ -204,1 +204,1 @@\n-#define TRAPS  Thread* THREAD\n+#define TRAPS  JavaThread* THREAD\n@@ -335,1 +335,1 @@\n-  Thread* _thread;\n+  JavaThread* _thread;\n@@ -340,1 +340,1 @@\n-  ExceptionMark(Thread* thread);\n+  ExceptionMark(JavaThread* thread);\n@@ -343,1 +343,1 @@\n-  Thread* thread() {\n+  JavaThread* thread() {\n@@ -356,1 +356,1 @@\n-#define EXCEPTION_MARK                           ExceptionMark __em; Thread* THREAD = __em.thread();\n+#define EXCEPTION_MARK                           ExceptionMark __em; JavaThread* THREAD = __em.thread();\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -154,0 +154,5 @@\n+\/\/ Convert pointer to intptr_t, for use in printing pointers.\n+inline intptr_t p2i(const volatile void* p) {\n+  return (intptr_t) p;\n+}\n+\n@@ -419,0 +424,1 @@\n+  assert(left >= right, \"avoid underflow - left: \" PTR_FORMAT \" right: \" PTR_FORMAT, p2i(left), p2i(right));\n@@ -1106,5 +1112,0 @@\n-\/\/ Convert pointer to intptr_t, for use in printing pointers.\n-inline intptr_t p2i(const void * p) {\n-  return (intptr_t) p;\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -216,0 +216,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -277,0 +278,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -624,0 +626,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -1055,0 +1058,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -1076,0 +1080,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -282,0 +283,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -305,0 +307,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -464,0 +467,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -497,0 +501,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -627,0 +632,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -1137,0 +1143,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -1500,7 +1507,2 @@\n-                case 'Z':\n-                case 'B':\n-                    f.setOffset(primDataSize++);\n-                    break;\n-\n-                case 'C':\n-                case 'S':\n+                case 'Z', 'B' -> f.setOffset(primDataSize++);\n+                case 'C', 'S' -> {\n@@ -1509,4 +1511,2 @@\n-                    break;\n-\n-                case 'I':\n-                case 'F':\n+                }\n+                case 'I', 'F' -> {\n@@ -1515,4 +1515,2 @@\n-                    break;\n-\n-                case 'J':\n-                case 'D':\n+                }\n+                case 'J', 'D' -> {\n@@ -1521,4 +1519,2 @@\n-                    break;\n-\n-                case '[':\n-                case 'L':\n+                }\n+                case '[', 'L' -> {\n@@ -1529,4 +1525,2 @@\n-                    break;\n-\n-                default:\n-                    throw new InternalError();\n+                }\n+                default -> throw new InternalError();\n@@ -1592,0 +1586,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -1680,2 +1675,2 @@\n-        return (cl1.getClassLoader() == cl2.getClassLoader() &&\n-                cl1.getPackageName().equals(cl2.getPackageName()));\n+        return cl1.getClassLoader() == cl2.getClassLoader() &&\n+                cl1.getPackageName() == cl2.getPackageName();\n@@ -2133,34 +2128,9 @@\n-                    case 'Z':\n-                        Bits.putBoolean(buf, off, unsafe.getBoolean(obj, key));\n-                        break;\n-\n-                    case 'B':\n-                        buf[off] = unsafe.getByte(obj, key);\n-                        break;\n-\n-                    case 'C':\n-                        Bits.putChar(buf, off, unsafe.getChar(obj, key));\n-                        break;\n-\n-                    case 'S':\n-                        Bits.putShort(buf, off, unsafe.getShort(obj, key));\n-                        break;\n-\n-                    case 'I':\n-                        Bits.putInt(buf, off, unsafe.getInt(obj, key));\n-                        break;\n-\n-                    case 'F':\n-                        Bits.putFloat(buf, off, unsafe.getFloat(obj, key));\n-                        break;\n-\n-                    case 'J':\n-                        Bits.putLong(buf, off, unsafe.getLong(obj, key));\n-                        break;\n-\n-                    case 'D':\n-                        Bits.putDouble(buf, off, unsafe.getDouble(obj, key));\n-                        break;\n-\n-                    default:\n-                        throw new InternalError();\n+                    case 'Z' -> Bits.putBoolean(buf, off, unsafe.getBoolean(obj, key));\n+                    case 'B' -> buf[off] = unsafe.getByte(obj, key);\n+                    case 'C' -> Bits.putChar(buf, off, unsafe.getChar(obj, key));\n+                    case 'S' -> Bits.putShort(buf, off, unsafe.getShort(obj, key));\n+                    case 'I' -> Bits.putInt(buf, off, unsafe.getInt(obj, key));\n+                    case 'F' -> Bits.putFloat(buf, off, unsafe.getFloat(obj, key));\n+                    case 'J' -> Bits.putLong(buf, off, unsafe.getLong(obj, key));\n+                    case 'D' -> Bits.putDouble(buf, off, unsafe.getDouble(obj, key));\n+                    default  -> throw new InternalError();\n@@ -2187,34 +2157,9 @@\n-                    case 'Z':\n-                        unsafe.putBoolean(obj, key, Bits.getBoolean(buf, off));\n-                        break;\n-\n-                    case 'B':\n-                        unsafe.putByte(obj, key, buf[off]);\n-                        break;\n-\n-                    case 'C':\n-                        unsafe.putChar(obj, key, Bits.getChar(buf, off));\n-                        break;\n-\n-                    case 'S':\n-                        unsafe.putShort(obj, key, Bits.getShort(buf, off));\n-                        break;\n-\n-                    case 'I':\n-                        unsafe.putInt(obj, key, Bits.getInt(buf, off));\n-                        break;\n-\n-                    case 'F':\n-                        unsafe.putFloat(obj, key, Bits.getFloat(buf, off));\n-                        break;\n-\n-                    case 'J':\n-                        unsafe.putLong(obj, key, Bits.getLong(buf, off));\n-                        break;\n-\n-                    case 'D':\n-                        unsafe.putDouble(obj, key, Bits.getDouble(buf, off));\n-                        break;\n-\n-                    default:\n-                        throw new InternalError();\n+                    case 'Z' -> unsafe.putBoolean(obj, key, Bits.getBoolean(buf, off));\n+                    case 'B' -> unsafe.putByte(obj, key, buf[off]);\n+                    case 'C' -> unsafe.putChar(obj, key, Bits.getChar(buf, off));\n+                    case 'S' -> unsafe.putShort(obj, key, Bits.getShort(buf, off));\n+                    case 'I' -> unsafe.putInt(obj, key, Bits.getInt(buf, off));\n+                    case 'F' -> unsafe.putFloat(obj, key, Bits.getFloat(buf, off));\n+                    case 'J' -> unsafe.putLong(obj, key, Bits.getLong(buf, off));\n+                    case 'D' -> unsafe.putDouble(obj, key, Bits.getDouble(buf, off));\n+                    default  -> throw new InternalError();\n@@ -2239,9 +2184,4 @@\n-                switch (typeCodes[i]) {\n-                    case 'L':\n-                    case '[':\n-                        vals[offsets[i]] = unsafe.getReference(obj, readKeys[i]);\n-                        break;\n-\n-                    default:\n-                        throw new InternalError();\n-                }\n+                vals[offsets[i]] = switch (typeCodes[i]) {\n+                    case 'L', '[' -> unsafe.getReference(obj, readKeys[i]);\n+                    default       -> throw new InternalError();\n+                };\n@@ -2281,2 +2221,1 @@\n-                    case 'L':\n-                    case '[':\n+                    case 'L', '[' -> {\n@@ -2298,4 +2237,2 @@\n-                        break;\n-\n-                    default:\n-                        throw new InternalError();\n+                    }\n+                    default -> throw new InternalError();\n@@ -2664,0 +2601,1 @@\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":46,"deletions":108,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -458,0 +458,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -527,0 +528,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -770,0 +772,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -1071,0 +1074,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -1534,0 +1538,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -1690,0 +1695,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -1737,0 +1743,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -1791,0 +1798,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -1899,1 +1907,6 @@\n-            return enclosingName + \".\" + getSimpleName();\n+            String simpleName = getSimpleName();\n+            return new StringBuilder(enclosingName.length() + simpleName.length() + 1)\n+                    .append(enclosingName)\n+                    .append('.')\n+                    .append(simpleName)\n+                    .toString();\n@@ -2012,0 +2025,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -2083,0 +2097,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2173,0 +2188,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2213,0 +2229,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2267,0 +2284,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2376,0 +2394,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2420,0 +2439,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2467,0 +2487,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2519,0 +2540,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2580,0 +2602,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2650,0 +2673,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2700,0 +2724,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2752,0 +2777,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2816,0 +2842,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -2894,0 +2921,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -3140,0 +3168,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -3185,1 +3214,1 @@\n-    private void checkMemberAccess(SecurityManager sm, int which,\n+    private void checkMemberAccess(@SuppressWarnings(\"removal\") SecurityManager sm, int which,\n@@ -3209,1 +3238,1 @@\n-    private void checkPackageAccess(SecurityManager sm, final ClassLoader ccl,\n+    private void checkPackageAccess(@SuppressWarnings(\"removal\") SecurityManager sm, final ClassLoader ccl,\n@@ -3215,1 +3244,1 @@\n-            if (pkg != null && !pkg.isEmpty()) {\n+            if (!pkg.isEmpty()) {\n@@ -3238,1 +3267,1 @@\n-    private static void checkPackageAccessForPermittedSubclasses(SecurityManager sm,\n+    private static void checkPackageAccessForPermittedSubclasses(@SuppressWarnings(\"removal\") SecurityManager sm,\n@@ -3249,1 +3278,1 @@\n-                if (pkg != null && !pkg.isEmpty()) {\n+                if (!pkg.isEmpty()) {\n@@ -3266,1 +3295,1 @@\n-            if (baseName != null && !baseName.isEmpty()) {\n+            if (!baseName.isEmpty()) {\n@@ -3934,0 +3963,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -3966,0 +3996,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -4381,0 +4412,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -4473,0 +4505,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -4545,1 +4578,1 @@\n-        String typeDesc = isPrimitiveClass() ? \"Q\" : \"L\";\n+        char typeDesc = isPrimitiveClass() ? 'Q' : 'L';\n@@ -4549,2 +4582,7 @@\n-            return typeDesc + name.substring(0, index).replace('.', '\/')\n-                       + \".\" + name.substring(index+1) + \";\";\n+            return new StringBuilder(name.length() + 2)\n+                    .append(typeDesc)\n+                    .append(name.substring(0, index).replace('.', '\/'))\n+                    .append('.')\n+                    .append(name, index + 1, name.length())\n+                    .append(';')\n+                    .toString();\n@@ -4552,1 +4590,6 @@\n-            return typeDesc + getName().replace('.', '\/') + \";\";\n+            String name = getName().replace('.', '\/');\n+            return new StringBuilder(name.length() + 2)\n+                    .append(typeDesc)\n+                    .append(name)\n+                    .append(';')\n+                    .toString();\n@@ -4644,1 +4687,1 @@\n-     * @since 15\n+     * @since 17\n@@ -4646,1 +4689,0 @@\n-    @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.SEALED_CLASSES, reflective=true)\n@@ -4662,0 +4704,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -4693,1 +4736,2 @@\n-     * @return {@code true} if and only if this {@code Class} object represents a sealed class or interface.\n+     * @return {@code true} if and only if this {@code Class} object represents\n+     * a sealed class or interface.\n@@ -4697,1 +4741,1 @@\n-     * @since 15\n+     * @since 17\n@@ -4699,2 +4743,0 @@\n-    @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.SEALED_CLASSES, reflective=true)\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":59,"deletions":17,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,6 +56,6 @@\n-    final MethodType invokedType;             \/\/ The type of the invoked method \"(CC)II\"\n-    final Class<?> samBase;                   \/\/ The type of the returned instance \"interface JJ\"\n-    final String samMethodName;               \/\/ Name of the SAM method \"foo\"\n-    final MethodType samMethodType;           \/\/ Type of the SAM method \"(Object)Object\"\n-    final MethodHandle implMethod;            \/\/ Raw method handle for the implementation method\n-    final MethodType implMethodType;          \/\/ Type of the implMethod MethodHandle \"(CC,int)String\"\n+    final MethodType factoryType;             \/\/ The type of the invoked method \"(CC)II\"\n+    final Class<?> interfaceClass;            \/\/ The type of the returned instance \"interface JJ\"\n+    final String interfaceMethodName;         \/\/ Name of the method to implement \"foo\"\n+    final MethodType interfaceMethodType;     \/\/ Type of the method to implement \"(Object)Object\"\n+    final MethodHandle implementation;        \/\/ Raw method handle for the implementation method\n+    final MethodType implMethodType;          \/\/ Type of the implementation MethodHandle \"(CC,int)String\"\n@@ -66,1 +66,1 @@\n-    final MethodType instantiatedMethodType;  \/\/ Instantiated erased functional interface method type \"(Integer)Object\"\n+    final MethodType dynamicMethodType;       \/\/ Dynamically checked method type \"(Integer)Object\"\n@@ -68,2 +68,2 @@\n-    final Class<?>[] markerInterfaces;        \/\/ Additional marker interfaces to be implemented\n-    final MethodType[] additionalBridges;     \/\/ Signatures of additional methods to bridge\n+    final Class<?>[] altInterfaces;           \/\/ Additional interfaces to be implemented\n+    final MethodType[] altMethods;            \/\/ Signatures of additional methods to bridge\n@@ -77,1 +77,1 @@\n-     * @param invokedType Stacked automatically by VM; the signature of the\n+     * @param factoryType Stacked automatically by VM; the signature of the\n@@ -84,15 +84,15 @@\n-     * @param samMethodName Name of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a String.\n-     * @param samMethodType Type of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a MethodType.\n-     * @param implMethod The implementation method which should be called\n-     *                   (with suitable adaptation of argument types, return\n-     *                   types, and adjustment for captured arguments) when\n-     *                   methods of the resulting functional interface instance\n-     *                   are invoked.\n-     * @param instantiatedMethodType The signature of the primary functional\n-     *                               interface method after type variables are\n-     *                               substituted with their instantiation from\n-     *                               the capture site\n+     * @param interfaceMethodName Name of the method in the functional interface to\n+     *                            which the lambda or method reference is being\n+     *                            converted, represented as a String.\n+     * @param interfaceMethodType Type of the method in the functional interface to\n+     *                            which the lambda or method reference is being\n+     *                            converted, represented as a MethodType.\n+     * @param implementation The implementation method which should be called\n+     *                       (with suitable adaptation of argument types, return\n+     *                       types, and adjustment for captured arguments) when\n+     *                       methods of the resulting functional interface instance\n+     *                       are invoked.\n+     * @param dynamicMethodType The signature of the primary functional\n+     *                          interface method after type variables are\n+     *                          substituted with their instantiation from\n+     *                          the capture site\n@@ -102,4 +102,4 @@\n-     * @param markerInterfaces Additional interfaces which the lambda object\n-     *                       should implement.\n-     * @param additionalBridges Method types for additional signatures to be\n-     *                          bridged to the implementation method\n+     * @param altInterfaces Additional interfaces which the lambda object\n+     *                      should implement.\n+     * @param altMethods Method types for additional signatures to be\n+     *                   implemented by invoking the implementation method\n@@ -107,1 +107,4 @@\n-     * invariants are violated\n+     *         invariants are violated\n+     * @throws SecurityException If a security manager is present, and it\n+     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n+     *         from {@code caller} to the package of {@code implementation}.\n@@ -110,8 +113,8 @@\n-                                       MethodType invokedType,\n-                                       String samMethodName,\n-                                       MethodType samMethodType,\n-                                       MethodHandle implMethod,\n-                                       MethodType instantiatedMethodType,\n-                                       boolean isSerializable,\n-                                       Class<?>[] markerInterfaces,\n-                                       MethodType[] additionalBridges)\n+                                        MethodType factoryType,\n+                                        String interfaceMethodName,\n+                                        MethodType interfaceMethodType,\n+                                        MethodHandle implementation,\n+                                        MethodType dynamicMethodType,\n+                                        boolean isSerializable,\n+                                        Class<?>[] altInterfaces,\n+                                        MethodType[] altMethods)\n@@ -119,1 +122,1 @@\n-        if ((caller.lookupModes() & MethodHandles.Lookup.PRIVATE) == 0) {\n+        if (!caller.hasFullPrivilegeAccess()) {\n@@ -126,1 +129,1 @@\n-        this.invokedType = invokedType;\n+        this.factoryType = factoryType;\n@@ -128,1 +131,1 @@\n-        this.samBase = invokedType.returnType();\n+        this.interfaceClass = factoryType.returnType();\n@@ -130,2 +133,2 @@\n-        this.samMethodName = samMethodName;\n-        this.samMethodType  = samMethodType;\n+        this.interfaceMethodName = interfaceMethodName;\n+        this.interfaceMethodType  = interfaceMethodType;\n@@ -133,3 +136,7 @@\n-        this.implMethod = implMethod;\n-        this.implMethodType = implMethod.type();\n-        this.implInfo = caller.revealDirect(implMethod);\n+        this.implementation = implementation;\n+        this.implMethodType = implementation.type();\n+        try {\n+            this.implInfo = caller.revealDirect(implementation); \/\/ may throw SecurityException\n+        } catch (IllegalArgumentException e) {\n+            throw new LambdaConversionException(implementation + \" is not direct or cannot be cracked\");\n+        }\n@@ -150,8 +157,4 @@\n-                \/\/ Classes compiled prior to dynamic nestmate support invokes a private instance\n-                \/\/ method with REF_invokeSpecial.\n-                \/\/\n-                \/\/ invokespecial should only be used to invoke private nestmate constructors.\n-                \/\/ The lambda proxy class will be defined as a nestmate of targetClass.\n-                \/\/ If the method to be invoked is an instance method of targetClass, then\n-                \/\/ convert to use invokevirtual or invokeinterface.\n-                if (targetClass == implClass && !implInfo.getName().equals(\"<init>\")) {\n+                \/\/ Classes compiled prior to dynamic nestmate support invoke a private instance\n+                \/\/ method with REF_invokeSpecial. Newer classes use REF_invokeVirtual or\n+                \/\/ REF_invokeInterface, and we can use that instruction in the lambda class.\n+                if (targetClass == implClass) {\n@@ -174,1 +177,1 @@\n-        this.instantiatedMethodType = instantiatedMethodType;\n+        this.dynamicMethodType = dynamicMethodType;\n@@ -176,2 +179,2 @@\n-        this.markerInterfaces = markerInterfaces;\n-        this.additionalBridges = additionalBridges;\n+        this.altInterfaces = altInterfaces;\n+        this.altMethods = altMethods;\n@@ -179,7 +182,7 @@\n-        if (samMethodName.isEmpty() ||\n-                samMethodName.indexOf('.') >= 0 ||\n-                samMethodName.indexOf(';') >= 0 ||\n-                samMethodName.indexOf('[') >= 0 ||\n-                samMethodName.indexOf('\/') >= 0 ||\n-                samMethodName.indexOf('<') >= 0 ||\n-                samMethodName.indexOf('>') >= 0) {\n+        if (interfaceMethodName.isEmpty() ||\n+                interfaceMethodName.indexOf('.') >= 0 ||\n+                interfaceMethodName.indexOf(';') >= 0 ||\n+                interfaceMethodName.indexOf('[') >= 0 ||\n+                interfaceMethodName.indexOf('\/') >= 0 ||\n+                interfaceMethodName.indexOf('<') >= 0 ||\n+                interfaceMethodName.indexOf('>') >= 0) {\n@@ -188,1 +191,1 @@\n-                    samMethodName));\n+                    interfaceMethodName));\n@@ -191,1 +194,1 @@\n-        if (!samBase.isInterface()) {\n+        if (!interfaceClass.isInterface()) {\n@@ -193,2 +196,2 @@\n-                    \"Functional interface %s is not an interface\",\n-                    samBase.getName()));\n+                    \"%s is not an interface\",\n+                    interfaceClass.getName()));\n@@ -197,1 +200,1 @@\n-        for (Class<?> c : markerInterfaces) {\n+        for (Class<?> c : altInterfaces) {\n@@ -200,1 +203,1 @@\n-                        \"Marker interface %s is not an interface\",\n+                        \"%s is not an interface\",\n@@ -223,3 +226,3 @@\n-        final int capturedArity = invokedType.parameterCount();\n-        final int samArity = samMethodType.parameterCount();\n-        final int instantiatedArity = instantiatedMethodType.parameterCount();\n+        final int capturedArity = factoryType.parameterCount();\n+        final int samArity = interfaceMethodType.parameterCount();\n+        final int dynamicArity = dynamicMethodType.parameterCount();\n@@ -232,1 +235,1 @@\n-        if (instantiatedArity != samArity) {\n+        if (dynamicArity != samArity) {\n@@ -234,1 +237,1 @@\n-                    String.format(\"Incorrect number of parameters for %s method %s; %d instantiated parameters, %d functional interface method parameters\",\n+                    String.format(\"Incorrect number of parameters for %s method %s; %d dynamic parameters, %d functional interface method parameters\",\n@@ -236,1 +239,1 @@\n-                                  instantiatedArity, samArity));\n+                                  dynamicArity, samArity));\n@@ -238,1 +241,1 @@\n-        for (MethodType bridgeMT : additionalBridges) {\n+        for (MethodType bridgeMT : altMethods) {\n@@ -242,1 +245,1 @@\n-                                      bridgeMT, samMethodType));\n+                                      bridgeMT, interfaceMethodType));\n@@ -257,1 +260,1 @@\n-                receiverClass = instantiatedMethodType.parameterType(0);\n+                receiverClass = dynamicMethodType.parameterType(0);\n@@ -262,1 +265,1 @@\n-                receiverClass = invokedType.parameterType(0);\n+                receiverClass = factoryType.parameterType(0);\n@@ -280,1 +283,1 @@\n-            Class<?> capturedParamType = invokedType.parameterType(i);\n+            Class<?> capturedParamType = factoryType.parameterType(i);\n@@ -290,2 +293,2 @@\n-            Class<?> instantiatedParamType = instantiatedMethodType.parameterType(i - capturedArity);\n-            if (!isAdaptableTo(instantiatedParamType, implParamType, true)) {\n+            Class<?> dynamicParamType = dynamicMethodType.parameterType(i - capturedArity);\n+            if (!isAdaptableTo(dynamicParamType, implParamType, true)) {\n@@ -294,1 +297,1 @@\n-                                      i, instantiatedParamType, implParamType));\n+                                      i, dynamicParamType, implParamType));\n@@ -299,1 +302,1 @@\n-        Class<?> expectedType = instantiatedMethodType.returnType();\n+        Class<?> expectedType = dynamicMethodType.returnType();\n@@ -308,2 +311,2 @@\n-        checkDescriptor(samMethodType);\n-        for (MethodType bridgeMT : additionalBridges) {\n+        checkDescriptor(interfaceMethodType);\n+        for (MethodType bridgeMT : altMethods) {\n@@ -314,1 +317,1 @@\n-    \/** Validate that the given descriptor's types are compatible with {@code instantiatedMethodType} **\/\n+    \/** Validate that the given descriptor's types are compatible with {@code dynamicMethodType} **\/\n@@ -316,2 +319,2 @@\n-        for (int i = 0; i < instantiatedMethodType.parameterCount(); i++) {\n-            Class<?> instantiatedParamType = instantiatedMethodType.parameterType(i);\n+        for (int i = 0; i < dynamicMethodType.parameterCount(); i++) {\n+            Class<?> dynamicParamType = dynamicMethodType.parameterType(i);\n@@ -319,3 +322,3 @@\n-            if (!descriptorParamType.isAssignableFrom(instantiatedParamType)) {\n-                String msg = String.format(\"Type mismatch for instantiated parameter %d: %s is not a subtype of %s\",\n-                                           i, instantiatedParamType, descriptorParamType);\n+            if (!descriptorParamType.isAssignableFrom(dynamicParamType)) {\n+                String msg = String.format(\"Type mismatch for dynamic parameter %d: %s is not a subtype of %s\",\n+                                           i, dynamicParamType, descriptorParamType);\n@@ -326,1 +329,1 @@\n-        Class<?> instantiatedReturnType = instantiatedMethodType.returnType();\n+        Class<?> dynamicReturnType = dynamicMethodType.returnType();\n@@ -328,1 +331,1 @@\n-        if (!isAdaptableToAsReturnStrict(instantiatedReturnType, descriptorReturnType)) {\n+        if (!isAdaptableToAsReturnStrict(dynamicReturnType, descriptorReturnType)) {\n@@ -330,1 +333,1 @@\n-                                       instantiatedReturnType, descriptorReturnType);\n+                                       dynamicReturnType, descriptorReturnType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":100,"deletions":97,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -65,13 +65,8 @@\n-            switch (xtype) {\n-            case L_TYPE:\n-                return bindSingle(type, form, x);  \/\/ Use known fast path.\n-            case I_TYPE:\n-                return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));\n-            case J_TYPE:\n-                return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);\n-            case F_TYPE:\n-                return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);\n-            case D_TYPE:\n-                return (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(D_TYPE_NUM).factory().invokeBasic(type, form, (double) x);\n-            default : throw newInternalError(\"unexpected xtype: \" + xtype);\n-            }\n+            return switch (xtype) {\n+                case L_TYPE -> bindSingle(type, form, x);  \/\/ Use known fast path.\n+                case I_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(I_TYPE_NUM).factory().invokeBasic(type, form, ValueConversions.widenSubword(x));\n+                case J_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(J_TYPE_NUM).factory().invokeBasic(type, form, (long) x);\n+                case F_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(F_TYPE_NUM).factory().invokeBasic(type, form, (float) x);\n+                case D_TYPE -> (BoundMethodHandle) SPECIALIZER.topSpecies().extendWith(D_TYPE_NUM).factory().invokeBasic(type, form, (double) x);\n+                default -> throw newInternalError(\"unexpected xtype: \" + xtype);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-            switch (refKind) {\n-                case REF_invokeSpecial: {\n+            return switch (refKind) {\n+                case REF_invokeSpecial -> {\n@@ -98,1 +98,1 @@\n-                    return new Special(mtype, lform, member, true, callerClass);\n+                    yield new Special(mtype, lform, member, true, callerClass);\n@@ -100,1 +100,1 @@\n-                case REF_invokeInterface: {\n+                case REF_invokeInterface -> {\n@@ -105,1 +105,1 @@\n-                    return new Interface(mtype, lform, member, true, refc);\n+                    yield new Interface(mtype, lform, member, true, refc);\n@@ -107,1 +107,1 @@\n-                default: {\n+                default -> {\n@@ -109,1 +109,1 @@\n-                    return new DirectMethodHandle(mtype, lform, member, true);\n+                    yield new DirectMethodHandle(mtype, lform, member, true);\n@@ -111,1 +111,1 @@\n-            }\n+            };\n@@ -198,1 +198,0 @@\n-        int which;\n@@ -204,8 +203,8 @@\n-        switch (m.getReferenceKind()) {\n-        case REF_invokeVirtual:    which = LF_INVVIRTUAL;    break;\n-        case REF_invokeStatic:     which = LF_INVSTATIC;     break;\n-        case REF_invokeSpecial:    which = LF_INVSPECIAL;    break;\n-        case REF_invokeInterface:  which = LF_INVINTERFACE;  break;\n-        case REF_newInvokeSpecial: which = LF_NEWINVSPECIAL; break;\n-        default:  throw new InternalError(m.toString());\n-        }\n+        int which = switch (m.getReferenceKind()) {\n+            case REF_invokeVirtual    -> LF_INVVIRTUAL;\n+            case REF_invokeStatic     -> LF_INVSTATIC;\n+            case REF_invokeSpecial    -> LF_INVSPECIAL;\n+            case REF_invokeInterface  -> LF_INVINTERFACE;\n+            case REF_newInvokeSpecial -> LF_NEWINVSPECIAL;\n+            default -> throw new InternalError(m.toString());\n+        };\n@@ -679,8 +678,8 @@\n-        byte formOp;\n-        switch (m.getReferenceKind()) {\n-        case REF_getField:      formOp = AF_GETFIELD;    break;\n-        case REF_putField:      formOp = AF_PUTFIELD;    break;\n-        case REF_getStatic:     formOp = AF_GETSTATIC;   break;\n-        case REF_putStatic:     formOp = AF_PUTSTATIC;   break;\n-        default:  throw new InternalError(m.toString());\n-        }\n+        boolean isVolatile = m.isVolatile();\n+        byte formOp = switch (m.getReferenceKind()) {\n+            case REF_getField  -> AF_GETFIELD;\n+            case REF_putField  -> AF_PUTFIELD;\n+            case REF_getStatic -> AF_GETSTATIC;\n+            case REF_putStatic -> AF_PUTSTATIC;\n+            default -> throw new InternalError(m.toString());\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,1 @@\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InfoFromMemberName.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    private static final int CLASSFILE_VERSION = V17;\n+    private static final int CLASSFILE_VERSION = V18;\n@@ -131,1 +131,1 @@\n-     * @param invokedType Stacked automatically by VM; the signature of the\n+     * @param factoryType Stacked automatically by VM; the signature of the\n@@ -138,14 +138,14 @@\n-     * @param samMethodName Name of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a String.\n-     * @param samMethodType Type of the method in the functional interface to\n-     *                      which the lambda or method reference is being\n-     *                      converted, represented as a MethodType.\n-     * @param implMethod The implementation method which should be called (with\n-     *                   suitable adaptation of argument types, return types,\n-     *                   and adjustment for captured arguments) when methods of\n-     *                   the resulting functional interface instance are invoked.\n-     * @param instantiatedMethodType The signature of the primary functional\n-     *                               interface method after type variables are\n-     *                               substituted with their instantiation from\n-     *                               the capture site\n+     * @param interfaceMethodName Name of the method in the functional interface to\n+     *                   which the lambda or method reference is being\n+     *                   converted, represented as a String.\n+     * @param interfaceMethodType Type of the method in the functional interface to\n+     *                            which the lambda or method reference is being\n+     *                            converted, represented as a MethodType.\n+     * @param implementation The implementation method which should be called (with\n+     *                       suitable adaptation of argument types, return types,\n+     *                       and adjustment for captured arguments) when methods of\n+     *                       the resulting functional interface instance are invoked.\n+     * @param dynamicMethodType The signature of the primary functional\n+     *                          interface method after type variables are\n+     *                          substituted with their instantiation from\n+     *                          the capture site\n@@ -155,4 +155,4 @@\n-     * @param markerInterfaces Additional interfaces which the lambda object\n-     *                       should implement.\n-     * @param additionalBridges Method types for additional signatures to be\n-     *                          bridged to the implementation method\n+     * @param altInterfaces Additional interfaces which the lambda object\n+     *                      should implement.\n+     * @param altMethods Method types for additional signatures to be\n+     *                   implemented by invoking the implementation method\n@@ -160,1 +160,4 @@\n-     * invariants are violated\n+     *         invariants are violated\n+     * @throws SecurityException If a security manager is present, and it\n+     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n+     *         from {@code caller} to the package of {@code implementation}.\n@@ -163,5 +166,5 @@\n-                                       MethodType invokedType,\n-                                       String samMethodName,\n-                                       MethodType samMethodType,\n-                                       MethodHandle implMethod,\n-                                       MethodType instantiatedMethodType,\n+                                       MethodType factoryType,\n+                                       String interfaceMethodName,\n+                                       MethodType interfaceMethodType,\n+                                       MethodHandle implementation,\n+                                       MethodType dynamicMethodType,\n@@ -169,2 +172,2 @@\n-                                       Class<?>[] markerInterfaces,\n-                                       MethodType[] additionalBridges)\n+                                       Class<?>[] altInterfaces,\n+                                       MethodType[] altMethods)\n@@ -172,3 +175,3 @@\n-        super(caller, invokedType, samMethodName, samMethodType,\n-              implMethod, instantiatedMethodType,\n-              isSerializable, markerInterfaces, additionalBridges);\n+        super(caller, factoryType, interfaceMethodName, interfaceMethodType,\n+              implementation, dynamicMethodType,\n+              isSerializable, altInterfaces, altMethods);\n@@ -178,1 +181,1 @@\n-        constructorType = invokedType.changeReturnType(Void.TYPE);\n+        constructorType = factoryType.changeReturnType(Void.TYPE);\n@@ -180,2 +183,9 @@\n-        useImplMethodHandle = !Modifier.isPublic(implInfo.getModifiers()) &&\n-                              !VerifyAccess.isSamePackage(implClass, implInfo.getDeclaringClass());\n+        \/\/ If the target class invokes a protected method inherited from a\n+        \/\/ superclass in a different package, or does 'invokespecial', the\n+        \/\/ lambda class has no access to the resolved method. Instead, we need\n+        \/\/ to pass the live implementation method handle to the proxy class\n+        \/\/ to invoke directly. (javac prefers to avoid this situation by\n+        \/\/ generating bridges in the target class)\n+        useImplMethodHandle = (Modifier.isProtected(implInfo.getModifiers()) &&\n+                               !VerifyAccess.isSamePackage(implClass, implInfo.getDeclaringClass())) ||\n+                               implKind == H_INVOKESPECIAL;\n@@ -183,1 +193,1 @@\n-        int parameterCount = invokedType.parameterCount();\n+        int parameterCount = factoryType.parameterCount();\n@@ -189,1 +199,1 @@\n-                argDescs[i] = BytecodeDescriptor.unparse(invokedType.parameterType(i));\n+                argDescs[i] = BytecodeDescriptor.unparse(factoryType.parameterType(i));\n@@ -219,1 +229,1 @@\n-        if (invokedType.parameterCount() == 0) {\n+        if (factoryType.parameterCount() == 0) {\n@@ -225,1 +235,1 @@\n-                            invokedType.returnType()));\n+                            factoryType.returnType()));\n@@ -231,0 +241,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -251,1 +262,1 @@\n-                    return new ConstantCallSite(MethodHandles.constant(samBase, inst));\n+                    return new ConstantCallSite(MethodHandles.constant(interfaceClass, inst));\n@@ -258,2 +269,2 @@\n-                MethodHandle mh = caller.findConstructor(innerClass, invokedType.changeReturnType(void.class));\n-                return new ConstantCallSite(mh.asType(invokedType));\n+                MethodHandle mh = caller.findConstructor(innerClass, constructorType);\n+                return new ConstantCallSite(mh.asType(factoryType));\n@@ -280,5 +291,5 @@\n-                                                 samMethodName,\n-                                                 invokedType,\n-                                                 samMethodType,\n-                                                 implMethod,\n-                                                 instantiatedMethodType,\n+                                                 interfaceMethodName,\n+                                                 factoryType,\n+                                                 interfaceMethodType,\n+                                                 implementation,\n+                                                 dynamicMethodType,\n@@ -286,2 +297,2 @@\n-                                                 markerInterfaces,\n-                                                 additionalBridges,\n+                                                 altInterfaces,\n+                                                 altMethods,\n@@ -294,5 +305,5 @@\n-                                                               samMethodName,\n-                                                               invokedType,\n-                                                               samMethodType,\n-                                                               implMethod,\n-                                                               instantiatedMethodType,\n+                                                               interfaceMethodName,\n+                                                               factoryType,\n+                                                               interfaceMethodType,\n+                                                               implementation,\n+                                                               dynamicMethodType,\n@@ -300,2 +311,2 @@\n-                                                               markerInterfaces,\n-                                                               additionalBridges);\n+                                                               altInterfaces,\n+                                                               altMethods);\n@@ -311,7 +322,0 @@\n-     * @implNote The class that is generated does not include signature\n-     * information for exceptions that may be present on the SAM method.\n-     * This is to reduce classfile size, and is harmless as checked exceptions\n-     * are erased anyway, no one will ever compile against this classfile,\n-     * and we make no guarantees about the reflective properties of lambda\n-     * objects.\n-     *\n@@ -322,0 +326,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -323,5 +328,5 @@\n-        String[] interfaces;\n-        String samIntf = samBase.getName().replace('.', '\/');\n-        boolean accidentallySerializable = !isSerializable && Serializable.class.isAssignableFrom(samBase);\n-        if (markerInterfaces.length == 0) {\n-            interfaces = new String[]{samIntf};\n+        String[] interfaceNames;\n+        String interfaceName = interfaceClass.getName().replace('.', '\/');\n+        boolean accidentallySerializable = !isSerializable && Serializable.class.isAssignableFrom(interfaceClass);\n+        if (altInterfaces.length == 0) {\n+            interfaceNames = new String[]{interfaceName};\n@@ -330,5 +335,5 @@\n-            Set<String> itfs = new LinkedHashSet<>(markerInterfaces.length + 1);\n-            itfs.add(samIntf);\n-            for (Class<?> markerInterface : markerInterfaces) {\n-                itfs.add(markerInterface.getName().replace('.', '\/'));\n-                accidentallySerializable |= !isSerializable && Serializable.class.isAssignableFrom(markerInterface);\n+            Set<String> itfs = new LinkedHashSet<>(altInterfaces.length + 1);\n+            itfs.add(interfaceName);\n+            for (Class<?> i : altInterfaces) {\n+                itfs.add(i.getName().replace('.', '\/'));\n+                accidentallySerializable |= !isSerializable && Serializable.class.isAssignableFrom(i);\n@@ -336,1 +341,1 @@\n-            interfaces = itfs.toArray(new String[itfs.size()]);\n+            interfaceNames = itfs.toArray(new String[itfs.size()]);\n@@ -341,1 +346,1 @@\n-                 JAVA_LANG_OBJECT, interfaces);\n+                 JAVA_LANG_OBJECT, interfaceNames);\n@@ -354,1 +359,1 @@\n-        if (invokedType.parameterCount() == 0 && disableEagerInitialization) {\n+        if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n@@ -359,8 +364,8 @@\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, samMethodName,\n-                                          samMethodType.toMethodDescriptorString(), null, null);\n-        new ForwardingMethodGenerator(mv).generate(samMethodType);\n-\n-        \/\/ Forward the bridges\n-        if (additionalBridges != null) {\n-            for (MethodType mt : additionalBridges) {\n-                mv = cw.visitMethod(ACC_PUBLIC|ACC_BRIDGE, samMethodName,\n+        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, interfaceMethodName,\n+                                          interfaceMethodType.toMethodDescriptorString(), null, null);\n+        new ForwardingMethodGenerator(mv).generate(interfaceMethodType);\n+\n+        \/\/ Forward the altMethods\n+        if (altMethods != null) {\n+            for (MethodType mt : altMethods) {\n+                mv = cw.visitMethod(ACC_PUBLIC, interfaceMethodName,\n@@ -399,8 +404,1 @@\n-                \/\/ If the target class invokes a method reference this::m which is\n-                \/\/ resolved to a protected method inherited from a superclass in a different\n-                \/\/ package, the target class does not have a bridge and this method reference\n-                \/\/ has been changed from public to protected after the target class was compiled.\n-                \/\/ This lambda proxy class has no access to the resolved method.\n-                \/\/ So this workaround by passing the live implMethod method handle\n-                \/\/ to the proxy class to invoke directly.\n-                lookup = caller.defineHiddenClassWithClassData(classBytes, implMethod, !disableEagerInitialization,\n+                lookup = caller.defineHiddenClassWithClassData(classBytes, implementation, !disableEagerInitialization,\n@@ -423,1 +421,1 @@\n-        String lambdaTypeDescriptor = invokedType.returnType().descriptorString();\n+        String lambdaTypeDescriptor = factoryType.returnType().descriptorString();\n@@ -436,1 +434,1 @@\n-        assert invokedType.parameterCount() == 0;\n+        assert factoryType.parameterCount() == 0;\n@@ -456,1 +454,1 @@\n-        int parameterCount = invokedType.parameterCount();\n+        int parameterCount = factoryType.parameterCount();\n@@ -459,1 +457,1 @@\n-            Class<?> argType = invokedType.parameterType(i);\n+            Class<?> argType = factoryType.parameterType(i);\n@@ -484,3 +482,3 @@\n-        mv.visitLdcInsn(invokedType.returnType().getName().replace('.', '\/'));\n-        mv.visitLdcInsn(samMethodName);\n-        mv.visitLdcInsn(samMethodType.toMethodDescriptorString());\n+        mv.visitLdcInsn(factoryType.returnType().getName().replace('.', '\/'));\n+        mv.visitLdcInsn(interfaceMethodName);\n+        mv.visitLdcInsn(interfaceMethodType.toMethodDescriptorString());\n@@ -491,1 +489,1 @@\n-        mv.visitLdcInsn(instantiatedMethodType.toMethodDescriptorString());\n+        mv.visitLdcInsn(dynamicMethodType.toMethodDescriptorString());\n@@ -593,1 +591,1 @@\n-            int captureArity = invokedType.parameterCount();\n+            int captureArity = factoryType.parameterCount();\n@@ -598,1 +596,1 @@\n-                convertType(argType, implMethodType.parameterType(captureArity + i), instantiatedMethodType.parameterType(i));\n+                convertType(argType, implMethodType.parameterType(captureArity + i), dynamicMethodType.parameterType(i));\n@@ -603,14 +601,8 @@\n-            switch (implKind) {\n-                case MethodHandleInfo.REF_invokeStatic:\n-                    return INVOKESTATIC;\n-                case MethodHandleInfo.REF_newInvokeSpecial:\n-                    return INVOKESPECIAL;\n-                 case MethodHandleInfo.REF_invokeVirtual:\n-                    return INVOKEVIRTUAL;\n-                case MethodHandleInfo.REF_invokeInterface:\n-                    return INVOKEINTERFACE;\n-                case MethodHandleInfo.REF_invokeSpecial:\n-                    return INVOKESPECIAL;\n-                default:\n-                    throw new InternalError(\"Unexpected invocation kind: \" + implKind);\n-            }\n+            return switch (implKind) {\n+                case MethodHandleInfo.REF_invokeStatic     -> INVOKESTATIC;\n+                case MethodHandleInfo.REF_newInvokeSpecial -> INVOKESPECIAL;\n+                case MethodHandleInfo.REF_invokeVirtual    -> INVOKEVIRTUAL;\n+                case MethodHandleInfo.REF_invokeInterface  -> INVOKEINTERFACE;\n+                case MethodHandleInfo.REF_invokeSpecial    -> INVOKESPECIAL;\n+                default -> throw new InternalError(\"Unexpected invocation kind: \" + implKind);\n+            };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":107,"deletions":115,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -205,0 +205,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -494,9 +495,8 @@\n-        switch (type) {\n-            case I_TYPE: return Opcodes.ILOAD;\n-            case J_TYPE: return Opcodes.LLOAD;\n-            case F_TYPE: return Opcodes.FLOAD;\n-            case D_TYPE: return Opcodes.DLOAD;\n-            case L_TYPE: return Opcodes.ALOAD;\n-            default:\n-                throw new InternalError(\"unknown type: \" + type);\n-        }\n+        return switch (type) {\n+            case I_TYPE -> Opcodes.ILOAD;\n+            case J_TYPE -> Opcodes.LLOAD;\n+            case F_TYPE -> Opcodes.FLOAD;\n+            case D_TYPE -> Opcodes.DLOAD;\n+            case L_TYPE -> Opcodes.ALOAD;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        };\n@@ -514,9 +514,8 @@\n-        switch (type) {\n-            case I_TYPE: return Opcodes.ISTORE;\n-            case J_TYPE: return Opcodes.LSTORE;\n-            case F_TYPE: return Opcodes.FSTORE;\n-            case D_TYPE: return Opcodes.DSTORE;\n-            case L_TYPE: return Opcodes.ASTORE;\n-            default:\n-                throw new InternalError(\"unknown type: \" + type);\n-        }\n+        return switch (type) {\n+            case I_TYPE -> Opcodes.ISTORE;\n+            case J_TYPE -> Opcodes.LSTORE;\n+            case F_TYPE -> Opcodes.FSTORE;\n+            case D_TYPE -> Opcodes.DSTORE;\n+            case L_TYPE -> Opcodes.ASTORE;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        };\n@@ -529,12 +528,12 @@\n-        switch (elementType) {\n-            case BOOLEAN: return Opcodes.T_BOOLEAN;\n-            case BYTE:    return Opcodes.T_BYTE;\n-            case CHAR:    return Opcodes.T_CHAR;\n-            case SHORT:   return Opcodes.T_SHORT;\n-            case INT:     return Opcodes.T_INT;\n-            case LONG:    return Opcodes.T_LONG;\n-            case FLOAT:   return Opcodes.T_FLOAT;\n-            case DOUBLE:  return Opcodes.T_DOUBLE;\n-            case OBJECT:  return 0; \/\/ in place of Opcodes.T_OBJECT\n-            default:      throw new InternalError();\n-        }\n+        return (byte) switch (elementType) {\n+            case BOOLEAN -> Opcodes.T_BOOLEAN;\n+            case BYTE    -> Opcodes.T_BYTE;\n+            case CHAR    -> Opcodes.T_CHAR;\n+            case SHORT   -> Opcodes.T_SHORT;\n+            case INT     -> Opcodes.T_INT;\n+            case LONG    -> Opcodes.T_LONG;\n+            case FLOAT   -> Opcodes.T_FLOAT;\n+            case DOUBLE  -> Opcodes.T_DOUBLE;\n+            case OBJECT  -> 0; \/\/ in place of Opcodes.T_OBJECT\n+            default -> throw new InternalError();\n+        };\n@@ -545,13 +544,12 @@\n-        int xas;\n-        switch (tcode) {\n-            case Opcodes.T_BOOLEAN: xas = Opcodes.BASTORE; break;\n-            case Opcodes.T_BYTE:    xas = Opcodes.BASTORE; break;\n-            case Opcodes.T_CHAR:    xas = Opcodes.CASTORE; break;\n-            case Opcodes.T_SHORT:   xas = Opcodes.SASTORE; break;\n-            case Opcodes.T_INT:     xas = Opcodes.IASTORE; break;\n-            case Opcodes.T_LONG:    xas = Opcodes.LASTORE; break;\n-            case Opcodes.T_FLOAT:   xas = Opcodes.FASTORE; break;\n-            case Opcodes.T_DOUBLE:  xas = Opcodes.DASTORE; break;\n-            case 0:                 xas = Opcodes.AASTORE; break;\n-            default:      throw new InternalError();\n-        }\n+        int xas = switch (tcode) {\n+            case Opcodes.T_BOOLEAN -> Opcodes.BASTORE;\n+            case Opcodes.T_BYTE    -> Opcodes.BASTORE;\n+            case Opcodes.T_CHAR    -> Opcodes.CASTORE;\n+            case Opcodes.T_SHORT   -> Opcodes.SASTORE;\n+            case Opcodes.T_INT     -> Opcodes.IASTORE;\n+            case Opcodes.T_LONG    -> Opcodes.LASTORE;\n+            case Opcodes.T_FLOAT   -> Opcodes.FASTORE;\n+            case Opcodes.T_DOUBLE  -> Opcodes.DASTORE;\n+            case 0                 -> Opcodes.AASTORE;\n+            default -> throw new InternalError();\n+        };\n@@ -867,0 +865,6 @@\n+                case TABLE_SWITCH:\n+                    assert lambdaForm.isTableSwitch(i);\n+                    int numCases = (Integer) name.function.intrinsicData();\n+                    onStack = emitTableSwitch(i, numCases);\n+                    i += 2; \/\/ jump to the end of the TS idiom\n+                    continue;\n@@ -1016,2 +1020,0 @@\n-        if (ReflectUtil.isVMAnonymousClass(cls))   \/\/ FIXME: Unsafe::defineAnonymousClass to be removed\n-            return false;\n@@ -1049,2 +1051,0 @@\n-        if (ReflectUtil.isVMAnonymousClass(cls))   \/\/ FIXME: Unsafe::defineAnonymousClass to be removed\n-            return false;\n@@ -1384,10 +1384,52 @@\n-        switch (type) {\n-            case I_TYPE:\n-            case F_TYPE:\n-            case L_TYPE:\n-                return Opcodes.POP;\n-            case J_TYPE:\n-            case D_TYPE:\n-                return Opcodes.POP2;\n-            default:\n-                throw new InternalError(\"unknown type: \" + type);\n+        return switch (type) {\n+            case I_TYPE, F_TYPE, L_TYPE -> Opcodes.POP;\n+            case J_TYPE, D_TYPE         -> Opcodes.POP2;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        };\n+    }\n+\n+    private Name emitTableSwitch(int pos, int numCases) {\n+        Name args    = lambdaForm.names[pos];\n+        Name invoker = lambdaForm.names[pos + 1];\n+        Name result  = lambdaForm.names[pos + 2];\n+\n+        Class<?> returnType = result.function.resolvedHandle().type().returnType();\n+        MethodType caseType = args.function.resolvedHandle().type()\n+            .dropParameterTypes(0, 1) \/\/ drop collector\n+            .changeReturnType(returnType);\n+        String caseDescriptor = caseType.basicType().toMethodDescriptorString();\n+\n+        emitPushArgument(invoker, 2); \/\/ push cases\n+        mv.visitFieldInsn(Opcodes.GETFIELD, \"java\/lang\/invoke\/MethodHandleImpl$CasesHolder\", \"cases\",\n+            \"[Ljava\/lang\/invoke\/MethodHandle;\");\n+        int casesLocal = extendLocalsMap(new Class<?>[] { MethodHandle[].class });\n+        emitStoreInsn(L_TYPE, casesLocal);\n+\n+        Label endLabel = new Label();\n+        Label defaultLabel = new Label();\n+        Label[] caseLabels = new Label[numCases];\n+        for (int i = 0; i < caseLabels.length; i++) {\n+            caseLabels[i] = new Label();\n+        }\n+\n+        emitPushArgument(invoker, 0); \/\/ push switch input\n+        mv.visitTableSwitchInsn(0, numCases - 1, defaultLabel, caseLabels);\n+\n+        mv.visitLabel(defaultLabel);\n+        emitPushArgument(invoker, 1); \/\/ push default handle\n+        emitPushArguments(args, 1); \/\/ again, skip collector\n+        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", caseDescriptor, false);\n+        mv.visitJumpInsn(Opcodes.GOTO, endLabel);\n+\n+        for (int i = 0; i < numCases; i++) {\n+            mv.visitLabel(caseLabels[i]);\n+            \/\/ Load the particular case:\n+            emitLoadInsn(L_TYPE, casesLocal);\n+            emitIconstInsn(i);\n+            mv.visitInsn(Opcodes.AALOAD);\n+\n+            \/\/ invoke it:\n+            emitPushArguments(args, 1); \/\/ again, skip collector\n+            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, \"invokeBasic\", caseDescriptor, false);\n+\n+            mv.visitJumpInsn(Opcodes.GOTO, endLabel);\n@@ -1395,0 +1437,4 @@\n+\n+        mv.visitLabel(endLabel);\n+\n+        return result;\n@@ -1612,8 +1658,8 @@\n-        switch (type) {\n-            case I_TYPE: mv.visitInsn(Opcodes.ICONST_0); break;\n-            case J_TYPE: mv.visitInsn(Opcodes.LCONST_0); break;\n-            case F_TYPE: mv.visitInsn(Opcodes.FCONST_0); break;\n-            case D_TYPE: mv.visitInsn(Opcodes.DCONST_0); break;\n-            case L_TYPE: mv.visitInsn(Opcodes.ACONST_NULL); break;\n-            default: throw new InternalError(\"unknown type: \" + type);\n-        }\n+        mv.visitInsn(switch (type) {\n+            case I_TYPE -> Opcodes.ICONST_0;\n+            case J_TYPE -> Opcodes.LCONST_0;\n+            case F_TYPE -> Opcodes.FCONST_0;\n+            case D_TYPE -> Opcodes.DCONST_0;\n+            case L_TYPE -> Opcodes.ACONST_NULL;\n+            default -> throw new InternalError(\"unknown type: \" + type);\n+        });\n@@ -1727,5 +1773,6 @@\n-                case LONG:\n-                    switch (to) {\n-                    case FLOAT:   mv.visitInsn(Opcodes.L2F);  break;\n-                    case DOUBLE:  mv.visitInsn(Opcodes.L2D);  break;\n-                    default:      error = true;               break;\n+                    case LONG -> {\n+                        switch (to) {\n+                            case FLOAT  -> mv.visitInsn(Opcodes.L2F);\n+                            case DOUBLE -> mv.visitInsn(Opcodes.L2D);\n+                            default -> error = true;\n+                        }\n@@ -1733,6 +1780,6 @@\n-                    break;\n-                case FLOAT:\n-                    switch (to) {\n-                    case LONG :   mv.visitInsn(Opcodes.F2L);  break;\n-                    case DOUBLE:  mv.visitInsn(Opcodes.F2D);  break;\n-                    default:      error = true;               break;\n+                    case FLOAT -> {\n+                        switch (to) {\n+                            case LONG   -> mv.visitInsn(Opcodes.F2L);\n+                            case DOUBLE -> mv.visitInsn(Opcodes.F2D);\n+                            default -> error = true;\n+                        }\n@@ -1740,6 +1787,6 @@\n-                    break;\n-                case DOUBLE:\n-                    switch (to) {\n-                    case LONG :   mv.visitInsn(Opcodes.D2L);  break;\n-                    case FLOAT:   mv.visitInsn(Opcodes.D2F);  break;\n-                    default:      error = true;               break;\n+                    case DOUBLE -> {\n+                        switch (to) {\n+                            case LONG  -> mv.visitInsn(Opcodes.D2L);\n+                            case FLOAT -> mv.visitInsn(Opcodes.D2F);\n+                            default -> error = true;\n+                        }\n@@ -1747,4 +1794,1 @@\n-                    break;\n-                default:\n-                    error = true;\n-                    break;\n+                    default -> error = true;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":130,"deletions":86,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -190,7 +190,7 @@\n-            switch (type) {\n-                case 'L': return L_TYPE;\n-                case 'I': return I_TYPE;\n-                case 'J': return J_TYPE;\n-                case 'F': return F_TYPE;\n-                case 'D': return D_TYPE;\n-                case 'V': return V_TYPE;\n+            return switch (type) {\n+                case 'L' -> L_TYPE;\n+                case 'I' -> I_TYPE;\n+                case 'J' -> J_TYPE;\n+                case 'F' -> F_TYPE;\n+                case 'D' -> D_TYPE;\n+                case 'V' -> V_TYPE;\n@@ -198,8 +198,3 @@\n-                case 'Z':\n-                case 'B':\n-                case 'S':\n-                case 'C':\n-                    return I_TYPE;\n-                default:\n-                    throw newInternalError(\"Unknown type char: '\"+type+\"'\");\n-            }\n+                case 'Z', 'B', 'S', 'C' -> I_TYPE;\n+                default -> throw newInternalError(\"Unknown type char: '\" + type + \"'\");\n+            };\n@@ -321,0 +316,1 @@\n+        TABLE_SWITCH(\"tableSwitch\"),\n@@ -714,0 +710,26 @@\n+    \/**\n+     * Check if i-th name is a start of the tableSwitch idiom.\n+     *\/\n+    boolean isTableSwitch(int pos) {\n+        \/\/ tableSwitch idiom:\n+        \/\/   t_{n}:L=MethodHandle.invokeBasic(...)     \/\/ args\n+        \/\/   t_{n+1}:L=MethodHandleImpl.tableSwitch(*, *, *, t_{n})\n+        \/\/   t_{n+2}:?=MethodHandle.invokeBasic(*, t_{n+1})\n+        if (pos + 2 >= names.length)  return false;\n+\n+        final int POS_COLLECT_ARGS = pos;\n+        final int POS_TABLE_SWITCH = pos + 1;\n+        final int POS_UNBOX_RESULT = pos + 2;\n+\n+        Name collectArgs = names[POS_COLLECT_ARGS];\n+        Name tableSwitch = names[POS_TABLE_SWITCH];\n+        Name unboxResult = names[POS_UNBOX_RESULT];\n+        return tableSwitch.refersTo(MethodHandleImpl.class, \"tableSwitch\") &&\n+                collectArgs.isInvokeBasic() &&\n+                unboxResult.isInvokeBasic() &&\n+                tableSwitch.lastUseIndex(collectArgs) == 3 &&     \/\/ t_{n+1}:L=MethodHandleImpl.<invoker>(*, *, *, t_{n});\n+                lastUseIndex(collectArgs) == POS_TABLE_SWITCH &&  \/\/ t_{n} is local: used only in t_{n+1}\n+                unboxResult.lastUseIndex(tableSwitch) == 1 &&     \/\/ t_{n+2}:?=MethodHandle.invokeBasic(*, t_{n+1})\n+                lastUseIndex(tableSwitch) == POS_UNBOX_RESULT;    \/\/ t_{n+1} is local: used only in t_{n+2}\n+    }\n+\n@@ -1074,1 +1096,0 @@\n-        private final MethodHandleImpl.Intrinsic intrinsicName;\n@@ -1077,4 +1098,1 @@\n-            this(resolvedHandle.internalMemberName(), resolvedHandle, MethodHandleImpl.Intrinsic.NONE);\n-        }\n-        NamedFunction(MethodHandle resolvedHandle, MethodHandleImpl.Intrinsic intrinsic) {\n-            this(resolvedHandle.internalMemberName(), resolvedHandle, intrinsic);\n+            this(resolvedHandle.internalMemberName(), resolvedHandle);\n@@ -1083,3 +1101,0 @@\n-            this(member, resolvedHandle, MethodHandleImpl.Intrinsic.NONE);\n-        }\n-        NamedFunction(MemberName member, MethodHandle resolvedHandle, MethodHandleImpl.Intrinsic intrinsic) {\n@@ -1088,4 +1103,0 @@\n-            this.intrinsicName = intrinsic;\n-            assert(resolvedHandle == null ||\n-                   resolvedHandle.intrinsicName() == MethodHandleImpl.Intrinsic.NONE ||\n-                   resolvedHandle.intrinsicName() == intrinsic) : resolvedHandle.intrinsicName() + \" != \" + intrinsic;\n@@ -1104,1 +1115,0 @@\n-            this.intrinsicName = MethodHandleImpl.Intrinsic.NONE;\n@@ -1257,1 +1267,9 @@\n-            return intrinsicName;\n+            return resolvedHandle != null\n+                ? resolvedHandle.intrinsicName()\n+                : MethodHandleImpl.Intrinsic.NONE;\n+        }\n+\n+        public Object intrinsicData() {\n+            return resolvedHandle != null\n+                ? resolvedHandle.intrinsicData()\n+                : null;\n@@ -1739,2 +1757,2 @@\n-                idFun = new NamedFunction(idMem, SimpleMethodHandle.make(idMem.getInvocationType(), idForm),\n-                            MethodHandleImpl.Intrinsic.IDENTITY);\n+                idFun = new NamedFunction(idMem, MethodHandleImpl.makeIntrinsic(SimpleMethodHandle.make(idMem.getInvocationType(), idForm),\n+                            MethodHandleImpl.Intrinsic.IDENTITY));\n@@ -1746,2 +1764,2 @@\n-                zeFun = new NamedFunction(zeMem, SimpleMethodHandle.make(zeMem.getInvocationType(), zeForm),\n-                        MethodHandleImpl.Intrinsic.ZERO);\n+                zeFun = new NamedFunction(zeMem, MethodHandleImpl.makeIntrinsic(SimpleMethodHandle.make(zeMem.getInvocationType(), zeForm),\n+                        MethodHandleImpl.Intrinsic.ZERO));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":51,"deletions":33,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import static java.lang.invoke.MethodHandleImpl.makeIntrinsic;\n@@ -623,1 +624,1 @@\n-            Name loadArgument = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), spreadParam, i);\n+            Name loadArgument = new Name(new NamedFunction(makeIntrinsic(aload, Intrinsic.ARRAY_LOAD)), spreadParam, i);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -316,12 +316,15 @@\n-        if (refKind == originalRefKind)  return true;\n-        switch (originalRefKind) {\n-        case REF_invokeInterface:\n-            \/\/ Looking up an interface method, can get (e.g.) Object.hashCode\n-            assert(refKind == REF_invokeVirtual ||\n-                   refKind == REF_invokeSpecial) : this;\n-            return true;\n-        case REF_invokeVirtual:\n-        case REF_newInvokeSpecial:\n-            \/\/ Looked up a virtual, can get (e.g.) final String.hashCode.\n-            assert(refKind == REF_invokeSpecial) : this;\n-            return true;\n+        if (refKind == originalRefKind) return true;\n+        if (getClass().desiredAssertionStatus()) {\n+            switch (originalRefKind) {\n+                case REF_invokeInterface -> {\n+                    \/\/ Looking up an interface method, can get (e.g.) Object.hashCode\n+                    assert (refKind == REF_invokeVirtual || refKind == REF_invokeSpecial) : this;\n+                }\n+                case REF_invokeVirtual, REF_newInvokeSpecial -> {\n+                    \/\/ Looked up a virtual, can get (e.g.) final String.hashCode.\n+                    assert (refKind == REF_invokeSpecial) : this;\n+                }\n+                default -> {\n+                    assert (false) : this + \" != \" + MethodHandleNatives.refKindName((byte) originalRefKind);\n+                }\n+            }\n@@ -329,1 +332,0 @@\n-        assert(false) : this+\" != \"+MethodHandleNatives.refKindName((byte)originalRefKind);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -110,6 +112,6 @@\n-            switch (a) {\n-                case GET: return \"getElement\";\n-                case SET: return \"setElement\";\n-                case LENGTH: return \"length\";\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> \"getElement\";\n+                case SET    -> \"setElement\";\n+                case LENGTH -> \"length\";\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -119,6 +121,6 @@\n-            switch (a) {\n-                case GET: return ArrayAccessor.OBJECT_ARRAY_GETTER;\n-                case SET: return ArrayAccessor.OBJECT_ARRAY_SETTER;\n-                case LENGTH: return ArrayAccessor.OBJECT_ARRAY_LENGTH;\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> ArrayAccessor.OBJECT_ARRAY_GETTER;\n+                case SET    -> ArrayAccessor.OBJECT_ARRAY_SETTER;\n+                case LENGTH -> ArrayAccessor.OBJECT_ARRAY_LENGTH;\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -128,6 +130,6 @@\n-            switch (a) {\n-                case GET: return ArrayAccessor.GETTER_INDEX;\n-                case SET: return ArrayAccessor.SETTER_INDEX;\n-                case LENGTH: return ArrayAccessor.LENGTH_INDEX;\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> ArrayAccessor.GETTER_INDEX;\n+                case SET    -> ArrayAccessor.SETTER_INDEX;\n+                case LENGTH -> ArrayAccessor.LENGTH_INDEX;\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -137,6 +139,6 @@\n-            switch (a) {\n-                case GET: return Intrinsic.ARRAY_LOAD;\n-                case SET: return Intrinsic.ARRAY_STORE;\n-                case LENGTH: return Intrinsic.ARRAY_LENGTH;\n-            }\n-            throw unmatchedArrayAccess(a);\n+            return switch (a) {\n+                case GET    -> Intrinsic.ARRAY_LOAD;\n+                case SET    -> Intrinsic.ARRAY_STORE;\n+                case LENGTH -> Intrinsic.ARRAY_LENGTH;\n+                default -> throw unmatchedArrayAccess(a);\n+            };\n@@ -214,6 +216,6 @@\n-            switch (access) {\n-                case GET:    return MethodType.methodType(elemClass,  arrayArgClass, int.class);\n-                case SET:    return MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);\n-                case LENGTH: return MethodType.methodType(int.class,  arrayArgClass);\n-            }\n-            throw unmatchedArrayAccess(access);\n+            return switch (access) {\n+                case GET    -> MethodType.methodType(elemClass, arrayArgClass, int.class);\n+                case SET    -> MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);\n+                case LENGTH -> MethodType.methodType(int.class, arrayArgClass);\n+                default -> throw unmatchedArrayAccess(access);\n+            };\n@@ -223,6 +225,6 @@\n-            switch (access) {\n-                case GET:    return MethodType.methodType(elemClass,  arrayClass, int.class);\n-                case SET:    return MethodType.methodType(void.class, arrayClass, int.class, elemClass);\n-                case LENGTH: return MethodType.methodType(int.class,  arrayClass);\n-            }\n-            throw unmatchedArrayAccess(access);\n+            return switch (access) {\n+                case GET    -> MethodType.methodType(elemClass, arrayClass, int.class);\n+                case SET    -> MethodType.methodType(void.class, arrayClass, int.class, elemClass);\n+                case LENGTH -> MethodType.methodType(int.class, arrayClass);\n+                default -> throw unmatchedArrayAccess(access);\n+            };\n@@ -826,1 +828,3 @@\n-        names[SELECT_ALT] = new Name(new NamedFunction(getConstantHandle(MH_selectAlternative), Intrinsic.SELECT_ALTERNATIVE), names[TEST], names[GET_TARGET], names[GET_FALLBACK]);\n+        names[SELECT_ALT] = new Name(new NamedFunction(\n+                makeIntrinsic(getConstantHandle(MH_selectAlternative), Intrinsic.SELECT_ALTERNATIVE)),\n+                names[TEST], names[GET_TARGET], names[GET_FALLBACK]);\n@@ -897,1 +901,1 @@\n-        names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.GUARD_WITH_CATCH), args);\n+        names[BOXED_ARGS] = new Name(new NamedFunction(makeIntrinsic(invokeBasic, Intrinsic.GUARD_WITH_CATCH)), args);\n@@ -979,6 +983,5 @@\n-        int idx;\n-        switch (method.getName()) {\n-        case \"invoke\":       idx = 0; break;\n-        case \"invokeExact\":  idx = 1; break;\n-        default:             throw new InternalError(method.getName());\n-        }\n+        int idx = switch (method.getName()) {\n+            case \"invoke\"      -> 0;\n+            case \"invokeExact\" -> 1;\n+            default -> throw new InternalError(method.getName());\n+        };\n@@ -1229,0 +1232,1 @@\n+        TABLE_SWITCH,\n@@ -1243,0 +1247,1 @@\n+        private final Object intrinsicData;\n@@ -1245,0 +1250,4 @@\n+           this(target, intrinsicName, null);\n+        }\n+\n+        IntrinsicMethodHandle(MethodHandle target, Intrinsic intrinsicName, Object intrinsicData) {\n@@ -1248,0 +1257,1 @@\n+            this.intrinsicData = intrinsicData;\n@@ -1260,0 +1270,5 @@\n+        @Override\n+        Object intrinsicData() {\n+            return intrinsicData;\n+        }\n+\n@@ -1285,0 +1300,4 @@\n+        return makeIntrinsic(target, intrinsicName, null);\n+    }\n+\n+    static MethodHandle makeIntrinsic(MethodHandle target, Intrinsic intrinsicName, Object intrinsicData) {\n@@ -1287,1 +1306,1 @@\n-        return new IntrinsicMethodHandle(target, intrinsicName);\n+        return new IntrinsicMethodHandle(target, intrinsicName, intrinsicData);\n@@ -1363,1 +1382,2 @@\n-            NF_LIMIT = 6;\n+            NF_tableSwitch = 6,\n+            NF_LIMIT = 7;\n@@ -1377,23 +1397,18 @@\n-            switch (func) {\n-                case NF_checkSpreadArgument:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"checkSpreadArgument\", Object.class, int.class));\n-                case NF_guardWithCatch:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"guardWithCatch\", MethodHandle.class, Class.class,\n-                                    MethodHandle.class, Object[].class));\n-                case NF_tryFinally:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"tryFinally\", MethodHandle.class, MethodHandle.class, Object[].class));\n-                case NF_loop:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"loop\", BasicType[].class, LoopClauses.class, Object[].class));\n-                case NF_throwException:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"throwException\", Throwable.class));\n-                case NF_profileBoolean:\n-                    return new NamedFunction(MethodHandleImpl.class\n-                            .getDeclaredMethod(\"profileBoolean\", boolean.class, int[].class));\n-                default:\n-                    throw new InternalError(\"Undefined function: \" + func);\n-            }\n+            return switch (func) {\n+                case NF_checkSpreadArgument -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"checkSpreadArgument\", Object.class, int.class));\n+                case NF_guardWithCatch      -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"guardWithCatch\", MethodHandle.class, Class.class,\n+                                                   MethodHandle.class, Object[].class));\n+                case NF_tryFinally          -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"tryFinally\", MethodHandle.class, MethodHandle.class, Object[].class));\n+                case NF_loop                -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"loop\", BasicType[].class, LoopClauses.class, Object[].class));\n+                case NF_throwException      -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"throwException\", Throwable.class));\n+                case NF_profileBoolean      -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"profileBoolean\", boolean.class, int[].class));\n+                case NF_tableSwitch         -> new NamedFunction(MethodHandleImpl.class\n+                                                .getDeclaredMethod(\"tableSwitch\", int.class, MethodHandle.class, CasesHolder.class, Object[].class));\n+                default -> throw new InternalError(\"Undefined function: \" + func);\n+            };\n@@ -1446,0 +1461,5 @@\n+            @Override\n+            public void ensureCustomized(MethodHandle mh) {\n+                mh.customize();\n+            }\n+\n@@ -1609,1 +1629,1 @@\n-            names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.LOOP), args);\n+            names[BOXED_ARGS] = new Name(new NamedFunction(makeIntrinsic(invokeBasic, Intrinsic.LOOP)), args);\n@@ -1846,1 +1866,1 @@\n-        names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.TRY_FINALLY), args);\n+        names[BOXED_ARGS] = new Name(new NamedFunction(makeIntrinsic(invokeBasic, Intrinsic.TRY_FINALLY)), args);\n@@ -1948,1 +1968,1 @@\n-            names[storeNameCursor] = new Name(new NamedFunction(storeFunc, Intrinsic.ARRAY_STORE),\n+            names[storeNameCursor] = new Name(new NamedFunction(makeIntrinsic(storeFunc, Intrinsic.ARRAY_STORE)),\n@@ -1959,0 +1979,135 @@\n+    \/\/ use a wrapper because we need this array to be @Stable\n+    static class CasesHolder {\n+        @Stable\n+        final MethodHandle[] cases;\n+\n+        public CasesHolder(MethodHandle[] cases) {\n+            this.cases = cases;\n+        }\n+    }\n+\n+    static MethodHandle makeTableSwitch(MethodType type, MethodHandle defaultCase, MethodHandle[] caseActions) {\n+        MethodType varargsType = type.changeReturnType(Object[].class);\n+        MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);\n+\n+        MethodHandle unboxResult = unboxResultHandle(type.returnType());\n+\n+        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();\n+        LambdaForm form = makeTableSwitchForm(type.basicType(), data, caseActions.length);\n+        BoundMethodHandle mh;\n+        CasesHolder caseHolder =  new CasesHolder(caseActions);\n+        try {\n+            mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) defaultCase, (Object) collectArgs,\n+                                                                (Object) unboxResult, (Object) caseHolder);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n+        assert(mh.type() == type);\n+        return mh;\n+    }\n+\n+    private static class TableSwitchCacheKey {\n+        private static final Map<TableSwitchCacheKey, LambdaForm> CACHE = new ConcurrentHashMap<>();\n+\n+        private final MethodType basicType;\n+        private final int numberOfCases;\n+\n+        public TableSwitchCacheKey(MethodType basicType, int numberOfCases) {\n+            this.basicType = basicType;\n+            this.numberOfCases = numberOfCases;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            TableSwitchCacheKey that = (TableSwitchCacheKey) o;\n+            return numberOfCases == that.numberOfCases && Objects.equals(basicType, that.basicType);\n+        }\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(basicType, numberOfCases);\n+        }\n+    }\n+\n+    private static LambdaForm makeTableSwitchForm(MethodType basicType, BoundMethodHandle.SpeciesData data,\n+                                                  int numCases) {\n+        MethodType lambdaType = basicType.invokerType();\n+\n+        \/\/ We need to cache based on the basic type X number of cases,\n+        \/\/ since the number of cases is used when generating bytecode.\n+        \/\/ This also means that we can't use the cache in MethodTypeForm,\n+        \/\/ which only uses the basic type as a key.\n+        TableSwitchCacheKey key = new TableSwitchCacheKey(basicType, numCases);\n+        LambdaForm lform = TableSwitchCacheKey.CACHE.get(key);\n+        if (lform != null) {\n+            return lform;\n+        }\n+\n+        final int THIS_MH       = 0;\n+        final int ARG_BASE      = 1;  \/\/ start of incoming arguments\n+        final int ARG_LIMIT     = ARG_BASE + basicType.parameterCount();\n+        final int ARG_SWITCH_ON = ARG_BASE;\n+        assert ARG_SWITCH_ON < ARG_LIMIT;\n+\n+        int nameCursor = ARG_LIMIT;\n+        final int GET_COLLECT_ARGS  = nameCursor++;\n+        final int GET_DEFAULT_CASE  = nameCursor++;\n+        final int GET_UNBOX_RESULT  = nameCursor++;\n+        final int GET_CASES         = nameCursor++;\n+        final int BOXED_ARGS        = nameCursor++;\n+        final int TABLE_SWITCH      = nameCursor++;\n+        final int UNBOXED_RESULT    = nameCursor++;\n+\n+        int fieldCursor = 0;\n+        final int FIELD_DEFAULT_CASE  = fieldCursor++;\n+        final int FIELD_COLLECT_ARGS  = fieldCursor++;\n+        final int FIELD_UNBOX_RESULT  = fieldCursor++;\n+        final int FIELD_CASES         = fieldCursor++;\n+\n+        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);\n+\n+        names[THIS_MH] = names[THIS_MH].withConstraint(data);\n+        names[GET_DEFAULT_CASE] = new Name(data.getterFunction(FIELD_DEFAULT_CASE), names[THIS_MH]);\n+        names[GET_COLLECT_ARGS]  = new Name(data.getterFunction(FIELD_COLLECT_ARGS), names[THIS_MH]);\n+        names[GET_UNBOX_RESULT]  = new Name(data.getterFunction(FIELD_UNBOX_RESULT), names[THIS_MH]);\n+        names[GET_CASES] = new Name(data.getterFunction(FIELD_CASES), names[THIS_MH]);\n+\n+        {\n+            MethodType collectArgsType = basicType.changeReturnType(Object.class);\n+            MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);\n+            Object[] args = new Object[invokeBasic.type().parameterCount()];\n+            args[0] = names[GET_COLLECT_ARGS];\n+            System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT - ARG_BASE);\n+            names[BOXED_ARGS] = new Name(new NamedFunction(makeIntrinsic(invokeBasic, Intrinsic.TABLE_SWITCH, numCases)), args);\n+        }\n+\n+        {\n+            Object[] tfArgs = new Object[]{\n+                names[ARG_SWITCH_ON], names[GET_DEFAULT_CASE], names[GET_CASES], names[BOXED_ARGS]};\n+            names[TABLE_SWITCH] = new Name(getFunction(NF_tableSwitch), tfArgs);\n+        }\n+\n+        {\n+            MethodHandle invokeBasic = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));\n+            Object[] unboxArgs = new Object[]{names[GET_UNBOX_RESULT], names[TABLE_SWITCH]};\n+            names[UNBOXED_RESULT] = new Name(invokeBasic, unboxArgs);\n+        }\n+\n+        lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.TABLE_SWITCH);\n+        LambdaForm prev = TableSwitchCacheKey.CACHE.putIfAbsent(key, lform);\n+        return prev != null ? prev : lform;\n+    }\n+\n+    @Hidden\n+    static Object tableSwitch(int input, MethodHandle defaultCase, CasesHolder holder, Object[] args) throws Throwable {\n+        MethodHandle[] caseActions = holder.cases;\n+        MethodHandle selectedCase;\n+        if (input < 0 || input >= caseActions.length) {\n+            selectedCase = defaultCase;\n+        } else {\n+            selectedCase = caseActions[input];\n+        }\n+        return selectedCase.invokeWithArguments(args);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":227,"deletions":72,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -209,12 +209,12 @@\n-        switch (refKind) {\n-        case REF_getField:          return \"getField\";\n-        case REF_getStatic:         return \"getStatic\";\n-        case REF_putField:          return \"putField\";\n-        case REF_putStatic:         return \"putStatic\";\n-        case REF_invokeVirtual:     return \"invokeVirtual\";\n-        case REF_invokeStatic:      return \"invokeStatic\";\n-        case REF_invokeSpecial:     return \"invokeSpecial\";\n-        case REF_newInvokeSpecial:  return \"newInvokeSpecial\";\n-        case REF_invokeInterface:   return \"invokeInterface\";\n-        default:                    return \"REF_???\";\n-        }\n+        return switch (refKind) {\n+            case REF_getField         -> \"getField\";\n+            case REF_getStatic        -> \"getStatic\";\n+            case REF_putField         -> \"putField\";\n+            case REF_putStatic        -> \"putStatic\";\n+            case REF_invokeVirtual    -> \"invokeVirtual\";\n+            case REF_invokeStatic     -> \"invokeStatic\";\n+            case REF_invokeSpecial    -> \"invokeSpecial\";\n+            case REF_newInvokeSpecial -> \"newInvokeSpecial\";\n+            case REF_invokeInterface  -> \"invokeInterface\";\n+            default -> \"REF_???\";\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.module.IllegalAccessLogger;\n@@ -232,0 +231,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -265,7 +265,0 @@\n-\n-            if (!callerModule.isNamed() && targetModule.isNamed()) {\n-                IllegalAccessLogger logger = IllegalAccessLogger.illegalAccessLogger();\n-                if (logger != null) {\n-                    logger.logIfOpenedForIllegalAccess(caller, targetClass);\n-                }\n-            }\n@@ -451,0 +444,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -1856,0 +1850,1 @@\n+                @SuppressWarnings(\"removal\")\n@@ -1941,3 +1936,3 @@\n-         * structure of a supported major and minor version. The major and minor version\n-         * may differ from the {@code class} file version of the lookup class of this\n-         * {@code Lookup}.<\/li>\n+         * structure (JVMS {@jvms 4.1}) of a supported major and minor version.\n+         * The major and minor version may differ from the {@code class} file version\n+         * of the lookup class of this {@code Lookup}.<\/li>\n@@ -3778,0 +3773,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -3809,0 +3805,1 @@\n+            @SuppressWarnings(\"removal\")\n@@ -5217,7 +5214,7 @@\n-        switch (w) {\n-        case INT:     return result.bindArgumentI(pos, (int)value);\n-        case LONG:    return result.bindArgumentJ(pos, (long)value);\n-        case FLOAT:   return result.bindArgumentF(pos, (float)value);\n-        case DOUBLE:  return result.bindArgumentD(pos, (double)value);\n-        default:      return result.bindArgumentI(pos, ValueConversions.widenSubword(value));\n-        }\n+        return switch (w) {\n+            case INT    -> result.bindArgumentI(pos, (int) value);\n+            case LONG   -> result.bindArgumentJ(pos, (long) value);\n+            case FLOAT  -> result.bindArgumentF(pos, (float) value);\n+            case DOUBLE -> result.bindArgumentD(pos, (double) value);\n+            default -> result.bindArgumentI(pos, ValueConversions.widenSubword(value));\n+        };\n@@ -7798,0 +7795,86 @@\n+    \/**\n+     * Creates a table switch method handle, which can be used to switch over a set of target\n+     * method handles, based on a given target index, called selector.\n+     * <p>\n+     * For a selector value of {@code n}, where {@code n} falls in the range {@code [0, N)},\n+     * and where {@code N} is the number of target method handles, the table switch method\n+     * handle will invoke the n-th target method handle from the list of target method handles.\n+     * <p>\n+     * For a selector value that does not fall in the range {@code [0, N)}, the table switch\n+     * method handle will invoke the given fallback method handle.\n+     * <p>\n+     * All method handles passed to this method must have the same type, with the additional\n+     * requirement that the leading parameter be of type {@code int}. The leading parameter\n+     * represents the selector.\n+     * <p>\n+     * Any trailing parameters present in the type will appear on the returned table switch\n+     * method handle as well. Any arguments assigned to these parameters will be forwarded,\n+     * together with the selector value, to the selected method handle when invoking it.\n+     *\n+     * @apiNote Example:\n+     * The cases each drop the {@code selector} value they are given, and take an additional\n+     * {@code String} argument, which is concatenated (using {@link String#concat(String)})\n+     * to a specific constant label string for each case:\n+     * <blockquote><pre>{@code\n+     * MethodHandles.Lookup lookup = MethodHandles.lookup();\n+     * MethodHandle caseMh = lookup.findVirtual(String.class, \"concat\",\n+     *         MethodType.methodType(String.class, String.class));\n+     * caseMh = MethodHandles.dropArguments(caseMh, 0, int.class);\n+     *\n+     * MethodHandle caseDefault = MethodHandles.insertArguments(caseMh, 1, \"default: \");\n+     * MethodHandle case0 = MethodHandles.insertArguments(caseMh, 1, \"case 0: \");\n+     * MethodHandle case1 = MethodHandles.insertArguments(caseMh, 1, \"case 1: \");\n+     *\n+     * MethodHandle mhSwitch = MethodHandles.tableSwitch(\n+     *     caseDefault,\n+     *     case0,\n+     *     case1\n+     * );\n+     *\n+     * assertEquals(\"default: data\", (String) mhSwitch.invokeExact(-1, \"data\"));\n+     * assertEquals(\"case 0: data\", (String) mhSwitch.invokeExact(0, \"data\"));\n+     * assertEquals(\"case 1: data\", (String) mhSwitch.invokeExact(1, \"data\"));\n+     * assertEquals(\"default: data\", (String) mhSwitch.invokeExact(2, \"data\"));\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param fallback the fallback method handle that is called when the selector is not\n+     *                 within the range {@code [0, N)}.\n+     * @param targets array of target method handles.\n+     * @return the table switch method handle.\n+     * @throws NullPointerException if {@code fallback}, the {@code targets} array, or any\n+     *                              any of the elements of the {@code targets} array are\n+     *                              {@code null}.\n+     * @throws IllegalArgumentException if the {@code targets} array is empty, if the leading\n+     *                                  parameter of the fallback handle or any of the target\n+     *                                  handles is not {@code int}, or if the types of\n+     *                                  the fallback handle and all of target handles are\n+     *                                  not the same.\n+     *\/\n+    public static MethodHandle tableSwitch(MethodHandle fallback, MethodHandle... targets) {\n+        Objects.requireNonNull(fallback);\n+        Objects.requireNonNull(targets);\n+        targets = targets.clone();\n+        MethodType type = tableSwitchChecks(fallback, targets);\n+        return MethodHandleImpl.makeTableSwitch(type, fallback, targets);\n+    }\n+\n+    private static MethodType tableSwitchChecks(MethodHandle defaultCase, MethodHandle[] caseActions) {\n+        if (caseActions.length == 0)\n+            throw new IllegalArgumentException(\"Not enough cases: \" + Arrays.toString(caseActions));\n+\n+        MethodType expectedType = defaultCase.type();\n+\n+        if (!(expectedType.parameterCount() >= 1) || expectedType.parameterType(0) != int.class)\n+            throw new IllegalArgumentException(\n+                \"Case actions must have int as leading parameter: \" + Arrays.toString(caseActions));\n+\n+        for (MethodHandle mh : caseActions) {\n+            Objects.requireNonNull(mh);\n+            if (mh.type() != expectedType)\n+                throw new IllegalArgumentException(\n+                    \"Case actions must have the same type: \" + Arrays.toString(caseActions));\n+        }\n+\n+        return expectedType;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":101,"deletions":18,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -703,4 +703,1 @@\n-\/\/                    if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n-\/\/                        throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n-\/\/                                + ad.symbolicMethodTypeExact);\n-\/\/                    }\n+\/\/                    handle.checkExactAccessMode(ad);\n@@ -721,4 +718,1 @@\n-\/\/                    if (handle.hasInvokeExactBehavior() && handle.accessModeType(ad.type) != ad.symbolicMethodTypeExact) {\n-\/\/                        throw new WrongMethodTypeException(\"expected \" + handle.accessModeType(ad.type) + \" but found \"\n-\/\/                                + ad.symbolicMethodTypeExact);\n-\/\/                    }\n+\/\/                    handle.checkExactAccessMode(ad);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import jdk.internal.module.IllegalAccessLogger;\n@@ -86,0 +85,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -328,1 +328,0 @@\n-                logIfExportedForIllegalAccess(caller, declaringClass);\n@@ -336,1 +335,0 @@\n-                logIfExportedForIllegalAccess(caller, declaringClass);\n@@ -343,1 +341,0 @@\n-            logIfOpenedForIllegalAccess(caller, declaringClass);\n@@ -377,24 +374,0 @@\n-    private void logIfOpenedForIllegalAccess(Class<?> caller, Class<?> declaringClass) {\n-        Module callerModule = caller.getModule();\n-        Module targetModule = declaringClass.getModule();\n-        \/\/ callerModule is null during early startup\n-        if (callerModule != null && !callerModule.isNamed() && targetModule.isNamed()) {\n-            IllegalAccessLogger logger = IllegalAccessLogger.illegalAccessLogger();\n-            if (logger != null) {\n-                logger.logIfOpenedForIllegalAccess(caller, declaringClass, this::toShortString);\n-            }\n-        }\n-    }\n-\n-    private void logIfExportedForIllegalAccess(Class<?> caller, Class<?> declaringClass) {\n-        Module callerModule = caller.getModule();\n-        Module targetModule = declaringClass.getModule();\n-        \/\/ callerModule is null during early startup\n-        if (callerModule != null && !callerModule.isNamed() && targetModule.isNamed()) {\n-            IllegalAccessLogger logger = IllegalAccessLogger.illegalAccessLogger();\n-            if (logger != null) {\n-                logger.logIfExportedForIllegalAccess(caller, declaringClass, this::toShortString);\n-            }\n-        }\n-    }\n-\n@@ -501,0 +474,1 @@\n+    @Deprecated(since=\"17\")\n@@ -514,0 +488,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -524,0 +499,4 @@\n+     * @implSpec\n+     * The default implementation throws {@link\n+     * UnsupportedOperationException}; subclasses should override this method.\n+     *\n@@ -529,1 +508,1 @@\n-        throw new AssertionError(\"All subclasses should override this method\");\n+        throw new UnsupportedOperationException(\"All subclasses should override this method\");\n@@ -549,0 +528,4 @@\n+     * @implSpec\n+     * The default implementation throws {@link\n+     * UnsupportedOperationException}; subclasses should override this method.\n+     *\n@@ -554,1 +537,1 @@\n-        throw new AssertionError(\"All subclasses should override this method\");\n+        throw new UnsupportedOperationException(\"All subclasses should override this method\");\n@@ -610,0 +593,4 @@\n+     * @implSpec\n+     * The default implementation throws {@link\n+     * UnsupportedOperationException}; subclasses should override this method.\n+     *\n@@ -614,1 +601,1 @@\n-        throw new AssertionError(\"All subclasses should override this method\");\n+        throw new UnsupportedOperationException(\"All subclasses should override this method\");\n@@ -734,3 +721,0 @@\n-        \/\/ access okay\n-        logIfExportedForIllegalAccess(caller, memberClass);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessibleObject.java","additions":19,"deletions":35,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -171,0 +172,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -456,1 +458,1 @@\n-        visit(V17, accessFlags, dotToSlash(className), null,\n+        visit(V18, accessFlags, dotToSlash(className), null,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -137,0 +137,7 @@\n+\n+    \/**\n+     * Ensure given method handle is customized\n+     *\n+     * @param mh the method handle\n+     *\/\n+    void ensureCustomized(MethodHandle mh);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1463,28 +1463,0 @@\n-    \/**\n-     * Defines a class but does not make it known to the class loader or system dictionary.\n-     * <p>\n-     * For each CP entry, the corresponding CP patch must either be null or have\n-     * the a format that matches its tag:\n-     * <ul>\n-     * <li>Integer, Long, Float, Double: the corresponding wrapper object type from java.lang\n-     * <li>Utf8: a string (must have suitable syntax if used as signature or name)\n-     * <li>Class: any java.lang.Class object\n-     * <li>String: any object (not just a java.lang.String)\n-     * <li>InterfaceMethodRef: (NYI) a method handle to invoke on that call site's arguments\n-     * <\/ul>\n-     * @param hostClass context for linkage, access control, protection domain, and class loader\n-     * @param data      bytes of a class file\n-     * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data\n-     *\/\n-    @Deprecated(since = \"15\", forRemoval = true)\n-    public Class<?> defineAnonymousClass(Class<?> hostClass, byte[] data, Object[] cpPatches) {\n-        if (hostClass == null || data == null) {\n-            throw new NullPointerException();\n-        }\n-        if (hostClass.isArray() || hostClass.isPrimitive()) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        return defineAnonymousClass0(hostClass, data, cpPatches);\n-    }\n-\n@@ -4228,1 +4200,0 @@\n-    private native Class<?> defineAnonymousClass0(Class<?> hostClass, byte[] data, Object[] cpPatches);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V17) {\n+        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V18) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,0 +316,1 @@\n+    int V18 = 0 << 16 | 62;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -214,1 +214,2 @@\n-        jdk.jpackage;\n+        jdk.jpackage,\n+        jdk.incubator.foreign;\n@@ -220,1 +221,2 @@\n-        jdk.management;\n+        jdk.management,\n+        jdk.jfr;\n@@ -230,1 +232,2 @@\n-        jdk.unsupported;\n+        jdk.unsupported,\n+        jdk.incubator.foreign;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.Objects;\n@@ -327,0 +326,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -379,1 +379,1 @@\n-        return Objects.equals(class1.getPackageName(), class2.getPackageName());\n+        return class1.getPackageName() == class2.getPackageName();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -3247,0 +3247,1 @@\n+            assert(new != NULL);\n@@ -3826,1 +3827,1 @@\n-                    buffer = malloc(length + 1);\n+                    buffer = calloc(length + 1, sizeof(char));\n","filename":"src\/java.base\/share\/native\/libverify\/check_code.c","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-     * @since 15\n+     * @since 17\n@@ -78,2 +78,0 @@\n-    @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.SEALED_CLASSES,\n-                                             reflective=true)\n@@ -84,1 +82,1 @@\n-     * @since 15\n+     * @since 17\n@@ -86,2 +84,0 @@\n-    @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.SEALED_CLASSES,\n-            reflective=true)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -229,0 +231,24 @@\n+        \/**\n+         * Used for instances of {@link GuardedPatternTree}.\n+         *\n+         * @since 17\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+        GUARDED_PATTERN(GuardedPatternTree.class),\n+\n+        \/**\n+         * Used for instances of {@link ParenthesizedPatternTree}.\n+         *\n+         * @since 17\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+        PARENTHESIZED_PATTERN(ParenthesizedPatternTree.class),\n+\n+        \/**\n+         * Used for instances of {@link DefaultCaseLabelTree}.\n+         *\n+         * @since 17\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+        DEFAULT_CASE_LABEL(DefaultCaseLabelTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+\n@@ -277,0 +279,10 @@\n+    \/**\n+     * Visits a DefaultCaseLabelTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 17\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    R visitDefaultCaseLabel(DefaultCaseLabelTree node, P p);\n+\n@@ -301,0 +313,20 @@\n+    \/**\n+     * Visits a GuardPatternTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 17\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    R visitGuardedPattern(GuardedPatternTree node, P p);\n+\n+    \/**\n+     * Visits a ParenthesizedPatternTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     * @since 17\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    R visitParenthesizedPattern(ParenthesizedPatternTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -99,1 +100,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -111,1 +114,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -123,1 +128,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -135,1 +142,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -147,1 +156,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -159,1 +170,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -171,1 +184,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -183,1 +198,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -195,1 +212,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -207,1 +226,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -219,1 +240,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -243,1 +266,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -255,1 +280,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -267,1 +294,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -279,1 +308,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -291,1 +322,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -303,1 +336,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -327,1 +362,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -339,1 +376,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -351,1 +390,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -363,1 +404,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -375,1 +418,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -387,1 +432,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -399,1 +446,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -411,1 +460,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -423,1 +474,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -435,1 +488,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -447,1 +502,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -459,1 +516,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -471,1 +530,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -483,1 +544,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -495,1 +558,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -507,1 +572,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -519,1 +586,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -531,1 +600,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -543,1 +614,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -555,1 +628,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -567,1 +642,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -579,1 +656,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -592,1 +671,19 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitDefaultCaseLabel(DefaultCaseLabelTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -604,1 +701,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -616,1 +715,35 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitGuardedPattern(GuardedPatternTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -628,1 +761,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -640,1 +775,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -652,1 +789,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -664,1 +803,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -676,1 +817,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -688,1 +831,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -700,1 +845,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -712,1 +859,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -724,1 +873,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -736,1 +887,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -748,1 +901,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -760,1 +915,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -771,0 +928,10 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n+    @Override\n@@ -775,0 +942,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n@@ -780,0 +956,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n@@ -785,0 +970,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n@@ -790,0 +984,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n@@ -795,0 +998,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n@@ -800,0 +1012,10 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n+    @Override\n@@ -805,1 +1027,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n@@ -817,1 +1041,3 @@\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation calls {@code defaultAction}.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":283,"deletions":57,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -37,16 +38,0 @@\n- * <p>The default implementation of the visitXYZ methods will determine\n- * a result as follows:\n- * <ul>\n- * <li>If the node being visited has no children, the result will be {@code null}.\n- * <li>If the node being visited has one child, the result will be the\n- * result of calling {@code scan} on that child. The child may be a simple node\n- * or itself a list of nodes.\n- * <li> If the node being visited has more than one child, the result will\n- * be determined by calling {@code scan} each child in turn, and then combining the\n- * result of each scan after the first with the cumulative result\n- * so far, as determined by the {@link #reduce} method. Each child may be either\n- * a simple node of a list of nodes. The default behavior of the {@code reduce}\n- * method is such that the result of the visitXYZ method will be the result of\n- * the last child scanned.\n- * <\/ul>\n- *\n@@ -67,0 +52,17 @@\n+ * @implSpec\n+ * <p>The default implementation of the visitXYZ methods will determine\n+ * a result as follows:\n+ * <ul>\n+ * <li>If the node being visited has no children, the result will be {@code null}.\n+ * <li>If the node being visited has one child, the result will be the\n+ * result of calling {@code scan} with that child. The child may be a simple node\n+ * or itself a list of nodes.\n+ * <li>If the node being visited has more than one child, the result will\n+ * be determined by calling {@code scan} with each child in turn, and then combining the\n+ * result of each scan after the first with the cumulative result\n+ * so far, as determined by the {@link #reduce} method. Each child may be either\n+ * a simple node or a list of nodes. The default behavior of the {@code reduce}\n+ * method is such that the result of the visitXYZ method will be the result of\n+ * the last child scanned.\n+ * <\/ul>\n+ *\n@@ -138,1 +140,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -154,1 +158,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -168,1 +174,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -180,1 +188,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -186,1 +196,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -199,1 +208,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -219,1 +230,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -235,1 +248,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -247,1 +262,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -259,1 +276,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -273,1 +292,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -287,1 +308,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -317,1 +340,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -332,1 +357,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -344,1 +371,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -358,1 +387,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -372,1 +403,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -389,1 +422,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -415,1 +450,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -431,1 +468,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -445,1 +484,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -460,1 +501,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -475,1 +518,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -487,1 +532,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -499,1 +546,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -511,1 +560,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -523,1 +574,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -535,1 +588,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -549,1 +604,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -564,1 +621,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -581,1 +640,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -600,1 +661,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -614,1 +677,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -626,1 +691,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -640,1 +707,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -654,1 +723,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -666,1 +737,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -680,1 +753,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -694,1 +769,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -712,1 +789,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -725,1 +804,19 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitDefaultCaseLabel(DefaultCaseLabelTree node, P p) {\n+        return null;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -739,1 +836,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -751,1 +850,36 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n+        return scan(node.getPattern(), p);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     * @since 17\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.SWITCH_PATTERN_MATCHING, reflective=true)\n+    public R visitGuardedPattern(GuardedPatternTree node, P p) {\n+        R r = scan(node.getPattern(), p);\n+        return scanAndReduce(node.getExpression(), p, r);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -765,1 +899,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -777,1 +913,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -789,1 +927,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -801,1 +941,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -813,1 +955,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -827,1 +971,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -839,1 +985,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -851,1 +999,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -865,1 +1015,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -877,1 +1029,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -889,1 +1043,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -903,1 +1059,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n@@ -916,0 +1074,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n@@ -924,0 +1091,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n@@ -931,0 +1107,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n@@ -938,0 +1123,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n@@ -945,0 +1139,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n@@ -950,0 +1153,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n@@ -956,1 +1168,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -968,1 +1182,3 @@\n-     * {@inheritDoc} This implementation returns {@code null}.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation returns {@code null}.\n@@ -980,1 +1196,3 @@\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":293,"deletions":75,"binary":false,"changes":368,"status":"modified"},{"patch":"@@ -627,1 +627,0 @@\n-    \/** @see com.sun.tools.javadoc.ClassDocImpl#findField *\/\n@@ -632,1 +631,0 @@\n-    \/** @see com.sun.tools.javadoc.ClassDocImpl#searchField *\/\n@@ -679,1 +677,0 @@\n-    \/** @see com.sun.tools.javadoc.ClassDocImpl#findConstructor *\/\n@@ -691,1 +688,0 @@\n-    \/** @see com.sun.tools.javadoc.ClassDocImpl#findMethod *\/\n@@ -696,1 +692,0 @@\n-    \/** @see com.sun.tools.javadoc.ClassDocImpl#searchMethod *\/\n@@ -778,1 +773,0 @@\n-    \/** @see com.sun.tools.javadoc.ClassDocImpl *\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -196,1 +196,6 @@\n-    public static final int ANONCONSTR   = 1<<29;\n+    public static final int ANONCONSTR   = 1<<29; \/\/non-class members\n+\n+    \/**\n+     * Flag to indicate the super classes of this ClassSymbol has been attributed.\n+     *\/\n+    public static final int SUPER_OWNER_ATTRIBUTED = 1<<29; \/\/ClassSymbols\n@@ -400,0 +405,1 @@\n+\n@@ -429,1 +435,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,3 @@\n+            if (Source.Feature.REDUNDANT_STRICTFP.allowedInSource(source)) {\n+                values.add(LintCategory.STRICTFP);\n+            }\n@@ -291,0 +294,5 @@\n+        \/**\n+         * Warn about unnecessary uses of the strictfp modifier\n+         *\/\n+        STRICTFP(\"strictfp\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,6 @@\n-    JDK17(\"17\");\n+    JDK17(\"17\"),\n+\n+    \/**\n+      * 18, tbd\n+      *\/\n+    JDK18(\"18\");\n@@ -167,0 +172,1 @@\n+        case JDK18  -> Target.JDK1_18;\n@@ -228,0 +234,3 @@\n+        CASE_NULL(JDK17, Fragments.FeatureCaseNull, DiagKind.NORMAL),\n+        PATTERN_SWITCH(JDK17, Fragments.FeaturePatternSwitch, DiagKind.PLURAL),\n+        REDUNDANT_STRICTFP(JDK17),\n@@ -307,0 +316,1 @@\n+        case JDK18  -> RELEASE_18;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1520,1 +1520,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -1569,1 +1568,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -1754,1 +1752,0 @@\n-                @SuppressWarnings(\"preview\")\n@@ -1823,1 +1820,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -1866,1 +1862,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -1877,1 +1872,0 @@\n-        @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+    public final Type switchBootstrapsType;\n@@ -603,0 +604,1 @@\n+        switchBootstrapsType = enterClass(\"java.lang.runtime.SwitchBootstraps\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.tools.javac.code.Attribute.Array;\n@@ -1227,1 +1226,3 @@\n-                            separateAnnotationsKinds(param.vartype, param.sym.type, param.sym, pos);\n+                            if (!param.declaredUsingVar()) {\n+                                separateAnnotationsKinds(param.vartype, param.sym.type, param.sym, pos);\n+                            }\n@@ -1265,1 +1266,1 @@\n-                if (!tree.isImplicitlyTyped()) {\n+                if (!tree.declaredUsingVar()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -172,3 +172,1 @@\n-        allowReifiableTypesInInstanceof =\n-                Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &&\n-                (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());\n+        allowReifiableTypesInInstanceof = Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source);\n@@ -1733,2 +1731,10 @@\n-            if (!enumSwitch && !stringSwitch)\n-                seltype = chk.checkType(selector.pos(), seltype, syms.intType);\n+            boolean patternSwitch;\n+            if (!enumSwitch && !stringSwitch && !errorEnumSwitch &&\n+                !types.isAssignable(seltype, syms.intType)) {\n+                preview.checkSourceLevel(selector.pos(), Feature.PATTERN_SWITCH);\n+                patternSwitch = true;\n+            } else {\n+                patternSwitch = cases.stream()\n+                                     .flatMap(c -> c.labels.stream())\n+                                     .anyMatch(l -> l.isPattern());\n+            }\n@@ -1739,1 +1745,4 @@\n-            boolean hasDefault = false;      \/\/ Is there a default label?\n+            List<Type> coveredTypes = List.nil();\n+            boolean hasDefault = false;           \/\/ Is there a default label?\n+            boolean hasTotalPattern = false;      \/\/ Is there a total pattern?\n+            boolean hasNullPattern = false;       \/\/ Is there a null pattern?\n@@ -1742,0 +1751,2 @@\n+            MatchBindings prevBindings = null;\n+            boolean prevCompletedNormally = false;\n@@ -1751,5 +1762,15 @@\n-                if (c.getExpressions().nonEmpty()) {\n-                    for (JCExpression pat : c.getExpressions()) {\n-                        if (TreeInfo.isNull(pat)) {\n-                            log.error(pat.pos(),\n-                                      Errors.SwitchNullNotAllowed);\n+                MatchBindings currentBindings = prevBindings;\n+                boolean wasTotalPattern = hasTotalPattern;\n+                for (JCCaseLabel pat : c.labels) {\n+                    if (pat.isExpression()) {\n+                        JCExpression expr = (JCExpression) pat;\n+                        if (TreeInfo.isNull(expr)) {\n+                            preview.checkSourceLevel(expr.pos(), Feature.CASE_NULL);\n+                            if (hasNullPattern) {\n+                                log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                            } else if (wasTotalPattern) {\n+                                log.error(c.pos(), Errors.PatternDominated);\n+                            }\n+                            hasNullPattern = true;\n+                            attribExpr(expr, switchEnv, seltype);\n+                            matchBindings = new MatchBindings(matchBindings.bindingsWhenTrue, matchBindings.bindingsWhenFalse, true);\n@@ -1757,1 +1778,1 @@\n-                            Symbol sym = enumConstant(pat, seltype);\n+                            Symbol sym = enumConstant(expr, seltype);\n@@ -1759,1 +1780,1 @@\n-                                log.error(pat.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);\n+                                log.error(expr.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);\n@@ -1762,0 +1783,2 @@\n+                            } else {\n+                                checkCaseLabelDominated(pat.pos(), coveredTypes, sym.type);\n@@ -1775,1 +1798,1 @@\n-                            Type pattype = attribExpr(pat, switchEnv, seltype);\n+                            Type pattype = attribExpr(expr, switchEnv, seltype);\n@@ -1777,0 +1800,3 @@\n+                                if (!stringSwitch && !types.isAssignable(seltype, syms.intType)) {\n+                                    log.error(pat.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                }\n@@ -1778,1 +1804,1 @@\n-                                    log.error(pat.pos(),\n+                                    log.error(expr.pos(),\n@@ -1782,0 +1808,2 @@\n+                                } else {\n+                                    checkCaseLabelDominated(pat.pos(), coveredTypes, types.boxedTypeOrType(pattype));\n@@ -1785,0 +1813,39 @@\n+                    } else if (pat.hasTag(DEFAULTCASELABEL)) {\n+                        if (hasDefault) {\n+                            log.error(pat.pos(), Errors.DuplicateDefaultLabel);\n+                        } else if (hasTotalPattern) {\n+                            log.error(pat.pos(), Errors.TotalPatternAndDefault);\n+                        } else if (matchBindings.bindingsWhenTrue.nonEmpty()) {\n+                            \/\/there was a pattern, and the execution flows into a default:\n+                            log.error(pat.pos(), Errors.FlowsThroughFromPattern);\n+                        }\n+                        hasDefault = true;\n+                        matchBindings = MatchBindingsComputer.EMPTY;\n+                    } else {\n+                        if (prevCompletedNormally) {\n+                            log.error(pat.pos(), Errors.FlowsThroughToPattern);\n+                        }\n+                        \/\/binding pattern\n+                        attribExpr(pat, switchEnv);\n+                        var primary = TreeInfo.primaryPatternType((JCPattern) pat);\n+                        Type primaryType = primary.type();\n+                        if (!primaryType.hasTag(TYPEVAR)) {\n+                            primaryType = chk.checkClassOrArrayType(pat.pos(), primaryType);\n+                        }\n+                        checkCastablePattern(pat.pos(), seltype, primaryType);\n+                        Type patternType = types.erasure(primaryType);\n+                        boolean isTotal = primary.unconditional() &&\n+                                          !patternType.isErroneous() &&\n+                                          types.isSubtype(types.erasure(seltype), patternType);\n+                        if (isTotal) {\n+                            if (hasTotalPattern) {\n+                                log.error(pat.pos(), Errors.DuplicateTotalPattern);\n+                            } else if (hasDefault) {\n+                                log.error(pat.pos(), Errors.TotalPatternAndDefault);\n+                            }\n+                            hasTotalPattern = true;\n+                        }\n+                        checkCaseLabelDominated(pat.pos(), coveredTypes, patternType);\n+                        if (primary.unconditional() && !patternType.isErroneous()) {\n+                            coveredTypes = coveredTypes.prepend(patternType);\n+                        }\n@@ -1786,4 +1853,2 @@\n-                } else if (hasDefault) {\n-                    log.error(c.pos(), Errors.DuplicateDefaultLabel);\n-                } else {\n-                    hasDefault = true;\n+                    currentBindings = matchBindingsComputer.switchCase(pat, currentBindings, matchBindings);\n+                    prevCompletedNormally = !TreeInfo.isNull(pat);\n@@ -1792,1 +1857,1 @@\n-                    switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));\n+                        bindingEnv(switchEnv, c, currentBindings.bindingsWhenTrue);\n@@ -1799,0 +1864,16 @@\n+\n+                boolean completesNormally = c.caseKind == CaseTree.CaseKind.STATEMENT ? flow.aliveAfter(caseEnv, c, make) : false;\n+                prevBindings = completesNormally ? currentBindings : null;\n+                prevCompletedNormally =\n+                        completesNormally &&\n+                        !(c.labels.size() == 1 &&\n+                          TreeInfo.isNull(c.labels.head) && c.stats.isEmpty());\n+            }\n+            if (switchTree.hasTag(SWITCH)) {\n+                ((JCSwitch) switchTree).hasTotalPattern = hasDefault || hasTotalPattern;\n+                ((JCSwitch) switchTree).patternSwitch = patternSwitch;\n+            } else if (switchTree.hasTag(SWITCH_EXPRESSION)) {\n+                ((JCSwitchExpression) switchTree).hasTotalPattern = hasDefault || hasTotalPattern;\n+                ((JCSwitchExpression) switchTree).patternSwitch = patternSwitch;\n+            } else {\n+                Assert.error(switchTree.getTag().name());\n@@ -1813,0 +1894,8 @@\n+        private void checkCaseLabelDominated(DiagnosticPosition pos,\n+                                             List<Type> coveredTypes, Type patternType) {\n+            for (Type existing : coveredTypes) {\n+                if (types.isSubtype(patternType, existing)) {\n+                    log.error(pos, Errors.PatternDominated);\n+                }\n+            }\n+        }\n@@ -2158,1 +2247,5 @@\n-        Env<AttrContext> env1 = env.dup(env.tree, env.info.dup(env.info.scope.dup()));\n+        return bindingEnv(env, env.tree, bindings);\n+    }\n+\n+    Env<AttrContext> bindingEnv(Env<AttrContext> env, JCTree newTree, List<BindingSymbol> bindings) {\n+        Env<AttrContext> env1 = env.dup(newTree, env.info.dup(env.info.scope.dup()));\n@@ -4126,13 +4219,1 @@\n-                if (preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF)) {\n-                    preview.warnPreview(tree.expr.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF);\n-                }\n-                Warner warner = new Warner();\n-                if (!types.isCastable(exprtype, clazztype, warner)) {\n-                    chk.basicHandler.report(tree.expr.pos(),\n-                                            diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));\n-                } else if (warner.hasLint(LintCategory.UNCHECKED)) {\n-                    log.error(tree.expr.pos(),\n-                              Errors.InstanceofReifiableNotSafe(exprtype, clazztype));\n-                } else {\n-                    valid = true;\n-                }\n+                valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n@@ -4153,0 +4234,17 @@\n+    private boolean checkCastablePattern(DiagnosticPosition pos,\n+                                         Type exprType,\n+                                         Type pattType) {\n+        Warner warner = new Warner();\n+        if (!types.isCastable(exprType, pattType, warner)) {\n+            chk.basicHandler.report(pos,\n+                    diags.fragment(Fragments.InconvertibleTypes(exprType, pattType)));\n+            return false;\n+        } else if (warner.hasLint(LintCategory.UNCHECKED)) {\n+            log.error(pos,\n+                    Errors.InstanceofReifiableNotSafe(exprType, pattType));\n+            return false;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n@@ -4169,0 +4267,19 @@\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+        attribExpr(tree.pattern, env);\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern tree) {\n+        attribExpr(tree.patt, env);\n+        MatchBindings afterPattern = matchBindings;\n+        Env<AttrContext> bodyEnv = bindingEnv(env, matchBindings.bindingsWhenTrue);\n+        try {\n+            attribExpr(tree.expr, bodyEnv, syms.booleanType);\n+        } finally {\n+            bodyEnv.info.scope.leave();\n+        }\n+        result = tree.type = tree.patt.type;\n+        matchBindings = matchBindingsComputer.guardedPattern(tree, afterPattern, matchBindings);\n+    }\n+\n@@ -5271,1 +5388,2 @@\n-        if ((c.flags_field & Flags.COMPOUND) == 0) {\n+        if ((c.flags_field & Flags.COMPOUND) == 0 &&\n+            (c.flags_field & Flags.SUPER_OWNER_ATTRIBUTED) == 0) {\n@@ -5279,0 +5397,2 @@\n+\n+            c.flags_field |= Flags.SUPER_OWNER_ATTRIBUTED;\n@@ -5370,3 +5490,11 @@\n-                for (ClassSymbol supertypeSym : sealedSupers) {\n-                    if (!supertypeSym.permitted.contains(c.type.tsym)) {\n-                        log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));\n+                if (!c.type.isCompound()) {\n+                    for (ClassSymbol supertypeSym : sealedSupers) {\n+                        if (!supertypeSym.permitted.contains(c.type.tsym)) {\n+                            log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));\n+                        }\n+                    }\n+                    if (!c.isNonSealed() && !c.isFinal() && !c.isSealed()) {\n+                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree),\n+                                c.isInterface() ?\n+                                        Errors.NonSealedOrSealedExpected :\n+                                        Errors.NonSealedSealedOrFinalExpected);\n@@ -5374,6 +5502,0 @@\n-                }\n-                if (!c.isNonSealed() && !c.isFinal() && !c.isSealed()) {\n-                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree),\n-                            c.isInterface() ?\n-                                    Errors.NonSealedOrSealedExpected :\n-                                    Errors.NonSealedSealedOrFinalExpected);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":166,"deletions":44,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -163,2 +163,1 @@\n-        allowSealed = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &&\n-                Feature.SEALED_CLASSES.allowedInSource(source);\n+        allowSealed = Feature.SEALED_CLASSES.allowedInSource(source);\n@@ -1395,0 +1394,3 @@\n+            if ((flags & STRICTFP) != 0) {\n+                warnOnExplicitStrictfp(pos);\n+            }\n@@ -1436,0 +1438,3 @@\n+            if ((flags & STRICTFP) != 0) {\n+                warnOnExplicitStrictfp(pos);\n+            }\n@@ -1498,0 +1503,13 @@\n+    private void warnOnExplicitStrictfp(DiagnosticPosition pos) {\n+        DiagnosticPosition prevLintPos = deferredLintHandler.setPos(pos);\n+        try {\n+            deferredLintHandler.report(() -> {\n+                                           if (lint.isEnabled(LintCategory.STRICTFP)) {\n+                                               log.warning(LintCategory.STRICTFP,\n+                                                           pos, Warnings.Strictfp); }\n+                                       });\n+        } finally {\n+            deferredLintHandler.setPos(prevLintPos);\n+        }\n+    }\n+\n@@ -2481,1 +2499,1 @@\n-        List<Symbol> seenClasses = List.nil();\n+        Set<Symbol> seenClasses = new HashSet<>();\n@@ -2500,1 +2518,1 @@\n-            } else {\n+            } else if (sym == null || sym.kind != PCK) {\n@@ -2549,1 +2567,1 @@\n-                    seenClasses = seenClasses.prepend(c);\n+                    seenClasses.add(c);\n@@ -2572,1 +2590,1 @@\n-                    seenClasses = seenClasses.tail;\n+                    seenClasses.remove(c);\n@@ -3570,1 +3588,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -330,0 +330,1 @@\n+                setPackageSymbols.scan(pd);\n@@ -393,0 +394,25 @@\n+        \/\/where:\n+        \/\/set package Symbols to the package expression:\n+        private final TreeScanner setPackageSymbols = new TreeScanner() {\n+            Symbol currentPackage;\n+\n+            @Override\n+            public void visitIdent(JCIdent tree) {\n+                tree.sym = currentPackage;\n+                tree.type = currentPackage.type;\n+            }\n+\n+            @Override\n+            public void visitSelect(JCFieldAccess tree) {\n+                tree.sym = currentPackage;\n+                tree.type = currentPackage.type;\n+                currentPackage = currentPackage.owner;\n+                super.visitSelect(tree);\n+            }\n+\n+            @Override\n+            public void visitPackageDef(JCPackageDecl tree) {\n+                currentPackage = tree.packge;\n+                scan(tree.pid);\n+            }\n+        };\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import com.sun.tools.javac.tree.TreeInfo.PatternPrimaryType;\n@@ -58,0 +59,2 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n+import com.sun.tools.javac.tree.JCTree.JCParenthesizedPattern;\n@@ -59,0 +62,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.Fragment;\n@@ -666,1 +670,1 @@\n-            boolean hasDefault = false;\n+            Set<Object> constants = tree.patternSwitch ? allSwitchConstants(tree.selector) : null;\n@@ -670,6 +674,3 @@\n-                if (c.pats.isEmpty())\n-                    hasDefault = true;\n-                else {\n-                    for (JCExpression pat : c.pats) {\n-                        scan(pat);\n-                    }\n+                for (JCCaseLabel pat : c.labels) {\n+                    scan(pat);\n+                    handleConstantCaseLabel(constants, pat);\n@@ -691,1 +692,5 @@\n-            if (!hasDefault) {\n+            if ((constants == null || !constants.isEmpty()) && !tree.hasTotalPattern &&\n+                tree.patternSwitch && !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n+                log.error(tree, Errors.NotExhaustiveStatement);\n+            }\n+            if (!tree.hasTotalPattern) {\n@@ -702,11 +707,1 @@\n-            Set<Object> constants = null;\n-            TypeSymbol selectorSym = tree.selector.type.tsym;\n-            if ((selectorSym.flags() & ENUM) != 0) {\n-                constants = new HashSet<>();\n-                Predicate<Symbol> enumConstantFilter =\n-                        s -> (s.flags() & ENUM) != 0 && s.kind == Kind.VAR;\n-                for (Symbol s : selectorSym.members().getSymbols(enumConstantFilter)) {\n-                    constants.add(s.name);\n-                }\n-            }\n-            boolean hasDefault = false;\n+            Set<Object> constants = allSwitchConstants(tree.selector);\n@@ -717,12 +712,3 @@\n-                if (c.pats.isEmpty())\n-                    hasDefault = true;\n-                else {\n-                    for (JCExpression pat : c.pats) {\n-                        scan(pat);\n-                        if (constants != null) {\n-                            if (pat.hasTag(IDENT))\n-                                constants.remove(((JCIdent) pat).name);\n-                            if (pat.type != null)\n-                                constants.remove(pat.type.constValue());\n-                        }\n-                    }\n+                for (JCCaseLabel pat : c.labels) {\n+                    scan(pat);\n+                    handleConstantCaseLabel(constants, pat);\n@@ -742,1 +728,1 @@\n-            if ((constants == null || !constants.isEmpty()) && !hasDefault &&\n+            if ((constants == null || !constants.isEmpty()) && !tree.hasTotalPattern &&\n@@ -750,0 +736,33 @@\n+        private Set<Object> allSwitchConstants(JCExpression selector) {\n+            Set<Object> constants = null;\n+            TypeSymbol selectorSym = selector.type.tsym;\n+            if ((selectorSym.flags() & ENUM) != 0) {\n+                constants = new HashSet<>();\n+                Predicate<Symbol> enumConstantFilter =\n+                        s -> (s.flags() & ENUM) != 0 && s.kind == Kind.VAR;\n+                for (Symbol s : selectorSym.members().getSymbols(enumConstantFilter)) {\n+                    constants.add(s.name);\n+                }\n+            } else if (selectorSym.isAbstract() && selectorSym.isSealed() && selectorSym.kind == Kind.TYP) {\n+                constants = new HashSet<>();\n+                constants.addAll(((ClassSymbol) selectorSym).permitted);\n+            }\n+            return constants;\n+        }\n+\n+        private void handleConstantCaseLabel(Set<Object> constants, JCCaseLabel pat) {\n+            if (constants != null) {\n+                if (pat.isExpression()) {\n+                    JCExpression expr = (JCExpression) pat;\n+                    if (expr.hasTag(IDENT))\n+                        constants.remove(((JCIdent) expr).name);\n+                } else if (pat.isPattern()) {\n+                    PatternPrimaryType patternType = TreeInfo.primaryPatternType((JCPattern) pat);\n+\n+                    if (patternType.unconditional()) {\n+                        constants.remove(patternType.type().tsym);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -1199,1 +1218,1 @@\n-                scan(c.pats);\n+                scan(c.labels);\n@@ -2398,1 +2417,1 @@\n-            handleSwitch(tree, tree.selector, tree.cases);\n+            handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern);\n@@ -2402,1 +2421,1 @@\n-            handleSwitch(tree, tree.selector, tree.cases);\n+            handleSwitch(tree, tree.selector, tree.cases, tree.hasTotalPattern);\n@@ -2405,1 +2424,2 @@\n-        private void handleSwitch(JCTree tree, JCExpression selector, List<JCCase> cases) {\n+        private void handleSwitch(JCTree tree, JCExpression selector,\n+                                  List<JCCase> cases, boolean hasTotalPattern) {\n@@ -2412,1 +2432,0 @@\n-            boolean hasDefault = false;\n@@ -2417,10 +2436,15 @@\n-                if (c.pats.isEmpty()) {\n-                    hasDefault = true;\n-                } else {\n-                    for (JCExpression pat : c.pats) {\n-                        scanExpr(pat);\n-                    }\n-                }\n-                if (hasDefault) {\n-                    inits.assign(initsSwitch);\n-                    uninits.assign(uninits.andSet(uninitsSwitch));\n+                for (JCCaseLabel pat : c.labels) {\n+                    scan(pat);\n+                }\n+                if (l.head.stats.isEmpty() &&\n+                    l.tail.nonEmpty() &&\n+                    l.tail.head.labels.size() == 1 &&\n+                    l.tail.head.labels.head.isExpression() &&\n+                    TreeInfo.isNull(l.tail.head.labels.head)) {\n+                    \/\/handling:\n+                    \/\/case Integer i:\n+                    \/\/case null:\n+                    \/\/joining these two cases together - processing Integer i pattern,\n+                    \/\/but statements from case null:\n+                    l = l.tail;\n+                    c = l.head;\n@@ -2433,4 +2457,0 @@\n-                if (!hasDefault) {\n-                    inits.assign(initsSwitch);\n-                    uninits.assign(uninits.andSet(uninitsSwitch));\n-                }\n@@ -2439,1 +2459,1 @@\n-            if (!hasDefault) {\n+            if (!hasTotalPattern) {\n@@ -2443,1 +2463,2 @@\n-                    inits.andSet(initsSwitch);\n+                    inits.assign(initsSwitch);\n+                    uninits.assign(uninits.andSet(uninitsSwitch));\n@@ -2922,0 +2943,1 @@\n+                    case GUARDPATTERN:\n@@ -2945,0 +2967,1 @@\n+                        case GUARDPATTERN:\n@@ -2953,2 +2976,6 @@\n-            String subKey = currentTree.hasTag(LAMBDA) ?\n-                  \"lambda\"  : \"inner.cls\";\n+            Fragment subKey = switch (currentTree.getTag()) {\n+                case LAMBDA -> Fragments.Lambda;\n+                case GUARDPATTERN -> Fragments.Guard;\n+                case CLASSDEF -> Fragments.InnerCls;\n+                default -> throw new AssertionError(\"Unexpected tree kind: \" + currentTree.getTag());\n+            };\n@@ -2990,0 +3017,12 @@\n+        @Override\n+        public void visitGuardPattern(JCGuardPattern tree) {\n+            scan(tree.patt);\n+            JCTree prevTree = currentTree;\n+            try {\n+                currentTree = tree;\n+                scan(tree.expr);\n+            } finally {\n+                currentTree = prevTree;\n+            }\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":94,"deletions":55,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -3646,1 +3646,2 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+        List<JCCase> cases = tree.patternSwitch ? addDefaultIfNeeded(tree.cases) : tree.cases;\n+        handleSwitch(tree, tree.selector, cases);\n@@ -3651,1 +3652,6 @@\n-        if (tree.cases.stream().noneMatch(c -> c.pats.isEmpty())) {\n+        List<JCCase> cases = addDefaultIfNeeded(tree.cases);\n+        handleSwitch(tree, tree.selector, cases);\n+    }\n+\n+    private List<JCCase> addDefaultIfNeeded(List<JCCase> cases) {\n+        if (cases.stream().flatMap(c -> c.labels.stream()).noneMatch(p -> p.hasTag(Tag.DEFAULTCASELABEL))) {\n@@ -3654,2 +3660,2 @@\n-            JCCase c = make.Case(JCCase.STATEMENT, List.nil(), List.of(thr), null);\n-            tree.cases = tree.cases.append(c);\n+            JCCase c = make.Case(JCCase.STATEMENT, List.of(make.DefaultCaseLabel()), List.of(thr), null);\n+            cases = cases.append(c);\n@@ -3657,1 +3663,2 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+\n+        return cases;\n@@ -3665,1 +3672,1 @@\n-            switch (c.pats.size()) {\n+            switch (c.labels.size()) {\n@@ -3676,1 +3683,1 @@\n-                    List<JCExpression> patterns = c.pats;\n+                    List<JCCaseLabel> patterns = c.labels;\n@@ -3684,1 +3691,1 @@\n-                    c.pats = patterns;\n+                    c.labels = patterns;\n@@ -3692,1 +3699,1 @@\n-                JCBreak b = make_at(c.pos()).Break(null);\n+                JCBreak b = make.at(TreeInfo.endPos(c.stats.last())).Break(null);\n@@ -3705,3 +3712,2 @@\n-        Type target = enumSwitch ? selector.type :\n-            (stringSwitch? syms.stringType : syms.intType);\n-        selector = translate(selector, target);\n+        boolean boxedSwitch = !enumSwitch && !stringSwitch && !selector.type.isPrimitive();\n+        selector = translate(selector, selector.type);\n@@ -3722,0 +3728,4 @@\n+        } else if (boxedSwitch) {\n+            \/\/An switch over boxed primitive. Pattern matching switches are already translated\n+            \/\/by TransPatterns, so all non-primitive types are only boxed primitives:\n+            result = visitBoxedPrimitiveSwitch(tree, selector, cases);\n@@ -3735,3 +3745,26 @@\n-        JCArrayAccess newSelector = make.Indexed(map.mapVar,\n-                                        make.App(make.Select(selector,\n-                                                             ordinalMethod)));\n+        JCExpression newSelector;\n+\n+        if (cases.stream().anyMatch(c -> TreeInfo.isNull(c.labels.head))) {\n+            \/\/for enum switches with case null, do:\n+            \/\/switch ($selector != null ? $mapVar[$selector.ordinal()] : -1) {...}\n+            \/\/replacing case null with case -1:\n+            VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,\n+                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               selector.type,\n+                                               currentMethodSym);\n+            JCStatement var = make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type);\n+            newSelector = make.Indexed(map.mapVar,\n+                    make.App(make.Select(make.Ident(dollar_s),\n+                            ordinalMethod)));\n+            newSelector =\n+                    make.LetExpr(List.of(var),\n+                                 make.Conditional(makeBinary(NE, make.Ident(dollar_s), makeNull()),\n+                                                  newSelector,\n+                                                  makeLit(syms.intType, -1))\n+                                     .setType(newSelector.type))\n+                        .setType(newSelector.type);\n+        } else {\n+            newSelector = make.Indexed(map.mapVar,\n+                    make.App(make.Select(selector,\n+                            ordinalMethod)));\n+        }\n@@ -3740,3 +3773,8 @@\n-            if (c.pats.nonEmpty()) {\n-                VarSymbol label = (VarSymbol)TreeInfo.symbol(c.pats.head);\n-                JCLiteral pat = map.forConstant(label);\n+            if (c.labels.head.isExpression()) {\n+                JCExpression pat;\n+                if (TreeInfo.isNull(c.labels.head)) {\n+                    pat = makeLit(syms.intType, -1);\n+                } else {\n+                    VarSymbol label = (VarSymbol)TreeInfo.symbol((JCExpression) c.labels.head);\n+                    pat = map.forConstant(label);\n+                }\n@@ -3819,0 +3857,2 @@\n+            JCCase nullCase = null;\n+            int nullCaseLabel = -1;\n@@ -3821,12 +3861,4 @@\n-                if (oneCase.pats.nonEmpty()) { \/\/ pats is empty for a \"default\" case\n-                    JCExpression expression = oneCase.pats.head;\n-                    String labelExpr = (String) expression.type.constValue();\n-                    Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);\n-                    Assert.checkNull(mapping);\n-                    int hashCode = labelExpr.hashCode();\n-\n-                    Set<String> stringSet = hashToString.get(hashCode);\n-                    if (stringSet == null) {\n-                        stringSet = new LinkedHashSet<>(1, 1.0f);\n-                        stringSet.add(labelExpr);\n-                        hashToString.put(hashCode, stringSet);\n+                if (oneCase.labels.head.isExpression()) {\n+                    if (TreeInfo.isNull(oneCase.labels.head)) {\n+                        nullCase = oneCase;\n+                        nullCaseLabel = casePosition;\n@@ -3834,2 +3866,15 @@\n-                        boolean added = stringSet.add(labelExpr);\n-                        Assert.check(added);\n+                        JCExpression expression = (JCExpression) oneCase.labels.head;\n+                        String labelExpr = (String) expression.type.constValue();\n+                        Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);\n+                        Assert.checkNull(mapping);\n+                        int hashCode = labelExpr.hashCode();\n+\n+                        Set<String> stringSet = hashToString.get(hashCode);\n+                        if (stringSet == null) {\n+                            stringSet = new LinkedHashSet<>(1, 1.0f);\n+                            stringSet.add(labelExpr);\n+                            hashToString.put(hashCode, stringSet);\n+                        } else {\n+                            boolean added = stringSet.add(labelExpr);\n+                            Assert.check(added);\n+                        }\n@@ -3910,1 +3955,8 @@\n-            stmtList.append(switch1);\n+\n+            if (nullCase != null) {\n+                stmtList.append(make.If(makeBinary(NE, make.Ident(dollar_s), makeNull()), switch1, make.Exec(make.Assign(make.Ident(dollar_tmp),\n+                                                             make.Literal(nullCaseLabel)).\n+                                                 setType(dollar_tmp.type))).setType(syms.intType));\n+            } else {\n+                stmtList.append(switch1);\n+            }\n@@ -3918,2 +3970,2 @@\n-                boolean isDefault = (oneCase.pats.isEmpty());\n-                JCExpression caseExpr;\n+                boolean isDefault = !oneCase.labels.head.isExpression();\n+                JCCaseLabel caseExpr;\n@@ -3922,2 +3974,4 @@\n-                else {\n-                    caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens(oneCase.pats.head).\n+                else if (oneCase == nullCase) {\n+                    caseExpr = make.Literal(nullCaseLabel);\n+                } else {\n+                    caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens((JCExpression) oneCase.labels.head).\n@@ -3927,1 +3981,1 @@\n-                lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.nil() : List.of(caseExpr),\n+                lb.append(make.Case(JCCase.STATEMENT, caseExpr == null ? List.of(make.DefaultCaseLabel()) : List.of(caseExpr),\n@@ -3961,0 +4015,64 @@\n+    private JCTree visitBoxedPrimitiveSwitch(JCTree tree, JCExpression selector, List<JCCase> cases) {\n+        JCExpression newSelector;\n+\n+        if (cases.stream().anyMatch(c -> TreeInfo.isNull(c.labels.head))) {\n+            \/\/a switch over a boxed primitive, with a null case. Pick two constants that are\n+            \/\/not used by any branch in the case (c1 and c2), close to other constants that are\n+            \/\/used in the switch. Then do:\n+            \/\/switch ($selector != null ? $selector != c1 ? $selector : c2 : c1) {...}\n+            \/\/replacing case null with case c1\n+            Set<Integer> constants = new LinkedHashSet<>();\n+            JCCase nullCase = null;\n+\n+            for (JCCase c : cases) {\n+                if (TreeInfo.isNull(c.labels.head)) {\n+                    nullCase = c;\n+                } else if (!c.labels.head.hasTag(DEFAULTCASELABEL)) {\n+                    constants.add((int) c.labels.head.type.constValue());\n+                }\n+            }\n+\n+            Assert.checkNonNull(nullCase);\n+\n+            int nullValue = constants.isEmpty() ? 0 : constants.iterator().next();\n+\n+            while (constants.contains(nullValue)) nullValue++;\n+\n+            constants.add(nullValue);\n+            nullCase.labels.head = makeLit(syms.intType, nullValue);\n+\n+            int replacementValue = nullValue;\n+\n+            while (constants.contains(replacementValue)) replacementValue++;\n+\n+            VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,\n+                                               names.fromString(\"s\" + tree.pos + this.target.syntheticNameChar()),\n+                                               selector.type,\n+                                               currentMethodSym);\n+            JCStatement var = make.at(tree.pos()).VarDef(dollar_s, selector).setType(dollar_s.type);\n+            JCExpression nullValueReplacement =\n+                    make.Conditional(makeBinary(NE,\n+                                                 unbox(make.Ident(dollar_s), syms.intType),\n+                                                 makeLit(syms.intType, nullValue)),\n+                                     unbox(make.Ident(dollar_s), syms.intType),\n+                                     makeLit(syms.intType, replacementValue))\n+                        .setType(syms.intType);\n+            JCExpression nullCheck =\n+                    make.Conditional(makeBinary(NE, make.Ident(dollar_s), makeNull()),\n+                                     nullValueReplacement,\n+                                     makeLit(syms.intType, nullValue))\n+                        .setType(syms.intType);\n+            newSelector = make.LetExpr(List.of(var), nullCheck).setType(syms.intType);\n+        } else {\n+            newSelector = unbox(selector, syms.intType);\n+        }\n+\n+        if (tree.hasTag(SWITCH)) {\n+            ((JCSwitch) tree).selector = newSelector;\n+        } else {\n+            ((JCSwitchExpression) tree).selector = newSelector;\n+        }\n+\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":156,"deletions":38,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import static com.sun.tools.javac.tree.JCTree.Tag.VARDEF;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,2 +149,1 @@\n-        allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &&\n-                Feature.SWITCH_EXPRESSION.allowedInSource(source);\n+        allowYieldStatement = Feature.SWITCH_EXPRESSION.allowedInSource(source);\n@@ -1513,1 +1512,0 @@\n-            if (isStatic(env1)) staticOnly = true;\n@@ -1517,0 +1515,3 @@\n+                    if (staticOnly) {\n+                        return new StaticError(sym);\n+                    }\n@@ -1520,0 +1521,1 @@\n+            if (isStatic(env1)) staticOnly = true;\n@@ -1525,12 +1527,3 @@\n-                   (sym.flags() & STATIC) == 0 &&\n-                    sym.kind == VAR &&\n-                        \/\/ if it is a field\n-                        (sym.owner.kind == TYP ||\n-                        \/\/ or it is a local variable but it is not declared inside of the static local type\n-                        \/\/ then error\n-                        allowRecords &&\n-                        (sym.owner.kind == MTH) &&\n-                        env1 != env &&\n-                        !isInnerClassOfMethod(sym.owner, env.tree.hasTag(CLASSDEF) ?\n-                                ((JCClassDecl)env.tree).sym :\n-                                env.enclClass.sym)))\n+                        sym.kind == VAR &&\n+                        sym.owner.kind == TYP &&\n+                        (sym.flags() & STATIC) == 0)\n@@ -2354,2 +2347,2 @@\n-    Symbol findTypeVar(Env<AttrContext> currentEnv, Env<AttrContext> originalEnv, Name name, boolean staticOnly) {\n-        for (Symbol sym : currentEnv.info.scope.getSymbolsByName(name)) {\n+    Symbol findTypeVar(Env<AttrContext> env, Name name, boolean staticOnly) {\n+        for (Symbol sym : env.info.scope.getSymbolsByName(name)) {\n@@ -2357,10 +2350,6 @@\n-                if (staticOnly &&\n-                    sym.type.hasTag(TYPEVAR) &&\n-                    ((sym.owner.kind == TYP) ||\n-                    \/\/ are we trying to access a TypeVar defined in a method from a local static type: interface, enum or record?\n-                    allowRecords &&\n-                    (sym.owner.kind == MTH &&\n-                    currentEnv != originalEnv &&\n-                    !isInnerClassOfMethod(sym.owner, originalEnv.tree.hasTag(CLASSDEF) ?\n-                            ((JCClassDecl)originalEnv.tree).sym :\n-                            originalEnv.enclClass.sym)))) {\n+                if (sym.type.hasTag(TYPEVAR) &&\n+                        (staticOnly || (isStatic(env) && sym.owner.kind == TYP)))\n+                    \/\/ if staticOnly is set, it means that we have recursed through a static declaration,\n+                    \/\/ so type variable symbols should not be accessible. If staticOnly is unset, but\n+                    \/\/ we are in a static declaration (field or method), we should not allow type-variables\n+                    \/\/ defined in the enclosing class to \"leak\" into this context.\n@@ -2368,1 +2357,0 @@\n-                }\n@@ -2375,8 +2363,0 @@\n-    boolean isInnerClassOfMethod(Symbol msym, Symbol csym) {\n-        while (csym.owner != msym) {\n-            if (csym.isStatic()) return false;\n-            csym = csym.owner.enclClass();\n-        }\n-        return (csym.owner == msym && !csym.isStatic());\n-    }\n-\n@@ -2402,2 +2382,2 @@\n-            if (isStatic(env1)) staticOnly = true;\n-            final Symbol tyvar = findTypeVar(env1, env, name, staticOnly);\n+            final Symbol tyvar = findTypeVar(env1, name, staticOnly);\n+            if (isStatic(env1)) staticOnly = true;\n@@ -3486,1 +3466,1 @@\n-                !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS;\n+                 !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS || sym.kind == STATICERR;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":19,"deletions":39,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.*;\n@@ -34,3 +33,0 @@\n-import com.sun.tools.javac.code.Type.IntersectionClassType;\n-import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;\n-import com.sun.tools.javac.resources.CompilerProperties.Errors;\n@@ -572,1 +568,1 @@\n-        tree.pats = translate(tree.pats, null);\n+        tree.labels = translate(tree.labels, null);\n@@ -593,0 +589,13 @@\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+        tree.pattern = translate(tree.pattern, null);\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern tree) {\n+        tree.patt = translate(tree.patt, null);\n+        tree.expr = translate(tree.expr, syms.booleanType);\n+        result = tree;\n+    }\n+\n@@ -777,1 +786,1 @@\n-            tree.expr = typeCast != null && types.isSameType(typeCast.type, originalTarget)\n+            tree.expr = typeCast != null && types.isSameType(typeCast.type, tree.type)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-            sr.mergeWith(csp(tree.pats));\n+            sr.mergeWith(csp(tree.labels));\n@@ -336,0 +336,5 @@\n+        @Override\n+        public void visitDefaultCaseLabel(JCTree.JCDefaultCaseLabel that) {\n+            result = null;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,2 @@\n-        V61(61, 0);   \/\/ JDK 17\n+        V61(61, 0),   \/\/ JDK 17\n+        V62(62, 0);   \/\/ JDK 18\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -204,0 +204,5 @@\n+    \/**\n+     * A table to hold the access flags of the method parameters.\n+     *\/\n+    int[] parameterAccessFlags;\n+\n@@ -284,2 +289,1 @@\n-        allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &&\n-                Feature.SEALED_CLASSES.allowedInSource(source);\n+        allowSealedTypes = Feature.SEALED_CLASSES.allowedInSource(source);\n@@ -603,1 +607,1 @@\n-                                tsym.complete();\n+                                tsym.apiComplete();\n@@ -1121,0 +1125,1 @@\n+                        parameterAccessFlags = new int[numEntries];\n@@ -1129,1 +1134,3 @@\n-                            parameterNameIndices[index++] = nameIndex;\n+                            parameterNameIndices[index] = nameIndex;\n+                            parameterAccessFlags[index] = flags;\n+                            index++;\n@@ -2449,0 +2456,1 @@\n+        parameterAccessFlags = null;\n@@ -2458,0 +2466,4 @@\n+        if (parameterAccessFlags != null && index < parameterAccessFlags.length\n+                && parameterAccessFlags[index] != 0) {\n+            flags |= parameterAccessFlags[index];\n+        }\n@@ -2626,1 +2638,5 @@\n-\n+        if (c.isRecord()) {\n+            for (RecordComponent rc: c.getRecordComponents()) {\n+                rc.accessor = lookupMethod(c, rc.name, List.nil());\n+            }\n+        }\n@@ -2630,0 +2646,9 @@\n+    private MethodSymbol lookupMethod(TypeSymbol tsym, Name name, List<Type> argtypes) {\n+        for (Symbol s : tsym.members().getSymbolsByName(name, s -> s.kind == MTH)) {\n+            if (types.isSameTypes(s.type.getParameterTypes(), argtypes)) {\n+                return (MethodSymbol) s;\n+            }\n+        }\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.code.Source.Feature;\n@@ -1820,0 +1821,4 @@\n+        \/\/ Elide strictfp bit in class files\n+        if (target.obsoleteAccStrict())\n+            result &= ~STRICTFP;\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1245,1 +1245,1 @@\n-        handleSwitch(tree, tree.selector, tree.cases);\n+        handleSwitch(tree, tree.selector, tree.cases, tree.patternSwitch);\n@@ -1290,1 +1290,1 @@\n-                handleSwitch(tree, tree.selector, tree.cases);\n+                handleSwitch(tree, tree.selector, tree.cases, tree.patternSwitch);\n@@ -1320,1 +1320,2 @@\n-    private void handleSwitch(JCTree swtch, JCExpression selector, List<JCCase> cases) {\n+    private void handleSwitch(JCTree swtch, JCExpression selector, List<JCCase> cases,\n+                              boolean patternSwitch) {\n@@ -1323,0 +1324,1 @@\n+        int switchStart = patternSwitch ? code.entryPoint() : -1;\n@@ -1352,3 +1354,3 @@\n-                if (l.head.pats.nonEmpty()) {\n-                    Assert.check(l.head.pats.size() == 1);\n-                    int val = ((Number)l.head.pats.head.type.constValue()).intValue();\n+                if (l.head.labels.head.isExpression()) {\n+                    Assert.check(l.head.labels.size() == 1);\n+                    int val = ((Number)((JCExpression) l.head.labels.head).type.constValue()).intValue();\n@@ -1426,0 +1428,6 @@\n+            if (switchEnv.info.cont != null) {\n+                Assert.check(patternSwitch);\n+                code.resolve(switchEnv.info.cont);\n+                code.resolve(code.branch(goto_), switchStart);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -67,6 +67,8 @@\n-\n-\/** The parser maps a token sequence into an abstract syntax\n- *  tree. It operates by recursive descent, with code derived\n- *  systematically from an LL(1) grammar. For efficiency reasons, an\n- *  operator precedence scheme is used for parsing binary operation\n- *  expressions.\n+import java.util.function.BiFunction;\n+\n+\/**\n+ * The parser maps a token sequence into an abstract syntax tree.\n+ * The parser is a hand-written recursive-descent parser that\n+ * implements the grammar described in the Java Language Specification.\n+ * For efficiency reasons, an operator precedence scheme is used\n+ * for parsing binary operation expressions.\n@@ -189,2 +191,0 @@\n-        this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &&\n-                Feature.SWITCH_EXPRESSION.allowedInSource(source);\n@@ -192,0 +192,1 @@\n+        this.allowYieldStatement = Feature.SWITCH_EXPRESSION.allowedInSource(source);\n@@ -193,2 +194,1 @@\n-        this.allowSealedTypes = (!preview.isPreview(Feature.SEALED_CLASSES) || preview.isEnabled()) &&\n-                Feature.SEALED_CLASSES.allowedInSource(source);\n+        this.allowSealedTypes = Feature.SEALED_CLASSES.allowedInSource(source);\n@@ -328,2 +328,2 @@\n-        for (; lookahead < kinds.length ; lookahead++) {\n-            if (!kinds[lookahead].test(S.token(lookahead + 1).kind)) {\n+        for (Predicate<TokenKind> kind : kinds) {\n+            if (!kind.test(S.token(++lookahead).kind)) {\n@@ -793,0 +793,27 @@\n+\n+    \/** parses patterns.\n+     *\/\n+\n+    public JCPattern parsePattern(int pos, JCModifiers mods, JCExpression parsedType, boolean inInstanceOf) {\n+        if (token.kind == LPAREN && parsedType == null) {\n+            int startPos = token.pos;\n+            accept(LPAREN);\n+            JCPattern p = parsePattern(token.pos, null, null, false);\n+            accept(RPAREN);\n+            return toP(F.at(startPos).ParenthesizedPattern(p));\n+        } else {\n+            JCPattern pattern;\n+            JCExpression e = parsedType == null ? term(EXPR | TYPE | NOLAMBDA) : parsedType;\n+            mods = mods != null ? mods : F.at(token.pos).Modifiers(0);\n+            JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), e, null));\n+            pattern = toP(F.at(pos).BindingPattern(var));\n+            if (!inInstanceOf && token.kind == AMPAMP) {\n+                checkSourceLevel(Feature.PATTERN_SWITCH);\n+                nextToken();\n+                JCExpression guard = term(EXPR | NOLAMBDA);\n+                pattern = F.at(pos).GuardPattern(pattern, guard);\n+            }\n+            return pattern;\n+        }\n+    }\n+\n@@ -971,8 +998,3 @@\n-                int patternPos = token.pos;\n-                JCModifiers mods = optFinal(0);\n-                int typePos = token.pos;\n-                JCExpression type = unannotatedType(false);\n-                if (token.kind == IDENTIFIER) {\n-                    checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);\n-                    JCVariableDecl var = toP(F.at(token.pos).VarDef(mods, ident(), type, null));\n-                    pattern = toP(F.at(patternPos).BindingPattern(var));\n+                if (token.kind == LPAREN) {\n+                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+                    pattern = parsePattern(token.pos, null, null, true);\n@@ -981,13 +1003,23 @@\n-                    checkNoMods(typePos, mods.flags & ~Flags.DEPRECATED);\n-                    if (mods.annotations.nonEmpty()) {\n-                        checkSourceLevel(mods.annotations.head.pos, Feature.TYPE_ANNOTATIONS);\n-                        List<JCAnnotation> typeAnnos =\n-                                mods.annotations\n-                                    .map(decl -> {\n-                                        JCAnnotation typeAnno = F.at(decl.pos)\n-                                                                 .TypeAnnotation(decl.annotationType,\n-                                                                                  decl.args);\n-                                        endPosTable.replaceTree(decl, typeAnno);\n-                                        return typeAnno;\n-                                    });\n-                        type = insertAnnotationsToMostInner(type, typeAnnos, false);\n+                    int patternPos = token.pos;\n+                    JCModifiers mods = optFinal(0);\n+                    int typePos = token.pos;\n+                    JCExpression type = unannotatedType(false);\n+                    if (token.kind == IDENTIFIER) {\n+                        checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);\n+                        pattern = parsePattern(patternPos, mods, type, true);\n+                    } else {\n+                        checkNoMods(typePos, mods.flags & ~Flags.DEPRECATED);\n+                        if (mods.annotations.nonEmpty()) {\n+                            checkSourceLevel(mods.annotations.head.pos, Feature.TYPE_ANNOTATIONS);\n+                            List<JCAnnotation> typeAnnos =\n+                                    mods.annotations\n+                                        .map(decl -> {\n+                                            JCAnnotation typeAnno = F.at(decl.pos)\n+                                                                     .TypeAnnotation(decl.annotationType,\n+                                                                                      decl.args);\n+                                            endPosTable.replaceTree(decl, typeAnno);\n+                                            return typeAnno;\n+                                        });\n+                            type = insertAnnotationsToMostInner(type, typeAnnos, false);\n+                        }\n+                        pattern = type;\n@@ -995,1 +1027,0 @@\n-                    pattern = type;\n@@ -1524,1 +1555,1 @@\n-        ListBuffer<JCExpression> pats = new ListBuffer<>();\n+        ListBuffer<JCCaseLabel> pats = new ListBuffer<>();\n@@ -1528,0 +1559,1 @@\n+            pats.append(toP(F.at(casePos).DefaultCaseLabel()));\n@@ -1531,1 +1563,2 @@\n-                pats.append(term(EXPR | NOLAMBDA));\n+                JCCaseLabel label = parseCaseLabel();\n+                pats.append(label);\n@@ -2493,1 +2526,1 @@\n-                if (token.kind == RBRACKET) {\n+                if (token.kind == RBRACKET) { \/\/ no dimension\n@@ -2496,7 +2529,3 @@\n-                    if (token.kind == RBRACKET) { \/\/ no dimension\n-                        elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);\n-                    } else {\n-                        dimAnnotations.append(maybeDimAnnos);\n-                        dims.append(parseExpression());\n-                        accept(RBRACKET);\n-                    }\n+                    dimAnnotations.append(maybeDimAnnos);\n+                    dims.append(parseExpression());\n+                    accept(RBRACKET);\n@@ -3051,1 +3080,1 @@\n-            ListBuffer<JCExpression> pats = new ListBuffer<>();\n+            ListBuffer<JCCaseLabel> pats = new ListBuffer<>();\n@@ -3053,1 +3082,1 @@\n-                pats.append(term(EXPR | NOLAMBDA));\n+                pats.append(parseCaseLabel());\n@@ -3084,0 +3113,1 @@\n+            int patternPos = token.pos;\n@@ -3099,1 +3129,2 @@\n-            c = F.at(pos).Case(caseKind, List.nil(), stats, body);\n+            JCCaseLabel defaultPattern = toP(F.at(patternPos).DefaultCaseLabel());\n+            c = F.at(pos).Case(caseKind, List.of(defaultPattern), stats, body);\n@@ -3108,0 +3139,40 @@\n+    private JCCaseLabel parseCaseLabel() {\n+        int patternPos = token.pos;\n+        JCCaseLabel label;\n+\n+        if (token.kind == DEFAULT) {\n+            checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+            nextToken();\n+            label = toP(F.at(patternPos).DefaultCaseLabel());\n+        } else {\n+            if (token.kind == LPAREN) {\n+                int lookahead = 0;\n+                Token ahead;\n+                while ((ahead = S.token(lookahead)).kind != EOF && ahead.kind != RPAREN && ahead.kind != AMPAMP) {\n+                    lookahead++;\n+                }\n+                Token twoBack;\n+                boolean pattern = S.token(lookahead - 1).kind == IDENTIFIER &&\n+                                  ((twoBack = S.token(lookahead - 2)).kind == IDENTIFIER ||\n+                                   twoBack.kind == GT || twoBack.kind == GTGT || twoBack.kind == GTGTGT);\n+                if (pattern) {\n+                    return parsePattern(token.pos, null, null, false);\n+                } else {\n+                    return term(EXPR | TYPE | NOLAMBDA);\n+                }\n+            } else {\n+                JCModifiers mods = optFinal(0);\n+                JCExpression e = term(EXPR | TYPE | NOLAMBDA);\n+\n+                if (token.kind == IDENTIFIER || mods.flags != 0 || mods.annotations.nonEmpty()) {\n+                    checkSourceLevel(token.pos, Feature.PATTERN_SWITCH);\n+                    return parsePattern(patternPos, null, e, false);\n+                } else {\n+                    return e;\n+                }\n+            }\n+        }\n+\n+        return label;\n+    }\n+\n@@ -3431,0 +3502,1 @@\n+        boolean declaredUsingVar = false;\n@@ -3449,0 +3521,1 @@\n+                    declaredUsingVar = true;\n@@ -3461,1 +3534,1 @@\n-            toP(F.at(pos).VarDef(mods, name, type, init));\n+            toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n@@ -3609,1 +3682,2 @@\n-        return toP(F.at(pos).VarDef(mods, name, type, null));\n+        return toP(F.at(pos).VarDef(mods, name, type, null,\n+                type != null && type.hasTag(IDENT) && ((JCIdent)type).name == names.var));\n@@ -4693,0 +4767,1 @@\n+            origEndPos = getEndPos(mostInnerType);\n@@ -4954,2 +5029,1 @@\n-            endPosMap.putAtIndex(tree, errorEndPos > endpos ? errorEndPos : endpos,\n-                                 endPosMap.lookup(tree));\n+            endPosMap.put(tree, errorEndPos > endpos ? errorEndPos : endpos);\n@@ -4969,1 +5043,1 @@\n-            int value = endPosMap.getFromIndex(endPosMap.lookup(tree));\n+            int value = endPosMap.get(tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":126,"deletions":52,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -975,1 +975,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -354,0 +354,3 @@\n+compiler.misc.guard=\\\n+    a guard\n+\n@@ -497,0 +500,3 @@\n+compiler.err.pattern.dominated=\\\n+    this case label is dominated by a preceding case label\n+\n@@ -500,0 +506,16 @@\n+compiler.err.duplicate.total.pattern=\\\n+    duplicate total pattern\n+\n+compiler.err.total.pattern.and.default=\\\n+    switch has both a total pattern and a default label\n+\n+# 0: type, 1: type\n+compiler.err.constant.label.not.compatible=\\\n+    constant label of type {0} is not compatible with switch selector type {1}\n+\n+compiler.err.flows.through.to.pattern=\\\n+    illegal fall-through to a pattern\n+\n+compiler.err.flows.through.from.pattern=\\\n+    illegal fall-through from a pattern\n+\n@@ -567,1 +589,1 @@\n-    floating point number too large\n+    floating-point number too large\n@@ -570,1 +592,1 @@\n-    floating point number too small\n+    floating-point number too small\n@@ -788,1 +810,1 @@\n-    malformed floating point literal\n+    malformed floating-point literal\n@@ -1360,0 +1382,3 @@\n+compiler.err.not.exhaustive.statement=\\\n+    the switch statement does not cover all possible input values\n+\n@@ -1767,0 +1792,3 @@\n+compiler.warn.strictfp=\\\n+    as of release 17, all floating-point expressions are evaluated strictly and ''strictfp'' is not required\n+\n@@ -2201,3 +2229,0 @@\n-compiler.err.expected.module=\\\n-    ''module'' expected\n-\n@@ -2964,0 +2989,6 @@\n+compiler.misc.feature.case.null=\\\n+    null in switch cases\n+\n+compiler.misc.feature.pattern.switch=\\\n+    patterns in switch statements\n+\n@@ -3221,1 +3252,1 @@\n-    '')'' missing in reference\n+    unexpected text after parenthesis\n@@ -3485,3 +3516,0 @@\n-compiler.err.switch.null.not.allowed=\\\n-    null label in case is not allowed\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,1 +175,1 @@\n-    Supported keys are:\n+    Use --help-lint to see the supported keys.\n@@ -247,1 +247,1 @@\n-\\                             Also warn about access to non-public members from a serializable element.\n+\\                         Also warn about access to non-public members from a serializable element.\n@@ -252,0 +252,3 @@\n+javac.opt.Xlint.desc.strictfp=\\\n+    Warn about unnecessary use of the strictfp modifier.\n+\n@@ -298,0 +301,4 @@\n+javac.opt.help.lint=\\\n+    Print the supported keys for -Xlint\n+javac.opt.help.lint.header=\\\n+    The supported keys for -Xlint are:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -247,0 +247,3 @@\n+        DEFAULTCASELABEL,\n+        GUARDPATTERN,\n+        PARENTHESIZEDPATTERN,\n@@ -710,1 +713,9 @@\n-    public static abstract class JCExpression extends JCTree implements ExpressionTree {\n+    public static abstract class JCCaseLabel extends JCTree implements CaseLabelTree {\n+        public abstract boolean isExpression();\n+        public boolean isNullPattern() {\n+            return isExpression() && TreeInfo.isNull((JCExpression) this);\n+        }\n+        public abstract boolean isPattern();\n+    }\n+\n+    public static abstract class JCExpression extends JCCaseLabel implements ExpressionTree {\n@@ -723,0 +734,10 @@\n+\n+        @Override\n+        public boolean isExpression() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean isPattern() {\n+            return false;\n+        }\n@@ -807,1 +828,0 @@\n-        @SuppressWarnings(\"preview\")\n@@ -970,0 +990,2 @@\n+        \/** declared using `var` *\/\n+        private boolean declaredUsingVar;\n@@ -976,0 +998,9 @@\n+            this(mods, name, vartype, init, sym, false);\n+        }\n+\n+        protected JCVariableDecl(JCModifiers mods,\n+                                 Name name,\n+                                 JCExpression vartype,\n+                                 JCExpression init,\n+                                 VarSymbol sym,\n+                                 boolean declaredUsingVar) {\n@@ -981,0 +1012,1 @@\n+            this.declaredUsingVar = declaredUsingVar;\n@@ -986,1 +1018,1 @@\n-            this(mods, null, vartype, null, null);\n+            this(mods, null, vartype, null, null, false);\n@@ -1000,0 +1032,4 @@\n+        public boolean declaredUsingVar() {\n+            return declaredUsingVar;\n+        }\n+\n@@ -1291,0 +1327,2 @@\n+        public boolean hasTotalPattern;\n+        public boolean patternSwitch;\n@@ -1323,1 +1361,1 @@\n-        public List<JCExpression> pats;\n+        public List<JCCaseLabel> labels;\n@@ -1327,1 +1365,1 @@\n-        protected JCCase(CaseKind caseKind, List<JCExpression> pats,\n+        protected JCCase(CaseKind caseKind, List<JCCaseLabel> labels,\n@@ -1329,2 +1367,2 @@\n-            Assert.checkNonNull(pats);\n-            Assert.check(pats.isEmpty() || pats.head != null);\n+            Assert.checkNonNull(labels);\n+            Assert.check(labels.isEmpty() || labels.head != null);\n@@ -1332,1 +1370,1 @@\n-            this.pats = pats;\n+            this.labels = labels;\n@@ -1342,1 +1380,3 @@\n-        public JCExpression getExpression() { return pats.head; }\n+        public JCExpression getExpression() { return getExpressions().head; }\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public List<JCExpression> getExpressions() { return labels.stream().filter(p -> p instanceof JCExpression).map(p -> (JCExpression) p).collect(List.collector()); }\n@@ -1344,1 +1384,1 @@\n-        public List<JCExpression> getExpressions() { return pats; }\n+        public List<JCCaseLabel> getLabels() { return labels; }\n@@ -1399,0 +1439,2 @@\n+        public boolean hasTotalPattern;\n+        public boolean patternSwitch;\n@@ -2265,1 +2307,1 @@\n-    public static abstract class JCPattern extends JCTree\n+    public static abstract class JCPattern extends JCCaseLabel\n@@ -2267,0 +2309,10 @@\n+\n+        @Override\n+        public boolean isExpression() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isPattern() {\n+            return true;\n+        }\n@@ -2304,0 +2356,115 @@\n+    public static class JCDefaultCaseLabel extends JCCaseLabel\n+            implements DefaultCaseLabelTree {\n+\n+        protected JCDefaultCaseLabel() {\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitDefaultCaseLabel(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.DEFAULT_CASE_LABEL;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitDefaultCaseLabel(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return DEFAULTCASELABEL;\n+        }\n+\n+        @Override\n+        public boolean isExpression() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isPattern() {\n+            return false;\n+        }\n+    }\n+\n+    public static class JCParenthesizedPattern extends JCPattern\n+            implements ParenthesizedPatternTree {\n+        public JCPattern pattern;\n+\n+        public JCParenthesizedPattern(JCPattern pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public PatternTree getPattern() {\n+            return pattern;\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitParenthesizedPattern(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.PARENTHESIZED_PATTERN;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitParenthesizedPattern(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return PARENTHESIZEDPATTERN;\n+        }\n+    }\n+\n+    public static class JCGuardPattern extends JCPattern\n+            implements GuardedPatternTree {\n+        public JCPattern patt;\n+        public JCExpression expr;\n+\n+        public JCGuardPattern(JCPattern patt, JCExpression expr) {\n+            this.patt = patt;\n+            this.expr = expr;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public PatternTree getPattern() {\n+            return patt;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public ExpressionTree getExpression() {\n+            return expr;\n+        }\n+\n+        @Override\n+        public void accept(Visitor v) {\n+            v.visitGuardPattern(this);\n+        }\n+\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.GUARDED_PATTERN;\n+        }\n+\n+        @Override\n+        @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitGuardedPattern(this, d);\n+        }\n+\n+        @Override\n+        public Tag getTag() {\n+            return Tag.GUARDPATTERN;\n+        }\n+    }\n+\n@@ -3240,1 +3407,1 @@\n-        JCCase Case(CaseTree.CaseKind caseKind, List<JCExpression> pat,\n+        JCCase Case(CaseTree.CaseKind caseKind, List<JCCaseLabel> labels,\n@@ -3347,0 +3514,3 @@\n+        public void visitDefaultCaseLabel(JCDefaultCaseLabel that) { visitTree(that); }\n+        public void visitParenthesizedPattern(JCParenthesizedPattern that) { visitTree(that); }\n+        public void visitGuardPattern(JCGuardPattern that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":182,"deletions":12,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -876,1 +876,1 @@\n-            if (tree.pats.isEmpty()) {\n+            if (tree.labels.size() == 1 && tree.labels.get(0).hasTag(DEFAULTCASELABEL)) {\n@@ -880,1 +880,1 @@\n-                printExprs(tree.pats);\n+                printExprs(tree.labels);\n@@ -891,1 +891,5 @@\n-                printStat(tree.stats.head);\n+                if (tree.stats.size() == 1) {\n+                    printStat(tree.stats.head);\n+                } else {\n+                    printBlock(tree.stats);\n+                }\n@@ -898,0 +902,9 @@\n+    @Override\n+    public void visitDefaultCaseLabel(JCTree.JCDefaultCaseLabel that) {\n+        try {\n+            print(\"default\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n@@ -923,0 +936,22 @@\n+        }\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern patt) {\n+        try {\n+            print(\"(\");\n+            printExpr(patt.pattern);\n+            print(\")\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern patt) {\n+        try {\n+            printExpr(patt.patt);\n+            print(\" && \");\n+            printExpr(patt.expr);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-        List<JCExpression> pats = copy(t.pats, p);\n+        List<JCCaseLabel> labels = copy(t.labels, p);\n@@ -164,1 +164,1 @@\n-        return M.at(t.pos).Case(t.caseKind, pats, stats, body);\n+        return M.at(t.pos).Case(t.caseKind, labels, stats, body);\n@@ -509,0 +509,21 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitGuardedPattern(GuardedPatternTree node, P p) {\n+        JCGuardPattern t = (JCGuardPattern) node;\n+        JCPattern patt = copy(t.patt, p);\n+        JCExpression expr = copy(t.expr, p);\n+        return M.at(t.pos).GuardPattern(patt, expr);\n+    }\n+\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitParenthesizedPattern(ParenthesizedPatternTree node, P p) {\n+        JCParenthesizedPattern t = (JCParenthesizedPattern) node;\n+        JCPattern pattern = copy(t.pattern, p);\n+        return M.at(t.pos).ParenthesizedPattern(pattern);\n+    }\n+\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitDefaultCaseLabel(DefaultCaseLabelTree node, P p) {\n+        JCDefaultCaseLabel t = (JCDefaultCaseLabel) node;\n+        return M.at(t.pos).DefaultCaseLabel();\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import static com.sun.tools.javac.code.TypeTag.BOOLEAN;\n@@ -549,0 +550,4 @@\n+            case GUARDPATTERN: {\n+                JCGuardPattern node = (JCGuardPattern) tree;\n+                return getStartPos(node.patt);\n+            }\n@@ -640,0 +645,8 @@\n+            case PARENTHESIZEDPATTERN: {\n+                JCParenthesizedPattern node = (JCParenthesizedPattern) tree;\n+                return getEndPos(node.pattern, endPosTable);\n+            }\n+            case GUARDPATTERN: {\n+                JCGuardPattern node = (JCGuardPattern) tree;\n+                return getEndPos(node.expr, endPosTable);\n+            }\n@@ -1339,1 +1352,1 @@\n-               cases.stream().flatMap(c -> c.pats.stream())\n+               cases.stream().flatMap(c -> c.labels.stream())\n@@ -1342,0 +1355,24 @@\n+\n+    public static PatternPrimaryType primaryPatternType(JCPattern pat) {\n+        return switch (pat.getTag()) {\n+            case BINDINGPATTERN -> new PatternPrimaryType(((JCBindingPattern) pat).type, true);\n+            case GUARDPATTERN -> {\n+                JCGuardPattern guarded = (JCGuardPattern) pat;\n+                PatternPrimaryType nested = primaryPatternType(guarded.patt);\n+                boolean unconditional = nested.unconditional();\n+                if (guarded.expr.type.hasTag(BOOLEAN) && unconditional) {\n+                    unconditional = false;\n+                    var constValue = guarded.expr.type.constValue();\n+                    if (constValue != null && ((int) constValue) == 1) {\n+                        unconditional = true;\n+                    }\n+                }\n+                yield new PatternPrimaryType(nested.type(), unconditional);\n+            }\n+            case PARENTHESIZEDPATTERN -> primaryPatternType(((JCParenthesizedPattern) pat).pattern);\n+            default -> throw new AssertionError();\n+        };\n+    }\n+\n+    public record PatternPrimaryType(Type type, boolean unconditional) {}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -230,0 +230,6 @@\n+    public JCVariableDecl VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init, boolean declaredUsingVar) {\n+        JCVariableDecl tree = new JCVariableDecl(mods, name, vartype, init, null, declaredUsingVar);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n@@ -294,1 +300,1 @@\n-    public JCCase Case(CaseTree.CaseKind caseKind, List<JCExpression> pats,\n+    public JCCase Case(CaseTree.CaseKind caseKind, List<JCCaseLabel> labels,\n@@ -296,1 +302,1 @@\n-        JCCase tree = new JCCase(caseKind, pats, stats, body);\n+        JCCase tree = new JCCase(caseKind, labels, stats, body);\n@@ -497,0 +503,18 @@\n+    public JCDefaultCaseLabel DefaultCaseLabel() {\n+        JCDefaultCaseLabel tree = new JCDefaultCaseLabel();\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n+    public JCParenthesizedPattern ParenthesizedPattern(JCPattern pattern) {\n+        JCParenthesizedPattern tree = new JCParenthesizedPattern(pattern);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n+    public JCGuardPattern GuardPattern(JCPattern guardedPattern, JCExpression expr) {\n+        JCGuardPattern tree = new JCGuardPattern(guardedPattern, expr);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-        scan(tree.pats);\n+        scan(tree.labels);\n@@ -319,0 +319,15 @@\n+    @Override\n+    public void visitDefaultCaseLabel(JCDefaultCaseLabel tree) {\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern that) {\n+        scan(that.pattern);\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern that) {\n+        scan(that.patt);\n+        scan(that.expr);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-        tree.pats = translate(tree.pats);\n+        tree.labels = translate(tree.labels);\n@@ -372,0 +372,18 @@\n+    @Override\n+    public void visitDefaultCaseLabel(JCDefaultCaseLabel tree) {\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitParenthesizedPattern(JCParenthesizedPattern tree) {\n+        tree.pattern = translate(tree.pattern);\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitGuardPattern(JCGuardPattern tree) {\n+        tree.patt = translate(tree.patt);\n+        tree.expr = translate(tree.expr);\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -452,8 +452,0 @@\n-    @Override\n-    public ResolvedJavaType getHostClass() {\n-        if (isArray()) {\n-            return null;\n-        }\n-        return compilerToVM().getHostClass(this);\n-    }\n-\n@@ -1044,5 +1036,0 @@\n-    @Override\n-    public boolean isUnsafeAnonymous() {\n-        return (getMiscFlags() & config().instanceKlassMiscIsUnsafeAnonymous) != 0;\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-    final int instanceKlassMiscIsUnsafeAnonymous = getConstant(\"InstanceKlass::_misc_is_unsafe_anonymous\", Integer.class);\n@@ -368,0 +367,2 @@\n+    final int codeInstallResultNMethodReclaimed = getConstant(\"JVMCI::nmethod_reclaimed\", Integer.class);\n+    final int codeInstallResultFirstPermanentBailout = getConstant(\"JVMCI::first_permanent_bailout\", Integer.class);\n@@ -382,0 +383,3 @@\n+        if (codeInstallResult == codeInstallResultNMethodReclaimed) {\n+            return \"nmethod reclaimed\";\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.Arrays;\n@@ -84,1 +83,0 @@\n-import javax.lang.model.util.ElementKindVisitor14;\n@@ -96,0 +94,1 @@\n+import com.sun.source.doctree.BlockTagTree;\n@@ -129,1 +128,0 @@\n-import static javax.lang.model.element.Modifier.*;\n@@ -236,3 +234,4 @@\n-     * @param  te        Class to search into.\n-     * @param  method    Method to be searched.\n-     * @return ExecutableElement Method found, null otherwise.\n+     * @param te     Class to search into.\n+     * @param method Method to be searched.\n+     *\n+     * @return Method found, null otherwise.\n@@ -241,3 +240,3 @@\n-        for (Element m : getMethods(te)) {\n-            if (executableMembersEqual(method, (ExecutableElement) m)) {\n-                return (ExecutableElement) m;\n+        for (ExecutableElement m : getMethods(te)) {\n+            if (executableMembersEqual(method, m)) {\n+                return m;\n@@ -335,1 +334,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -455,1 +453,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -460,1 +457,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -495,100 +491,0 @@\n-    @SuppressWarnings(\"preview\")\n-    public String modifiersToString(Element e, boolean trailingSpace) {\n-        SortedSet<Modifier> modifiers = new TreeSet<>(e.getModifiers());\n-        modifiers.remove(NATIVE);\n-        modifiers.remove(STRICTFP);\n-        modifiers.remove(SYNCHRONIZED);\n-\n-        return new ElementKindVisitor14<String, SortedSet<Modifier>>() {\n-            final StringBuilder sb = new StringBuilder();\n-\n-            void addVisibilityModifier(Set<Modifier> modifiers) {\n-                if (modifiers.contains(PUBLIC)) {\n-                    append(\"public\");\n-                } else if (modifiers.contains(PROTECTED)) {\n-                    append(\"protected\");\n-                } else if (modifiers.contains(PRIVATE)) {\n-                    append(\"private\");\n-                }\n-            }\n-\n-            void addStatic(Set<Modifier> modifiers) {\n-                if (modifiers.contains(STATIC)) {\n-                    append(\"static\");\n-                }\n-            }\n-\n-            void addSealed(TypeElement e) {\n-                if (e.getModifiers().contains(Modifier.SEALED)) {\n-                    append(\"sealed\");\n-                } else if (e.getModifiers().contains(Modifier.NON_SEALED)) {\n-                    append(\"non-sealed\");\n-                }\n-            }\n-\n-            void addModifiers(Set<Modifier> modifiers) {\n-                modifiers.stream()\n-                        .map(Modifier::toString)\n-                        .forEachOrdered(this::append);\n-            }\n-\n-            void append(String s) {\n-                if (sb.length() > 0) {\n-                    sb.append(\" \");\n-                }\n-                sb.append(s);\n-            }\n-\n-            String finalString(String s) {\n-                append(s);\n-                if (trailingSpace) {\n-                    sb.append(\" \");\n-                }\n-                return sb.toString();\n-            }\n-\n-            @Override\n-            public String visitTypeAsInterface(TypeElement e, SortedSet<Modifier> mods) {\n-                addVisibilityModifier(mods);\n-                addStatic(mods);\n-                addSealed(e);\n-                return finalString(\"interface\");\n-            }\n-\n-            @Override\n-            public String visitTypeAsEnum(TypeElement e, SortedSet<Modifier> mods) {\n-                addVisibilityModifier(mods);\n-                addStatic(mods);\n-                return finalString(\"enum\");\n-            }\n-\n-            @Override\n-            public String visitTypeAsAnnotationType(TypeElement e, SortedSet<Modifier> mods) {\n-                addVisibilityModifier(mods);\n-                addStatic(mods);\n-                return finalString(\"@interface\");\n-            }\n-\n-            @Override\n-            public String visitTypeAsRecord(TypeElement e, SortedSet<Modifier> mods) {\n-                mods.remove(FINAL); \/\/ suppress the implicit `final`\n-                return visitTypeAsClass(e, mods);\n-            }\n-\n-            @Override\n-            @SuppressWarnings(\"preview\")\n-            public String visitTypeAsClass(TypeElement e, SortedSet<Modifier> mods) {\n-                addModifiers(mods);\n-                String keyword = e.getKind() == ElementKind.RECORD ? \"record\" : \"class\";\n-                return finalString(keyword);\n-            }\n-\n-            @Override\n-            protected String defaultAction(Element e, SortedSet<Modifier> mods) {\n-                addModifiers(mods);\n-                return sb.toString().trim();\n-            }\n-\n-        }.visit(e, modifiers);\n-    }\n-\n@@ -606,1 +502,1 @@\n-        if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {\n+        if (isEnum(te) || isInterface(te) || isAnnotationType(te) || isRecord(te)) {\n@@ -710,1 +606,1 @@\n-     * @return String signature with simple (unqualified) parameter types\n+     * @return signature with simple (unqualified) parameter types\n@@ -1509,1 +1405,1 @@\n-     * Return true if the given Element is deprecated for removal.\n+     * Returns true if the given Element is deprecated for removal.\n@@ -1515,0 +1411,18 @@\n+        Object forRemoval = getDeprecatedElement(e, \"forRemoval\");\n+        return forRemoval != null && (boolean) forRemoval;\n+    }\n+\n+    \/**\n+     * Returns the value of the {@code Deprecated.since} element if it is set on the given Element.\n+     *\n+     * @param e the Element to check.\n+     * @return the Deprecated.since value for e, or null.\n+     *\/\n+    public String getDeprecatedSince(Element e) {\n+        return (String) getDeprecatedElement(e, \"since\");\n+    }\n+\n+    \/**\n+     * Returns the Deprecated annotation element value of the given element, or null.\n+     *\/\n+    private Object getDeprecatedElement(Element e, String elementName) {\n@@ -1522,2 +1436,2 @@\n-                        if (element.getSimpleName().contentEquals(\"forRemoval\")) {\n-                            return Boolean.parseBoolean((pairs.get(element)).toString());\n+                        if (element.getSimpleName().contentEquals(elementName)) {\n+                            return (pairs.get(element)).getValue();\n@@ -1529,1 +1443,1 @@\n-        return false;\n+        return null;\n@@ -1605,1 +1519,1 @@\n-            for (Element te : classlist) {\n+            for (TypeElement te : classlist) {\n@@ -1607,1 +1521,1 @@\n-                    filteredOutClasses.add((TypeElement)te);\n+                    filteredOutClasses.add(te);\n@@ -1612,1 +1526,1 @@\n-        for (Element e : classlist) {\n+        for (TypeElement e : classlist) {\n@@ -1616,1 +1530,1 @@\n-            filteredOutClasses.add((TypeElement)e);\n+            filteredOutClasses.add(e);\n@@ -1744,1 +1658,1 @@\n-            if (baseCollator instanceof RuleBasedCollator) {\n+            if (baseCollator instanceof RuleBasedCollator rbc) {\n@@ -1748,1 +1662,1 @@\n-                    return new RuleBasedCollator(((RuleBasedCollator) baseCollator).getRules()\n+                    return new RuleBasedCollator(rbc.getRules()\n@@ -1796,1 +1710,1 @@\n-     * if the entity is not qualifiable then its enclosing entity, it is upto\n+     * if the entity is not qualifiable then its enclosing entity, it is up to\n@@ -1805,1 +1719,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -1831,0 +1744,6 @@\n+    \/**\n+     * Returns the recursively enclosed documented type elements in a package\n+     *\n+     * @param pkg the package\n+     * @return the elements\n+     *\/\n@@ -1832,6 +1751,1 @@\n-        List<TypeElement> out = getInterfaces(pkg);\n-        out.addAll(getClasses(pkg));\n-        out.addAll(getEnums(pkg));\n-        out.addAll(getAnnotationTypes(pkg));\n-        out.addAll(getRecords(pkg));\n-        return out;\n+        return getItems(pkg, false, this::isTypeElement, TypeElement.class);\n@@ -1841,20 +1755,13 @@\n-    public List<Element> getAnnotationMembers(TypeElement aClass) {\n-        List<Element> members = getAnnotationFields(aClass);\n-        members.addAll(getAnnotationMethods(aClass));\n-        return members;\n-    }\n-    public List<Element> getAnnotationFields(TypeElement aClass) {\n-        return getItems0(aClass, true, FIELD);\n-    }\n-\n-    List<Element> getAnnotationFieldsUnfiltered(TypeElement aClass) {\n-        return getItems0(aClass, true, FIELD);\n-    }\n-\n-    public List<Element> getAnnotationMethods(TypeElement aClass) {\n-        return getItems0(aClass, true, METHOD);\n-    }\n-\n-    public List<TypeElement> getAnnotationTypes(Element e) {\n-        return convertToTypeElement(getItems(e, true, ANNOTATION_TYPE));\n-    }\n+    \/**\n+     * Returns the fields and methods declared in an annotation interface.\n+     *\n+     * @param te the annotation interface\n+     * @return the fields and methods\n+     *\/\n+    public List<Element> getAnnotationMembers(TypeElement te) {\n+        return getItems(te, false, e_ ->\n+                        switch (e_.getKind()) {\n+                            case FIELD, METHOD -> shouldDocument(e_);\n+                            default -> false;\n+                        },\n+                Element.class);\n@@ -1863,2 +1770,0 @@\n-    public List<TypeElement> getAnnotationTypesUnfiltered(Element e) {\n-        return convertToTypeElement(getItems(e, false, ANNOTATION_TYPE));\n@@ -1867,3 +1772,8 @@\n-    @SuppressWarnings(\"preview\")\n-    public List<TypeElement> getRecords(Element e) {\n-        return convertToTypeElement(getItems(e, true, RECORD));\n+    \/**\n+     * Returns the documented annotation interfaces in a package.\n+     *\n+     * @param pkg the package\n+     * @return the annotation interfaces\n+     *\/\n+    public List<TypeElement> getAnnotationTypes(PackageElement pkg) {\n+        return getDocumentedItems(pkg, ANNOTATION_TYPE, TypeElement.class);\n@@ -1872,3 +1782,8 @@\n-    @SuppressWarnings(\"preview\")\n-    public List<TypeElement> getRecordsUnfiltered(Element e) {\n-        return convertToTypeElement(getItems(e, false, RECORD));\n+    \/**\n+     * Returns the documented record classes in a package.\n+     *\n+     * @param pkg the package\n+     * @return the record classes\n+     *\/\n+    public List<TypeElement> getRecords(PackageElement pkg) {\n+        return getDocumentedItems(pkg, RECORD, TypeElement.class);\n@@ -1877,2 +1792,8 @@\n-    public List<VariableElement> getFields(Element e) {\n-        return convertToVariableElement(getItems(e, true, FIELD));\n+    \/**\n+     * Returns the documented fields in a type element.\n+     *\n+     * @param te the element\n+     * @return the fields\n+     *\/\n+    public List<VariableElement> getFields(TypeElement te) {\n+        return getDocumentedItems(te, FIELD, VariableElement.class);\n@@ -1881,2 +1802,8 @@\n-    public List<VariableElement> getFieldsUnfiltered(Element e) {\n-        return convertToVariableElement(getItems(e, false, FIELD));\n+    \/**\n+     * Returns the fields in a type element.\n+     *\n+     * @param te the element\n+     * @return the fields\n+     *\/\n+    public List<VariableElement> getFieldsUnfiltered(TypeElement te) {\n+        return getAllItems(te, FIELD, VariableElement.class);\n@@ -1885,0 +1812,7 @@\n+    \/**\n+     * Returns the documented classes in an element,\n+     * such as a package element or type element.\n+     *\n+     * @param e the element\n+     * @return the classes\n+     *\/\n@@ -1886,5 +1820,1 @@\n-       return convertToTypeElement(getItems(e, true, CLASS));\n-    }\n-\n-    public List<TypeElement> getClassesUnfiltered(Element e) {\n-       return convertToTypeElement(getItems(e, false, CLASS));\n+        return getDocumentedItems(e, CLASS, TypeElement.class);\n@@ -1893,2 +1823,8 @@\n-    public List<ExecutableElement> getConstructors(Element e) {\n-        return convertToExecutableElement(getItems(e, true, CONSTRUCTOR));\n+    \/**\n+     * Returns the documented constructors in a type element.\n+     *\n+     * @param te the type element\n+     * @return the constructors\n+     *\/\n+    public List<ExecutableElement> getConstructors(TypeElement te) {\n+        return getDocumentedItems(te, CONSTRUCTOR, ExecutableElement.class);\n@@ -1897,5 +1833,8 @@\n-    public List<ExecutableElement> getMethods(Element e) {\n-        return convertToExecutableElement(getItems(e, true, METHOD));\n-    }\n-    List<ExecutableElement> getMethodsUnfiltered(Element e) {\n-        return convertToExecutableElement(getItems(e, false, METHOD));\n+    \/**\n+     * Returns the documented methods in a type element.\n+     *\n+     * @param te the type element\n+     * @return the methods\n+     *\/\n+    public List<ExecutableElement> getMethods(TypeElement te) {\n+        return getDocumentedItems(te, METHOD, ExecutableElement.class);\n@@ -1983,42 +1922,8 @@\n-    public List<ExecutableElement> convertToExecutableElement(List<Element> list) {\n-        List<ExecutableElement> out = new ArrayList<>(list.size());\n-        for (Element e : list) {\n-            out.add((ExecutableElement)e);\n-        }\n-        return out;\n-    }\n-\n-    public List<TypeElement> convertToTypeElement(List<Element> list) {\n-        List<TypeElement> out = new ArrayList<>(list.size());\n-        for (Element e : list) {\n-            out.add((TypeElement)e);\n-        }\n-        return out;\n-    }\n-\n-    public List<VariableElement> convertToVariableElement(List<Element> list) {\n-        List<VariableElement> out = new ArrayList<>(list.size());\n-        for (Element e : list) {\n-            out.add((VariableElement) e);\n-        }\n-        return out;\n-    }\n-\n-    public List<TypeElement> getInterfaces(Element e)  {\n-        return convertToTypeElement(getItems(e, true, INTERFACE));\n-    }\n-\n-    public List<TypeElement> getInterfacesUnfiltered(Element e)  {\n-        return convertToTypeElement(getItems(e, false, INTERFACE));\n-    }\n-\n-    public List<Element> getEnumConstants(Element e) {\n-        return getItems(e, true, ENUM_CONSTANT);\n-    }\n-\n-    public List<TypeElement> getEnums(Element e) {\n-        return convertToTypeElement(getItems(e, true, ENUM));\n-    }\n-\n-    public List<TypeElement> getEnumsUnfiltered(Element e) {\n-        return convertToTypeElement(getItems(e, false, ENUM));\n+    \/**\n+     * Returns the documented interfaces in a package.\n+     *\n+     * @param pkg the package\n+     * @return the interfaces\n+     *\/\n+    public List<TypeElement> getInterfaces(PackageElement pkg)  {\n+        return getDocumentedItems(pkg, INTERFACE, TypeElement.class);\n@@ -2027,8 +1932,8 @@\n-    public SortedSet<TypeElement> getAllClassesUnfiltered(Element e) {\n-        List<TypeElement> clist = getClassesUnfiltered(e);\n-        clist.addAll(getInterfacesUnfiltered(e));\n-        clist.addAll(getAnnotationTypesUnfiltered(e));\n-        clist.addAll(getRecordsUnfiltered(e));\n-        SortedSet<TypeElement> oset = new TreeSet<>(comparators.makeGeneralPurposeComparator());\n-        oset.addAll(clist);\n-        return oset;\n+    \/**\n+     * Returns the documented enum constants in a type element.\n+     *\n+     * @param te the element\n+     * @return the interfaces\n+     *\/\n+    public List<VariableElement> getEnumConstants(TypeElement te) {\n+        return getDocumentedItems(te, ENUM_CONSTANT, VariableElement.class);\n@@ -2037,5 +1942,4 @@\n-    private final HashMap<Element, SortedSet<TypeElement>> cachedClasses = new HashMap<>();\n-     * Returns a list containing classes and interfaces,\n-     * including annotation types.\n-     * @param e Element\n-     * @return List\n+     * Returns the documented enum classes in a package.\n+     *\n+     * @param pkg the package\n+     * @return the interfaces\n@@ -2044,13 +1948,2 @@\n-    public SortedSet<TypeElement> getAllClasses(Element e) {\n-        SortedSet<TypeElement> oset = cachedClasses.get(e);\n-        if (oset != null)\n-            return oset;\n-        List<TypeElement> clist = getClasses(e);\n-        clist.addAll(getInterfaces(e));\n-        clist.addAll(getAnnotationTypes(e));\n-        clist.addAll(getEnums(e));\n-        clist.addAll(getRecords(e));\n-        oset = new TreeSet<>(comparators.makeGeneralPurposeComparator());\n-        oset.addAll(clist);\n-        cachedClasses.put(e, oset);\n-        return oset;\n+    public List<TypeElement> getEnums(PackageElement pkg) {\n+        return getDocumentedItems(pkg, ENUM, TypeElement.class);\n@@ -2059,3 +1952,5 @@\n-    \/*\n-     * Get all the elements unfiltered and filter them finally based\n-     * on its visibility, this works differently from the other getters.\n+    \/**\n+     * Returns all the classes in a package.\n+     *\n+     * @param pkg the package\n+     * @return the interfaces\n@@ -2063,23 +1958,4 @@\n-    private List<TypeElement> getInnerClasses(Element e, boolean filter) {\n-        List<TypeElement> olist = new ArrayList<>();\n-        for (TypeElement te : getClassesUnfiltered(e)) {\n-            if (!filter || configuration.docEnv.isSelected(te)) {\n-                olist.add(te);\n-            }\n-        }\n-        for (TypeElement te : getInterfacesUnfiltered(e)) {\n-            if (!filter || configuration.docEnv.isSelected(te)) {\n-                olist.add(te);\n-            }\n-        }\n-        for (TypeElement te : getAnnotationTypesUnfiltered(e)) {\n-            if (!filter || configuration.docEnv.isSelected(te)) {\n-                olist.add(te);\n-            }\n-        }\n-        for (TypeElement te : getEnumsUnfiltered(e)) {\n-            if (!filter || configuration.docEnv.isSelected(te)) {\n-                olist.add(te);\n-            }\n-        }\n-        return olist;\n+    public SortedSet<TypeElement> getAllClassesUnfiltered(PackageElement pkg) {\n+        SortedSet<TypeElement> set = new TreeSet<>(comparators.makeGeneralPurposeComparator());\n+        set.addAll(getItems(pkg, true, this::isTypeElement, TypeElement.class));\n+        return set;\n@@ -2088,3 +1964,1 @@\n-    public List<TypeElement> getInnerClasses(Element e) {\n-        return getInnerClasses(e, true);\n-    }\n+    private final HashMap<Element, SortedSet<TypeElement>> cachedClasses = new HashMap<>();\n@@ -2092,2 +1966,13 @@\n-    public List<TypeElement> getInnerClassesUnfiltered(Element e) {\n-        return getInnerClasses(e, false);\n+    \/**\n+     * Returns a sorted set containing the documented classes and interfaces in a package.\n+     *\n+     * @param pkg the element\n+     * @return the classes and interfaces\n+     *\/\n+    public SortedSet<TypeElement> getAllClasses(PackageElement pkg) {\n+        return cachedClasses.computeIfAbsent(pkg, p_ -> {\n+            List<TypeElement> clist = getItems(pkg, false, this::isTypeElement, TypeElement.class);\n+            SortedSet<TypeElement>oset = new TreeSet<>(comparators.makeGeneralPurposeComparator());\n+            oset.addAll(clist);\n+            return oset;\n+        });\n@@ -2121,15 +2006,14 @@\n-    @SuppressWarnings(\"preview\")\n-    List<Element> getItems(Element e, boolean filter, ElementKind select) {\n-        List<Element> elements = new ArrayList<>();\n-        return new SimpleElementVisitor14<List<Element>, Void>() {\n-\n-            @Override\n-            public List<Element> visitPackage(PackageElement e, Void p) {\n-                recursiveGetItems(elements, e, filter, select);\n-                return elements;\n-            }\n-\n-            @Override\n-            protected List<Element> defaultAction(Element e0, Void p) {\n-                return getItems0(e0, filter, select);\n-            }\n+    \/**\n+     * Returns a list of documented elements of a given type with a given kind.\n+     * If the root of the search is a package, the search is recursive.\n+     *\n+     * @param e      the element, such as a package element or type element\n+     * @param kind   the element kind\n+     * @param clazz  the class of the filtered members\n+     * @param <T>    the class of the filtered members\n+     *\n+     * @return the list of enclosed elements\n+     *\/\n+    private <T extends Element> List<T> getDocumentedItems(Element e, ElementKind kind, Class<T> clazz) {\n+        return getItems(e, false, e_ -> e_.getKind() == kind && shouldDocument(e_), clazz);\n+    }\n@@ -2137,1 +2021,13 @@\n-        }.visit(e);\n+    \/**\n+     * Returns a list of elements of a given type with a given kind.\n+     * If the root of the search is a package, the search is recursive.\n+     *\n+     * @param e      the element, such as a package element or type element\n+     * @param kind   the element kind\n+     * @param clazz  the class of the filtered members\n+     * @param <T>    the class of the filtered members\n+     *\n+     * @return the list of enclosed elements\n+     *\/\n+    private <T extends Element> List<T> getAllItems(Element e, ElementKind kind, Class<T> clazz) {\n+        return getItems(e, true, e_ -> e_.getKind() == kind, clazz);\n@@ -2140,9 +2036,20 @@\n-    Set<ElementKind> nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);\n-    void recursiveGetItems(Collection<Element> list, Element e, boolean filter, ElementKind... select) {\n-        list.addAll(getItems0(e, filter, select));\n-        List<Element> classes = getItems0(e, filter, nestedKinds);\n-        for (Element c : classes) {\n-            list.addAll(getItems0(c, filter, select));\n-            if (isTypeElement(c)) {\n-                recursiveGetItems(list, c, filter, select);\n-            }\n+    \/**\n+     * Returns a list of elements of a given type that match a predicate.\n+     * If the root of the search is a package, the search is recursive through packages\n+     * and classes.\n+     *\n+     * @param e      the element, such as a package element or type element\n+     * @param all    whether to search through all packages and classes, or just documented ones\n+     * @param select the predicate to select members\n+     * @param clazz  the class of the filtered members\n+     * @param <T>    the class of the filtered members\n+     *\n+     * @return the list of enclosed elements\n+     *\/\n+    private <T extends Element> List<T> getItems(Element e, boolean all, Predicate<Element> select, Class<T> clazz) {\n+        if (e.getKind() == ElementKind.PACKAGE) {\n+            List<T> elements = new ArrayList<>();\n+            recursiveGetItems(elements, e, all, select, clazz);\n+            return elements;\n+        } else {\n+            return getItems0(e, all, select, clazz);\n@@ -2152,3 +2059,16 @@\n-    private List<Element> getItems0(Element te, boolean filter, ElementKind... select) {\n-        Set<ElementKind> kinds = EnumSet.copyOf(Arrays.asList(select));\n-        return getItems0(te, filter, kinds);\n+    \/**\n+     * Searches for a list of recursively enclosed elements of a given class that match a predicate.\n+     * The recursion is through nested types.\n+     *\n+     * @param e      the element, such as a package element or type element\n+     * @param all    whether to search all packages and classes, or just documented ones\n+     * @param filter the filter\n+     * @param clazz  the class of the filtered members\n+     * @param <T>    the class of the filtered members\n+     *\/\n+    private <T extends Element> void recursiveGetItems(Collection<T> list, Element e, boolean all, Predicate<Element> filter, Class<T> clazz) {\n+        list.addAll(getItems0(e, all, filter, clazz));\n+        List<TypeElement> classes = getItems0(e, all, this::isTypeElement, TypeElement.class);\n+        for (TypeElement c : classes) {\n+            recursiveGetItems(list, c, all, filter, clazz);\n+        }\n@@ -2157,10 +2077,16 @@\n-    private List<Element> getItems0(Element te, boolean filter, Set<ElementKind> kinds) {\n-        List<Element> elements = new ArrayList<>();\n-        for (Element e : te.getEnclosedElements()) {\n-            if (kinds.contains(e.getKind())) {\n-                if (!filter || shouldDocument(e)) {\n-                    elements.add(e);\n-                }\n-            }\n-        }\n-        return elements;\n+    \/**\n+     * Returns a list of immediately enclosed elements of a given class that match a predicate.\n+     *\n+     * @param e      the element, such as a package element or type element\n+     * @param all    whether to search all packages and classes, or just documented ones\n+     * @param select the predicate for the selected members\n+     * @param clazz  the class of the filtered members\n+     * @param <T>    the class of the filtered members\n+     *\n+     * @return the list of enclosed elements\n+     *\/\n+    private <T extends Element> List<T> getItems0(Element e, boolean all, Predicate<Element> select, Class<T> clazz) {\n+        return e.getEnclosedElements().stream()\n+                .filter(e_ -> select.test(e_) && (all || shouldDocument(e_)))\n+                .map(clazz::cast)\n+                .toList();\n@@ -2169,1 +2095,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -2172,1 +2097,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -2225,1 +2149,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -2228,1 +2151,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -2231,1 +2153,1 @@\n-            snvisitor = new SimpleElementVisitor14<String, Void>() {\n+            snvisitor = new SimpleElementVisitor14<>() {\n@@ -2332,2 +2254,2 @@\n-            else if (val instanceof String)\n-                return sourceForm((String) val);\n+            else if (val instanceof String s)\n+                return sourceForm(s);\n@@ -2400,2 +2322,0 @@\n-    @SuppressWarnings(\"preview\")\n-    @SuppressWarnings(\"preview\")\n@@ -2405,1 +2325,1 @@\n-            specifiedVisitor = new SimpleElementVisitor14<Boolean, Void>() {\n+            specifiedVisitor = new SimpleElementVisitor14<>() {\n@@ -2615,1 +2535,1 @@\n-                .map(t -> tClass.cast(t))\n+                .map(tClass::cast)\n@@ -2633,4 +2553,4 @@\n-            if (taglet instanceof BaseTaglet) {\n-                return ((BaseTaglet) taglet).accepts(t);\n-            } else if (t instanceof UnknownBlockTagTree) {\n-                return ((UnknownBlockTagTree) t).getTagName().equals(taglet.getName());\n+            if (taglet instanceof BaseTaglet baseTaglet) {\n+                return baseTaglet.accepts(t);\n+            } else if (t instanceof BlockTagTree blockTagTree) {\n+                return blockTagTree.getTagName().equals(taglet.getName());\n@@ -2990,16 +2910,1 @@\n-    @SuppressWarnings(\"preview\")\n-        Set<DeclarationPreviewLanguageFeatures> result = new HashSet<>();\n-\n-        if ((e.getKind().isClass() || e.getKind().isInterface()) &&\n-            e.getModifiers().contains(Modifier.SEALED)) {\n-            List<? extends TypeMirror> permits = ((TypeElement) e).getPermittedSubclasses();\n-            boolean hasLinkablePermits = permits.stream()\n-                                                .anyMatch(t -> isLinkable(asTypeElement(t)));\n-            if (hasLinkablePermits) {\n-                result.add(DeclarationPreviewLanguageFeatures.SEALED_PERMITS);\n-            } else {\n-                result.add(DeclarationPreviewLanguageFeatures.SEALED);\n-            }\n-        }\n-\n-        return result;\n+        return new HashSet<>();\n@@ -3010,3 +2915,1 @@\n-\n-        SEALED(List.of(\"sealed\")),\n-        SEALED_PERMITS(List.of(\"sealed\", \"permits\"));\n+        NONE(List.of(\"\"));\n@@ -3015,1 +2918,1 @@\n-        private DeclarationPreviewLanguageFeatures(List<String> features) {\n+        DeclarationPreviewLanguageFeatures(List<String> features) {\n@@ -3018,1 +2921,0 @@\n-\n@@ -3021,1 +2923,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -3034,1 +2935,1 @@\n-                usedInDeclaration.addAll(types2Classes(te.getRecordComponents().stream().map(c -> c.asType()).toList())); \/\/TODO: annotations on record components???\n+                usedInDeclaration.addAll(types2Classes(te.getRecordComponents().stream().map(Element::asType).toList())); \/\/TODO: annotations on record components???\n@@ -3044,1 +2945,1 @@\n-                usedInDeclaration.addAll(types2Classes(ee.getParameters().stream().map(p -> p.asType()).toList()));\n+                usedInDeclaration.addAll(types2Classes(ee.getParameters().stream().map(VariableElement::asType).toList()));\n@@ -3215,5 +3116,6 @@\n-        if (!previewLanguageFeaturesUsed(el).isEmpty() ||\n-            configuration.workArounds.isPreviewAPI(el) ||\n-            !previewAPIs.previewAPI.isEmpty() ||\n-            !previewAPIs.reflectivePreviewAPI.isEmpty() ||\n-            !previewAPIs.declaredUsingPreviewFeature.isEmpty())  {\n+        if ((!previewLanguageFeaturesUsed(el).isEmpty() ||\n+             configuration.workArounds.isPreviewAPI(el) ||\n+             !previewAPIs.previewAPI.isEmpty() ||\n+             !previewAPIs.reflectivePreviewAPI.isEmpty() ||\n+             !previewAPIs.declaredUsingPreviewFeature.isEmpty()) &&\n+            !hasNoProviewAnnotation(el)) {\n@@ -3232,1 +3134,1 @@\n-        PREVIEW;\n+        PREVIEW\n@@ -3235,0 +3137,5 @@\n+    private boolean hasNoProviewAnnotation(Element el) {\n+        return el.getAnnotationMirrors()\n+                 .stream()\n+                 .anyMatch(am -> \"jdk.internal.javac.NoPreview\".equals(getQualifiedTypeName(am.getAnnotationType())));\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":265,"deletions":358,"binary":false,"changes":623,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -594,1 +594,1 @@\n-        if (tsi.tag != null && tsi.tree instanceof StartElementTree) {\n+        if (tsi.tag != null && tsi.tree instanceof StartElementTree startTree) {\n@@ -600,2 +600,2 @@\n-                DocTree tree = (endTree != null) ? endTree : tsi.tree;\n-                Name treeName = ((StartElementTree) tsi.tree).getName();\n+                DocTree tree = (endTree != null) ? endTree : startTree;\n+                Name treeName = startTree.getName();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -866,28 +866,0 @@\n-    \/**\n-     * Defines a class but does not make it known to the class loader or system dictionary.\n-     * <p>\n-     * For each CP entry, the corresponding CP patch must either be null or have\n-     * the a format that matches its tag:\n-     * <ul>\n-     * <li>Integer, Long, Float, Double: the corresponding wrapper object type from java.lang\n-     * <li>Utf8: a string (must have suitable syntax if used as signature or name)\n-     * <li>Class: any java.lang.Class object\n-     * <li>String: any object (not just a java.lang.String)\n-     * <li>InterfaceMethodRef: (NYI) a method handle to invoke on that call site's arguments\n-     * <\/ul>\n-     *\n-     * @deprecated Use {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)}\n-     * or {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClassWithClassData(byte[], Object, boolean, MethodHandles.Lookup.ClassOption...)}\n-     * instead.\n-     *\n-     * @param hostClass context for linkage, access control, protection domain, and class loader\n-     * @param data      bytes of a class file\n-     * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data\n-     *\/\n-    @ForceInline\n-    @Deprecated(since = \"15\", forRemoval = true)\n-    @SuppressWarnings(\"removal\")\n-    public Class<?> defineAnonymousClass(Class<?> hostClass, byte[] data, Object[] cpPatches) {\n-        return theInternalUnsafe.defineAnonymousClass(hostClass, data, cpPatches);\n-    }\n-\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -163,1 +163,6 @@\n-runtime\/ReservedStack\/ReservedStackTest.java 8231031 generic-all\n+runtime\/os\/TestTracePageSizes.java#no-options 8267460 linux-aarch64\n+runtime\/os\/TestTracePageSizes.java#explicit-large-page-size 8267460 linux-aarch64\n+runtime\/os\/TestTracePageSizes.java#compiler-options 8267460 linux-aarch64\n+runtime\/os\/TestTracePageSizes.java#with-G1 8267460 linux-aarch64\n+runtime\/os\/TestTracePageSizes.java#with-Parallel 8267460 linux-aarch64\n+runtime\/os\/TestTracePageSizes.java#with-Serial 8267460 linux-aarch64\n@@ -169,1 +174,5 @@\n-serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062 macosx-x64\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062,8268570 generic-all\n+serviceability\/attach\/RemovingUnixDomainSocketTest.java 8268570 generic-all\n+serviceability\/sa\/TestJhsdbJstackLock.java 8268570 generic-all\n+serviceability\/sa\/JhsdbThreadInfoTest.java 8268570 generic-all\n+\n@@ -227,0 +236,1 @@\n+vmTestbase\/nsk\/jdi\/HiddenClass\/events\/events001.java                 8257705 generic-all\n@@ -238,0 +248,2 @@\n+vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003\/TestDescription.java 8264605 generic-all\n+vmTestbase\/nsk\/jvmti\/PopFrame\/popframe011\/TestDescription.java 8266593 generic-all\n@@ -250,1 +262,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -337,0 +337,1 @@\n+ -runtime\/cds\/appcds\/jcmd\/JCmdTestFileSafety.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,39 +165,0 @@\n-    private static Class<?> anonClass() throws Exception {\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(Opcodes.V1_8, Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, \"Anon\", null, \"java\/lang\/Object\", null);\n-        FieldVisitor intField = cw.visitField(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, \"intField\", \"I\", null, 0);\n-        intField.visitEnd();\n-        cw.visitEnd();\n-        return unsafe.defineAnonymousClass(TypeUniverse.class, cw.toByteArray(), null);\n-    }\n-\n-    @Test\n-    public void getHostClassTest() throws Exception {\n-        ResolvedJavaType type = metaAccess.lookupJavaType(anonClass());\n-        ResolvedJavaType host = type.getHostClass();\n-        assertNotNull(host);\n-        for (Class<?> c : classes) {\n-            type = metaAccess.lookupJavaType(c);\n-            host = type.getHostClass();\n-            assertNull(host);\n-            if (type.equals(predicateType)) {\n-                assertTrue(c.isHidden());\n-            }\n-        }\n-\n-        class LocalClass {\n-        }\n-        Cloneable clone = new Cloneable() {\n-        };\n-        assertNull(metaAccess.lookupJavaType(LocalClass.class).getHostClass());\n-        assertNull(metaAccess.lookupJavaType(clone.getClass()).getHostClass());\n-\n-        Supplier<Runnable> lambda = () -> () -> System.out.println(\"run\");\n-        ResolvedJavaType lambdaType = metaAccess.lookupJavaType(lambda.getClass());\n-        ResolvedJavaType nestedLambdaType = metaAccess.lookupJavaType(lambda.get().getClass());\n-        assertNull(lambdaType.getHostClass());\n-        assertTrue(lambda.getClass().isHidden());\n-        assertNull(nestedLambdaType.getHostClass());\n-        assertTrue(lambda.get().getClass().isHidden());\n-    }\n-\n@@ -1160,0 +1121,1 @@\n+        \"getHostClass\",\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":2,"deletions":40,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -164,1 +164,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -324,1 +324,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -372,1 +372,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -523,1 +523,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -571,1 +571,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -727,1 +727,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -775,1 +775,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/GetfieldChains.jcod","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -78,1 +78,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/HiddenPoint.jcod","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/MultiANewArrayTest\/MultiANewArrayTypeCheck.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-public class runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatchHelper version 61:0 {\n+public class runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatchHelper version 62:0 {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/TestFieldTypeMismatchHelper.jasm","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -356,1 +356,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/WithFieldNoAccessTest.jcod","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -207,1 +207,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -363,1 +363,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -519,1 +519,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -626,1 +626,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -881,1 +881,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -1160,1 +1160,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -1474,1 +1474,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -1752,1 +1752,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -2039,1 +2039,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/cfpTests.jcod","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/identityObject\/IdentityType.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-        return new BasicClassBuilder(\"ANormalClass\", 61, 0)\n+        return new BasicClassBuilder(\"ANormalClass\", 62, 0)\n@@ -100,1 +100,1 @@\n-        return new BasicClassBuilder(\"AbstractWithField\", 61, 0)\n+        return new BasicClassBuilder(\"AbstractWithField\", 62, 0)\n@@ -108,1 +108,1 @@\n-        return new BasicClassBuilder(\"AbstractIdentity\", 61, 0)\n+        return new BasicClassBuilder(\"AbstractIdentity\", 62, 0)\n@@ -116,1 +116,1 @@\n-        return new BasicClassBuilder(\"Identity\", 61, 0)\n+        return new BasicClassBuilder(\"Identity\", 62, 0)\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/primitiveObject\/TestPrimitiveObject.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -302,1 +302,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -562,1 +562,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -821,1 +821,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -1082,1 +1082,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -1342,1 +1342,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -1606,1 +1606,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -1866,1 +1866,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/testSupers\/InlineClassWithBadSupers.jcod","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/NoNullVT.jcod","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -265,1 +265,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -366,1 +366,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -484,1 +484,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -601,1 +601,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -820,1 +820,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -939,1 +939,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -1061,1 +1061,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -1289,1 +1289,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n@@ -1517,1 +1517,1 @@\n-  61; \/\/ version\n+  62; \/\/ version\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/verifierTests.jcod","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,6 @@\n+\/\/ These classes are loaded on a different thread.\n+\/\/ We should not get ClassPrepare events for them.\n+static const class_info unexpectedClasses[] = {\n+    { \"Lnsk\/jvmti\/ClassPrepare\/classprep001$TestInterface2;\", 0, 0, 0, 0 },\n+    { \"Lnsk\/jvmti\/ClassPrepare\/classprep001$TestClass2;\", 0, 0, 0, 0}\n+};\n@@ -90,0 +96,11 @@\n+const size_t NOT_FOUND = (size_t)(-1);\n+\n+size_t findClass(const char *classSig, const class_info *arr, int size) {\n+    for (int i = 0; i < size; i++) {\n+        if (strcmp(classSig, arr[i].sig) == 0) {\n+            return i;\n+        }\n+    }\n+    return NOT_FOUND;\n+}\n+\n@@ -191,4 +208,9 @@\n-    if (eventsCount >= eventsExpected) {\n-        printf(\"(#%\" PRIuPTR \") too many events: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n-               eventsCount, eventsCount + 1, eventsExpected);\n-        result = STATUS_FAILED;\n+    size_t expectedClassIdx = findClass(inf.sig, classes, sizeof(classes)\/sizeof(class_info));\n+    \/\/ Test classes loading may cause system classes loading - skip them.\n+    if (expectedClassIdx == NOT_FOUND) {\n+        size_t unexpectedClassIdx = findClass(inf.sig, unexpectedClasses,\n+                                              sizeof(unexpectedClasses)\/sizeof(class_info));\n+        if (unexpectedClassIdx != NOT_FOUND) {\n+            printf(\"# wrong class: \\\"%s\\\"\\n\", inf.sig);\n+            result = STATUS_FAILED;\n+        }\n@@ -198,4 +220,3 @@\n-    if (inf.sig == NULL || strcmp(inf.sig, classes[eventsCount].sig) != 0) {\n-        printf(\"(#%\" PRIuPTR \") wrong class: \\\"%s\\\"\",\n-               eventsCount, inf.sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", classes[eventsCount].sig);\n+    if (eventsCount != expectedClassIdx) {\n+        printf(\"(#%\" PRIuPTR \") unexpected order: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n+               eventsCount, expectedClassIdx, eventsCount);\n@@ -203,0 +224,1 @@\n+        return;\n@@ -204,0 +226,1 @@\n+\n@@ -269,1 +292,1 @@\n-Java_nsk_jvmti_ClassPrepare_classprep001_getReady(JNIEnv *env, jclass cls) {\n+Java_nsk_jvmti_ClassPrepare_classprep001_getReady(JNIEnv *env, jclass cls, jthread thread) {\n@@ -271,1 +294,0 @@\n-    jthread prep_thread;\n@@ -278,8 +300,1 @@\n-    err = jvmti->GetCurrentThread(&prep_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to get current thread: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-            JVMTI_EVENT_CLASS_PREPARE, prep_thread);\n+            JVMTI_EVENT_CLASS_PREPARE, thread);\n@@ -297,1 +312,1 @@\n-Java_nsk_jvmti_ClassPrepare_classprep001_check(JNIEnv *env, jclass cls) {\n+Java_nsk_jvmti_ClassPrepare_classprep001_check(JNIEnv *env, jclass cls, jthread thread) {\n@@ -299,1 +314,0 @@\n-    jthread prep_thread;\n@@ -306,7 +320,1 @@\n-    err = jvmti->GetCurrentThread(&prep_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to get current thread: %s (%d)\\n\", TranslateError(err), err);\n-        return STATUS_FAILED;\n-    }\n-\n-            JVMTI_EVENT_CLASS_PREPARE, prep_thread);\n+            JVMTI_EVENT_CLASS_PREPARE, thread);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassPrepare\/classprep001\/classprep001.cpp","additions":36,"deletions":28,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -344,1 +344,2 @@\n-    java\/foreign\n+    java\/foreign \\\n+    -java\/foreign\/TestMatrix.java\n@@ -528,1 +529,0 @@\n-    java\/rmi\/activation\/nonLocalActivation\/NonLocalActivationTest.java \\\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n- * @run main\/othervm --add-modules=ALL-SYSTEM FieldSetAccessibleTest SECURE\n+ * @run main\/othervm --add-modules=ALL-SYSTEM -Djava.security.manager=allow FieldSetAccessibleTest SECURE\n@@ -289,1 +289,5 @@\n-            Set<String> mods = Set.of(\"javafx.deploy\", \"jdk.deploy\", \"jdk.plugin\", \"jdk.javaws\");\n+            Set<String> mods = Set.of(\"javafx.deploy\", \"jdk.deploy\", \"jdk.plugin\", \"jdk.javaws\",\n+                \/\/ All JVMCI packages other than jdk.vm.ci.services are dynamically\n+                \/\/ exported to jdk.internal.vm.compiler\n+                \"jdk.internal.vm.compiler\"\n+            );\n","filename":"test\/jdk\/java\/lang\/Class\/getDeclaredField\/FieldSetAccessibleTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-                .withMajorVersion(61)\n+                .withMajorVersion(62)\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -314,0 +314,1 @@\n+        vmOptFinalFlag(map, \"UseVectorizedMismatchIntrinsic\");\n@@ -317,0 +318,1 @@\n+        vmOptFinalFlag(map, \"UseVtableBasedCHA\");\n@@ -331,1 +333,1 @@\n-        return \"\" + WB.isJFRIncludedInVmBuild();\n+        return \"\" + WB.isJFRIncluded();\n@@ -367,1 +369,1 @@\n-        return \"\" + WB.isCDSIncludedInVmBuild();\n+        return \"\" + WB.isCDSIncluded();\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -144,0 +144,3 @@\n+compiler.warn.declared.using.preview                    # after making sealed classes a final feature there is no other\n+                                                        # preview feature but we should keep this key for future use just\n+                                                        # in case\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -318,1 +318,2 @@\n-                    .withOption(\"--should-stop=at=ATTR\")\n+                    .withOption(\"--should-stop=ifError=ATTR\")\n+                    .withOption(\"--should-stop=ifNoError=ATTR\")\n","filename":"test\/langtools\/tools\/javac\/failover\/CheckAttributedTree.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -248,1 +249,1 @@\n-  public native boolean isC2OrJVMCIIncludedInVmBuild();\n+  public native boolean isC2OrJVMCIIncluded();\n@@ -608,2 +609,2 @@\n-  public native boolean isCDSIncludedInVmBuild();\n-  public native boolean isJFRIncludedInVmBuild();\n+  public native boolean isCDSIncluded();\n+  public native boolean isJFRIncluded();\n@@ -651,1 +652,1 @@\n-  public native void verifyFrames(boolean log);\n+  public native void verifyFrames(boolean log, boolean updateRegisterMap);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}