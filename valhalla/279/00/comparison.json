{"files":[{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-\/**\n- * Base builder.\n- *\n- * @param <S> the type of the symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <E> the type of pool entries\n- * @param <D> the type of this builder\n- *\/\n-public class AbstractBuilder<S, T, E, D extends AbstractBuilder<S, T, E, D>> {\n-    \/**\n-     * The helper to build the constant pool.\n-     *\/\n-    protected final PoolHelper<S, T, E> poolHelper;\n-\n-    \/**\n-     * The helper to use to manipulate type descriptors.\n-     *\/\n-    protected final TypeHelper<S, T> typeHelper;\n-\n-    \/**\n-     * Create a builder.\n-     *\n-     * @param poolHelper the helper to build the constant pool\n-     * @param typeHelper the helper to use to manipulate type descriptors\n-     *\/\n-    AbstractBuilder(PoolHelper<S, T, E> poolHelper, TypeHelper<S, T> typeHelper) {\n-        this.poolHelper = poolHelper;\n-        this.typeHelper = typeHelper;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    D thisBuilder() {\n-        return (D) this;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/AbstractBuilder.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,340 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.function.Consumer;\n-import java.util.function.ToIntBiFunction;\n-\n-public class AnnotationsBuilder<S, T, E> extends AbstractBuilder<S, T, E, AnnotationsBuilder<S, T, E>> {\n-\n-    GrowableByteBuffer annoAttribute;\n-    int nannos;\n-\n-    AnnotationsBuilder(PoolHelper<S, T, E> poolHelper, TypeHelper<S, T> typeHelper) {\n-        super(poolHelper, typeHelper);\n-        this.annoAttribute = new GrowableByteBuffer();\n-        annoAttribute.writeChar(0);\n-    }\n-\n-    public enum Kind {\n-        RUNTIME_VISIBLE,\n-        RUNTIME_INVISIBLE;\n-    }\n-\n-    enum Tag {\n-        B('B'),\n-        C('C'),\n-        D('D'),\n-        F('F'),\n-        I('I'),\n-        J('J'),\n-        S('S'),\n-        Z('Z'),\n-        STRING('s'),\n-        ENUM('e'),\n-        CLASS('c'),\n-        ANNO('@'),\n-        ARRAY('[');\n-\n-        char tagChar;\n-\n-        Tag(char tagChar) {\n-            this.tagChar = tagChar;\n-        }\n-    }\n-\n-    AnnotationsBuilder<S, T, E> withAnnotation(T annoType, Consumer<? super AnnotationElementBuilder> annotationBuilder) {\n-        annoAttribute.writeChar(poolHelper.putType(annoType));\n-        int offset = annoAttribute.offset;\n-        annoAttribute.writeChar(0);\n-        if (annotationBuilder != null) {\n-            AnnotationElementBuilder _builder = new AnnotationElementBuilder();\n-            int nelems = _builder.withElements(annotationBuilder);\n-            patchCharAt(offset, nelems);\n-        }\n-        nannos++;\n-        return this;\n-    }\n-\n-    byte[] build() {\n-        patchCharAt(0, nannos);\n-        return annoAttribute.bytes();\n-    }\n-\n-    private void patchCharAt(int offset, int newChar) {\n-        int prevOffset = annoAttribute.offset;\n-        try {\n-            annoAttribute.offset = offset;\n-            annoAttribute.writeChar(newChar);\n-        } finally {\n-            annoAttribute.offset = prevOffset;\n-        }\n-    }\n-\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    static Consumer NO_BUILDER =\n-            new Consumer() {\n-                @Override\n-                public void accept(Object o) {\n-                    \/\/do nothing\n-                }\n-            };\n-\n-    public class AnnotationElementBuilder {\n-\n-        int nelems;\n-\n-        public AnnotationElementBuilder withString(String name, String s) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writeStringValue(s);\n-            return this;\n-        }\n-\n-        private void writeStringValue(String s) {\n-            annoAttribute.writeByte(Tag.STRING.tagChar);\n-            annoAttribute.writeChar(poolHelper.putUtf8(s));\n-            nelems++;\n-        }\n-\n-        public AnnotationElementBuilder withClass(String name, T s) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writeClassValue(s);\n-            return this;\n-        }\n-\n-        private void writeClassValue(T s) {\n-            annoAttribute.writeByte(Tag.CLASS.tagChar);\n-            annoAttribute.writeChar(poolHelper.putType(s));\n-            nelems++;\n-        }\n-\n-        public AnnotationElementBuilder withEnum(String name, T enumType, int constant) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writeEnumValue(enumType, constant);\n-            return this;\n-        }\n-\n-        private void writeEnumValue(T enumType, int constant) {\n-            annoAttribute.writeByte(Tag.ENUM.tagChar);\n-            annoAttribute.writeChar(poolHelper.putType(enumType));\n-            annoAttribute.writeChar(constant);\n-            nelems++;\n-        }\n-\n-        public AnnotationElementBuilder withAnnotation(String name, T annoType, Consumer<? super AnnotationElementBuilder> annotationBuilder) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writeAnnotationValue(annoType, annotationBuilder);\n-            return this;\n-        }\n-\n-        private void writeAnnotationValue(T annoType, Consumer<? super AnnotationElementBuilder> annotationBuilder) {\n-            annoAttribute.writeByte(Tag.ANNO.tagChar);\n-            annoAttribute.writeChar(poolHelper.putType(annoType));\n-            int offset = annoAttribute.offset;\n-            annoAttribute.writeChar(0);\n-            int nelems = withNestedElements(annotationBuilder);\n-            patchCharAt(offset, nelems);\n-            this.nelems++;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, char c) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.C, (int)c, PoolHelper::putInt);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, short s) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.S, (int)s, PoolHelper::putInt);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, byte b) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.B, (int)b, PoolHelper::putInt);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, int i) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.I, i, PoolHelper::putInt);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, float f) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.F, f, PoolHelper::putFloat);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, long l) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.J, l, PoolHelper::putLong);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, double d) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.D, d, PoolHelper::putDouble);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, boolean b) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.Z, b ? 1 : 0, PoolHelper::putInt);\n-            return this;\n-        }\n-\n-        private <Z> void writePrimitiveValue(Tag tag, Z value, ToIntBiFunction<PoolHelper<S, T, E>, Z> poolFunc) {\n-            annoAttribute.writeByte(tag.tagChar);\n-            annoAttribute.writeChar(poolFunc.applyAsInt(poolHelper, value));\n-            nelems++;\n-        }\n-\n-        AnnotationElementBuilder withStrings(String name, String... ss) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(ss.length);\n-            for (String s : ss) {\n-                writeStringValue(s);\n-            }\n-            return this;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        AnnotationElementBuilder withClasses(String name, T... cc) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(cc.length);\n-            for (T c : cc) {\n-                writeClassValue(c);\n-            }\n-            return this;\n-        }\n-\n-        AnnotationElementBuilder withEnums(String name, T enumType, int... constants) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(constants.length);\n-            for (int c : constants) {\n-                writeEnumValue(enumType, c);\n-            }\n-            return this;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public AnnotationElementBuilder withAnnotations(String name, T annoType, Consumer<? super AnnotationElementBuilder>... annotationBuilders) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(annotationBuilders.length);\n-            for (Consumer<? super AnnotationElementBuilder> annotationBuilder : annotationBuilders) {\n-                writeAnnotationValue(annoType, annotationBuilder);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, char... cc) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(cc.length);\n-            for (char c : cc) {\n-                writePrimitiveValue(Tag.C, (int)c, PoolHelper::putInt);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, short... ss) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(ss.length);\n-            for (short s : ss) {\n-                writePrimitiveValue(Tag.S, (int)s, PoolHelper::putInt);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, byte... bb) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(bb.length);\n-            for (byte b : bb) {\n-                writePrimitiveValue(Tag.B, (int)b, PoolHelper::putInt);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, int... ii) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(ii.length);\n-            for (int i : ii) {\n-                writePrimitiveValue(Tag.I, i,  PoolHelper::putInt);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, float... ff) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(ff.length);\n-            for (float f : ff) {\n-                writePrimitiveValue(Tag.F, f, PoolHelper::putFloat);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, long... ll) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(ll.length);\n-            for (long l : ll) {\n-                writePrimitiveValue(Tag.J, l, PoolHelper::putLong);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, double... dd) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(dd.length);\n-            for (double d : dd) {\n-                writePrimitiveValue(Tag.D, d, PoolHelper::putDouble);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, boolean... bb) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(bb.length);\n-            for (boolean b : bb) {\n-                writePrimitiveValue(Tag.Z, b ? 1 : 0, PoolHelper::putInt);\n-            }\n-            return this;\n-        }\n-\n-        int withNestedElements(Consumer<? super AnnotationElementBuilder> annotationBuilder) {\n-            return withElements(new AnnotationElementBuilder(), annotationBuilder);\n-        }\n-\n-        int withElements(Consumer<? super AnnotationElementBuilder> annotationBuilder) {\n-            return withElements(this, annotationBuilder);\n-        }\n-\n-        private int withElements(AnnotationElementBuilder builder, Consumer<? super AnnotationElementBuilder> annotationBuilder) {\n-            annotationBuilder.accept(builder);\n-            return builder.nelems;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/AnnotationsBuilder.java","additions":0,"deletions":340,"binary":false,"changes":340,"status":"deleted"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-\/**\n- * Base builder for attribute containing class file entities.\n- *\n- * @param <S> the type of the symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <E> the type of pool entries\n- * @param <D> the type of this builder\n- *\/\n- public class AttributeBuilder<S, T, E, D extends AttributeBuilder<S, T, E, D>>\n-        extends AbstractBuilder<S, T, E, D> {\n-\n-     \/**\n-      * The number of attributes.\n-      *\/\n-    protected int nattrs;\n-\n-    \/**\n-     * The attributes represented as bytes.\n-     *\/\n-    protected GrowableByteBuffer attributes = new GrowableByteBuffer();\n-\n-    \/**\n-     * Create an attribute builder.\n-     *\n-     * @param poolHelper the helper to build the constant pool\n-     * @param typeHelper the helper to use to manipulate type descriptors\n-     *\/\n-    public AttributeBuilder(PoolHelper<S, T, E> poolHelper, TypeHelper<S, T> typeHelper) {\n-        super(poolHelper, typeHelper);\n-    }\n-\n-    \/**\n-     * Add a class file Attribute.  Defined as:\n-     * <pre>\n-     * {@code   attribute_info {\n-     *     u2 attribute_name_index;\n-     *     u4 attribute_length;\n-     *     u1 info[attribute_length];\n-     *   }}\n-     * <\/pre>\n-     *\n-     * @param name the attribute name\n-     * @param bytes the bytes of the attribute info\n-     * @return this builder, for chained calls\n-     *\/\n-    public D withAttribute(CharSequence name, byte[] bytes) {\n-        attributes.writeChar(poolHelper.putUtf8(name));\n-        attributes.writeInt(bytes.length);\n-        attributes.writeBytes(bytes);\n-        nattrs++;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Add a class file Attribute, using a writer.  Defined as:\n-     * <pre>\n-     * {@code   attribute_info {\n-     *     u2 attribute_name_index;\n-     *     u4 attribute_length;\n-     *     u1 info[attribute_length];\n-     *   }}\n-     * <\/pre>\n-     *\n-     * @param <Z> the type of the object representing the attribute\n-     * @param name the attribute name\n-     * @param attr the representation of the attribute\n-     * @param attrWriter the writer which transform the attribute representation into bytes\n-     * @return this builder, for chained calls\n-     *\/\n-    public <Z> D withAttribute(CharSequence name, Z attr, AttributeWriter<S, T, E, Z> attrWriter) {\n-        attributes.writeChar(poolHelper.putUtf8(name));\n-        int offset = attributes.offset;\n-        attributes.writeInt(0);\n-        attrWriter.write(attr, poolHelper, attributes);\n-        int len = attributes.offset - offset - 4;\n-        attributes.withOffset(offset, buf -> buf.writeInt(len));\n-        nattrs++;\n-        return thisBuilder();\n-    }\n-\n-     \/**\n-      * Writer for transforming attribute representations to bytes\n-      *\n-      * @param <S> the type of symbol representation\n-      * @param <T> the type of type descriptors representation\n-      * @param <E> the type of pool entries\n-      * @param <A> the type of the object representing the attribute\n-      *\/\n-    public interface AttributeWriter<S, T, E, A> {\n-\n-        \/**\n-         * Write an attribute representation into a byte buffer.\n-         *\n-         * @param attr the representation of the attribute\n-         * @param poolHelper the constant pool helper\n-         * @param buf the buffer to collect the bytes\n-         *\/\n-        void write(A attr, PoolHelper<S, T, E> poolHelper, GrowableByteBuffer buf);\n-    }\n-\n-    \/**\n-     * Add a source file attribute.\n-     *\n-     * @param sourceFile name of the source file\n-     * @return this builder, for chained calls\n-     *\/\n-    public D withSourceFile(String sourceFile) {\n-        GrowableByteBuffer a = new GrowableByteBuffer();\n-        a.writeChar(poolHelper.putUtf8(sourceFile));\n-        return withAttribute(\"SourceFile\", a.bytes());\n-    }\n-\n-    \/**\n-     * Add a linenumber table attribute.\n-     *\n-     * @param pcln pairs of start_pc and linenumber\n-     * @return this builder, for chained calls\n-     *\/\n-    public D withLineNumberTable(int... pcln) {\n-        GrowableByteBuffer a = new GrowableByteBuffer();\n-        if (pcln.length % 2 != 0) {\n-            throw new IllegalArgumentException(\"Unmatched start_pc\/linenumber pair\");\n-        }\n-        a.writeChar(pcln.length \/ 2);\n-        for (int v : pcln) {\n-            a.writeChar(v);\n-        }\n-        return withAttribute(\"LineNumberTable\", a.bytes());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/AttributeBuilder.java","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-public class BasicClassBuilder extends ClassBuilder<String, String, BasicClassBuilder> {\n-\n-    public BasicClassBuilder(String thisClass, int majorVersion, int minorVersion) {\n-        this();\n-        withMinorVersion(minorVersion);\n-        withMajorVersion(majorVersion);\n-        withThisClass(thisClass);\n-    }\n-\n-    public BasicClassBuilder() {\n-        this(new BytePoolHelper<>(s->s, s->s), new BasicTypeHelper());\n-    }\n-\n-    public BasicClassBuilder(BytePoolHelper<String, String> poolHelper, TypeHelper<String, String> typeHelper) {\n-        super(poolHelper, typeHelper);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/BasicClassBuilder.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,199 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.Iterator;\n-\n-\/**\n- * Helper to create and manipulate type descriptors, where type descriptors\n- * are represented as JVM type descriptor strings and symbols are represented\n- * as name strings\n- *\/\n-public class BasicTypeHelper implements TypeHelper<String, String> {\n-\n-    @Override\n-    public String elemtype(String s) {\n-        if (!s.startsWith(\"[\")) {\n-            throw new IllegalStateException();\n-        }\n-        return s.substring(1);\n-    }\n-\n-    @Override\n-    public String arrayOf(String s) {\n-        return \"[\" + s;\n-    }\n-\n-    @Override\n-    public boolean isValue(String t) {\n-        return t.charAt(0) == 'Q' && t.endsWith(\";\");\n-    }\n-\n-    @Override\n-    public String type(String s) {\n-        return \"L\" + s + \";\";\n-    }\n-\n-    @Override\n-    public String valueType(String s) {\n-        return \"Q\" + s + \";\";\n-    }\n-\n-    @Override\n-    public TypeTag tag(String s) {\n-        switch (s.charAt(0)) {\n-            case '[':\n-            case 'Q':\n-            case 'L':\n-                return TypeTag.A;\n-            case 'B':\n-            case 'C':\n-            case 'Z':\n-            case 'S':\n-            case 'I':\n-                return TypeTag.I;\n-            case 'F':\n-                return TypeTag.F;\n-            case 'J':\n-                return TypeTag.J;\n-            case 'D':\n-                return TypeTag.D;\n-            case 'V':\n-                return TypeTag.V;\n-            default:\n-                if (s == nullType()) {\n-                    return TypeTag.A;\n-                }\n-                throw new IllegalStateException(\"Bad type: \" + s);\n-        }\n-    }\n-\n-    @Override\n-    public String nullType() {\n-        \/\/ Needed in TypedCodeBuilder; ACONST_NULL pushes a 'null' onto the stack,\n-        \/\/ and stack maps handle null differently\n-        return \"<null>\";\n-    }\n-\n-    @Override\n-    public String commonSupertype(String t1, String t2) {\n-        if (t1.equals(t2)) {\n-            return t1;\n-        } else {\n-            try {\n-                Class<?> c1 = from(t1);\n-                Class<?> c2 = from(t2);\n-                if (c1.isAssignableFrom(c2)) {\n-                    return t1;\n-                } else if (c2.isAssignableFrom(c1)) {\n-                    return t2;\n-                } else {\n-                    return \"Ljava\/lang\/Object;\";\n-                }\n-            } catch (Exception e) {\n-                return null;\n-            }\n-        }\n-    }\n-\n-    public Class<?> from(String desc) throws ReflectiveOperationException {\n-        if (desc.startsWith(\"[\")) {\n-            return Class.forName(desc.replaceAll(\"\/\", \".\"));\n-        } else {\n-            return Class.forName(symbol(desc).replaceAll(\"\/\", \".\"));\n-        }\n-    }\n-\n-    @Override\n-    public Iterator<String> parameterTypes(String s) {\n-        \/\/TODO: gracefully non-method types\n-        return new Iterator<String>() {\n-            int ch = 1;\n-\n-            @Override\n-            public boolean hasNext() {\n-                return s.charAt(ch) != ')';\n-            }\n-\n-            @Override\n-            public String next() {\n-                char curr = s.charAt(ch);\n-                switch (curr) {\n-                    case 'C':\n-                    case 'B':\n-                    case 'S':\n-                    case 'I':\n-                    case 'J':\n-                    case 'F':\n-                    case 'D':\n-                    case 'Z':\n-                        ch++;\n-                        return String.valueOf(curr);\n-                    case '[':\n-                        ch++;\n-                        return \"[\" + next();\n-                    case 'Q':\n-                    case 'L':\n-                        StringBuilder builder = new StringBuilder();\n-                        while (curr != ';') {\n-                            builder.append(curr);\n-                            curr = s.charAt(++ch);\n-                        }\n-                        builder.append(';');\n-                        ch++;\n-                        return builder.toString();\n-                    default:\n-                        throw new AssertionError(\"cannot parse string: \" + s);\n-                }\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public String symbolFrom(String s) {\n-        return s;\n-    }\n-\n-    @Override\n-    public String fromTag(TypeTag tag) {\n-        return tag.name();\n-    }\n-\n-    @Override\n-    public String symbol(String type) {\n-\tif (type.startsWith(\"L\") || type.startsWith(\"Q\")) {\n-\t    return type.substring(1, type.length() - 1);\n-\t} else {\n-\t    return type;\n-\t}\n-    }\n-\n-    @Override\n-    public String returnType(String s) {\n-        return s.substring(s.indexOf(')') + 1, s.length());\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/BasicTypeHelper.java","additions":0,"deletions":199,"binary":false,"changes":199,"status":"deleted"},{"patch":"@@ -1,224 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-\/**\n- * Low-level internal constant pool builder.\n- *\/\n-class BytePoolBuilder implements PoolBuilder<byte[]> {\n-\n-    GrowableByteBuffer pool = new GrowableByteBuffer();\n-    int currentIndex = 1;\n-\n-    @Override\n-    public int putClass(int utf8_idx) {\n-        pool.writeByte(PoolTag.CLASS.tag);\n-        pool.writeChar(utf8_idx);\n-        return currentIndex++;\n-    }\n-\n-    @Override\n-    public int putFieldRef(int owner_idx, int nameAndType_idx) {\n-        return putMemberRef(PoolTag.FIELDREF, owner_idx, nameAndType_idx);\n-    }\n-\n-    @Override\n-    public int putMethodRef(int owner_idx, int nameAndType_idx, boolean isInterface) {\n-        return putMemberRef((isInterface ? PoolTag.INTERFACEMETHODREF : PoolTag.METHODREF),\n-                owner_idx, nameAndType_idx);\n-    }\n-\n-    @Override\n-    public int putMemberRef(PoolTag tag, int owner_idx, int nameAndType_idx) {\n-        pool.writeByte(tag.tag);\n-        pool.writeChar(owner_idx);\n-        pool.writeChar(nameAndType_idx);\n-        return currentIndex++;\n-    }\n-\n-    @Override\n-    public int putInt(int i) {\n-        pool.writeByte(PoolTag.INTEGER.tag);\n-        pool.writeInt(i);\n-        return currentIndex++;\n-    }\n-\n-    @Override\n-    public int putFloat(float f) {\n-        pool.writeByte(PoolTag.FLOAT.tag);\n-        pool.writeFloat(f);\n-        return currentIndex++;\n-    }\n-\n-    @Override\n-    public int putLong(long l) {\n-        pool.writeByte(PoolTag.LONG.tag);\n-        pool.writeLong(l);\n-        int inx = currentIndex;\n-        currentIndex += 2;\n-        return inx;\n-    }\n-\n-    @Override\n-    public int putDouble(double d) {\n-        pool.writeByte(PoolTag.DOUBLE.tag);\n-        pool.writeDouble(d);\n-        int inx = currentIndex;\n-        currentIndex += 2;\n-        return inx;\n-    }\n-\n-    @Override\n-    public int putInvokeDynamic(int bsmIndex, int nameAndType_idx) {\n-        pool.writeByte(PoolTag.INVOKEDYNAMIC.tag);\n-        pool.writeChar(bsmIndex);\n-        pool.writeChar(nameAndType_idx);\n-        return currentIndex++;\n-    }\n-\n-    @Override\n-    public int putConstantDynamic(int bsmIndex, int nameAndType_idx) {\n-        pool.writeByte(PoolTag.CONSTANTDYNAMIC.tag);\n-        pool.writeChar(bsmIndex);\n-        pool.writeChar(nameAndType_idx);\n-        return currentIndex++;\n-    }\n-\n-    @Override\n-    public int putMethodType(int desc_idx) {\n-        pool.writeByte(PoolTag.METHODTYPE.tag);\n-        pool.writeChar(desc_idx);\n-        return currentIndex++;\n-    }\n-\n-    @Override\n-    public int putMethodHandle(int refKind, int ref_idx) {\n-        pool.writeByte(PoolTag.METHODHANDLE.tag);\n-        pool.writeByte(refKind);\n-        pool.writeChar(ref_idx);\n-        return currentIndex++;\n-    }\n-\n-    @Override\n-    public int putString(int utf8_index) {\n-        pool.writeByte(PoolTag.STRING.tag);\n-        pool.writeChar(utf8_index);\n-        return currentIndex++;\n-    }\n-\n-    @Override\n-    public int putNameAndType(int name_idx, int type_idx) {\n-        pool.writeByte(PoolTag.NAMEANDTYPE.tag);\n-        pool.writeChar(name_idx);\n-        pool.writeChar(type_idx);\n-        return currentIndex++;\n-    }\n-\n-    @Override\n-    public int putUtf8(CharSequence s) {\n-        int charLength = s.length();\n-        if (charLength > 65535) {\n-            throw new IllegalArgumentException();\n-        }\n-        pool.writeByte(PoolTag.UTF8.tag);\n-        \/\/ optimistic algorithm: instead of computing the byte length and then\n-        \/\/ serializing the string (which requires two loops), we assume the byte\n-        \/\/ length is equal to char length (which is the most frequent case), and\n-        \/\/ we start serializing the string right away. During the serialization,\n-        \/\/ if we find that this assumption is wrong, we continue with the\n-        \/\/ general method.\n-        pool.writeChar(charLength);\n-        for (int i = 0; i < charLength; ++i) {\n-            char c = s.charAt(i);\n-            if (c >= '\\001' && c <= '\\177') {\n-                pool.writeByte((byte) c);\n-            } else {\n-                encodeUTF8(s, i, 65535);\n-                break;\n-            }\n-        }\n-        return currentIndex++;\n-    }\n-\n-    \/**\n-     * Puts an UTF8 string into this byte vector. The byte vector is\n-     * automatically enlarged if necessary. The string length is encoded in two\n-     * bytes before the encoded characters, if there is space for that (i.e. if\n-     * this.length - i - 2 >= 0).\n-     *\n-     * @param s             the String to encode.\n-     * @param i             the index of the first character to encode. The previous\n-     *                      characters are supposed to have already been encoded, using\n-     *                      only one byte per character.\n-     * @param maxByteLength the maximum byte length of the encoded string, including the\n-     *                      already encoded characters.\n-     * @return this byte vector.\n-     *\/\n-    private void encodeUTF8(final CharSequence s, int i, int maxByteLength) {\n-        int charLength = s.length();\n-        int byteLength = i;\n-        char c;\n-        for (int j = i; j < charLength; ++j) {\n-            c = s.charAt(j);\n-            if (c >= '\\001' && c <= '\\177') {\n-                byteLength++;\n-            } else if (c > '\\u07FF') {\n-                byteLength += 3;\n-            } else {\n-                byteLength += 2;\n-            }\n-        }\n-        if (byteLength > maxByteLength) {\n-            throw new IllegalArgumentException();\n-        }\n-        int byteLengthFinal = byteLength;\n-        pool.withOffset(pool.offset - i - 2, buf -> buf.writeChar(byteLengthFinal));\n-        for (int j = i; j < charLength; ++j) {\n-            c = s.charAt(j);\n-            if (c >= '\\001' && c <= '\\177') {\n-                pool.writeChar((byte) c);\n-            } else if (c > '\\u07FF') {\n-                pool.writeChar((byte) (0xE0 | c >> 12 & 0xF));\n-                pool.writeChar((byte) (0x80 | c >> 6 & 0x3F));\n-                pool.writeChar((byte) (0x80 | c & 0x3F));\n-            } else {\n-                pool.writeChar((byte) (0xC0 | c >> 6 & 0x1F));\n-                pool.writeChar((byte) (0x80 | c & 0x3F));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public int size() {\n-        return currentIndex - 1;\n-    }\n-\n-    @Override\n-    public byte[] representation() {\n-        return pool.bytes();\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/BytePoolBuilder.java","additions":0,"deletions":224,"binary":false,"changes":224,"status":"deleted"},{"patch":"@@ -1,795 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleInfo;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Member;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.ToIntBiFunction;\n-\n-\/**\n- * A helper for building and tracking constant pools whose entries are\n- * represented as byte arrays.\n- *\n- * @param <S> the type of the symbol representation\n- * @param <T> the type of type descriptors representation\n- *\/\n-public class BytePoolHelper<S, T> implements PoolHelper<S, T, byte[]> {\n-\n-    final BytePoolBuilder builder;\n-    GrowableByteBuffer bsm_attr = new GrowableByteBuffer();\n-    \/\/Map<PoolKey, PoolKey> indicesMap = new HashMap<>();\n-    int currentBsmIndex = 0;\n-\n-    KeyMap<PoolKey> entries = new KeyMap<>();\n-    KeyMap<BsmKey> bootstraps = new KeyMap<>();\n-    PoolKey key = new PoolKey();\n-    BsmKey bsmKey = new BsmKey();\n-\n-    Function<S, String> symbolToString;\n-    Function<T, String> typeToString;\n-\n-    public BytePoolHelper(Function<S, String> symbolToString, Function<T, String> typeToString) {\n-        this(new BytePoolBuilder(), symbolToString, typeToString);\n-    }\n-\n-    BytePoolHelper(BytePoolBuilder builder, Function<S, String> symbolToString, Function<T, String> typeToString) {\n-        this.builder = builder;\n-        this.symbolToString = symbolToString;\n-        this.typeToString = typeToString;\n-    }\n-    \n-    public static <S, T> BytePoolHelper<S, T> immutable(Consumer<PoolBuilder<byte[]>> cpBuild,\n-            Function<S, String> symbolToString, Function<T, String> typeToString) {\n-        return new ImmutableBytePoolHelper<>(cpBuild, symbolToString, typeToString);\n-    }\n-\n-    static class KeyMap<K extends AbstractKey<K>> {\n-\n-        @SuppressWarnings(\"unchecked\")\n-        K[] table = (K[])new AbstractKey<?>[0x10];\n-        int nelems;\n-\n-        public void enter(K e) {\n-            if (nelems * 3 >= (table.length - 1) * 2)\n-                dble();\n-            int hash = getIndex(e);\n-            K old = table[hash];\n-            if (old == null) {\n-                nelems++;\n-            }\n-            e.next = old;\n-            table[hash] = e;\n-        }\n-\n-        protected K lookup(K other) {\n-            K e = table[getIndex(other)];\n-            while (e != null && !e.equals(other))\n-                e = e.next;\n-            return e;\n-        }\n-\n-        \/**\n-         * Look for slot in the table.\n-         * We use open addressing with double hashing.\n-         *\/\n-        int getIndex(K e) {\n-            int hashMask = table.length - 1;\n-            int h = e.hashCode();\n-            int i = h & hashMask;\n-            \/\/ The expression below is always odd, so it is guaranteed\n-            \/\/ to be mutually prime with table.length, a power of 2.\n-            int x = hashMask - ((h + (h >> 16)) << 1);\n-            for (; ; ) {\n-                K e2 = table[i];\n-                if (e2 == null)\n-                    return i;\n-                else if (e.hash == e2.hash)\n-                    return i;\n-                i = (i + x) & hashMask;\n-            }\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        private void dble() {\n-            K[] oldtable = table;\n-            table = (K[])new AbstractKey<?>[oldtable.length * 2];\n-            int n = 0;\n-            for (int i = oldtable.length; --i >= 0; ) {\n-                K e = oldtable[i];\n-                if (e != null) {\n-                    table[getIndex(e)] = e;\n-                    n++;\n-                }\n-            }\n-            \/\/ We don't need to update nelems for shared inherited scopes,\n-            \/\/ since that gets handled by leave().\n-            nelems = n;\n-        }\n-    }\n-\n-    public static abstract class AbstractKey<K extends AbstractKey<K>> {\n-        int hash;\n-        int index = -1;\n-        K next;\n-\n-        abstract K dup();\n-\n-        @Override\n-        public abstract boolean equals(Object o);\n-\n-        @Override\n-        public int hashCode() {\n-            return hash;\n-        }\n-\n-        void at(int index) {\n-            this.index = index;\n-        }\n-    }\n-\n-    public static class PoolKey extends AbstractKey<PoolKey> {\n-        PoolTag tag;\n-        Object o1;\n-        Object o2;\n-        Object o3;\n-        Object o4;\n-        int size = -1;\n-\n-        void setUtf8(CharSequence s) {\n-            tag = PoolTag.UTF8;\n-            o1 = s;\n-            size = 1;\n-            hash = tag.tag | (s.hashCode() << 1);\n-        }\n-\n-        void setClass(String clazz) {\n-            tag = PoolTag.CLASS;\n-            o1 = clazz;\n-            size = 1;\n-            hash = tag.tag | (clazz.hashCode() << 1);\n-        }\n-\n-        void setNameAndType(CharSequence name, String type) {\n-            tag = PoolTag.NAMEANDTYPE;\n-            o1 = name;\n-            o2 = type;\n-            size = 2;\n-            hash = tag.tag | ((name.hashCode() | type.hashCode()) << 1);\n-        }\n-\n-        void setMemberRef(PoolTag poolTag, String owner, CharSequence name, String type) {\n-            tag = poolTag;\n-            o1 = owner;\n-            o2 = name;\n-            o3 = type;\n-            size = 3;\n-            hash = tag.tag | ((owner.hashCode() | name.hashCode() | type.hashCode()) << 1);\n-        }\n-\n-        void setInvokeDynamic(int bsmIndex, CharSequence name, String type) {\n-            tag = PoolTag.INVOKEDYNAMIC;\n-            o1 = bsmIndex;\n-            o2 = name;\n-            o3 = type;\n-            size = 3;\n-            hash = tag.tag | ((bsmIndex | name.hashCode() | type.hashCode()) << 1);\n-        }\n-\n-        void setConstantDynamic(int bsmIndex, CharSequence name, String type) {\n-            tag = PoolTag.INVOKEDYNAMIC;\n-            o1 = bsmIndex;\n-            o2 = name;\n-            o3 = type;\n-            size = 3;\n-            hash = tag.tag | ((bsmIndex | name.hashCode() | type.hashCode()) << 1);\n-        }\n-\n-        void setString(String s) {\n-            tag = PoolTag.STRING;\n-            o1 = s;\n-            size = 1;\n-            hash = tag.tag | (s.hashCode() << 1);\n-        }\n-\n-        void setInteger(Integer i) {\n-            tag = PoolTag.INTEGER;\n-            o1 = i;\n-            size = 1;\n-            hash = tag.tag | (i.hashCode() << 1);\n-        }\n-\n-        void setFloat(Float f) {\n-            tag = PoolTag.FLOAT;\n-            o1 = f;\n-            size = 1;\n-            hash = tag.tag | (f.hashCode() << 1);\n-        }\n-\n-        void setLong(Long l) {\n-            tag = PoolTag.LONG;\n-            o1 = l;\n-            size = 1;\n-            hash = tag.tag | (l.hashCode() << 1);\n-        }\n-\n-        void setDouble(Double d) {\n-            tag = PoolTag.DOUBLE;\n-            o1 = d;\n-            size = 1;\n-            hash = tag.tag | (d.hashCode() << 1);\n-        }\n-\n-        void setMethodType(String type) {\n-            tag = PoolTag.METHODTYPE;\n-            o1 = type;\n-            size = 1;\n-            hash = tag.tag | (type.hashCode() << 1);\n-        }\n-\n-        void setMethodType(MethodType mt) {\n-            tag = PoolTag.METHODTYPE;\n-            o1 = mt;\n-            size = 1;\n-            hash = tag.tag | (mt.hashCode() << 1);\n-        }\n-\n-        void setMethodHandle(int bsmKind, String owner, CharSequence name, String type) {\n-            tag = PoolTag.METHODHANDLE;\n-            o1 = bsmKind;\n-            o2 = owner;\n-            o3 = name;\n-            o4 = type;\n-            size = 4;\n-            hash = tag.tag | (bsmKind | owner.hashCode() | name.hashCode() | type.hashCode() << 1);\n-        }\n-\n-        void setMethodHandle(MethodHandle mh) {\n-            tag = PoolTag.METHODHANDLE;\n-            o1 = mh;\n-            size = 1;\n-            hash = tag.tag | (mh.hashCode() << 1);\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            PoolKey that = (PoolKey) obj;\n-            if (tag != that.tag) return false;\n-            switch (size) {\n-                case 1:\n-                    if (!o1.equals(that.o1)) {\n-                        return false;\n-                    }\n-                    break;\n-                case 2:\n-                    if (!o2.equals(that.o2) || !o1.equals(that.o1)) {\n-                        return false;\n-                    }\n-                    break;\n-                case 3:\n-                    if (!o3.equals(that.o3) || !o2.equals(that.o2) || !o1.equals(that.o1)) {\n-                        return false;\n-                    }\n-                    break;\n-                case 4:\n-                    if (!o4.equals(that.o4) || !o3.equals(that.o3) || !o2.equals(that.o2) || !o1.equals(that.o1)) {\n-                        return false;\n-                    }\n-                    break;\n-            }\n-            return true;\n-        }\n-\n-        @Override\n-        PoolKey dup() {\n-            PoolKey poolKey = new PoolKey();\n-            poolKey.tag = tag;\n-            poolKey.size = size;\n-            poolKey.hash = hash;\n-            poolKey.o1 = o1;\n-            poolKey.o2 = o2;\n-            poolKey.o3 = o3;\n-            poolKey.o4 = o4;\n-            return poolKey;\n-        }\n-    }\n-\n-    static class BsmKey extends AbstractKey<BsmKey> {\n-        String bsmClass;\n-        CharSequence bsmName;\n-        String bsmType;\n-        List<Integer> bsmArgs;\n-\n-        void set(String bsmClass, CharSequence bsmName, String bsmType, List<Integer> bsmArgs) {\n-            this.bsmClass = bsmClass;\n-            this.bsmName = bsmName;\n-            this.bsmType = bsmType;\n-            this.bsmArgs = bsmArgs;\n-            hash = bsmClass.hashCode() | bsmName.hashCode() | bsmType.hashCode() | Objects.hash(bsmArgs);\n-        }\n-\n-        @Override\n-        BsmKey dup() {\n-            BsmKey bsmKey = new BsmKey();\n-            bsmKey.bsmClass = bsmClass;\n-            bsmKey.bsmName = bsmName;\n-            bsmKey.bsmType = bsmType;\n-            bsmKey.bsmArgs = bsmArgs;\n-            bsmKey.hash = hash;\n-            return bsmKey;\n-        }\n-\n-        \/\/TODO: missing hashCode()\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (obj instanceof BsmKey) {\n-                BsmKey that = (BsmKey)obj;\n-                return Objects.equals(bsmClass, that.bsmClass) &&\n-                        Objects.equals(bsmName, that.bsmName) &&\n-                        Objects.equals(bsmType, that.bsmType) &&\n-                        Objects.deepEquals(bsmArgs, that.bsmArgs);\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public int putClass(S symbol) {\n-        return putClassInternal(symbolToString.apply(symbol));\n-    }\n-\n-    @Override\n-    public int putValueClass(S symbol) {\n-        return putClassInternal(\"Q\" + symbolToString.apply(symbol) + \";\");\n-    }\n-\n-    private int putClassInternal(String symbol) {\n-        key.setClass(symbol);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int utf8_idx = putUtf8(symbol);\n-            poolKey.at(builder.putClass(utf8_idx));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putFieldRef(S owner, CharSequence name, T type) {\n-        return putMemberRef(PoolTag.FIELDREF, owner, name, type);\n-    }\n-\n-    @Override\n-    public int putMethodRef(S owner, CharSequence name, T type, boolean isInterface) {\n-        return putMemberRef(isInterface ? PoolTag.INTERFACEMETHODREF : PoolTag.METHODREF,\n-                owner, name, type);\n-    }\n-\n-    int putMemberRef(PoolTag poolTag, S owner, CharSequence name, T type) {\n-        return putMemberRefInternal(poolTag, symbolToString.apply(owner), name, typeToString.apply(type));\n-    }\n-\n-    int putMemberRefInternal(PoolTag poolTag, String owner, CharSequence name, String type) {\n-        key.setMemberRef(poolTag, owner, name, type);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int owner_idx = putClassInternal(owner);\n-            int nameAndType_idx = putNameAndType(name, type);\n-            poolKey.at(builder.putMemberRef(poolTag, owner_idx, nameAndType_idx));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putInt(int i) {\n-        key.setInteger(i);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            poolKey.at(builder.putInt(i));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putFloat(float f) {\n-        key.setFloat(f);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            poolKey.at(builder.putFloat(f));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putLong(long l) {\n-        key.setLong(l);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            poolKey.at(builder.putLong(l));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putDouble(double d) {\n-        key.setDouble(d);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            poolKey.at(builder.putDouble(d));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-\n-    @Override\n-    public int putInvokeDynamic(CharSequence invokedName, T invokedType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, byte[]>> staticArgs) {\n-        return putInvokeDynamicInternal(invokedName, typeToString.apply(invokedType), symbolToString.apply(bsmClass), bsmName, typeToString.apply(bsmType), staticArgs);\n-    }\n-\n-    @Override\n-    public int putConstantDynamic(CharSequence constName, T constType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, byte[]>> staticArgs) {\n-        return putConstantDynamicInternal(constName, typeToString.apply(constType), symbolToString.apply(bsmClass), bsmName, typeToString.apply(bsmType), staticArgs);\n-    }\n-\n-    private int putInvokeDynamicInternal(CharSequence invokedName, String invokedType, String bsmClass, CharSequence bsmName, String bsmType, Consumer<StaticArgListBuilder<S, T, byte[]>> staticArgs) {\n-        int bsmIndex = putBsmInternal(bsmClass, bsmName, bsmType, staticArgs);\n-        key.setInvokeDynamic(bsmIndex, invokedName, invokedType);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int nameAndType_idx = putNameAndType(invokedName, invokedType);\n-            poolKey.at(builder.putInvokeDynamic(bsmIndex, nameAndType_idx));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    private int putConstantDynamicInternal(CharSequence constName, String constType, String bsmClass, CharSequence bsmName, String bsmType, Consumer<StaticArgListBuilder<S, T, byte[]>> staticArgs) {\n-        int bsmIndex = putBsmInternal(bsmClass, bsmName, bsmType, staticArgs);\n-        key.setConstantDynamic(bsmIndex, constName, constType);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int nameAndType_idx = putNameAndType(constName, constType);\n-            poolKey.at(builder.putConstantDynamic(bsmIndex, nameAndType_idx));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    private int putBsmInternal(String bsmClass, CharSequence bsmName, String bsmType, Consumer<StaticArgListBuilder<S, T, byte[]>> staticArgs) {\n-        ByteStaticArgListBuilder staticArgsBuilder = new ByteStaticArgListBuilder();\n-        staticArgs.accept(staticArgsBuilder);\n-        List<Integer> static_idxs = staticArgsBuilder.indexes;\n-        bsmKey.set(bsmClass, bsmName, bsmType, static_idxs);\n-        BsmKey poolKey = bootstraps.lookup(bsmKey);\n-        if (poolKey == null) {\n-            poolKey = bsmKey.dup();\n-            int bsm_ref = putMethodHandleInternal(MethodHandleInfo.REF_invokeStatic, bsmClass, bsmName, bsmType, false);\n-            poolKey.at(currentBsmIndex++);\n-            bootstraps.enter(poolKey);\n-            bsm_attr.writeChar(bsm_ref);\n-            bsm_attr.writeChar(static_idxs.size());\n-            for (int i : static_idxs) {\n-                bsm_attr.writeChar(i);\n-            }\n-        }\n-        return poolKey.index;\n-    }\n-    \/\/where\n-        class ByteStaticArgListBuilder implements StaticArgListBuilder<S, T, byte[]> {\n-\n-            List<Integer> indexes = new ArrayList<>();\n-\n-            @Override\n-            public ByteStaticArgListBuilder add(int i) {\n-                indexes.add(putInt(i));\n-                return this;\n-            }\n-            @Override\n-            public ByteStaticArgListBuilder add(float f) {\n-                indexes.add(putFloat(f));\n-                return this;\n-            }\n-            @Override\n-            public ByteStaticArgListBuilder add(long l) {\n-                indexes.add(putLong(l));\n-                return this;\n-            }\n-            @Override\n-            public ByteStaticArgListBuilder add(double d) {\n-                indexes.add(putDouble(d));\n-                return this;\n-            }\n-            @Override\n-            public ByteStaticArgListBuilder add(String s) {\n-                indexes.add(putString(s));\n-                return this;\n-            }\n-            @Override\n-            public StaticArgListBuilder<S, T, byte[]> add(int refKind, S owner, CharSequence name, T type) {\n-                indexes.add(putMethodHandle(refKind, owner, name, type));\n-                return this;\n-            }\n-            @Override\n-            public <Z> ByteStaticArgListBuilder add(Z z, ToIntBiFunction<PoolHelper<S, T, byte[]>, Z> poolFunc) {\n-                indexes.add(poolFunc.applyAsInt(BytePoolHelper.this, z));\n-                return this;\n-            }\n-            @Override\n-            public ByteStaticArgListBuilder add(CharSequence constName, T constType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, byte[]>> staticArgs) {\n-                indexes.add(putConstantDynamic(constName, constType, bsmClass, bsmName, bsmType, staticArgs));\n-                return this;\n-            }\n-        }\n-\n-    @Override\n-    public int putMethodType(T s) {\n-        return putMethodTypeInternal(typeToString.apply(s));\n-    }\n-\n-    private int putMethodTypeInternal(String s) {\n-        key.setMethodType(s);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int desc_idx = putUtf8(s);\n-            poolKey.at(builder.putMethodType(desc_idx));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putMethodHandle(int refKind, S owner, CharSequence name, T type) {\n-        return putMethodHandle(refKind, owner, name, type, false);\n-    }\n-\n-    @Override\n-    public int putMethodHandle(int refKind, S owner, CharSequence name, T type, boolean isInterface) {\n-        return putMethodHandleInternal(refKind, symbolToString.apply(owner), name, typeToString.apply(type), isInterface);\n-    }\n-\n-    private int putMethodHandleInternal(int refKind, String owner, CharSequence name, String type, boolean isInterface) {\n-        key.setMethodHandle(refKind, owner, name, type);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int ref_idx = putMemberRefInternal(fromKind(refKind, isInterface), owner, name, type);\n-            poolKey.at(builder.putMethodHandle(refKind, ref_idx));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putValue(Object v) {\n-        if (v instanceof Class<?>) {\n-            return putClassInternal(((Class<?>) v).getName().replaceAll(\"\\\\.\", \"\/\"));\n-        } else if (v instanceof String) {\n-            key.setString((String) v);\n-            PoolKey poolKey = entries.lookup(key);\n-            if (poolKey == null) {\n-                poolKey = key.dup();\n-                int utf8_index = putUtf8((String) v);\n-                poolKey.at(builder.putString(utf8_index));\n-                entries.enter(poolKey);\n-            }\n-            return poolKey.index;\n-        } else if (v instanceof Integer) {\n-            key.setInteger((Integer) v);\n-            PoolKey poolKey = entries.lookup(key);\n-            if (poolKey == null) {\n-                poolKey = key.dup();\n-                poolKey.at(builder.putInt((Integer) v));\n-                entries.enter(poolKey);\n-            }\n-            return poolKey.index;\n-        } else if (v instanceof Float) {\n-            key.setFloat((Float) v);\n-            PoolKey poolKey = entries.lookup(key);\n-            if (poolKey == null) {\n-                poolKey = key.dup();\n-                poolKey.at(builder.putFloat((Float) v));\n-                entries.enter(poolKey);\n-            }\n-            return poolKey.index;\n-        } else if (v instanceof Double) {\n-            key.setDouble((Double) v);\n-            PoolKey poolKey = entries.lookup(key);\n-            if (poolKey == null) {\n-                poolKey = key.dup();\n-                poolKey.at(builder.putDouble((Double) v));\n-                entries.enter(poolKey);\n-            }\n-            return poolKey.index;\n-        } else if (v instanceof Long) {\n-            key.setLong((Long) v);\n-            PoolKey poolKey = entries.lookup(key);\n-            if (poolKey == null) {\n-                poolKey = key.dup();\n-                poolKey.at(builder.putLong((Long) v));\n-                entries.enter(poolKey);\n-            }\n-            return poolKey.index;\n-        } else if (v instanceof MethodHandle) {\n-            key.setMethodHandle((MethodHandle) v);\n-            PoolKey poolKey = entries.lookup(key);\n-            if (poolKey == null) {\n-                poolKey = key.dup();\n-                MethodHandle mh = (MethodHandle) v;\n-                Member member = memberFromHandle(mh);\n-                \/\/ ## TODO\n-                String type = null;   \/\/ type from handle\n-                int refKind = 0;      \/\/ kind for member\n-                PoolTag tag = null;   \/\/ tag for member\n-                int ref_idx = putMemberRefInternal(tag,\n-                    member.getDeclaringClass().getSimpleName(),\n-                    member.getName(),\n-                    type);\n-                poolKey.at(builder.putMethodHandle(refKind, ref_idx));\n-                entries.enter(poolKey);\n-            }\n-            return poolKey.index;\n-        } else if (v instanceof MethodType) {\n-            key.setMethodType((MethodType) v);\n-            PoolKey poolKey = entries.lookup(key);\n-            if (poolKey == null) {\n-                poolKey = key.dup();\n-                MethodType mt = (MethodType) v;\n-                int desc_idx = putUtf8(mt.toMethodDescriptorString());\n-                poolKey.at(builder.putMethodType(desc_idx));\n-                entries.enter(poolKey);\n-            }\n-            return poolKey.index;\n-        } else {\n-            throw new UnsupportedOperationException(\"Unsupported object class: \" + v.getClass().getName());\n-        }\n-    }\n-\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    private Member memberFromHandle(MethodHandle mh) {\n-        Class<Member>[] targets = new Class[]{Method.class, Field.class, Constructor.class};\n-        for (Class<Member> target : targets) {\n-            try {\n-                return MethodHandles.reflectAs(target, mh);\n-            } catch (ClassCastException ex) {\n-                \/\/swallow\n-            }\n-        }\n-        throw new UnsupportedOperationException(\"Cannot crack method handle!\");\n-    }\n-\n-    PoolTag fromKind(int bsmKind, boolean isInterface) {\n-        switch (bsmKind) {\n-            case 1: \/\/ REF_getField\n-            case 2: \/\/ REF_getStatic\n-            case 3: \/\/ REF_putField\n-            case 4: \/\/ REF_putStatic\n-                return PoolTag.FIELDREF;\n-            case 5: \/\/ REF_invokeVirtual\n-            case 7: \/\/ REF_invokeSpecial\n-            case 8: \/\/ REF_newInvokeSpecial\n-                return PoolTag.METHODREF;\n-            case 6: \/\/ REF_invokeStatic\n-            case 9: \/\/ REF_invokeInterface\n-                return isInterface ? PoolTag.INTERFACEMETHODREF : PoolTag.METHODREF;\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    @Override\n-    public int putType(T s) {\n-        return putUtf8(typeToString.apply(s));\n-    }\n-\n-    @Override\n-    public int putUtf8(CharSequence s) {\n-        key.setUtf8(s);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            poolKey.at(builder.putUtf8(s));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putString(String s) {\n-        key.setString(s);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int utf8_index = putUtf8(s);\n-            poolKey.at(builder.putString(utf8_index));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    public int putNameAndType(CharSequence name, String type) {\n-        key.setNameAndType(name, type);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int name_idx = putUtf8(name);\n-            int type_idx = putUtf8(type);\n-            poolKey.at(builder.putNameAndType(name_idx, type_idx));\n-            entries.enter(poolKey);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    \/**\n-     * @return the count of constant pool indicies.\n-     *\/\n-    @Override\n-    public int size() {\n-        return builder.size();\n-    }\n-\n-    \/**\n-     * @return the size in bytes of all constant pool entries.\n-     *\/\n-    @Override\n-    public byte[] representation() {\n-        return builder.representation();\n-    }\n-\n-    <Z extends ClassBuilder<S, T, Z>> void addAttributes(ClassBuilder<S , T, Z> cb) {\n-        if (currentBsmIndex > 0) {\n-            GrowableByteBuffer bsmAttrBuf = new GrowableByteBuffer();\n-            bsmAttrBuf.writeChar(currentBsmIndex);\n-            bsmAttrBuf.writeBytes(bsm_attr);\n-            cb.withAttribute(\"BootstrapMethods\", bsmAttrBuf.bytes());\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/BytePoolHelper.java","additions":0,"deletions":795,"binary":false,"changes":795,"status":"deleted"},{"patch":"@@ -1,254 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.function.Consumer;\n-\n-\/**\n- * Base class builder. The base of higher level class builders.\n- *\n- * @param <S> the type of symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <C> the type of this builder\n- *\/\n-public class ClassBuilder<S, T, C extends ClassBuilder<S, T, C>>\n-        extends DeclBuilder<S, T, byte[], C> {\n-\n-    \/**\n-     * The helper to use to manipulate type descriptors.\n-     *\/\n-    protected TypeHelper<S, T> typeHelper;\n-\n-    \/**\n-     * The symbol for the class being built.\n-     *\/\n-    protected S thisClass;\n-\n-    \/**\n-     * The super-interfaces of the class being built..\n-     *\/\n-    protected GrowableByteBuffer interfaces = new GrowableByteBuffer();\n-\n-    \/**\n-     * The fields of the class being built.\n-     *\/\n-    protected GrowableByteBuffer fields = new GrowableByteBuffer();\n-\n-    \/**\n-     * The methods of the class being built.\n-     *\/\n-    protected GrowableByteBuffer methods = new GrowableByteBuffer();\n-\n-    int majorVersion;\n-    int minorVersion;\n-    int flags;\n-    int superclass;\n-    int nmethods, nfields, ninterfaces;\n-\n-    \/**\n-     * Create a class builder.\n-     *\n-     * @param poolHelper the helper to build the constant pool\n-     * @param typeHelper the helper to use to manipulate type descriptors\n-     *\/\n-    public ClassBuilder(BytePoolHelper<S, T> poolHelper, TypeHelper<S, T> typeHelper) {\n-        super(poolHelper, typeHelper);\n-        this.typeHelper = typeHelper;\n-    }\n-\n-    \/**\n-     * Set the minor class file version.\n-     *\n-     * @param minorVersion the minor version number\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withMinorVersion(int minorVersion) {\n-        this.minorVersion = minorVersion;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Set the major class file version.\n-     *\n-     * @param majorVersion the major version number\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withMajorVersion(int majorVersion) {\n-        this.majorVersion = majorVersion;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Set the class symbol\n-     *\n-     * @param thisClass the class symbol\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withThisClass(S thisClass) {\n-        this.thisClass = thisClass;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Set the class access flags\n-     *\n-     * @param flags an array of {@code Flag}\n-     * @return this builder, for chained calls\n-     *\/\n-    @Override\n-    public C withFlags(Flag... flags) {\n-        for (Flag f : flags) {\n-            this.flags |= f.flag;\n-        }\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Set the superclass\n-     *\n-     * @param sup the superclass symbol\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withSuperclass(S sup) {\n-        this.superclass = poolHelper.putClass(sup);\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Add a super interface.\n-     *\n-     * @param sup an interface symbol\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withSuperinterface(S sup) {\n-        this.interfaces.writeChar(poolHelper.putClass(sup));\n-        ninterfaces++;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Add a field.\n-     *\n-     * @param name the name of the field\n-     * @param type the type descriptor of the field\n-     * @return this builder, for chained calls\n-     *\/\n-    public final C withField(CharSequence name, T type) {\n-        return withField(name, type, FB -> {\n-        });\n-    }\n-\n-    \/**\n-     * Add a field.\n-     *\n-     * @param name the name of the field\n-     * @param type the type descriptor of the field\n-     * @param fieldConfig access to the {@code FieldBuilder} to allow clients to\n-     * adjust flags, annotations and bytecode attributes on the field declaration\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withField(CharSequence name, T type, Consumer<? super FieldBuilder<S, T, byte[]>> fieldConfig) {\n-        FieldBuilder<S, T, byte[]> F = new FieldBuilder<>(name, type, poolHelper, typeHelper);\n-        fieldConfig.accept(F);\n-        F.build(fields);\n-        nfields++;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Add a method\n-     *\n-     * @param name the name of the method\n-     * @param type the type descriptor of the method\n-     * @return this builder, for chained calls\n-     *\/\n-    public final C withMethod(CharSequence name, T type) {\n-        return withMethod(name, type, MB -> {\n-        });\n-    }\n-\n-    \/**\n-     * Add a method\n-     *\n-     * @param name the name of the method\n-     * @param type the type descriptor of the method\n-     * @param methodConfig access to the {@code MethodBuilder} to allow clients to\n-     * adjust flags, annotations and bytecode attributes on the method declaration\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withMethod(CharSequence name, T type, Consumer<? super MethodBuilder<S, T, byte[]>> methodConfig) {\n-        MethodBuilder<S, T, byte[]> M = new MethodBuilder<>(thisClass, name, type, poolHelper, typeHelper);\n-        methodConfig.accept(M);\n-        M.build(methods);\n-        nmethods++;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Add a source file attribute.\n-     *\n-     * @param sourceFile name of the source file\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withSourceFile(String sourceFile) {\n-        GrowableByteBuffer a = new GrowableByteBuffer();\n-        a.writeChar(poolHelper.putUtf8(sourceFile));\n-        return withAttribute(\"SourceFile\", a.bytes());\n-    }\n-\n-    \/**\n-     * Build the constant pool into a byte array.\n-     *\n-     * @return a representation of this constant pool as a byte array\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public byte[] build() {\n-        ((BytePoolHelper<S, T>)poolHelper).addAttributes(this);\n-        addAnnotations();\n-        int thisClassIdx = poolHelper.putClass(thisClass);\n-        byte[] poolBytes = poolHelper.representation();\n-        GrowableByteBuffer buf = new GrowableByteBuffer();\n-        buf.writeInt(0xCAFEBABE);\n-        buf.writeChar(minorVersion);\n-        buf.writeChar(majorVersion);\n-        buf.writeChar(poolHelper.size() + 1);\n-        buf.writeBytes(poolBytes);\n-        buf.writeChar(flags);\n-        buf.writeChar(thisClassIdx);\n-        buf.writeChar(superclass);\n-        buf.writeChar(ninterfaces);\n-        if (ninterfaces > 0) {\n-            buf.writeBytes(interfaces);\n-        }\n-        buf.writeChar(nfields);\n-        buf.writeBytes(fields);\n-        buf.writeChar(nmethods);\n-        buf.writeBytes(methods);\n-        buf.writeChar(nattrs);\n-        buf.writeBytes(attributes);\n-        return buf.bytes();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/ClassBuilder.java","additions":0,"deletions":254,"binary":false,"changes":254,"status":"deleted"},{"patch":"@@ -1,1353 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import jdk.experimental.bytecode.PoolHelper.StaticArgListBuilder;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.function.BiFunction;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.ToIntFunction;\n-\n-\/**\n- * Builder for class file code attributes. A code attribute is defined:\n- * <pre>\n- * {@code\n- * Code_attribute {\n- *    u2 attribute_name_index;\n- *    u4 attribute_length;\n- *    u2 max_stack;\n- *    u2 max_locals;\n- *    u4 code_length;\n- *    u1 code[code_length];\n- *    u2 exception_table_length;\n- *    {   u2 start_pc;\n- *        u2 end_pc;\n- *        u2 handler_pc;\n- *        u2 catch_type;\n- *    } exception_table[exception_table_length];\n- *    u2 attributes_count;\n- *    attribute_info attributes[attributes_count];\n- * } }\n- * <\/pre>\n- *\n- * @param <S> the type of symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <E> the type of pool entries\n- * @param <C> the type of this code builder\n- *\/\n-public class CodeBuilder<S, T, E, C extends CodeBuilder<S, T, E, C>> extends AttributeBuilder<S, T, E, C> {\n-\n-    protected GrowableByteBuffer code = new GrowableByteBuffer();\n-    GrowableByteBuffer catchers = new GrowableByteBuffer();\n-    GrowableByteBuffer stackmaps = new GrowableByteBuffer();\n-    MethodBuilder<S, T, E> methodBuilder;\n-    int ncatchers;\n-    int stacksize = -1;\n-    int localsize = -1;\n-    int nstackmaps = 0;\n-\n-    public enum JumpMode {\n-        NARROW,\n-        WIDE;\n-    }\n-\n-    CodeBuilder(MethodBuilder<S, T, E> methodBuilder) {\n-        super(methodBuilder.poolHelper, methodBuilder.typeHelper);\n-        this.methodBuilder = methodBuilder;\n-    }\n-\n-    public C getstatic(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.GETSTATIC, type);\n-        code.writeChar(poolHelper.putFieldRef(owner, name, type));\n-        return thisBuilder();\n-    }\n-\n-    public C putstatic(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.PUTSTATIC, type);\n-        code.writeChar(poolHelper.putFieldRef(owner, name, type));\n-        return thisBuilder();\n-    }\n-\n-    public C getfield(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.GETFIELD, type);\n-        code.writeChar(poolHelper.putFieldRef(owner, name, type));\n-        return thisBuilder();\n-    }\n-\n-    public C putfield(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.PUTFIELD, type);\n-        code.writeChar(poolHelper.putFieldRef(owner, name, type));\n-        return thisBuilder();\n-    }\n-\n-    public C withfield(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.WITHFIELD, type);\n-        code.writeChar(poolHelper.putFieldRef(owner, name, type));\n-        return thisBuilder();\n-    }\n-\n-    public C invokevirtual(S owner, CharSequence name, T type, boolean isInterface) {\n-        emitOp(Opcode.INVOKEVIRTUAL, type);\n-        code.writeChar(poolHelper.putMethodRef(owner, name, type, isInterface));\n-        return thisBuilder();\n-    }\n-\n-    public C invokespecial(S owner, CharSequence name, T type, boolean isInterface) {\n-        emitOp(Opcode.INVOKESPECIAL, type);\n-        code.writeChar(poolHelper.putMethodRef(owner, name, type, isInterface));\n-        return thisBuilder();\n-    }\n-\n-    public C invokestatic(S owner, CharSequence name, T type, boolean isInterface) {\n-        emitOp(Opcode.INVOKESTATIC, type);\n-        code.writeChar(poolHelper.putMethodRef(owner, name, type, isInterface));\n-        return thisBuilder();\n-    }\n-\n-    public C invokeinterface(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.INVOKEINTERFACE, type);\n-        code.writeChar(poolHelper.putMethodRef(owner, name, type, true));\n-        int nargs = 1;\n-        Iterator<T> it = typeHelper.parameterTypes(type);\n-        while (it.hasNext()) {\n-            nargs += typeHelper.tag(it.next()).width;\n-        }\n-        code.writeByte(nargs);\n-        code.writeByte(0);\n-        return thisBuilder();\n-    }\n-\n-    public C invokedynamic(CharSequence invokedName, T invokedType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, E>> staticArgs) {\n-        emitOp(Opcode.INVOKEDYNAMIC, invokedType);\n-        code.writeChar(poolHelper.putInvokeDynamic(invokedName, invokedType, bsmClass, bsmName, bsmType, staticArgs));\n-        code.writeChar(0); \/\/padding\n-        return thisBuilder();\n-    }\n-\n-    public C new_(S clazz) {\n-        emitOp(Opcode.NEW, clazz);\n-        code.writeChar(poolHelper.putClass(clazz));\n-        return thisBuilder();\n-    }\n-\n-    public C defaultvalue(S target) {\n-        emitOp(Opcode.DEFAULTVALUE, target);\n-        code.writeChar(poolHelper.putClass(target));\n-        return thisBuilder();\n-    }\n-\n-    public C newarray(TypeTag tag) {\n-        emitOp(Opcode.NEWARRAY, tag);\n-        int newarraycode = tag.newarraycode;\n-        if (newarraycode == -1) {\n-            throw new IllegalStateException(\"Bad tag \" + tag);\n-        }\n-        code.writeByte(newarraycode);\n-        return thisBuilder();\n-    }\n-\n-    public C anewarray(S array) {\n-        emitOp(Opcode.ANEWARRAY, array);\n-        code.writeChar(poolHelper.putClass(array));\n-        return thisBuilder();\n-    }\n-\n-    public C anewvaluearray(S array) {\n-        emitOp(Opcode.ANEWARRAY, array);\n-        code.writeChar(poolHelper.putValueClass(array));\n-        return thisBuilder();\n-    }\n-\n-    public C checkcast(S target) {\n-        emitOp(Opcode.CHECKCAST);\n-        code.writeChar(poolHelper.putClass(target));\n-        return thisBuilder();\n-    }\n-\n-    public C checkvaluecast(S target) {\n-        emitOp(Opcode.CHECKCAST);\n-        code.writeChar(poolHelper.putValueClass(target));\n-        return thisBuilder();\n-    }\n-\n-    public C instanceof_(S target) {\n-        emitOp(Opcode.INSTANCEOF);\n-        code.writeChar(poolHelper.putClass(target));\n-        return thisBuilder();\n-    }\n-\n-    public C multianewarray(S array, byte dims) {\n-        emitOp(Opcode.MULTIANEWARRAY, new Object[]{array, dims});\n-        code.writeChar(poolHelper.putClass(array)).writeByte(dims);\n-        return thisBuilder();\n-    }\n-\n-    public C ldc(int i) {\n-        return ldc(pool -> pool.putInt(i), false);\n-    }\n-\n-    public C ldc(long l) {\n-        return ldc(pool -> pool.putLong(l), true);\n-    }\n-\n-    public C ldc(float f) {\n-        return ldc(pool -> pool.putFloat(f), false);\n-    }\n-\n-    public C ldc(double d) {\n-        return ldc(pool -> pool.putDouble(d), true);\n-    }\n-\n-    public C ldc(String s) {\n-        return ldc(pool -> pool.putString(s), false);\n-    }\n-\n-    public C ldc(CharSequence constName, T constType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, E>> staticArgs) {\n-        boolean fat = typeHelper.tag(constType).width() == 2;\n-        return ldc(pool -> pool.putConstantDynamic(constName, constType, bsmClass, bsmName, bsmType, staticArgs), fat);\n-    }\n-\n-    public <Z> C ldc(Z z, BiFunction<PoolHelper<S, T, E>, Z, Integer> poolFunc) {\n-        return ldc(pool -> poolFunc.apply(pool, z), false);\n-    }\n-\n-\n-    protected C ldc(ToIntFunction<PoolHelper<S, T, E>> indexFunc, boolean fat) {\n-        \/\/ @@@ This should probably be abstract\n-        int index = indexFunc.applyAsInt(poolHelper);\n-        return ldc(index, null, fat);\n-    }\n-\n-    protected final C ldc(int index, T type, boolean fat) {\n-        if (fat) {\n-            emitOp(Opcode.LDC2_W, type);\n-            code.writeChar(index);\n-        } else if (index > 63) {\n-            emitOp(Opcode.LDC_W, type);\n-            code.writeChar(index);\n-        } else {\n-            emitOp(Opcode.LDC, type);\n-            code.writeByte(index);\n-        }\n-        return thisBuilder();\n-    }\n-\n-    public C ldc(MethodHandle o) {\n-        return ldc(o, false);\n-    }\n-\n-    public C ldc(MethodType o) {\n-        return ldc(o, false);\n-    }\n-\n-    public C ldc(Object o) {\n-        emitOp(Opcode.LDC, o);\n-        code.writeByte(poolHelper.putValue(o));\n-        return thisBuilder();\n-    }\n-\n-    public C ldc_w(Object o) {\n-        emitOp(Opcode.LDC_W, o);\n-        code.writeChar(poolHelper.putValue(o));\n-        return thisBuilder();\n-    }\n-\n-    public C ldc2_w(Object o) {\n-        emitOp(Opcode.LDC2_W, o);\n-        code.writeChar(poolHelper.putValue(o));\n-        return thisBuilder();\n-    }\n-\n-    private final C ldc(Object o, boolean fat) {\n-        int idx = poolHelper.putValue(o);\n-        if (fat) {\n-            return ldc2_w(o);\n-        } else if (idx > 63) {\n-            return ldc_w(o);\n-        } else {\n-            return ldc(o);\n-        }\n-    }\n-\n-    \/\/other non-CP dependent opcodes\n-    public C areturn() {\n-        return emitOp(Opcode.ARETURN);\n-    }\n-\n-    public C ireturn() {\n-        return emitOp(Opcode.IRETURN);\n-    }\n-\n-    public C freturn() {\n-        return emitOp(Opcode.FRETURN);\n-    }\n-\n-    public C lreturn() {\n-        return emitOp(Opcode.LRETURN);\n-    }\n-\n-    public C dreturn() {\n-        return emitOp(Opcode.DRETURN);\n-    }\n-\n-    public C return_() {\n-        return emitOp(Opcode.RETURN);\n-    }\n-\n-    protected C emitWideIfNeeded(Opcode opcode, int n) {\n-        boolean wide = n > Byte.MAX_VALUE;\n-        if (wide) {\n-            wide();\n-        }\n-        emitOp(opcode, n);\n-        if (wide) {\n-            code.writeChar(n);\n-        } else {\n-            code.writeByte(n);\n-        }\n-        return thisBuilder();\n-    }\n-\n-    protected C emitWideIfNeeded(Opcode opcode, int n, int v) {\n-        boolean wide = n > Byte.MAX_VALUE || v > Byte.MAX_VALUE;\n-        if (wide) {\n-            wide();\n-        }\n-        emitOp(opcode, n);\n-        if (wide) {\n-            code.writeChar(n).writeChar(v);\n-        } else {\n-            code.writeByte(n).writeByte(v);\n-        }\n-        return thisBuilder();\n-    }\n-\n-    public TypedBuilder typed(TypeTag typeTag) {\n-        return typed(typeTag, _unused -> new TypedBuilder());\n-    }\n-\n-    protected <TB extends TypedBuilder> TB typed(TypeTag typeTag, Function<TypeTag, TB> typedBuilderFunc) {\n-        emitOp(Opcode.TYPED);\n-        code.writeChar(poolHelper.putType(typeHelper.fromTag(typeTag)));\n-        return typedBuilderFunc.apply(typeTag);\n-    }\n-\n-    public class TypedBuilder {\n-        public C aload_0() {\n-            return CodeBuilder.this.aload_0();\n-        }\n-\n-        public C aload_1() {\n-            return CodeBuilder.this.aload_1();\n-        }\n-\n-        public C aload_2() {\n-            return CodeBuilder.this.aload_2();\n-        }\n-\n-        public C aload_3() {\n-            return CodeBuilder.this.aload_3();\n-        }\n-\n-        public C aload(int n) {\n-            return CodeBuilder.this.aload(n);\n-        }\n-\n-        public C astore_0() {\n-            return CodeBuilder.this.astore_0();\n-        }\n-\n-        public C astore_1() {\n-            return CodeBuilder.this.astore_1();\n-        }\n-\n-        public C astore_2() {\n-            return CodeBuilder.this.astore_2();\n-        }\n-\n-        public C astore_3() {\n-            return CodeBuilder.this.astore_3();\n-        }\n-\n-        public C astore(int n) {\n-            return CodeBuilder.this.astore(n);\n-        }\n-\n-        public C aaload() {\n-            return CodeBuilder.this.aaload();\n-        }\n-\n-        public C aastore() {\n-            return CodeBuilder.this.aastore();\n-        }\n-\n-        public C areturn() {\n-            return CodeBuilder.this.areturn();\n-        }\n-\n-        public C anewarray(S s) {\n-            return CodeBuilder.this.anewarray(s);\n-        }\n-\n-        public C anewvaluearray(S s) {\n-            return CodeBuilder.this.anewvaluearray(s);\n-        }\n-\n-        public C aconst_null() {\n-            return CodeBuilder.this.aconst_null();\n-        }\n-\n-        public C if_acmpeq(short target) {\n-            return CodeBuilder.this.if_acmpeq(target);\n-        }\n-\n-        public C if_acmpne(short target) {\n-            return CodeBuilder.this.if_acmpeq(target);\n-        }\n-    }\n-\n-    public C aload(int i) {\n-        return emitWideIfNeeded(Opcode.ALOAD, i);\n-    }\n-\n-    public C iload(int i) {\n-        return emitWideIfNeeded(Opcode.ILOAD, i);\n-    }\n-\n-    public C fload(int i) {\n-        return emitWideIfNeeded(Opcode.FLOAD, i);\n-    }\n-\n-    public C lload(int i) {\n-        return emitWideIfNeeded(Opcode.LLOAD, i);\n-    }\n-\n-    public C dload(int i) {\n-        return emitWideIfNeeded(Opcode.DLOAD, i);\n-    }\n-\n-    public C aload_0() {\n-        return emitOp(Opcode.ALOAD_0);\n-    }\n-\n-    public C iload_0() {\n-        return emitOp(Opcode.ILOAD_0);\n-    }\n-\n-    public C fload_0() {\n-        return emitOp(Opcode.FLOAD_0);\n-    }\n-\n-    public C lload_0() {\n-        return emitOp(Opcode.LLOAD_0);\n-    }\n-\n-    public C dload_0() {\n-        return emitOp(Opcode.DLOAD_0);\n-    }\n-\n-    public C aload_1() {\n-        return emitOp(Opcode.ALOAD_1);\n-    }\n-\n-    public C iload_1() {\n-        return emitOp(Opcode.ILOAD_1);\n-    }\n-\n-    public C fload_1() {\n-        return emitOp(Opcode.FLOAD_1);\n-    }\n-\n-    public C lload_1() {\n-        return emitOp(Opcode.LLOAD_1);\n-    }\n-\n-    public C dload_1() {\n-        return emitOp(Opcode.DLOAD_1);\n-    }\n-\n-    public C aload_2() {\n-        return emitOp(Opcode.ALOAD_2);\n-    }\n-\n-    public C iload_2() {\n-        return emitOp(Opcode.ILOAD_2);\n-    }\n-\n-    public C fload_2() {\n-        return emitOp(Opcode.FLOAD_2);\n-    }\n-\n-    public C lload_2() {\n-        return emitOp(Opcode.LLOAD_2);\n-    }\n-\n-    public C dload_2() {\n-        return emitOp(Opcode.DLOAD_2);\n-    }\n-\n-    public C aload_3() {\n-        return emitOp(Opcode.ALOAD_3);\n-    }\n-\n-    public C iload_3() {\n-        return emitOp(Opcode.ILOAD_3);\n-    }\n-\n-    public C fload_3() {\n-        return emitOp(Opcode.FLOAD_3);\n-    }\n-\n-    public C lload_3() {\n-        return emitOp(Opcode.LLOAD_3);\n-    }\n-\n-    public C dload_3() {\n-        return emitOp(Opcode.DLOAD_3);\n-    }\n-\n-    public C astore(int i) {\n-        return emitWideIfNeeded(Opcode.ASTORE, i);\n-    }\n-\n-    public C istore(int i) {\n-        return emitWideIfNeeded(Opcode.ISTORE, i);\n-    }\n-\n-    public C fstore(int i) {\n-        return emitWideIfNeeded(Opcode.FSTORE, i);\n-    }\n-\n-    public C lstore(int i) {\n-        return emitWideIfNeeded(Opcode.LSTORE, i);\n-    }\n-\n-    public C dstore(int i) {\n-        return emitWideIfNeeded(Opcode.DSTORE, i);\n-    }\n-\n-    public C astore_0() {\n-        return emitOp(Opcode.ASTORE_0);\n-    }\n-\n-    public C istore_0() {\n-        return emitOp(Opcode.ISTORE_0);\n-    }\n-\n-    public C fstore_0() {\n-        return emitOp(Opcode.FSTORE_0);\n-    }\n-\n-    public C lstore_0() {\n-        return emitOp(Opcode.LSTORE_0);\n-    }\n-\n-    public C dstore_0() {\n-        return emitOp(Opcode.DSTORE_0);\n-    }\n-\n-    public C astore_1() {\n-        return emitOp(Opcode.ASTORE_1);\n-    }\n-\n-    public C istore_1() {\n-        return emitOp(Opcode.ISTORE_1);\n-    }\n-\n-    public C fstore_1() {\n-        return emitOp(Opcode.FSTORE_1);\n-    }\n-\n-    public C lstore_1() {\n-        return emitOp(Opcode.LSTORE_1);\n-    }\n-\n-    public C dstore_1() {\n-        return emitOp(Opcode.DSTORE_1);\n-    }\n-\n-    public C astore_2() {\n-        return emitOp(Opcode.ASTORE_2);\n-    }\n-\n-    public C istore_2() {\n-        return emitOp(Opcode.ISTORE_2);\n-    }\n-\n-    public C fstore_2() {\n-        return emitOp(Opcode.FSTORE_2);\n-    }\n-\n-    public C lstore_2() {\n-        return emitOp(Opcode.LSTORE_2);\n-    }\n-\n-    public C dstore_2() {\n-        return emitOp(Opcode.DSTORE_2);\n-    }\n-\n-    public C astore_3() {\n-        return emitOp(Opcode.ASTORE_3);\n-    }\n-\n-    public C istore_3() {\n-        return emitOp(Opcode.ISTORE_3);\n-    }\n-\n-    public C fstore_3() {\n-        return emitOp(Opcode.FSTORE_3);\n-    }\n-\n-    public C lstore_3() {\n-        return emitOp(Opcode.LSTORE_3);\n-    }\n-\n-    public C dstore_3() {\n-        return emitOp(Opcode.DSTORE_3);\n-    }\n-\n-    \/\/...\n-\n-    public C iaload() {\n-        return emitOp(Opcode.IALOAD);\n-    }\n-\n-    public C laload() {\n-        return emitOp(Opcode.LALOAD);\n-    }\n-\n-    public C faload() {\n-        return emitOp(Opcode.FALOAD);\n-    }\n-\n-    public C daload() {\n-        return emitOp(Opcode.DALOAD);\n-    }\n-\n-    public C aaload() {\n-        return emitOp(Opcode.AALOAD);\n-    }\n-\n-    public C baload() {\n-        return emitOp(Opcode.BALOAD);\n-    }\n-\n-    public C caload() {\n-        return emitOp(Opcode.CALOAD);\n-    }\n-\n-    public C saload() {\n-        return emitOp(Opcode.SALOAD);\n-    }\n-\n-    public C iastore() {\n-        return emitOp(Opcode.IASTORE);\n-    }\n-\n-    public C lastore() {\n-        return emitOp(Opcode.LASTORE);\n-    }\n-\n-    public C fastore() {\n-        return emitOp(Opcode.FASTORE);\n-    }\n-\n-    public C dastore() {\n-        return emitOp(Opcode.DASTORE);\n-    }\n-\n-    public C aastore() {\n-        return emitOp(Opcode.AASTORE);\n-    }\n-\n-    public C bastore() {\n-        return emitOp(Opcode.BASTORE);\n-    }\n-\n-    public C castore() {\n-        return emitOp(Opcode.CASTORE);\n-    }\n-\n-    public C sastore() {\n-        return emitOp(Opcode.SASTORE);\n-    }\n-\n-    public C nop() {\n-        return emitOp(Opcode.NOP);\n-    }\n-\n-    public C aconst_null() {\n-        return emitOp(Opcode.ACONST_NULL);\n-    }\n-\n-    public C iconst_0() {\n-        return emitOp(Opcode.ICONST_0);\n-    }\n-\n-    public C iconst_1() {\n-        return emitOp(Opcode.ICONST_1);\n-    }\n-\n-    public C iconst_2() {\n-        return emitOp(Opcode.ICONST_2);\n-    }\n-\n-    public C iconst_3() {\n-        return emitOp(Opcode.ICONST_3);\n-    }\n-\n-    public C iconst_4() {\n-        return emitOp(Opcode.ICONST_4);\n-    }\n-\n-    public C iconst_5() {\n-        return emitOp(Opcode.ICONST_5);\n-    }\n-\n-    public C iconst_m1() {\n-        return emitOp(Opcode.ICONST_M1);\n-    }\n-\n-    public C lconst_0() {\n-        return emitOp(Opcode.LCONST_0);\n-    }\n-\n-    public C lconst_1() {\n-        return emitOp(Opcode.LCONST_1);\n-    }\n-\n-    public C fconst_0() {\n-        return emitOp(Opcode.FCONST_0);\n-    }\n-\n-    public C fconst_1() {\n-        return emitOp(Opcode.FCONST_1);\n-    }\n-\n-    public C fconst_2() {\n-        return emitOp(Opcode.FCONST_2);\n-    }\n-\n-    public C dconst_0() {\n-        return emitOp(Opcode.DCONST_0);\n-    }\n-\n-    public C dconst_1() {\n-        return emitOp(Opcode.DCONST_1);\n-    }\n-\n-    public C sipush(int s) {\n-        emitOp(Opcode.SIPUSH);\n-        code.writeChar(s);\n-        return thisBuilder();\n-    }\n-\n-    public C bipush(int b) {\n-        emitOp(Opcode.BIPUSH);\n-        code.writeByte(b);\n-        return thisBuilder();\n-    }\n-\n-    public C pop() {\n-        return emitOp(Opcode.POP);\n-    }\n-\n-    public C pop2() {\n-        return emitOp(Opcode.POP2);\n-    }\n-\n-    public C dup() {\n-        return emitOp(Opcode.DUP);\n-    }\n-\n-    public C dup_x1() {\n-        return emitOp(Opcode.DUP_X1);\n-    }\n-\n-    public C dup_x2() {\n-        return emitOp(Opcode.DUP_X2);\n-    }\n-\n-    public C dup2() {\n-        return emitOp(Opcode.DUP2);\n-    }\n-\n-    public C dup2_x1() {\n-        return emitOp(Opcode.DUP2_X1);\n-    }\n-\n-    public C dup2_x2() {\n-        return emitOp(Opcode.DUP2_X2);\n-    }\n-\n-    public C swap() {\n-        return emitOp(Opcode.SWAP);\n-    }\n-\n-    public C iadd() {\n-        return emitOp(Opcode.IADD);\n-    }\n-\n-    public C ladd() {\n-        return emitOp(Opcode.LADD);\n-    }\n-\n-    public C fadd() {\n-        return emitOp(Opcode.FADD);\n-    }\n-\n-    public C dadd() {\n-        return emitOp(Opcode.DADD);\n-    }\n-\n-    public C isub() {\n-        return emitOp(Opcode.ISUB);\n-    }\n-\n-    public C lsub() {\n-        return emitOp(Opcode.LSUB);\n-    }\n-\n-    public C fsub() {\n-        return emitOp(Opcode.FSUB);\n-    }\n-\n-    public C dsub() {\n-        return emitOp(Opcode.DSUB);\n-    }\n-\n-    public C imul() {\n-        return emitOp(Opcode.IMUL);\n-    }\n-\n-    public C lmul() {\n-        return emitOp(Opcode.LMUL);\n-    }\n-\n-    public C fmul() {\n-        return emitOp(Opcode.FMUL);\n-    }\n-\n-    public C dmul() {\n-        return emitOp(Opcode.DMUL);\n-    }\n-\n-    public C idiv() {\n-        return emitOp(Opcode.IDIV);\n-    }\n-\n-    public C ldiv() {\n-        return emitOp(Opcode.LDIV);\n-    }\n-\n-    public C fdiv() {\n-        return emitOp(Opcode.FDIV);\n-    }\n-\n-    public C ddiv() {\n-        return emitOp(Opcode.DDIV);\n-    }\n-\n-    public C irem() {\n-        return emitOp(Opcode.IREM);\n-    }\n-\n-    public C lrem() {\n-        return emitOp(Opcode.LREM);\n-    }\n-\n-    public C frem() {\n-        return emitOp(Opcode.FREM);\n-    }\n-\n-    public C drem() {\n-        return emitOp(Opcode.DREM);\n-    }\n-\n-    public C ineg() {\n-        return emitOp(Opcode.INEG);\n-    }\n-\n-    public C lneg() {\n-        return emitOp(Opcode.LNEG);\n-    }\n-\n-    public C fneg() {\n-        return emitOp(Opcode.FNEG);\n-    }\n-\n-    public C dneg() {\n-        return emitOp(Opcode.DNEG);\n-    }\n-\n-    public C ishl() {\n-        return emitOp(Opcode.ISHL);\n-    }\n-\n-    public C lshl() {\n-        return emitOp(Opcode.LSHL);\n-    }\n-\n-    public C ishr() {\n-        return emitOp(Opcode.ISHR);\n-    }\n-\n-    public C lshr() {\n-        return emitOp(Opcode.LSHR);\n-    }\n-\n-    public C iushr() {\n-        return emitOp(Opcode.IUSHR);\n-    }\n-\n-    public C lushr() {\n-        return emitOp(Opcode.LUSHR);\n-    }\n-\n-    public C iand() {\n-        return emitOp(Opcode.IAND);\n-    }\n-\n-    public C land() {\n-        return emitOp(Opcode.LAND);\n-    }\n-\n-    public C ior() {\n-        return emitOp(Opcode.IOR);\n-    }\n-\n-    public C lor() {\n-        return emitOp(Opcode.LOR);\n-    }\n-\n-    public C ixor() {\n-        return emitOp(Opcode.IXOR);\n-    }\n-\n-    public C lxor() {\n-        return emitOp(Opcode.LXOR);\n-    }\n-\n-    public C iinc(int index, int val) {\n-        return emitWideIfNeeded(Opcode.IINC, index, val);\n-    }\n-\n-    public C i2l() {\n-        return emitOp(Opcode.I2L);\n-    }\n-\n-    public C i2f() {\n-        return emitOp(Opcode.I2F);\n-    }\n-\n-    public C i2d() {\n-        return emitOp(Opcode.I2D);\n-    }\n-\n-    public C l2i() {\n-        return emitOp(Opcode.L2I);\n-    }\n-\n-    public C l2f() {\n-        return emitOp(Opcode.L2F);\n-    }\n-\n-    public C l2d() {\n-        return emitOp(Opcode.L2D);\n-    }\n-\n-    public C f2i() {\n-        return emitOp(Opcode.F2I);\n-    }\n-\n-    public C f2l() {\n-        return emitOp(Opcode.F2L);\n-    }\n-\n-    public C f2d() {\n-        return emitOp(Opcode.F2D);\n-    }\n-\n-    public C d2i() {\n-        return emitOp(Opcode.D2I);\n-    }\n-\n-    public C d2l() {\n-        return emitOp(Opcode.D2L);\n-    }\n-\n-    public C d2f() {\n-        return emitOp(Opcode.D2F);\n-    }\n-\n-    public C i2b() {\n-        return emitOp(Opcode.I2B);\n-    }\n-\n-    public C i2c() {\n-        return emitOp(Opcode.I2C);\n-    }\n-\n-    public C i2s() {\n-        return emitOp(Opcode.I2S);\n-    }\n-\n-    public C lcmp() {\n-        return emitOp(Opcode.LCMP);\n-    }\n-\n-    public C fcmpl() {\n-        return emitOp(Opcode.FCMPL);\n-    }\n-\n-    public C fcmpg() {\n-        return emitOp(Opcode.FCMPG);\n-    }\n-\n-    public C dcmpl() {\n-        return emitOp(Opcode.DCMPL);\n-    }\n-\n-    public C dcmpg() {\n-        return emitOp(Opcode.DCMPG);\n-    }\n-\n-    public C ifeq(short target) {\n-        return emitNarrowJumpOp(Opcode.IFEQ, target);\n-    }\n-\n-    public C ifne(short target) {\n-        return emitNarrowJumpOp(Opcode.IFNE, target);\n-    }\n-\n-    public C iflt(short target) {\n-        return emitNarrowJumpOp(Opcode.IFLT, target);\n-    }\n-\n-    public C ifge(short target) {\n-        return emitNarrowJumpOp(Opcode.IFGE, target);\n-    }\n-\n-    public C ifgt(short target) {\n-        return emitNarrowJumpOp(Opcode.IFGT, target);\n-    }\n-\n-    public C ifle(short target) {\n-        return emitNarrowJumpOp(Opcode.IFLE, target);\n-    }\n-\n-    public C if_icmpeq(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ICMPEQ, target);\n-    }\n-\n-    public C if_icmpne(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ICMPNE, target);\n-    }\n-\n-    public C if_icmplt(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ICMPLT, target);\n-    }\n-\n-    public C if_icmpge(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ICMPGE, target);\n-    }\n-\n-    public C if_icmpgt(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ICMPGT, target);\n-    }\n-\n-    public C if_icmple(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ICMPLE, target);\n-    }\n-\n-    public C if_acmpeq(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ACMPEQ, target);\n-    }\n-\n-    public C if_acmpne(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ACMPNE, target);\n-    }\n-\n-    public C goto_(short target) {\n-        return emitNarrowJumpOp(Opcode.GOTO_, target);\n-    }\n-\n-    public C jsr(short target) {\n-        return emitNarrowJumpOp(Opcode.JSR, target);\n-    }\n-\n-    public C ret(int index) {\n-        return emitWideIfNeeded(Opcode.RET, index);\n-    }\n-\n-    public C tableswitch(int low, int high, int defaultTarget, int... targets) {\n-        if (high - low + 1 != targets.length) throw new IllegalStateException(\"Bad targets length\");\n-        emitOp(Opcode.TABLESWITCH);\n-        \/\/padding\n-        int start = code.offset;\n-        if ((start % 4) != 0) {\n-            \/\/add padding\n-            for (int i = 0; i < 4 - (start % 4); i++) {\n-                code.writeByte(0);\n-            }\n-        }\n-        code.writeInt(defaultTarget)\n-                .writeInt(low)\n-                .writeInt(high);\n-        for (int target : targets) {\n-            code.writeInt(target);\n-        }\n-        return thisBuilder();\n-    }\n-\n-    public C lookupswitch(int defaultTarget, int... npairs) {\n-        if (npairs.length % 2 != 0) throw new IllegalStateException(\"Bad npairs length\");\n-        emitOp(Opcode.LOOKUPSWITCH);\n-        \/\/padding\n-        int start = code.offset;\n-        for (int i = 0; i < (4 - (start % 4)); i++) {\n-            code.writeByte(0);\n-        }\n-        code.writeInt(defaultTarget)\n-                .writeInt(npairs.length \/ 2);\n-        for (int i = 0; i < npairs.length; i += 2) {\n-            code.writeInt(npairs[i]);\n-            code.writeInt(npairs[i + 1]);\n-        }\n-        return thisBuilder();\n-    }\n-\n-    public C arraylength() {\n-        return emitOp(Opcode.ARRAYLENGTH);\n-    }\n-\n-    public C athrow() {\n-        return emitOp(Opcode.ATHROW);\n-    }\n-\n-    public C monitorenter() {\n-        return emitOp(Opcode.MONITORENTER);\n-    }\n-\n-    public C monitorexit() {\n-        return emitOp(Opcode.MONITOREXIT);\n-    }\n-\n-    public C wide() {\n-        return emitOp(Opcode.WIDE);\n-    }\n-\n-    public C if_null(short offset) {\n-        return emitNarrowJumpOp(Opcode.IF_NULL, offset);\n-    }\n-\n-    public C if_nonnull(short offset) {\n-        return emitNarrowJumpOp(Opcode.IF_NONNULL, offset);\n-    }\n-\n-    public C goto_w(int target) {\n-        return emitWideJumpOp(Opcode.GOTO_W, target);\n-    }\n-\n-    public C jsr_w(int target) {\n-        return emitWideJumpOp(Opcode.JSR_W, target);\n-    }\n-\n-    public C withCatch(S type, int start, int end, int offset) {\n-        catchers.writeChar(start);\n-        catchers.writeChar(end);\n-        catchers.writeChar(offset);\n-        catchers.writeChar(type != null ? poolHelper.putClass(type) : 0);\n-        ncatchers++;\n-        return thisBuilder();\n-    }\n-\n-    public C withLocalSize(int localsize) {\n-        this.localsize = localsize;\n-        return thisBuilder();\n-    }\n-\n-    public C withStackSize(int stacksize) {\n-        this.stacksize = stacksize;\n-        return thisBuilder();\n-    }\n-\n-    protected int localsize() {\n-        return localsize;\n-    }\n-\n-    void build(GrowableByteBuffer buf) {\n-        buf.writeChar(stacksize); \/\/max stack size\n-        buf.writeChar(localsize()); \/\/max locals\n-        buf.writeInt(code.offset);\n-        buf.writeBytes(code);\n-        buf.writeChar(ncatchers);\n-        buf.writeBytes(catchers);\n-        buf.writeChar(nattrs); \/\/attributes\n-        buf.writeBytes(attributes);\n-    }\n-\n-    byte[] build() {\n-        GrowableByteBuffer buf = new GrowableByteBuffer();\n-        build(buf);\n-        return buf.bytes();\n-    }\n-\n-    protected C emitNarrowJumpOp(Opcode opcode, short target) {\n-        emitOp(opcode);\n-        emitOffset(code, JumpMode.NARROW, target);\n-        return thisBuilder();\n-    }\n-\n-    protected C emitWideJumpOp(Opcode opcode, int target) {\n-        emitOp(opcode);\n-        emitOffset(code, JumpMode.WIDE, target);\n-        return thisBuilder();\n-    }\n-\n-    protected C emitOp(Opcode opcode) {\n-        return emitOp(opcode, null);\n-    }\n-\n-    protected C emitOp(Opcode opcode, Object optPoolValue) {\n-        code.writeByte(opcode.code);\n-        return thisBuilder();\n-    }\n-\n-    protected void emitOffset(GrowableByteBuffer buf, JumpMode jumpMode, int offset) {\n-        if (jumpMode == JumpMode.NARROW) {\n-            buf.writeChar((short) offset);\n-        } else {\n-            buf.writeInt(offset);\n-        }\n-    }\n-\n-    int offset() {\n-        return code.offset;\n-    }\n-\n-    \/*** stackmap support ***\/\n-\n-    \/**\n-     * The tags and constants used in compressed stackmap.\n-     *\/\n-    static final int SAME_FRAME_SIZE = 64;\n-    static final int SAME_LOCALS_1_STACK_ITEM_EXTENDED = 247;\n-    static final int SAME_FRAME_EXTENDED = 251;\n-    static final int FULL_FRAME = 255;\n-    static final int MAX_LOCAL_LENGTH_DIFF = 4;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void writeStackMapType(T t) {\n-        if (t == null) {\n-            stackmaps.writeByte(0);\n-        } else {\n-            switch (typeHelper.tag(t)) {\n-                case B:\n-                case C:\n-                case S:\n-                case I:\n-                case Z:\n-                    stackmaps.writeByte(1);\n-                    break;\n-                case F:\n-                    stackmaps.writeByte(2);\n-                    break;\n-                case D:\n-                    stackmaps.writeByte(3);\n-                    break;\n-                case J:\n-                    stackmaps.writeByte(4);\n-                    break;\n-                case A:\n-                    if (t == typeHelper.nullType()) {\n-                        stackmaps.writeByte(5); \/\/null\n-                    } else {\n-                        \/\/TODO: uninit this, top?\n-                        stackmaps.writeByte(7);\n-                        stackmaps.writeChar(typeHelper.isValue(t) ?\n-                                poolHelper.putValueClass(typeHelper.symbol(t)) : poolHelper.putClass(typeHelper.symbol(t)));\n-                    }\n-                    break;\n-                default:\n-                    throw new IllegalStateException(\"Bad type\");\n-            }\n-        }\n-    }\n-\n-    public void sameFrame(int offsetDelta) {\n-        int frameType = (offsetDelta < SAME_FRAME_SIZE) ?\n-                offsetDelta : SAME_FRAME_EXTENDED;\n-        stackmaps.writeByte(frameType);\n-        if (frameType == SAME_FRAME_EXTENDED) {\n-            stackmaps.writeChar(offsetDelta);\n-        }\n-    }\n-\n-    public void sameLocals1StackItemFrame(int offsetDelta, T stackItem) {\n-        int frameType = (offsetDelta < SAME_FRAME_SIZE) ?\n-                (SAME_FRAME_SIZE + offsetDelta) : SAME_LOCALS_1_STACK_ITEM_EXTENDED;\n-        stackmaps.writeByte(frameType);\n-        if (frameType == SAME_LOCALS_1_STACK_ITEM_EXTENDED) {\n-            stackmaps.writeChar(offsetDelta);\n-        }\n-        writeStackMapType(stackItem);\n-    }\n-\n-    public void appendFrame(int offsetDelta, int prevLocalsSize, List<T> locals) {\n-        int frameType = SAME_FRAME_EXTENDED + (locals.size() - prevLocalsSize);\n-        stackmaps.writeByte(frameType);\n-        stackmaps.writeChar(offsetDelta);\n-        for (int i = prevLocalsSize; i < locals.size(); i++) {\n-            writeStackMapType(locals.get(i));\n-        }\n-    }\n-\n-    public void chopFrame(int offsetDelta, int droppedVars) {\n-        int frameType = SAME_FRAME_EXTENDED - droppedVars;\n-        stackmaps.writeByte(frameType);\n-        stackmaps.writeChar(offsetDelta);\n-    }\n-\n-    public void fullFrame(int offsetDelta, List<T> locals, List<T> stackItems) {\n-        stackmaps.writeByte(FULL_FRAME);\n-        stackmaps.writeChar(offsetDelta);\n-        stackmaps.writeChar(locals.size());\n-        for (T local : locals) {\n-            writeStackMapType(local);\n-        }\n-\n-        stackmaps.writeChar(stackItems.size());\n-        for (T stackType : stackItems) {\n-            writeStackMapType(stackType);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/CodeBuilder.java","additions":0,"deletions":1353,"binary":false,"changes":1353,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.function.Consumer;\n-\n-\/**\n- * Declaration (class, class member, ...) builder.\n- *\n- * @param <S> the type of symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <E> the type of pool entries\n- * @param <D> the type of this builder\n- *\/\n-public class DeclBuilder<S, T, E, D extends DeclBuilder<S, T, E, D>>\n-        extends AttributeBuilder<S, T, E, D> {\n-\n-    \/**\n-     * The access flags of the declaration, as bit flags.\n-     *\/\n-    protected int flags;\n-\n-    AnnotationsBuilder<S, T, E> runtimeInvisibleAnnotations;\n-    AnnotationsBuilder<S, T, E> runtimeVisibleAnnotations;\n-\n-    \/**\n-     * Create a declaration builder,\n-     *\n-     * @param poolHelper the helper to build the constant pool\n-     * @param typeHelper the helper to use to manipulate type descriptors\n-     *\/\n-    DeclBuilder(PoolHelper<S, T, E> poolHelper, TypeHelper<S, T> typeHelper) {\n-        super(poolHelper, typeHelper);\n-    }\n-\n-    \/**\n-     * Specify the class file flags for this declaration.\n-     *\n-     * @param flags the flags as {@code Flag} objects\n-     * @return this builder, for chained calls\n-     *\/\n-    public D withFlags(Flag... flags) {\n-        for (Flag f : flags) {\n-            this.flags |= f.flag;\n-        }\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Specify, via bits, the class file flags for this declaration.\n-     *\n-     * @param flags the flags as bit settings\n-     * @return this builder, for chained calls\n-     *\/\n-    public D withFlags(int flags) {\n-        withFlags(Flag.parse(flags));\n-        return thisBuilder();\n-    }\n-\n-    public D withAnnotation(AnnotationsBuilder.Kind kind, T annoType) {\n-        getAnnotations(kind).withAnnotation(annoType, null);\n-        return thisBuilder();\n-    }\n-\n-    public D withAnnotation(AnnotationsBuilder.Kind kind, T annoType, Consumer<? super AnnotationsBuilder<S, T, E>.AnnotationElementBuilder> annotations) {\n-        getAnnotations(kind).withAnnotation(annoType, annotations);\n-        return thisBuilder();\n-    }\n-\n-    private AnnotationsBuilder<S, T, E> getAnnotations(AnnotationsBuilder.Kind kind) {\n-        switch (kind) {\n-            case RUNTIME_INVISIBLE:\n-                if (runtimeInvisibleAnnotations == null) {\n-                    runtimeInvisibleAnnotations = new AnnotationsBuilder<>(poolHelper, typeHelper);\n-                }\n-                return runtimeInvisibleAnnotations;\n-            case RUNTIME_VISIBLE:\n-                if (runtimeVisibleAnnotations == null) {\n-                    runtimeVisibleAnnotations = new AnnotationsBuilder<>(poolHelper, typeHelper);\n-                }\n-                return runtimeVisibleAnnotations;\n-        }\n-        throw new IllegalStateException();\n-    }\n-\n-    void addAnnotations() {\n-        if (runtimeVisibleAnnotations != null) {\n-            withAttribute(\"RuntimeVisibleAnnotations\", runtimeVisibleAnnotations.build());\n-        }\n-        if (runtimeInvisibleAnnotations != null) {\n-            withAttribute(\"RuntimeInvisibleAnnotations\", runtimeVisibleAnnotations.build());\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/DeclBuilder.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-\/**\n- * Field builder.\n- *\n- * @param <S> the type of symbol representation\n- * @param <T> the type of type descriptor representation\n- * @param <E> the type of pool entries\n- *\/\n-public class FieldBuilder<S, T, E> extends MemberBuilder<S, T, E, FieldBuilder<S, T, E>> {\n-    public FieldBuilder(CharSequence name, T type, PoolHelper<S, T, E> poolHelper, TypeHelper<S, T> typeHelper) {\n-        super(name, type, poolHelper, typeHelper);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/FieldBuilder.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.EnumSet;\n-\n-public enum Flag {\n-    ACC_PUBLIC(0x0001),\n-    ACC_PROTECTED(0x0004),\n-    ACC_PRIVATE(0x0002),\n-    ACC_INTERFACE(0x0200),\n-    ACC_ENUM(0x4000),\n-    ACC_ANNOTATION(0x2000),\n-    ACC_SUPER(0x0020),\n-    ACC_ABSTRACT(0x0400),\n-    ACC_VOLATILE(0x0040),\n-    ACC_TRANSIENT(0x0080),\n-    ACC_SYNTHETIC(0x1000),\n-    ACC_STATIC(0x0008),\n-    ACC_FINAL(0x0010),\n-    ACC_SYNCHRONIZED(0x0020),\n-    ACC_BRIDGE(0x0040),\n-    ACC_VARARGS(0x0080),\n-    ACC_INLINE(0x0100),\n-    ACC_NATIVE(0x0100),\n-    ACC_STRICT(0x0800);\n-\n-    public int flag;\n-\n-    Flag(int flag) {\n-        this.flag = flag;\n-    }\n-\n-    static Flag[] parse(int flagsMask) {\n-        EnumSet<Flag> flags = EnumSet.noneOf(Flag.class);\n-        for (Flag f : Flag.values()) {\n-            if ((f.flag & flagsMask) != 0) {\n-                flags.add(f);\n-            }\n-        }\n-        return flags.stream().toArray(Flag[]::new);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/Flag.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,110 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.function.Consumer;\n-\n-public class GrowableByteBuffer {\n-\n-    public GrowableByteBuffer() {\n-    }\n-\n-    byte[] elems = new byte[64];\n-    int offset = 0;\n-\n-    public GrowableByteBuffer writeByte(int b) {\n-        return writeBytes(1, b);\n-    }\n-\n-    public GrowableByteBuffer writeChar(int x) {\n-        return writeBytes(2, x);\n-    }\n-\n-    public GrowableByteBuffer writeInt(int x) {\n-        return writeBytes(4, x);\n-    }\n-\n-    public GrowableByteBuffer writeFloat(float x) {\n-        return writeInt(Float.floatToIntBits(x));\n-    }\n-\n-    public GrowableByteBuffer writeLong(long x) {\n-        return writeBytes(8, x);\n-    }\n-\n-    public GrowableByteBuffer writeDouble(double x) {\n-        writeLong(Double.doubleToLongBits(x));\n-        return this;\n-    }\n-\n-    public GrowableByteBuffer writeBytes(byte[] barr) {\n-        expandIfNeeded(barr.length);\n-        System.arraycopy(barr, 0, elems, offset, barr.length);\n-        offset += barr.length;\n-        return this;\n-    }\n-\n-    public GrowableByteBuffer writeBytes(GrowableByteBuffer bb) {\n-        expandIfNeeded(bb.offset);\n-        System.arraycopy(bb.elems, 0, elems, offset, bb.offset);\n-        offset += bb.offset;\n-        return this;\n-    }\n-\n-    public GrowableByteBuffer withOffset(int offset, Consumer<GrowableByteBuffer> actions) {\n-        int prevOffset = this.offset;\n-        this.offset = offset;\n-        actions.accept(this);\n-        this.offset = prevOffset;\n-        return this;\n-    }\n-\n-    private GrowableByteBuffer writeBytes(int size, long x) {\n-        expandIfNeeded(size);\n-        for (int i = 0; i < size; i++) {\n-            elems[offset++] = (byte) ((x >> 8 * (size - i - 1)) & 0xFF);\n-        }\n-        return this;\n-    }\n-\n-    void expandIfNeeded(int increment) {\n-        if (offset + increment > elems.length) {\n-            int newsize = elems.length * 2;\n-            while (offset + increment > newsize) {\n-                newsize *= 2;\n-            }\n-            byte[] newelems = new byte[newsize];\n-            System.arraycopy(elems, 0, newelems, 0, offset);\n-            elems = newelems;\n-        }\n-    }\n-\n-    public byte[] bytes() {\n-        byte[] bytes = new byte[offset];\n-        System.arraycopy(elems, 0, bytes, 0, offset);\n-        return bytes;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/GrowableByteBuffer.java","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -1,313 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.experimental.bytecode;\n-\n-import jdk.experimental.bytecode.Pool.Class_info;\n-import jdk.experimental.bytecode.Pool.Double_info;\n-import jdk.experimental.bytecode.Pool.Fieldref_info;\n-import jdk.experimental.bytecode.Pool.Float_info;\n-import jdk.experimental.bytecode.Pool.Integer_info;\n-import jdk.experimental.bytecode.Pool.InterfaceMethodref_info;\n-import jdk.experimental.bytecode.Pool.InvokeDynamic_info;\n-import jdk.experimental.bytecode.Pool.Long_info;\n-import jdk.experimental.bytecode.Pool.MethodHandle_info;\n-import jdk.experimental.bytecode.Pool.MethodType_info;\n-import jdk.experimental.bytecode.Pool.Methodref_info;\n-import jdk.experimental.bytecode.Pool.NameAndType_info;\n-import jdk.experimental.bytecode.Pool.String_info;\n-import jdk.experimental.bytecode.Pool.Utf8_info;\n-import jdk.experimental.bytecode.Pool.PoolInfo;\n-import java.util.ArrayList;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-import static jdk.experimental.bytecode.Pool.*;\n-import jdk.experimental.bytecode.Pool.PoolInfoAndIndex;\n-\n-\/**\n- * A helper for explicitly building immutable constant pools with a defined\n- * order.\n- *\/\n-class ImmutableBytePoolHelper<S, T> extends BytePoolHelper<S, T> {\n-\n-    private final BuiltPool icpool;\n-\n-    public ImmutableBytePoolHelper(Consumer<PoolBuilder<byte[]>> cpBuild,\n-            Function<S, String> symbolToString, Function<T, String> typeToString) {\n-        super(null \/* already built *\/, symbolToString, typeToString);\n-        this.icpool = new BuiltPool(cpBuild);\n-        \/\/ go through the constant pool installing all the entries in the\n-        \/\/ helper's map.\n-        for (PoolInfoAndIndex pii : icpool.entriesAndIndicies()) {\n-            PoolInfo info = pii.info;\n-            PoolKey poolKey = new PoolKey();\n-            try {\n-                switch (info.getTag()) {\n-                    case STRING_TAG: {\n-                        String_info si = (String_info) info;\n-                        poolKey.setString(si.getString());\n-                        break;\n-                    }\n-                    case INTEGER_TAG:\n-                        poolKey.setInteger(((Integer_info) info).value);\n-                        break;\n-                    case FLOAT_TAG:\n-                        poolKey.setFloat(((Float_info) info).value);\n-                        break;\n-                    case DOUBLE_TAG:\n-                        poolKey.setDouble(((Double_info) info).value);\n-                        break;\n-                    case LONG_TAG:\n-                        poolKey.setLong(((Long_info) info).value);\n-                        break;\n-                    case CLASS_TAG: {\n-                        Class_info ci = (Class_info) info;\n-                        poolKey.setClass(ci.getName());\n-                        break;\n-                    }\n-                    case FIELDREF_TAG: {\n-                        Fieldref_info fr = (Fieldref_info) info;\n-                        NameAndType_info nat = fr.getNameAndTypeInfo();\n-                        poolKey.setMemberRef(PoolTag.FIELDREF, fr.getClassName(), nat.getName(), nat.getType());\n-                        break;\n-                    }\n-                    case METHODREF_TAG: {\n-                        Methodref_info mr = (Methodref_info) info;\n-                        NameAndType_info nat = mr.getNameAndTypeInfo();\n-                        poolKey.setMemberRef(PoolTag.METHODREF, mr.getClassName(), nat.getName(), nat.getType());\n-                        break;\n-                    }\n-                    case INTERFACEMETHODREF_TAG: {\n-                        InterfaceMethodref_info mr = (InterfaceMethodref_info) info;\n-                        NameAndType_info nat = mr.getNameAndTypeInfo();\n-                        poolKey.setMemberRef(PoolTag.INTERFACEMETHODREF, mr.getClassName(), nat.getName(), nat.getType());\n-                        break;\n-                    }\n-                    case METHODTYPE_TAG: {\n-                        MethodType_info mt = (MethodType_info) info;\n-                        poolKey.setMethodType(mt.getType());\n-                        break;\n-                    }\n-                    case METHODHANDLE_TAG: {\n-                        MethodHandle_info mh = (MethodHandle_info) info;\n-                        PoolInfo rinfo = icpool.get(mh.reference_index);\n-                        String owner;\n-                        NameAndType_info nat;\n-                        switch (rinfo.getTag()) {\n-                            case FIELDREF_TAG:\n-                                Fieldref_info fr = (Fieldref_info) rinfo;\n-                                owner = fr.getClassName();\n-                                nat = fr.getNameAndTypeInfo();\n-                                break;\n-                            case METHODREF_TAG:\n-                                Methodref_info mr = (Methodref_info) rinfo;\n-                                owner = mr.getClassName();\n-                                nat = mr.getNameAndTypeInfo();\n-                                break;\n-                            case INTERFACEMETHODREF_TAG:\n-                                InterfaceMethodref_info imr = (InterfaceMethodref_info) rinfo;\n-                                owner = imr.getClassName();\n-                                nat = imr.getNameAndTypeInfo();\n-                                break;\n-                            default:\n-                                throw new IllegalStateException(rinfo.toString());\n-                        }\n-                        poolKey.setMethodHandle(mh.reference_kind, owner, nat.getName(), nat.getType());\n-                        break;\n-                    }\n-                    case NAMEANDTYPE_TAG: {\n-                        NameAndType_info nat = (NameAndType_info) info;\n-                        poolKey.setNameAndType(nat.getName(), nat.getType());\n-                        break;\n-                    }\n-                    case UTF8_TAG: {\n-                        Utf8_info u = (Utf8_info) info;\n-                        poolKey.setUtf8(u.value);\n-                        break;\n-                    }\n-                    case INVOKEDYNAMIC_TAG: {\n-                        InvokeDynamic_info idi = (InvokeDynamic_info) info;\n-                        NameAndType_info nat = (NameAndType_info) icpool.get(idi.name_and_type_index);\n-                        PoolInfo bsm = icpool.get(idi.bootstrap_method_attr_index);\n-                        \/\/ idi.bootstrap_method_attr_index, idi.name_and_type_index);\n-                        throw new UnsupportedOperationException(\"InvokeDynamic \" + idi);\n-                    }\n-                    case MODULE_TAG: {\n-                        throw new UnsupportedOperationException(\"Module \" + info);\n-                    }\n-                    case PACKAGE_TAG: {\n-                        throw new UnsupportedOperationException(\"Package \" + info);\n-                    }\n-                    default:\n-                        throw new IllegalStateException(\"unsupported pool entry: \" + info);\n-                }\n-            } catch (PoolException ex) {\n-            }\n-            poolKey.at(pii.index);\n-            entries.enter(poolKey);\n-        }\n-    }\n-\n-    \/**\n-     * @return the count of constant pool indicies.\n-     *\/\n-    @Override\n-    public int size() {\n-        return icpool.builder.size();\n-    }\n-\n-    \/**\n-     * @return the size in bytes of all constant pool entries.\n-     *\/\n-    @Override\n-    public byte[] representation() {\n-        return icpool.builder.representation();\n-    }\n-\n-    \/**\n-     * Build the byte array representation of the constant pool, and at the\n-     * same time build as an array of PoolInfo objects.\n-     *\/\n-    private static class BuiltPool extends Pool {\n-\n-        final ArrayList<PoolInfo> infos = new ArrayList<>();\n-        final IBCPB builder;\n-\n-        BuiltPool(Consumer<PoolBuilder<byte[]>> cpBuild) {\n-            this.builder = new IBCPB();\n-            cpBuild.accept(builder);\n-        }\n-\n-        @Override\n-        protected PoolInfo getSafe(int index) {\n-            return infos.get(index);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return infos.size();\n-        }\n-\n-        private class IBCPB extends BytePoolBuilder {\n-\n-            @Override\n-            public int putClass(int utf8_idx) {\n-                int id = super.putClass(utf8_idx);\n-                return put(id, new Class_info(utf8_idx));\n-            }\n-\n-            @Override\n-            public int putMemberRef(PoolTag tag, int owner_idx, int nameAndType_idx) {\n-                int id = super.putMemberRef(tag, owner_idx, nameAndType_idx);\n-                switch (tag) {\n-                    case FIELDREF:\n-                        return put(id, new Fieldref_info(owner_idx, nameAndType_idx));\n-                    case METHODREF:\n-                        return put(id, new Methodref_info(owner_idx, nameAndType_idx));\n-                    case INTERFACEMETHODREF:\n-                        return put(id, new InterfaceMethodref_info(owner_idx, nameAndType_idx));\n-                    default:\n-                        throw new IllegalArgumentException(\"tag: \" + tag);\n-                }\n-            }\n-\n-            @Override\n-            public int putInt(int i) {\n-                int id = super.putInt(i);\n-                return put(id, new Integer_info(i));\n-            }\n-\n-            @Override\n-            public int putFloat(float f) {\n-                int id = super.putFloat(f);\n-                return put(id, new Float_info(f));\n-            }\n-\n-            @Override\n-            public int putLong(long l) {\n-                int id = super.putLong(l);\n-                return put(id, new Long_info(l));\n-            }\n-\n-            @Override\n-            public int putDouble(double d) {\n-                int id = super.putDouble(d);\n-                return put(id, new Double_info(d));\n-            }\n-\n-            @Override\n-            public int putInvokeDynamic(int bsmIndex, int nameAndType_idx) {\n-                int id = super.putInvokeDynamic(bsmIndex, nameAndType_idx);\n-                return put(id, new InvokeDynamic_info(bsmIndex, nameAndType_idx));\n-            }\n-\n-            @Override\n-            public int putConstantDynamic(int bsmIndex, int nameAndType_idx) {\n-                int id = super.putConstantDynamic(bsmIndex, nameAndType_idx);\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            public int putMethodType(int desc_idx) {\n-                int id = super.putMethodType(desc_idx);\n-                return put(id, new MethodType_info(desc_idx));\n-            }\n-\n-            @Override\n-            public int putMethodHandle(int refKind, int ref_idx) {\n-                int id = super.putMethodHandle(refKind, ref_idx);\n-                return put(id, new MethodHandle_info(refKind, ref_idx));\n-            }\n-\n-            @Override\n-            public int putString(int utf8_index) {\n-                int id = super.putString(utf8_index);\n-                return put(id, new String_info(utf8_index));\n-            }\n-\n-            @Override\n-            public int putNameAndType(int name_idx, int type_idx) {\n-                int id = super.putNameAndType(name_idx, type_idx);\n-                return put(id, new NameAndType_info(name_idx, type_idx));\n-            }\n-\n-            @Override\n-            public int putUtf8(CharSequence s) {\n-                int id = super.putUtf8(s);\n-                return put(id, new Utf8_info(s.toString()));\n-            }\n-\n-            private int put(int id, PoolInfo info) {\n-                \/\/ fill gaps with nulls\n-                int fill = id - infos.size();\n-                for (int i = 0; i < fill; ++i) {\n-                    infos.add(null);\n-                }\n-                infos.add(info);\n-                return id;\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/ImmutableBytePoolHelper.java","additions":0,"deletions":313,"binary":false,"changes":313,"status":"deleted"},{"patch":"@@ -1,193 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.nio.ByteBuffer;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-\n-public class IsolatedMethodBuilder extends MethodBuilder<Class<?>, String, Object[]> {\n-\n-    public IsolatedMethodBuilder(Lookup lookup, String name, String type) {\n-        super(null, name, type, new IsolatedMethodPoolHelper(lookup), null);\n-    }\n-\n-    static class IsolatedMethodPoolHelper implements PoolHelper<Class<?>, String, Object[]> {\n-        Map<Object, Integer> constants = new HashMap<>();\n-        Lookup lookup;\n-\n-        private IsolatedMethodPoolHelper(Lookup lookup) {\n-            this.lookup = lookup;\n-        }\n-\n-        @Override\n-        public int putClass(Class<?> symbol) {\n-            return putIfAbsent(symbol);\n-        }\n-\n-        @Override\n-        public int putValueClass(Class<?> symbol) {\n-            return putIfAbsent(symbol);\n-        }\n-\n-        @Override\n-        public int putFieldRef(Class<?> owner, CharSequence name, String type) {\n-            try {\n-                Field f = owner.getDeclaredField(name.toString()); \/\/TODO: we should unreflect for a var handle\n-                return putIfAbsent(lookup.unreflectGetter(f));\n-            } catch (Throwable ex) {\n-                ex.printStackTrace();\n-                return -1;\n-            }\n-        }\n-\n-        @Override\n-        public int putMethodRef(Class<?> owner, CharSequence name, String type, boolean isInterface) {\n-            try {\n-                Method m = owner.getDeclaredMethod(name.toString()); \/\/we should unreflect according to method vs. constructor\n-                \/\/and static vs. private etc.\n-                return putIfAbsent(lookup.unreflect(m));\n-            } catch (Throwable ex) {\n-                ex.printStackTrace();\n-                return -1;\n-            }\n-        }\n-\n-        @Override\n-        public int putInt(int i) {\n-            return putIfAbsent(i);\n-        }\n-\n-        @Override\n-        public int putFloat(float f) {\n-            return putIfAbsent(f);\n-        }\n-\n-        @Override\n-        public int putLong(long l) {\n-            return putIfAbsent(l);\n-        }\n-\n-        @Override\n-        public int putDouble(double d) {\n-            return putIfAbsent(d);\n-        }\n-\n-        @Override\n-        public int putString(String s) {\n-            return putIfAbsent(s);\n-        }\n-\n-        @Override\n-        public int putValue(Object v) {\n-            return 0; \/\/ ???\n-        }\n-\n-        @Override\n-        public int putInvokeDynamic(CharSequence invokedName, String invokedType, Class<?> bsmClass, CharSequence bsmName, String bsmType, Consumer<StaticArgListBuilder<Class<?>, String, Object[]>> staticArgs) {\n-            return 0; \/\/???\n-        }\n-\n-        @Override\n-        public int putConstantDynamic(CharSequence constName, String constType, Class<?> bsmClass, CharSequence bsmName, String bsmType, Consumer<StaticArgListBuilder<Class<?>, String, Object[]>> staticArgs) {\n-            return 0; \/\/???\n-        }\n-\n-        @Override\n-        public int putMethodHandle(int refKind, Class<?> owner, CharSequence name, String type) {\n-            return putMethodHandle(refKind, owner, name, type, false);\n-        }\n-\n-        @Override\n-        public int putMethodHandle(int refKind, Class<?> owner, CharSequence name, String type, boolean isInterface) {\n-            return 0; \/\/???\n-        }\n-\n-        @Override\n-        public int putMethodType(String s) {\n-            return 0; \/\/???\n-        }\n-\n-        @Override\n-        public int putUtf8(CharSequence s) {\n-            return putIfAbsent(s);\n-        }\n-\n-        @Override\n-        public int putType(String s) {\n-            return putIfAbsent(s);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return constants.size();\n-        }\n-\n-        @Override\n-        public Object[] representation() {\n-            return constants.keySet().toArray();\n-        }\n-\n-        int putIfAbsent(Object o) {\n-            int nextIndex = constants.size() + 1;\n-            Object res = constants.putIfAbsent(o, nextIndex);\n-            return res == null ?\n-                    nextIndex : (Integer)res;\n-        }\n-    }\n-\n-    public Object[] entries() {\n-        return poolHelper.representation();\n-    }\n-\n-    @Override\n-    public byte[] build() {\n-        byte[] arr = super.build();\n-        int codelength_offset = 2 + 2 + 2 + 2 +\n-                2 + 4 + 2 + 2;\n-        int code_offset = codelength_offset + 4;\n-        int length = ByteBuffer.wrap(arr).getInt(codelength_offset);\n-        byte[] opcodes = new byte[length];\n-        System.arraycopy(arr, code_offset, opcodes, 0, length);\n-        return opcodes;\n-    }\n-\n-    public static void main(String[] args) {\n-        IsolatedMethodBuilder imb =  new IsolatedMethodBuilder(MethodHandles.lookup(), \"foo\", \"(java\/lang\/String;)I\");\n-        imb.withCode(C ->\n-                    C.aload_0()\n-                     .invokevirtual(String.class, \"length\", \"()I\", false)\n-                     .ireturn());\n-        byte[] opcodes = imb.build();\n-        System.out.println(Arrays.toString(opcodes));\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/IsolatedMethodBuilder.java","additions":0,"deletions":193,"binary":false,"changes":193,"status":"deleted"},{"patch":"@@ -1,704 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.TreeMap;\n-import java.util.function.Consumer;\n-\n-public class MacroCodeBuilder<S, T, E, C extends MacroCodeBuilder<S, T, E, C>> extends CodeBuilder<S, T, E, C> {\n-\n-    JumpMode jumpMode = JumpMode.NARROW;\n-\n-    Map<CharSequence, Integer> labels = new HashMap<>();\n-    List<PendingJump> pendingJumps = new LinkedList<>();\n-\n-    class PendingJump {\n-        CharSequence label;\n-        int pc;\n-\n-        PendingJump(CharSequence label, int pc) {\n-            this.label = label;\n-            this.pc = pc;\n-        }\n-\n-        boolean resolve(CharSequence label, int offset) {\n-            if (this.label.equals(label)) {\n-                \/\/patch offset\n-                code.withOffset(pc + 1, buf -> emitOffset(buf, jumpMode, offset - pc));\n-                return true;\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    public enum InvocationKind {\n-        INVOKESTATIC,\n-        INVOKEVIRTUAL,\n-        INVOKESPECIAL,\n-        INVOKEINTERFACE;\n-    }\n-\n-    public enum FieldAccessKind {\n-        STATIC,\n-        INSTANCE;\n-    }\n-\n-    public enum CondKind {\n-        EQ(0),\n-        NE(1),\n-        LT(2),\n-        GE(3),\n-        GT(4),\n-        LE(5);\n-\n-        int offset;\n-\n-        CondKind(int offset) {\n-            this.offset = offset;\n-        }\n-\n-        public CondKind negate() {\n-            switch (this) {\n-                case EQ:\n-                    return NE;\n-                case NE:\n-                    return EQ;\n-                case LT:\n-                    return GE;\n-                case GE:\n-                    return LT;\n-                case GT:\n-                    return LE;\n-                case LE:\n-                    return GT;\n-                default:\n-                    throw new IllegalStateException(\"Unknown cond\");\n-            }\n-        }\n-    }\n-\n-    static class WideJumpException extends RuntimeException {\n-        static final long serialVersionUID = 42L;\n-    }\n-\n-    public MacroCodeBuilder(MethodBuilder<S, T, E> methodBuilder) {\n-        super(methodBuilder);\n-    }\n-\n-    public C load(TypeTag type, int n) {\n-        switch (n) {\n-            case 0:\n-                return emitOp(Opcode.ILOAD_0.at(type, 4));\n-            case 1:\n-                return emitOp(Opcode.ILOAD_1.at(type, 4));\n-            case 2:\n-                return emitOp(Opcode.ILOAD_2.at(type, 4));\n-            case 3:\n-                return emitOp(Opcode.ILOAD_3.at(type, 4));\n-            default:\n-                return emitWideIfNeeded(Opcode.ILOAD.at(type), n);\n-        }\n-    }\n-\n-    public C store(TypeTag type, int n) {\n-        switch (n) {\n-            case 0:\n-                return emitOp(Opcode.ISTORE_0.at(type, 4));\n-            case 1:\n-                return emitOp(Opcode.ISTORE_1.at(type, 4));\n-            case 2:\n-                return emitOp(Opcode.ISTORE_2.at(type, 4));\n-            case 3:\n-                return emitOp(Opcode.ISTORE_3.at(type, 4));\n-            default:\n-                return emitWideIfNeeded(Opcode.ISTORE.at(type), n);\n-        }\n-    }\n-\n-    public C arrayload(TypeTag type) {\n-        return emitOp(Opcode.IALOAD.at(type));\n-    }\n-\n-    public C arraystore(TypeTag type, int n) {\n-        return emitOp(Opcode.IASTORE.at(type));\n-    }\n-\n-    public C const_(int i) {\n-        switch (i) {\n-            case -1:\n-                return iconst_m1();\n-            case 0:\n-                return iconst_0();\n-            case 1:\n-                return iconst_1();\n-            case 2:\n-                return iconst_2();\n-            case 3:\n-                return iconst_3();\n-            case 4:\n-                return iconst_4();\n-            case 5:\n-                return iconst_5();\n-            default:\n-                if (i > 0 && i <= Byte.MAX_VALUE) {\n-                    return bipush(i);\n-                } else if (i >= Short.MIN_VALUE && i <= Short.MAX_VALUE) {\n-                    return sipush(i);\n-                } else {\n-                    return ldc(i);\n-                }\n-        }\n-    }\n-\n-    public C const_(long l) {\n-        if (l == 0) {\n-            return lconst_0();\n-        } else if (l == 1) {\n-            return lconst_1();\n-        } else {\n-            return ldc(l);\n-        }\n-    }\n-\n-    public C const_(float f) {\n-        if (f == 0) {\n-            return fconst_0();\n-        } else if (f == 1) {\n-            return fconst_1();\n-        } else if (f == 2) {\n-            return fconst_2();\n-        } else {\n-            return ldc(f);\n-        }\n-    }\n-\n-    public C const_(double d) {\n-        if (d == 0) {\n-            return dconst_0();\n-        } else if (d == 1) {\n-            return dconst_1();\n-        } else {\n-            return ldc(d);\n-        }\n-    }\n-\n-    public C getfield(FieldAccessKind fak, S owner, CharSequence name, T type) {\n-        switch (fak) {\n-            case INSTANCE:\n-                return getfield(owner, name, type);\n-            case STATIC:\n-                return getstatic(owner, name, type);\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    public C putfield(FieldAccessKind fak, S owner, CharSequence name, T type) {\n-        switch (fak) {\n-            case INSTANCE:\n-                return putfield(owner, name, type);\n-            case STATIC:\n-                return putstatic(owner, name, type);\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    public C invoke(InvocationKind ik, S owner, CharSequence name, T type, boolean isInterface) {\n-        switch (ik) {\n-            case INVOKESTATIC:\n-                return invokestatic(owner, name, type, isInterface);\n-            case INVOKEVIRTUAL:\n-                return invokevirtual(owner, name, type, isInterface);\n-            case INVOKESPECIAL:\n-                return invokespecial(owner, name, type, isInterface);\n-            case INVOKEINTERFACE:\n-                if (!isInterface) throw new AssertionError();\n-                return invokeinterface(owner, name, type);\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    public C add(TypeTag type) {\n-        return emitOp(Opcode.IADD.at(type));\n-    }\n-\n-    public C sub(TypeTag type) {\n-        return emitOp(Opcode.ISUB.at(type));\n-    }\n-\n-    public C mul(TypeTag type) {\n-        return emitOp(Opcode.IMUL.at(type));\n-    }\n-\n-    public C div(TypeTag type) {\n-        return emitOp(Opcode.IDIV.at(type));\n-    }\n-\n-    public C rem(TypeTag type) {\n-        return emitOp(Opcode.IREM.at(type));\n-    }\n-\n-    public C neg(TypeTag type) {\n-        return emitOp(Opcode.INEG.at(type));\n-    }\n-\n-    public C shl(TypeTag type) {\n-        return emitOp(Opcode.ISHL.at(type));\n-    }\n-\n-    public C shr(TypeTag type) {\n-        return emitOp(Opcode.ISHR.at(type));\n-    }\n-\n-    public C ushr(TypeTag type) {\n-        return emitOp(Opcode.ISHR.at(type));\n-    }\n-\n-    public C and(TypeTag type) {\n-        return emitOp(Opcode.IAND.at(type));\n-    }\n-\n-    public C or(TypeTag type) {\n-        return emitOp(Opcode.IOR.at(type));\n-    }\n-\n-    public C xor(TypeTag type) {\n-        return emitOp(Opcode.IXOR.at(type));\n-    }\n-\n-    public C return_(TypeTag type) {\n-        switch (type) {\n-            case V:\n-                return return_();\n-            default:\n-                return emitOp(Opcode.IRETURN.at(type));\n-        }\n-    }\n-\n-    @Override\n-    public LabelledTypedBuilder typed(TypeTag typeTag) {\n-        return super.typed(typeTag, _unused -> new LabelledTypedBuilder());\n-    }\n-\n-    public class LabelledTypedBuilder extends TypedBuilder {\n-        public C if_acmpeq(CharSequence target) {\n-            return ifcmp(TypeTag.A, CondKind.EQ, target);\n-        }\n-\n-        public C if_acmpne(CharSequence target) {\n-            return ifcmp(TypeTag.A, CondKind.NE, target);\n-        }\n-    }\n-\n-    public C conv(TypeTag from, TypeTag to) {\n-        switch (from) {\n-            case B:\n-            case C:\n-            case S:\n-                switch (to) {\n-                    case J:\n-                        return i2l();\n-                    case F:\n-                        return i2f();\n-                    case D:\n-                        return i2d();\n-                }\n-                break;\n-            case I:\n-                switch (to) {\n-                    case J:\n-                        return i2l();\n-                    case F:\n-                        return i2f();\n-                    case D:\n-                        return i2d();\n-                    case B:\n-                        return i2b();\n-                    case C:\n-                        return i2c();\n-                    case S:\n-                        return i2s();\n-                }\n-                break;\n-            case J:\n-                switch (to) {\n-                    case I:\n-                        return l2i();\n-                    case F:\n-                        return l2f();\n-                    case D:\n-                        return l2d();\n-                }\n-                break;\n-            case F:\n-                switch (to) {\n-                    case I:\n-                        return f2i();\n-                    case J:\n-                        return f2l();\n-                    case D:\n-                        return f2d();\n-                }\n-                break;\n-            case D:\n-                switch (to) {\n-                    case I:\n-                        return d2i();\n-                    case J:\n-                        return d2l();\n-                    case F:\n-                        return d2f();\n-                }\n-                break;\n-        }\n-        \/\/no conversion is necessary - do nothing!\n-        return thisBuilder();\n-    }\n-\n-    public C if_null(CharSequence label) {\n-        return emitCondJump(Opcode.IF_NULL, Opcode.IF_NONNULL, label);\n-    }\n-\n-    public C if_nonnull(CharSequence label) {\n-        return emitCondJump(Opcode.IF_NONNULL, Opcode.IF_NULL, label);\n-    }\n-\n-    public C ifcmp(TypeTag type, CondKind cond, CharSequence label) {\n-        switch (type) {\n-            case I:\n-                return emitCondJump(Opcode.IF_ICMPEQ, cond, label);\n-            case A:\n-                return emitCondJump(Opcode.IF_ACMPEQ, cond, label);\n-            case J:\n-                return lcmp().emitCondJump(Opcode.IFEQ, cond, label);\n-            case D:\n-                return dcmpg().emitCondJump(Opcode.IFEQ, cond, label);\n-            case F:\n-                return fcmpg().emitCondJump(Opcode.IFEQ, cond, label);\n-            default:\n-                throw new IllegalArgumentException(\"Bad cmp type\");\n-        }\n-    }\n-\n-    public C goto_(CharSequence label) {\n-        emitOp(jumpMode == JumpMode.NARROW ? Opcode.GOTO_ : Opcode.GOTO_W);\n-        emitOffset(code, jumpMode, labelOffset(label));\n-        return thisBuilder();\n-    }\n-\n-    protected int labelOffset(CharSequence label) {\n-        int pc = code.offset - 1;\n-        Integer labelPc = labels.get(label);\n-        if (labelPc == null) {\n-            addPendingJump(label, pc);\n-        }\n-        return labelPc == null ? 0 : (labelPc - pc);\n-    }\n-\n-    public C label(CharSequence s) {\n-        int pc = code.offset;\n-        Object old = labels.put(s, pc);\n-        if (old != null) {\n-            throw new IllegalStateException(\"label already exists\");\n-        }\n-        resolveJumps(s, pc);\n-        return thisBuilder();\n-    }\n-\n-    \/\/FIXME: address this jumpy mess - i.e. offset and state update work against each other!\n-    public C emitCondJump(Opcode opcode, CondKind ck, CharSequence label) {\n-        return emitCondJump(opcode.at(ck), opcode.at(ck.negate()), label);\n-    }\n-\n-    public C emitCondJump(Opcode pos, Opcode neg, CharSequence label) {\n-        if (jumpMode == JumpMode.NARROW) {\n-            emitOp(pos);\n-            emitOffset(code, jumpMode, labelOffset(label));\n-        } else {\n-            emitOp(neg);\n-            emitOffset(code, JumpMode.NARROW, 8);\n-            goto_w(labelOffset(label));\n-        }\n-        return thisBuilder();\n-    }\n-\n-    void addPendingJump(CharSequence label, int pc) {\n-        pendingJumps.add(new PendingJump(label, pc));\n-    }\n-\n-    void resolveJumps(CharSequence label, int pc) {\n-        Iterator<PendingJump> jumpsIt = pendingJumps.iterator();\n-        while (jumpsIt.hasNext()) {\n-            PendingJump jump = jumpsIt.next();\n-            if (jump.resolve(label, pc)) {\n-                jumpsIt.remove();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected void emitOffset(GrowableByteBuffer buf, JumpMode jumpMode, int offset) {\n-        if (jumpMode == JumpMode.NARROW && (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE)) {\n-            throw new WideJumpException();\n-        }\n-        super.emitOffset(buf, jumpMode, offset);\n-    }\n-\n-    public C jsr(CharSequence label) {\n-        emitOp(jumpMode == JumpMode.NARROW ? Opcode.JSR : Opcode.JSR_W);\n-        emitOffset(code, jumpMode, labelOffset(label));\n-        return thisBuilder();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public C withTry(Consumer<? super C> tryBlock, Consumer<? super CatchBuilder> catchBlocks) {\n-        int start = code.offset;\n-        tryBlock.accept((C) this);\n-        int end = code.offset;\n-        CatchBuilder catchBuilder = makeCatchBuilder(start, end);\n-        catchBlocks.accept(catchBuilder);\n-        catchBuilder.build();\n-        return thisBuilder();\n-    }\n-\n-    void clear() {\n-        code.offset = 0;\n-        catchers.offset = 0;\n-        ncatchers = 0;\n-        labels.clear();\n-        pendingJumps = null;\n-    }\n-\n-    protected CatchBuilder makeCatchBuilder(int start, int end) {\n-        return new CatchBuilder(start, end);\n-    }\n-\n-    public class CatchBuilder {\n-        int start, end;\n-\n-        String endLabel = labelName();\n-\n-        Map<S, Consumer<? super C>> catchers = new LinkedHashMap<>();\n-        public Consumer<? super C> finalizer;\n-        List<Integer> pendingGaps = new ArrayList<>();\n-\n-        public CatchBuilder(int start, int end) {\n-            this.start = start;\n-            this.end = end;\n-        }\n-\n-        public CatchBuilder withCatch(S exc, Consumer<? super C> catcher) {\n-            catchers.put(exc, catcher);\n-            return this;\n-        }\n-\n-        public CatchBuilder withFinally(Consumer<? super C> finalizer) {\n-            this.finalizer = finalizer;\n-            return this;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        void build() {\n-            if (finalizer != null) {\n-                finalizer.accept((C) MacroCodeBuilder.this);\n-            }\n-            goto_(endLabel);\n-            for (Map.Entry<S, Consumer<? super C>> catcher_entry : catchers.entrySet()) {\n-                emitCatch(catcher_entry.getKey(), catcher_entry.getValue());\n-            }\n-            if (finalizer != null) {\n-                emitFinalizer();\n-            }\n-            resolveJumps(endLabel, code.offset);\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        protected void emitCatch(S exc, Consumer<? super C> catcher) {\n-            int offset = code.offset;\n-            MacroCodeBuilder.this.withCatch(exc, start, end, offset);\n-            catcher.accept((C) MacroCodeBuilder.this);\n-            if (finalizer != null) {\n-                int startFinalizer = code.offset;\n-                finalizer.accept((C) MacroCodeBuilder.this);\n-                pendingGaps.add(startFinalizer);\n-                pendingGaps.add(code.offset);\n-            }\n-            goto_(endLabel);\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        protected void emitFinalizer() {\n-            int offset = code.offset;\n-            pop();\n-            for (int i = 0; i < pendingGaps.size(); i += 2) {\n-                MacroCodeBuilder.this.withCatch(null, pendingGaps.get(i), pendingGaps.get(i + 1), offset);\n-            }\n-            MacroCodeBuilder.this.withCatch(null, start, end, offset);\n-            finalizer.accept((C) MacroCodeBuilder.this);\n-        }\n-\n-\/\/        @SuppressWarnings(\"unchecked\")\n-\/\/        CatchBuilder withCatch(S exc, Consumer<? super C> catcher) {\n-\/\/            int offset = code.offset;\n-\/\/            MacroCodeBuilder.this.withCatch(exc, start, end, offset);\n-\/\/            catcher.accept((C)MacroCodeBuilder.this);\n-\/\/            return this;\n-\/\/        }\n-\/\/\n-\/\/        @SuppressWarnings(\"unchecked\")\n-\/\/        CatchBuilder withFinally(Consumer<? super C> catcher) {\n-\/\/            int offset = code.offset;\n-\/\/            MacroCodeBuilder.this.withCatch(null, start, end, offset);\n-\/\/            catcher.accept((C)MacroCodeBuilder.this);\n-\/\/            return this;\n-\/\/        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public C switch_(Consumer<? super SwitchBuilder> consumer) {\n-        int start = code.offset;\n-        SwitchBuilder sb = makeSwitchBuilder();\n-        consumer.accept(sb);\n-        int nlabels = sb.cases.size();\n-        switch (sb.switchCode()) {\n-            case LOOKUPSWITCH: {\n-                int[] lookupOffsets = new int[nlabels * 2];\n-                int i = 0;\n-                for (Integer v : sb.cases.keySet()) {\n-                    lookupOffsets[i] = v;\n-                    i += 2;\n-                }\n-                lookupswitch(0, lookupOffsets);\n-                \/\/backpatch lookup\n-                int curr = code.offset - (8 * nlabels) - 8;\n-                int defaultOffset = code.offset - start;\n-                code.withOffset(curr, buf -> emitOffset(buf, JumpMode.WIDE, defaultOffset));\n-                sb.defaultCase.accept((C) this);\n-                curr += 12;\n-                for (Consumer<? super C> case_ : sb.cases.values()) {\n-                    int offset = code.offset;\n-                    code.withOffset(curr, buf -> emitOffset(buf, JumpMode.WIDE, offset - start));\n-                    case_.accept((C) this);\n-                    curr += 8;\n-                }\n-                break;\n-            }\n-            case TABLESWITCH: {\n-                int[] tableOffsets = new int[sb.hi - sb.lo + 1];\n-                tableswitch(sb.lo, sb.hi, 0, tableOffsets);\n-                \/\/backpatch table\n-                int curr = code.offset - (4 * tableOffsets.length) - 12;\n-                int defaultOffset = code.offset - start;\n-                code.withOffset(curr, buf -> emitOffset(buf, JumpMode.WIDE, defaultOffset));\n-                sb.defaultCase.accept((C) this);\n-                curr += 12;\n-                int lastCasePc = -1;\n-                for (int i = sb.lo; i <= sb.hi; i++) {\n-                    Consumer<? super C> case_ = sb.cases.get(i);\n-                    if (case_ != null) {\n-                        lastCasePc = code.offset;\n-                        case_.accept((C) this);\n-                    }\n-                    int offset = lastCasePc - start;\n-                    code.withOffset(curr, buf -> emitOffset(buf, JumpMode.WIDE, offset));\n-                    curr += 4;\n-                }\n-            }\n-        }\n-        resolveJumps(sb.endLabel, code.offset);\n-        return thisBuilder();\n-    }\n-\n-    private static int labelCount = 0;\n-\n-    String labelName() {\n-        return \"label\" + labelCount++;\n-    }\n-\n-    protected SwitchBuilder makeSwitchBuilder() {\n-        return new SwitchBuilder();\n-    }\n-\n-    public class SwitchBuilder {\n-        Map<Integer, Consumer<? super C>> cases = new TreeMap<>();\n-        int lo = Integer.MAX_VALUE;\n-        int hi = Integer.MIN_VALUE;\n-        String endLabel = labelName();\n-\n-        public Consumer<? super C> defaultCase;\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public SwitchBuilder withCase(int value, Consumer<? super C> case_, boolean fallthrough) {\n-            if (value > hi) {\n-                hi = value;\n-            }\n-            if (value < lo) {\n-                lo = value;\n-            }\n-            if (!fallthrough) {\n-                Consumer<? super C> prevCase = case_;\n-                case_ = C -> {\n-                    prevCase.accept(C);\n-                    C.goto_(endLabel);\n-                };\n-            }\n-            cases.put(value, case_);\n-            return this;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public SwitchBuilder withDefault(Consumer<? super C> defaultCase) {\n-            if (this.defaultCase != null) {\n-                throw new IllegalStateException(\"default already set\");\n-            }\n-            this.defaultCase = defaultCase;\n-            return this;\n-        }\n-\n-        Opcode switchCode() {\n-            int nlabels = cases.size();\n-            \/\/ Determine whether to issue a tableswitch or a lookupswitch\n-            \/\/ instruction.\n-            long table_space_cost = 4 + ((long) hi - lo + 1); \/\/ words\n-            long lookup_space_cost = 3 + 2 * (long) nlabels;\n-            return\n-                    nlabels > 0 &&\n-                            table_space_cost <= lookup_space_cost\n-                            ?\n-                            Opcode.TABLESWITCH : Opcode.LOOKUPSWITCH;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/MacroCodeBuilder.java","additions":0,"deletions":704,"binary":false,"changes":704,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-\/**\n- * Class member builder.\n- *\n- * @param <S> the type of symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <E> the type of pool entries\n- * @param <M> the type of this builder\n- *\/\n-public class MemberBuilder<S, T, E, M extends MemberBuilder<S, T, E, M>> extends DeclBuilder<S, T, E, M> {\n-\n-    CharSequence name;\n-    T desc;\n-\n-    \/**\n-     * Create a member builder.\n-     *\n-     * @param name the name of the class member\n-     * @param type the type descriptor of the class member\n-     * @param poolHelper the helper to build the constant pool\n-     * @param typeHelper the helper to use to manipulate type descriptors\n-     *\/\n-    MemberBuilder(CharSequence name, T type, PoolHelper<S, T, E> poolHelper, TypeHelper<S, T> typeHelper) {\n-        super(poolHelper, typeHelper);\n-        this.name = name;\n-        this.desc = type;\n-    }\n-\n-    \/**\n-     * Build the member.\n-     *\n-     * @param buf the {@code GrowableByteBuffer} to build the member into\n-     *\/\n-    protected void build(GrowableByteBuffer buf) {\n-        addAnnotations();\n-        buf.writeChar(flags);\n-        buf.writeChar(poolHelper.putUtf8(name));\n-        buf.writeChar(poolHelper.putType(desc));\n-        buf.writeChar(nattrs);\n-        buf.writeBytes(attributes);\n-    }\n-\n-    \/**\n-     * Build the member.\n-     *\n-     * @return a byte array representation of the member\n-     *\/\n-    protected byte[] build() {\n-        GrowableByteBuffer buf = new GrowableByteBuffer();\n-        addAnnotations();\n-        build(buf);\n-        return buf.bytes();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/MemberBuilder.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import jdk.experimental.bytecode.CodeBuilder.JumpMode;\n-\n-import java.util.Iterator;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-public class MethodBuilder<S, T, E> extends MemberBuilder<S, T, E, MethodBuilder<S, T, E>> {\n-\n-    S thisClass;\n-    ParameterAnnotationsBuilder runtimeVisibleParameterAnnotations;\n-    ParameterAnnotationsBuilder runtimeInvisibleParameterAnnotations;\n-\n-    public MethodBuilder(S thisClass, CharSequence name, T type, PoolHelper<S, T, E> pool, TypeHelper<S, T> typeHelper) {\n-        super(name, type, pool, typeHelper);\n-        this.thisClass = thisClass;\n-    }\n-\n-    public <C extends CodeBuilder<S, T, E, ?>> MethodBuilder<S, T, E> withCode(Function<? super MethodBuilder<S, T, E>, ? extends C> func,\n-                                                                               Consumer<? super C> code) {\n-        C codeBuilder = func.apply(this);\n-        int start = attributes.offset;\n-        try {\n-            code.accept(codeBuilder);\n-        } catch (MacroCodeBuilder.WideJumpException ex) {\n-            \/\/wide jumps! Redo the code\n-            ((MacroCodeBuilder<S, T, E, ?>) codeBuilder).jumpMode = JumpMode.WIDE;\n-            ((MacroCodeBuilder<S, T, E, ?>) codeBuilder).clear();\n-            code.accept(codeBuilder);\n-        }\n-\n-        attributes.writeChar(poolHelper.putUtf8(\"Code\"));\n-        attributes.writeInt(0);\n-        codeBuilder.build(attributes);\n-        int length = attributes.offset - start;\n-        \/\/avoid using lambda here\n-        int prevOffset = attributes.offset;\n-        try {\n-            attributes.offset = start + 2;\n-            attributes.writeInt(length - 6);\n-        } finally {\n-            attributes.offset = prevOffset;\n-        }\n-        nattrs++;\n-        return this;\n-    }\n-\n-    public MethodBuilder<S, T, E> withCode(Consumer<? super CodeBuilder<S, T, E, ?>> code) {\n-        return withCode(CodeBuilder::new, code);\n-    }\n-\n-    @SuppressWarnings({\"varargs\", \"unchecked\"})\n-    public MethodBuilder<S, T, E> withExceptions(S... exceptions) {\n-        attributes.writeChar(poolHelper.putUtf8(\"Exceptions\"));\n-        attributes.writeInt(2 + (2 * exceptions.length));\n-        attributes.writeChar(exceptions.length);\n-        for (S exception : exceptions) {\n-            attributes.writeChar(poolHelper.putClass(exception));\n-        }\n-        nattrs++;\n-        return this;\n-    }\n-\n-    public MethodBuilder<S, T, E> withParameterAnnotation(AnnotationsBuilder.Kind kind, int nparam, T annoType) {\n-        getParameterAnnotations(kind).builders[nparam].withAnnotation(annoType, null);\n-        return this;\n-    }\n-\n-    public MethodBuilder<S, T, E> withParameterAnnotation(AnnotationsBuilder.Kind kind, int nparam, T annoType, Consumer<? super AnnotationsBuilder<S, T, E>.AnnotationElementBuilder> annotations) {\n-        getParameterAnnotations(kind).builders[nparam].withAnnotation(annoType, annotations);\n-        return this;\n-    }\n-\n-    private ParameterAnnotationsBuilder getParameterAnnotations(AnnotationsBuilder.Kind kind) {\n-        switch (kind) {\n-            case RUNTIME_INVISIBLE:\n-                if (runtimeInvisibleParameterAnnotations == null) {\n-                    runtimeInvisibleParameterAnnotations = new ParameterAnnotationsBuilder();\n-                }\n-                return runtimeInvisibleParameterAnnotations;\n-            case RUNTIME_VISIBLE:\n-                if (runtimeVisibleParameterAnnotations == null) {\n-                    runtimeVisibleParameterAnnotations = new ParameterAnnotationsBuilder();\n-                }\n-                return runtimeVisibleParameterAnnotations;\n-        }\n-        throw new IllegalStateException();\n-    }\n-\n-    class ParameterAnnotationsBuilder {\n-\n-        GrowableByteBuffer parameterAnnos = new GrowableByteBuffer();\n-\n-        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-        AnnotationsBuilder<S, T, E>[] builders = new AnnotationsBuilder[nparams()];\n-\n-        ParameterAnnotationsBuilder() {\n-            for (int i = 0; i < builders.length; i++) {\n-                builders[i] = new AnnotationsBuilder<>(poolHelper, typeHelper);\n-            }\n-        }\n-\n-        byte[] build() {\n-            parameterAnnos.writeByte(builders.length);\n-            for (AnnotationsBuilder<S, T, E> builder : builders) {\n-                parameterAnnos.writeBytes(builder.build());\n-            }\n-            return parameterAnnos.bytes();\n-        }\n-\n-        int nparams() {\n-            Iterator<T> paramsIt = typeHelper.parameterTypes(desc);\n-            int nparams = 0;\n-            while (paramsIt.hasNext()) {\n-                paramsIt.next();\n-                nparams++;\n-            }\n-            return nparams;\n-        }\n-    }\n-\n-    @Override\n-    void addAnnotations() {\n-        super.addAnnotations();\n-        if (runtimeInvisibleParameterAnnotations != null) {\n-            withAttribute(\"RuntimeInvisibleParameterAnnotations\", runtimeInvisibleParameterAnnotations.build());\n-        }\n-        if (runtimeVisibleParameterAnnotations != null) {\n-            withAttribute(\"RuntimeVisibleParameterAnnotations\", runtimeVisibleParameterAnnotations.build());\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/MethodBuilder.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -1,260 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import jdk.experimental.bytecode.MacroCodeBuilder.CondKind;\n-\n-public enum Opcode {\n-\n-    NOP(0),\n-    ACONST_NULL(1),\n-    ICONST_M1(2),\n-    ICONST_0(3),\n-    ICONST_1(4),\n-    ICONST_2(5),\n-    ICONST_3(6),\n-    ICONST_4(7),\n-    ICONST_5(8),\n-    LCONST_0(9),\n-    LCONST_1(10),\n-    FCONST_0(11),\n-    FCONST_1(12),\n-    FCONST_2(13),\n-    DCONST_0(14),\n-    DCONST_1(15),\n-    BIPUSH(16),\n-    SIPUSH(17),\n-    LDC(18),\n-    LDC_W(19),\n-    LDC2_W(20),\n-    ILOAD(21),\n-    LLOAD(22),\n-    FLOAD(23),\n-    DLOAD(24),\n-    ALOAD(25),\n-    ILOAD_0(26),\n-    ILOAD_1(27),\n-    ILOAD_2(28),\n-    ILOAD_3(29),\n-    LLOAD_0(30),\n-    LLOAD_1(31),\n-    LLOAD_2(32),\n-    LLOAD_3(33),\n-    FLOAD_0(34),\n-    FLOAD_1(35),\n-    FLOAD_2(36),\n-    FLOAD_3(37),\n-    DLOAD_0(38),\n-    DLOAD_1(39),\n-    DLOAD_2(40),\n-    DLOAD_3(41),\n-    ALOAD_0(42),\n-    ALOAD_1(43),\n-    ALOAD_2(44),\n-    ALOAD_3(45),\n-    IALOAD(46),\n-    LALOAD(47),\n-    FALOAD(48),\n-    DALOAD(49),\n-    AALOAD(50),\n-    BALOAD(51),\n-    CALOAD(52),\n-    SALOAD(53),\n-    ISTORE(54),\n-    LSTORE(55),\n-    FSTORE(56),\n-    DSTORE(57),\n-    ASTORE(58),\n-    ISTORE_0(59),\n-    ISTORE_1(60),\n-    ISTORE_2(61),\n-    ISTORE_3(62),\n-    LSTORE_0(63),\n-    LSTORE_1(64),\n-    LSTORE_2(65),\n-    LSTORE_3(66),\n-    FSTORE_0(67),\n-    FSTORE_1(68),\n-    FSTORE_2(69),\n-    FSTORE_3(70),\n-    DSTORE_0(71),\n-    DSTORE_1(72),\n-    DSTORE_2(73),\n-    DSTORE_3(74),\n-    ASTORE_0(75),\n-    ASTORE_1(76),\n-    ASTORE_2(77),\n-    ASTORE_3(78),\n-    IASTORE(79),\n-    LASTORE(80),\n-    FASTORE(81),\n-    DASTORE(82),\n-    AASTORE(83),\n-    BASTORE(84),\n-    CASTORE(85),\n-    SASTORE(86),\n-    POP(87),\n-    POP2(88),\n-    DUP(89),\n-    DUP_X1(90),\n-    DUP_X2(91),\n-    DUP2(92),\n-    DUP2_X1(93),\n-    DUP2_X2(94),\n-    SWAP(95),\n-    IADD(96),\n-    LADD(97),\n-    FADD(98),\n-    DADD(99),\n-    ISUB(100),\n-    LSUB(101),\n-    FSUB(102),\n-    DSUB(103),\n-    IMUL(104),\n-    LMUL(105),\n-    FMUL(106),\n-    DMUL(107),\n-    IDIV(108),\n-    LDIV(109),\n-    FDIV(110),\n-    DDIV(111),\n-    IREM(112),\n-    LREM(113),\n-    FREM(114),\n-    DREM(115),\n-    INEG(116),\n-    LNEG(117),\n-    FNEG(118),\n-    DNEG(119),\n-    ISHL(120),\n-    LSHL(121),\n-    ISHR(122),\n-    LSHR(123),\n-    IUSHR(124),\n-    LUSHR(125),\n-    IAND(126),\n-    LAND(127),\n-    IOR(128),\n-    LOR(129),\n-    IXOR(130),\n-    LXOR(131),\n-    IINC(132),\n-    I2L(133),\n-    I2F(134),\n-    I2D(135),\n-    L2I(136),\n-    L2F(137),\n-    L2D(138),\n-    F2I(139),\n-    F2L(140),\n-    F2D(141),\n-    D2I(142),\n-    D2L(143),\n-    D2F(144),\n-    I2B(145),\n-    I2C(146),\n-    I2S(147),\n-    LCMP(148),\n-    FCMPL(149),\n-    FCMPG(150),\n-    DCMPL(151),\n-    DCMPG(152),\n-    IFEQ(153),\n-    IFNE(154),\n-    IFLT(155),\n-    IFGE(156),\n-    IFGT(157),\n-    IFLE(158),\n-    IF_ICMPEQ(159),\n-    IF_ICMPNE(160),\n-    IF_ICMPLT(161),\n-    IF_ICMPGE(162),\n-    IF_ICMPGT(163),\n-    IF_ICMPLE(164),\n-    IF_ACMPEQ(165),\n-    IF_ACMPNE(166),\n-    GOTO_(167),\n-    JSR(168),\n-    RET(169),\n-    TABLESWITCH(170),\n-    LOOKUPSWITCH(171),\n-    IRETURN(172),\n-    LRETURN(173),\n-    FRETURN(174),\n-    DRETURN(175),\n-    ARETURN(176),\n-    RETURN(177),\n-    GETSTATIC(178),\n-    PUTSTATIC(179),\n-    GETFIELD(180),\n-    PUTFIELD(181),\n-    INVOKEVIRTUAL(182),\n-    INVOKESPECIAL(183),\n-    INVOKESTATIC(184),\n-    INVOKEINTERFACE(185),\n-    INVOKEDYNAMIC(186),\n-    NEW(187),\n-    NEWARRAY(188),\n-    ANEWARRAY(189),\n-    ARRAYLENGTH(190),\n-    ATHROW(191),\n-    CHECKCAST(192),\n-    INSTANCEOF(193),\n-    MONITORENTER(194),\n-    MONITOREXIT(195),\n-    WIDE(196),\n-    MULTIANEWARRAY(197),\n-    IF_NULL(198),\n-    IF_NONNULL(199),\n-    GOTO_W(200),\n-    JSR_W(201),\n-    DEFAULTVALUE(203),\n-    WITHFIELD(204),\n-    TYPED(212);\n-\n-    int code;\n-\n-    Opcode(int code) {\n-        this.code = code;\n-    }\n-\n-    protected Opcode at(TypeTag type) {\n-        return at(type, 1);\n-    }\n-\n-    protected Opcode at(CondKind cond) {\n-        return at(cond.offset, 1);\n-    }\n-\n-    protected Opcode at(TypeTag type, int multiplier) {\n-        return at(type.offset, multiplier);\n-    }\n-\n-    private Opcode at(int offset, int multiplier) {\n-        if (offset < 0) throw new AssertionError();\n-        return Opcode.values()[code + (multiplier * offset)];\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/Opcode.java","additions":0,"deletions":260,"binary":false,"changes":260,"status":"deleted"},{"patch":"@@ -1,981 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.util.Iterator;\n-\n-\/**\n- * See JVMS, section 4.\n- *\n- * Representation of a Constant Pool, where subclasses of PoolInfo represent the\n- * entries. Concrete implementations provide access to pool entries by index.\n- *\/\n-public abstract class Pool {\n-\n-    public static final int CLASS_TAG = 7;\n-    public static final int CONSTANTDYNAMIC_TAG = 17;\n-    public static final int DOUBLE_TAG = 6;\n-    public static final int FIELDREF_TAG = 9;\n-    public static final int FLOAT_TAG = 4;\n-    public static final int INTEGER_TAG = 3;\n-    public static final int INTERFACEMETHODREF_TAG = 11;\n-    public static final int INVOKEDYNAMIC_TAG = 18;\n-    public static final int LONG_TAG = 5;\n-    public static final int METHODHANDLE_TAG = 15;\n-    public static final int METHODREF_TAG = 10;\n-    public static final int METHODTYPE_TAG = 16;\n-    public static final int MODULE_TAG = 19;\n-    public static final int NAMEANDTYPE_TAG = 12;\n-    public static final int PACKAGE_TAG = 20;\n-    public static final int STRING_TAG = 8;\n-    public static final int UNICODE_TAG = 2;\n-    public static final int UTF8_TAG = 1;\n-\n-    protected abstract PoolInfo getSafe(int index);\n-    \n-    public abstract int size();\n-\n-    public PoolInfo get(int index) throws InvalidIndex {\n-        if (index <= 0 || index >= size())\n-            throw new InvalidIndex(index);\n-        PoolInfo info = getSafe(index);\n-        if (info == null) {\n-            \/\/ this occurs for indices referencing the \"second half\" of an\n-            \/\/ 8 byte constant, such as CONSTANT_Double or CONSTANT_Long\n-            throw new InvalidIndex(index);\n-        }\n-        return info;\n-    }\n-\n-    public int byteLength() {\n-        int length = 2;\n-        for (int i = 1; i < size();) {\n-            PoolInfo cpInfo = getSafe(i);\n-            length += cpInfo.byteLength();\n-            i += cpInfo.size();\n-        }\n-        return length;\n-    }\n-\n-    public Iterable<PoolInfo> entries() {\n-        return () -> new Iterator<PoolInfo>() {\n-\n-            @Override\n-            public boolean hasNext() {\n-                return next < size;\n-            }\n-\n-            @Override\n-            public PoolInfo next() {\n-                PoolInfo pi = getSafe(next);\n-                switch (pi.getTag()) {\n-                    case DOUBLE_TAG:\n-                    case LONG_TAG:\n-                        next += 2;\n-                        break;\n-                    default:\n-                        next += 1;\n-                }\n-                return pi;\n-            }\n-\n-            @Override\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            private int next = 1;\n-            private final int size = size();\n-\n-        };\n-    }\n-    \n-    public Iterable<PoolInfoAndIndex> entriesAndIndicies() {\n-        return () -> new Iterator<PoolInfoAndIndex>() {\n-\n-            @Override\n-            public boolean hasNext() {\n-                return next < size;\n-            }\n-\n-            @Override\n-            public PoolInfoAndIndex next() {\n-                int i = next;\n-                PoolInfo pi = getSafe(i);\n-                switch (pi.getTag()) {\n-                    case DOUBLE_TAG:\n-                    case LONG_TAG:\n-                        next += 2;\n-                        break;\n-                    default:\n-                        next += 1;\n-                }\n-                return new PoolInfoAndIndex(pi, i);\n-            }\n-\n-            @Override\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            private int next = 1;\n-            private final int size = size();\n-\n-        };\n-    }\n-    \n-    \n-    public class PoolInfoAndIndex {\n-        public final PoolInfo info;\n-        public final int index;\n-        PoolInfoAndIndex(PoolInfo info, int index) {\n-            this.info = info;\n-            this.index = index;\n-        }\n-    }\n-\n-    private PoolInfo get(int index, int expected_type) throws InvalidIndex, UnexpectedEntry {\n-        PoolInfo info = get(index);\n-        if (info.getTag() != expected_type) {\n-            throw new UnexpectedEntry(index, expected_type, info.getTag());\n-        }\n-        return info;\n-    }\n-\n-    public Utf8_info getUTF8Info(int index) throws InvalidIndex, UnexpectedEntry {\n-        return ((Utf8_info) get(index, UTF8_TAG));\n-    }\n-\n-    public Class_info getClassInfo(int index) throws InvalidIndex, UnexpectedEntry {\n-        return ((Class_info) get(index, CLASS_TAG));\n-    }\n-\n-    public Module_info getModuleInfo(int index) throws InvalidIndex, UnexpectedEntry {\n-        return ((Module_info) get(index, MODULE_TAG));\n-    }\n-\n-    public NameAndType_info getNameAndTypeInfo(int index) throws InvalidIndex, UnexpectedEntry {\n-        return ((NameAndType_info) get(index, NAMEANDTYPE_TAG));\n-    }\n-\n-    public Package_info getPackageInfo(int index) throws InvalidIndex, UnexpectedEntry {\n-        return ((Package_info) get(index, PACKAGE_TAG));\n-    }\n-\n-    public String getUTF8Value(int index) throws InvalidIndex, UnexpectedEntry {\n-        return getUTF8Info(index).value;\n-    }\n-\n-    public int getUTF8Index(String value) throws EntryNotFound {\n-        for (int i = 1; i < size(); i++) {\n-            PoolInfo info = getSafe(i);\n-            if (info instanceof Utf8_info &&\n-                    ((Utf8_info) info).value.equals(value))\n-                return i;\n-        }\n-        throw new EntryNotFound(value);\n-    }\n-\n-    public interface Visitor<R, P> {\n-\n-        R visitClass(Class_info info, P p);\n-\n-        R visitDouble(Double_info info, P p);\n-\n-        R visitFieldref(Fieldref_info info, P p);\n-\n-        R visitFloat(Float_info info, P p);\n-\n-        R visitInteger(Integer_info info, P p);\n-\n-        R visitInterfaceMethodref(InterfaceMethodref_info info, P p);\n-\n-        R visitInvokeDynamic(InvokeDynamic_info info, P p);\n-\n-        R visitLong(Long_info info, P p);\n-\n-        R visitMethodref(Methodref_info info, P p);\n-\n-        R visitMethodHandle(MethodHandle_info info, P p);\n-\n-        R visitMethodType(MethodType_info info, P p);\n-\n-        R visitModule(Module_info info, P p);\n-\n-        R visitNameAndType(NameAndType_info info, P p);\n-\n-        R visitPackage(Package_info info, P p);\n-\n-        R visitString(String_info info, P p);\n-\n-        R visitUtf8(Utf8_info info, P p);\n-    }\n-\n-    public abstract class PoolInfo {\n-\n-        public Pool getPool() {\n-            return Pool.this;\n-        }\n-\n-        public abstract int getTag();\n-\n-        \/**\n-         * @return The number of slots in the constant pool used by this entry.\n-         * 2 for CONSTANT_Double and CONSTANT_Long; 1 for everything else.\n-         *\/\n-        public int size() {\n-            return 1;\n-        }\n-\n-        public abstract int byteLength();\n-\n-        public abstract <R, D> R accept(Visitor<R, D> visitor, D data);\n-    }\n-\n-    public abstract class RefPoolInfo extends PoolInfo {\n-\n-        protected RefPoolInfo(int tag, int class_index, int name_and_type_index) {\n-            this.tag = tag;\n-            this.class_index = class_index;\n-            this.name_and_type_index = name_and_type_index;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return tag;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 5;\n-        }\n-\n-        public Class_info getClassInfo() throws PoolException {\n-            return Pool.this.getClassInfo(class_index);\n-        }\n-\n-        public String getClassName() throws PoolException {\n-            return Pool.this.getClassInfo(class_index).getName();\n-        }\n-\n-        public NameAndType_info getNameAndTypeInfo() throws PoolException {\n-            return Pool.this.getNameAndTypeInfo(name_and_type_index);\n-        }\n-\n-        public final int tag;\n-        public final int class_index;\n-        public final int name_and_type_index;\n-    }\n-\n-    public class Class_info extends PoolInfo {\n-\n-        public Class_info(int name_index) {\n-            this.name_index = name_index;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return CLASS_TAG;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 3;\n-        }\n-\n-        \/**\n-         * Get the raw value of the class referenced by this constant pool\n-         * entry.This will either be the name of the class, in internal form, or\n-         * a descriptor for an array class.\n-         *\n-         * @return the raw value of the class\n-         * @throws PoolException\n-         *\/\n-        public String getName() throws PoolException {\n-            return getUTF8Value(name_index);\n-        }\n-\n-        \/**\n-         * If this constant pool entry identifies either a class or interface\n-         * type, or a possibly multi-dimensional array of a class of interface\n-         * type, return the name of the class or interface in internal\n-         * form.Otherwise, (i.e. if this is a possibly multi-dimensional array\n-         * of a primitive type), return null.\n-         *\n-         * @return the base class or interface name\n-         * @throws PoolException\n-         *\/\n-        public String getBaseName() throws PoolException {\n-            String name = getName();\n-            if (name.startsWith(\"[\")) {\n-                int index = name.indexOf(\"[L\");\n-                if (index == -1)\n-                    index = name.indexOf(\"[Q\");\n-                if (index == -1) {\n-                    return null;\n-                }\n-                return name.substring(index + 2, name.length() - 1);\n-            } else {\n-                return name;\n-            }\n-        }\n-\n-        public int getDimensionCount() throws PoolException {\n-            String name = getName();\n-            int count = 0;\n-            while (name.charAt(count) == '[') {\n-                count++;\n-            }\n-            return count;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Class_info[name_index: \" + name_index + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitClass(this, data);\n-        }\n-\n-        public final int name_index;\n-    }\n-\n-    public class Double_info extends PoolInfo {\n-\n-        public Double_info(double value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return DOUBLE_TAG;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 9;\n-        }\n-\n-        @Override\n-        public int size() {\n-            return 2;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Double_info[value: \" + value + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitDouble(this, data);\n-        }\n-\n-        public final double value;\n-    }\n-\n-    public class Fieldref_info extends RefPoolInfo {\n-\n-        public Fieldref_info(int class_index, int name_and_type_index) {\n-            super(FIELDREF_TAG, class_index, name_and_type_index);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Fieldref_info[class_index: \" + class_index + \", name_and_type_index: \" + name_and_type_index + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitFieldref(this, data);\n-        }\n-    }\n-\n-    public class Float_info extends PoolInfo {\n-\n-        public Float_info(float value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return FLOAT_TAG;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 5;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Float_info[value: \" + value + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitFloat(this, data);\n-        }\n-\n-        public final float value;\n-    }\n-\n-    public class Integer_info extends PoolInfo {\n-\n-        public Integer_info(int value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return INTEGER_TAG;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 5;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Integer_info[value: \" + value + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitInteger(this, data);\n-        }\n-\n-        public final int value;\n-    }\n-\n-    public class InterfaceMethodref_info extends RefPoolInfo {\n-\n-        public InterfaceMethodref_info(int class_index, int name_and_type_index) {\n-            super(INTERFACEMETHODREF_TAG, class_index, name_and_type_index);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_InterfaceMethodref_info[class_index: \" + class_index + \", name_and_type_index: \" + name_and_type_index + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitInterfaceMethodref(this, data);\n-        }\n-    }\n-\n-    public class InvokeDynamic_info extends PoolInfo {\n-\n-        public InvokeDynamic_info(int bootstrap_method_index, int name_and_type_index) {\n-            this.bootstrap_method_attr_index = bootstrap_method_index;\n-            this.name_and_type_index = name_and_type_index;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return INVOKEDYNAMIC_TAG;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 5;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_InvokeDynamic_info[bootstrap_method_index: \" + bootstrap_method_attr_index + \", name_and_type_index: \" + name_and_type_index + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitInvokeDynamic(this, data);\n-        }\n-\n-        public NameAndType_info getNameAndTypeInfo() throws PoolException {\n-            return Pool.this.getNameAndTypeInfo(name_and_type_index);\n-        }\n-\n-        public final int bootstrap_method_attr_index;\n-        public final int name_and_type_index;\n-    }\n-\n-    public class Long_info extends PoolInfo {\n-\n-        public Long_info(long value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return LONG_TAG;\n-        }\n-\n-        @Override\n-        public int size() {\n-            return 2;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 9;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Long_info[value: \" + value + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitLong(this, data);\n-        }\n-\n-        public final long value;\n-    }\n-\n-    public class MethodHandle_info extends PoolInfo {\n-\n-        public MethodHandle_info(int ref_kind, int member_index) {\n-            this.reference_kind = ref_kind;\n-            this.reference_index = member_index;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return METHODHANDLE_TAG;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 4;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_MethodHandle_info[ref_kind: \" + RefKind.getRefkind(reference_kind) + \", member_index: \" + reference_index + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitMethodHandle(this, data);\n-        }\n-\n-        public RefPoolInfo getRefPoolInfo() throws PoolException {\n-            int expected = METHODREF_TAG;\n-            int actual = Pool.this.get(reference_index).getTag();\n-            \/\/ allow these tag types also:\n-            switch (actual) {\n-                case FIELDREF_TAG:\n-                case INTERFACEMETHODREF_TAG:\n-                    expected = actual;\n-            }\n-            return (RefPoolInfo) Pool.this.get(reference_index, expected);\n-        }\n-\n-        public final int reference_kind;\n-        public final int reference_index;\n-    }\n-\n-    public class MethodType_info extends PoolInfo {\n-\n-        public MethodType_info(int signature_index) {\n-            this.descriptor_index = signature_index;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return METHODTYPE_TAG;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 3;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_MethodType_info[signature_index: \" + descriptor_index + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitMethodType(this, data);\n-        }\n-\n-        public String getType() throws PoolException {\n-            return Pool.this.getUTF8Value(descriptor_index);\n-        }\n-\n-        public final int descriptor_index;\n-    }\n-\n-    public class Methodref_info extends RefPoolInfo {\n-\n-        public Methodref_info(int class_index, int name_and_type_index) {\n-            super(METHODREF_TAG, class_index, name_and_type_index);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Methodref_info[class_index: \" + class_index + \", name_and_type_index: \" + name_and_type_index + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitMethodref(this, data);\n-        }\n-    }\n-\n-    public class Module_info extends PoolInfo {\n-\n-        public Module_info(int name_index) {\n-            this.name_index = name_index;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return MODULE_TAG;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 3;\n-        }\n-\n-        \/**\n-         * Get the raw value of the module name referenced by this constant pool\n-         * entry. This will be the name of the module.\n-         *\n-         * @return the raw value of the module name\n-         *\/\n-        public String getName() throws PoolException {\n-            return Pool.this.getUTF8Value(name_index);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Module_info[name_index: \" + name_index + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitModule(this, data);\n-        }\n-\n-        public final int name_index;\n-    }\n-\n-    public class NameAndType_info extends PoolInfo {\n-\n-        public NameAndType_info(int name_index, int type_index) {\n-            this.name_index = name_index;\n-            this.type_index = type_index;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return NAMEANDTYPE_TAG;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 5;\n-        }\n-\n-        public String getName() throws PoolException {\n-            return Pool.this.getUTF8Value(name_index);\n-        }\n-\n-        public String getType() throws PoolException {\n-            return Pool.this.getUTF8Value(type_index);\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitNameAndType(this, data);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_NameAndType_info[name_index: \" + name_index + \", type_index: \" + type_index + \"]\";\n-        }\n-\n-        public final int name_index;\n-        public final int type_index;\n-    }\n-\n-    public class Package_info extends PoolInfo {\n-\n-        public Package_info(int name_index) {\n-            this.name_index = name_index;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return PACKAGE_TAG;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 3;\n-        }\n-\n-        \/**\n-         * Get the raw value of the package name referenced by this constant\n-         * pool entry.This will be the name of the package, in internal form.\n-         *\n-         * @return the raw value of the module name\n-         * @throws jdk.experimental.bytecode.classfile.ConstantPoolException\n-         *\/\n-        public String getName() throws PoolException {\n-            return Pool.this.getUTF8Value(name_index);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Package_info[name_index: \" + name_index + \"]\";\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitPackage(this, data);\n-        }\n-\n-        public final int name_index;\n-    }\n-\n-    public class String_info extends PoolInfo {\n-\n-        public String_info(int string_index) {\n-            this.string_index = string_index;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return STRING_TAG;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            return 3;\n-        }\n-\n-        public String getString() throws PoolException {\n-            return Pool.this.getUTF8Value(string_index);\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitString(this, data);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_String_info[class_index: \" + string_index + \"]\";\n-        }\n-\n-        public final int string_index;\n-    }\n-\n-    public class Utf8_info extends PoolInfo {\n-\n-        public Utf8_info(String value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public int getTag() {\n-            return UTF8_TAG;\n-        }\n-\n-        @Override\n-        public int byteLength() {\n-            class SizeOutputStream extends OutputStream {\n-\n-                @Override\n-                public void write(int b) {\n-                    size++;\n-                }\n-                int size;\n-            }\n-            SizeOutputStream sizeOut = new SizeOutputStream();\n-            DataOutputStream out = new DataOutputStream(sizeOut);\n-            try {\n-                out.writeUTF(value);\n-            } catch (IOException ignore) {\n-            }\n-            return 1 + sizeOut.size;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            if (value.length() < 32 && isPrintableAscii(value)) {\n-                return \"CONSTANT_Utf8_info[value: \\\"\" + value + \"\\\"]\";\n-            } else {\n-                return \"CONSTANT_Utf8_info[value: (\" + value.length() + \" chars)]\";\n-            }\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitUtf8(this, data);\n-        }\n-\n-        public final String value;\n-    }\n-\n-    public static enum RefKind {\n-        GETFIELD_REF(1),\n-        GETSTATIC_REF(2),\n-        PUTFIELD_REF(3),\n-        PUTSTATIC_REF(4),\n-        INVOKEVIRTUAL_REF(5),\n-        INVOKESTATIC_REF(6),\n-        INVOKESPECIAL_REF(7),\n-        NEWINVOKESPECIAL_REF(8),\n-        INVOKEINTERFACE_REF(9);\n-\n-        public final int tag;\n-\n-        RefKind(int tag) {\n-            this.tag = tag;\n-        }\n-\n-        public static RefKind getRefkind(int tag) {\n-            switch (tag) {\n-                case 1:\n-                    return GETFIELD_REF;\n-                case 2:\n-                    return GETSTATIC_REF;\n-                case 3:\n-                    return PUTFIELD_REF;\n-                case 4:\n-                    return PUTSTATIC_REF;\n-                case 5:\n-                    return INVOKEVIRTUAL_REF;\n-                case 6:\n-                    return INVOKESTATIC_REF;\n-                case 7:\n-                    return INVOKESPECIAL_REF;\n-                case 8:\n-                    return NEWINVOKESPECIAL_REF;\n-                case 9:\n-                    return INVOKEINTERFACE_REF;\n-                default:\n-                    return null;\n-            }\n-        }\n-    }\n-\n-    static boolean isPrintableAscii(String s) {\n-        for (int i = 0; i < s.length(); i++) {\n-            char c = s.charAt(i);\n-            if (c < 32 || c >= 127) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public static class InvalidIndex extends PoolException {\n-\n-        private static final long serialVersionUID = -4350294289300939730L;\n-\n-        public InvalidIndex(int index) {\n-            super(index);\n-        }\n-\n-        @Override\n-        public String getMessage() {\n-            \/\/ i18n\n-            return \"invalid index #\" + index;\n-        }\n-    }\n-\n-    public static class UnexpectedEntry extends PoolException {\n-\n-        private static final long serialVersionUID = 6986335935377933211L;\n-\n-        public UnexpectedEntry(int index, int expected_tag, int found_tag) {\n-            super(index);\n-            this.expected_tag = expected_tag;\n-            this.found_tag = found_tag;\n-        }\n-\n-        @Override\n-        public String getMessage() {\n-            \/\/ i18n?\n-            return \"unexpected entry at #\" + index + \" -- expected tag \" + expected_tag + \", found \" + found_tag;\n-        }\n-\n-        public final int expected_tag;\n-        public final int found_tag;\n-    }\n-\n-    public static class InvalidEntry extends PoolException {\n-\n-        private static final long serialVersionUID = 1000087545585204447L;\n-\n-        public InvalidEntry(int index, int tag) {\n-            super(index);\n-            this.tag = tag;\n-        }\n-\n-        @Override\n-        public String getMessage() {\n-            \/\/ i18n?\n-            return \"unexpected tag at #\" + index + \": \" + tag;\n-        }\n-\n-        public final int tag;\n-    }\n-\n-    public static class EntryNotFound extends PoolException {\n-\n-        private static final long serialVersionUID = 2885537606468581850L;\n-\n-        public EntryNotFound(Object value) {\n-            super(-1);\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public String getMessage() {\n-            \/\/ i18n?\n-            return \"value not found: \" + value;\n-        }\n-\n-        public final Object value;\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/Pool.java","additions":0,"deletions":981,"binary":false,"changes":981,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-\/**\n- * Interface for low-level building of constant pool. Indicies are used rather\n- * than strings and thus component parts aren't added automatically.\n- *\n- * @param <R> the type of the constant pool representation that is built\n- *\/\n-public interface PoolBuilder<R> {\n-\n-    int putClass(int utf8_idx);\n-\n-    int putConstantDynamic(int bsmIndex, int nameAndType_idx);\n-\n-    int putDouble(double d);\n-\n-    int putFieldRef(int owner_idx, int nameAndType_idx);\n-\n-    int putFloat(float f);\n-\n-    int putMethodHandle(int refKind, int ref_idx);\n-\n-    int putInt(int i);\n-\n-    int putInvokeDynamic(int bsmIndex, int nameAndType_idx);\n-\n-    int putLong(long l);\n-\n-    int putMemberRef(PoolTag tag, int owner_idx, int nameAndType_idx);\n-\n-    int putMethodRef(int owner_idx, int nameAndType_idx, boolean isInterface);\n-\n-    int putMethodType(int desc_idx);\n-\n-    int putNameAndType(int name_idx, int type_idx);\n-\n-    int putString(int utf8_index);\n-\n-    int putUtf8(CharSequence s);\n-\n-    \/**\n-     * \n-     * @return count of constant pool indicies\n-     *\/\n-    int size();\n-\n-    \/**\n-     * \n-     * @return the representation of the constant pool\n-     *\/\n-    R representation();\n-    \n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/PoolBuilder.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-\/*\n- * Base constant pool exception.\n- *\/\n-public class PoolException extends Exception {\n-    private static final long serialVersionUID = -2324397349644754565L;\n-    public PoolException(int index) {\n-        this.index = index;\n-    }\n-\n-    public final int index;\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/PoolException.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.function.Consumer;\n-import java.util.function.ToIntBiFunction;\n-\n-\/**\n- * An interface for building and tracking constant pools.\n- *\n- * @param <S> the type of the symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <R> the type of pool entries\n- *\/\n-public interface PoolHelper<S, T, R> {\n-    int putClass(S symbol);\n-\n-    int putValueClass(S symbol);\n-\n-    int putFieldRef(S owner, CharSequence name, T type);\n-\n-    int putMethodRef(S owner, CharSequence name, T type, boolean isInterface);\n-\n-    int putUtf8(CharSequence s);\n-\n-    int putInt(int i);\n-\n-    int putFloat(float f);\n-\n-    int putLong(long l);\n-\n-    int putDouble(double d);\n-\n-    int putString(String s);\n-\n-    int putValue(Object v);\n-\n-    int putType(T t);\n-\n-    int putMethodType(T t);\n-\n-    int putMethodHandle(int refKind, S owner, CharSequence name, T type);\n-\n-    int putMethodHandle(int refKind, S owner, CharSequence name, T type, boolean isInterface);\n-\n-    int putInvokeDynamic(CharSequence invokedName, T invokedType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, R>> staticArgs);\n-\n-    int putConstantDynamic(CharSequence constName, T constType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, R>> staticArgs);\n-\n-    int size();\n-\n-    R representation();\n-\n-    interface StaticArgListBuilder<S, T, E> {\n-        StaticArgListBuilder<S, T, E> add(int i);\n-        StaticArgListBuilder<S, T, E> add(float f);\n-        StaticArgListBuilder<S, T, E> add(long l);\n-        StaticArgListBuilder<S, T, E> add(double d);\n-        StaticArgListBuilder<S, T, E> add(String s);\n-        StaticArgListBuilder<S, T, E> add(int refKind, S owner, CharSequence name, T type);\n-        <Z> StaticArgListBuilder<S, T, E> add(Z z, ToIntBiFunction<PoolHelper<S, T, E>, Z> poolFunc);\n-        StaticArgListBuilder<S, T, E> add(CharSequence constName, T constType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, E>> staticArgList);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/PoolHelper.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import static jdk.experimental.bytecode.Pool.*;\n-\n-public enum PoolTag {\n-    UTF8                   (UTF8_TAG),\n-    UNICODE                (UNICODE_TAG),\n-    INTEGER                (INTEGER_TAG),\n-    FLOAT                  (FLOAT_TAG),\n-    LONG                   (LONG_TAG),\n-    DOUBLE                 (DOUBLE_TAG),\n-    CLASS                  (CLASS_TAG),\n-    STRING                 (STRING_TAG),\n-    FIELDREF               (FIELDREF_TAG),\n-    METHODREF              (METHODREF_TAG),\n-    INTERFACEMETHODREF     (INTERFACEMETHODREF_TAG),\n-    NAMEANDTYPE            (NAMEANDTYPE_TAG),\n-    METHODHANDLE           (METHODHANDLE_TAG),\n-    METHODTYPE             (METHODTYPE_TAG),\n-    CONSTANTDYNAMIC        (CONSTANTDYNAMIC_TAG),\n-    INVOKEDYNAMIC          (INVOKEDYNAMIC_TAG),\n-    MODULE                 (MODULE_TAG),\n-    PACKAGE                (PACKAGE_TAG);\n-\n-    public final int tag;\n-\n-    PoolTag(int tag) {\n-        this.tag = tag;\n-    }\n-\n-    static PoolTag from(int tag) {\n-        return values()[tag - 1];\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/PoolTag.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-public interface Type {\n-    TypeTag getTag();\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/Type.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.Iterator;\n-\n-\/**\n- * Helper to create and manipulate type descriptors of T.\n- *\n- * @param <S> the type of symbols\n- * @param <T> the type of type descriptors\n- *\/\n-public interface TypeHelper<S, T> {\n-    \/**\n-     * Return the type descriptor of an element given the type\n-     * descriptor of an array.\n-     *\n-     * @param t the type descriptor of the array\n-     * @return the element type\n-     *\/\n-    T elemtype(T t);\n-\n-    \/**\n-     * Return the type descriptor of an array given the type descriptor\n-     * of an element.\n-     *\n-     * @param t the type descriptor of the element\n-     * @return the type descriptor of the array\n-     *\/\n-    T arrayOf(T t);\n-\n-    \/**\n-     * Return an iterator over the type descriptors of the parameters of a\n-     * method.\n-       *\n-     * @param t the method type descriptor\n-     * @return an iterator over the type descriptors of the parameters\n-     *\/\n-    Iterator<T> parameterTypes(T t);\n-\n-    \/**\n-     * Return the type descriptor of a {@code TypeTag}.\n-     *\n-     * @param tag the {@code TypeTag} of a primitive type\n-     * @return the type descriptor of the primitive type\n-     *\/\n-    T fromTag(TypeTag tag);\n-\n-    \/**\n-     * Return the return type descriptor of a method.\n-     *\n-     * @param t the method type descriptor\n-     * @return the return type descriptor\n-     *\/\n-    T returnType(T t);\n-\n-    \/**\n-     * Return the type descriptor for a symbol.\n-     *\n-     * @param s the symbol\n-     * @return the type descriptor\n-     *\/\n-    T type(S s);\n-\n-    \/**\n-     * Return true if the parameter is a value type.\n-     *\n-     * @param t the type descreiptor\n-     * @return true if the given type is a value type\n-     *\/\n-    boolean isValue(T t);\n-\n-    \/**\n-     * For a symbol that corresponds to a value type, return the type descriptor.\n-     *\n-     * @param s the symbol\n-     * @return the type descriptor\n-     *\/\n-    default T valueType(S s) {\n-        return type(s);\n-    }\n-\n-    \/**\n-     * Return the symbol corresponding to a type descriptor.\n-     *\n-     * @param type the type descriptor\n-     * @return the symbol\n-     *\/\n-    S symbol(T type);\n-\n-    \/**\n-     * Return the {@code TypeTag} corresponding to a type descriptor.  Reference\n-     * types return {@code TypeTag.A}.\n-     *\n-     * @param t a type descriptor\n-     * @return the corresponding {@code TypeTag}\n-     *\/\n-    TypeTag tag(T t);\n-\n-    \/**\n-     * Return the symbol corresponding to a JVM type descriptor string.\n-     *\n-     * @param s a JVM type descriptor string\n-     * @return the corresponding symbol\n-     *\/\n-    S symbolFrom(String s);\n-\n-    \/**\n-     * Return the common supertype descriptor of two type descriptors.\n-     *\n-     * @param t1 a type descriptor\n-     * @param t2 a type descriptor\n-     * @return the common supertype descriptor\n-     *\/\n-    T commonSupertype(T t1, T t2);\n-\n-    \/**\n-     * Return the type descriptor for the null type.\n-     *\n-     * @return the type descriptor for the null type\n-     *\/\n-    T nullType();\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/TypeHelper.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-public enum TypeTag implements Type {\n-    \/**\n-     * byte\n-     *\/\n-    B(\"B\", 0, 1, 8),\n-    \/**\n-     * short\n-     *\/\n-    S(\"S\", 0, 1, 9),\n-    \/**\n-     * int\n-     *\/\n-    I(\"I\", 0, 1, 10),\n-    \/**\n-     * float\n-     *\/\n-    F(\"F\", 2, 1, 6),\n-    \/**\n-     * long\n-     *\/\n-    J(\"J\", 1, 2, 11),\n-    \/**\n-     * double\n-     *\/\n-    D(\"D\", 3, 2, 7),\n-    \/**\n-     * Reference type\n-     *\/\n-    A(\"A\", 4, 1, -1),\n-    \/**\n-     * char\n-     *\/\n-    C(\"C\", 0, 1, 5),\n-    \/**\n-     * boolean\n-     *\/\n-    Z(\"Z\", 0, 1, 4),\n-    \/**\n-     * void\n-     *\/\n-    V(\"V\", -1, -1, -1);\n-\n-    String typeStr;\n-    int offset;\n-    int width;\n-    int newarraycode;\n-\n-    TypeTag(String typeStr, int offset, int width, int newarraycode) {\n-        this.typeStr = typeStr;\n-        this.offset = offset;\n-        this.width = width;\n-        this.newarraycode = newarraycode;\n-    }\n-\n-    static TypeTag commonSupertype(TypeTag t1, TypeTag t2) {\n-        if (t1.isIntegral() && t2.isIntegral()) {\n-            int p1 = t1.ordinal();\n-            int p2 = t2.ordinal();\n-            return (p1 <= p2) ? t2 : t1;\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    public int width() {\n-        return width;\n-    }\n-\n-    boolean isIntegral() {\n-        switch (this) {\n-            case B:\n-            case S:\n-            case I:\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    public TypeTag getTag() {\n-        return this;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/TypeTag.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,1263 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Vector;\n-import java.util.function.Consumer;\n-import java.util.function.Supplier;\n-import java.util.function.ToIntFunction;\n-\n-public class TypedCodeBuilder<S, T, E, C extends TypedCodeBuilder<S, T, E, C>> extends MacroCodeBuilder<S, T, E, C> {\n-\n-    State lastStackMapState;\n-    int lastStackMapPc = -1;\n-    Map<CharSequence, LocalVarInfo> lvarOffsets = new HashMap<>();\n-    protected State state;\n-    int depth = 0;\n-    int currLocalOffset = 0;\n-\n-    class StatefulPendingJump extends PendingJump {\n-\n-        State state;\n-\n-        StatefulPendingJump(CharSequence label, int pc, State state) {\n-            super(label, pc);\n-            this.state = state;\n-        }\n-\n-        @Override\n-        boolean resolve(CharSequence label, int pc) {\n-            boolean b = super.resolve(label, pc);\n-            if (b) {\n-                TypedCodeBuilder.this.state = TypedCodeBuilder.this.state.merge(state);\n-            }\n-            return b;\n-        }\n-    }\n-\n-    class LocalVarInfo {\n-        CharSequence name;\n-        int offset;\n-        int depth;\n-        TypeTag type;\n-\n-        LocalVarInfo(CharSequence name, int offset, int depth, TypeTag type) {\n-            this.name = name;\n-            this.offset = offset;\n-            this.depth = depth;\n-            this.type = type;\n-        }\n-    }\n-\n-    public TypedCodeBuilder(MethodBuilder<S, T, E> methodBuilder) {\n-        super(methodBuilder);\n-        T t = methodBuilder.desc;\n-        state = new State();\n-        if ((methodBuilder.flags & Flag.ACC_STATIC.flag) == 0) {\n-            T clazz = typeHelper.type(methodBuilder.thisClass);\n-            state.load(clazz, currLocalOffset++); \/\/TODO: uninit??\n-        }\n-        Iterator<T> paramsIt = typeHelper.parameterTypes(t);\n-        while (paramsIt.hasNext()) {\n-            T p = paramsIt.next();\n-            state.load(p, currLocalOffset);\n-            currLocalOffset += typeHelper.tag(p).width;\n-        }\n-        lastStackMapState = state.dup();\n-        stacksize = state.stack.size();\n-        localsize = state.locals.size();\n-    }\n-\n-    @Override\n-    protected C emitOp(Opcode opcode, Object optPoolValue) {\n-        updateState(opcode, optPoolValue);\n-        return super.emitOp(opcode, optPoolValue);\n-    }\n-\n-    @Override\n-    protected SwitchBuilder makeSwitchBuilder() {\n-        return new TypedSwitchBuilder();\n-    }\n-\n-    class TypedSwitchBuilder extends SwitchBuilder {\n-\n-        @Override\n-        public SwitchBuilder withCase(int value, Consumer<? super C> case_, boolean fallthrough) {\n-            super.withCase(value, c -> {\n-                withLocalScope(() -> {\n-                    State prevState = state;\n-                    state = prevState.dup();\n-                    emitStackMap(c.offset());\n-                    case_.accept(c);\n-                    state = prevState;\n-                });\n-            }, fallthrough);\n-            return this;\n-        }\n-\n-        @Override\n-        public SwitchBuilder withDefault(Consumer<? super C> defaultCase) {\n-            super.withDefault(c -> {\n-                withLocalScope(() -> {\n-                    State prevState = state;\n-                    state = prevState.dup();\n-                    emitStackMap(c.offset());\n-                    defaultCase.accept(c);\n-                    state = prevState;\n-                });\n-            });\n-            return this;\n-        }\n-    }\n-\n-    @Override\n-    public StatefulTypedBuilder typed(TypeTag tag) {\n-        return super.typed(tag, StatefulTypedBuilder::new);\n-    }\n-\n-    public class StatefulTypedBuilder extends LabelledTypedBuilder {\n-\n-        TypeTag tag;\n-\n-        StatefulTypedBuilder(TypeTag tag) {\n-            this.tag = tag;\n-        }\n-\n-        @Override\n-        public C astore_0() {\n-            return storeAndUpdate(super::astore_0);\n-        }\n-\n-        @Override\n-        public C astore_1() {\n-            return storeAndUpdate(super::astore_1);\n-        }\n-\n-        @Override\n-        public C astore_2() {\n-            return storeAndUpdate(super::astore_2);\n-        }\n-\n-        @Override\n-        public C astore_3() {\n-            return storeAndUpdate(super::astore_3);\n-        }\n-\n-        @Override\n-        public C astore(int n) {\n-            return storeAndUpdate(() -> super.astore(n));\n-        }\n-\n-        @Override\n-        public C aastore() {\n-            return storeAndUpdate(super::aastore);\n-        }\n-\n-        @Override\n-        public C areturn() {\n-            state.pop(tag);\n-            state.push(typeHelper.nullType());\n-            return super.areturn();\n-        }\n-\n-        @Override\n-        public C anewarray(S s) {\n-            super.anewarray(s);\n-            state.pop();\n-            state.push(typeHelper.arrayOf(typeHelper.type(s)));\n-            return thisBuilder();\n-        }\n-\n-        @Override\n-        public C anewvaluearray(S s) {\n-            super.anewvaluearray(s);\n-            state.pop();\n-            state.push(typeHelper.arrayOf(typeHelper.valueType(s)));\n-            return thisBuilder();\n-        }\n-\n-        @Override\n-        public C aconst_null() {\n-            super.aconst_null();\n-            state.pop();\n-            state.push(tag);\n-            return thisBuilder();\n-        }\n-\n-        public C if_acmpeq(CharSequence label) {\n-            return jumpAndUpdate(() -> super.if_acmpeq(label));\n-        }\n-\n-        public C if_acmpne(CharSequence label) {\n-            return jumpAndUpdate(() -> super.if_acmpne(label));\n-        }\n-\n-        private C storeAndUpdate(Supplier<C> op) {\n-            state.pop(tag);\n-            state.push(typeHelper.nullType());\n-            return op.get();\n-        }\n-\n-        private C jumpAndUpdate(Supplier<C> op) {\n-            state.pop(tag);\n-            state.pop(tag);\n-            state.push(typeHelper.nullType());\n-            state.push(typeHelper.nullType());\n-            return op.get();\n-        }\n-    }\n-\n-    public class State {\n-        public final ArrayList<T> stack;\n-        public final Vector<T> locals;\n-        boolean alive;\n-\n-        State(ArrayList<T> stack, Vector<T> locals) {\n-            this.stack = stack;\n-            this.locals = locals;\n-            this.alive = true;\n-        }\n-\n-        State() {\n-            this(new ArrayList<>(), new Vector<>());\n-        }\n-\n-        void push(TypeTag tag) {\n-            switch (tag) {\n-                case A:\n-                case V:\n-                    throw new IllegalStateException(\"Bad type tag\");\n-                default:\n-                    push(typeHelper.fromTag(tag));\n-            }\n-        }\n-\n-        void push(T t) {\n-            stack.add(t);\n-            if (width(t) == 2) {\n-                stack.add(null);\n-            }\n-            if (stack.size() > stacksize) {\n-                stacksize = stack.size();\n-            }\n-        }\n-\n-        T peek() {\n-            return stack.get(stack.size() - 1);\n-        }\n-\n-        T tosType() {\n-            T tos = peek();\n-            if (tos == null) {\n-                \/\/double slot\n-                tos = stack.get(stack.size() - 2);\n-            }\n-            return tos;\n-        }\n-\n-        T popInternal() {\n-            return stack.remove(stack.size() - 1);\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        T pop() {\n-            if (stack.size() == 0 || peek() == null) throw new IllegalStateException();\n-            return popInternal();\n-        }\n-\n-        T pop2() {\n-            T o = stack.get(stack.size() - 2);\n-            TypeTag t = typeHelper.tag(o);\n-            if (t.width != 2) throw new IllegalStateException();\n-            popInternal();\n-            popInternal();\n-            return o;\n-        }\n-\n-        T pop(TypeTag t) {\n-            return (t.width() == 2) ?\n-                pop2() : pop();\n-        }\n-\n-        void load(TypeTag tag, int index) {\n-            if (tag == TypeTag.A) throw new IllegalStateException(\"Bad type tag\");\n-            load(typeHelper.fromTag(tag), index);\n-        }\n-\n-        void load(T t, int index) {\n-            ensureDefined(index);\n-            locals.set(index, t);\n-            if (width(t) == 2) {\n-                locals.add(null);\n-            }\n-            if (locals.size() > localsize) {\n-                localsize = locals.size();\n-            }\n-        }\n-\n-        void ensureDefined(int index) {\n-            if (index >= locals.size()) {\n-                locals.setSize(index + 1);\n-            }\n-        }\n-\n-        State dup() {\n-            State newState = new State(new ArrayList<>(stack), new Vector<>(locals));\n-            return newState;\n-        }\n-\n-        State merge(State that) {\n-            if (!alive) { return that; }\n-            if (that.stack.size() != stack.size()) {\n-                throw new IllegalStateException(\"Bad stack size at merge point\");\n-            }\n-            for (int i = 0; i < stack.size(); i++) {\n-                T t1 = stack.get(i);\n-                T t2 = that.stack.get(i);\n-                stack.set(i, merge(t1, t2, \"Bad stack type at merge point\"));\n-            }\n-            int nlocals = locals.size() > that.locals.size() ? that.locals.size() : locals.size();\n-            for (int i = 0; i < nlocals; i++) {\n-                T t1 = locals.get(i);\n-                T t2 = that.locals.get(i);\n-                locals.set(i, merge(t1, t2, \"Bad local type at merge point\"));\n-            }\n-            if (locals.size() > nlocals) {\n-                for (int i = nlocals; i < locals.size(); i++) {\n-                    locals.remove(i);\n-                }\n-            }\n-            return this;\n-        }\n-\n-        T merge(T t1, T t2, String msg) {\n-            if (t1 == null && t2 == null) {\n-                return t1;\n-            }\n-            T res;\n-            TypeTag tag1 = typeHelper.tag(t1);\n-            TypeTag tag2 = typeHelper.tag(t2);\n-            if (tag1 != TypeTag.A && tag2 != TypeTag.A) {\n-                res = typeHelper.fromTag(TypeTag.commonSupertype(tag1, tag2));\n-            } else if (t1 == typeHelper.nullType()) {\n-                res = t2;\n-            } else if (t2 == typeHelper.nullType()) {\n-                res = t1;\n-            } else {\n-                res = typeHelper.commonSupertype(t1, t2);\n-            }\n-            if (res == null) {\n-                throw new IllegalStateException(msg);\n-            }\n-            return res;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.format(\"[locals = %s, stack = %s]\", locals, stack);\n-        }\n-    }\n-\n-    int width(T o) {\n-        return o == typeHelper.nullType() ?\n-                TypeTag.A.width() :\n-                typeHelper.tag(o).width;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public void updateState(Opcode op, Object optValue) {\n-        switch (op) {\n-            case AALOAD:\n-                state.pop();\n-                state.push(typeHelper.elemtype(state.pop()));\n-                break;\n-            case GOTO_:\n-                state.alive = false;\n-                break;\n-            case NOP:\n-            case IINC:\n-            case INEG:\n-            case LNEG:\n-            case FNEG:\n-            case DNEG:\n-                break;\n-            case ACONST_NULL:\n-                state.push(typeHelper.nullType());\n-                break;\n-            case ICONST_M1:\n-            case ICONST_0:\n-            case ICONST_1:\n-            case ICONST_2:\n-            case ICONST_3:\n-            case ICONST_4:\n-            case ICONST_5:\n-                state.push(TypeTag.I);\n-                break;\n-            case LCONST_0:\n-            case LCONST_1:\n-                state.push(TypeTag.J);\n-                break;\n-            case FCONST_0:\n-            case FCONST_1:\n-            case FCONST_2:\n-                state.push(TypeTag.F);\n-                break;\n-            case DCONST_0:\n-            case DCONST_1:\n-                state.push(TypeTag.D);\n-                break;\n-            case ILOAD_0:\n-            case FLOAD_0:\n-            case ALOAD_0:\n-            case LLOAD_0:\n-            case DLOAD_0:\n-                state.push(state.locals.get(0));\n-                break;\n-            case ILOAD_1:\n-            case FLOAD_1:\n-            case ALOAD_1:\n-            case LLOAD_1:\n-            case DLOAD_1:\n-                state.push(state.locals.get(1));\n-                break;\n-            case ILOAD_2:\n-            case FLOAD_2:\n-            case ALOAD_2:\n-            case LLOAD_2:\n-            case DLOAD_2:\n-                state.push(state.locals.get(2));\n-                break;\n-            case ILOAD_3:\n-            case FLOAD_3:\n-            case ALOAD_3:\n-            case LLOAD_3:\n-            case DLOAD_3:\n-                state.push(state.locals.get(3));\n-                break;\n-            case ILOAD:\n-            case FLOAD:\n-            case ALOAD:\n-            case LLOAD:\n-            case DLOAD:\n-                state.push(state.locals.get((Integer) optValue));\n-                break;\n-            case IALOAD:\n-            case BALOAD:\n-            case CALOAD:\n-            case SALOAD:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.I);\n-                break;\n-            case LALOAD:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.J);\n-                break;\n-            case FALOAD:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.F);\n-                break;\n-            case DALOAD:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.D);\n-                break;\n-            case ISTORE_0:\n-            case FSTORE_0:\n-            case ASTORE_0:\n-                state.load(state.pop(), 0);\n-                break;\n-            case ISTORE_1:\n-            case FSTORE_1:\n-            case ASTORE_1:\n-                state.load(state.pop(), 1);\n-                break;\n-            case ISTORE_2:\n-            case FSTORE_2:\n-            case ASTORE_2:\n-                state.load(state.pop(), 2);\n-                break;\n-            case ISTORE_3:\n-            case FSTORE_3:\n-            case ASTORE_3:\n-                state.load(state.pop(), 3);\n-                break;\n-            case ISTORE:\n-            case FSTORE:\n-            case ASTORE:\n-                state.load(state.pop(), (int) optValue);\n-                break;\n-            case LSTORE_0:\n-            case DSTORE_0:\n-                state.load(state.pop2(), 0);\n-                break;\n-            case LSTORE_1:\n-            case DSTORE_1:\n-                state.load(state.pop2(), 1);\n-                break;\n-            case LSTORE_2:\n-            case DSTORE_2:\n-                state.load(state.pop2(), 2);\n-                break;\n-            case LSTORE_3:\n-            case DSTORE_3:\n-                state.load(state.pop2(), 3);\n-                break;\n-            case LSTORE:\n-            case DSTORE:\n-                state.load(state.pop2(), (int) optValue);\n-                break;\n-            case POP:\n-            case LSHR:\n-            case LSHL:\n-            case LUSHR:\n-                state.pop();\n-                break;\n-            case ARETURN:\n-            case IRETURN:\n-            case FRETURN:\n-                state.pop();\n-                break;\n-            case ATHROW:\n-                state.pop();\n-                break;\n-            case POP2:\n-                state.pop2();\n-                break;\n-            case LRETURN:\n-            case DRETURN:\n-                state.pop2();\n-                break;\n-            case DUP:\n-                state.push(state.peek());\n-                break;\n-            case RETURN:\n-                break;\n-            case ARRAYLENGTH:\n-                state.pop();\n-                state.push(TypeTag.I);\n-                break;\n-            case ISUB:\n-            case IADD:\n-            case IMUL:\n-            case IDIV:\n-            case IREM:\n-            case ISHL:\n-            case ISHR:\n-            case IUSHR:\n-            case IAND:\n-            case IOR:\n-            case IXOR:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.I);\n-                break;\n-            case AASTORE:\n-                state.pop();\n-                state.pop();\n-                state.pop();\n-                break;\n-            case LAND:\n-            case LOR:\n-            case LXOR:\n-            case LREM:\n-            case LDIV:\n-            case LMUL:\n-            case LSUB:\n-            case LADD:\n-                state.pop2();\n-                state.pop2();\n-                state.push(TypeTag.J);\n-                break;\n-            case LCMP:\n-                state.pop2();\n-                state.pop2();\n-                state.push(TypeTag.I);\n-                break;\n-            case L2I:\n-                state.pop2();\n-                state.push(TypeTag.I);\n-                break;\n-            case I2L:\n-                state.pop();\n-                state.push(TypeTag.J);\n-                break;\n-            case I2F:\n-                state.pop();\n-                state.push(TypeTag.F);\n-                break;\n-            case I2D:\n-                state.pop();\n-                state.push(TypeTag.D);\n-                break;\n-            case L2F:\n-                state.pop2();\n-                state.push(TypeTag.F);\n-                break;\n-            case L2D:\n-                state.pop2();\n-                state.push(TypeTag.D);\n-                break;\n-            case F2I:\n-                state.pop();\n-                state.push(TypeTag.I);\n-                break;\n-            case F2L:\n-                state.pop();\n-                state.push(TypeTag.J);\n-                break;\n-            case F2D:\n-                state.pop();\n-                state.push(TypeTag.D);\n-                break;\n-            case D2I:\n-                state.pop2();\n-                state.push(TypeTag.I);\n-                break;\n-            case D2L:\n-                state.pop2();\n-                state.push(TypeTag.J);\n-                break;\n-            case D2F:\n-                state.pop2();\n-                state.push(TypeTag.F);\n-                break;\n-            case TABLESWITCH:\n-            case LOOKUPSWITCH:\n-                state.pop();\n-                break;\n-            case DUP_X1: {\n-                T val1 = state.pop();\n-                T val2 = state.pop();\n-                state.push(val1);\n-                state.push(val2);\n-                state.push(val1);\n-                break;\n-            }\n-            case BASTORE:\n-                state.pop();\n-                state.pop();\n-                state.pop();\n-                break;\n-            case I2B:\n-            case I2C:\n-            case I2S:\n-                break;\n-            case FMUL:\n-            case FADD:\n-            case FSUB:\n-            case FDIV:\n-            case FREM:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.F);\n-                break;\n-            case CASTORE:\n-            case IASTORE:\n-            case FASTORE:\n-            case SASTORE:\n-                state.pop();\n-                state.pop();\n-                state.pop();\n-                break;\n-            case LASTORE:\n-            case DASTORE:\n-                state.pop2();\n-                state.pop();\n-                state.pop();\n-                break;\n-            case DUP2:\n-                if (state.peek() != null) {\n-                    \/\/form 1\n-                    T value1 = state.pop();\n-                    T value2 = state.pop();\n-                    state.push(value2);\n-                    state.push(value1);\n-                    state.push(value2);\n-                    state.push(value1);\n-                } else {\n-                    \/\/form 2\n-                    T value = state.pop2();\n-                    state.push(value);\n-                    state.push(value);\n-                }\n-                break;\n-            case DUP2_X1:\n-                if (state.peek() != null) {\n-                    T value1 = state.pop();\n-                    T value2 = state.pop();\n-                    T value3 = state.pop();\n-                    state.push(value2);\n-                    state.push(value1);\n-                    state.push(value3);\n-                    state.push(value2);\n-                    state.push(value1);\n-                } else {\n-                    T value1 = state.pop2();\n-                    T value2 = state.pop();\n-                    state.push(value1);\n-                    state.push(value2);\n-                    state.push(value1);\n-                }\n-                break;\n-            case DUP2_X2:\n-                if (state.peek() != null) {\n-                    T value1 = state.pop();\n-                    T value2 = state.pop();\n-                    if (state.peek() != null) {\n-                        \/\/ form 1\n-                        T value3 = state.pop();\n-                        T value4 = state.pop();\n-                        state.push(value2);\n-                        state.push(value1);\n-                        state.push(value4);\n-                        state.push(value3);\n-                        state.push(value2);\n-                        state.push(value1);\n-                    } else {\n-                        \/\/ form 3\n-                        T value3 = state.pop2();\n-                        state.push(value2);\n-                        state.push(value1);\n-                        state.push(value3);\n-                        state.push(value2);\n-                        state.push(value1);\n-                    }\n-                } else {\n-                    T value1 = state.pop2();\n-                    if (state.peek() != null) {\n-                        \/\/ form 2\n-                        T value2 = state.pop();\n-                        T value3 = state.pop();\n-                        state.push(value1);\n-                        state.push(value3);\n-                        state.push(value2);\n-                        state.push(value1);\n-                    } else {\n-                        \/\/ form 4\n-                        T value2 = state.pop2();\n-                        state.push(value1);\n-                        state.push(value2);\n-                        state.push(value1);\n-                    }\n-                }\n-                break;\n-            case DUP_X2: {\n-                T value1 = state.pop();\n-                if (state.peek() != null) {\n-                    \/\/ form 1\n-                    T value2 = state.pop();\n-                    T value3 = state.pop();\n-                    state.push(value1);\n-                    state.push(value3);\n-                    state.push(value2);\n-                    state.push(value1);\n-                } else {\n-                    \/\/ form 2\n-                    T value2 = state.pop2();\n-                    state.push(value1);\n-                    state.push(value2);\n-                    state.push(value1);\n-                }\n-            }\n-            break;\n-            case FCMPL:\n-            case FCMPG:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.I);\n-                break;\n-            case DCMPL:\n-            case DCMPG:\n-                state.pop2();\n-                state.pop2();\n-                state.push(TypeTag.I);\n-                break;\n-            case SWAP: {\n-                T value1 = state.pop();\n-                T value2 = state.pop();\n-                state.push(value1);\n-                state.push(value2);\n-                break;\n-            }\n-            case DADD:\n-            case DSUB:\n-            case DMUL:\n-            case DDIV:\n-            case DREM:\n-                state.pop2();\n-                state.pop2();\n-                state.push(TypeTag.D);\n-                break;\n-            case RET:\n-                break;\n-            case WIDE:\n-                \/\/ must be handled by the caller.\n-                return;\n-            case MONITORENTER:\n-            case MONITOREXIT:\n-                state.pop();\n-                break;\n-            case NEW:\n-            case DEFAULTVALUE:\n-                state.push(typeHelper.type((S) optValue));\n-                break;\n-            case NEWARRAY:\n-                state.pop();\n-                state.push(typeHelper.arrayOf(typeHelper.fromTag((TypeTag) optValue)));\n-                break;\n-            case ANEWARRAY:\n-                state.pop();\n-                state.push(typeHelper.arrayOf(typeHelper.type((S)optValue)));\n-                break;\n-            case MULTIANEWARRAY:\n-                for (int i = 0; i < (byte) ((Object[]) optValue)[1]; i++) {\n-                    state.pop();\n-                }\n-                state.push(typeHelper.type((S) ((Object[]) optValue)[0]));\n-                break;\n-            case INVOKEINTERFACE:\n-            case INVOKEVIRTUAL:\n-            case INVOKESPECIAL:\n-            case INVOKESTATIC:\n-            case INVOKEDYNAMIC:\n-                processInvoke(op, (T) optValue);\n-                break;\n-            case GETSTATIC:\n-                state.push((T) optValue);\n-                break;\n-            case GETFIELD:\n-                state.pop();\n-                state.push((T) optValue);\n-                break;\n-            case PUTSTATIC: {\n-                TypeTag tag = typeHelper.tag((T) optValue);\n-                if (tag.width == 1) {\n-                    state.pop();\n-                } else {\n-                    state.pop2();\n-                }\n-                break;\n-            }\n-            case PUTFIELD: {\n-                TypeTag tag = typeHelper.tag((T) optValue);\n-                if (tag.width == 1) {\n-                    state.pop();\n-                } else {\n-                    state.pop2();\n-                }\n-                state.pop();\n-                break;\n-            }\n-            case WITHFIELD: {\n-                TypeTag tag = typeHelper.tag((T) optValue);\n-                if (tag.width == 1) {\n-                    state.pop();\n-                } else {\n-                    state.pop2();\n-                }\n-                break;\n-            }\n-            case BIPUSH:\n-            case SIPUSH:\n-                state.push(TypeTag.I);\n-                break;\n-            case LDC:\n-            case LDC_W:\n-            case LDC2_W:\n-                state.push((T)optValue);\n-                break;\n-            case IF_ACMPEQ:\n-            case IF_ICMPEQ:\n-            case IF_ACMPNE:\n-            case IF_ICMPGE:\n-            case IF_ICMPGT:\n-            case IF_ICMPLE:\n-            case IF_ICMPLT:\n-            case IF_ICMPNE:\n-                state.pop();\n-                state.pop();\n-                break;\n-            case IF_NONNULL:\n-            case IF_NULL:\n-            case IFEQ:\n-            case IFGE:\n-            case IFGT:\n-            case IFLE:\n-            case IFLT:\n-            case IFNE:\n-                state.pop();\n-                break;\n-            case INSTANCEOF:\n-                state.pop();\n-                state.push(TypeTag.Z);\n-                break;\n-            case TYPED:\n-            case CHECKCAST:\n-                break;\n-\n-            default:\n-                throw new UnsupportedOperationException(\"Unsupported opcode: \" + op);\n-        }\n-    }\n-\n-    void processInvoke(Opcode opcode, T invokedType) {\n-        Iterator<T> paramsIt = typeHelper.parameterTypes(invokedType);\n-        while (paramsIt.hasNext()) {\n-            T t = paramsIt.next();\n-            TypeTag tag = typeHelper.tag(t);\n-            if (tag.width == 2) {\n-                state.popInternal();\n-                state.popInternal();\n-            } else {\n-                state.popInternal();\n-            }\n-        }\n-        if (opcode != Opcode.INVOKESTATIC && opcode != Opcode.INVOKEDYNAMIC) {\n-            state.pop(); \/\/receiver\n-        }\n-        T retType = typeHelper.returnType(invokedType);\n-        TypeTag retTag = typeHelper.tag(retType);\n-        if (retTag != TypeTag.V)\n-            state.push(retType);\n-    }\n-\n-    @Override\n-    protected C ldc(ToIntFunction<PoolHelper<S, T, E>> indexFunc, boolean fat) {\n-        LdcPoolHelper ldcPoolHelper = new LdcPoolHelper();\n-        int index = indexFunc.applyAsInt(ldcPoolHelper);\n-        fat = typeHelper.tag(ldcPoolHelper.type).width() == 2;\n-        return super.ldc(index, ldcPoolHelper.type, fat);\n-    }\n-    \/\/where\n-        class LdcPoolHelper implements PoolHelper<S, T, E> {\n-\n-            T type;\n-\n-            @Override\n-            public int putClass(S symbol) {\n-                type = typeHelper.type(symbol);\n-                return poolHelper.putClass(symbol);\n-            }\n-\n-            @Override\n-            public int putValueClass(S symbol) {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public int putInt(int i) {\n-                type = typeHelper.fromTag(TypeTag.I);\n-                return poolHelper.putInt(i);\n-            }\n-\n-            @Override\n-            public int putFloat(float f) {\n-                type = typeHelper.fromTag(TypeTag.F);\n-                return poolHelper.putFloat(f);\n-            }\n-\n-            @Override\n-            public int putLong(long l) {\n-                type = typeHelper.fromTag(TypeTag.J);\n-                return poolHelper.putLong(l);\n-            }\n-\n-            @Override\n-            public int putDouble(double d) {\n-                type = typeHelper.fromTag(TypeTag.D);\n-                return poolHelper.putDouble(d);\n-            }\n-\n-            @Override\n-            public int putString(String s) {\n-                type = typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/String\"));\n-                return poolHelper.putString(s);\n-            }\n-\n-            @Override\n-            public int putValue(Object v) {\n-                type = typeTag(v);\n-                return poolHelper.putValue(v);\n-            }\n-\n-            @Override\n-            public int putConstantDynamic(CharSequence constName, T constType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, E>> staticArgs) {\n-                type = constType;\n-                return poolHelper.putConstantDynamic(constName, constType, bsmClass, bsmName, bsmType, staticArgs);\n-            }\n-\n-            @Override\n-            public int putFieldRef(S owner, CharSequence name, T type) {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public int putMethodRef(S owner, CharSequence name, T type, boolean isInterface) {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public int putUtf8(CharSequence s) {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public int putType(T t) {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public int putMethodType(T t) {\n-                type = typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/invoke\/MethodType\"));\n-                return poolHelper.putMethodType(t);\n-            }\n-\n-            @Override\n-            public int putMethodHandle(int refKind, S owner, CharSequence name, T t) {\n-                type = typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/invoke\/MethodHandle\"));\n-                return poolHelper.putMethodHandle(refKind, owner, name, t);\n-            }\n-\n-            @Override\n-            public int putMethodHandle(int refKind, S owner, CharSequence name, T t, boolean isInterface) {\n-                type = typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/invoke\/MethodHandle\"));\n-                return poolHelper.putMethodHandle(refKind, owner, name, t, isInterface);\n-            }\n-\n-            @Override\n-            public int putInvokeDynamic(CharSequence invokedName, T invokedType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, E>> staticArgs) {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public int size() {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public E representation() {\n-                throw new IllegalStateException();\n-            }\n-\n-            private T typeTag(Object o) {\n-                if (o instanceof Double) {\n-                    return typeHelper.fromTag(TypeTag.D);\n-                } else if (o instanceof Long) {\n-                    return typeHelper.fromTag(TypeTag.J);\n-                } else if (o instanceof Float) {\n-                    return typeHelper.fromTag(TypeTag.F);\n-                } else if (o instanceof Integer) {\n-                    return typeHelper.fromTag(TypeTag.I);\n-                } else if (o instanceof Class<?>) {\n-                    return typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/Class\"));\n-                } else if (o instanceof String) {\n-                    return typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/String\"));\n-                } else if (o instanceof MethodHandle) {\n-                    return typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/invoke\/MethodHandle\"));\n-                } else if (o instanceof MethodType) {\n-                    return typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/invoke\/MethodType\"));\n-                } else {\n-                    throw new IllegalStateException(\"Unsupported object class: \" + o.getClass().getName());\n-                }\n-            }\n-    }\n-\n-    public C load(int index) {\n-        return load(typeHelper.tag(state.locals.get(index)), index);\n-    }\n-\n-    public C store(int index) {\n-        return store(typeHelper.tag(state.tosType()), index);\n-    }\n-\n-    @Override\n-    public C withLocalSize(int localsize) {\n-        throw new IllegalStateException(\"Local size automatically computed\");\n-    }\n-\n-    @Override\n-    public C withStackSize(int stacksize) {\n-        throw new IllegalStateException(\"Stack size automatically computed\");\n-    }\n-\n-    public C withLocal(CharSequence name, T type) {\n-        int offset = currLocalOffset;\n-        TypeTag tag = typeHelper.tag(type);\n-        lvarOffsets.put(name, new LocalVarInfo(name, offset, depth, tag));\n-        state.load(type, offset);\n-        currLocalOffset += tag.width;\n-        return thisBuilder();\n-    }\n-\n-    public C load(CharSequence local) {\n-        return load(lvarOffsets.get(local).offset);\n-    }\n-\n-    public C store(CharSequence local) {\n-        return store(lvarOffsets.get(local).offset);\n-    }\n-\n-    @Override\n-    public C withTry(Consumer<? super C> tryBlock, Consumer<? super CatchBuilder> catchBlocks) {\n-        return super.withTry(c -> {\n-            withLocalScope(() -> {\n-                tryBlock.accept(c);\n-            });\n-        }, catchBlocks);\n-    }\n-\n-    @Override\n-    protected CatchBuilder makeCatchBuilder(int start, int end) {\n-        return new TypedCatchBuilder(start, end);\n-    }\n-\n-    class TypedCatchBuilder extends CatchBuilder {\n-\n-        State initialState = state.dup();\n-\n-        TypedCatchBuilder(int start, int end) {\n-            super(start, end);\n-        }\n-\n-        @Override\n-        protected void emitCatch(S exc, Consumer<? super C> catcher) {\n-            withLocalScope(() -> {\n-                state.push(typeHelper.type(exc));\n-                emitStackMap(code.offset);\n-                super.emitCatch(exc, catcher);\n-                state = initialState;\n-            });\n-        }\n-\n-        @Override\n-        protected void emitFinalizer() {\n-            withLocalScope(() -> {\n-                state.push(typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/Throwable\")));\n-                emitStackMap(code.offset);\n-                super.emitFinalizer();\n-            });\n-        }\n-    }\n-\n-    protected void withLocalScope(Runnable runnable) {\n-        int prevDepth = depth;\n-        try {\n-            depth++;\n-            runnable.run();\n-        } finally {\n-            Iterator<Entry<CharSequence, LocalVarInfo>> lvarIt = lvarOffsets.entrySet().iterator();\n-            while (lvarIt.hasNext()) {\n-                LocalVarInfo lvi = lvarIt.next().getValue();\n-                if (lvi.depth == depth) {\n-                    int width = lvi.type.width;\n-                    currLocalOffset -= width;\n-                    lvarIt.remove();\n-                }\n-            }\n-            depth = prevDepth;\n-        }\n-    }\n-\n-    @Override\n-    void addPendingJump(CharSequence label, int pc) {\n-        pendingJumps.add(new StatefulPendingJump(label, pc, state.dup()));\n-    }\n-\n-    @Override\n-    void resolveJumps(CharSequence label, int pc) {\n-        super.resolveJumps(label, pc);\n-        emitStackMap(pc);\n-    }\n-\n-    \/\/TODO: optimize stackmap generation by avoiding intermediate classes\n-    protected void emitStackMap(int pc) {\n-        \/\/stack map generation\n-        if (pc > lastStackMapPc) {\n-            writeStackMapFrame(pc);\n-            lastStackMapState = state.dup();\n-            lastStackMapPc = pc;\n-            nstackmaps++;\n-        }\n-    }\n-\n-    @Override\n-    void build(GrowableByteBuffer buf) {\n-        if (stacksize == -1) {\n-            throw new IllegalStateException(\"Bad stack size\");\n-        }\n-        if (localsize == -1) {\n-            throw new IllegalStateException(\"Bad locals size\");\n-        }\n-        if (nstackmaps > 0) {\n-            GrowableByteBuffer stackmapsAttr = new GrowableByteBuffer();\n-            stackmapsAttr.writeChar(nstackmaps);\n-            stackmapsAttr.writeBytes(stackmaps);\n-            withAttribute(\"StackMapTable\", stackmapsAttr.bytes());\n-        }\n-        super.build(buf);\n-    }\n-\n-    \/**\n-     * Compare this frame with the previous frame and produce\n-     * an entry of compressed stack map frame.\n-     *\/\n-    void writeStackMapFrame(int pc) {\n-        List<T> locals = state.locals;\n-        List<T> stack = state.stack;\n-        List<T> prev_locals = lastStackMapState.locals;\n-        int offset_delta = lastStackMapPc == -1 ? pc : pc - lastStackMapPc - 1;\n-        if (stack.size() == 1) {\n-            if (locals.size() == prev_locals.size() && prev_locals.equals(locals)) {\n-                sameLocals1StackItemFrame(offset_delta, stack.get(stack.size() - 1));\n-                return;\n-            }\n-        } else if (stack.size() == 0) {\n-            int diff_length = prev_locals.size() - locals.size();\n-            if (diff_length == 0) {\n-                sameFrame(offset_delta);\n-                return;\n-            } else if (-MAX_LOCAL_LENGTH_DIFF < diff_length && diff_length < 0) {\n-                appendFrame(offset_delta, prev_locals.size(), locals);\n-                return;\n-            } else if (0 < diff_length && diff_length < MAX_LOCAL_LENGTH_DIFF) {\n-                chopFrame(offset_delta, diff_length);\n-                return;\n-            }\n-        }\n-        fullFrame(offset_delta, locals, stack);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/bytecode\/TypedCodeBuilder.java","additions":0,"deletions":1263,"binary":false,"changes":1263,"status":"deleted"},{"patch":"@@ -1,354 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.value;\n-\n-import jdk.experimental.bytecode.BytePoolHelper;\n-import jdk.experimental.bytecode.BasicTypeHelper;\n-import jdk.experimental.bytecode.ClassBuilder;\n-import jdk.experimental.bytecode.CodeBuilder;\n-import jdk.experimental.bytecode.Flag;\n-import jdk.experimental.bytecode.MethodBuilder;\n-import jdk.experimental.bytecode.TypeHelper;\n-import jdk.experimental.bytecode.TypeTag;\n-import jdk.experimental.bytecode.TypedCodeBuilder;\n-import jdk.experimental.value.MethodHandleBuilder.IsolatedMethodBuilder.IsolatedMethodPoolHelper;\n-import jdk.internal.misc.Unsafe;\n-import sun.security.action.GetPropertyAction;\n-\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.io.UncheckedIOException;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.lang.invoke.MethodType;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.*;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-\/**\n- * Utility class for building method handles.\n- *\/\n-public class MethodHandleBuilder {\n-\n-    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    public static final boolean ENABLE_POOL_PATCHES;\n-    public static final String DUMP_CLASS_FILES_DIR;\n-\n-    static {\n-        Properties props = GetPropertyAction.privilegedGetProperties();\n-        ENABLE_POOL_PATCHES = Boolean.parseBoolean(\n-                props.getProperty(\"valhalla.enablePoolPatches\"));\n-        DUMP_CLASS_FILES_DIR = props.getProperty(\"valhalla.DUMP_CLASS_FILES_DIR\");\n-    }\n-\n-    public static MethodHandle loadCode(Lookup lookup, String name, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n-        return loadCode(lookup, name, name, type, builder);\n-    }\n-\n-    public static MethodHandle loadCode(Lookup lookup, String className, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n-        String descriptor = type.toMethodDescriptorString();\n-        return loadCode(lookup, className, methodName, descriptor, MethodHandleCodeBuilder::new,\n-                    clazz -> {\n-                        try {\n-                            return lookup.findStatic(clazz, methodName, MethodType.fromMethodDescriptorString(descriptor, lookup.lookupClass().getClassLoader()));\n-                        } catch (ReflectiveOperationException ex) {\n-                            throw new IllegalStateException(ex);\n-                        }\n-                    },\n-                    builder);\n-    }\n-\n-    protected static <Z, C extends CodeBuilder<Class<?>, String, byte[], ?>> Z loadCode(\n-            Lookup lookup, String className, String methodName, String type,\n-            Function<MethodBuilder<Class<?>, String, byte[]>, ? extends C> builderFunc,\n-            Function<Class<?>, Z> resFunc, Consumer<? super C> builder) {\n-\n-        IsolatedMethodBuilder isolatedMethodBuilder = new IsolatedMethodBuilder(className, lookup);\n-        isolatedMethodBuilder\n-                .withSuperclass(Object.class)\n-                .withMajorVersion(60)\n-                .withMinorVersion(0)\n-                .withFlags(Flag.ACC_PUBLIC)\n-                .withMethod(methodName, type, M ->\n-                        M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)\n-                                .withCode(builderFunc, builder));\n-\n-        try {\n-            byte[] barr = isolatedMethodBuilder.build();\n-            maybeDump(className, barr);\n-            Class<?> clazz = UNSAFE.defineAnonymousClass(lookup.lookupClass(), barr, isolatedMethodBuilder.patches());\n-            UNSAFE.ensureClassInitialized(clazz);\n-            return resFunc.apply(clazz);\n-        } catch (Throwable e) {\n-             throw new IllegalStateException(e);\n-        }\n-    }\n-\n-    public static class IsolatedMethodBuilder extends ClassBuilder<Class<?>, String, IsolatedMethodBuilder> {\n-\n-        private static final Class<?> THIS_CLASS = new Object() { }.getClass();\n-\n-        public IsolatedMethodBuilder(String clazz, Lookup lookup) {\n-            super(ENABLE_POOL_PATCHES ?\n-                            new IsolatedMethodPatchingPoolHelper(clazz) :\n-                            new IsolatedMethodPoolHelper(clazz),\n-                  new IsolatedMethodTypeHelper(lookup));\n-            withThisClass(THIS_CLASS);\n-        }\n-\n-        public Class<?> thisClass() {\n-            return THIS_CLASS;\n-        }\n-\n-        Object[] patches() {\n-            return ((IsolatedMethodPoolHelper)poolHelper).patches();\n-        }\n-\n-        static String classToInternalName(Class<?> c) {\n-            return c.getName().replace('.', '\/');\n-        }\n-\n-        static class IsolatedMethodTypeHelper implements TypeHelper<Class<?>, String> {\n-\n-            BasicTypeHelper basicTypeHelper = new BasicTypeHelper();\n-            Lookup lookup;\n-\n-            IsolatedMethodTypeHelper(Lookup lookup) {\n-                this.lookup = lookup;\n-            }\n-\n-            @Override\n-            public String elemtype(String s) {\n-                return basicTypeHelper.elemtype(s);\n-            }\n-\n-            @Override\n-            public String arrayOf(String s) {\n-                return basicTypeHelper.arrayOf(s);\n-            }\n-\n-            @Override\n-            public Iterator<String> parameterTypes(String s) {\n-                return basicTypeHelper.parameterTypes(s);\n-            }\n-\n-            @Override\n-            public String fromTag(TypeTag tag) {\n-                return basicTypeHelper.fromTag(tag);\n-            }\n-\n-            @Override\n-            public String returnType(String s) {\n-                return basicTypeHelper.returnType(s);\n-            }\n-\n-            @Override\n-            public String type(Class<?> aClass) {\n-                if (aClass.isArray()) {\n-                    return classToInternalName(aClass);\n-                } else {\n-                    return (aClass.isInlineClass() ? \"Q\" : \"L\") + classToInternalName(aClass) + \";\";\n-                }\n-            }\n-\n-            @Override\n-            public boolean isValue(String desc) {\n-                Class<?> aClass = symbol(desc);\n-                return aClass != null && aClass.isInlineClass();\n-            }\n-\n-            @Override\n-            public Class<?> symbol(String desc) {\n-                try {\n-                    if (desc.startsWith(\"[\")) {\n-                        return Class.forName(desc.replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n-                    } else {\n-                        return Class.forName(basicTypeHelper.symbol(desc).replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n-                    }\n-                } catch (ReflectiveOperationException ex) {\n-                    throw new AssertionError(ex);\n-                }\n-            }\n-\n-            @Override\n-            public TypeTag tag(String s) {\n-                return basicTypeHelper.tag(s);\n-            }\n-\n-            @Override\n-            public Class<?> symbolFrom(String s) {\n-                return symbol(s);\n-            }\n-\n-            @Override\n-            public String commonSupertype(String t1, String t2) {\n-                return basicTypeHelper.commonSupertype(t1, t2);\n-            }\n-\n-            @Override\n-            public String nullType() {\n-                return basicTypeHelper.nullType();\n-            }\n-        }\n-\n-        static class IsolatedMethodPoolHelper extends BytePoolHelper<Class<?>, String> {\n-            final String clazz;\n-\n-            IsolatedMethodPoolHelper(String clazz) {\n-                super(c -> from(c, clazz), s->s);\n-                this.clazz = clazz;\n-            }\n-\n-            Object[] patches() {\n-                return null;\n-            }\n-\n-            static String from(Class<?> c, String clazz) {\n-                return c == THIS_CLASS ? clazz.replace('.', '\/')\n-                                       : classToInternalName(c);\n-            }\n-        }\n-\n-        @Override\n-        public byte[] build() {\n-            return super.build();\n-        }\n-    }\n-\n-    static class IsolatedMethodPatchingPoolHelper extends IsolatedMethodPoolHelper {\n-\n-        public IsolatedMethodPatchingPoolHelper(String clazz) {\n-            super(clazz);\n-        }\n-\n-        Map<Object, CpPatch> cpPatches = new HashMap<>();\n-        int cph = 0;  \/\/ for counting constant placeholders\n-\n-        static class CpPatch {\n-\n-            final int index;\n-            final String placeholder;\n-            final Object value;\n-\n-            CpPatch(int index, String placeholder, Object value) {\n-                this.index = index;\n-                this.placeholder = placeholder;\n-                this.value = value;\n-            }\n-\n-            public String toString() {\n-                return \"CpPatch\/index=\"+index+\",placeholder=\"+placeholder+\",value=\"+value;\n-            }\n-        }\n-\n-        @Override\n-        public int putValue(Object v) {\n-            if (v instanceof String || v instanceof Integer || v instanceof Float || v instanceof Double || v instanceof Long) {\n-                return super.putValue(v);\n-            }\n-            assert (!v.getClass().isPrimitive()) : v;\n-            return patchPoolEntry(v); \/\/ CP patching support\n-        }\n-\n-        int patchPoolEntry(Object v) {\n-            String cpPlaceholder = \"CONSTANT_PLACEHOLDER_\" + cph++;\n-            if (cpPatches.containsKey(cpPlaceholder)) {\n-                throw new InternalError(\"observed CP placeholder twice: \" + cpPlaceholder);\n-            }\n-            \/\/ insert placeholder in CP and remember the patch\n-            int index = super.putValue(cpPlaceholder);  \/\/ TODO check if already in the constant pool\n-            cpPatches.put(cpPlaceholder, new CpPatch(index, cpPlaceholder, v));\n-            return index;\n-        }\n-\n-        @Override\n-        Object[] patches() {\n-            int size = size();\n-            Object[] res = new Object[size];\n-            for (CpPatch p : cpPatches.values()) {\n-                if (p.index >= size)\n-                    throw new InternalError(\"bad cp patch index\");\n-                res[p.index] = p.value;\n-            }\n-            return res;\n-        }\n-\n-        private static String debugString(Object arg) {\n-            \/\/ @@@ Cannot crack open a MH like with InvokerByteCodeGenerator.debugString\n-            return arg.toString();\n-        }\n-    }\n-\n-    public static class MethodHandleCodeBuilder<T extends MethodHandleCodeBuilder<T>> extends TypedCodeBuilder<Class<?>, String, byte[], T> {\n-\n-        BasicTypeHelper basicTypeHelper = new BasicTypeHelper();\n-\n-        public MethodHandleCodeBuilder(jdk.experimental.bytecode.MethodBuilder<Class<?>, String, byte[]> methodBuilder) {\n-            super(methodBuilder);\n-        }\n-\n-        TypeTag getTagType(String s) {\n-            return basicTypeHelper.tag(s);\n-        }\n-\n-        public T ifcmp(String s, CondKind cond, CharSequence label) {\n-            return super.ifcmp(getTagType(s), cond, label);\n-        }\n-\n-        public T return_(String s) {\n-            return super.return_(getTagType(s));\n-        }\n-    }\n-\n-    static void maybeDump(final String className, final byte[] classFile) {\n-        if (DUMP_CLASS_FILES_DIR != null) {\n-            java.security.AccessController.doPrivileged(\n-                new java.security.PrivilegedAction<>() {\n-                    public Void run() {\n-                        String dumpName = className.replace('.','\/');\n-                        Path dumpFile = Paths.get(DUMP_CLASS_FILES_DIR, dumpName + \".class\");\n-                        try {\n-                            Files.createDirectories(dumpFile.getParent());\n-                        } catch (IOException e) {\n-                            throw new UncheckedIOException(e);\n-                        }\n-\n-                        System.out.println(\"dump: \" + dumpFile);\n-                        try (OutputStream os = Files.newOutputStream(dumpFile)) {\n-                            os.write(classFile);\n-                        } catch (IOException ex) {\n-                            throw new UncheckedIOException(ex);\n-                        }\n-                        return null;\n-                    }\n-                });\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/experimental\/value\/MethodHandleBuilder.java","additions":0,"deletions":354,"binary":false,"changes":354,"status":"deleted"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.experimental.value.MethodHandleBuilder;\n@@ -38,1 +37,0 @@\n- * @modules java.base\/jdk.experimental.value\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC1.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.experimental.value.MethodHandleBuilder;\n@@ -39,1 +38,0 @@\n- * @modules java.base\/jdk.experimental.value\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGetfieldChains.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.experimental.value.MethodHandleBuilder;\n@@ -32,0 +31,1 @@\n+import test.java.lang.invoke.lib.InstructionHelper;\n@@ -37,2 +37,2 @@\n- * @modules java.base\/jdk.experimental.value\n- * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common \/testlibrary \/compiler\/whitebox \/\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -1050,1 +1050,1 @@\n-    private static final MethodHandle setArrayElementNull = MethodHandleBuilder.loadCode(MethodHandles.lookup(),\n+    private static final MethodHandle setArrayElementNull = InstructionHelper.loadCode(MethodHandles.lookup(),\n@@ -1377,1 +1377,1 @@\n-    private static final MethodHandle setArrayElementIncompatible = MethodHandleBuilder.loadCode(MethodHandles.lookup(),\n+    private static final MethodHandle setArrayElementIncompatible = InstructionHelper.loadCode(MethodHandles.lookup(),\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @modules java.base\/jdk.experimental.value\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @modules java.base\/jdk.experimental.value\n@@ -43,1 +42,0 @@\n-import jdk.experimental.value.MethodHandleBuilder;\n@@ -52,0 +50,1 @@\n+\n@@ -56,20 +55,1 @@\n-    private static final MethodHandle cloneValue = MethodHandleBuilder.loadCode(MethodHandles.lookup(),\n-        \"MyValue\",\n-        MethodType.methodType(Object.class, MyValue.class),\n-        CODE -> {\n-            CODE.\n-            aload_0().\n-            invokevirtual(Object.class, \"clone\", \"()Ljava\/lang\/Object;\", false).\n-            areturn();\n-        });\n-\n-    public static void test1(MyValue vt) throws Throwable {\n-        try {\n-            cloneValue.invoke(vt);\n-            throw new RuntimeException(\"No exception thrown\");\n-        } catch (CloneNotSupportedException e) {\n-            \/\/ Expected\n-        }\n-    }\n-\n-    public static void test2(Method clone, Object obj) {\n+    public static void test1(Method clone, Object obj) {\n@@ -93,2 +73,1 @@\n-            test1(vt);\n-            test2(clone, vt);\n+            test1(clone, vt);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNativeClone.java","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.experimental.value.MethodHandleBuilder;\n@@ -38,1 +37,0 @@\n- * @modules java.base\/jdk.experimental.value\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWithfieldC1.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import test.java.lang.invoke.lib.InstructionHelper;\n@@ -44,2 +45,0 @@\n-import jdk.experimental.value.MethodHandleBuilder;\n-\n@@ -51,3 +50,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- *          java.base\/jdk.experimental.value\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -55,2 +53,1 @@\n- *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=false\n+ *                   -XX:+UnlockDiagnosticVMOptions\n@@ -78,1 +75,1 @@\n-        MethodHandle testNewOnInlineClass = MethodHandleBuilder.loadCode(\n+        MethodHandle testNewOnInlineClass = InstructionHelper.loadCode(\n@@ -100,1 +97,1 @@\n-        MethodHandle testDefaultvalueOnIdentityClass = MethodHandleBuilder.loadCode(\n+        MethodHandle testDefaultvalueOnIdentityClass = InstructionHelper.loadCode(\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/CreationErrorTest.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-import java.lang.invoke.*;\n-\n-import jdk.experimental.value.MethodHandleBuilder;\n@@ -34,2 +31,0 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- *          java.base\/jdk.experimental.value\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlattenableSemanticTest.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-\n-import jdk.experimental.value.MethodHandleBuilder;\n+import test.java.lang.invoke.lib.InstructionHelper;\n@@ -40,3 +39,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- *          java.base\/jdk.experimental.value\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -56,3 +54,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- *          java.base\/jdk.experimental.value\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -72,3 +69,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- *          java.base\/jdk.experimental.value\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -88,3 +84,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- *          java.base\/jdk.experimental.value\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -105,3 +100,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- *          java.base\/jdk.experimental.value\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -121,3 +115,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- *          java.base\/jdk.experimental.value\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -137,3 +130,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- *          java.base\/jdk.experimental.value\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -153,3 +145,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- *          java.base\/jdk.experimental.value\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -413,1 +404,1 @@\n-            MethodHandle moveValueThroughStackAndLvt = MethodHandleBuilder.loadCode(\n+            MethodHandle moveValueThroughStackAndLvt = InstructionHelper.loadCode(\n@@ -680,1 +671,1 @@\n-                MethodHandleBuilder.loadCode(\n+                InstructionHelper.loadCode(\n@@ -720,1 +711,1 @@\n-                MethodHandleBuilder.loadCode(LOOKUP, \"exerciseVBytecodeExprStackWithRefs\", mt,\n+                InstructionHelper.loadCode(LOOKUP, \"exerciseVBytecodeExprStackWithRefs\", mt,\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineOops.java","additions":20,"deletions":29,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-import jdk.experimental.value.MethodHandleBuilder;\n-\n@@ -47,0 +45,1 @@\n+import test.java.lang.invoke.lib.InstructionHelper;\n@@ -51,3 +50,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- *          java.base\/jdk.experimental.value\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -106,1 +104,1 @@\n-        MethodHandle fromExecStackToLocalVar = MethodHandleBuilder.loadCode(\n+        MethodHandle fromExecStackToLocalVar = InstructionHelper.loadCode(\n@@ -151,1 +149,1 @@\n-        MethodHandle fromExecStackToFields = MethodHandleBuilder.loadCode(\n+        MethodHandle fromExecStackToFields = InstructionHelper.loadCode(\n@@ -222,1 +220,1 @@\n-        MethodHandle fromExecStackToInlineArray = MethodHandleBuilder.loadCode(\n+        MethodHandle fromExecStackToInlineArray = InstructionHelper.loadCode(\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypesTest.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.experimental.value.MethodHandleBuilder;\n+import test.java.lang.invoke.lib.InstructionHelper;\n@@ -32,3 +32,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- *          java.base\/jdk.experimental.value\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -137,9 +136,9 @@\n-            MethodHandleBuilder.loadCode(MethodHandles.lookup(),\n-                                         \"mismatchedMonitorExit\",\n-                                         MethodType.methodType(Void.TYPE, Object.class),\n-                                         CODE->{\n-                                             CODE\n-                                                 .aload(0)\n-                                                 .monitorexit()\n-                                                 .return_();\n-                                         }).invokeExact(val);\n+            InstructionHelper.loadCode(MethodHandles.lookup(),\n+                                        \"mismatchedMonitorExit\",\n+                                        MethodType.methodType(Void.TYPE, Object.class),\n+                                        CODE->{\n+                                            CODE\n+                                                .aload(0)\n+                                                .monitorexit()\n+                                                .return_();\n+                                        }).invokeExact(val);\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ObjectMethods.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.experimental.bytecode.BytePoolHelper;\n+import jdk.experimental.bytecode.ClassBuilder;\n+import jdk.experimental.bytecode.CodeBuilder;\n@@ -29,0 +32,1 @@\n+import jdk.experimental.bytecode.MethodBuilder;\n@@ -31,0 +35,2 @@\n+import jdk.experimental.bytecode.TypeHelper;\n+import jdk.experimental.bytecode.TypeTag;\n@@ -36,0 +42,1 @@\n+import java.util.Iterator;\n@@ -49,0 +56,4 @@\n+    static String generateClassNameFromLookupClass(MethodHandles.Lookup l) {\n+        return l.lookupClass().getCanonicalName().replace('.', '\/') + \"$Code_\" + COUNT.getAndIncrement();\n+    }\n+\n@@ -50,1 +61,1 @@\n-        String className = l.lookupClass().getCanonicalName().replace('.', '\/') + \"$Code_\" + COUNT.getAndIncrement();\n+        String className = generateClassNameFromLookupClass(l);\n@@ -86,1 +97,1 @@\n-                   P -> P.putMethodHandle(refKind, csym(owner), name, type.toMethodDescriptorString()));\n+                   P -> P.putHandle(refKind, csym(owner), name, type.toMethodDescriptorString()));\n@@ -115,1 +126,1 @@\n-                   P -> P.putConstantDynamic(name, type,\n+                   P -> P.putDynamicConstant(name, type,\n@@ -151,0 +162,195 @@\n+\n+\n+    \/\/ loadCode(MethodHandles.Lookup, String, MethodType, Consumer<? super MethodHandleCodeBuilder<?>>) et al...\n+\n+    public static MethodHandle loadCode(MethodHandles.Lookup lookup, String name, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+        String className = generateClassNameFromLookupClass(lookup);\n+        return loadCode(lookup, className, name, type, builder);\n+    }\n+\n+    public static MethodHandle loadCode(MethodHandles.Lookup lookup, String className, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n+        String descriptor = type.toMethodDescriptorString();\n+        return loadCode(lookup, className, methodName, descriptor, MethodHandleCodeBuilder::new,\n+                    clazz -> {\n+                        try {\n+                            return lookup.findStatic(clazz, methodName, MethodType.fromMethodDescriptorString(descriptor, lookup.lookupClass().getClassLoader()));\n+                        } catch (ReflectiveOperationException ex) {\n+                            throw new IllegalStateException(ex);\n+                        }\n+                    },\n+                    builder);\n+    }\n+\n+\n+    protected static <Z, C extends CodeBuilder<Class<?>, String, byte[], ?>> Z loadCode(\n+            MethodHandles.Lookup lookup, String className, String methodName, String type,\n+            Function<MethodBuilder<Class<?>, String, byte[]>, ? extends C> builderFunc,\n+            Function<Class<?>, Z> resFunc, Consumer<? super C> builder) {\n+\n+        IsolatedMethodBuilder isolatedMethodBuilder = new IsolatedMethodBuilder(className, lookup);\n+        isolatedMethodBuilder\n+                .withSuperclass(Object.class)\n+                .withMajorVersion(60)\n+                .withMinorVersion(0)\n+                .withFlags(Flag.ACC_PUBLIC)\n+                .withMethod(methodName, type, M ->\n+                        M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)\n+                                .withCode(builderFunc, builder));\n+\n+        try {\n+            byte[] byteArray = isolatedMethodBuilder.build();\n+            Class<?> clazz = lookup.defineClass(byteArray);\n+            return resFunc.apply(clazz);\n+        } catch (Throwable e) {\n+             throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    public static class IsolatedMethodBuilder extends ClassBuilder<Class<?>, String, IsolatedMethodBuilder> {\n+\n+        private static final Class<?> THIS_CLASS = new Object() { }.getClass();\n+\n+        public IsolatedMethodBuilder(String clazz, MethodHandles.Lookup lookup) {\n+            super(new IsolatedMethodPoolHelper(clazz),\n+                  new IsolatedMethodTypeHelper(lookup));\n+            withThisClass(THIS_CLASS);\n+        }\n+\n+        public Class<?> thisClass() {\n+            return THIS_CLASS;\n+        }\n+\n+        static String classToInternalName(Class<?> c) {\n+            return c.getName().replace('.', '\/');\n+        }\n+\n+        static class IsolatedMethodTypeHelper implements TypeHelper<Class<?>, String> {\n+\n+            BasicTypeHelper basicTypeHelper = new BasicTypeHelper();\n+            MethodHandles.Lookup lookup;\n+\n+            IsolatedMethodTypeHelper(MethodHandles.Lookup lookup) {\n+                this.lookup = lookup;\n+            }\n+\n+            @Override\n+            public String elemtype(String s) {\n+                return basicTypeHelper.elemtype(s);\n+            }\n+\n+            @Override\n+            public String arrayOf(String s) {\n+                return basicTypeHelper.arrayOf(s);\n+            }\n+\n+            @Override\n+            public Iterator<String> parameterTypes(String s) {\n+                return basicTypeHelper.parameterTypes(s);\n+            }\n+\n+            @Override\n+            public String fromTag(TypeTag tag) {\n+                return basicTypeHelper.fromTag(tag);\n+            }\n+\n+            @Override\n+            public String returnType(String s) {\n+                return basicTypeHelper.returnType(s);\n+            }\n+\n+            @Override\n+            public String type(Class<?> aClass) {\n+                if (aClass.isArray()) {\n+                    return classToInternalName(aClass);\n+                } else {\n+                    return (aClass.isInlineClass() ? \"Q\" : \"L\") + classToInternalName(aClass) + \";\";\n+                }\n+            }\n+\n+            @Override\n+            public boolean isValue(String desc) {\n+                Class<?> aClass = symbol(desc);\n+                return aClass != null && aClass.isInlineClass();\n+            }\n+\n+            @Override\n+            public Class<?> symbol(String desc) {\n+                try {\n+                    if (desc.startsWith(\"[\")) {\n+                        return Class.forName(desc.replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                    } else {\n+                        return Class.forName(basicTypeHelper.symbol(desc).replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n+                    }\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }\n+\n+            @Override\n+            public TypeTag tag(String s) {\n+                return basicTypeHelper.tag(s);\n+            }\n+\n+            @Override\n+            public Class<?> symbolFrom(String s) {\n+                return symbol(s);\n+            }\n+\n+            @Override\n+            public String commonSupertype(String t1, String t2) {\n+                return basicTypeHelper.commonSupertype(t1, t2);\n+            }\n+\n+            @Override\n+            public String nullType() {\n+                return basicTypeHelper.nullType();\n+            }\n+        }\n+\n+        static class IsolatedMethodPoolHelper extends BytePoolHelper<Class<?>, String> {\n+            final String clazz;\n+\n+            IsolatedMethodPoolHelper(String clazz) {\n+                super(c -> from(c, clazz), s->s);\n+                this.clazz = clazz;\n+            }\n+\n+            Object[] patches() {\n+                return null;\n+            }\n+\n+            static String from(Class<?> c, String clazz) {\n+                return c == THIS_CLASS ? clazz.replace('.', '\/')\n+                                       : classToInternalName(c);\n+            }\n+        }\n+\n+        @Override\n+        public byte[] build() {\n+            return super.build();\n+        }\n+    }\n+\n+    public static class MethodHandleCodeBuilder<T extends MethodHandleCodeBuilder<T>> extends TypedCodeBuilder<Class<?>, String, byte[], T> {\n+\n+        BasicTypeHelper basicTypeHelper = new BasicTypeHelper();\n+\n+        public MethodHandleCodeBuilder(jdk.experimental.bytecode.MethodBuilder<Class<?>, String, byte[]> methodBuilder) {\n+            super(methodBuilder);\n+        }\n+\n+        TypeTag getTagType(String s) {\n+            return basicTypeHelper.tag(s);\n+        }\n+\n+        public T ifcmp(String s, CondKind cond, CharSequence label) {\n+            return super.ifcmp(getTagType(s), cond, label);\n+        }\n+\n+        public T return_(String s) {\n+            return super.return_(getTagType(s));\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/InstructionHelper.java","additions":209,"deletions":3,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n- * @library \/java\/lang\/invoke\/common\n- * @modules java.base\/jdk.experimental.bytecode\n- * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @library \/lib\/testlibrary\/bytecode \/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/BootstrapMethodJumboArgsTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n- * @library \/java\/lang\/invoke\/common\n- * @modules java.base\/jdk.experimental.bytecode\n- * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @library \/lib\/testlibrary\/bytecode  \/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyBSMException.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n- * @library \/java\/lang\/invoke\/common\n- * @modules java.base\/jdk.experimental.bytecode\n- * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @library \/lib\/testlibrary\/bytecode \/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyBSMInvocation.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n- * @library \/java\/lang\/invoke\/common\n- * @modules java.base\/jdk.experimental.bytecode\n- * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @library \/lib\/testlibrary\/bytecode \/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyBSMValidationTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n+ * @library \/lib\/testlibrary\/bytecode\n+ * @build jdk.experimental.bytecode.BasicClassBuilder\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyInterfaceWithOverpassMethods.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n- * @library \/java\/lang\/invoke\/common\n- * @modules java.base\/jdk.experimental.bytecode\n- * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @library \/lib\/testlibrary\/bytecode \/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyNameValidationTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n- * @library \/java\/lang\/invoke\/common\n- * @modules java.base\/jdk.experimental.bytecode\n+ * @library \/lib\/testlibrary\/bytecode \/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyRepeatFailedResolution.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n+ * @library \/lib\/testlibrary\/bytecode\n+ * @build jdk.experimental.bytecode.BasicClassBuilder\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyReturnPrimitiveTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n- * @library \/java\/lang\/invoke\/common\n- * @modules java.base\/jdk.experimental.bytecode\n- * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @library \/lib\/testlibrary\/bytecode \/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -112,1 +111,1 @@\n-                            return P.putMethodHandle(mhi.getReferenceKind(), \"CondyStaticArgumentsTest\", mhi.getName(), bi.descriptor);\n+                            return P.putHandle(mhi.getReferenceKind(), \"CondyStaticArgumentsTest\", mhi.getName(), bi.descriptor);\n@@ -151,1 +150,1 @@\n-        return P.putConstantDynamic(\"big-decimal\", \"Ljava\/math\/BigDecimal;\", InstructionHelper.csym(L.lookupClass()), bi.methodName, bi.descriptor,\n+        return P.putDynamicConstant(\"big-decimal\", \"Ljava\/math\/BigDecimal;\", InstructionHelper.csym(L.lookupClass()), bi.methodName, bi.descriptor,\n@@ -160,1 +159,1 @@\n-        return P.putConstantDynamic(mc, \"Ljava\/math\/MathContext;\", InstructionHelper.csym(L.lookupClass()), bi.methodName, bi.descriptor,\n+        return P.putDynamicConstant(mc, \"Ljava\/math\/MathContext;\", InstructionHelper.csym(L.lookupClass()), bi.methodName, bi.descriptor,\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyStaticArgumentsTest.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n- * @library \/java\/lang\/invoke\/common\n- * @modules java.base\/jdk.experimental.bytecode\n+ * @library \/lib\/testlibrary\/bytecode \/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyTypeValidationTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n- * @library \/java\/lang\/invoke\/common\n- * @modules java.base\/jdk.experimental.bytecode\n- * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @library \/lib\/testlibrary\/bytecode \/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyWithGarbageTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n- * @library \/java\/lang\/invoke\/common\n- * @modules java.base\/jdk.experimental.bytecode\n- * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @library \/lib\/testlibrary\/bytecode \/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyWrongType.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n- * @modules java.base\/jdk.experimental.bytecode\n- * @library \/java\/lang\/invoke\/common\n- * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @library \/lib\/testlibrary\/bytecode \/java\/lang\/invoke\/common\n+ * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.InstructionHelper\n@@ -163,0 +162,1 @@\n+\n@@ -169,1 +169,1 @@\n-                        return P.putMethodHandle(MethodHandleInfo.REF_invokeStatic, \"java\/util\/List\", \"of\",\n+                        return P.putHandle(MethodHandleInfo.REF_invokeStatic, \"java\/util\/List\", \"of\",\n@@ -184,1 +184,1 @@\n-                        return P.putMethodHandle(MethodHandleInfo.REF_invokeStatic, \"java\/lang\/Integer\", \"valueOf\",\n+                        return P.putHandle(MethodHandleInfo.REF_invokeStatic, \"java\/lang\/Integer\", \"valueOf\",\n@@ -200,1 +200,1 @@\n-                        return P.putMethodHandle(MethodHandleInfo.REF_invokeStatic, \"java\/util\/List\", \"of\",\n+                        return P.putHandle(MethodHandleInfo.REF_invokeStatic, \"java\/util\/List\", \"of\",\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/ConstantBootstrapsTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+    public BasicClassBuilder(BytePoolHelper<String, String> poolHelper, TypeHelper<String, String> typeHelper) {\n+        super(poolHelper, typeHelper);\n+    }\n+\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/BasicClassBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,5 @@\n+    @Override\n+    public boolean isValue(String t) {\n+        return t.charAt(0) == 'Q' && t.endsWith(\";\");\n+    }\n+\n@@ -53,0 +58,5 @@\n+    @Override\n+    public String valueType(String s) {\n+        return \"Q\" + s + \";\";\n+    }\n+\n@@ -58,0 +68,1 @@\n+            case 'Q':\n@@ -73,2 +84,0 @@\n-            case 'Q':\n-                return TypeTag.Q;\n@@ -76,0 +85,3 @@\n+                if (s == nullType()) {\n+                    return TypeTag.A;\n+                }\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/BasicTypeHelper.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodType;\n@@ -339,0 +340,5 @@\n+    @Override\n+    public int putValueClass(S symbol) {\n+        return putClassInternal(\"Q\" + symbolToString.apply(symbol) + \";\");\n+    }\n+\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/BytePoolHelper.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,2 +102,2 @@\n-    public C vgetfield(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.VGETFIELD, type);\n+    public C putfield(S owner, CharSequence name, T type) {\n+        emitOp(Opcode.PUTFIELD, type);\n@@ -108,2 +108,2 @@\n-    public C putfield(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.PUTFIELD, type);\n+    public C withfield(S owner, CharSequence name, T type) {\n+        emitOp(Opcode.WITHFIELD, type);\n@@ -158,9 +158,3 @@\n-    public C vnew_(S clazz, CharSequence name, T desc) {\n-        emitOp(Opcode.VNEW, clazz);\n-        code.writeChar(poolHelper.putMethodRef(clazz, name, desc, false));\n-        return thisBuilder();\n-    }\n-\n-    public C vnewarray(S array) {\n-        emitOp(Opcode.VNEWARRAY, array);\n-        code.writeChar(poolHelper.putClass(array));\n+    public C defaultvalue(S clazz) {\n+        emitOp(Opcode.DEFAULTVALUE, clazz);\n+        code.writeChar(poolHelper.putClass(clazz));\n@@ -204,18 +198,0 @@\n-    public C multivnewarray(S array, byte dims) {\n-        emitOp(Opcode.MULTIVNEWARRAY, new Object[]{array, dims});\n-        code.writeChar(poolHelper.putClass(array)).writeByte(dims);\n-        return thisBuilder();\n-    }\n-\n-    public C vbox(S target) {\n-        emitOp(Opcode.VBOX, target);\n-        code.writeChar(poolHelper.putClass(target));\n-        return thisBuilder();\n-    }\n-\n-    public C vunbox(S target) {\n-        emitOp(Opcode.VUNBOX, target);\n-        code.writeChar(poolHelper.putClass(target));\n-        return thisBuilder();\n-    }\n-\n@@ -296,4 +272,0 @@\n-    public C vreturn() {\n-        return emitOp(Opcode.VRETURN);\n-    }\n-\n@@ -328,84 +300,0 @@\n-    public TypedBuilder typed(TypeTag typeTag) {\n-        return typed(typeTag, _unused -> new TypedBuilder());\n-    }\n-\n-    protected <TB extends TypedBuilder> TB typed(TypeTag typeTag, Function<TypeTag, TB> typedBuilderFunc) {\n-        emitOp(Opcode.TYPED);\n-        code.writeChar(poolHelper.putType(typeHelper.fromTag(typeTag)));\n-        return typedBuilderFunc.apply(typeTag);\n-    }\n-\n-    public class TypedBuilder {\n-        public C aload_0() {\n-            return CodeBuilder.this.aload_0();\n-        }\n-\n-        public C aload_1() {\n-            return CodeBuilder.this.aload_1();\n-        }\n-\n-        public C aload_2() {\n-            return CodeBuilder.this.aload_2();\n-        }\n-\n-        public C aload_3() {\n-            return CodeBuilder.this.aload_3();\n-        }\n-\n-        public C aload(int n) {\n-            return CodeBuilder.this.aload(n);\n-        }\n-\n-        public C astore_0() {\n-            return CodeBuilder.this.astore_0();\n-        }\n-\n-        public C astore_1() {\n-            return CodeBuilder.this.astore_1();\n-        }\n-\n-        public C astore_2() {\n-            return CodeBuilder.this.astore_2();\n-        }\n-\n-        public C astore_3() {\n-            return CodeBuilder.this.astore_3();\n-        }\n-\n-        public C astore(int n) {\n-            return CodeBuilder.this.astore(n);\n-        }\n-\n-        public C aaload() {\n-            return CodeBuilder.this.aaload();\n-        }\n-\n-        public C aastore() {\n-            return CodeBuilder.this.aastore();\n-        }\n-\n-        public C areturn() {\n-            return CodeBuilder.this.areturn();\n-        }\n-\n-        public C anewarray(S s) {\n-            return CodeBuilder.this.anewarray(s);\n-        }\n-\n-        public C aconst_null() {\n-            return CodeBuilder.this.aconst_null();\n-        }\n-\n-        public C if_acmpeq(short target) {\n-            return CodeBuilder.this.if_acmpeq(target);\n-        }\n-\n-        public C if_acmpne(short target) {\n-            return CodeBuilder.this.if_acmpeq(target);\n-        }\n-    }\n-\n-    public C vload(int i) {\n-        return emitWideIfNeeded(Opcode.VLOAD, i);\n-    }\n-\n@@ -512,4 +400,0 @@\n-    public C vstore(int i) {\n-        return emitWideIfNeeded(Opcode.VSTORE, i);\n-    }\n-\n@@ -634,4 +518,0 @@\n-    public C vaload() {\n-        return emitOp(Opcode.VALOAD);\n-    }\n-\n@@ -670,4 +550,0 @@\n-    public C vastore() {\n-        return emitOp(Opcode.VASTORE);\n-    }\n-\n@@ -1283,1 +1159,2 @@\n-                        stackmaps.writeChar(poolHelper.putClass(typeHelper.symbol(t)));\n+                        stackmaps.writeChar(typeHelper.isValue(t) ?\n+                            poolHelper.putValueClass(typeHelper.symbol(t)) : poolHelper.putClass(typeHelper.symbol(t)));\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/CodeBuilder.java","additions":9,"deletions":132,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    ACC_INLINE(0x0100),\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/Flag.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,5 @@\n+        @Override\n+        public int putValueClass(Class<?> symbol) {\n+            return putIfAbsent(symbol);\n+        }\n+\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/IsolatedMethodBuilder.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -118,15 +118,11 @@\n-        if (type == TypeTag.Q) {\n-            return vload(n);\n-        } else {\n-            switch (n) {\n-                case 0:\n-                    return emitOp(Opcode.ILOAD_0.at(type, 4));\n-                case 1:\n-                    return emitOp(Opcode.ILOAD_1.at(type, 4));\n-                case 2:\n-                    return emitOp(Opcode.ILOAD_2.at(type, 4));\n-                case 3:\n-                    return emitOp(Opcode.ILOAD_3.at(type, 4));\n-                default:\n-                    return emitWideIfNeeded(Opcode.ILOAD.at(type), n);\n-            }\n+        switch (n) {\n+            case 0:\n+                return emitOp(Opcode.ILOAD_0.at(type, 4));\n+            case 1:\n+                return emitOp(Opcode.ILOAD_1.at(type, 4));\n+            case 2:\n+                return emitOp(Opcode.ILOAD_2.at(type, 4));\n+            case 3:\n+                return emitOp(Opcode.ILOAD_3.at(type, 4));\n+            default:\n+                return emitWideIfNeeded(Opcode.ILOAD.at(type), n);\n@@ -137,15 +133,11 @@\n-        if (type == TypeTag.Q) {\n-            return vstore(n);\n-        } else {\n-            switch (n) {\n-                case 0:\n-                    return emitOp(Opcode.ISTORE_0.at(type, 4));\n-                case 1:\n-                    return emitOp(Opcode.ISTORE_1.at(type, 4));\n-                case 2:\n-                    return emitOp(Opcode.ISTORE_2.at(type, 4));\n-                case 3:\n-                    return emitOp(Opcode.ISTORE_3.at(type, 4));\n-                default:\n-                    return emitWideIfNeeded(Opcode.ISTORE.at(type), n);\n-            }\n+        switch (n) {\n+            case 0:\n+                return emitOp(Opcode.ISTORE_0.at(type, 4));\n+            case 1:\n+                return emitOp(Opcode.ISTORE_1.at(type, 4));\n+            case 2:\n+                return emitOp(Opcode.ISTORE_2.at(type, 4));\n+            case 3:\n+                return emitOp(Opcode.ISTORE_3.at(type, 4));\n+            default:\n+                return emitWideIfNeeded(Opcode.ISTORE.at(type), n);\n@@ -311,1 +303,0 @@\n-                return return_();\n@@ -313,1 +304,1 @@\n-                return vreturn();\n+                return return_();\n@@ -319,15 +310,0 @@\n-    @Override\n-    public LabelledTypedBuilder typed(TypeTag typeTag) {\n-        return super.typed(typeTag, _unused -> new LabelledTypedBuilder());\n-    }\n-\n-    public class LabelledTypedBuilder extends TypedBuilder {\n-        public C if_acmpeq(CharSequence target) {\n-            return ifcmp(TypeTag.A, CondKind.EQ, target);\n-        }\n-\n-        public C if_acmpne(CharSequence target) {\n-            return ifcmp(TypeTag.A, CondKind.NE, target);\n-        }\n-    }\n-\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/MacroCodeBuilder.java","additions":23,"deletions":47,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -232,12 +232,3 @@\n-    VLOAD(203),\n-    VSTORE(204),\n-    VALOAD(205),\n-    VASTORE(206),\n-    VNEW(207),\n-    VNEWARRAY(208),\n-    MULTIVNEWARRAY(209),\n-    VRETURN(210),\n-    VGETFIELD(211),\n-    TYPED(212),\n-    VBOX(216),\n-    VUNBOX(217);\n+    DEFAULTVALUE(203),\n+    WITHFIELD(204);\n+\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/Opcode.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+    int putValueClass(S symbol);\n+\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/PoolHelper.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,18 @@\n+     * Return true if the parameter is a value type.\n+     *\n+     * @param t the type descreiptor\n+     * @return true if the given type is a value type\n+     *\/\n+    boolean isValue(T t);\n+\n+    \/**\n+     * For a symbol that corresponds to a value type, return the type descriptor.\n+     *\n+     * @param s the symbol\n+     * @return the type descriptor\n+     *\/\n+    default T valueType(S s) {\n+        return type(s);\n+    }\n+\n+    \/**\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/TypeHelper.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -140,89 +140,0 @@\n-    @Override\n-    public StatefulTypedBuilder typed(TypeTag tag) {\n-        return super.typed(tag, StatefulTypedBuilder::new);\n-    }\n-\n-    public class StatefulTypedBuilder extends LabelledTypedBuilder {\n-\n-        TypeTag tag;\n-\n-        StatefulTypedBuilder(TypeTag tag) {\n-            this.tag = tag;\n-        }\n-\n-        @Override\n-        public C astore_0() {\n-            return storeAndUpdate(super::astore_0);\n-        }\n-\n-        @Override\n-        public C astore_1() {\n-            return storeAndUpdate(super::astore_1);\n-        }\n-\n-        @Override\n-        public C astore_2() {\n-            return storeAndUpdate(super::astore_2);\n-        }\n-\n-        @Override\n-        public C astore_3() {\n-            return storeAndUpdate(super::astore_3);\n-        }\n-\n-        @Override\n-        public C astore(int n) {\n-            return storeAndUpdate(() -> super.astore(n));\n-        }\n-\n-        @Override\n-        public C aastore() {\n-            return storeAndUpdate(super::aastore);\n-        }\n-\n-        @Override\n-        public C areturn() {\n-            state.pop(tag);\n-            state.push(typeHelper.nullType());\n-            return super.areturn();\n-        }\n-\n-        @Override\n-        public C anewarray(S s) {\n-            super.anewarray(s);\n-            state.pop();\n-            state.push(typeHelper.arrayOf(typeHelper.type(s)));\n-            return thisBuilder();\n-        }\n-\n-        @Override\n-        public C aconst_null() {\n-            super.aconst_null();\n-            state.pop();\n-            state.push(tag);\n-            return thisBuilder();\n-        }\n-\n-        public C if_acmpeq(CharSequence label) {\n-            return jumpAndUpdate(() -> super.if_acmpeq(label));\n-        }\n-\n-        public C if_acmpne(CharSequence label) {\n-            return jumpAndUpdate(() -> super.if_acmpne(label));\n-        }\n-\n-        private C storeAndUpdate(Supplier<C> op) {\n-            state.pop(tag);\n-            state.push(typeHelper.nullType());\n-            return op.get();\n-        }\n-\n-        private C jumpAndUpdate(Supplier<C> op) {\n-            state.pop(tag);\n-            state.pop(tag);\n-            state.push(typeHelper.nullType());\n-            state.push(typeHelper.nullType());\n-            return op.get();\n-        }\n-    }\n-\n@@ -389,1 +300,0 @@\n-            case VALOAD:\n@@ -398,0 +308,1 @@\n+            case IINC:\n@@ -461,1 +372,0 @@\n-            case VLOAD:\n@@ -510,1 +420,0 @@\n-            case VSTORE:\n@@ -539,1 +448,0 @@\n-            case VRETURN:\n@@ -579,1 +487,0 @@\n-            case VASTORE:\n@@ -826,1 +733,0 @@\n-            case VNEW:\n@@ -828,0 +734,1 @@\n+            case DEFAULTVALUE:\n@@ -838,7 +745,0 @@\n-            case VNEWARRAY:\n-            case VBOX:\n-            case VUNBOX:\n-                state.pop();\n-                state.push(typeHelper.type((S) optValue));\n-                break;\n-            case MULTIVNEWARRAY:\n@@ -861,1 +761,0 @@\n-            case VGETFIELD:\n@@ -885,0 +784,9 @@\n+            case WITHFIELD: {\n+                TypeTag tag = typeHelper.tag((T) optValue);\n+                if (tag.width == 1) {\n+                    state.pop();\n+                } else {\n+                    state.pop2();\n+                }\n+                break;\n+            }\n@@ -919,1 +827,0 @@\n-            case TYPED:\n@@ -967,0 +874,5 @@\n+            @Override\n+            public int putValueClass(S symbol) {\n+                throw new IllegalStateException();\n+            }\n+\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/TypedCodeBuilder.java","additions":16,"deletions":104,"binary":false,"changes":120,"status":"modified"}]}