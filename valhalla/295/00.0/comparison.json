{"files":[{"patch":"@@ -1241,0 +1241,1 @@\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -1773,0 +1774,5 @@\n+int MachCallNativeNode::ret_addr_offset() {\n+  ShouldNotReachHere();\n+  return -1;\n+}\n+\n@@ -13897,0 +13903,28 @@\n+instruct absdF_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (AbsF (SubF src1 src2)));\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{ \"fabds   $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fabds(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_uop_s);\n+%}\n+\n+instruct absdD_reg(vRegD dst, vRegD src1, vRegD src2) %{\n+  match(Set dst (AbsD (SubD src1 src2)));\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{ \"fabdd   $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fabdd(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_uop_d);\n+%}\n+\n@@ -17875,123 +17909,0 @@\n-\/\/ --------------------------------- ABS --------------------------------------\n-\n-instruct vabs8B(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n-  match(Set dst (AbsVB src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vabs16B(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (AbsVB src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs4S(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVS src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vabs8S(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AbsVS src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs2I(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vabs4I(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs2L(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVL src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs2F(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVF src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabs  $dst,$src\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fabs(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp64);\n-%}\n-\n-instruct vabs4F(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVF src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabs  $dst,$src\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fabs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct vabs2D(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVD src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabs  $dst,$src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fabs(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":34,"deletions":123,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -684,1 +684,1 @@\n-  ldr(esp,\n+  ldr(rscratch2,\n@@ -690,0 +690,2 @@\n+    \/\/ look for an overflow into the stack reserved zone, i.e.\n+    \/\/ interpreter_frame_sender_sp <= JavaThread::reserved_stack_activation\n@@ -691,1 +693,1 @@\n-    cmp(esp, rscratch1);\n+    cmp(rscratch2, rscratch1);\n@@ -702,0 +704,3 @@\n+\n+  \/\/ restore sender esp\n+  mov(esp, rscratch2);\n@@ -1620,1 +1625,1 @@\n-    stop(\"InterpreterMacroAssembler::call_VM_leaf_base:\"\n+    stop(\"InterpreterMacroAssembler::call_VM_base:\"\n@@ -1781,1 +1786,1 @@\n-      subs(zr, rscratch1, vmIntrinsics::_compiledLambdaForm);\n+      subs(zr, rscratch1, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  std(return_pc, _abi(lr), R1_SP);     \/\/ SP->lr = return_pc\n+  std(return_pc, _abi0(lr), R1_SP);     \/\/ SP->lr = return_pc\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -775,1 +775,1 @@\n-    ld(return_pc, _abi(lr), Rscratch1); \/\/ LR\n+    ld(return_pc, _abi0(lr), Rscratch1); \/\/ LR\n@@ -852,1 +852,1 @@\n-    ld_ptr(R11_scratch1, _abi(callers_sp), R1_SP); \/\/ Load frame pointer.\n+    ld_ptr(R11_scratch1, _abi0(callers_sp), R1_SP); \/\/ Load frame pointer.\n@@ -1922,1 +1922,1 @@\n-      cmpwi(CCR1, tmp2, vmIntrinsics::_compiledLambdaForm);\n+      cmpwi(CCR1, tmp2, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -860,1 +860,1 @@\n-  std(tmp, _abi(cr), R1_SP);\n+  std(tmp, _abi0(cr), R1_SP);\n@@ -862,1 +862,1 @@\n-  std(tmp, _abi(lr), R1_SP);\n+  std(tmp, _abi0(lr), R1_SP);\n@@ -868,1 +868,1 @@\n-  ld(tmp, _abi(lr), R1_SP);\n+  ld(tmp, _abi0(lr), R1_SP);\n@@ -870,1 +870,1 @@\n-  ld(tmp, _abi(cr), R1_SP);\n+  ld(tmp, _abi0(cr), R1_SP);\n@@ -891,1 +891,1 @@\n-  ld(tmp, _abi(callers_sp), R1_SP);\n+  ld(tmp, _abi0(callers_sp), R1_SP);\n@@ -903,1 +903,1 @@\n-  ld(tmp, _abi(callers_sp), R1_SP);\n+  ld(tmp, _abi0(callers_sp), R1_SP);\n@@ -957,1 +957,1 @@\n-  ld(R1_SP, _abi(callers_sp), R1_SP);\n+  ld(R1_SP, _abi0(callers_sp), R1_SP);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1809,1 +1809,1 @@\n-        z_cli(Method::intrinsic_id_offset_in_bytes(), tmp, vmIntrinsics::_compiledLambdaForm);\n+        z_cli(Method::intrinsic_id_offset_in_bytes(), tmp, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n@@ -1813,1 +1813,1 @@\n-        z_chi(tmp, vmIntrinsics::_compiledLambdaForm);\n+        z_chi(tmp, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1894,0 +1894,14 @@\n+\n+void C2_MacroAssembler::genmask(Register dst, Register len, Register temp) {\n+  if (ArrayCopyPartialInlineSize <= 32) {\n+    mov64(dst, 1);\n+    shlxq(dst, dst, len);\n+    decq(dst);\n+  } else {\n+    mov64(dst, -1);\n+    movq(temp, len);\n+    negptr(temp);\n+    addptr(temp, 64);\n+    shrxq(dst, dst, temp);\n+  }\n+}\n@@ -1940,0 +1954,9 @@\n+void C2_MacroAssembler::evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, Address src, int vector_len) {\n+  MacroAssembler::evmovdqu(type, kmask, dst, src, vector_len);\n+}\n+\n+void C2_MacroAssembler::evmovdqu(BasicType type, KRegister kmask, Address dst, XMMRegister src, int vector_len) {\n+  MacroAssembler::evmovdqu(type, kmask, dst, src, vector_len);\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-      cmpw(Address(tmp, Method::intrinsic_id_offset_in_bytes()), vmIntrinsics::_compiledLambdaForm);\n+      cmpw(Address(tmp, Method::intrinsic_id_offset_in_bytes()), static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5305,1 +5305,2 @@\n-      for (int id = vmIntrinsics::FIRST_ID; id < (int)vmIntrinsics::ID_LIMIT; ++id) {\n+      for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n+        vmIntrinsicID id = *it;\n@@ -5313,1 +5314,1 @@\n-        if (vmIntrinsics::class_for(vmIntrinsics::ID_from(id)) == klass_id) {\n+        if (vmIntrinsics::class_for(id) == klass_id) {\n@@ -5329,2 +5330,1 @@\n-                        vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),\n-                                                             buf, sizeof(buf)),\n+                        vmIntrinsics::short_name_as_C_string(id, buf, sizeof(buf)),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2513,1 +2513,1 @@\n-Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,\n+Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsicID iid,\n@@ -2517,0 +2517,1 @@\n+  const int iid_as_int = vmIntrinsics::as_int(iid);\n@@ -2520,1 +2521,1 @@\n-         \"must be a known MH intrinsic iid=%d: %s\", iid, vmIntrinsics::name_at(iid));\n+         \"must be a known MH intrinsic iid=%d: %s\", iid_as_int, vmIntrinsics::name_at(iid));\n@@ -2522,1 +2523,1 @@\n-  unsigned int hash  = invoke_method_table()->compute_hash(signature, iid);\n+  unsigned int hash  = invoke_method_table()->compute_hash(signature, iid_as_int);\n@@ -2524,1 +2525,1 @@\n-  SymbolPropertyEntry* spe = invoke_method_table()->find_entry(index, hash, signature, iid);\n+  SymbolPropertyEntry* spe = invoke_method_table()->find_entry(index, hash, signature, iid_as_int);\n@@ -2543,1 +2544,1 @@\n-      spe = invoke_method_table()->find_entry(index, hash, signature, iid);\n+      spe = invoke_method_table()->find_entry(index, hash, signature, iid_as_int);\n@@ -2545,1 +2546,1 @@\n-        spe = invoke_method_table()->add_entry(index, hash, signature, iid);\n+        spe = invoke_method_table()->add_entry(index, hash, signature, iid_as_int);\n@@ -2696,1 +2697,1 @@\n-  vmIntrinsics::ID null_iid = vmIntrinsics::_none;  \/\/ distinct from all method handle invoker intrinsics\n+  int null_iid = vmIntrinsics::as_int(vmIntrinsics::_none);  \/\/ distinct from all method handle invoker intrinsics\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -277,0 +277,1 @@\n+  template(linkToNative_name,                         \"linkToNative\")                             \\\n@@ -351,2 +352,5 @@\n-                                                                                                                                      \\\n-  \/* Support for JVMCI *\/                                                                                                             \\\n+  \/* Panama Support *\/                                                                                          \\\n+  template(jdk_internal_invoke_NativeEntryPoint,                 \"jdk\/internal\/invoke\/NativeEntryPoint\")           \\\n+  template(jdk_internal_invoke_NativeEntryPoint_signature,       \"Ljdk\/internal\/invoke\/NativeEntryPoint;\")         \\\n+                                                                                                  \\\n+  \/* Support for JVMCI *\/                                                                         \\\n@@ -394,0 +398,1 @@\n+  template(refersTo0_name,                            \"refersTo0\")                                \\\n@@ -524,0 +529,1 @@\n+  template(long_array_signature,                      \"[J\")                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1013,1 +1013,0 @@\n-     <Field type=\"boolean\" name=\"noReserve\" label=\"No Reserve\" \/>\n@@ -1019,2 +1018,1 @@\n-    <Field type=\"ulong\" contentType=\"bytes\" name=\"compactingFrom\" label=\"Compacting From\" \/>\n-    <Field type=\"ulong\" contentType=\"bytes\" name=\"compactingTo\" label=\"Compacting To\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"relocate\" label=\"Relocate\" \/>\n@@ -1028,2 +1026,1 @@\n-    <Field type=\"ulong\" contentType=\"bytes\" name=\"compactingFrom\" label=\"Compacting From\" \/>\n-    <Field type=\"ulong\" contentType=\"bytes\" name=\"compactingTo\" label=\"Compacting To\" \/>\n+    <Field type=\"ulong\" contentType=\"bytes\" name=\"relocate\" label=\"Relocate\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2574,0 +2574,1 @@\n+#if INCLUDE_JVMTI\n@@ -2580,0 +2581,4 @@\n+    \/\/ First fix any default methods that point to a super class that may\n+    \/\/ have been redefined.\n+    bool trace_name_printed = false;\n+    adjust_default_methods(&trace_name_printed);\n@@ -2583,0 +2588,1 @@\n+#endif\n@@ -2981,21 +2987,0 @@\n-\/\/ Returns true iff super_method can be overridden by a method in targetclassname\n-\/\/ See JLS 3rd edition 8.4.6.1\n-\/\/ Assumes name-signature match\n-\/\/ \"this\" is InstanceKlass of super_method which must exist\n-\/\/ note that the InstanceKlass of the method in the targetclassname has not always been created yet\n-bool InstanceKlass::is_override(const methodHandle& super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS) {\n-   \/\/ Private methods can not be overridden\n-   if (super_method->is_private()) {\n-     return false;\n-   }\n-   \/\/ If super method is accessible, then override\n-   if ((super_method->is_protected()) ||\n-       (super_method->is_public())) {\n-     return true;\n-   }\n-   \/\/ Package-private methods are not inherited outside of package\n-   assert(super_method->is_package_private(), \"must be package private\");\n-   return(is_same_class_package(targetclassloader(), targetclassname));\n-}\n-\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -524,9 +524,9 @@\n-  { \"UseBiasedLocking\",             JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"BiasedLockingStartupDelay\",    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"PrintBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"BiasedLockingBulkRebiasThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"BiasedLockingBulkRevokeThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"BiasedLockingDecayTime\",              JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"UseOptoBiasInlining\",                 JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"PrintPreciseBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"CriticalJNINatives\",                  JDK_Version::jdk(16), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"CriticalJNINatives\",           JDK_Version::jdk(16), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"UseBiasedLocking\",             JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"BiasedLockingStartupDelay\",    JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"PrintBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"BiasedLockingBulkRebiasThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"BiasedLockingBulkRevokeThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"BiasedLockingDecayTime\",              JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"UseOptoBiasInlining\",                 JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"PrintPreciseBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n@@ -572,10 +572,0 @@\n-#ifndef COMPILER2\n-  \/\/ These flags were generally available, but are C2 only, now.\n-  { \"MaxInlineLevel\",               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n-  { \"MaxRecursiveInlineLevel\",      JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n-  { \"InlineSmallCode\",              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n-  { \"MaxInlineSize\",                JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n-  { \"FreqInlineSize\",               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n-  { \"MaxTrivialSize\",               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n-#endif\n-\n@@ -1681,1 +1671,0 @@\n-#ifndef ZERO\n@@ -1702,1 +1691,0 @@\n-#endif \/\/ ZERO\n@@ -1709,1 +1697,0 @@\n-#ifndef ZERO\n@@ -1737,1 +1724,0 @@\n-#endif \/\/ !ZERO\n@@ -1756,1 +1742,0 @@\n-#ifndef ZERO\n@@ -1767,1 +1752,0 @@\n-#endif \/\/ !ZERO\n@@ -3925,0 +3909,4 @@\n+  if (ReplayCompiles) {\n+    FLAG_SET_ERGO_IF_DEFAULT(UseDebuggerErgo, true);\n+  }\n+\n@@ -4193,2 +4181,0 @@\n-  LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedOops, false));\n-  LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedClassPointers, false));\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":13,"deletions":27,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2493,1 +2493,6 @@\n-                \"Make nmethod barriers deoptimise a lot.\")\n+                \"Make nmethod barriers deoptimise a lot.\")                  \\\n+                                                                            \\\n+  develop(bool, VerifyCrossModifyFence,                                     \\\n+          false AARCH64_ONLY(DEBUG_ONLY(||true)),                           \\\n+             \"Mark all threads after a safepoint, and clear on a modify \"   \\\n+             \"fence. Add cleanliness checks.\")                              \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -230,2 +230,8 @@\n-#define NINFLATIONLOCKS 256\n-static volatile intptr_t gInflationLocks[NINFLATIONLOCKS];\n+static const int NINFLATIONLOCKS = 256;\n+static os::PlatformMutex* gInflationLocks[NINFLATIONLOCKS];\n+\n+void ObjectSynchronizer::initialize() {\n+  for (int i = 0; i < NINFLATIONLOCKS; i++) {\n+    gInflationLocks[i] = new os::PlatformMutex();\n+  }\n+}\n@@ -344,1 +350,1 @@\n-    Thread* const owner = (Thread *) m->_owner;\n+    Thread* const owner = (Thread *) m->owner_raw();\n@@ -758,7 +764,1 @@\n-    \/\/ Avoid live-lock\n-    \/\/ TODO: consider calling SafepointSynchronize::do_call_back() while\n-    \/\/ spinning to see if there's a safepoint pending.  If so, immediately\n-    \/\/ yielding or blocking would be appropriate.  Avoid spinning while\n-    \/\/ there is a safepoint pending.\n-    \/\/ TODO: add inflation contention performance counters.\n-    \/\/ TODO: restrict the aggregate number of spinners.\n+    \/\/ Avoid live-lock.\n@@ -784,2 +784,3 @@\n-        \/\/ This is conceptually similar to muxAcquire-muxRelease, except that muxRelease\n-        \/\/ wakes at most one thread whereas we need to wake the entire list.\n+\n+        \/\/ Index into the lock array based on the current object address.\n+        static_assert(is_power_of_2(NINFLATIONLOCKS), \"must be\");\n@@ -789,2 +790,1 @@\n-        assert((NINFLATIONLOCKS & (NINFLATIONLOCKS-1)) == 0, \"invariant\");\n-        Thread::muxAcquire(gInflationLocks + ix, \"gInflationLock\");\n+        gInflationLocks[ix]->lock();\n@@ -792,1 +792,1 @@\n-          \/\/ Beware: NakedYield() is advisory and has almost no effect on some platforms\n+          \/\/ Beware: naked_yield() is advisory and has almost no effect on some platforms\n@@ -801,1 +801,1 @@\n-        Thread::muxRelease(gInflationLocks + ix);\n+        gInflationLocks[ix]->unlock();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -117,0 +118,3 @@\n+  \/\/ Initialize the gInflationLocks\n+  static void initialize();\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -812,1 +812,1 @@\n-     *  one of the units has the value {@code Long.MIN_VALUE}\n+     *  one of the units has the value {@code Integer.MIN_VALUE}\n","filename":"src\/java.base\/share\/classes\/java\/time\/Period.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,2 +96,1 @@\n-\n-\n+    static final ListN<?> EMPTY_LIST_NULLS;\n@@ -100,1 +99,0 @@\n-\n@@ -107,1 +105,2 @@\n-            EMPTY_LIST = new ListN<>(new Object[0]);\n+            EMPTY_LIST = new ListN<>(new Object[0], false);\n+            EMPTY_LIST_NULLS = new ListN<>(new Object[0], true);\n@@ -110,1 +109,2 @@\n-            archivedObjects = new Object[] { EMPTY, EMPTY_LIST, EMPTY_SET, EMPTY_MAP };\n+            archivedObjects =\n+                new Object[] { EMPTY, EMPTY_LIST, EMPTY_LIST_NULLS, EMPTY_SET, EMPTY_MAP };\n@@ -114,2 +114,3 @@\n-            EMPTY_SET = (SetN)archivedObjects[2];\n-            EMPTY_MAP = (MapN)archivedObjects[3];\n+            EMPTY_LIST_NULLS = (ListN)archivedObjects[2];\n+            EMPTY_SET = (SetN)archivedObjects[3];\n+            EMPTY_MAP = (MapN)archivedObjects[4];\n@@ -123,1 +124,4 @@\n-                    return ImmutableCollections.ListN.fromTrustedArray(array);\n+                    return ImmutableCollections.listFromTrustedArray(array);\n+                }\n+                public <E> List<E> listFromTrustedArrayNullsAllowed(Object[] array) {\n+                    return ImmutableCollections.listFromTrustedArrayNullsAllowed(array);\n@@ -152,1 +156,1 @@\n-    \/\/ ---------- List Implementations ----------\n+    \/\/ ---------- List Static Factory Methods ----------\n@@ -154,1 +158,9 @@\n-    \/\/ make a copy, short-circuiting based on implementation class\n+    \/**\n+     * Copies a collection into a new List, unless the arg is already a safe,\n+     * null-prohibiting unmodifiable list, in which case the arg itself is returned.\n+     * Null argument or null elements in the argument will result in NPE.\n+     *\n+     * @param <E> the List's element type\n+     * @param input the input array\n+     * @return the new list\n+     *\/\n@@ -157,1 +169,1 @@\n-        if (coll instanceof AbstractImmutableList && coll.getClass() != SubList.class) {\n+        if (coll instanceof List12 || (coll instanceof ListN && ! ((ListN<?>)coll).allowNulls)) {\n@@ -160,1 +172,74 @@\n-            return (List<E>)List.of(coll.toArray());\n+            return (List<E>)List.of(coll.toArray()); \/\/ implicit nullcheck of coll\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new List from an untrusted array, creating a new array for internal\n+     * storage, and checking for and rejecting null elements.\n+     *\n+     * @param <E> the List's element type\n+     * @param input the input array\n+     * @return the new list\n+     *\/\n+    @SafeVarargs\n+    static <E> List<E> listFromArray(E... input) {\n+        \/\/ copy and check manually to avoid TOCTOU\n+        @SuppressWarnings(\"unchecked\")\n+        E[] tmp = (E[])new Object[input.length]; \/\/ implicit nullcheck of input\n+        for (int i = 0; i < input.length; i++) {\n+            tmp[i] = Objects.requireNonNull(input[i]);\n+        }\n+        return new ListN<>(tmp, false);\n+    }\n+\n+    \/**\n+     * Creates a new List from a trusted array, checking for and rejecting null\n+     * elements.\n+     *\n+     * <p>A trusted array has no references retained by the caller. It can therefore be\n+     * safely reused as the List's internal storage, avoiding a defensive copy. The array's\n+     * class must be Object[].class. This method is declared with a parameter type of\n+     * Object... instead of E... so that a varargs call doesn't accidentally create an array\n+     * of some class other than Object[].class.\n+     *\n+     * @param <E> the List's element type\n+     * @param input the input array\n+     * @return the new list\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <E> List<E> listFromTrustedArray(Object... input) {\n+        assert input.getClass() == Object[].class;\n+        for (Object o : input) { \/\/ implicit null check of 'input' array\n+            Objects.requireNonNull(o);\n+        }\n+\n+        return switch (input.length) {\n+            case 0  -> (List<E>) ImmutableCollections.EMPTY_LIST;\n+            case 1  -> (List<E>) new List12<>(input[0]);\n+            case 2  -> (List<E>) new List12<>(input[0], input[1]);\n+            default -> (List<E>) new ListN<>(input, false);\n+        };\n+    }\n+\n+    \/**\n+     * Creates a new List from a trusted array, allowing null elements.\n+     *\n+     * <p>A trusted array has no references retained by the caller. It can therefore be\n+     * safely reused as the List's internal storage, avoiding a defensive copy. The array's\n+     * class must be Object[].class. This method is declared with a parameter type of\n+     * Object... instead of E... so that a varargs call doesn't accidentally create an array\n+     * of some class other than Object[].class.\n+     *\n+     * <p>Avoids creating a List12 instance, as it cannot accommodate null elements.\n+     *\n+     * @param <E> the List's element type\n+     * @param input the input array\n+     * @return the new list\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <E> List<E> listFromTrustedArrayNullsAllowed(Object... input) {\n+        assert input.getClass() == Object[].class;\n+        if (input.length == 0) {\n+            return (List<E>) EMPTY_LIST_NULLS;\n+        } else {\n+            return new ListN<>((E[])input, true);\n@@ -164,0 +249,2 @@\n+    \/\/ ---------- List Implementations ----------\n+\n@@ -224,1 +311,1 @@\n-                if (!oit.hasNext() || !get(i).equals(oit.next())) {\n+                if (!oit.hasNext() || !Objects.equals(get(i), oit.next())) {\n@@ -231,22 +318,0 @@\n-        @Override\n-        public int indexOf(Object o) {\n-            Objects.requireNonNull(o);\n-            for (int i = 0, s = size(); i < s; i++) {\n-                if (o.equals(get(i))) {\n-                    return i;\n-                }\n-            }\n-            return -1;\n-        }\n-\n-        @Override\n-        public int lastIndexOf(Object o) {\n-            Objects.requireNonNull(o);\n-            for (int i = size() - 1; i >= 0; i--) {\n-                if (o.equals(get(i))) {\n-                    return i;\n-                }\n-            }\n-            return -1;\n-        }\n-\n@@ -257,1 +322,1 @@\n-                hash = 31 * hash + get(i).hashCode();\n+                hash = 31 * hash + Objects.hashCode(get(i));\n@@ -366,1 +431,1 @@\n-        private final List<E> root;\n+        private final AbstractImmutableList<E> root;\n@@ -374,1 +439,2 @@\n-        private SubList(List<E> root, int offset, int size) {\n+        private SubList(AbstractImmutableList<E> root, int offset, int size) {\n+            assert root instanceof List12 || root instanceof ListN;\n@@ -391,1 +457,1 @@\n-        static <E> SubList<E> fromList(List<E> list, int fromIndex, int toIndex) {\n+        static <E> SubList<E> fromList(AbstractImmutableList<E> list, int fromIndex, int toIndex) {\n@@ -424,0 +490,30 @@\n+        private boolean allowNulls() {\n+            return root instanceof ListN && ((ListN<?>)root).allowNulls;\n+        }\n+\n+        @Override\n+        public int indexOf(Object o) {\n+            if (!allowNulls() && o == null) {\n+                throw new NullPointerException();\n+            }\n+            for (int i = 0, s = size(); i < s; i++) {\n+                if (Objects.equals(o, get(i))) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object o) {\n+            if (!allowNulls() && o == null) {\n+                throw new NullPointerException();\n+            }\n+            for (int i = size() - 1; i >= 0; i--) {\n+                if (Objects.equals(o, get(i))) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n@@ -462,1 +558,1 @@\n-            \/\/ enable constant folding optimizations over single-element lists\n+            \/\/ enables constant folding optimizations over single-element lists\n@@ -492,0 +588,24 @@\n+        @Override\n+        public int indexOf(Object o) {\n+            Objects.requireNonNull(o);\n+            if (o.equals(e0)) {\n+                return 0;\n+            } else if (e1 != EMPTY && o.equals(e1)) {\n+                return 1;\n+            } else {\n+                return -1;\n+            }\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object o) {\n+            Objects.requireNonNull(o);\n+            if (e1 != EMPTY && o.equals(e1)) {\n+                return 1;\n+            } else if (o.equals(e0)) {\n+                return 0;\n+            } else {\n+                return -1;\n+            }\n+        }\n+\n@@ -539,3 +659,2 @@\n-        private ListN(E[] array) {\n-            elements = array;\n-        }\n+        @Stable\n+        private final boolean allowNulls;\n@@ -543,21 +662,4 @@\n-        \/\/ creates a new internal array, and checks and rejects null elements\n-        @SafeVarargs\n-        static <E> List<E> fromArray(E... input) {\n-            \/\/ copy and check manually to avoid TOCTOU\n-            @SuppressWarnings(\"unchecked\")\n-            E[] tmp = (E[])new Object[input.length]; \/\/ implicit nullcheck of input\n-            for (int i = 0; i < input.length; i++) {\n-                tmp[i] = Objects.requireNonNull(input[i]);\n-            }\n-            return new ListN<>(tmp);\n-        }\n-\n-        \/\/ Avoids creating a new array, but checks and rejects null elements.\n-        \/\/ Declared with Object... arg so that varargs calls don't accidentally\n-        \/\/ create an array of a subtype.\n-        @SuppressWarnings(\"unchecked\")\n-        static <E> List<E> fromTrustedArray(Object... input) {\n-            for (Object o : input) {\n-                Objects.requireNonNull(o);\n-            }\n-            return new ListN<>((E[])input);\n+        \/\/ caller must ensure that elements has no nulls if allowNulls is false\n+        private ListN(E[] elements, boolean allowNulls) {\n+            this.elements = elements;\n+            this.allowNulls = allowNulls;\n@@ -588,1 +690,1 @@\n-            return new CollSer(CollSer.IMM_LIST, elements);\n+            return new CollSer(allowNulls ? CollSer.IMM_LIST_NULLS : CollSer.IMM_LIST, elements);\n@@ -610,0 +712,28 @@\n+\n+        @Override\n+        public int indexOf(Object o) {\n+            if (!allowNulls && o == null) {\n+                throw new NullPointerException();\n+            }\n+            Object[] es = elements;\n+            for (int i = 0; i < es.length; i++) {\n+                if (Objects.equals(o, es[i])) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object o) {\n+            if (!allowNulls && o == null) {\n+                throw new NullPointerException();\n+            }\n+            Object[] es = elements;\n+            for (int i = es.length - 1; i >= 0; i--) {\n+                if (Objects.equals(o, es[i])) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n@@ -1238,3 +1368,4 @@\n-    static final int IMM_LIST = 1;\n-    static final int IMM_SET = 2;\n-    static final int IMM_MAP = 3;\n+    static final int IMM_LIST       = 1;\n+    static final int IMM_SET        = 2;\n+    static final int IMM_MAP        = 3;\n+    static final int IMM_LIST_NULLS = 4;\n@@ -1245,2 +1376,5 @@\n-     * {@code List}, 2 for an immutable {@code Set}, and 3 for\n-     * an immutable {@code Map}. Any other value causes an\n+     * {@code List}, 2 for an immutable {@code Set}, 3 for\n+     * an immutable {@code Map}, and 4 for an immutable\n+     * {@code List} that allows null elements.\n+     *\n+     * Any other value causes an\n@@ -1353,1 +1487,1 @@\n-   @java.io.Serial\n+    @java.io.Serial\n@@ -1365,0 +1499,3 @@\n+                case IMM_LIST_NULLS:\n+                    return ImmutableCollections.listFromTrustedArrayNullsAllowed(\n+                            Arrays.copyOf(array, array.length, Object[].class));\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":208,"deletions":71,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -847,1 +847,1 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3);\n@@ -866,1 +866,1 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4);\n@@ -886,1 +886,1 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5);\n@@ -907,2 +907,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6);\n@@ -930,2 +930,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6, e7);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6, e7);\n@@ -954,2 +954,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6, e7, e8);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6, e7, e8);\n@@ -979,2 +979,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6, e7, e8, e9);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6, e7, e8, e9);\n@@ -1005,2 +1005,2 @@\n-        return ImmutableCollections.ListN.fromTrustedArray(e1, e2, e3, e4, e5,\n-                                                           e6, e7, e8, e9, e10);\n+        return ImmutableCollections.listFromTrustedArray(e1, e2, e3, e4, e5,\n+                                                         e6, e7, e8, e9, e10);\n@@ -1047,1 +1047,1 @@\n-                return ImmutableCollections.ListN.fromArray(elements);\n+                return ImmutableCollections.listFromArray(elements);\n","filename":"src\/java.base\/share\/classes\/java\/util\/List.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+        allowRecords = Feature.RECORDS.allowedInSource(source);\n@@ -210,0 +211,4 @@\n+    \/** Are records allowed\n+     *\/\n+    private final boolean allowRecords;\n+\n@@ -5327,3 +5332,4 @@\n-            if (c.owner.kind != PCK &&\n-                ((c.flags() & STATIC) == 0 || c.name == names.empty) &&\n-                (TreeInfo.flags(l.head) & (STATIC | INTERFACE)) != 0) {\n+            if (!allowRecords &&\n+                    c.owner.kind != PCK &&\n+                    ((c.flags() & STATIC) == 0 || c.name == names.empty) &&\n+                    (TreeInfo.flags(l.head) & (STATIC | INTERFACE)) != 0) {\n@@ -5333,2 +5339,2 @@\n-                    sym.kind != VAR ||\n-                    ((VarSymbol) sym).getConstValue() == null)\n+                        sym.kind != VAR ||\n+                        ((VarSymbol) sym).getConstValue() == null)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/GroupLayout.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.stream.Collectors;\n@@ -85,0 +86,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n@@ -406,0 +410,1 @@\n+        Objects.requireNonNull(carrier);\n@@ -437,0 +442,1 @@\n+        Objects.requireNonNull(op);\n@@ -443,0 +449,1 @@\n+        Objects.requireNonNull(elements);\n@@ -444,1 +451,1 @@\n-            LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)e;\n+            LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)Objects.requireNonNull(e);\n@@ -470,0 +477,3 @@\n+     * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+     * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+     *\n@@ -489,1 +499,0 @@\n-         * @throws NullPointerException if the specified group element name is {@code null}.\n@@ -610,0 +619,1 @@\n+        Objects.requireNonNull(order);\n@@ -625,1 +635,1 @@\n-        return new SequenceLayout(size, elementLayout);\n+        return new SequenceLayout(size, Objects.requireNonNull(elementLayout));\n@@ -635,1 +645,1 @@\n-        return new SequenceLayout(OptionalLong.empty(), elementLayout);\n+        return new SequenceLayout(OptionalLong.empty(), Objects.requireNonNull(elementLayout));\n@@ -645,1 +655,5 @@\n-        return new GroupLayout(GroupLayout.Kind.STRUCT, List.of(elements));\n+        Objects.requireNonNull(elements);\n+        return new GroupLayout(GroupLayout.Kind.STRUCT,\n+                Stream.of(elements)\n+                        .map(Objects::requireNonNull)\n+                        .collect(Collectors.toList()));\n@@ -655,1 +669,5 @@\n-        return new GroupLayout(GroupLayout.Kind.UNION, List.of(elements));\n+        Objects.requireNonNull(elements);\n+        return new GroupLayout(GroupLayout.Kind.UNION,\n+                Stream.of(elements)\n+                        .map(Objects::requireNonNull)\n+                        .collect(Collectors.toList()));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n@@ -326,1 +329,0 @@\n-     * @throws NullPointerException if {@code newBase == null}.\n@@ -370,1 +372,0 @@\n-     * @throws NullPointerException if {@code newBase == null}.\n@@ -434,1 +435,0 @@\n-     * @throws NullPointerException if {@code thread == null}\n@@ -438,0 +438,27 @@\n+    \/**\n+     * Obtains a new confined memory segment backed by the same underlying memory region as this segment, but whose\n+     * temporal bounds are controlled by the provided {@link NativeScope} instance.\n+     * <p>\n+     * This is a <em>terminal operation<\/em>;\n+     * as a side-effect, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n+     * will fail with {@link IllegalStateException}.\n+     * <p>\n+     * The returned segment will feature only {@link MemorySegment#READ} and {@link MemorySegment#WRITE} access modes\n+     * (assuming these were available in the original segment). As such the returned segment cannot be closed directly\n+     * using {@link MemorySegment#close()} - but it will be closed indirectly when this native scope is closed. The\n+     * returned segment will also be confined by the same thread as the provided native scope (see {@link NativeScope#ownerThread()}).\n+     * <p>\n+     * In case where the owner thread of the returned segment differs from that of this segment, write accesses to this\n+     * segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n+     * to the returned segment's contents on the new owner thread.\n+     *\n+     * @param nativeScope the native scope.\n+     * @return a new confined memory segment backed by the same underlying memory region as this segment, but whose life-cycle\n+     * is tied to that of {@code nativeScope}.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.\n+     *\/\n+    MemorySegment handoff(NativeScope nativeScope);\n+\n@@ -694,1 +721,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfByte.fromArray(arr);\n@@ -708,1 +735,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfChar.fromArray(arr);\n@@ -722,1 +749,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfShort.fromArray(arr);\n@@ -736,1 +763,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfInt.fromArray(arr);\n@@ -750,1 +777,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfFloat.fromArray(arr);\n@@ -764,1 +791,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfLong.fromArray(arr);\n@@ -778,1 +805,1 @@\n-        return HeapMemorySegmentImpl.makeArraySegment(arr);\n+        return HeapMemorySegmentImpl.OfDouble.fromArray(arr);\n@@ -798,0 +825,1 @@\n+        Objects.requireNonNull(layout);\n@@ -949,1 +977,1 @@\n-     * (see {@link #handoff(Thread)}).\n+     * (see {@link #handoff(NativeScope)} and {@link #handoff(Thread)}).\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/PaddingLayout.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,0 +64,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n@@ -141,1 +144,0 @@\n-     * @throws NullPointerException if {@code elementCounts == null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SequenceLayout.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n@@ -81,1 +84,1 @@\n-        return new ValueLayout(order, bitSize(), alignment, attributes);\n+        return new ValueLayout(Objects.requireNonNull(order), bitSize(), alignment, attributes);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}