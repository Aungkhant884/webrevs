{"files":[{"patch":"@@ -670,0 +670,1 @@\n+36b29df125dc88f11657ce93b4998aa9ff5f5d41 jdk-16+14\n","filename":".hgtags","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,22 +1,0 @@\n-;\n-; Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n-; DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-;\n-; This code is free software; you can redistribute it and\/or modify it\n-; under the terms of the GNU General Public License version 2 only, as\n-; published by the Free Software Foundation.\n-;\n-; This code is distributed in the hope that it will be useful, but WITHOUT\n-; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; version 2 for more details (a copy is included in the LICENSE file that\n-; accompanied this code).\n-;\n-; You should have received a copy of the GNU General Public License version\n-; 2 along with this work; if not, write to the Free Software Foundation,\n-; Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-;\n-; Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-; or visit www.oracle.com if you need additional information or have any\n-; questions.\n-;\n@@ -28,1 +6,1 @@\n-error=author,committer,whitespace,executable\n+error=author,committer,merge,executable,symlink,hg-tag,whitespace\n@@ -34,0 +12,4 @@\n+[repository]\n+tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\\\.(?:0|[1-9][0-9]*)){0,4})(?:\\\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\\\d{1,3})?-(?:(?:b\\\\d{2,3})|(?:ga)))|(?:hs\\\\d\\\\d(?:\\\\.\\\\d{1,2})?-b\\\\d\\\\d)\n+branches=lworld\n+\n@@ -35,1 +17,10 @@\n-files=.*\\.java$|.*\\.cpp$|.*\\.hpp$|.*\\.c$|.*\\.h$\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java\n+\n+[checks \"merge\"]\n+message=Merge jdk\n+\n+[checks \"committer\"]\n+role=committer\n+\n+[checks \"issues\"]\n+pattern=^([124-8][0-9]{6}): (\\S.*)$\n","filename":".jcheck\/conf","additions":15,"deletions":24,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-\/\/   r8-r9 invisible to the allocator (so we can use them as scratch regs)\n+\/\/   r8-r9 non-allocatable (so we can use them as scratch regs)\n@@ -97,0 +97,4 @@\n+reg_def R8      ( NS,  SOC, Op_RegI,  8, r8->as_VMReg()         ); \/\/ rscratch1, non-allocatable\n+reg_def R8_H    ( NS,  SOC, Op_RegI,  8, r8->as_VMReg()->next() );\n+reg_def R9      ( NS,  SOC, Op_RegI,  9, r9->as_VMReg()         ); \/\/ rscratch2, non-allocatable\n+reg_def R9_H    ( NS,  SOC, Op_RegI,  9, r9->as_VMReg()->next() );\n@@ -143,1 +147,1 @@\n-\/\/ Float\/Double Registers\n+\/\/ Float\/Double\/Vector Registers\n@@ -164,159 +168,318 @@\n-  reg_def V0   ( SOC, SOC, Op_RegF,  0, v0->as_VMReg()          );\n-  reg_def V0_H ( SOC, SOC, Op_RegF,  0, v0->as_VMReg()->next()  );\n-  reg_def V0_J ( SOC, SOC, Op_RegF,  0, v0->as_VMReg()->next(2) );\n-  reg_def V0_K ( SOC, SOC, Op_RegF,  0, v0->as_VMReg()->next(3) );\n-\n-  reg_def V1   ( SOC, SOC, Op_RegF,  1, v1->as_VMReg()          );\n-  reg_def V1_H ( SOC, SOC, Op_RegF,  1, v1->as_VMReg()->next()  );\n-  reg_def V1_J ( SOC, SOC, Op_RegF,  1, v1->as_VMReg()->next(2) );\n-  reg_def V1_K ( SOC, SOC, Op_RegF,  1, v1->as_VMReg()->next(3) );\n-\n-  reg_def V2   ( SOC, SOC, Op_RegF,  2, v2->as_VMReg()          );\n-  reg_def V2_H ( SOC, SOC, Op_RegF,  2, v2->as_VMReg()->next()  );\n-  reg_def V2_J ( SOC, SOC, Op_RegF,  2, v2->as_VMReg()->next(2) );\n-  reg_def V2_K ( SOC, SOC, Op_RegF,  2, v2->as_VMReg()->next(3) );\n-\n-  reg_def V3   ( SOC, SOC, Op_RegF,  3, v3->as_VMReg()          );\n-  reg_def V3_H ( SOC, SOC, Op_RegF,  3, v3->as_VMReg()->next()  );\n-  reg_def V3_J ( SOC, SOC, Op_RegF,  3, v3->as_VMReg()->next(2) );\n-  reg_def V3_K ( SOC, SOC, Op_RegF,  3, v3->as_VMReg()->next(3) );\n-\n-  reg_def V4   ( SOC, SOC, Op_RegF,  4, v4->as_VMReg()          );\n-  reg_def V4_H ( SOC, SOC, Op_RegF,  4, v4->as_VMReg()->next()  );\n-  reg_def V4_J ( SOC, SOC, Op_RegF,  4, v4->as_VMReg()->next(2) );\n-  reg_def V4_K ( SOC, SOC, Op_RegF,  4, v4->as_VMReg()->next(3) );\n-\n-  reg_def V5   ( SOC, SOC, Op_RegF,  5, v5->as_VMReg()          );\n-  reg_def V5_H ( SOC, SOC, Op_RegF,  5, v5->as_VMReg()->next()  );\n-  reg_def V5_J ( SOC, SOC, Op_RegF,  5, v5->as_VMReg()->next(2) );\n-  reg_def V5_K ( SOC, SOC, Op_RegF,  5, v5->as_VMReg()->next(3) );\n-\n-  reg_def V6   ( SOC, SOC, Op_RegF,  6, v6->as_VMReg()          );\n-  reg_def V6_H ( SOC, SOC, Op_RegF,  6, v6->as_VMReg()->next()  );\n-  reg_def V6_J ( SOC, SOC, Op_RegF,  6, v6->as_VMReg()->next(2) );\n-  reg_def V6_K ( SOC, SOC, Op_RegF,  6, v6->as_VMReg()->next(3) );\n-\n-  reg_def V7   ( SOC, SOC, Op_RegF,  7, v7->as_VMReg()          );\n-  reg_def V7_H ( SOC, SOC, Op_RegF,  7, v7->as_VMReg()->next()  );\n-  reg_def V7_J ( SOC, SOC, Op_RegF,  7, v7->as_VMReg()->next(2) );\n-  reg_def V7_K ( SOC, SOC, Op_RegF,  7, v7->as_VMReg()->next(3) );\n-\n-  reg_def V8   ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()          );\n-  reg_def V8_H ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()->next()  );\n-  reg_def V8_J ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()->next(2) );\n-  reg_def V8_K ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()->next(3) );\n-\n-  reg_def V9   ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()          );\n-  reg_def V9_H ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()->next()  );\n-  reg_def V9_J ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()->next(2) );\n-  reg_def V9_K ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()->next(3) );\n-\n-  reg_def V10  ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()         );\n-  reg_def V10_H( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next() );\n-  reg_def V10_J( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(2));\n-  reg_def V10_K( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(3));\n-\n-  reg_def V11  ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()         );\n-  reg_def V11_H( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next() );\n-  reg_def V11_J( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(2));\n-  reg_def V11_K( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(3));\n-\n-  reg_def V12  ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()         );\n-  reg_def V12_H( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next() );\n-  reg_def V12_J( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(2));\n-  reg_def V12_K( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(3));\n-\n-  reg_def V13  ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()         );\n-  reg_def V13_H( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next() );\n-  reg_def V13_J( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(2));\n-  reg_def V13_K( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(3));\n-\n-  reg_def V14  ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()         );\n-  reg_def V14_H( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next() );\n-  reg_def V14_J( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(2));\n-  reg_def V14_K( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(3));\n-\n-  reg_def V15  ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()         );\n-  reg_def V15_H( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next() );\n-  reg_def V15_J( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(2));\n-  reg_def V15_K( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(3));\n-\n-  reg_def V16  ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()         );\n-  reg_def V16_H( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next() );\n-  reg_def V16_J( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(2));\n-  reg_def V16_K( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(3));\n-\n-  reg_def V17  ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()         );\n-  reg_def V17_H( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next() );\n-  reg_def V17_J( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(2));\n-  reg_def V17_K( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(3));\n-\n-  reg_def V18  ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()         );\n-  reg_def V18_H( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next() );\n-  reg_def V18_J( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(2));\n-  reg_def V18_K( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(3));\n-\n-  reg_def V19  ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()         );\n-  reg_def V19_H( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next() );\n-  reg_def V19_J( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(2));\n-  reg_def V19_K( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(3));\n-\n-  reg_def V20  ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()         );\n-  reg_def V20_H( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next() );\n-  reg_def V20_J( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(2));\n-  reg_def V20_K( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(3));\n-\n-  reg_def V21  ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()         );\n-  reg_def V21_H( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next() );\n-  reg_def V21_J( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(2));\n-  reg_def V21_K( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(3));\n-\n-  reg_def V22  ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()         );\n-  reg_def V22_H( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next() );\n-  reg_def V22_J( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(2));\n-  reg_def V22_K( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(3));\n-\n-  reg_def V23  ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()         );\n-  reg_def V23_H( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next() );\n-  reg_def V23_J( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(2));\n-  reg_def V23_K( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(3));\n-\n-  reg_def V24  ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()         );\n-  reg_def V24_H( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next() );\n-  reg_def V24_J( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(2));\n-  reg_def V24_K( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(3));\n-\n-  reg_def V25  ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()         );\n-  reg_def V25_H( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next() );\n-  reg_def V25_J( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(2));\n-  reg_def V25_K( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(3));\n-\n-  reg_def V26  ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()         );\n-  reg_def V26_H( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next() );\n-  reg_def V26_J( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(2));\n-  reg_def V26_K( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(3));\n-\n-  reg_def V27  ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()         );\n-  reg_def V27_H( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next() );\n-  reg_def V27_J( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(2));\n-  reg_def V27_K( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(3));\n-\n-  reg_def V28  ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()         );\n-  reg_def V28_H( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next() );\n-  reg_def V28_J( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(2));\n-  reg_def V28_K( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(3));\n-\n-  reg_def V29  ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()         );\n-  reg_def V29_H( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next() );\n-  reg_def V29_J( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(2));\n-  reg_def V29_K( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(3));\n-\n-  reg_def V30  ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()         );\n-  reg_def V30_H( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next() );\n-  reg_def V30_J( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(2));\n-  reg_def V30_K( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(3));\n-\n-  reg_def V31  ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()         );\n-  reg_def V31_H( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next() );\n-  reg_def V31_J( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(2));\n-  reg_def V31_K( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(3));\n+\/\/ For SVE vector registers, we simply extend vector register size to 8\n+\/\/ 'logical' slots. This is nominally 256 bits but it actually covers\n+\/\/ all possible 'physical' SVE vector register lengths from 128 ~ 2048\n+\/\/ bits. The 'physical' SVE vector register length is detected during\n+\/\/ startup, so the register allocator is able to identify the correct\n+\/\/ number of bytes needed for an SVE spill\/unspill.\n+\/\/ Note that a vector register with 4 slots denotes a 128-bit NEON\n+\/\/ register allowing it to be distinguished from the corresponding SVE\n+\/\/ vector register when the SVE vector length is 128 bits.\n+\n+  reg_def V0   ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()          );\n+  reg_def V0_H ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next()  );\n+  reg_def V0_J ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(2) );\n+  reg_def V0_K ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(3) );\n+  reg_def V0_L ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(4) );\n+  reg_def V0_M ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(5) );\n+  reg_def V0_N ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(6) );\n+  reg_def V0_O ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(7) );\n+\n+  reg_def V1   ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()          );\n+  reg_def V1_H ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next()  );\n+  reg_def V1_J ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(2) );\n+  reg_def V1_K ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(3) );\n+  reg_def V1_L ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(4) );\n+  reg_def V1_M ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(5) );\n+  reg_def V1_N ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(6) );\n+  reg_def V1_O ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(7) );\n+\n+  reg_def V2   ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()          );\n+  reg_def V2_H ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next()  );\n+  reg_def V2_J ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(2) );\n+  reg_def V2_K ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(3) );\n+  reg_def V2_L ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(4) );\n+  reg_def V2_M ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(5) );\n+  reg_def V2_N ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(6) );\n+  reg_def V2_O ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(7) );\n+\n+  reg_def V3   ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()          );\n+  reg_def V3_H ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next()  );\n+  reg_def V3_J ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(2) );\n+  reg_def V3_K ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(3) );\n+  reg_def V3_L ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(4) );\n+  reg_def V3_M ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(5) );\n+  reg_def V3_N ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(6) );\n+  reg_def V3_O ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(7) );\n+\n+  reg_def V4   ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()          );\n+  reg_def V4_H ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next()  );\n+  reg_def V4_J ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(2) );\n+  reg_def V4_K ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(3) );\n+  reg_def V4_L ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(4) );\n+  reg_def V4_M ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(5) );\n+  reg_def V4_N ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(6) );\n+  reg_def V4_O ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(7) );\n+\n+  reg_def V5   ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()          );\n+  reg_def V5_H ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next()  );\n+  reg_def V5_J ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(2) );\n+  reg_def V5_K ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(3) );\n+  reg_def V5_L ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(4) );\n+  reg_def V5_M ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(5) );\n+  reg_def V5_N ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(6) );\n+  reg_def V5_O ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(7) );\n+\n+  reg_def V6   ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()          );\n+  reg_def V6_H ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next()  );\n+  reg_def V6_J ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(2) );\n+  reg_def V6_K ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(3) );\n+  reg_def V6_L ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(4) );\n+  reg_def V6_M ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(5) );\n+  reg_def V6_N ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(6) );\n+  reg_def V6_O ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(7) );\n+\n+  reg_def V7   ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()          );\n+  reg_def V7_H ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next()  );\n+  reg_def V7_J ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(2) );\n+  reg_def V7_K ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(3) );\n+  reg_def V7_L ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(4) );\n+  reg_def V7_M ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(5) );\n+  reg_def V7_N ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(6) );\n+  reg_def V7_O ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(7) );\n+\n+  reg_def V8   ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()          );\n+  reg_def V8_H ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next()  );\n+  reg_def V8_J ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(2) );\n+  reg_def V8_K ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(3) );\n+  reg_def V8_L ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(4) );\n+  reg_def V8_M ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(5) );\n+  reg_def V8_N ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(6) );\n+  reg_def V8_O ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(7) );\n+\n+  reg_def V9   ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()          );\n+  reg_def V9_H ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next()  );\n+  reg_def V9_J ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(2) );\n+  reg_def V9_K ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(3) );\n+  reg_def V9_L ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(4) );\n+  reg_def V9_M ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(5) );\n+  reg_def V9_N ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(6) );\n+  reg_def V9_O ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(7) );\n+\n+  reg_def V10   ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()          );\n+  reg_def V10_H ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next()  );\n+  reg_def V10_J ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(2) );\n+  reg_def V10_K ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(3) );\n+  reg_def V10_L ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(4) );\n+  reg_def V10_M ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(5) );\n+  reg_def V10_N ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(6) );\n+  reg_def V10_O ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(7) );\n+\n+  reg_def V11   ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()          );\n+  reg_def V11_H ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next()  );\n+  reg_def V11_J ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(2) );\n+  reg_def V11_K ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(3) );\n+  reg_def V11_L ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(4) );\n+  reg_def V11_M ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(5) );\n+  reg_def V11_N ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(6) );\n+  reg_def V11_O ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(7) );\n+\n+  reg_def V12   ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()          );\n+  reg_def V12_H ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next()  );\n+  reg_def V12_J ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(2) );\n+  reg_def V12_K ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(3) );\n+  reg_def V12_L ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(4) );\n+  reg_def V12_M ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(5) );\n+  reg_def V12_N ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(6) );\n+  reg_def V12_O ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(7) );\n+\n+  reg_def V13   ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()          );\n+  reg_def V13_H ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next()  );\n+  reg_def V13_J ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(2) );\n+  reg_def V13_K ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(3) );\n+  reg_def V13_L ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(4) );\n+  reg_def V13_M ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(5) );\n+  reg_def V13_N ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(6) );\n+  reg_def V13_O ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(7) );\n+\n+  reg_def V14   ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()          );\n+  reg_def V14_H ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next()  );\n+  reg_def V14_J ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(2) );\n+  reg_def V14_K ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(3) );\n+  reg_def V14_L ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(4) );\n+  reg_def V14_M ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(5) );\n+  reg_def V14_N ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(6) );\n+  reg_def V14_O ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(7) );\n+\n+  reg_def V15   ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()          );\n+  reg_def V15_H ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next()  );\n+  reg_def V15_J ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(2) );\n+  reg_def V15_K ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(3) );\n+  reg_def V15_L ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(4) );\n+  reg_def V15_M ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(5) );\n+  reg_def V15_N ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(6) );\n+  reg_def V15_O ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(7) );\n+\n+  reg_def V16   ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()          );\n+  reg_def V16_H ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next()  );\n+  reg_def V16_J ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(2) );\n+  reg_def V16_K ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(3) );\n+  reg_def V16_L ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(4) );\n+  reg_def V16_M ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(5) );\n+  reg_def V16_N ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(6) );\n+  reg_def V16_O ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(7) );\n+\n+  reg_def V17   ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()          );\n+  reg_def V17_H ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next()  );\n+  reg_def V17_J ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(2) );\n+  reg_def V17_K ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(3) );\n+  reg_def V17_L ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(4) );\n+  reg_def V17_M ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(5) );\n+  reg_def V17_N ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(6) );\n+  reg_def V17_O ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(7) );\n+\n+  reg_def V18   ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()          );\n+  reg_def V18_H ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next()  );\n+  reg_def V18_J ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(2) );\n+  reg_def V18_K ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(3) );\n+  reg_def V18_L ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(4) );\n+  reg_def V18_M ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(5) );\n+  reg_def V18_N ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(6) );\n+  reg_def V18_O ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(7) );\n+\n+  reg_def V19   ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()          );\n+  reg_def V19_H ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next()  );\n+  reg_def V19_J ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(2) );\n+  reg_def V19_K ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(3) );\n+  reg_def V19_L ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(4) );\n+  reg_def V19_M ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(5) );\n+  reg_def V19_N ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(6) );\n+  reg_def V19_O ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(7) );\n+\n+  reg_def V20   ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()          );\n+  reg_def V20_H ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next()  );\n+  reg_def V20_J ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(2) );\n+  reg_def V20_K ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(3) );\n+  reg_def V20_L ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(4) );\n+  reg_def V20_M ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(5) );\n+  reg_def V20_N ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(6) );\n+  reg_def V20_O ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(7) );\n+\n+  reg_def V21   ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()          );\n+  reg_def V21_H ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next()  );\n+  reg_def V21_J ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(2) );\n+  reg_def V21_K ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(3) );\n+  reg_def V21_L ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(4) );\n+  reg_def V21_M ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(5) );\n+  reg_def V21_N ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(6) );\n+  reg_def V21_O ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(7) );\n+\n+  reg_def V22   ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()          );\n+  reg_def V22_H ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next()  );\n+  reg_def V22_J ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(2) );\n+  reg_def V22_K ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(3) );\n+  reg_def V22_L ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(4) );\n+  reg_def V22_M ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(5) );\n+  reg_def V22_N ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(6) );\n+  reg_def V22_O ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(7) );\n+\n+  reg_def V23   ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()          );\n+  reg_def V23_H ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next()  );\n+  reg_def V23_J ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(2) );\n+  reg_def V23_K ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(3) );\n+  reg_def V23_L ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(4) );\n+  reg_def V23_M ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(5) );\n+  reg_def V23_N ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(6) );\n+  reg_def V23_O ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(7) );\n+\n+  reg_def V24   ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()          );\n+  reg_def V24_H ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next()  );\n+  reg_def V24_J ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(2) );\n+  reg_def V24_K ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(3) );\n+  reg_def V24_L ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(4) );\n+  reg_def V24_M ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(5) );\n+  reg_def V24_N ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(6) );\n+  reg_def V24_O ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(7) );\n+\n+  reg_def V25   ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()          );\n+  reg_def V25_H ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next()  );\n+  reg_def V25_J ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(2) );\n+  reg_def V25_K ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(3) );\n+  reg_def V25_L ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(4) );\n+  reg_def V25_M ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(5) );\n+  reg_def V25_N ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(6) );\n+  reg_def V25_O ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(7) );\n+\n+  reg_def V26   ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()          );\n+  reg_def V26_H ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next()  );\n+  reg_def V26_J ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(2) );\n+  reg_def V26_K ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(3) );\n+  reg_def V26_L ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(4) );\n+  reg_def V26_M ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(5) );\n+  reg_def V26_N ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(6) );\n+  reg_def V26_O ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(7) );\n+\n+  reg_def V27   ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()          );\n+  reg_def V27_H ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next()  );\n+  reg_def V27_J ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(2) );\n+  reg_def V27_K ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(3) );\n+  reg_def V27_L ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(4) );\n+  reg_def V27_M ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(5) );\n+  reg_def V27_N ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(6) );\n+  reg_def V27_O ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(7) );\n+\n+  reg_def V28   ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()          );\n+  reg_def V28_H ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next()  );\n+  reg_def V28_J ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(2) );\n+  reg_def V28_K ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(3) );\n+  reg_def V28_L ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(4) );\n+  reg_def V28_M ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(5) );\n+  reg_def V28_N ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(6) );\n+  reg_def V28_O ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(7) );\n+\n+  reg_def V29   ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()          );\n+  reg_def V29_H ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next()  );\n+  reg_def V29_J ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(2) );\n+  reg_def V29_K ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(3) );\n+  reg_def V29_L ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(4) );\n+  reg_def V29_M ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(5) );\n+  reg_def V29_N ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(6) );\n+  reg_def V29_O ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(7) );\n+\n+  reg_def V30   ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()          );\n+  reg_def V30_H ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next()  );\n+  reg_def V30_J ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(2) );\n+  reg_def V30_K ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(3) );\n+  reg_def V30_L ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(4) );\n+  reg_def V30_M ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(5) );\n+  reg_def V30_N ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(6) );\n+  reg_def V30_O ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(7) );\n+\n+  reg_def V31   ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()          );\n+  reg_def V31_H ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next()  );\n+  reg_def V31_J ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(2) );\n+  reg_def V31_K ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(3) );\n+  reg_def V31_L ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(4) );\n+  reg_def V31_M ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(5) );\n+  reg_def V31_N ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(6) );\n+  reg_def V31_O ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(7) );\n+\n+\n+\/\/ ----------------------------\n+\/\/ SVE Predicate Registers\n+\/\/ ----------------------------\n+  reg_def P0 (SOC, SOC, Op_RegVMask, 0, p0->as_VMReg());\n+  reg_def P1 (SOC, SOC, Op_RegVMask, 1, p1->as_VMReg());\n+  reg_def P2 (SOC, SOC, Op_RegVMask, 2, p2->as_VMReg());\n+  reg_def P3 (SOC, SOC, Op_RegVMask, 3, p3->as_VMReg());\n+  reg_def P4 (SOC, SOC, Op_RegVMask, 4, p4->as_VMReg());\n+  reg_def P5 (SOC, SOC, Op_RegVMask, 5, p5->as_VMReg());\n+  reg_def P6 (SOC, SOC, Op_RegVMask, 6, p6->as_VMReg());\n+  reg_def P7 (SOC, SOC, Op_RegVMask, 7, p7->as_VMReg());\n+  reg_def P8 (SOC, SOC, Op_RegVMask, 8, p8->as_VMReg());\n+  reg_def P9 (SOC, SOC, Op_RegVMask, 9, p9->as_VMReg());\n+  reg_def P10 (SOC, SOC, Op_RegVMask, 10, p10->as_VMReg());\n+  reg_def P11 (SOC, SOC, Op_RegVMask, 11, p11->as_VMReg());\n+  reg_def P12 (SOC, SOC, Op_RegVMask, 12, p12->as_VMReg());\n+  reg_def P13 (SOC, SOC, Op_RegVMask, 13, p13->as_VMReg());\n+  reg_def P14 (SOC, SOC, Op_RegVMask, 14, p14->as_VMReg());\n+  reg_def P15 (SOC, SOC, Op_RegVMask, 15, p15->as_VMReg());\n@@ -336,1 +499,0 @@\n-\n@@ -384,0 +546,2 @@\n+    R8, R8_H,   \/\/ rscratch1\n+    R9, R9_H,   \/\/ rscratch2\n@@ -389,16 +553,16 @@\n-    V16, V16_H, V16_J, V16_K,\n-    V17, V17_H, V17_J, V17_K,\n-    V18, V18_H, V18_J, V18_K,\n-    V19, V19_H, V19_J, V19_K,\n-    V20, V20_H, V20_J, V20_K,\n-    V21, V21_H, V21_J, V21_K,\n-    V22, V22_H, V22_J, V22_K,\n-    V23, V23_H, V23_J, V23_K,\n-    V24, V24_H, V24_J, V24_K,\n-    V25, V25_H, V25_J, V25_K,\n-    V26, V26_H, V26_J, V26_K,\n-    V27, V27_H, V27_J, V27_K,\n-    V28, V28_H, V28_J, V28_K,\n-    V29, V29_H, V29_J, V29_K,\n-    V30, V30_H, V30_J, V30_K,\n-    V31, V31_H, V31_J, V31_K,\n+    V16, V16_H, V16_J, V16_K, V16_L, V16_M, V16_N, V16_O,\n+    V17, V17_H, V17_J, V17_K, V17_L, V17_M, V17_N, V17_O,\n+    V18, V18_H, V18_J, V18_K, V18_L, V18_M, V18_N, V18_O,\n+    V19, V19_H, V19_J, V19_K, V19_L, V19_M, V19_N, V19_O,\n+    V20, V20_H, V20_J, V20_K, V20_L, V20_M, V20_N, V20_O,\n+    V21, V21_H, V21_J, V21_K, V21_L, V21_M, V21_N, V21_O,\n+    V22, V22_H, V22_J, V22_K, V22_L, V22_M, V22_N, V22_O,\n+    V23, V23_H, V23_J, V23_K, V23_L, V23_M, V23_N, V23_O,\n+    V24, V24_H, V24_J, V24_K, V24_L, V24_M, V24_N, V24_O,\n+    V25, V25_H, V25_J, V25_K, V25_L, V25_M, V25_N, V25_O,\n+    V26, V26_H, V26_J, V26_K, V26_L, V26_M, V26_N, V26_O,\n+    V27, V27_H, V27_J, V27_K, V27_L, V27_M, V27_N, V27_O,\n+    V28, V28_H, V28_J, V28_K, V28_L, V28_M, V28_N, V28_O,\n+    V29, V29_H, V29_J, V29_K, V29_L, V29_M, V29_N, V29_O,\n+    V30, V30_H, V30_J, V30_K, V30_L, V30_M, V30_N, V30_O,\n+    V31, V31_H, V31_J, V31_K, V31_L, V31_M, V31_N, V31_O,\n@@ -407,8 +571,8 @@\n-    V0, V0_H, V0_J, V0_K,\n-    V1, V1_H, V1_J, V1_K,\n-    V2, V2_H, V2_J, V2_K,\n-    V3, V3_H, V3_J, V3_K,\n-    V4, V4_H, V4_J, V4_K,\n-    V5, V5_H, V5_J, V5_K,\n-    V6, V6_H, V6_J, V6_K,\n-    V7, V7_H, V7_J, V7_K,\n+    V0, V0_H, V0_J, V0_K, V0_L, V0_M, V0_N, V0_O,\n+    V1, V1_H, V1_J, V1_K, V1_L, V1_M, V1_N, V1_O,\n+    V2, V2_H, V2_J, V2_K, V2_L, V2_M, V2_N, V2_O,\n+    V3, V3_H, V3_J, V3_K, V3_L, V3_M, V3_N, V3_O,\n+    V4, V4_H, V4_J, V4_K, V4_L, V4_M, V4_N, V4_O,\n+    V5, V5_H, V5_J, V5_K, V5_L, V5_M, V5_N, V5_O,\n+    V6, V6_H, V6_J, V6_K, V6_L, V6_M, V6_N, V6_O,\n+    V7, V7_H, V7_J, V7_K, V7_L, V7_M, V7_N, V7_O,\n@@ -417,8 +581,8 @@\n-    V8, V8_H, V8_J, V8_K,\n-    V9, V9_H, V9_J, V9_K,\n-    V10, V10_H, V10_J, V10_K,\n-    V11, V11_H, V11_J, V11_K,\n-    V12, V12_H, V12_J, V12_K,\n-    V13, V13_H, V13_J, V13_K,\n-    V14, V14_H, V14_J, V14_K,\n-    V15, V15_H, V15_J, V15_K,\n+    V8, V8_H, V8_J, V8_K, V8_L, V8_M, V8_N, V8_O,\n+    V9, V9_H, V9_J, V9_K, V9_L, V9_M, V9_N, V9_O,\n+    V10, V10_H, V10_J, V10_K, V10_L, V10_M, V10_N, V10_O,\n+    V11, V11_H, V11_J, V11_K, V11_L, V11_M, V11_N, V11_O,\n+    V12, V12_H, V12_J, V12_K, V12_L, V12_M, V12_N, V12_O,\n+    V13, V13_H, V13_J, V13_K, V13_L, V13_M, V13_N, V13_O,\n+    V14, V14_H, V14_J, V14_K, V14_L, V14_M, V14_N, V14_O,\n+    V15, V15_H, V15_J, V15_K, V15_L, V15_M, V15_N, V15_O,\n@@ -427,1 +591,21 @@\n-alloc_class chunk2(RFLAGS);\n+alloc_class chunk2 (\n+    P0,\n+    P1,\n+    P2,\n+    P3,\n+    P4,\n+    P5,\n+    P6,\n+    P7,\n+\n+    P8,\n+    P9,\n+    P10,\n+    P11,\n+    P12,\n+    P13,\n+    P14,\n+    P15,\n+);\n+\n+alloc_class chunk3(RFLAGS);\n@@ -711,0 +895,36 @@\n+\/\/ Class for all SVE vector registers.\n+reg_class vectora_reg (\n+    V0, V0_H, V0_J, V0_K, V0_L, V0_M, V0_N, V0_O,\n+    V1, V1_H, V1_J, V1_K, V1_L, V1_M, V1_N, V1_O,\n+    V2, V2_H, V2_J, V2_K, V2_L, V2_M, V2_N, V2_O,\n+    V3, V3_H, V3_J, V3_K, V3_L, V3_M, V3_N, V3_O,\n+    V4, V4_H, V4_J, V4_K, V4_L, V4_M, V4_N, V4_O,\n+    V5, V5_H, V5_J, V5_K, V5_L, V5_M, V5_N, V5_O,\n+    V6, V6_H, V6_J, V6_K, V6_L, V6_M, V6_N, V6_O,\n+    V7, V7_H, V7_J, V7_K, V7_L, V7_M, V7_N, V7_O,\n+    V8, V8_H, V8_J, V8_K, V8_L, V8_M, V8_N, V8_O,\n+    V9, V9_H, V9_J, V9_K, V9_L, V9_M, V9_N, V9_O,\n+    V10, V10_H, V10_J, V10_K, V10_L, V10_M, V10_N, V10_O,\n+    V11, V11_H, V11_J, V11_K, V11_L, V11_M, V11_N, V11_O,\n+    V12, V12_H, V12_J, V12_K, V12_L, V12_M, V12_N, V12_O,\n+    V13, V13_H, V13_J, V13_K, V13_L, V13_M, V13_N, V13_O,\n+    V14, V14_H, V14_J, V14_K, V14_L, V14_M, V14_N, V14_O,\n+    V15, V15_H, V15_J, V15_K, V15_L, V15_M, V15_N, V15_O,\n+    V16, V16_H, V16_J, V16_K, V16_L, V16_M, V16_N, V16_O,\n+    V17, V17_H, V17_J, V17_K, V17_L, V17_M, V17_N, V17_O,\n+    V18, V18_H, V18_J, V18_K, V18_L, V18_M, V18_N, V18_O,\n+    V19, V19_H, V19_J, V19_K, V19_L, V19_M, V19_N, V19_O,\n+    V20, V20_H, V20_J, V20_K, V20_L, V20_M, V20_N, V20_O,\n+    V21, V21_H, V21_J, V21_K, V21_L, V21_M, V21_N, V21_O,\n+    V22, V22_H, V22_J, V22_K, V22_L, V22_M, V22_N, V22_O,\n+    V23, V23_H, V23_J, V23_K, V23_L, V23_M, V23_N, V23_O,\n+    V24, V24_H, V24_J, V24_K, V24_L, V24_M, V24_N, V24_O,\n+    V25, V25_H, V25_J, V25_K, V25_L, V25_M, V25_N, V25_O,\n+    V26, V26_H, V26_J, V26_K, V26_L, V26_M, V26_N, V26_O,\n+    V27, V27_H, V27_J, V27_K, V27_L, V27_M, V27_N, V27_O,\n+    V28, V28_H, V28_J, V28_K, V28_L, V28_M, V28_N, V28_O,\n+    V29, V29_H, V29_J, V29_K, V29_L, V29_M, V29_N, V29_O,\n+    V30, V30_H, V30_J, V30_K, V30_L, V30_M, V30_N, V30_O,\n+    V31, V31_H, V31_J, V31_K, V31_L, V31_M, V31_N, V31_O,\n+);\n+\n@@ -943,0 +1163,33 @@\n+\/\/ Class for all SVE predicate registers.\n+reg_class pr_reg (\n+    P0,\n+    P1,\n+    P2,\n+    P3,\n+    P4,\n+    P5,\n+    P6,\n+    \/\/ P7, non-allocatable, preserved with all elements preset to TRUE.\n+    P8,\n+    P9,\n+    P10,\n+    P11,\n+    P12,\n+    P13,\n+    P14,\n+    P15\n+);\n+\n+\/\/ Class for SVE governing predicate registers, which are used\n+\/\/ to determine the active elements of a predicated instruction.\n+reg_class gov_pr (\n+    P0,\n+    P1,\n+    P2,\n+    P3,\n+    P4,\n+    P5,\n+    P6,\n+    \/\/ P7, non-allocatable, preserved with all elements preset to TRUE.\n+);\n+\n@@ -1649,0 +1902,4 @@\n+  if (UseSVE > 0 && C->max_vector_size() >= 16) {\n+    __ reinitialize_ptrue();\n+  }\n+\n@@ -1747,1 +2004,1 @@\n-enum RC { rc_bad, rc_int, rc_float, rc_stack };\n+enum RC { rc_bad, rc_int, rc_float, rc_predicate, rc_stack };\n@@ -1755,3 +2012,2 @@\n-  \/\/ we have 30 int registers * 2 halves\n-  \/\/ (rscratch1 and rscratch2 are omitted)\n-  int slots_of_int_registers = RegisterImpl::max_slots_per_register * (RegisterImpl::number_of_registers - 2);\n+  \/\/ we have 32 int registers * 2 halves\n+  int slots_of_int_registers = RegisterImpl::max_slots_per_register * RegisterImpl::number_of_registers;\n@@ -1763,2 +2019,3 @@\n-  \/\/ we have 32 float register * 4 halves\n-  if (reg < slots_of_int_registers + FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers) {\n+  \/\/ we have 32 float register * 8 halves\n+  int slots_of_float_registers = FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers;\n+  if (reg < slots_of_int_registers + slots_of_float_registers) {\n@@ -1768,1 +2025,6 @@\n-  \/\/ Between float regs & stack is the flags regs.\n+  int slots_of_predicate_registers = PRegisterImpl::max_slots_per_register * PRegisterImpl::number_of_registers;\n+  if (reg < slots_of_int_registers + slots_of_float_registers + slots_of_predicate_registers) {\n+    return rc_predicate;\n+  }\n+\n+  \/\/ Between predicate regs & stack is the flags.\n@@ -1807,2 +2069,22 @@\n-    assert(ireg == Op_VecD || ireg == Op_VecX, \"must be 64 bit or 128 bit vector\");\n-    if (cbuf) {\n+    if (ireg == Op_VecA && cbuf) {\n+      C2_MacroAssembler _masm(cbuf);\n+      int sve_vector_reg_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);\n+      if (src_lo_rc == rc_stack && dst_lo_rc == rc_stack) {\n+        \/\/ stack->stack\n+        __ spill_copy_sve_vector_stack_to_stack(src_offset, dst_offset,\n+                                                sve_vector_reg_size_in_bytes);\n+      } else if (src_lo_rc == rc_float && dst_lo_rc == rc_stack) {\n+        __ spill_sve_vector(as_FloatRegister(Matcher::_regEncode[src_lo]), ra_->reg2offset(dst_lo),\n+                            sve_vector_reg_size_in_bytes);\n+      } else if (src_lo_rc == rc_stack && dst_lo_rc == rc_float) {\n+        __ unspill_sve_vector(as_FloatRegister(Matcher::_regEncode[dst_lo]), ra_->reg2offset(src_lo),\n+                              sve_vector_reg_size_in_bytes);\n+      } else if (src_lo_rc == rc_float && dst_lo_rc == rc_float) {\n+        __ sve_orr(as_FloatRegister(Matcher::_regEncode[dst_lo]),\n+                   as_FloatRegister(Matcher::_regEncode[src_lo]),\n+                   as_FloatRegister(Matcher::_regEncode[src_lo]));\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    } else if (cbuf) {\n+      assert(ireg == Op_VecD || ireg == Op_VecX, \"must be 64 bit or 128 bit vector\");\n@@ -1826,2 +2108,2 @@\n-                       ireg == Op_VecD ? __ D : __ Q,\n-                       ra_->reg2offset(dst_lo));\n+                 ireg == Op_VecD ? __ D : __ Q,\n+                 ra_->reg2offset(dst_lo));\n@@ -1830,2 +2112,2 @@\n-                       ireg == Op_VecD ? __ D : __ Q,\n-                       ra_->reg2offset(src_lo));\n+                   ireg == Op_VecD ? __ D : __ Q,\n+                   ra_->reg2offset(src_lo));\n@@ -1916,1 +2198,16 @@\n-      st->print(\"\\t# vector spill size = %d\", ideal_reg()==Op_VecD ? 64:128);\n+      int vsize = 0;\n+      switch (ideal_reg()) {\n+      case Op_VecD:\n+        vsize = 64;\n+        break;\n+      case Op_VecX:\n+        vsize = 128;\n+        break;\n+      case Op_VecA:\n+        vsize = Matcher::scalable_vector_reg_size(T_BYTE) * 8;\n+        break;\n+      default:\n+        assert(false, \"bad register type for spill\");\n+        ShouldNotReachHere();\n+      }\n+      st->print(\"\\t# vector spill size = %d\", vsize);\n@@ -1918,1 +2215,1 @@\n-      st->print(\"\\t# spill size = %d\", is64 ? 64:32);\n+      st->print(\"\\t# spill size = %d\", is64 ? 64 : 32);\n@@ -2124,1 +2421,1 @@\n-  if (!match_rule_supported(opcode)) {\n+  if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen)) {\n@@ -2127,5 +2424,11 @@\n-\n-  \/\/ Special cases which require vector length\n-  switch (opcode) {\n-    case Op_MulAddVS2VI: {\n-      if (vlen != 4) {\n+  int bit_size = vlen * type2aelembytes(bt) * 8;\n+  if (UseSVE == 0 && bit_size > 128) {\n+    return false;\n+  }\n+  if (UseSVE > 0) {\n+    return op_sve_supported(opcode);\n+  } else { \/\/ NEON\n+    \/\/ Special cases\n+    switch (opcode) {\n+    case Op_MulAddVS2VI:\n+      if (bit_size < 128) {\n@@ -2135,0 +2438,4 @@\n+    case Op_MulVL:\n+      return false;\n+    default:\n+      break;\n@@ -2137,1 +2444,0 @@\n-\n@@ -2142,1 +2448,1 @@\n-  return false;\n+  return UseSVE > 0;\n@@ -2178,1 +2484,2 @@\n-  int size = MIN2(16,(int)MaxVectorSize);\n+  \/\/ The MaxVectorSize should have been set by detecting SVE max vector register size.\n+  int size = MIN2((UseSVE > 0) ? 256 : 16, (int)MaxVectorSize);\n@@ -2191,1 +2498,6 @@\n-\/\/  For the moment limit the vector size to 8 bytes\n+  int max_size = max_vector_size(bt);\n+  if ((UseSVE > 0) && (MaxVectorSize >= 16)) {\n+    \/\/ Currently vector length less than SVE vector register size is not supported.\n+    return max_size;\n+  } else {\n+    \/\/  For the moment limit the vector size to 8 bytes with NEON.\n@@ -2195,0 +2507,10 @@\n+  }\n+}\n+\n+const bool Matcher::supports_scalable_vector() {\n+  return UseSVE > 0;\n+}\n+\n+\/\/ Actual max scalable vector register length.\n+const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+  return Matcher::max_vector_size(bt);\n@@ -2199,0 +2521,3 @@\n+  if (UseSVE > 0 && 16 <= len && len <= 256) {\n+    return Op_VecA;\n+  }\n@@ -3466,0 +3791,5 @@\n+    } else if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+      \/\/ Only non uncommon_trap calls need to reinitialize ptrue.\n+      if (uncommon_trap_request() == 0) {\n+        __ reinitialize_ptrue();\n+      }\n@@ -3476,0 +3806,2 @@\n+    } else if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+      __ reinitialize_ptrue();\n@@ -3512,0 +3844,3 @@\n+    if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+      __ reinitialize_ptrue();\n+    }\n@@ -3521,0 +3856,5 @@\n+#ifdef ASSERT\n+    if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+      __ verify_ptrue();\n+    }\n+#endif\n@@ -4291,0 +4631,35 @@\n+\/\/ 8 bit signed value.\n+operand immI8()\n+%{\n+  predicate(n->get_int() <= 127 && n->get_int() >= -128);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ 8 bit signed value (simm8), or #simm8 LSL 8.\n+operand immI8_shift8()\n+%{\n+  predicate((n->get_int() <= 127 && n->get_int() >= -128) ||\n+            (n->get_int() <= 32512 && n->get_int() >= -32768 && (n->get_int() & 0xff) == 0));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ 8 bit signed value (simm8), or #simm8 LSL 8.\n+operand immL8_shift8()\n+%{\n+  predicate((n->get_long() <= 127 && n->get_long() >= -128) ||\n+            (n->get_long() <= 32512 && n->get_long() >= -32768 && (n->get_long() & 0xff) == 0));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4909,0 +5284,12 @@\n+\/\/ Generic vector class. This will be used for\n+\/\/ all vector operands, including NEON and SVE,\n+\/\/ but currently only used for SVE VecA.\n+operand vReg()\n+%{\n+  constraint(ALLOC_IN_RC(vectora_reg));\n+  match(VecA);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -5217,0 +5604,9 @@\n+operand pRegGov()\n+%{\n+  constraint(ALLOC_IN_RC(gov_pr));\n+  match(RegVMask);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -13675,0 +14071,71 @@\n+instruct copySignD_reg(vRegD dst, vRegD src1, vRegD src2, vRegD zero) %{\n+  match(Set dst (CopySignD src1 (Binary src2 zero)));\n+  effect(TEMP_DEF dst, USE src1, USE src2, USE zero);\n+  format %{ \"CopySignD  $dst $src1 $src2\" %}\n+  ins_encode %{\n+    FloatRegister dst = as_FloatRegister($dst$$reg),\n+                  src1 = as_FloatRegister($src1$$reg),\n+                  src2 = as_FloatRegister($src2$$reg),\n+                  zero = as_FloatRegister($zero$$reg);\n+    __ fnegd(dst, zero);\n+    __ bsl(dst, __ T8B, src2, src1);\n+  %}\n+  ins_pipe(fp_uop_d);\n+%}\n+\n+instruct copySignF_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (CopySignF src1 src2));\n+  effect(TEMP_DEF dst, USE src1, USE src2);\n+  format %{ \"CopySignF  $dst $src1 $src2\" %}\n+  ins_encode %{\n+    FloatRegister dst = as_FloatRegister($dst$$reg),\n+                  src1 = as_FloatRegister($src1$$reg),\n+                  src2 = as_FloatRegister($src2$$reg);\n+    __ movi(dst, __ T2S, 0x80, 24);\n+    __ bsl(dst, __ T8B, src2, src1);\n+  %}\n+  ins_pipe(fp_uop_d);\n+%}\n+\n+instruct signumD_reg(vRegD dst, vRegD src, vRegD zero, vRegD one) %{\n+  match(Set dst (SignumD src (Binary zero one)));\n+  effect(TEMP_DEF dst, USE src, USE zero, USE one);\n+  format %{ \"signumD  $dst, $src\" %}\n+  ins_encode %{\n+    FloatRegister src = as_FloatRegister($src$$reg),\n+                  dst = as_FloatRegister($dst$$reg),\n+                  zero = as_FloatRegister($zero$$reg),\n+                  one = as_FloatRegister($one$$reg);\n+    __ facgtd(dst, src, zero); \/\/ dst=0 for +-0.0 and NaN. 0xFFF..F otherwise\n+    __ ushrd(dst, dst, 1);     \/\/ dst=0 for +-0.0 and NaN. 0x7FF..F otherwise\n+    \/\/ Bit selection instruction gets bit from \"one\" for each enabled bit in\n+    \/\/ \"dst\", otherwise gets a bit from \"src\". For \"src\" that contains +-0.0 or\n+    \/\/ NaN the whole \"src\" will be copied because \"dst\" is zero. For all other\n+    \/\/ \"src\" values dst is 0x7FF..F, which means only the sign bit is copied\n+    \/\/ from \"src\", and all other bits are copied from 1.0.\n+    __ bsl(dst, __ T8B, one, src);\n+  %}\n+  ins_pipe(fp_uop_d);\n+%}\n+\n+instruct signumF_reg(vRegF dst, vRegF src, vRegF zero, vRegF one) %{\n+  match(Set dst (SignumF src (Binary zero one)));\n+  effect(TEMP_DEF dst, USE src, USE zero, USE one);\n+  format %{ \"signumF  $dst, $src\" %}\n+  ins_encode %{\n+    FloatRegister src = as_FloatRegister($src$$reg),\n+                  dst = as_FloatRegister($dst$$reg),\n+                  zero = as_FloatRegister($zero$$reg),\n+                  one = as_FloatRegister($one$$reg);\n+    __ facgts(dst, src, zero);    \/\/ dst=0 for +-0.0 and NaN. 0xFFF..F otherwise\n+    __ ushr(dst, __ T2S, dst, 1); \/\/ dst=0 for +-0.0 and NaN. 0x7FF..F otherwise\n+    \/\/ Bit selection instruction gets bit from \"one\" for each enabled bit in\n+    \/\/ \"dst\", otherwise gets a bit from \"src\". For \"src\" that contains +-0.0 or\n+    \/\/ NaN the whole \"src\" will be copied because \"dst\" is zero. For all other\n+    \/\/ \"src\" values dst is 0x7FF..F, which means only the sign bit is copied\n+    \/\/ from \"src\", and all other bits are copied from 1.0.\n+    __ bsl(dst, __ T8B, one, src);\n+  %}\n+  ins_pipe(fp_uop_d);\n+%}\n+\n@@ -16187,1 +16654,1 @@\n-  predicate(n->as_LoadVector()->memory_size() == 16);\n+  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 16);\n@@ -16243,1 +16710,1 @@\n-  predicate(n->as_Vector()->length() == 16);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 16);\n@@ -16268,1 +16735,1 @@\n-  predicate(n->as_Vector()->length() == 16);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 16);\n@@ -16293,1 +16760,1 @@\n-  predicate(n->as_Vector()->length() == 8);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 8);\n@@ -16318,1 +16785,1 @@\n-  predicate(n->as_Vector()->length() == 8);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 8);\n@@ -16342,1 +16809,1 @@\n-  predicate(n->as_Vector()->length() == 4);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n@@ -16366,1 +16833,1 @@\n-  predicate(n->as_Vector()->length() == 4);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n@@ -16378,1 +16845,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n@@ -16390,1 +16857,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n@@ -16417,1 +16884,1 @@\n-  predicate(n->as_Vector()->length() == 4);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 4);\n@@ -16430,1 +16897,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(UseSVE == 0 && n->as_Vector()->length() == 2);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":698,"deletions":231,"binary":false,"changes":929,"status":"modified"},{"patch":"@@ -2243,1 +2243,1 @@\n-\/* Currently, vtable-dispatch is only enabled for sparc platforms *\/\n+\/* vtable-dispatch is not enabled for aarch64 platform*\/\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -435,0 +435,5 @@\n+    if (UseSVE > 0) {\n+      \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+      \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+      __ reinitialize_ptrue();\n+    }\n@@ -436,1 +441,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -105,0 +105,3 @@\n+  product(uint, UseSVE, 0,                                              \\\n+          \"Highest supported SVE instruction set version\")              \\\n+          range(0, 2)                                                   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2166,1 +2166,1 @@\n-\/\/ Return the number of words pushed\n+\/\/ Return the number of dwords pushed\n@@ -2169,0 +2169,7 @@\n+  bool use_sve = false;\n+  int sve_vector_size_in_bytes = 0;\n+\n+#ifdef COMPILER2\n+  use_sve = Matcher::supports_scalable_vector();\n+  sve_vector_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);\n+#endif\n@@ -2183,0 +2190,10 @@\n+  \/\/ SVE\n+  if (use_sve && sve_vector_size_in_bytes > 16) {\n+    sub(stack, stack, sve_vector_size_in_bytes * count);\n+    for (int i = 0; i < count; i++) {\n+      sve_str(as_FloatRegister(regs[i]), Address(stack, i));\n+    }\n+    return count * sve_vector_size_in_bytes \/ 8;\n+  }\n+\n+  \/\/ NEON\n@@ -2185,1 +2202,1 @@\n-    return 1;\n+    return 2;\n@@ -2206,1 +2223,1 @@\n-  return count;\n+  return count * 2;\n@@ -2209,0 +2226,1 @@\n+\/\/ Return the number of dwords poped\n@@ -2211,0 +2229,2 @@\n+  bool use_sve = false;\n+  int sve_vector_size_in_bytes = 0;\n@@ -2212,0 +2232,4 @@\n+#ifdef COMPILER2\n+  use_sve = Matcher::supports_scalable_vector();\n+  sve_vector_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);\n+#endif\n@@ -2225,0 +2249,10 @@\n+  \/\/ SVE\n+  if (use_sve && sve_vector_size_in_bytes > 16) {\n+    for (int i = count - 1; i >= 0; i--) {\n+      sve_ldr(as_FloatRegister(regs[i]), Address(stack, i));\n+    }\n+    add(stack, stack, sve_vector_size_in_bytes * count);\n+    return count * sve_vector_size_in_bytes \/ 8;\n+  }\n+\n+  \/\/ NEON\n@@ -2227,1 +2261,1 @@\n-    return 1;\n+    return 2;\n@@ -2248,1 +2282,1 @@\n-  return count;\n+  return count * 2;\n@@ -2696,2 +2730,2 @@\n-void MacroAssembler::push_CPU_state(bool save_vectors) {\n-  int step = (save_vectors ? 8 : 4) * wordSize;\n+void MacroAssembler::push_CPU_state(bool save_vectors, bool use_sve,\n+                                    int sve_vector_size_in_bytes) {\n@@ -2699,5 +2733,14 @@\n-  mov(rscratch1, -step);\n-  sub(sp, sp, step);\n-  for (int i = 28; i >= 4; i -= 4) {\n-    st1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n-        as_FloatRegister(i+3), save_vectors ? T2D : T1D, Address(post(sp, rscratch1)));\n+  if (save_vectors && use_sve && sve_vector_size_in_bytes > 16) {\n+    sub(sp, sp, sve_vector_size_in_bytes * FloatRegisterImpl::number_of_registers);\n+    for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+      sve_str(as_FloatRegister(i), Address(sp, i));\n+    }\n+  } else {\n+    int step = (save_vectors ? 8 : 4) * wordSize;\n+    mov(rscratch1, -step);\n+    sub(sp, sp, step);\n+    for (int i = 28; i >= 4; i -= 4) {\n+      st1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n+          as_FloatRegister(i+3), save_vectors ? T2D : T1D, Address(post(sp, rscratch1)));\n+    }\n+    st1(v0, v1, v2, v3, save_vectors ? T2D : T1D, sp);\n@@ -2705,1 +2748,0 @@\n-  st1(v0, v1, v2, v3, save_vectors ? T2D : T1D, sp);\n@@ -2708,5 +2750,13 @@\n-void MacroAssembler::pop_CPU_state(bool restore_vectors) {\n-  int step = (restore_vectors ? 8 : 4) * wordSize;\n-  for (int i = 0; i <= 28; i += 4)\n-    ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n-        as_FloatRegister(i+3), restore_vectors ? T2D : T1D, Address(post(sp, step)));\n+void MacroAssembler::pop_CPU_state(bool restore_vectors, bool use_sve,\n+                                   int sve_vector_size_in_bytes) {\n+  if (restore_vectors && use_sve && sve_vector_size_in_bytes > 16) {\n+    for (int i = FloatRegisterImpl::number_of_registers - 1; i >= 0; i--) {\n+      sve_ldr(as_FloatRegister(i), Address(sp, i));\n+    }\n+    add(sp, sp, sve_vector_size_in_bytes * FloatRegisterImpl::number_of_registers);\n+  } else {\n+    int step = (restore_vectors ? 8 : 4) * wordSize;\n+    for (int i = 0; i <= 28; i += 4)\n+      ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n+          as_FloatRegister(i+3), restore_vectors ? T2D : T1D, Address(post(sp, step)));\n+  }\n@@ -2761,0 +2811,15 @@\n+Address MacroAssembler::sve_spill_address(int sve_reg_size_in_bytes, int offset, Register tmp) {\n+  assert(offset >= 0, \"spill to negative address?\");\n+\n+  Register base = sp;\n+\n+  \/\/ An immediate offset in the range 0 to 255 which is multiplied\n+  \/\/ by the current vector or predicate register size in bytes.\n+  if (offset % sve_reg_size_in_bytes == 0 && offset < ((1<<8)*sve_reg_size_in_bytes)) {\n+    return Address(base, offset \/ sve_reg_size_in_bytes);\n+  }\n+\n+  add(tmp, base, offset);\n+  return Address(tmp);\n+}\n+\n@@ -5678,0 +5743,21 @@\n+\n+void MacroAssembler::verify_sve_vector_length() {\n+  Label verify_ok;\n+  assert(UseSVE > 0, \"should only be used for SVE\");\n+  movw(rscratch1, zr);\n+  sve_inc(rscratch1, B);\n+  subsw(zr, rscratch1, VM_Version::get_initial_sve_vector_length());\n+  br(EQ, verify_ok);\n+  stop(\"Error: SVE vector length has changed since jvm startup\");\n+  bind(verify_ok);\n+}\n+\n+void MacroAssembler::verify_ptrue() {\n+  Label verify_ok;\n+  assert(UseSVE > 0, \"should only be used for SVE\");\n+  sve_cntp(rscratch1, B, ptrue, ptrue); \/\/ get true elements count.\n+  sve_dec(rscratch1, B);\n+  cbz(rscratch1, verify_ok);\n+  stop(\"Error: the preserved predicate register (p7) elements are not all true\");\n+  bind(verify_ok);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":104,"deletions":18,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -894,2 +894,4 @@\n-  void push_CPU_state(bool save_vectors = false);\n-  void pop_CPU_state(bool restore_vectors = false) ;\n+  void push_CPU_state(bool save_vectors = false, bool use_sve = false,\n+                      int sve_vector_size_in_bytes = 0);\n+  void pop_CPU_state(bool restore_vectors = false, bool use_sve = false,\n+                      int sve_vector_size_in_bytes = 0);\n@@ -975,0 +977,5 @@\n+  void verify_sve_vector_length();\n+  void reinitialize_ptrue() {\n+    sve_ptrue(ptrue, B);\n+  }\n+  void verify_ptrue();\n@@ -1357,0 +1364,1 @@\n+  Address sve_spill_address(int sve_reg_size_in_bytes, int offset, Register tmp=rscratch2);\n@@ -1380,0 +1388,3 @@\n+  void spill_sve_vector(FloatRegister Zx, int offset, int vector_reg_size_in_bytes) {\n+    sve_str(Zx, sve_spill_address(vector_reg_size_in_bytes, offset));\n+  }\n@@ -1390,0 +1401,3 @@\n+  void unspill_sve_vector(FloatRegister Zx, int offset, int vector_reg_size_in_bytes) {\n+    sve_ldr(Zx, sve_spill_address(vector_reg_size_in_bytes, offset));\n+  }\n@@ -1403,1 +1417,9 @@\n-\n+  void spill_copy_sve_vector_stack_to_stack(int src_offset, int dst_offset,\n+                                            int sve_vec_reg_size_in_bytes) {\n+    assert(sve_vec_reg_size_in_bytes % 16 == 0, \"unexpected sve vector reg size\");\n+    for (int i = 0; i < sve_vec_reg_size_in_bytes \/ 16; i++) {\n+      spill_copy128(src_offset, dst_offset);\n+      src_offset += 16;\n+      dst_offset += 16;\n+    }\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -119,0 +119,10 @@\n+  bool use_sve = false;\n+  int sve_vector_size_in_bytes = 0;\n+  int sve_vector_size_in_slots = 0;\n+\n+#ifdef COMPILER2\n+  use_sve = Matcher::supports_scalable_vector();\n+  sve_vector_size_in_bytes = Matcher::scalable_vector_reg_size(T_BYTE);\n+  sve_vector_size_in_slots = Matcher::scalable_vector_reg_size(T_FLOAT);\n+#endif\n+\n@@ -121,0 +131,2 @@\n+    int vect_words = 0;\n+    int extra_save_slots_per_register = 0;\n@@ -122,2 +134,7 @@\n-    int vect_words = FloatRegisterImpl::number_of_registers * FloatRegisterImpl::extra_save_slots_per_register \/\n-                     VMRegImpl::slots_per_word;\n+    if (use_sve) {\n+      extra_save_slots_per_register = sve_vector_size_in_slots - FloatRegisterImpl::save_slots_per_register;\n+    } else {\n+      extra_save_slots_per_register = FloatRegisterImpl::extra_save_slots_per_neon_register;\n+    }\n+    vect_words = FloatRegisterImpl::number_of_registers * extra_save_slots_per_register \/\n+                 VMRegImpl::slots_per_word;\n@@ -142,1 +159,1 @@\n-  __ push_CPU_state(save_vectors);\n+  __ push_CPU_state(save_vectors, use_sve, sve_vector_size_in_bytes);\n@@ -166,2 +183,7 @@\n-    int sp_offset = save_vectors ? (FloatRegisterImpl::max_slots_per_register * i) :\n-                                   (FloatRegisterImpl::save_slots_per_register * i);\n+    int sp_offset = 0;\n+    if (save_vectors) {\n+      sp_offset = use_sve ? (sve_vector_size_in_slots * i) :\n+                            (FloatRegisterImpl::slots_per_neon_register * i);\n+    } else {\n+      sp_offset = FloatRegisterImpl::save_slots_per_register * i;\n+    }\n@@ -176,1 +198,5 @@\n-#if !COMPILER2_OR_JVMCI\n+#ifdef COMPILER2\n+  __ pop_CPU_state(restore_vectors, Matcher::supports_scalable_vector(),\n+                   Matcher::scalable_vector_reg_size(T_BYTE));\n+#else\n+#if !INCLUDE_JVMCI\n@@ -180,0 +206,1 @@\n+#endif\n@@ -1102,1 +1129,1 @@\n-\/\/ 64 bits items (sparc abi) even though java would only store\n+\/\/ 64 bits items (Aarch64 abi) even though java would only store\n@@ -2123,0 +2150,5 @@\n+  if (UseSVE > 0) {\n+    \/\/ Make sure that jni code does not change SVE vector length.\n+    __ verify_sve_vector_length();\n+  }\n+\n@@ -3055,0 +3087,6 @@\n+  if (UseSVE > 0 && save_vectors) {\n+    \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+    \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+    __ reinitialize_ptrue();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":45,"deletions":7,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -506,0 +506,5 @@\n+    if (UseSVE > 0 ) {\n+      \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+      \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+      __ reinitialize_ptrue();\n+    }\n@@ -5036,0 +5041,6 @@\n+    if (UseSVE > 0) {\n+      \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+      \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+      __ reinitialize_ptrue();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1382,0 +1382,5 @@\n+  if (UseSVE > 0) {\n+    \/\/ Make sure that jni code does not change SVE vector length.\n+    __ verify_sve_vector_length();\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,3 +115,3 @@\n-  \/\/ of the return address we need the real \"raw\" sp. Since sparc already\n-  \/\/ uses sp() to mean \"raw\" sp and unextended_sp() to mean the caller's\n-  \/\/ original sp we use that convention.\n+  \/\/ of the return address we need the real \"raw\" sp. By convention we\n+  \/\/ use sp() to mean \"raw\" sp and unextended_sp() to mean the caller's\n+  \/\/ original sp.\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1385,1 +1385,1 @@\n-\/\/ 64 bits items (sparc abi) even though java would only store\n+\/\/ 64 bits items (x86_32\/64 abi) even though java would only store\n@@ -1511,1 +1511,0 @@\n-  \/\/ This greatly simplifies the cases here compared to sparc.\n@@ -1540,1 +1539,0 @@\n-  \/\/ This greatly simplifies the cases here compared to sparc.\n@@ -1566,1 +1564,0 @@\n-  \/\/ This greatly simplifies the cases here compared to sparc.\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2829,1 +2829,1 @@\n-    assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, \"missing type\");\n+    assert(ARRAY_SIZE(hi) == _last_machine_leaf - 8, \"missing type\");\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3947,0 +3947,2 @@\n+         strcmp(opType,\"RegVMask\")==0 ||\n+         strcmp(opType,\"VecA\")==0 ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,2 +154,2 @@\n-  \/\/ addressable on the platform.  Used by sparc to verify that all\n-  \/\/ stack addresses are expressable in a simm13.\n+  \/\/ addressable on the platform.  Used by arm, ppc to verify that all\n+  \/\/ stack addresses are valid.\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1472,4 +1472,0 @@\n-\n-  \/\/ In 64bit the type can be long, sparc doesn't have this assert\n-  \/\/ assert(offset.type()->tag() == intTag, \"invalid type\");\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2707,1 +2707,1 @@\n-      \/\/ Does this reverse on x86 vs. sparc?\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-  case handle_exception_nofpu_id:  \/\/ Unused on sparc\n+  case handle_exception_nofpu_id:\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -790,1 +790,1 @@\n-  LinkInfo link_info(holder_klass, name, sig, accessor_klass, LinkInfo::AccessCheck::required, tag);\n+  LinkInfo link_info(holder_klass, name, sig, accessor_klass, LinkInfo::AccessCheck::required, LinkInfo::LoaderConstraintCheck::required, tag);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -829,1 +829,2 @@\n-                      check_access ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip);\n+                      check_access ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip,\n+                      check_access ? LinkInfo::LoaderConstraintCheck::required : LinkInfo::LoaderConstraintCheck::skip);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1139,1 +1139,5 @@\n-    MN_ACCESS_VM_ANNOTATIONS = 0x00000008\n+    MN_ACCESS_VM_ANNOTATIONS = 0x00000008,\n+    \/\/ Lookup modes\n+    MN_MODULE_MODE           = 0x00000010,\n+    MN_UNCONDITIONAL_MODE    = 0x00000020,\n+    MN_TRUSTED_MODE          = -1\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2924,1 +2924,1 @@\n-    MethodHandles::resolve_MemberName(mname, caller, \/*speculative_resolve*\/false, CHECK_(empty));\n+    MethodHandles::resolve_MemberName(mname, caller, 0, false \/*speculative_resolve*\/, CHECK_(empty));\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -822,0 +822,8 @@\n+  case vmIntrinsics::_dcopySign:\n+  case vmIntrinsics::_fcopySign:\n+    if (!InlineMathNatives || !UseCopySignIntrinsic) return true;\n+    break;\n+  case vmIntrinsics::_dsignum:\n+  case vmIntrinsics::_fsignum:\n+    if (!InlineMathNatives || !UseSignumIntrinsic) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -793,0 +793,2 @@\n+  do_name(copySign_name, \"copySign\")                                                                                    \\\n+  do_name(signum_name,\"signum\")                                                                                         \\\n@@ -831,0 +833,4 @@\n+  do_intrinsic(_dcopySign,                java_lang_Math,         copySign_name,      double2_double_signature,  F_S)   \\\n+  do_intrinsic(_fcopySign,                java_lang_Math,         copySign_name,      float2_float_signature,    F_S)   \\\n+  do_intrinsic(_dsignum,                  java_lang_Math,         signum_name,        double_double_signature,   F_S)   \\\n+  do_intrinsic(_fsignum,                  java_lang_Math,         signum_name,        float_float_signature,     F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -244,0 +244,1 @@\n+  _check_loader_constraints = true;\n@@ -259,0 +260,1 @@\n+  _check_loader_constraints = true;\n@@ -264,1 +266,1 @@\n-  tty->print_cr(\"Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s\",\n+  tty->print_cr(\"Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s check_loader_constraints=%s\",\n@@ -269,1 +271,3 @@\n-                _check_access ? \"true\" : \"false\");\n+                _check_access ? \"true\" : \"false\",\n+                _check_loader_constraints ? \"true\" : \"false\");\n+\n@@ -798,1 +802,2 @@\n-\n+  }\n+  if (link_info.check_loader_constraints()) {\n@@ -894,1 +899,2 @@\n-\n+  }\n+  if (link_info.check_loader_constraints()) {\n@@ -1072,1 +1078,1 @@\n-  if ((sel_klass != current_klass) && (current_klass != NULL)) {\n+  if (link_info.check_loader_constraints() && (sel_klass != current_klass) && (current_klass != NULL)) {\n@@ -1106,1 +1112,2 @@\n-                      link_info.check_access() ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip);\n+                      link_info.check_access() ? LinkInfo::AccessCheck::required : LinkInfo::AccessCheck::skip,\n+                      link_info.check_loader_constraints() ? LinkInfo::LoaderConstraintCheck::required : LinkInfo::LoaderConstraintCheck::skip);\n@@ -1269,1 +1276,1 @@\n-      } else if (sel_method() != resolved_method()) {\n+      } else if (link_info.check_loader_constraints() && sel_method() != resolved_method()) {\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+  bool        _check_loader_constraints;\n@@ -148,0 +149,1 @@\n+  enum class LoaderConstraintCheck { required, skip };\n@@ -155,0 +157,1 @@\n+           LoaderConstraintCheck check_loader_constraints = LoaderConstraintCheck::required,\n@@ -158,1 +161,2 @@\n-    _check_access(check_access == AccessCheck::required), _tag(tag) {}\n+    _check_access(check_access == AccessCheck::required),\n+    _check_loader_constraints(check_loader_constraints == LoaderConstraintCheck::required), _tag(tag) {}\n@@ -162,0 +166,1 @@\n+           LoaderConstraintCheck check_loader_constraints = LoaderConstraintCheck::required,\n@@ -165,1 +170,3 @@\n-    _check_access(check_access == AccessCheck::required), _tag(tag) {}\n+    _check_access(check_access == AccessCheck::required),\n+    _check_loader_constraints(check_loader_constraints == LoaderConstraintCheck::required), _tag(tag) {}\n+\n@@ -171,1 +178,1 @@\n-    _check_access(false), _tag(JVM_CONSTANT_Invalid) {}\n+    _check_access(false), _check_loader_constraints(false), _tag(JVM_CONSTANT_Invalid) {}\n@@ -174,8 +181,8 @@\n-  Symbol* name() const               { return _name; }\n-  Symbol* signature() const          { return _signature; }\n-  Klass* resolved_klass() const      { return _resolved_klass; }\n-  Klass* current_klass() const       { return _current_klass; }\n-  Method* current_method() const     { return _current_method(); }\n-  constantTag tag() const            { return _tag; }\n-  bool check_access() const          { return _check_access; }\n-\n+  Symbol* name() const                  { return _name; }\n+  Symbol* signature() const             { return _signature; }\n+  Klass* resolved_klass() const         { return _resolved_klass; }\n+  Klass* current_klass() const          { return _current_klass; }\n+  Method* current_method() const        { return _current_method(); }\n+  constantTag tag() const               { return _tag; }\n+  bool check_access() const             { return _check_access; }\n+  bool check_loader_constraints() const { return _check_loader_constraints; }\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -922,1 +922,1 @@\n-    if (SafepointMechanism::should_block(thread)) {\n+    if (SafepointMechanism::should_process(thread)) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,4 +335,3 @@\n-  bool created = false;\n-  SourceObjInfo* p = _src_obj_table.lookup(src_obj);\n-  if (p == NULL) {\n-    p = _src_obj_table.add(src_obj, src_info);\n+  bool created;\n+  SourceObjInfo* p = _src_obj_table.add_if_absent(src_obj, src_info, &created);\n+  if (created) {\n@@ -342,1 +341,0 @@\n-    created = true;\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-\/\/    and c1_CodePatterns_sparc.cpp.\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2277,1 +2277,1 @@\n-    \/\/ Also have to add the method to the list safely, which the cld lock\n+    \/\/ Also have to add the method to the list safely, which the lock\n@@ -2279,1 +2279,1 @@\n-    MutexLocker ml(cld->metaspace_lock(),  Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml(JmethodIdCreation_lock,  Mutex::_no_safepoint_check_flag);\n@@ -2301,1 +2301,1 @@\n-    \/\/ Also have to add the method to the list safely, which the cld lock\n+    \/\/ Also have to add the method to the list safely, which the lock\n@@ -2303,1 +2303,1 @@\n-    MutexLocker ml(cld->metaspace_lock(),  Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml(JmethodIdCreation_lock,  Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -461,0 +461,12 @@\n+  case vmIntrinsics::_dcopySign:\n+    if (!Matcher::match_rule_supported(Op_CopySignD)) return false;\n+    break;\n+  case vmIntrinsics::_fcopySign:\n+    if (!Matcher::match_rule_supported(Op_CopySignF)) return false;\n+    break;\n+  case vmIntrinsics::_dsignum:\n+    if (!Matcher::match_rule_supported(Op_SignumD)) return false;\n+    break;\n+  case vmIntrinsics::_fsignum:\n+    if (!Matcher::match_rule_supported(Op_SignumF)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  if( _is_scalable ) tty->print(\"Scalable \");\n@@ -647,1 +648,9 @@\n-          OptoReg::Name lo = OptoReg::add(hi, (1-lrg.num_regs())); \/\/ Find lo\n+          int num_regs = lrg.num_regs();\n+          if (lrg.is_scalable() && OptoReg::is_stack(hi)) {\n+            \/\/ For scalable vector registers, when they are allocated in physical\n+            \/\/ registers, num_regs is RegMask::SlotsPerVecA for reg mask of scalable\n+            \/\/ vector. If they are allocated on stack, we need to get the actual\n+            \/\/ num_regs, which reflects the physical length of scalable registers.\n+            num_regs = lrg.scalable_reg_slots();\n+          }\n+          OptoReg::Name lo = OptoReg::add(hi, (1-num_regs)); \/\/ Find lo\n@@ -805,1 +814,1 @@\n-        if (RegMask::is_vector(ireg))\n+        if (RegMask::is_vector(ireg)) {\n@@ -807,0 +816,11 @@\n+          if (ireg == Op_VecA) {\n+            assert(Matcher::supports_scalable_vector(), \"scalable vector should be supported\");\n+            lrg._is_scalable = 1;\n+            \/\/ For scalable vector, when it is allocated in physical register,\n+            \/\/ num_regs is RegMask::SlotsPerVecA for reg mask,\n+            \/\/ which may not be the actual physical register size.\n+            \/\/ If it is allocated in stack, we need to get the actual\n+            \/\/ physical length of scalable vector register.\n+            lrg.set_scalable_reg_slots(Matcher::scalable_vector_reg_size(T_FLOAT));\n+          }\n+        }\n@@ -908,0 +928,7 @@\n+        case Op_VecA:\n+          assert(Matcher::supports_scalable_vector(), \"does not support scalable vector\");\n+          assert(RegMask::num_registers(Op_VecA) == RegMask::SlotsPerVecA, \"sanity\");\n+          assert(lrgmask.is_aligned_sets(RegMask::SlotsPerVecA), \"vector should be aligned\");\n+          lrg.set_num_regs(RegMask::SlotsPerVecA);\n+          lrg.set_reg_pressure(1);\n+          break;\n@@ -1308,0 +1335,40 @@\n+static OptoReg::Name find_first_set(LRG &lrg, RegMask mask, int chunk) {\n+  int num_regs = lrg.num_regs();\n+  OptoReg::Name assigned = mask.find_first_set(lrg, num_regs);\n+\n+  if (lrg.is_scalable()) {\n+    \/\/ a physical register is found\n+    if (chunk == 0 && OptoReg::is_reg(assigned)) {\n+      return assigned;\n+    }\n+\n+    \/\/ find available stack slots for scalable register\n+    if (lrg._is_vector) {\n+      num_regs = lrg.scalable_reg_slots();\n+      \/\/ if actual scalable vector register is exactly SlotsPerVecA * 32 bits\n+      if (num_regs == RegMask::SlotsPerVecA) {\n+        return assigned;\n+      }\n+\n+      \/\/ mask has been cleared out by clear_to_sets(SlotsPerVecA) before choose_color, but it\n+      \/\/ does not work for scalable size. We have to find adjacent scalable_reg_slots() bits\n+      \/\/ instead of SlotsPerVecA bits.\n+      assigned = mask.find_first_set(lrg, num_regs); \/\/ find highest valid reg\n+      while (OptoReg::is_valid(assigned) && RegMask::can_represent(assigned)) {\n+        \/\/ Verify the found reg has scalable_reg_slots() bits set.\n+        if (mask.is_valid_reg(assigned, num_regs)) {\n+          return assigned;\n+        } else {\n+          \/\/ Remove more for each iteration\n+          mask.Remove(assigned - num_regs + 1); \/\/ Unmask the lowest reg\n+          mask.clear_to_sets(RegMask::SlotsPerVecA); \/\/ Align by SlotsPerVecA bits\n+          assigned = mask.find_first_set(lrg, num_regs);\n+        }\n+      }\n+      return OptoReg::Bad; \/\/ will cause chunk change, and retry next chunk\n+    }\n+  }\n+\n+  return assigned;\n+}\n+\n@@ -1341,1 +1408,1 @@\n-      OptoReg::Name reg = tempmask.find_first_set(lrg.num_regs());\n+      OptoReg::Name reg = find_first_set(lrg, tempmask, chunk);\n@@ -1350,1 +1417,1 @@\n-    return OptoReg::add(lrg.mask().find_first_set(lrg.num_regs()),chunk);\n+    return OptoReg::add(find_first_set(lrg, lrg.mask(), chunk), chunk);\n@@ -1405,1 +1472,0 @@\n-\n@@ -1487,1 +1553,0 @@\n-\n@@ -1512,1 +1577,5 @@\n-        assert(!lrg->_is_vector || n_regs <= RegMask::SlotsPerVecZ, \"sanity\");\n+        if (Matcher::supports_scalable_vector()) {\n+          assert(!lrg->_is_vector || n_regs <= RegMask::SlotsPerVecA, \"sanity\");\n+        } else {\n+          assert(!lrg->_is_vector || n_regs <= RegMask::SlotsPerVecZ, \"sanity\");\n+        }\n@@ -1516,1 +1585,5 @@\n-        for (int i = 1; i < n_regs; i++)\n+        \/\/ We always choose the high bit, then mask the low bits by register size\n+        if (lrg->is_scalable() && OptoReg::is_stack(lrg->reg())) { \/\/ stack\n+          n_regs = lrg->scalable_reg_slots();\n+        }\n+        for (int i = 1; i < n_regs; i++) {\n@@ -1518,0 +1591,1 @@\n+        }\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":82,"deletions":8,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -293,0 +293,4 @@\n+macro(CopySignD)\n+macro(CopySignF)\n+macro(SignumD)\n+macro(SignumF)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -588,1 +588,5 @@\n-  case vmIntrinsics::_dpow:                     return inline_math_native(intrinsic_id());\n+  case vmIntrinsics::_dpow:\n+  case vmIntrinsics::_dcopySign:\n+  case vmIntrinsics::_fcopySign:\n+  case vmIntrinsics::_dsignum:\n+  case vmIntrinsics::_fsignum:                  return inline_math_native(intrinsic_id());\n@@ -1856,0 +1860,2 @@\n+  case vmIntrinsics::_dcopySign: n = CopySignDNode::make(_gvn, arg, round_double_node(argument(2))); break;\n+  case vmIntrinsics::_dsignum: n = SignumDNode::make(_gvn, arg); break;\n@@ -1873,0 +1879,2 @@\n+  case vmIntrinsics::_fcopySign: n = new CopySignFNode(arg, argument(1)); break;\n+  case vmIntrinsics::_fsignum: n = SignumFNode::make(_gvn, arg); break;\n@@ -1957,0 +1965,5 @@\n+  case vmIntrinsics::_dcopySign: return inline_double_math(id);\n+  case vmIntrinsics::_fcopySign: return inline_math(id);\n+  case vmIntrinsics::_dsignum: return inline_double_math(id);\n+  case vmIntrinsics::_fsignum: return inline_math(id);\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  idealreg2spillmask  [Op_VecA] = NULL;\n@@ -104,0 +105,1 @@\n+  idealreg2debugmask  [Op_VecA] = NULL;\n@@ -117,0 +119,1 @@\n+  idealreg2mhdebugmask[Op_VecA] = NULL;\n@@ -465,1 +468,1 @@\n-#define NOF_STACK_MASKS (3*6+5)\n+#define NOF_STACK_MASKS (3*6+6)\n@@ -501,5 +504,6 @@\n-  idealreg2spillmask  [Op_VecS] = &rms[18];\n-  idealreg2spillmask  [Op_VecD] = &rms[19];\n-  idealreg2spillmask  [Op_VecX] = &rms[20];\n-  idealreg2spillmask  [Op_VecY] = &rms[21];\n-  idealreg2spillmask  [Op_VecZ] = &rms[22];\n+  idealreg2spillmask  [Op_VecA] = &rms[18];\n+  idealreg2spillmask  [Op_VecS] = &rms[19];\n+  idealreg2spillmask  [Op_VecD] = &rms[20];\n+  idealreg2spillmask  [Op_VecX] = &rms[21];\n+  idealreg2spillmask  [Op_VecY] = &rms[22];\n+  idealreg2spillmask  [Op_VecZ] = &rms[23];\n@@ -551,0 +555,1 @@\n+  RegMask scalable_stack_mask = aligned_stack_mask;\n@@ -621,7 +626,27 @@\n-   if (UseFPUForSpilling) {\n-     \/\/ This mask logic assumes that the spill operations are\n-     \/\/ symmetric and that the registers involved are the same size.\n-     \/\/ On sparc for instance we may have to use 64 bit moves will\n-     \/\/ kill 2 registers when used with F0-F31.\n-     idealreg2spillmask[Op_RegI]->OR(*idealreg2regmask[Op_RegF]);\n-     idealreg2spillmask[Op_RegF]->OR(*idealreg2regmask[Op_RegI]);\n+\n+  if (Matcher::supports_scalable_vector()) {\n+    int k = 1;\n+    OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);\n+    \/\/ Exclude last input arg stack slots to avoid spilling vector register there,\n+    \/\/ otherwise vector spills could stomp over stack slots in caller frame.\n+    for (; (in >= init_in) && (k < scalable_vector_reg_size(T_FLOAT)); k++) {\n+      scalable_stack_mask.Remove(in);\n+      in = OptoReg::add(in, -1);\n+    }\n+\n+    \/\/ For VecA\n+     scalable_stack_mask.clear_to_sets(RegMask::SlotsPerVecA);\n+     assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+    *idealreg2spillmask[Op_VecA] = *idealreg2regmask[Op_VecA];\n+     idealreg2spillmask[Op_VecA]->OR(scalable_stack_mask);\n+  } else {\n+    *idealreg2spillmask[Op_VecA] = RegMask::Empty;\n+  }\n+\n+  if (UseFPUForSpilling) {\n+    \/\/ This mask logic assumes that the spill operations are\n+    \/\/ symmetric and that the registers involved are the same size.\n+    \/\/ On sparc for instance we may have to use 64 bit moves will\n+    \/\/ kill 2 registers when used with F0-F31.\n+    idealreg2spillmask[Op_RegI]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegF]->OR(*idealreg2regmask[Op_RegI]);\n@@ -629,4 +654,4 @@\n-     idealreg2spillmask[Op_RegN]->OR(*idealreg2regmask[Op_RegF]);\n-     idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n-     idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n-     idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegN]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n+    idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegD]);\n@@ -634,1 +659,1 @@\n-     idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegF]);\n+    idealreg2spillmask[Op_RegP]->OR(*idealreg2regmask[Op_RegF]);\n@@ -636,4 +661,4 @@\n-     \/\/ ARM has support for moving 64bit values between a pair of\n-     \/\/ integer registers and a double register\n-     idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n-     idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n+    \/\/ ARM has support for moving 64bit values between a pair of\n+    \/\/ integer registers and a double register\n+    idealreg2spillmask[Op_RegL]->OR(*idealreg2regmask[Op_RegD]);\n+    idealreg2spillmask[Op_RegD]->OR(*idealreg2regmask[Op_RegL]);\n@@ -642,1 +667,1 @@\n-   }\n+  }\n@@ -934,0 +959,1 @@\n+  idealreg2regmask[Op_VecA] = regmask_for_ideal_register(Op_VecA, ret);\n@@ -1628,1 +1654,0 @@\n-\n@@ -2354,0 +2379,8 @@\n+    case Op_CopySignD:\n+    case Op_SignumF:\n+    case Op_SignumD: {\n+      Node* pair = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair);\n+      n->del_req(3);\n+      break;\n+    }\n@@ -2485,1 +2518,1 @@\n-    assert(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ, \"not a vector: %d\", ideal_reg);\n+    assert(ideal_reg >= Op_VecA && ideal_reg <= Op_VecZ, \"not a vector: %d\", ideal_reg);\n@@ -2502,0 +2535,1 @@\n+    case Op_VecA: \/\/ fall-through\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":59,"deletions":25,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -343,0 +343,4 @@\n+  static const bool supports_scalable_vector();\n+  \/\/ Actual max scalable vector register length.\n+  static const int scalable_vector_reg_size(const BasicType bt);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectora:\",      false, Op_VecA,              relocInfo::none          },  \/\/ VectorA.\n@@ -717,0 +718,4 @@\n+  if (Matcher::supports_scalable_vector()) {\n+    TypeVect::VECTA = TypeVect::make(T_BYTE, Matcher::scalable_vector_reg_size(T_BYTE));\n+  }\n+\n@@ -733,0 +738,2 @@\n+\n+  mreg2type[Op_VecA] = TypeVect::VECTA;\n@@ -1055,0 +1062,1 @@\n+  Bad,          \/\/ VectorA - handled in v-call\n@@ -2525,0 +2533,1 @@\n+const TypeVect *TypeVect::VECTA = NULL; \/\/ vector length agnostic\n@@ -2535,1 +2544,0 @@\n-  assert(length > 1 && is_power_of_2(length), \"vector length is power of 2\");\n@@ -2539,0 +2547,2 @@\n+  case Op_VecA:\n+    return (TypeVect*)(new TypeVectA(elem, length))->hashcons();\n@@ -2570,1 +2580,1 @@\n-\n+  case VectorA:\n@@ -2625,0 +2635,2 @@\n+  case VectorA:\n+    st->print(\"vectora[\"); break;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+class     TypeVectA;\n@@ -93,0 +94,1 @@\n+    VectorA,                    \/\/ (Scalable) Vector types for vector length agnostic\n@@ -834,0 +836,1 @@\n+  static const TypeVect *VECTA;\n@@ -845,0 +848,5 @@\n+class TypeVectA : public TypeVect {\n+  friend class TypeVect;\n+  TypeVectA(const Type* elem, uint length) : TypeVect(VectorA, elem, length) {}\n+};\n+\n@@ -1736,1 +1744,1 @@\n-  assert( _base >= VectorS && _base <= VectorZ, \"Not a Vector\" );\n+  assert( _base >= VectorA && _base <= VectorZ, \"Not a Vector\" );\n@@ -1741,1 +1749,1 @@\n-  return (_base >= VectorS && _base <= VectorZ) ? (TypeVect*)this : NULL;\n+  return (_base >= VectorA && _base <= VectorZ) ? (TypeVect*)this : NULL;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1411,15 +1411,0 @@\n-class RegisterArrayForGC {\n- private:\n-  JavaThread *_thread;\n- public:\n-  RegisterArrayForGC(JavaThread *thread, GrowableArray<oop>* array)  {\n-    _thread = thread;\n-    _thread->register_array_for_gc(array);\n-  }\n-\n-  ~RegisterArrayForGC() {\n-    _thread->register_array_for_gc(NULL);\n-  }\n-};\n-\n-\n@@ -1431,1 +1416,1 @@\n-  GrowableArray<oop>* local_array = new GrowableArray<oop>(12);\n+  GrowableArray<Handle>* local_array = new GrowableArray<Handle>(12);\n@@ -1473,1 +1458,1 @@\n-      local_array->push(protection_domain);\n+      local_array->push(Handle(thread, protection_domain));\n@@ -1490,2 +1475,0 @@\n-  \/\/ the resource area must be registered in case of a gc\n-  RegisterArrayForGC ragc(thread, local_array);\n@@ -1496,1 +1479,1 @@\n-    h_context->obj_at_put(index, local_array->at(index));\n+    h_context->obj_at_put(index, local_array->at(index)());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1717,9 +1717,12 @@\n-    \/\/ thread. All other usage needs to use a vm-safepoint-op for safety.\n-    if (java_thread == JavaThread::current()) {\n-      state->update_for_pop_top_frame();\n-    } else {\n-      VM_UpdateForPopTopFrame op(state);\n-      VMThread::execute(&op);\n-      jvmtiError err = op.result();\n-      if (err != JVMTI_ERROR_NONE) {\n-        return err;\n+    \/\/ thread. All other usage needs to use a handshake for safety.\n+    {\n+      MutexLocker mu(JvmtiThreadState_lock);\n+      if (java_thread == JavaThread::current()) {\n+        state->update_for_pop_top_frame();\n+      } else {\n+        UpdateForPopTopFrameClosure op(state);\n+        bool executed = Handshake::execute_direct(&op, java_thread);\n+        jvmtiError err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n+        if (err != JVMTI_ERROR_NONE) {\n+          return err;\n+        }\n@@ -1799,0 +1802,1 @@\n+  MutexLocker mu(JvmtiThreadState_lock);\n@@ -1803,3 +1807,3 @@\n-    VM_SetFramePop op(this, state, depth);\n-    VMThread::execute(&op);\n-    err = op.result();\n+    SetFramePopClosure op(this, state, depth);\n+    bool executed = Handshake::execute_direct(&op, java_thread);\n+    err = executed ? op.result() : JVMTI_ERROR_THREAD_NOT_ALIVE;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1512,1 +1512,1 @@\n-VM_UpdateForPopTopFrame::doit() {\n+UpdateForPopTopFrameClosure::do_thread(Thread *target) {\n@@ -1514,2 +1514,2 @@\n-  ThreadsListHandle tlh;\n-  if (jt != NULL && tlh.includes(jt) && !jt->is_exiting() && jt->threadObj() != NULL) {\n+  assert(jt == target, \"just checking\");\n+  if (!jt->is_exiting() && jt->threadObj() != NULL) {\n@@ -1517,2 +1517,1 @@\n-  } else {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    _result = JVMTI_ERROR_NONE;\n@@ -1523,1 +1522,1 @@\n-VM_SetFramePop::doit() {\n+SetFramePopClosure::do_thread(Thread *target) {\n@@ -1525,2 +1524,2 @@\n-  ThreadsListHandle tlh;\n-  if (jt != NULL && tlh.includes(jt) && !jt->is_exiting() && jt->threadObj() != NULL) {\n+  assert(jt == target, \"just checking\");\n+  if (!jt->is_exiting() && jt->threadObj() != NULL) {\n@@ -1529,2 +1528,1 @@\n-  } else {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+    _result = JVMTI_ERROR_NONE;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -135,0 +135,3 @@\n+  LM_UNCONDITIONAL      = java_lang_invoke_MemberName::MN_UNCONDITIONAL_MODE,\n+  LM_MODULE             = java_lang_invoke_MemberName::MN_MODULE_MODE,\n+  LM_TRUSTED            = java_lang_invoke_MemberName::MN_TRUSTED_MODE,\n@@ -678,1 +681,0 @@\n-\n@@ -682,1 +684,1 @@\n-Handle MethodHandles::resolve_MemberName(Handle mname, Klass* caller,\n+Handle MethodHandles::resolve_MemberName(Handle mname, Klass* caller, int lookup_mode,\n@@ -751,0 +753,1 @@\n+  \/\/ skip access check if it's trusted lookup\n@@ -754,0 +757,4 @@\n+  \/\/ skip loader constraints if it's trusted lookup or a public lookup\n+  LinkInfo::LoaderConstraintCheck loader_constraint_check = (caller != NULL && (lookup_mode & LM_UNCONDITIONAL) == 0) ?\n+                                              LinkInfo::LoaderConstraintCheck::required :\n+                                              LinkInfo::LoaderConstraintCheck::skip;\n@@ -760,1 +767,1 @@\n-      LinkInfo link_info(defc, name, type, caller, access_check);\n+      LinkInfo link_info(defc, name, type, caller, access_check, loader_constraint_check);\n@@ -801,1 +808,1 @@\n-      LinkInfo link_info(defc, name, type, caller, access_check);\n+      LinkInfo link_info(defc, name, type, caller, access_check, loader_constraint_check);\n@@ -829,1 +836,1 @@\n-        LinkInfo link_info(defc, name, type, caller, LinkInfo::AccessCheck::skip);\n+        LinkInfo link_info(defc, name, type, caller, LinkInfo::AccessCheck::skip, loader_constraint_check);\n@@ -1126,0 +1133,3 @@\n+    template(java_lang_invoke_MemberName,MN_MODULE_MODE) \\\n+    template(java_lang_invoke_MemberName,MN_UNCONDITIONAL_MODE) \\\n+    template(java_lang_invoke_MemberName,MN_TRUSTED_MODE) \\\n@@ -1199,1 +1209,1 @@\n-    jboolean speculative_resolve)) {\n+    jint lookup_mode, jboolean speculative_resolve)) {\n@@ -1205,1 +1215,5 @@\n-  if (VerifyMethodHandles && caller_jh != NULL &&\n+  \/\/ This only verifies from the context of the lookup class.  It does not\n+  \/\/ verify the lookup context for a Lookup object teleported from one module\n+  \/\/ to another. Such Lookup object can only access the intersection of the set\n+  \/\/ of accessible classes from both lookup class and previous lookup class.\n+  if (VerifyMethodHandles && (lookup_mode & LM_TRUSTED) == LM_TRUSTED && caller_jh != NULL &&\n@@ -1216,1 +1230,3 @@\n-      if (caller != SystemDictionary::Object_klass()\n+      \/\/ access check on behalf of the caller if this is not a public lookup\n+      \/\/ i.e. lookup mode is not UNCONDITIONAL\n+      if ((lookup_mode & LM_UNCONDITIONAL) == 0\n@@ -1220,1 +1236,5 @@\n-        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), reference_klass->external_name());\n+        ResourceMark rm(THREAD);\n+        stringStream ss;\n+        ss.print(\"caller %s tried to access %s\", caller->class_in_module_of_loader(),\n+                 reference_klass->class_in_module_of_loader());\n+        THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), ss.as_string());\n@@ -1227,1 +1247,2 @@\n-  Handle resolved = MethodHandles::resolve_MemberName(mname, caller, speculative_resolve == JNI_TRUE,\n+  Handle resolved = MethodHandles::resolve_MemberName(mname, caller, lookup_mode,\n+                                                      speculative_resolve == JNI_TRUE,\n@@ -1527,1 +1548,1 @@\n-  {CC \"resolve\",                   CC \"(\" MEM \"\" CLS \"Z)\" MEM,               FN_PTR(MHN_resolve_Mem)},\n+  {CC \"resolve\",                   CC \"(\" MEM \"\" CLS \"IZ)\" MEM,              FN_PTR(MHN_resolve_Mem)},\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -350,0 +350,6 @@\n+  diagnostic(bool, UseCopySignIntrinsic, false,                             \\\n+          \"Enables intrinsification of Math.copySign\")                      \\\n+                                                                            \\\n+  diagnostic(bool, UseSignumIntrinsic, false,                               \\\n+          \"Enables intrinsification of Math.signum\")                        \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -505,0 +505,17 @@\n+\n+  class Tracer {\n+  private:\n+    const char*               _name;\n+    EventSafepointCleanupTask _event;\n+    TraceTime                 _timer;\n+\n+  public:\n+    Tracer(const char* name) :\n+        _name(name),\n+        _event(),\n+        _timer(name, TRACETIME_LOG(Info, safepoint, cleanup)) {}\n+    ~Tracer() {\n+      post_safepoint_cleanup_task_event(_event, SafepointSynchronize::safepoint_id(), _name);\n+    }\n+  };\n+\n@@ -512,5 +529,1 @@\n-    uint64_t safepoint_id = SafepointSynchronize::safepoint_id();\n-\n-      const char* name = \"deflating idle monitors\";\n-      EventSafepointCleanupTask event;\n-      TraceTime timer(name, TRACETIME_LOG(Info, safepoint, cleanup));\n+      Tracer t(\"deflating idle monitors\");\n@@ -519,2 +532,0 @@\n-\n-      post_safepoint_cleanup_task_event(event, safepoint_id, name);\n@@ -524,3 +535,1 @@\n-      const char* name = \"updating inline caches\";\n-      EventSafepointCleanupTask event;\n-      TraceTime timer(name, TRACETIME_LOG(Info, safepoint, cleanup));\n+      Tracer t(\"updating inline caches\");\n@@ -528,2 +537,0 @@\n-\n-      post_safepoint_cleanup_task_event(event, safepoint_id, name);\n@@ -533,3 +540,1 @@\n-      const char* name = \"compilation policy safepoint handler\";\n-      EventSafepointCleanupTask event;\n-      TraceTime timer(name, TRACETIME_LOG(Info, safepoint, cleanup));\n+      Tracer t(\"compilation policy safepoint handler\");\n@@ -537,2 +542,0 @@\n-\n-      post_safepoint_cleanup_task_event(event, safepoint_id, name);\n@@ -543,3 +546,1 @@\n-        const char* name = \"rehashing symbol table\";\n-        EventSafepointCleanupTask event;\n-        TraceTime timer(name, TRACETIME_LOG(Info, safepoint, cleanup));\n+        Tracer t(\"rehashing symbol table\");\n@@ -547,2 +548,0 @@\n-\n-        post_safepoint_cleanup_task_event(event, safepoint_id, name);\n@@ -554,3 +553,1 @@\n-        const char* name = \"rehashing string table\";\n-        EventSafepointCleanupTask event;\n-        TraceTime timer(name, TRACETIME_LOG(Info, safepoint, cleanup));\n+        Tracer t(\"rehashing string table\");\n@@ -558,2 +555,0 @@\n-\n-        post_safepoint_cleanup_task_event(event, safepoint_id, name);\n@@ -565,3 +560,1 @@\n-        const char* name = \"resizing system dictionaries\";\n-        EventSafepointCleanupTask event;\n-        TraceTime timer(name, TRACETIME_LOG(Info, safepoint, cleanup));\n+        Tracer t(\"resizing system dictionaries\");\n@@ -569,2 +562,0 @@\n-\n-        post_safepoint_cleanup_task_event(event, safepoint_id, name);\n@@ -787,1 +778,1 @@\n-  \/\/ cross_modify_fence is done by SafepointMechanism::block_if_requested_slow\n+  \/\/ cross_modify_fence is done by SafepointMechanism::process_operation_if_requested_slow\n@@ -937,1 +928,1 @@\n-\/\/ Block the thread at poll or poll return for safepoint\/handshake.\n+\/\/ Process pending operation.\n@@ -1000,2 +991,2 @@\n-    \/\/ Block the thread\n-    SafepointMechanism::block_if_requested(thread());\n+    \/\/ Process pending operation\n+    SafepointMechanism::process_if_requested(thread());\n@@ -1019,2 +1010,2 @@\n-    \/\/ Block the thread\n-    SafepointMechanism::block_if_requested(thread());\n+    \/\/ Process pending operation\n+    SafepointMechanism::process_if_requested(thread());\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":29,"deletions":38,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2349,1 +2349,1 @@\n-      if (SafepointMechanism::should_block(self) &&\n+      if (SafepointMechanism::should_process(self) &&\n@@ -2543,1 +2543,1 @@\n-        assert(SafepointMechanism::should_block(self), \"sanity check\");\n+        assert(SafepointMechanism::should_process(self), \"sanity check\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1696,1 +1696,0 @@\n-  _array_for_gc = NULL;\n@@ -2619,3 +2618,11 @@\n-  set_thread_state(_thread_blocked);\n-  java_suspend_self();\n-  set_thread_state_fence(state);\n+\n+  do {\n+    set_thread_state(_thread_blocked);\n+    java_suspend_self();\n+    \/\/ The current thread could have been suspended again. We have to check for\n+    \/\/ suspend after restoring the saved state. Without this the current thread\n+    \/\/ might return to _thread_in_Java and execute bytecodes for an arbitrary\n+    \/\/ long time.\n+    set_thread_state_fence(state);\n+  } while (is_external_suspend());\n+\n@@ -2626,1 +2633,1 @@\n-    SafepointMechanism::block_if_requested(this);\n+    SafepointMechanism::process_if_requested(this);\n@@ -2656,1 +2663,1 @@\n-    SafepointMechanism::block_if_requested(thread);\n+    SafepointMechanism::process_if_requested(thread);\n@@ -3018,7 +3025,0 @@\n-    \/\/ traverse the registered growable array\n-    if (_array_for_gc != NULL) {\n-      for (int index = 0; index < _array_for_gc->length(); index++) {\n-        f->do_oop(_array_for_gc->adr_at(index));\n-      }\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1371,1 +1371,0 @@\n-#ifdef ASSERT\n@@ -1375,1 +1374,0 @@\n-#endif\n@@ -1970,7 +1968,0 @@\n-\n- private:\n-  GrowableArray<oop>* _array_for_gc;\n- public:\n-\n-  void register_array_for_gc(GrowableArray<oop>* array) { _array_for_gc = array; }\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -79,2 +79,0 @@\n-  template(UpdateForPopTopFrame)                  \\\n-  template(SetFramePop)                           \\\n@@ -86,1 +84,0 @@\n-  template(GetCurrentLocation)                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1848,0 +1848,4 @@\n+  declare_c2_type(CopySignDNode, Node)                                    \\\n+  declare_c2_type(CopySignFNode, Node)                                    \\\n+  declare_c2_type(SignumDNode, Node)                                      \\\n+  declare_c2_type(SignumFNode, Node)                                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-            m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);\n+            m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null, LM_TRUSTED);\n@@ -264,1 +264,2 @@\n-            linker = IMPL_NAMES.resolveOrFail(REF_invokeStatic, linker, null, NoSuchMethodException.class);\n+            linker = IMPL_NAMES.resolveOrFail(REF_invokeStatic, linker, null, LM_TRUSTED,\n+                                              NoSuchMethodException.class);\n@@ -796,1 +797,2 @@\n-            linker = IMPL_NAMES.resolveOrFail(REF_invokeVirtual, linker, null, NoSuchMethodException.class);\n+            linker = IMPL_NAMES.resolveOrFail(REF_invokeVirtual, linker, null, LM_TRUSTED,\n+                                              NoSuchMethodException.class);\n@@ -949,2 +951,3 @@\n-                            MemberName.getFactory()\n-                                    .resolveOrFail(REF_getField, member, DirectMethodHandle.class, NoSuchMethodException.class));\n+                            MemberName.getFactory().resolveOrFail(REF_getField, member,\n+                                                                  DirectMethodHandle.class, LM_TRUSTED,\n+                                                                  NoSuchMethodException.class));\n@@ -954,2 +957,3 @@\n-                        MemberName.getFactory()\n-                            .resolveOrFail(REF_invokeVirtual, member, DirectMethodHandle.class, NoSuchMethodException.class));\n+                        MemberName.getFactory().resolveOrFail(REF_invokeVirtual, member,\n+                                                              DirectMethodHandle.class, LM_TRUSTED,\n+                                                              NoSuchMethodException.class));\n@@ -973,2 +977,3 @@\n-            MemberName.getFactory()\n-                .resolveOrFail(REF_invokeStatic, member, DirectMethodHandle.class, NoSuchMethodException.class));\n+                MemberName.getFactory().resolveOrFail(REF_invokeStatic, member,\n+                                                      DirectMethodHandle.class, LM_TRUSTED,\n+                                                      NoSuchMethodException.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,4 @@\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.stream.Stream;\n@@ -36,2 +40,6 @@\n-import static java.lang.invoke.MethodTypeForm.LF_INVINTERFACE;\n-import static java.lang.invoke.MethodTypeForm.LF_INVVIRTUAL;\n+import static java.lang.invoke.LambdaForm.basicTypeSignature;\n+import static java.lang.invoke.LambdaForm.shortenSignature;\n+import static java.lang.invoke.LambdaForm.BasicType.*;\n+import static java.lang.invoke.MethodHandleStatics.TRACE_RESOLVE;\n+import static java.lang.invoke.MethodTypeForm.*;\n+import static java.lang.invoke.LambdaForm.Kind.*;\n@@ -44,0 +52,2 @@\n+    private static final String LF_RESOLVE = \"[LF_RESOLVE]\";\n+    private static final String SPECIES_RESOLVE = \"[SPECIES_RESOLVE]\";\n@@ -45,0 +55,302 @@\n+    static void traceLambdaForm(String name, MethodType type, Class<?> holder, MemberName resolvedMember) {\n+        if (TRACE_RESOLVE) {\n+            System.out.println(LF_RESOLVE + \" \" + holder.getName() + \" \" + name + \" \" +\n+                    shortenSignature(basicTypeSignature(type)) +\n+                    (resolvedMember != null ? \" (success)\" : \" (fail)\"));\n+        }\n+    }\n+\n+    static void traceSpeciesType(String cn, Class<?> salvage) {\n+        if (TRACE_RESOLVE) {\n+            System.out.println(SPECIES_RESOLVE + \" \" + cn + (salvage != null ? \" (salvaged)\" : \" (generated)\"));\n+        }\n+    }\n+\n+    \/\/ Map from DirectMethodHandle method type name to index to LambdForms\n+    static final Map<String, Integer> DMH_METHOD_TYPE_MAP =\n+            Map.of(\n+                    DIRECT_INVOKE_VIRTUAL.methodName,     LF_INVVIRTUAL,\n+                    DIRECT_INVOKE_STATIC.methodName,      LF_INVSTATIC,\n+                    DIRECT_INVOKE_SPECIAL.methodName,     LF_INVSPECIAL,\n+                    DIRECT_NEW_INVOKE_SPECIAL.methodName, LF_NEWINVSPECIAL,\n+                    DIRECT_INVOKE_INTERFACE.methodName,   LF_INVINTERFACE,\n+                    DIRECT_INVOKE_STATIC_INIT.methodName, LF_INVSTATIC_INIT,\n+                    DIRECT_INVOKE_SPECIAL_IFC.methodName, LF_INVSPECIAL_IFC\n+            );\n+\n+    static final String DIRECT_HOLDER = \"java\/lang\/invoke\/DirectMethodHandle$Holder\";\n+    static final String DELEGATING_HOLDER = \"java\/lang\/invoke\/DelegatingMethodHandle$Holder\";\n+    static final String BASIC_FORMS_HOLDER = \"java\/lang\/invoke\/LambdaForm$Holder\";\n+    static final String INVOKERS_HOLDER = \"java\/lang\/invoke\/Invokers$Holder\";\n+    static final String INVOKERS_HOLDER_CLASS_NAME = INVOKERS_HOLDER.replace('\/', '.');\n+    static final String BMH_SPECIES_PREFIX = \"java.lang.invoke.BoundMethodHandle$Species_\";\n+\n+    static class HolderClassBuilder {\n+\n+\n+        private final TreeSet<String> speciesTypes = new TreeSet<>();\n+        private final TreeSet<String> invokerTypes = new TreeSet<>();\n+        private final TreeSet<String> callSiteTypes = new TreeSet<>();\n+        private final Map<String, Set<String>> dmhMethods = new TreeMap<>();\n+\n+        HolderClassBuilder addSpeciesType(String type) {\n+            speciesTypes.add(expandSignature(type));\n+            return this;\n+        }\n+\n+        HolderClassBuilder addInvokerType(String methodType) {\n+            validateMethodType(methodType);\n+            invokerTypes.add(methodType);\n+            return this;\n+        }\n+\n+        HolderClassBuilder addCallSiteType(String csType) {\n+            validateMethodType(csType);\n+            callSiteTypes.add(csType);\n+            return this;\n+        }\n+\n+        Map<String, byte[]> build() {\n+            int count = 0;\n+            for (Set<String> entry : dmhMethods.values()) {\n+                count += entry.size();\n+            }\n+            MethodType[] directMethodTypes = new MethodType[count];\n+            int[] dmhTypes = new int[count];\n+            int index = 0;\n+            for (Map.Entry<String, Set<String>> entry : dmhMethods.entrySet()) {\n+                String dmhType = entry.getKey();\n+                for (String type : entry.getValue()) {\n+                    \/\/ The DMH type to actually ask for is retrieved by removing\n+                    \/\/ the first argument, which needs to be of Object.class\n+                    MethodType mt = asMethodType(type);\n+                    if (mt.parameterCount() < 1 ||\n+                            mt.parameterType(0) != Object.class) {\n+                        throw new RuntimeException(\n+                                \"DMH type parameter must start with L: \" + dmhType + \" \" + type);\n+                    }\n+\n+                    \/\/ Adapt the method type of the LF to retrieve\n+                    directMethodTypes[index] = mt.dropParameterTypes(0, 1);\n+\n+                    \/\/ invokeVirtual and invokeInterface must have a leading Object\n+                    \/\/ parameter, i.e., the receiver\n+                    dmhTypes[index] = DMH_METHOD_TYPE_MAP.get(dmhType);\n+                    if (dmhTypes[index] == LF_INVINTERFACE || dmhTypes[index] == LF_INVVIRTUAL) {\n+                        if (mt.parameterCount() < 2 ||\n+                                mt.parameterType(1) != Object.class) {\n+                            throw new RuntimeException(\n+                                    \"DMH type parameter must start with LL: \" + dmhType + \" \" + type);\n+                        }\n+                    }\n+                    index++;\n+                }\n+            }\n+\n+            \/\/ The invoker type to ask for is retrieved by removing the first\n+            \/\/ and the last argument, which needs to be of Object.class\n+            MethodType[] invokerMethodTypes = new MethodType[invokerTypes.size()];\n+            index = 0;\n+            for (String invokerType : invokerTypes) {\n+                MethodType mt = asMethodType(invokerType);\n+                final int lastParam = mt.parameterCount() - 1;\n+                if (mt.parameterCount() < 2 ||\n+                        mt.parameterType(0) != Object.class ||\n+                        mt.parameterType(lastParam) != Object.class) {\n+                    throw new RuntimeException(\n+                            \"Invoker type parameter must start and end with Object: \" + invokerType);\n+                }\n+                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                invokerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n+                index++;\n+            }\n+\n+            \/\/ The callSite type to ask for is retrieved by removing the last\n+            \/\/ argument, which needs to be of Object.class\n+            MethodType[] callSiteMethodTypes = new MethodType[callSiteTypes.size()];\n+            index = 0;\n+            for (String callSiteType : callSiteTypes) {\n+                MethodType mt = asMethodType(callSiteType);\n+                final int lastParam = mt.parameterCount() - 1;\n+                if (mt.parameterCount() < 1 ||\n+                        mt.parameterType(lastParam) != Object.class) {\n+                    throw new RuntimeException(\n+                            \"CallSite type parameter must end with Object: \" + callSiteType);\n+                }\n+                callSiteMethodTypes[index] = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                index++;\n+            }\n+\n+            Map<String, byte[]> result = new TreeMap<>();\n+            result.put(DIRECT_HOLDER,\n+                       generateDirectMethodHandleHolderClassBytes(\n+                            DIRECT_HOLDER, directMethodTypes, dmhTypes));\n+            result.put(DELEGATING_HOLDER,\n+                       generateDelegatingMethodHandleHolderClassBytes(\n+                            DELEGATING_HOLDER, directMethodTypes));\n+            result.put(INVOKERS_HOLDER,\n+                       generateInvokersHolderClassBytes(INVOKERS_HOLDER,\n+                            invokerMethodTypes, callSiteMethodTypes));\n+            result.put(BASIC_FORMS_HOLDER,\n+                       generateBasicFormsClassBytes(BASIC_FORMS_HOLDER));\n+\n+            speciesTypes.forEach(types -> {\n+                Map.Entry<String, byte[]> entry = generateConcreteBMHClassBytes(types);\n+                result.put(entry.getKey(), entry.getValue());\n+            });\n+\n+            \/\/ clear builder\n+            speciesTypes.clear();\n+            invokerTypes.clear();\n+            callSiteTypes.clear();\n+            dmhMethods.clear();\n+\n+            return result;\n+        }\n+\n+        private static MethodType asMethodType(String basicSignatureString) {\n+            String[] parts = basicSignatureString.split(\"_\");\n+            assert (parts.length == 2);\n+            assert (parts[1].length() == 1);\n+            String parameters = expandSignature(parts[0]);\n+            Class<?> rtype = simpleType(parts[1].charAt(0));\n+            if (parameters.isEmpty()) {\n+                return MethodType.methodType(rtype);\n+            } else {\n+                Class<?>[] ptypes = new Class<?>[parameters.length()];\n+                for (int i = 0; i < ptypes.length; i++) {\n+                    ptypes[i] = simpleType(parameters.charAt(i));\n+                }\n+                return MethodType.methodType(rtype, ptypes);\n+            }\n+        }\n+\n+        private void addDMHMethodType(String dmh, String methodType) {\n+            validateMethodType(methodType);\n+            Set<String> methodTypes = dmhMethods.get(dmh);\n+            if (methodTypes == null) {\n+                methodTypes = new TreeSet<>();\n+                dmhMethods.put(dmh, methodTypes);\n+            }\n+            methodTypes.add(methodType);\n+        }\n+\n+        private static void validateMethodType(String type) {\n+            String[] typeParts = type.split(\"_\");\n+            \/\/ check return type (second part)\n+            if (typeParts.length != 2 || typeParts[1].length() != 1\n+                    || !isBasicTypeChar(typeParts[1].charAt(0))) {\n+                throw new RuntimeException(\n+                        \"Method type signature must be of form [LJIFD]*_[LJIFDV]\");\n+            }\n+            \/\/ expand and check arguments (first part)\n+            expandSignature(typeParts[0]);\n+        }\n+\n+        \/\/ Convert LL -> LL, L3 -> LLL\n+        private static String expandSignature(String signature) {\n+            StringBuilder sb = new StringBuilder();\n+            char last = 'X';\n+            int count = 0;\n+            for (int i = 0; i < signature.length(); i++) {\n+                char c = signature.charAt(i);\n+                if (c >= '0' && c <= '9') {\n+                    count *= 10;\n+                    count += (c - '0');\n+                } else {\n+                    requireBasicType(c);\n+                    for (int j = 1; j < count; j++) {\n+                        sb.append(last);\n+                    }\n+                    sb.append(c);\n+                    last = c;\n+                    count = 0;\n+                }\n+            }\n+\n+            \/\/ ended with a number, e.g., \"L2\": append last char count - 1 times\n+            if (count > 1) {\n+                requireBasicType(last);\n+                for (int j = 1; j < count; j++) {\n+                    sb.append(last);\n+                }\n+            }\n+            return sb.toString();\n+        }\n+\n+        private static void requireBasicType(char c) {\n+            if (!isArgBasicTypeChar(c)) {\n+                throw new RuntimeException(\n+                        \"Character \" + c + \" must correspond to a basic field type: LIJFD\");\n+            }\n+        }\n+\n+        private static Class<?> simpleType(char c) {\n+            if (isBasicTypeChar(c)) {\n+                return LambdaForm.BasicType.basicType(c).basicTypeClass();\n+            }\n+            switch (c) {\n+                case 'Z':\n+                case 'B':\n+                case 'S':\n+                case 'C':\n+                    throw new IllegalArgumentException(\"Not a valid primitive: \" + c +\n+                            \" (use I instead)\");\n+                default:\n+                    throw new IllegalArgumentException(\"Not a primitive: \" + c);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Returns a map of class name in internal form to the corresponding class bytes\n+     * per the given stream of SPECIES_RESOLVE and LF_RESOLVE trace logs.\n+     *\n+     * Used by GenerateJLIClassesPlugin to pre-generate holder classes during\n+     * jlink phase.\n+     *\/\n+    static Map<String, byte[]> generateHolderClasses(Stream<String> traces)  {\n+        HolderClassBuilder builder = new HolderClassBuilder();\n+        traces.map(line -> line.split(\" \"))\n+                .forEach(parts -> {\n+                    switch (parts[0]) {\n+                        case SPECIES_RESOLVE:\n+                            \/\/ Allow for new types of species data classes being resolved here\n+                            assert parts.length == 3;\n+                            if (parts[1].startsWith(BMH_SPECIES_PREFIX)) {\n+                                String species = parts[1].substring(BMH_SPECIES_PREFIX.length());\n+                                if (!\"L\".equals(species)) {\n+                                    builder.addSpeciesType(species);\n+                                }\n+                            }\n+                            break;\n+                        case LF_RESOLVE:\n+                            assert parts.length > 3;\n+                            String methodType = parts[3];\n+                            if (parts[1].equals(INVOKERS_HOLDER_CLASS_NAME)) {\n+                                if (\"linkToTargetMethod\".equals(parts[2]) ||\n+                                        \"linkToCallSite\".equals(parts[2])) {\n+                                    builder.addCallSiteType(methodType);\n+                                } else {\n+                                    builder.addInvokerType(methodType);\n+                                }\n+                            } else if (parts[1].contains(\"DirectMethodHandle\")) {\n+                                String dmh = parts[2];\n+                                \/\/ ignore getObject etc for now (generated by default)\n+                                if (DMH_METHOD_TYPE_MAP.containsKey(dmh)) {\n+                                    builder.addDMHMethodType(dmh, methodType);\n+                                }\n+                            }\n+                            break;\n+                        default:\n+                            break; \/\/ ignore\n+                    }\n+                });\n+\n+        return builder.build();\n+    }\n+\n+    \/**\n+     * Returns a {@code byte[]} representation of a class implementing\n+     * the zero and identity forms of all {@code LambdaForm.BasicType}s.\n+     *\/\n@@ -71,0 +383,5 @@\n+    \/**\n+     * Returns a {@code byte[]} representation of a class implementing\n+     * DirectMethodHandle of each pairwise combination of {@code MethodType} and\n+     * an {@code int} representing method type.\n+     *\/\n@@ -118,0 +435,5 @@\n+    \/**\n+     * Returns a {@code byte[]} representation of a class implementing\n+     * DelegatingMethodHandles of each {@code MethodType} kind in the\n+     * {@code methodTypes} argument.\n+     *\/\n@@ -148,0 +470,5 @@\n+    \/**\n+     * Returns a {@code byte[]} representation of a class implementing\n+     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n+     * and {@code callSiteMethodTypes}.\n+     *\/\n@@ -196,4 +523,1 @@\n-    private static byte[] generateCodeBytesForLFs(String className,\n-            String[] names, LambdaForm[] forms) {\n-\n-\n+    private static byte[] generateCodeBytesForLFs(String className, String[] names, LambdaForm[] forms) {\n@@ -232,0 +556,4 @@\n+    \/**\n+     * Returns a {@code byte[]} representation of {@code BoundMethodHandle}\n+     * species class implementing the signature defined by {@code types}.\n+     *\/\n@@ -235,1 +563,1 @@\n-            if (\"LIJFD\".indexOf(c) < 0) {\n+            if (!isArgBasicTypeChar(c)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":336,"deletions":8,"binary":false,"changes":344,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import static java.lang.invoke.GenerateJLIClassesHelper.traceLambdaForm;\n@@ -325,1 +326,3 @@\n-            member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member, HOST_CLASS, ReflectiveOperationException.class);\n+            member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member,\n+                                                      HOST_CLASS, LM_TRUSTED,\n+                                                      ReflectiveOperationException.class);\n@@ -696,5 +699,2 @@\n-        MemberName resolvedMember = MemberName.getFactory().resolveOrNull(REF_invokeStatic, member, holder);\n-        if (TRACE_RESOLVE) {\n-            System.out.println(\"[LF_RESOLVE] \" + holder.getName() + \" \" + name + \" \" +\n-                    shortenSignature(basicTypeSignature(type)) + (resolvedMember != null ? \" (success)\" : \" (fail)\") );\n-        }\n+        MemberName resolvedMember = MemberName.getFactory().resolveOrNull(REF_invokeStatic, member, holder, LM_TRUSTED);\n+        traceLambdaForm(name, type, holder, resolvedMember);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static java.lang.invoke.MethodHandleNatives.Constants.REF_invokeStatic;\n+import static java.lang.invoke.MethodHandleNatives.Constants.*;\n@@ -1765,1 +1765,1 @@\n-                idMem = IMPL_NAMES.resolveOrFail(REF_invokeStatic, idMem, null, NoSuchMethodException.class);\n+                idMem = IMPL_NAMES.resolveOrFail(REF_invokeStatic, idMem, null, LM_TRUSTED, NoSuchMethodException.class);\n@@ -1768,1 +1768,1 @@\n-                    zeMem = IMPL_NAMES.resolveOrFail(REF_invokeStatic, zeMem, null, NoSuchMethodException.class);\n+                    zeMem = IMPL_NAMES.resolveOrFail(REF_invokeStatic, zeMem, null, LM_TRUSTED, NoSuchMethodException.class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1093,1 +1093,1 @@\n-        private MemberName resolve(byte refKind, MemberName ref, Class<?> lookupClass,\n+        private MemberName resolve(byte refKind, MemberName ref, Class<?> lookupClass, int allowedModes,\n@@ -1113,1 +1113,1 @@\n-                m = MethodHandleNatives.resolve(m, lookupClass, speculativeResolve);\n+                m = MethodHandleNatives.resolve(m, lookupClass, allowedModes, speculativeResolve);\n@@ -1137,2 +1137,3 @@\n-                MemberName resolveOrFail(byte refKind, MemberName m, Class<?> lookupClass,\n-                                 Class<NoSuchMemberException> nsmClass)\n+                MemberName resolveOrFail(byte refKind, MemberName m,\n+                                         Class<?> lookupClass, int allowedModes,\n+                                         Class<NoSuchMemberException> nsmClass)\n@@ -1140,1 +1141,2 @@\n-            MemberName result = resolve(refKind, m, lookupClass, false);\n+            assert lookupClass != null || allowedModes == LM_TRUSTED;\n+            MemberName result = resolve(refKind, m, lookupClass, allowedModes, false);\n@@ -1153,2 +1155,3 @@\n-        public MemberName resolveOrNull(byte refKind, MemberName m, Class<?> lookupClass) {\n-            MemberName result = resolve(refKind, m, lookupClass, true);\n+        public MemberName resolveOrNull(byte refKind, MemberName m, Class<?> lookupClass, int allowedModes) {\n+            assert lookupClass != null || allowedModes == LM_TRUSTED;\n+            MemberName result = resolve(refKind, m, lookupClass, allowedModes, true);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1767,35 +1767,2 @@\n-            public byte[] generateDirectMethodHandleHolderClassBytes(\n-                    String className, MethodType[] methodTypes, int[] types) {\n-                return GenerateJLIClassesHelper\n-                        .generateDirectMethodHandleHolderClassBytes(\n-                                className, methodTypes, types);\n-            }\n-\n-            @Override\n-            public byte[] generateDelegatingMethodHandleHolderClassBytes(\n-                    String className, MethodType[] methodTypes) {\n-                return GenerateJLIClassesHelper\n-                        .generateDelegatingMethodHandleHolderClassBytes(\n-                                className, methodTypes);\n-            }\n-\n-            @Override\n-            public Map.Entry<String, byte[]> generateConcreteBMHClassBytes(\n-                    final String types) {\n-                return GenerateJLIClassesHelper\n-                        .generateConcreteBMHClassBytes(types);\n-            }\n-\n-            @Override\n-            public byte[] generateBasicFormsClassBytes(final String className) {\n-                return GenerateJLIClassesHelper\n-                        .generateBasicFormsClassBytes(className);\n-            }\n-\n-            @Override\n-            public byte[] generateInvokersHolderClassBytes(final String className,\n-                    MethodType[] invokerMethodTypes,\n-                    MethodType[] callSiteMethodTypes) {\n-                return GenerateJLIClassesHelper\n-                        .generateInvokersHolderClassBytes(className,\n-                                invokerMethodTypes, callSiteMethodTypes);\n+            public Map<String, byte[]> generateHolderClasses(Stream<String> traces) {\n+                return GenerateJLIClassesHelper.generateHolderClasses(traces);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":2,"deletions":35,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    static native MemberName resolve(MemberName self, Class<?> caller,\n+    static native MemberName resolve(MemberName self, Class<?> caller, int lookupMode,\n@@ -152,0 +152,9 @@\n+\n+        \/**\n+         * Lookup modes\n+         *\/\n+        static final int\n+            LM_MODULE        = Lookup.MODULE,\n+            LM_UNCONDITIONAL = Lookup.UNCONDITIONAL,\n+            LM_TRUSTED       = -1;\n+\n@@ -564,1 +573,1 @@\n-                                                           VarHandleGuards.class);\n+                                                           VarHandleGuards.class, LM_TRUSTED);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1412,8 +1412,1 @@\n-            if (allowedModes == TRUSTED) {\n-                return null;\n-            }\n-            if (allowedModes == UNCONDITIONAL) {\n-                \/\/ use Object as the caller to pass to VM doing resolution\n-                return Object.class;\n-            }\n-            return lookupClass;\n+            return (allowedModes == TRUSTED) ? null : lookupClass;\n@@ -3469,1 +3462,1 @@\n-            return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(),\n+            return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(), allowedModes,\n@@ -3478,1 +3471,1 @@\n-            return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(),\n+            return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(), allowedModes,\n@@ -3486,1 +3479,1 @@\n-            return IMPL_NAMES.resolveOrFail(refKind, member, lookupClassOrNull(),\n+            return IMPL_NAMES.resolveOrFail(refKind, member, lookupClassOrNull(), allowedModes,\n@@ -3497,1 +3490,1 @@\n-            return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());\n+            return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull(), allowedModes);\n@@ -3803,1 +3796,1 @@\n-                    m2 = IMPL_NAMES.resolveOrNull(refKind, m2, lookupClassOrNull());\n+                    m2 = IMPL_NAMES.resolveOrNull(refKind, m2, lookupClassOrNull(), allowedModes);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.stream.Stream;\n@@ -71,4 +72,4 @@\n-     * Returns a {@code byte[]} representation of a class implementing\n-     * DirectMethodHandle of each pairwise combination of {@code MethodType} and\n-     * an {@code int} representing method type.  Used by\n-     * GenerateJLIClassesPlugin to generate such a class during the jlink phase.\n+     * Returns a map of class name in internal forms to its corresponding\n+     * class bytes per the given stream of LF_RESOLVE and SPECIES_RESOLVE\n+     * trace logs. Used by GenerateJLIClassesPlugin to enable generation\n+     * of such classes during the jlink phase.\n@@ -76,36 +77,1 @@\n-    byte[] generateDirectMethodHandleHolderClassBytes(String className,\n-            MethodType[] methodTypes, int[] types);\n-\n-    \/**\n-     * Returns a {@code byte[]} representation of a class implementing\n-     * DelegatingMethodHandles of each {@code MethodType} kind in the\n-     * {@code methodTypes} argument.  Used by GenerateJLIClassesPlugin to\n-     * generate such a class during the jlink phase.\n-     *\/\n-    byte[] generateDelegatingMethodHandleHolderClassBytes(String className,\n-            MethodType[] methodTypes);\n-\n-    \/**\n-     * Returns a {@code byte[]} representation of {@code BoundMethodHandle}\n-     * species class implementing the signature defined by {@code types}. Used\n-     * by GenerateJLIClassesPlugin to enable generation of such classes during\n-     * the jlink phase. Should do some added validation since this string may be\n-     * user provided.\n-     *\/\n-    Map.Entry<String, byte[]> generateConcreteBMHClassBytes(\n-            final String types);\n-\n-    \/**\n-     * Returns a {@code byte[]} representation of a class implementing\n-     * the zero and identity forms of all {@code LambdaForm.BasicType}s.\n-     *\/\n-    byte[] generateBasicFormsClassBytes(final String className);\n-\n-    \/**\n-     * Returns a {@code byte[]} representation of a class implementing\n-     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n-     * and {@code callSiteMethodTypes}.\n-     *\/\n-    byte[] generateInvokersHolderClassBytes(String className,\n-            MethodType[] invokerMethodTypes,\n-            MethodType[] callSiteMethodTypes);\n+    Map<String, byte[]> generateHolderClasses(Stream<String> traces);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":6,"deletions":40,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1101,1 +1101,1 @@\n-                            log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);\n+                            log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor(env.enclClass.sym));\n@@ -5213,1 +5213,1 @@\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));\n+                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n@@ -5226,1 +5226,3 @@\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));\n+                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                    Errors.ClassInUnnamedModuleCantExtendSealedInDiffPackage(c)\n+                            );\n@@ -5229,1 +5231,3 @@\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree), Errors.CantInheritFromSealed(c));\n+                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                Errors.ClassInModuleCantExtendSealedInDiffModule(c, c.packge().modle)\n+                        );\n@@ -5268,1 +5272,1 @@\n-                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed);\n+                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed(c.isAnonymous() ? Fragments.Anonymous : Fragments.Local));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3622,0 +3622,3 @@\n+            } else if (target == names.MODULE) {\n+                if (s.kind == MDL)\n+                    applicableTargets.add(names.MODULE);\n@@ -3750,1 +3753,2 @@\n-                && (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)) {\n+                && (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)\n+                && s.kind != Kind.PCK) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3624,1 +3624,1 @@\n-                checkNoMods(mods.flags);\n+                checkNoMods(mods.flags & ~Flags.DEPRECATED);\n@@ -3935,1 +3935,2 @@\n-                                .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags & Flags.VARARGS, param.mods.annotations),\n+                                .VarDef(F.Modifiers(Flags.PARAMETER | Flags.GENERATED_MEMBER | param.mods.flags & Flags.VARARGS,\n+                                        param.mods.annotations),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3502,1 +3502,10 @@\n-    class is not allowed to extend sealed class: {0}\n+    class is not allowed to extend sealed class: {0} \\\n+    (as it is not listed in its 'permits' clause)\n+\n+# 0: symbol\n+compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package=\\\n+    class {0} in unnamed module cannot extend a sealed class in a different package\n+\n+# 0: symbol, 1: symbol\n+compiler.err.class.in.module.cant.extend.sealed.in.diff.module=\\\n+    class {0} in module {1} cannot extend a sealed class in a different module\n@@ -3518,0 +3527,1 @@\n+# 0: fragment\n@@ -3519,1 +3529,7 @@\n-    local classes must not extend sealed classes\n+    {0} classes must not extend sealed classes\\\n+\n+compiler.misc.anonymous=\\\n+    anonymous\n+\n+compiler.misc.local=\\\n+    local\n@@ -3601,0 +3617,1 @@\n+# 0: symbol\n@@ -3602,1 +3619,1 @@\n-    constructor is not canonical, so its first statement must invoke another constructor\n+    constructor is not canonical, so its first statement must invoke another constructor of class {0}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -434,0 +434,4 @@\n+                            \"java\/lang\/Math.copySign(DD)D\",\n+                            \"java\/lang\/Math.copySign(FF)F\",\n+                            \"java\/lang\/Math.signum(D)D\",\n+                            \"java\/lang\/Math.signum(F)F\",\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot.test\/src\/org\/graalvm\/compiler\/hotspot\/test\/CheckGraalIntrinsics.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}