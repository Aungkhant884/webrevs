{"files":[{"patch":"@@ -6,1 +6,1 @@\n-error=author,committer,merge,executable,symlink,hg-tag,whitespace\n+error=author,committer,merge,executable,symlink,whitespace,problemlists\n@@ -12,5 +12,1 @@\n-[repository]\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\\\.(?:0|[1-9][0-9]*)){0,4})(?:\\\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\\\d{1,3})?-(?:(?:b\\\\d{2,3})|(?:ga)))|(?:hs\\\\d\\\\d(?:\\\\.\\\\d{1,2})?-b\\\\d\\\\d)\n-branches=lworld\n-\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm\n@@ -27,0 +23,3 @@\n+\n+[checks \"problemlists\"]\n+dirs=test\/jdk|test\/langtools|test\/lib-test|test\/hotspot\/jtreg|test\/jaxp\n","filename":".jcheck\/conf","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -617,2 +617,2 @@\n-\/\/ 2) reg_class compiler_method_oop_reg    ( \/* as def'd in frame section *\/ )\n-\/\/ 2) reg_class interpreter_method_oop_reg ( \/* as def'd in frame section *\/ )\n+\/\/ 2) reg_class compiler_method_reg        ( \/* as def'd in frame section *\/ )\n+\/\/ 2) reg_class interpreter_method_reg     ( \/* as def'd in frame section *\/ )\n@@ -2455,6 +2455,0 @@\n-int Matcher::regnum_to_fpu_offset(int regnum)\n-{\n-  Unimplemented();\n-  return 0;\n-}\n-\n@@ -4087,3 +4081,0 @@\n-  \/\/ What direction does stack grow in (assumed to be same for C & Java)\n-  stack_direction(TOWARDS_LOW);\n-\n@@ -4096,2 +4087,2 @@\n-  \/\/ Method Oop Register when calling interpreter.\n-  interpreter_method_oop_reg(R12);\n+  \/\/ Method Register when calling interpreter.\n+  interpreter_method_reg(R12);\n@@ -5666,1 +5657,1 @@\n-operand interpreter_method_oop_RegP(iRegP reg)\n+operand interpreter_method_RegP(iRegP reg)\n@@ -5668,1 +5659,1 @@\n-  constraint(ALLOC_IN_RC(method_reg)); \/\/ interpreter_method_oop_reg\n+  constraint(ALLOC_IN_RC(method_reg)); \/\/ interpreter_method_reg\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -81,7 +81,5 @@\n-#define ARCH_FLAGS(develop, \\\n-                   product, \\\n-                   diagnostic, \\\n-                   experimental, \\\n-                   notproduct, \\\n-                   range, \\\n-                   constraint) \\\n+#define ARCH_FLAGS(develop,                                             \\\n+                   product,                                             \\\n+                   notproduct,                                          \\\n+                   range,                                               \\\n+                   constraint)                                          \\\n@@ -119,0 +117,2 @@\n+\/\/ end of ARCH_FLAGS\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -81,7 +81,5 @@\n-#define ARCH_FLAGS(develop,      \\\n-                   product,      \\\n-                   diagnostic,   \\\n-                   experimental, \\\n-                   notproduct,   \\\n-                   range,        \\\n-                   constraint)   \\\n+#define ARCH_FLAGS(develop,                                                 \\\n+                   product,                                                 \\\n+                   notproduct,                                              \\\n+                   range,                                                   \\\n+                   constraint)                                              \\\n@@ -142,6 +140,0 @@\n-  product(bool, UsePower6SchedulerPPC64, false,                             \\\n-          \"Use Power6 Scheduler.\")                                          \\\n-                                                                            \\\n-  product(bool, InsertEndGroupPPC64, false,                                 \\\n-          \"Insert EndGroup instructions to optimize for Power6.\")           \\\n-                                                                            \\\n@@ -167,1 +159,1 @@\n-  experimental(bool, UseRTMForStackLocks, false,                            \\\n+  product(bool, UseRTMForStackLocks, false, EXPERIMENTAL,                   \\\n@@ -177,1 +169,1 @@\n-  experimental(int, RTMSpinLoopCount, 100,                                  \\\n+  product(int, RTMSpinLoopCount, 100, EXPERIMENTAL,                         \\\n@@ -181,1 +173,1 @@\n-  experimental(int, RTMAbortThreshold, 1000,                                \\\n+  product(int, RTMAbortThreshold, 1000, EXPERIMENTAL,                       \\\n@@ -185,1 +177,1 @@\n-  experimental(int, RTMLockingThreshold, 10000,                             \\\n+  product(int, RTMLockingThreshold, 10000, EXPERIMENTAL,                    \\\n@@ -190,1 +182,1 @@\n-  experimental(int, RTMAbortRatio, 50,                                      \\\n+  product(int, RTMAbortRatio, 50, EXPERIMENTAL,                             \\\n@@ -194,1 +186,1 @@\n-  experimental(int, RTMTotalCountIncrRate, 64,                              \\\n+  product(int, RTMTotalCountIncrRate, 64, EXPERIMENTAL,                     \\\n@@ -199,1 +191,1 @@\n-  experimental(intx, RTMLockingCalculationDelay, 0,                         \\\n+  product(intx, RTMLockingCalculationDelay, 0, EXPERIMENTAL,                \\\n@@ -203,2 +195,4 @@\n-  experimental(bool, UseRTMXendForLockBusy, true,                           \\\n-          \"Use RTM Xend instead of Xabort when lock busy\")                  \\\n+  product(bool, UseRTMXendForLockBusy, true, EXPERIMENTAL,                  \\\n+          \"Use RTM Xend instead of Xabort when lock busy\")\n+\n+\/\/ end of ARCH_FLAGS\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -95,7 +95,5 @@\n-#define ARCH_FLAGS(develop, \\\n-                   product, \\\n-                   diagnostic, \\\n-                   experimental, \\\n-                   notproduct, \\\n-                   range, \\\n-                   constraint) \\\n+#define ARCH_FLAGS(develop,                                                 \\\n+                   product,                                                 \\\n+                   notproduct,                                              \\\n+                   range,                                                   \\\n+                   constraint)                                              \\\n@@ -120,1 +118,1 @@\n-  diagnostic(bool, UseIncDec, true,                                         \\\n+  product(bool, UseIncDec, true, DIAGNOSTIC,                                \\\n@@ -154,1 +152,1 @@\n-  experimental(bool, UseRTMForStackLocks, false,                            \\\n+  product(bool, UseRTMForStackLocks, false, EXPERIMENTAL,                   \\\n@@ -164,1 +162,1 @@\n-  experimental(int, RTMSpinLoopCount, 100,                                  \\\n+  product(int, RTMSpinLoopCount, 100, EXPERIMENTAL,                         \\\n@@ -168,1 +166,1 @@\n-  experimental(int, RTMAbortThreshold, 1000,                                \\\n+  product(int, RTMAbortThreshold, 1000, EXPERIMENTAL,                       \\\n@@ -172,1 +170,1 @@\n-  experimental(int, RTMLockingThreshold, 10000,                             \\\n+  product(int, RTMLockingThreshold, 10000, EXPERIMENTAL,                    \\\n@@ -177,1 +175,1 @@\n-  experimental(int, RTMAbortRatio, 50,                                      \\\n+  product(int, RTMAbortRatio, 50, EXPERIMENTAL,                             \\\n@@ -181,1 +179,1 @@\n-  experimental(int, RTMTotalCountIncrRate, 64,                              \\\n+  product(int, RTMTotalCountIncrRate, 64, EXPERIMENTAL,                     \\\n@@ -186,1 +184,1 @@\n-  experimental(intx, RTMLockingCalculationDelay, 0,                         \\\n+  product(intx, RTMLockingCalculationDelay, 0, EXPERIMENTAL,                \\\n@@ -190,1 +188,1 @@\n-  experimental(bool, UseRTMXendForLockBusy, true,                           \\\n+  product(bool, UseRTMXendForLockBusy, true, EXPERIMENTAL,                  \\\n@@ -209,1 +207,1 @@\n-  diagnostic(bool, UseLibmIntrinsic, true,                                  \\\n+  product(bool, UseLibmIntrinsic, true, DIAGNOSTIC,                         \\\n@@ -216,1 +214,1 @@\n-  diagnostic(int, AVX3Threshold, 4096,                                      \\\n+  product(int, AVX3Threshold, 4096, DIAGNOSTIC,                             \\\n@@ -222,1 +220,1 @@\n-  diagnostic(bool, IntelJccErratumMitigation, true,                         \\\n+  product(bool, IntelJccErratumMitigation, true, DIAGNOSTIC,                \\\n@@ -226,0 +224,2 @@\n+\/\/ end of ARCH_FLAGS\n+\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -134,2 +134,2 @@\n-\/\/ 2) reg_class compiler_method_oop_reg    ( \/* as def'd in frame section *\/ )\n-\/\/ 2) reg_class interpreter_method_oop_reg ( \/* as def'd in frame section *\/ )\n+\/\/ 2) reg_class compiler_method_reg        ( \/* as def'd in frame section *\/ )\n+\/\/ 2) reg_class interpreter_method_reg     ( \/* as def'd in frame section *\/ )\n@@ -1371,4 +1371,0 @@\n-int Matcher::regnum_to_fpu_offset(int regnum) {\n-  return regnum - 32; \/\/ The FP registers are in the second chunk\n-}\n-\n@@ -1931,1 +1927,1 @@\n-\/\/     \/\/ int imo_reg    = Matcher::interpreter_method_oop_reg();\n+\/\/     \/\/ int imo_reg    = Matcher::interpreter_method_reg();\n@@ -3191,3 +3187,0 @@\n-  \/\/ What direction does stack grow in (assumed to be same for C & Java)\n-  stack_direction(TOWARDS_LOW);\n-\n@@ -3197,1 +3190,1 @@\n-  interpreter_method_oop_reg(EBX);      \/\/ Method Oop Register when calling interpreter\n+  interpreter_method_reg(EBX);          \/\/ Method Register when calling interpreter\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -164,2 +164,2 @@\n-\/\/ 2) reg_class compiler_method_oop_reg    ( \/* as def'd in frame section *\/ )\n-\/\/ 2) reg_class interpreter_method_oop_reg ( \/* as def'd in frame section *\/ )\n+\/\/ 2) reg_class compiler_method_reg        ( \/* as def'd in frame section *\/ )\n+\/\/ 2) reg_class interpreter_method_reg     ( \/* as def'd in frame section *\/ )\n@@ -1573,5 +1573,0 @@\n-int Matcher::regnum_to_fpu_offset(int regnum)\n-{\n-  return regnum - 32; \/\/ The FP registers are in the second chunk\n-}\n-\n@@ -2735,3 +2730,0 @@\n-  \/\/ What direction does stack grow in (assumed to be same for C & Java)\n-  stack_direction(TOWARDS_LOW);\n-\n@@ -2741,1 +2733,1 @@\n-  interpreter_method_oop_reg(RBX);      \/\/ Method Oop Register when\n+  interpreter_method_reg(RBX);          \/\/ Method Register when\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -79,7 +79,5 @@\n-#define ARCH_FLAGS(develop, \\\n-                   product, \\\n-                   diagnostic, \\\n-                   experimental, \\\n-                   notproduct, \\\n-                   range, \\\n-                   constraint)  \\\n+#define ARCH_FLAGS(develop,                                                 \\\n+                   product,                                                 \\\n+                   notproduct,                                              \\\n+                   range,                                                   \\\n+                   constraint)                                              \\\n@@ -91,2 +89,3 @@\n-          \"Use fast method entry code for accessor methods\")                \\\n-                                                                            \\\n+          \"Use fast method entry code for accessor methods\")\n+\n+\/\/ end of ARCH_FLAGS\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-                                                                       KILL_COMPILE_ON_FATAL_(fail_type));\n+                                                                       CHECK_AND_CLEAR_(fail_type));\n@@ -460,1 +460,1 @@\n-                                                           KILL_COMPILE_ON_FATAL_(fail_type));\n+                                                           CHECK_AND_CLEAR_(fail_type));\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -430,1 +430,1 @@\n-  LinkResolver::resolve_field(result, link_info, bc, false, KILL_COMPILE_ON_FATAL_(false));\n+  LinkResolver::resolve_field(result, link_info, bc, false, CHECK_AND_CLEAR_(false));\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1274,1 +1274,1 @@\n-    bool has_unloaded = Method::has_unloaded_classes_in_signature(m, (JavaThread *)THREAD);\n+    bool has_unloaded = Method::has_unloaded_classes_in_signature(m, thread);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1647,1 +1647,2 @@\n-    ModuleEntry* jb_module = null_cld_modules->locked_create_entry(Handle(),\n+    if (ModuleEntryTable::javabase_moduleEntry() == NULL) {  \/\/ may have been inited by CDS.\n+      ModuleEntry* jb_module = null_cld_modules->locked_create_entry(Handle(),\n@@ -1649,2 +1650,4 @@\n-    if (jb_module == NULL) {\n-      vm_exit_during_initialization(\"Unable to create ModuleEntry for \" JAVA_BASE_NAME);\n+      if (jb_module == NULL) {\n+        vm_exit_during_initialization(\"Unable to create ModuleEntry for \" JAVA_BASE_NAME);\n+      }\n+      ModuleEntryTable::set_javabase_moduleEntry(jb_module);\n@@ -1652,1 +1655,0 @@\n-    ModuleEntryTable::set_javabase_moduleEntry(jb_module);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -413,2 +413,1 @@\n-    assert(THREAD->is_Java_thread(), \"must be java thread\");\n-    JavaThread* thread = (JavaThread*)THREAD;\n+    JavaThread* thread = THREAD->as_Java_thread();\n@@ -440,2 +439,1 @@\n-  { JavaThread* thread = (JavaThread*)THREAD;\n-    assert(thread->is_Java_thread(), \"must be java thread\");\n+  { JavaThread* thread = THREAD->as_Java_thread();\n@@ -2441,1 +2439,1 @@\n-  JavaThread* thread = (JavaThread*)THREAD;\n+  JavaThread* thread = THREAD->as_Java_thread();\n@@ -3419,1 +3417,1 @@\n-ModuleEntry* java_lang_Module::module_entry(oop module) {\n+ModuleEntry* java_lang_Module::module_entry_raw(oop module) {\n@@ -3425,0 +3423,5 @@\n+  return module_entry;\n+}\n+\n+ModuleEntry* java_lang_Module::module_entry(oop module) {\n+  ModuleEntry* module_entry = module_entry_raw(module);\n@@ -4919,2 +4922,1 @@\n-      klass == SystemDictionary::Module_klass() ||       \/\/ Module::module_entry is malloc'ed\n-      \/\/ regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes\n+      \/\/ regular Java code. The implementation of java.lang.invoke uses generated anonymous classes\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -802,0 +802,1 @@\n+    static ModuleEntry* module_entry_raw(oop module);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -619,1 +619,1 @@\n-      = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);\n+      = ObjectSynchronizer::current_thread_holds_lock(THREAD->as_Java_thread(), lockObject);\n@@ -952,3 +952,1 @@\n-            Thread *thread = THREAD;\n-            assert(thread->is_Java_thread(), \"thread->is_Java_thread()\");\n-            JvmtiExport::post_class_load((JavaThread *) thread, k);\n+            JvmtiExport::post_class_load(THREAD->as_Java_thread(), k);\n@@ -1138,2 +1136,1 @@\n-        assert(THREAD->is_Java_thread(), \"thread->is_Java_thread()\");\n-        JvmtiExport::post_class_load((JavaThread *) THREAD, k);\n+      JvmtiExport::post_class_load(THREAD->as_Java_thread(), k);\n@@ -1677,2 +1674,1 @@\n-    assert(THREAD->is_Java_thread(), \"must be a JavaThread\");\n-    JavaThread* jt = (JavaThread*) THREAD;\n+    JavaThread* jt = THREAD->as_Java_thread();\n@@ -1741,9 +1737,9 @@\n- \/\/ for bootstrap and other parallel classloaders don't acquire lock,\n- \/\/ use placeholder token\n- \/\/ If a parallelCapable class loader calls define_instance_class instead of\n- \/\/ find_or_define_instance_class to get here, we have a timing\n- \/\/ hole with systemDictionary updates and check_constraints\n- if (!class_loader_h.is_null() && !is_parallelCapable(class_loader_h)) {\n-    assert(ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD,\n-         compute_loader_lock_object(class_loader_h, THREAD)),\n-         \"define called without lock\");\n+  \/\/ for bootstrap and other parallel classloaders don't acquire lock,\n+  \/\/ use placeholder token\n+  \/\/ If a parallelCapable class loader calls define_instance_class instead of\n+  \/\/ find_or_define_instance_class to get here, we have a timing\n+  \/\/ hole with systemDictionary updates and check_constraints\n+  if (!class_loader_h.is_null() && !is_parallelCapable(class_loader_h)) {\n+    assert(ObjectSynchronizer::current_thread_holds_lock(THREAD->as_Java_thread(),\n+           compute_loader_lock_object(class_loader_h, THREAD)),\n+           \"define called without lock\");\n@@ -1799,3 +1795,1 @@\n-      assert(THREAD->is_Java_thread(), \"thread->is_Java_thread()\");\n-      JvmtiExport::post_class_load((JavaThread *) THREAD, k);\n-\n+    JvmtiExport::post_class_load(THREAD->as_Java_thread(), k);\n@@ -1926,1 +1920,1 @@\n-  if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)\n+  if (ObjectSynchronizer::query_lock_ownership(THREAD->as_Java_thread(), loader_lock)\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":15,"deletions":21,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -193,0 +193,1 @@\n+  do_klass(jdk_internal_loader_BuiltinClassLoader_klass,jdk_internal_loader_BuiltinClassLoader                ) \\\n@@ -197,0 +198,2 @@\n+  do_klass(ConcurrentHashMap_klass,                     java_util_concurrent_ConcurrentHashMap                ) \\\n+  do_klass(ArrayList_klass,                             java_util_ArrayList                                   ) \\\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  JavaThread* jt = (JavaThread*)THREAD;\n+  JavaThread* jt = THREAD->as_Java_thread();\n@@ -300,1 +300,1 @@\n-  JavaThread* thread = (JavaThread*)THREAD;\n+  JavaThread* thread = THREAD->as_Java_thread();\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+  template(jdk_internal_loader_BuiltinClassLoader,    \"jdk\/internal\/loader\/BuiltinClassLoader\")   \\\n@@ -673,0 +674,2 @@\n+  template(java_util_concurrent_ConcurrentHashMap, \"java\/util\/concurrent\/ConcurrentHashMap\")                      \\\n+  template(java_util_ArrayList,                    \"java\/util\/ArrayList\")                                         \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -252,5 +252,0 @@\n-#if INCLUDE_JVMCI\n-  if (task->is_blocking() && CompileBroker::compiler(task->comp_level())->is_jvmci()) {\n-    task->set_jvmci_compiler_thread(thread);\n-  }\n-#endif\n@@ -280,1 +275,1 @@\n-        task->set_jvmci_compiler_thread(NULL);\n+        task->set_blocking_jvmci_compile_state(NULL);\n@@ -609,4 +604,1 @@\n-    \/\/ register serializer, phases will be added later lazily.\n-    GrowableArray<const char*>* jvmci_phase_names = new GrowableArray<const char*>(1);\n-    jvmci_phase_names->append(\"NOT_A_PHASE_NAME\");\n-    CompilerEvent::PhaseEvent::register_phases(jvmci_phase_names);\n+    CompilerEvent::PhaseEvent::get_phase_id(\"NOT_A_PHASE_NAME\", false, false, false);\n@@ -619,1 +611,2 @@\n-      c2_phase_names->append(CompilerPhaseTypeHelper::to_string((CompilerPhaseType)i));\n+      const char* phase_name = CompilerPhaseTypeHelper::to_string((CompilerPhaseType) i);\n+      CompilerEvent::PhaseEvent::get_phase_id(phase_name, false, false, false);\n@@ -621,1 +614,0 @@\n-    CompilerEvent::PhaseEvent::register_phases(c2_phase_names);\n@@ -1186,1 +1178,1 @@\n-        vframeStream vfst((JavaThread*) thread);\n+        vframeStream vfst(thread->as_Java_thread());\n@@ -1607,1 +1599,2 @@\n-  int methods_compiled = jvmci->methods_compiled();\n+  jint thread_jvmci_compilation_ticks = 0;\n+  jint global_jvmci_compilation_ticks = jvmci->global_compilation_ticks();\n@@ -1610,1 +1603,1 @@\n-    CompilerThread* jvmci_compiler_thread = task->jvmci_compiler_thread();\n+    JVMCICompileState* jvmci_compile_state = task->blocking_jvmci_compile_state();\n@@ -1613,4 +1606,5 @@\n-    if (jvmci_compiler_thread != NULL) {\n-      \/\/ If the JVMCI compiler thread is not blocked or suspended, we deem it to be making progress.\n-      progress = jvmci_compiler_thread->thread_state() != _thread_blocked &&\n-        !jvmci_compiler_thread->is_external_suspend();\n+    if (jvmci_compile_state != NULL) {\n+      jint ticks = jvmci_compile_state->compilation_ticks();\n+      progress = (ticks - thread_jvmci_compilation_ticks) != 0;\n+      JVMCI_event_1(\"waiting on compilation %d [ticks=%d]\", task->compile_id(), ticks);\n+      thread_jvmci_compilation_ticks = ticks;\n@@ -1619,2 +1613,2 @@\n-      \/\/ that all JVMCI compiler threads are blocked on. We use the counter for\n-      \/\/ successful JVMCI compilations to determine whether JVMCI compilation\n+      \/\/ that all JVMCI compiler threads are blocked on. We use the global JVMCI\n+      \/\/ compilation ticks to determine whether JVMCI compilation\n@@ -1622,1 +1616,4 @@\n-      progress = jvmci->methods_compiled() != methods_compiled;\n+      jint ticks = jvmci->global_compilation_ticks();\n+      progress = (ticks - global_jvmci_compilation_ticks) != 0;\n+      JVMCI_event_1(\"waiting on compilation %d to be queued [ticks=%d]\", task->compile_id(), ticks);\n+      global_jvmci_compilation_ticks = ticks;\n@@ -1630,0 +1627,1 @@\n+        JVMCI_event_1(\"waiting on compilation %d timed out\", task->compile_id());\n@@ -1634,3 +1632,0 @@\n-      if (jvmci_compiler_thread == NULL) {\n-        methods_compiled = jvmci->methods_compiled();\n-      }\n@@ -2155,1 +2150,1 @@\n-    JVMCICompileState compile_state(task);\n+    JVMCICompileState compile_state(task, jvmci);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":21,"deletions":26,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1047,1 +1047,1 @@\n-  Universe::update_heap_info_at_gc();\n+  Universe::heap()->update_capacity_and_used_at_gc();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,0 +113,4 @@\n+  \/\/ Historic gc information\n+  size_t _capacity_at_last_gc;\n+  size_t _used_at_last_gc;\n+\n@@ -242,0 +246,5 @@\n+  \/\/ Historic gc information\n+  size_t free_at_last_gc() const { return _capacity_at_last_gc - _used_at_last_gc; }\n+  size_t used_at_last_gc() const { return _used_at_last_gc; }\n+  void update_capacity_and_used_at_gc();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  _global_compilation_ticks = 0;\n@@ -89,1 +90,1 @@\n-      ((JavaThread*)THREAD)->sleep(100);\n+      THREAD->as_Java_thread()->sleep(100);\n@@ -160,0 +161,9 @@\n+\n+void JVMCICompiler::inc_methods_compiled() {\n+  Atomic::inc(&_methods_compiled);\n+  Atomic::inc(&_global_compilation_ticks);\n+}\n+\n+void JVMCICompiler::inc_global_compilation_ticks() {\n+  Atomic::inc(&_global_compilation_ticks);\n+}\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-  JNI_JVMCIENV(thread, env);\n+  JNI_JVMCIENV(JVMCI::compilation_tick(thread), env);\n@@ -143,2 +143,1 @@\n-  assert(thread->is_Java_thread(), \"must be\");\n-  return (JavaThread*) thread;\n+  return thread->as_Java_thread();\n@@ -2643,1 +2642,1 @@\n-C2V_VMENTRY_0(jint, registerCompilerPhases, (JNIEnv* env, jobject, jobjectArray jphases))\n+C2V_VMENTRY_0(jint, registerCompilerPhase, (JNIEnv* env, jobject, jstring jphase_name))\n@@ -2645,11 +2644,3 @@\n-  if (jphases == NULL) {\n-    return -1;\n-  }\n-  JVMCIObjectArray phases = JVMCIENV->wrap(jphases);\n-  int len = JVMCIENV->get_length(phases);\n-  GrowableArray<const char*>* jvmci_phase_names = new GrowableArray<const char*>(len);\n-  for (int i = 0; i < len; i++) {\n-    JVMCIObject phase = JVMCIENV->get_object_at(phases, i);\n-    jvmci_phase_names->append(strdup(JVMCIENV->as_utf8_string(phase)));\n-  }\n-  return CompilerEvent::PhaseEvent::register_phases(jvmci_phase_names);\n+  JVMCIObject phase_name = JVMCIENV->wrap(jphase_name);\n+  const char *name = JVMCIENV->as_utf8_string(phase_name);\n+  return CompilerEvent::PhaseEvent::get_phase_id(name, true, true, true);\n@@ -2827,1 +2818,1 @@\n-  {CC \"registerCompilerPhases\",                       CC \"([\" STRING \")I\",                                                                  FN_PTR(registerCompilerPhases)},\n+  {CC \"registerCompilerPhase\",                        CC \"(\" STRING \")I\",                                                                   FN_PTR(registerCompilerPhase)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -152,6 +152,0 @@\n-  nonstatic_field(JVMFlag,                     _type,                                         const char*)                           \\\n-  nonstatic_field(JVMFlag,                     _name,                                         const char*)                           \\\n-  unchecked_nonstatic_field(JVMFlag,           _addr,                                         sizeof(void*))                         \\\n-  nonstatic_field(JVMFlag,                     _flags,                                        JVMFlag::Flags)                        \\\n-  static_field(JVMFlag,                        flags,                                         JVMFlag*)                              \\\n-                                                                                                                                     \\\n@@ -172,0 +166,1 @@\n+  nonstatic_field(JVMCICompileState,           _compilation_ticks,                            jint)                                  \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classLoaderDataShared.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"memory\/cppVtables.hpp\"\n@@ -221,0 +223,5 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (DumpSharedSpaces && MetaspaceShared::use_full_module_graph()) {\n+    ClassLoaderDataShared::iterate_symbols(&doit);\n+  }\n+#endif\n@@ -471,1 +478,1 @@\n-  intptr_t* archived_vtable = MetaspaceShared::get_archived_cpp_vtable(ref->msotype(), (address)dest);\n+  intptr_t* archived_vtable = CppVtables::get_archived_cpp_vtable(ref->msotype(), (address)dest);\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,336 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/archiveUtils.hpp\"\n+#include \"memory\/cppVtables.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n+#include \"oops\/instanceClassLoaderKlass.hpp\"\n+#include \"oops\/instanceMirrorKlass.hpp\"\n+#include \"oops\/instanceRefKlass.hpp\"\n+#include \"oops\/methodData.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n+#include \"oops\/typeArrayKlass.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.\n+\/\/ (In GCC this is the field <Type>::_vptr, i.e., first word in the object.)\n+\/\/\n+\/\/ Addresses of the vtables and the methods may be different across JVM runs,\n+\/\/ if libjvm.so is dynamically loaded at a different base address.\n+\/\/\n+\/\/ To ensure that the Metadata objects in the CDS archive always have the correct vtable:\n+\/\/\n+\/\/ + at dump time:  we redirect the _vptr to point to our own vtables inside\n+\/\/                  the CDS image\n+\/\/ + at run time:   we clone the actual contents of the vtables from libjvm.so\n+\/\/                  into our own tables.\n+\n+\/\/ Currently, the archive contain ONLY the following types of objects that have C++ vtables.\n+#define CPP_VTABLE_PATCH_TYPES_DO(f) \\\n+  f(ConstantPool) \\\n+  f(InstanceKlass) \\\n+  f(InstanceClassLoaderKlass) \\\n+  f(InstanceMirrorKlass) \\\n+  f(InstanceRefKlass) \\\n+  f(Method) \\\n+  f(ObjArrayKlass) \\\n+  f(TypeArrayKlass) \\\n+  f(FlatArrayKlass) \\\n+  f(InlineKlass)\n+\n+class CppVtableInfo {\n+  intptr_t _vtable_size;\n+  intptr_t _cloned_vtable[1];\n+public:\n+  static int num_slots(int vtable_size) {\n+    return 1 + vtable_size; \/\/ Need to add the space occupied by _vtable_size;\n+  }\n+  int vtable_size()           { return int(uintx(_vtable_size)); }\n+  void set_vtable_size(int n) { _vtable_size = intptr_t(n); }\n+  intptr_t* cloned_vtable()   { return &_cloned_vtable[0]; }\n+  void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }\n+  \/\/ Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo\n+  static size_t byte_size(int vtable_size) {\n+    CppVtableInfo i;\n+    return pointer_delta(&i._cloned_vtable[vtable_size], &i, sizeof(u1));\n+  }\n+};\n+\n+static inline intptr_t* vtable_of(Metadata* m) {\n+  return *((intptr_t**)m);\n+}\n+\n+static inline DumpRegion* mc_region() {\n+  return MetaspaceShared::misc_code_dump_space();\n+}\n+\n+template <class T> class CppVtableCloner : public T {\n+  static CppVtableInfo* _info;\n+\n+  static int get_vtable_length(const char* name);\n+\n+public:\n+  \/\/ Allocate and initialize the C++ vtable, starting from top, but do not go past end.\n+  static intptr_t* allocate(const char* name);\n+\n+  \/\/ Clone the vtable to ...\n+  static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);\n+\n+  static void zero_vtable_clone() {\n+    assert(DumpSharedSpaces, \"dump-time only\");\n+    _info->zero();\n+  }\n+\n+  static bool is_valid_shared_object(const T* obj) {\n+    intptr_t* vptr = *(intptr_t**)obj;\n+    return vptr == _info->cloned_vtable();\n+  }\n+\n+  static void init_orig_cpp_vtptr(int kind);\n+};\n+\n+template <class T> CppVtableInfo* CppVtableCloner<T>::_info = NULL;\n+\n+template <class T>\n+intptr_t* CppVtableCloner<T>::allocate(const char* name) {\n+  assert(is_aligned(mc_region()->top(), sizeof(intptr_t)), \"bad alignment\");\n+  int n = get_vtable_length(name);\n+  _info = (CppVtableInfo*)mc_region()->allocate(CppVtableInfo::byte_size(n), sizeof(intptr_t));\n+  _info->set_vtable_size(n);\n+\n+  intptr_t* p = clone_vtable(name, _info);\n+  assert((char*)p == mc_region()->top(), \"must be\");\n+\n+  return _info->cloned_vtable();\n+}\n+\n+template <class T>\n+intptr_t* CppVtableCloner<T>::clone_vtable(const char* name, CppVtableInfo* info) {\n+  if (!DumpSharedSpaces) {\n+    assert(_info == 0, \"_info is initialized only at dump time\");\n+    _info = info; \/\/ Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()\n+  }\n+  T tmp; \/\/ Allocate temporary dummy metadata object to get to the original vtable.\n+  int n = info->vtable_size();\n+  intptr_t* srcvtable = vtable_of(&tmp);\n+  intptr_t* dstvtable = info->cloned_vtable();\n+\n+  \/\/ We already checked (and, if necessary, adjusted n) when the vtables were allocated, so we are\n+  \/\/ safe to do memcpy.\n+  log_debug(cds, vtables)(\"Copying %3d vtable entries for %s\", n, name);\n+  memcpy(dstvtable, srcvtable, sizeof(intptr_t) * n);\n+  return dstvtable + n;\n+}\n+\n+\/\/ To determine the size of the vtable for each type, we use the following\n+\/\/ trick by declaring 2 subclasses:\n+\/\/\n+\/\/   class CppVtableTesterA: public InstanceKlass {virtual int   last_virtual_method() {return 1;}    };\n+\/\/   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };\n+\/\/\n+\/\/ CppVtableTesterA and CppVtableTesterB's vtables have the following properties:\n+\/\/ - Their size (N+1) is exactly one more than the size of InstanceKlass's vtable (N)\n+\/\/ - The first N entries have are exactly the same as in InstanceKlass's vtable.\n+\/\/ - Their last entry is different.\n+\/\/\n+\/\/ So to determine the value of N, we just walk CppVtableTesterA and CppVtableTesterB's tables\n+\/\/ and find the first entry that's different.\n+\/\/\n+\/\/ This works on all C++ compilers supported by Oracle, but you may need to tweak it for more\n+\/\/ esoteric compilers.\n+\n+template <class T> class CppVtableTesterB: public T {\n+public:\n+  virtual int last_virtual_method() {return 1;}\n+};\n+\n+template <class T> class CppVtableTesterA : public T {\n+public:\n+  virtual void* last_virtual_method() {\n+    \/\/ Make this different than CppVtableTesterB::last_virtual_method so the C++\n+    \/\/ compiler\/linker won't alias the two functions.\n+    return NULL;\n+  }\n+};\n+\n+template <class T>\n+int CppVtableCloner<T>::get_vtable_length(const char* name) {\n+  CppVtableTesterA<T> a;\n+  CppVtableTesterB<T> b;\n+\n+  intptr_t* avtable = vtable_of(&a);\n+  intptr_t* bvtable = vtable_of(&b);\n+\n+  \/\/ Start at slot 1, because slot 0 may be RTTI (on Solaris\/Sparc)\n+  int vtable_len = 1;\n+  for (; ; vtable_len++) {\n+    if (avtable[vtable_len] != bvtable[vtable_len]) {\n+      break;\n+    }\n+  }\n+  log_debug(cds, vtables)(\"Found   %3d vtable entries for %s\", vtable_len, name);\n+\n+  return vtable_len;\n+}\n+\n+#define ALLOC_CPP_VTABLE_CLONE(c) \\\n+  _cloned_cpp_vtptrs[c##_Kind] = CppVtableCloner<c>::allocate(#c); \\\n+  ArchivePtrMarker::mark_pointer(&_cloned_cpp_vtptrs[c##_Kind]);\n+\n+#define CLONE_CPP_VTABLE(c) \\\n+  p = CppVtableCloner<c>::clone_vtable(#c, (CppVtableInfo*)p);\n+\n+#define ZERO_CPP_VTABLE(c) \\\n+ CppVtableCloner<c>::zero_vtable_clone();\n+\n+#define INIT_ORIG_CPP_VTPTRS(c) \\\n+  CppVtableCloner<c>::init_orig_cpp_vtptr(c##_Kind);\n+\n+#define DECLARE_CLONED_VTABLE_KIND(c) c ## _Kind,\n+\n+enum ClonedVtableKind {\n+  \/\/ E.g., ConstantPool_Kind == 0, InstanceKlass_Kind == 1, etc.\n+  CPP_VTABLE_PATCH_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)\n+  _num_cloned_vtable_kinds\n+};\n+\n+\/\/ This is a map of all the original vtptrs. E.g., for\n+\/\/     ConstantPool *cp = new (...) ConstantPool(...) ; \/\/ a dynamically allocated constant pool\n+\/\/ the following holds true:\n+\/\/     _orig_cpp_vtptrs[ConstantPool_Kind] ==  ((intptr_t**)cp)[0]\n+static intptr_t* _orig_cpp_vtptrs[_num_cloned_vtable_kinds];\n+static bool _orig_cpp_vtptrs_inited = false;\n+\n+template <class T>\n+void CppVtableCloner<T>::init_orig_cpp_vtptr(int kind) {\n+  assert(kind < _num_cloned_vtable_kinds, \"sanity\");\n+  T tmp; \/\/ Allocate temporary dummy metadata object to get to the original vtable.\n+  intptr_t* srcvtable = vtable_of(&tmp);\n+  _orig_cpp_vtptrs[kind] = srcvtable;\n+}\n+\n+\/\/ This is the index of all the cloned vtables. E.g., for\n+\/\/     ConstantPool* cp = ....; \/\/ an archived constant pool\n+\/\/     InstanceKlass* ik = ....;\/\/ an archived class\n+\/\/ the following holds true:\n+\/\/     _cloned_cpp_vtptrs[ConstantPool_Kind]  == ((intptr_t**)cp)[0]\n+\/\/     _cloned_cpp_vtptrs[InstanceKlass_Kind] == ((intptr_t**)ik)[0]\n+static intptr_t** _cloned_cpp_vtptrs = NULL;\n+\n+void CppVtables::allocate_cloned_cpp_vtptrs() {\n+  assert(DumpSharedSpaces, \"must\");\n+  size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(intptr_t*);\n+  _cloned_cpp_vtptrs = (intptr_t**)mc_region()->allocate(vtptrs_bytes, sizeof(intptr_t*));\n+}\n+\n+void CppVtables::serialize_cloned_cpp_vtptrs(SerializeClosure* soc) {\n+  soc->do_ptr((void**)&_cloned_cpp_vtptrs);\n+}\n+\n+intptr_t* CppVtables::get_archived_cpp_vtable(MetaspaceObj::Type msotype, address obj) {\n+  if (!_orig_cpp_vtptrs_inited) {\n+    CPP_VTABLE_PATCH_TYPES_DO(INIT_ORIG_CPP_VTPTRS);\n+    _orig_cpp_vtptrs_inited = true;\n+  }\n+\n+  Arguments::assert_is_dumping_archive();\n+  int kind = -1;\n+  switch (msotype) {\n+  case MetaspaceObj::SymbolType:\n+  case MetaspaceObj::TypeArrayU1Type:\n+  case MetaspaceObj::TypeArrayU2Type:\n+  case MetaspaceObj::TypeArrayU4Type:\n+  case MetaspaceObj::TypeArrayU8Type:\n+  case MetaspaceObj::TypeArrayOtherType:\n+  case MetaspaceObj::ConstMethodType:\n+  case MetaspaceObj::ConstantPoolCacheType:\n+  case MetaspaceObj::AnnotationsType:\n+  case MetaspaceObj::MethodCountersType:\n+  case MetaspaceObj::RecordComponentType:\n+    \/\/ These have no vtables.\n+    break;\n+  case MetaspaceObj::MethodDataType:\n+    \/\/ We don't archive MethodData <-- should have been removed in removed_unsharable_info\n+    ShouldNotReachHere();\n+    break;\n+  default:\n+    for (kind = 0; kind < _num_cloned_vtable_kinds; kind ++) {\n+      if (vtable_of((Metadata*)obj) == _orig_cpp_vtptrs[kind]) {\n+        break;\n+      }\n+    }\n+    if (kind >= _num_cloned_vtable_kinds) {\n+      fatal(\"Cannot find C++ vtable for \" INTPTR_FORMAT \" -- you probably added\"\n+            \" a new subtype of Klass or MetaData without updating CPP_VTABLE_PATCH_TYPES_DO\",\n+            p2i(obj));\n+    }\n+  }\n+\n+  if (kind >= 0) {\n+    assert(kind < _num_cloned_vtable_kinds, \"must be\");\n+    return _cloned_cpp_vtptrs[kind];\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+\/\/ This can be called at both dump time and run time:\n+\/\/ - clone the contents of the c++ vtables into the space\n+\/\/   allocated by allocate_cpp_vtable_clones()\n+void CppVtables::clone_cpp_vtables(intptr_t* p) {\n+  assert(DumpSharedSpaces || UseSharedSpaces, \"sanity\");\n+  CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);\n+}\n+\n+void CppVtables::zero_cpp_vtable_clones_for_writing() {\n+  assert(DumpSharedSpaces, \"dump-time only\");\n+  CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);\n+}\n+\n+\/\/ Allocate and initialize the C++ vtables, starting from top, but do not go past end.\n+char* CppVtables::allocate_cpp_vtable_clones() {\n+  char* cloned_vtables = mc_region()->top(); \/\/ This is the beginning of all the cloned vtables\n+\n+  assert(DumpSharedSpaces, \"dump-time only\");\n+  \/\/ Layout (each slot is a intptr_t):\n+  \/\/   [number of slots in the first vtable = n1]\n+  \/\/   [ <n1> slots for the first vtable]\n+  \/\/   [number of slots in the first second = n2]\n+  \/\/   [ <n2> slots for the second vtable]\n+  \/\/   ...\n+  \/\/ The order of the vtables is the same as the CPP_VTAB_PATCH_TYPES_DO macro.\n+  CPP_VTABLE_PATCH_TYPES_DO(ALLOC_CPP_VTABLE_CLONE);\n+\n+  return cloned_vtables;\n+}\n+\n+bool CppVtables::is_valid_shared_method(const Method* m) {\n+  assert(MetaspaceShared::is_in_shared_metaspace(m), \"must be\");\n+  return CppVtableCloner<Method>::is_valid_shared_object(m);\n+}\n","filename":"src\/hotspot\/share\/memory\/cppVtables.cpp","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/classLoaderDataShared.hpp\"\n@@ -43,0 +44,2 @@\n+#include \"memory\/cppVtables.hpp\"\n+#include \"memory\/dumpAllocStats.hpp\"\n@@ -54,4 +57,0 @@\n-#include \"oops\/instanceClassLoaderKlass.hpp\"\n-#include \"oops\/instanceRefKlass.hpp\"\n-#include \"oops\/methodData.hpp\"\n-#include \"oops\/objArrayKlass.hpp\"\n@@ -62,1 +61,0 @@\n-#include \"oops\/typeArrayKlass.hpp\"\n@@ -92,0 +90,1 @@\n+bool MetaspaceShared::_use_full_module_graph = true;\n@@ -156,0 +155,4 @@\n+char* MetaspaceShared::read_write_space_alloc(size_t num_bytes) {\n+  return _rw_region.allocate(num_bytes);\n+}\n+\n@@ -502,1 +505,1 @@\n-  serialize_cloned_cpp_vtptrs(soc);\n+  CppVtables::serialize_cloned_cpp_vtptrs(soc);\n@@ -505,0 +508,2 @@\n+  CDS_JAVA_HEAP_ONLY(ClassLoaderDataShared::serialize(soc));\n+\n@@ -612,293 +617,0 @@\n-\/\/ Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.\n-\/\/ (In GCC this is the field <Type>::_vptr, i.e., first word in the object.)\n-\/\/\n-\/\/ Addresses of the vtables and the methods may be different across JVM runs,\n-\/\/ if libjvm.so is dynamically loaded at a different base address.\n-\/\/\n-\/\/ To ensure that the Metadata objects in the CDS archive always have the correct vtable:\n-\/\/\n-\/\/ + at dump time:  we redirect the _vptr to point to our own vtables inside\n-\/\/                  the CDS image\n-\/\/ + at run time:   we clone the actual contents of the vtables from libjvm.so\n-\/\/                  into our own tables.\n-\n-\/\/ Currently, the archive contain ONLY the following types of objects that have C++ vtables.\n-#define CPP_VTABLE_PATCH_TYPES_DO(f) \\\n-  f(ConstantPool) \\\n-  f(InstanceClassLoaderKlass) \\\n-  f(InstanceKlass) \\\n-  f(InstanceMirrorKlass) \\\n-  f(InstanceRefKlass) \\\n-  f(Method) \\\n-  f(ObjArrayKlass) \\\n-  f(TypeArrayKlass) \\\n-  f(FlatArrayKlass) \\\n-  f(InlineKlass)\n-\n-class CppVtableInfo {\n-  intptr_t _vtable_size;\n-  intptr_t _cloned_vtable[1];\n-public:\n-  static int num_slots(int vtable_size) {\n-    return 1 + vtable_size; \/\/ Need to add the space occupied by _vtable_size;\n-  }\n-  int vtable_size()           { return int(uintx(_vtable_size)); }\n-  void set_vtable_size(int n) { _vtable_size = intptr_t(n); }\n-  intptr_t* cloned_vtable()   { return &_cloned_vtable[0]; }\n-  void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }\n-  \/\/ Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo\n-  static size_t byte_size(int vtable_size) {\n-    CppVtableInfo i;\n-    return pointer_delta(&i._cloned_vtable[vtable_size], &i, sizeof(u1));\n-  }\n-};\n-\n-static inline intptr_t* vtable_of(Metadata* m) {\n-  return *((intptr_t**)m);\n-}\n-\n-template <class T> class CppVtableCloner : public T {\n-  static CppVtableInfo* _info;\n-\n-  static int get_vtable_length(const char* name);\n-\n-public:\n-  \/\/ Allocate and initialize the C++ vtable, starting from top, but do not go past end.\n-  static intptr_t* allocate(const char* name);\n-\n-  \/\/ Clone the vtable to ...\n-  static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);\n-\n-  static void zero_vtable_clone() {\n-    assert(DumpSharedSpaces, \"dump-time only\");\n-    _info->zero();\n-  }\n-\n-  static bool is_valid_shared_object(const T* obj) {\n-    intptr_t* vptr = *(intptr_t**)obj;\n-    return vptr == _info->cloned_vtable();\n-  }\n-\n-  static void init_orig_cpp_vtptr(int kind);\n-};\n-\n-template <class T> CppVtableInfo* CppVtableCloner<T>::_info = NULL;\n-\n-template <class T>\n-intptr_t* CppVtableCloner<T>::allocate(const char* name) {\n-  assert(is_aligned(_mc_region.top(), sizeof(intptr_t)), \"bad alignment\");\n-  int n = get_vtable_length(name);\n-  _info = (CppVtableInfo*)_mc_region.allocate(CppVtableInfo::byte_size(n), sizeof(intptr_t));\n-  _info->set_vtable_size(n);\n-\n-  intptr_t* p = clone_vtable(name, _info);\n-  assert((char*)p == _mc_region.top(), \"must be\");\n-\n-  return _info->cloned_vtable();\n-}\n-\n-template <class T>\n-intptr_t* CppVtableCloner<T>::clone_vtable(const char* name, CppVtableInfo* info) {\n-  if (!DumpSharedSpaces) {\n-    assert(_info == 0, \"_info is initialized only at dump time\");\n-    _info = info; \/\/ Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()\n-  }\n-  T tmp; \/\/ Allocate temporary dummy metadata object to get to the original vtable.\n-  int n = info->vtable_size();\n-  intptr_t* srcvtable = vtable_of(&tmp);\n-  intptr_t* dstvtable = info->cloned_vtable();\n-\n-  \/\/ We already checked (and, if necessary, adjusted n) when the vtables were allocated, so we are\n-  \/\/ safe to do memcpy.\n-  log_debug(cds, vtables)(\"Copying %3d vtable entries for %s\", n, name);\n-  memcpy(dstvtable, srcvtable, sizeof(intptr_t) * n);\n-  return dstvtable + n;\n-}\n-\n-\/\/ To determine the size of the vtable for each type, we use the following\n-\/\/ trick by declaring 2 subclasses:\n-\/\/\n-\/\/   class CppVtableTesterA: public InstanceKlass {virtual int   last_virtual_method() {return 1;}    };\n-\/\/   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };\n-\/\/\n-\/\/ CppVtableTesterA and CppVtableTesterB's vtables have the following properties:\n-\/\/ - Their size (N+1) is exactly one more than the size of InstanceKlass's vtable (N)\n-\/\/ - The first N entries have are exactly the same as in InstanceKlass's vtable.\n-\/\/ - Their last entry is different.\n-\/\/\n-\/\/ So to determine the value of N, we just walk CppVtableTesterA and CppVtableTesterB's tables\n-\/\/ and find the first entry that's different.\n-\/\/\n-\/\/ This works on all C++ compilers supported by Oracle, but you may need to tweak it for more\n-\/\/ esoteric compilers.\n-\n-template <class T> class CppVtableTesterB: public T {\n-public:\n-  virtual int last_virtual_method() {return 1;}\n-};\n-\n-template <class T> class CppVtableTesterA : public T {\n-public:\n-  virtual void* last_virtual_method() {\n-    \/\/ Make this different than CppVtableTesterB::last_virtual_method so the C++\n-    \/\/ compiler\/linker won't alias the two functions.\n-    return NULL;\n-  }\n-};\n-\n-template <class T>\n-int CppVtableCloner<T>::get_vtable_length(const char* name) {\n-  CppVtableTesterA<T> a;\n-  CppVtableTesterB<T> b;\n-\n-  intptr_t* avtable = vtable_of(&a);\n-  intptr_t* bvtable = vtable_of(&b);\n-\n-  \/\/ Start at slot 1, because slot 0 may be RTTI (on Solaris\/Sparc)\n-  int vtable_len = 1;\n-  for (; ; vtable_len++) {\n-    if (avtable[vtable_len] != bvtable[vtable_len]) {\n-      break;\n-    }\n-  }\n-  log_debug(cds, vtables)(\"Found   %3d vtable entries for %s\", vtable_len, name);\n-\n-  return vtable_len;\n-}\n-\n-#define ALLOC_CPP_VTABLE_CLONE(c) \\\n-  _cloned_cpp_vtptrs[c##_Kind] = CppVtableCloner<c>::allocate(#c); \\\n-  ArchivePtrMarker::mark_pointer(&_cloned_cpp_vtptrs[c##_Kind]);\n-\n-#define CLONE_CPP_VTABLE(c) \\\n-  p = CppVtableCloner<c>::clone_vtable(#c, (CppVtableInfo*)p);\n-\n-#define ZERO_CPP_VTABLE(c) \\\n- CppVtableCloner<c>::zero_vtable_clone();\n-\n-#define INIT_ORIG_CPP_VTPTRS(c) \\\n-  CppVtableCloner<c>::init_orig_cpp_vtptr(c##_Kind);\n-\n-#define DECLARE_CLONED_VTABLE_KIND(c) c ## _Kind,\n-\n-enum ClonedVtableKind {\n-  \/\/ E.g., ConstantPool_Kind == 0, InstanceKlass_Kind == 1, etc.\n-  CPP_VTABLE_PATCH_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)\n-  _num_cloned_vtable_kinds\n-};\n-\n-\/\/ This is a map of all the original vtptrs. E.g., for\n-\/\/     ConstantPool *cp = new (...) ConstantPool(...) ; \/\/ a dynamically allocated constant pool\n-\/\/ the following holds true:\n-\/\/     _orig_cpp_vtptrs[ConstantPool_Kind] ==  ((intptr_t**)cp)[0]\n-static intptr_t* _orig_cpp_vtptrs[_num_cloned_vtable_kinds];\n-static bool _orig_cpp_vtptrs_inited = false;\n-\n-template <class T>\n-void CppVtableCloner<T>::init_orig_cpp_vtptr(int kind) {\n-  assert(kind < _num_cloned_vtable_kinds, \"sanity\");\n-  T tmp; \/\/ Allocate temporary dummy metadata object to get to the original vtable.\n-  intptr_t* srcvtable = vtable_of(&tmp);\n-  _orig_cpp_vtptrs[kind] = srcvtable;\n-}\n-\n-\/\/ This is the index of all the cloned vtables. E.g., for\n-\/\/     ConstantPool* cp = ....; \/\/ an archived constant pool\n-\/\/     InstanceKlass* ik = ....;\/\/ an archived class\n-\/\/ the following holds true:\n-\/\/     _cloned_cpp_vtptrs[ConstantPool_Kind]  == ((intptr_t**)cp)[0]\n-\/\/     _cloned_cpp_vtptrs[InstanceKlass_Kind] == ((intptr_t**)ik)[0]\n-static intptr_t** _cloned_cpp_vtptrs = NULL;\n-\n-void MetaspaceShared::allocate_cloned_cpp_vtptrs() {\n-  assert(DumpSharedSpaces, \"must\");\n-  size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(intptr_t*);\n-  _cloned_cpp_vtptrs = (intptr_t**)_mc_region.allocate(vtptrs_bytes, sizeof(intptr_t*));\n-}\n-\n-void MetaspaceShared::serialize_cloned_cpp_vtptrs(SerializeClosure* soc) {\n-  soc->do_ptr((void**)&_cloned_cpp_vtptrs);\n-}\n-\n-intptr_t* MetaspaceShared::get_archived_cpp_vtable(MetaspaceObj::Type msotype, address obj) {\n-  if (!_orig_cpp_vtptrs_inited) {\n-    CPP_VTABLE_PATCH_TYPES_DO(INIT_ORIG_CPP_VTPTRS);\n-    _orig_cpp_vtptrs_inited = true;\n-  }\n-\n-  Arguments::assert_is_dumping_archive();\n-  int kind = -1;\n-  switch (msotype) {\n-  case MetaspaceObj::SymbolType:\n-  case MetaspaceObj::TypeArrayU1Type:\n-  case MetaspaceObj::TypeArrayU2Type:\n-  case MetaspaceObj::TypeArrayU4Type:\n-  case MetaspaceObj::TypeArrayU8Type:\n-  case MetaspaceObj::TypeArrayOtherType:\n-  case MetaspaceObj::ConstMethodType:\n-  case MetaspaceObj::ConstantPoolCacheType:\n-  case MetaspaceObj::AnnotationsType:\n-  case MetaspaceObj::MethodCountersType:\n-  case MetaspaceObj::RecordComponentType:\n-    \/\/ These have no vtables.\n-    break;\n-  case MetaspaceObj::MethodDataType:\n-    \/\/ We don't archive MethodData <-- should have been removed in removed_unsharable_info\n-    ShouldNotReachHere();\n-    break;\n-  default:\n-    for (kind = 0; kind < _num_cloned_vtable_kinds; kind ++) {\n-      if (vtable_of((Metadata*)obj) == _orig_cpp_vtptrs[kind]) {\n-        break;\n-      }\n-    }\n-    if (kind >= _num_cloned_vtable_kinds) {\n-      fatal(\"Cannot find C++ vtable for \" INTPTR_FORMAT \" -- you probably added\"\n-            \" a new subtype of Klass or MetaData without updating CPP_VTABLE_PATCH_TYPES_DO\",\n-            p2i(obj));\n-    }\n-  }\n-\n-  if (kind >= 0) {\n-    assert(kind < _num_cloned_vtable_kinds, \"must be\");\n-    return _cloned_cpp_vtptrs[kind];\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/\/ This can be called at both dump time and run time:\n-\/\/ - clone the contents of the c++ vtables into the space\n-\/\/   allocated by allocate_cpp_vtable_clones()\n-void MetaspaceShared::clone_cpp_vtables(intptr_t* p) {\n-  assert(DumpSharedSpaces || UseSharedSpaces, \"sanity\");\n-  CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);\n-}\n-\n-void MetaspaceShared::zero_cpp_vtable_clones_for_writing() {\n-  assert(DumpSharedSpaces, \"dump-time only\");\n-  CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);\n-}\n-\n-\/\/ Allocate and initialize the C++ vtables, starting from top, but do not go past end.\n-char* MetaspaceShared::allocate_cpp_vtable_clones() {\n-  char* cloned_vtables = _mc_region.top(); \/\/ This is the beginning of all the cloned vtables\n-\n-  assert(DumpSharedSpaces, \"dump-time only\");\n-  \/\/ Layout (each slot is a intptr_t):\n-  \/\/   [number of slots in the first vtable = n1]\n-  \/\/   [ <n1> slots for the first vtable]\n-  \/\/   [number of slots in the first second = n2]\n-  \/\/   [ <n2> slots for the second vtable]\n-  \/\/   ...\n-  \/\/ The order of the vtables is the same as the CPP_VTAB_PATCH_TYPES_DO macro.\n-  CPP_VTABLE_PATCH_TYPES_DO(ALLOC_CPP_VTABLE_CLONE);\n-\n-  return cloned_vtables;\n-}\n-\n-bool MetaspaceShared::is_valid_shared_method(const Method* m) {\n-  assert(is_in_shared_metaspace(m), \"must be\");\n-  return CppVtableCloner<Method>::is_valid_shared_object(m);\n-}\n-\n@@ -1073,1 +785,1 @@\n-  MetaspaceShared::allocate_cloned_cpp_vtptrs();\n+  CppVtables::allocate_cloned_cpp_vtptrs();\n@@ -1075,1 +787,1 @@\n-  MetaspaceShared::allocate_cpp_vtable_clones();\n+  CppVtables::allocate_cpp_vtable_clones();\n@@ -1077,4 +789,23 @@\n-  _mc_region.pack(&_rw_region);\n-  builder.dump_rw_region();\n-  _rw_region.pack(&_ro_region);\n-  builder.dump_ro_region();\n+  {\n+    _mc_region.pack(&_rw_region);\n+    builder.dump_rw_region();\n+#if INCLUDE_CDS_JAVA_HEAP\n+    if (MetaspaceShared::use_full_module_graph()) {\n+      \/\/ Archive the ModuleEntry's and PackageEntry's of the 3 built-in loaders\n+      char* start = _rw_region.top();\n+      ClassLoaderDataShared::allocate_archived_tables();\n+      ArchiveBuilder::alloc_stats()->record_modules(_rw_region.top() - start, \/*read_only*\/false);\n+    }\n+#endif\n+  }\n+  {\n+    _rw_region.pack(&_ro_region);\n+    builder.dump_ro_region();\n+#if INCLUDE_CDS_JAVA_HEAP\n+    if (MetaspaceShared::use_full_module_graph()) {\n+      char* start = _ro_region.top();\n+      ClassLoaderDataShared::init_archived_tables();\n+      ArchiveBuilder::alloc_stats()->record_modules(_ro_region.top() - start, \/*read_only*\/true);\n+    }\n+#endif\n+  }\n@@ -1097,1 +828,1 @@\n-  MetaspaceShared::zero_cpp_vtable_clones_for_writing();\n+  CppVtables::zero_cpp_vtable_clones_for_writing();\n@@ -1363,0 +1094,2 @@\n+    \/\/ exercise the manifest processing code to ensure classes used by CDS are always archived\n+    SystemDictionaryShared::create_jar_manifest(\"Manifest-Version: 1.0\\n\", strlen(\"Manifest-Version: 1.0\\n\"), THREAD);\n@@ -1373,0 +1106,6 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+    if (use_full_module_graph()) {\n+      HeapShared::reset_archived_object_states(THREAD);\n+    }\n+#endif\n+\n@@ -1756,1 +1495,2 @@\n-    log_info(cds)(\"Using optimized module handling %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"optimized module handling: %s\", MetaspaceShared::use_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    log_info(cds)(\"full module graph: %s\", MetaspaceShared::use_full_module_graph() ? \"enabled\" : \"disabled\");\n@@ -1998,1 +1738,1 @@\n-  clone_cpp_vtables((intptr_t*)buffer);\n+  CppVtables::clone_cpp_vtables((intptr_t*)buffer);\n@@ -2081,0 +1821,11 @@\n+bool MetaspaceShared::use_full_module_graph() {\n+  bool result = _use_optimized_module_handling && _use_full_module_graph &&\n+    (UseSharedSpaces || DumpSharedSpaces) && HeapShared::is_heap_object_archiving_allowed();\n+  if (result && UseSharedSpaces) {\n+    \/\/ Classes used by the archived full module graph are loaded in JVMTI early phase.\n+    assert(!(JvmtiExport::should_post_class_file_load_hook() && JvmtiExport::has_early_class_hook_env()),\n+           \"CDS should be disabled if early class hooks are enabled\");\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":59,"deletions":308,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -147,3 +147,0 @@\n-size_t          Universe::_heap_capacity_at_last_gc;\n-size_t          Universe::_heap_used_at_last_gc = 0;\n-\n@@ -892,8 +889,0 @@\n-\n-\/\/ It's the caller's responsibility to ensure glitch-freedom\n-\/\/ (if required).\n-void Universe::update_heap_info_at_gc() {\n-  _heap_capacity_at_last_gc = heap()->capacity();\n-  _heap_used_at_last_gc     = heap()->used();\n-}\n-\n@@ -1046,1 +1035,1 @@\n-    Universe::update_heap_info_at_gc();\n+    Universe::heap()->update_capacity_and_used_at_gc();\n@@ -1080,20 +1069,0 @@\n-void Universe::print_heap_before_gc() {\n-  LogTarget(Debug, gc, heap) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"Heap before GC invocations=%u (full %u):\", heap()->total_collections(), heap()->total_full_collections());\n-    ResourceMark rm;\n-    heap()->print_on(&ls);\n-  }\n-}\n-\n-void Universe::print_heap_after_gc() {\n-  LogTarget(Debug, gc, heap) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"Heap after GC invocations=%u (full %u):\", heap()->total_collections(), heap()->total_full_collections());\n-    ResourceMark rm;\n-    heap()->print_on(&ls);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -169,4 +169,0 @@\n-  \/\/ Historic gc information\n-  static size_t _heap_capacity_at_last_gc;\n-  static size_t _heap_used_at_last_gc;\n-\n@@ -325,5 +321,0 @@\n-  \/\/ Historic gc information\n-  static size_t get_heap_free_at_last_gc()             { return _heap_capacity_at_last_gc - _heap_used_at_last_gc; }\n-  static size_t get_heap_used_at_last_gc()             { return _heap_used_at_last_gc; }\n-  static void update_heap_info_at_gc();\n-\n@@ -382,2 +373,0 @@\n-  static void print_heap_before_gc();\n-  static void print_heap_after_gc();\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -505,2 +505,1 @@\n-  assert(THREAD->is_Java_thread(), \"must be a Java thread\");\n-  JavaThread* javaThread = (JavaThread*)THREAD;\n+  JavaThread* javaThread = THREAD->as_Java_thread();\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-  \/\/ Method oops internally created for method handles may also\n+  \/\/ Methods internally created for method handles may also\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"memory\/archiveUtils.hpp\"\n@@ -949,2 +950,1 @@\n-  assert(THREAD->is_Java_thread(), \"non-JavaThread in link_class_impl\");\n-  JavaThread* jt = (JavaThread*)THREAD;\n+  JavaThread* jt = THREAD->as_Java_thread();\n@@ -1109,3 +1109,1 @@\n-        Thread *thread = THREAD;\n-        assert(thread->is_Java_thread(), \"thread->is_Java_thread()\");\n-        JvmtiExport::post_class_prepare((JavaThread *) thread, this);\n+        JvmtiExport::post_class_prepare(THREAD->as_Java_thread(), this);\n@@ -1175,2 +1173,1 @@\n-  assert(THREAD->is_Java_thread(), \"non-JavaThread in initialize_impl\");\n-  JavaThread* jt = (JavaThread*)THREAD;\n+  JavaThread* jt = THREAD->as_Java_thread();\n@@ -1581,1 +1578,1 @@\n-    JavaThread *jt = (JavaThread *)THREAD;\n+    JavaThread *jt = THREAD->as_Java_thread();\n@@ -3821,1 +3818,1 @@\n-                ? ((JavaThread*)THREAD)->security_get_caller_class(1)\n+                ? THREAD->as_Java_thread()->security_get_caller_class(1)\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1503,0 +1503,1 @@\n+  void init_shared_package_entry();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+class outputStream;\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"memory\/cppVtables.hpp\"\n@@ -2395,1 +2396,1 @@\n-    return MetaspaceShared::is_valid_shared_method(m);\n+    return CppVtables::is_valid_shared_method(m);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -332,0 +332,1 @@\n+    JavaThread *jt = THREAD->as_Java_thread();\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+    JavaThread *jt = THREAD->as_Java_thread();\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,12 +38,9 @@\n-#define C2_FLAGS(develop, \\\n-                 develop_pd, \\\n-                 product, \\\n-                 product_pd, \\\n-                 diagnostic, \\\n-                 diagnostic_pd, \\\n-                 experimental, \\\n-                 notproduct, \\\n-                 range, \\\n-                 constraint) \\\n-                                                                            \\\n-  diagnostic(bool, StressLCM, false,                                        \\\n+#define C2_FLAGS(develop,                                                   \\\n+                 develop_pd,                                                \\\n+                 product,                                                   \\\n+                 product_pd,                                                \\\n+                 notproduct,                                                \\\n+                 range,                                                     \\\n+                 constraint)                                                \\\n+                                                                            \\\n+  product(bool, StressLCM, false, DIAGNOSTIC,                               \\\n@@ -52,1 +49,1 @@\n-  diagnostic(bool, StressGCM, false,                                        \\\n+  product(bool, StressGCM, false, DIAGNOSTIC,                               \\\n@@ -119,1 +116,1 @@\n-  diagnostic_pd(bool, IdealizeClearArrayNode,                               \\\n+  product_pd(bool, IdealizeClearArrayNode, DIAGNOSTIC,                      \\\n@@ -140,1 +137,1 @@\n-  diagnostic(bool, PrintOptoAssembly, false,                                \\\n+  product(bool, PrintOptoAssembly, false, DIAGNOSTIC,                       \\\n@@ -180,1 +177,1 @@\n-  experimental(bool, PostLoopMultiversioning, false,                        \\\n+  product(bool, PostLoopMultiversioning, false, EXPERIMENTAL,               \\\n@@ -186,1 +183,1 @@\n-  diagnostic(bool, UseVectorMacroLogic, true,                               \\\n+  product(bool, UseVectorMacroLogic, true, DIAGNOSTIC,                      \\\n@@ -387,3 +384,0 @@\n-  product(bool, InsertMemBarAfterArraycopy, true,                           \\\n-          \"Insert memory barrier after arraycopy call\")                     \\\n-                                                                            \\\n@@ -488,1 +482,1 @@\n-  diagnostic(bool, PrintPreciseBiasedLockingStatistics, false,              \\\n+  product(bool, PrintPreciseBiasedLockingStatistics, false, DIAGNOSTIC,     \\\n@@ -492,1 +486,1 @@\n-  diagnostic(bool, PrintPreciseRTMLockingStatistics, false,                 \\\n+  product(bool, PrintPreciseRTMLockingStatistics, false, DIAGNOSTIC,        \\\n@@ -505,1 +499,1 @@\n-  diagnostic(bool, AggressiveUnboxing, true,                                \\\n+  product(bool, AggressiveUnboxing, true, DIAGNOSTIC,                       \\\n@@ -560,1 +554,1 @@\n-  diagnostic(intx, DominatorSearchLimit, 1000,                              \\\n+  product(intx, DominatorSearchLimit, 1000, DIAGNOSTIC,                     \\\n@@ -575,1 +569,1 @@\n-  diagnostic(bool, InlineReflectionGetCallerClass, true,                    \\\n+  product(bool, InlineReflectionGetCallerClass, true, DIAGNOSTIC,           \\\n@@ -579,1 +573,1 @@\n-  diagnostic(bool, InlineObjectCopy, true,                                  \\\n+  product(bool, InlineObjectCopy, true, DIAGNOSTIC,                         \\\n@@ -582,1 +576,1 @@\n-  diagnostic(bool, SpecialStringCompareTo, true,                            \\\n+  product(bool, SpecialStringCompareTo, true, DIAGNOSTIC,                   \\\n@@ -585,1 +579,1 @@\n-  diagnostic(bool, SpecialStringIndexOf, true,                              \\\n+  product(bool, SpecialStringIndexOf, true, DIAGNOSTIC,                     \\\n@@ -588,1 +582,1 @@\n-  diagnostic(bool, SpecialStringEquals, true,                               \\\n+  product(bool, SpecialStringEquals, true, DIAGNOSTIC,                      \\\n@@ -591,1 +585,1 @@\n-  diagnostic(bool, SpecialArraysEquals, true,                               \\\n+  product(bool, SpecialArraysEquals, true, DIAGNOSTIC,                      \\\n@@ -594,1 +588,1 @@\n-  diagnostic(bool, SpecialEncodeISOArray, true,                             \\\n+  product(bool, SpecialEncodeISOArray, true, DIAGNOSTIC,                    \\\n@@ -616,1 +610,1 @@\n-  diagnostic(bool, TraceSpilling, false,                                    \\\n+  product(bool, TraceSpilling, false, DIAGNOSTIC,                           \\\n@@ -619,1 +613,1 @@\n-  diagnostic(bool, TraceTypeProfile, false,                                 \\\n+  product(bool, TraceTypeProfile, false, DIAGNOSTIC,                        \\\n@@ -635,1 +629,1 @@\n-  diagnostic(bool, PrintIntrinsics, false,                                  \\\n+  product(bool, PrintIntrinsics, false, DIAGNOSTIC,                         \\\n@@ -641,1 +635,1 @@\n-  diagnostic(bool, DebugInlinedCalls, true,                                 \\\n+  product(bool, DebugInlinedCalls, true, DIAGNOSTIC,                        \\\n@@ -647,1 +641,1 @@\n-  diagnostic(bool, ProfileDynamicTypes, true,                               \\\n+  product(bool, ProfileDynamicTypes, true, DIAGNOSTIC,                      \\\n@@ -716,1 +710,1 @@\n-  diagnostic(bool, OptimizeExpensiveOps, true,                              \\\n+  product(bool, OptimizeExpensiveOps, true, DIAGNOSTIC,                     \\\n@@ -719,1 +713,1 @@\n-  diagnostic(bool, UseMathExactIntrinsics, true,                            \\\n+  product(bool, UseMathExactIntrinsics, true, DIAGNOSTIC,                   \\\n@@ -722,1 +716,1 @@\n-  diagnostic(bool, UseCharacterCompareIntrinsics, false,                    \\\n+  product(bool, UseCharacterCompareIntrinsics, false, DIAGNOSTIC,           \\\n@@ -725,1 +719,1 @@\n-  diagnostic(bool, UseMultiplyToLenIntrinsic, false,                        \\\n+  product(bool, UseMultiplyToLenIntrinsic, false, DIAGNOSTIC,               \\\n@@ -728,1 +722,1 @@\n-  diagnostic(bool, UseSquareToLenIntrinsic, false,                          \\\n+  product(bool, UseSquareToLenIntrinsic, false, DIAGNOSTIC,                 \\\n@@ -731,1 +725,1 @@\n-  diagnostic(bool, UseMulAddIntrinsic, false,                               \\\n+  product(bool, UseMulAddIntrinsic, false, DIAGNOSTIC,                      \\\n@@ -734,1 +728,1 @@\n-  diagnostic(bool, UseMontgomeryMultiplyIntrinsic, false,                   \\\n+  product(bool, UseMontgomeryMultiplyIntrinsic, false, DIAGNOSTIC,          \\\n@@ -737,1 +731,1 @@\n-  diagnostic(bool, UseMontgomerySquareIntrinsic, false,                     \\\n+  product(bool, UseMontgomerySquareIntrinsic, false, DIAGNOSTIC,            \\\n@@ -743,1 +737,1 @@\n-  diagnostic(bool, UseInlineDepthForSpeculativeTypes, true,                 \\\n+  product(bool, UseInlineDepthForSpeculativeTypes, true, DIAGNOSTIC,        \\\n@@ -777,2 +771,4 @@\n-  diagnostic(bool, ExpandSubTypeCheckAtParseTime, false,                    \\\n-          \"Do not use subtype check macro node\")                            \\\n+  product(bool, ExpandSubTypeCheckAtParseTime, false, DIAGNOSTIC,           \\\n+          \"Do not use subtype check macro node\")\n+\n+\/\/ end of C2_FLAGS\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":43,"deletions":47,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-class OopMap;\n@@ -331,1 +330,0 @@\n-      _oop_map(NULL),\n@@ -338,1 +336,0 @@\n-  OopMap*         _oop_map;   \/\/ Array of OopMap info (8-bit char) for GC\n@@ -351,2 +348,0 @@\n-  OopMap *oop_map() const { return _oop_map; }\n-  void set_oop_map(OopMap *om) { _oop_map = om; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -919,1 +919,0 @@\n-  uint         _argsize;      \/\/ Size of argument block on stack\n@@ -924,1 +923,0 @@\n-  uint argsize()              const { return _argsize; }\n@@ -929,1 +927,0 @@\n-  void set_argsize(int s)         { _argsize = s; }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -784,3 +784,1 @@\n-  } else if (InsertMemBarAfterArraycopy) {\n-    insert_mem_bar(ctrl, &out_mem, Op_MemBarCPUOrder);\n-  } else if (adr_type == TypeRawPtr::BOTTOM) {\n+  } else {\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1370,4 +1370,0 @@\n-\n-    \/\/ Compute number of stack slots needed to restore stack in case of\n-    \/\/ Pascal-style argument popping.\n-    mcall->_argsize = out_arg_limit_per_call - begin_out_arg_area;\n@@ -1411,3 +1407,0 @@\n-  \/\/ Move the OopMap\n-  msfpt->_oop_map = sfpt->_oop_map;\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -363,3 +363,0 @@\n-  \/\/ TRUE - grows up, FALSE - grows down (Intel)\n-  virtual bool stack_direction() const;\n-\n@@ -423,2 +420,2 @@\n-  static OptoReg::Name  interpreter_method_oop_reg();\n-  static int            interpreter_method_oop_reg_encode();\n+  static OptoReg::Name  interpreter_method_reg();\n+  static int            interpreter_method_reg_encode();\n@@ -426,3 +423,3 @@\n-  static OptoReg::Name  compiler_method_oop_reg();\n-  static const RegMask &compiler_method_oop_reg_mask();\n-  static int            compiler_method_oop_reg_encode();\n+  static OptoReg::Name  compiler_method_reg();\n+  static const RegMask &compiler_method_reg_mask();\n+  static int            compiler_method_reg_encode();\n@@ -445,3 +442,0 @@\n-  \/\/ !!!!! Special stuff for building ScopeDescs\n-  virtual int      regnum_to_fpu_offset(int regnum);\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectora:\",      false, Op_VecA,              relocInfo::none          },  \/\/ VectorA.\n@@ -120,0 +121,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectora:\",      false, Op_VecA,              relocInfo::none          },  \/\/ VectorA.\n@@ -311,1 +313,1 @@\n-            con_type = con_type->is_aryptr()->cast_to_autobox_cache(true);\n+            con_type = con_type->is_aryptr()->cast_to_autobox_cache();\n@@ -4577,2 +4579,2 @@\n-const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {\n-  if (is_autobox_cache() == cache)  return this;\n+const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache() const {\n+  if (is_autobox_cache())  return this;\n@@ -4582,1 +4584,0 @@\n-  TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;\n@@ -4584,1 +4585,1 @@\n-  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, cache);\n+  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, \/*is_autobox_cache=*\/true);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1335,1 +1335,1 @@\n-  const TypeAryPtr* cast_to_autobox_cache(bool cache) const;\n+  const TypeAryPtr* cast_to_autobox_cache() const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -334,1 +334,1 @@\n-        query_lock_ownership((JavaThread*)THREAD, class_loader) !=\n+        query_lock_ownership(thread, class_loader) !=\n@@ -4359,1 +4359,1 @@\n-      *(JNIEnv**)penv = ((JavaThread*) t)->jni_environment();\n+      *(JNIEnv**)penv = t->as_Java_thread()->jni_environment();\n@@ -4497,1 +4497,1 @@\n-  JavaThread* thread = (JavaThread*) current;\n+  JavaThread* thread = current->as_Java_thread();\n@@ -4552,1 +4552,1 @@\n-      *(JNIEnv**)penv = ((JavaThread*) thread)->jni_environment();\n+      *(JNIEnv**)penv = thread->as_Java_thread()->jni_environment();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -96,2 +96,2 @@\n-    JavaThread* thr = (JavaThread*) Thread::current_or_null();           \\\n-    if (thr == NULL || !thr->is_Java_thread()) {                         \\\n+    Thread* cur = Thread::current_or_null();                             \\\n+    if (cur == NULL || !cur->is_Java_thread()) {                         \\\n@@ -101,0 +101,1 @@\n+    JavaThread* thr = cur->as_Java_thread();                             \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  JavaThread* jthread = (JavaThread*) THREAD;\n+  JavaThread* jthread = THREAD->as_Java_thread();\n@@ -615,2 +615,1 @@\n-  JavaThread* jt = (JavaThread*) THREAD;\n-  if (!jt->is_Java_thread() || !jt->has_last_Java_frame()) {\n+  if (!thread->has_last_Java_frame()) {\n@@ -696,1 +695,1 @@\n-    JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);\n+    JvmtiExport::post_monitor_wait(thread, (oop)obj(), ms);\n@@ -947,1 +946,1 @@\n-  if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=\n+  if (ObjectSynchronizer::query_lock_ownership(THREAD->as_Java_thread(), loader) !=\n@@ -960,2 +959,1 @@\n-  assert(THREAD->is_Java_thread(), \"must be a JavaThread\");\n-  JavaThread* jt = (JavaThread*) THREAD;\n+  JavaThread* jt = THREAD->as_Java_thread();\n@@ -1015,1 +1013,0 @@\n-  assert(THREAD->is_Java_thread(), \"must be a JavaThread\");\n@@ -1256,0 +1253,5 @@\n+JVM_ENTRY(void, JVM_DefineArchivedModules(JNIEnv *env, jobject platform_loader, jobject system_loader))\n+  JVMWrapper(\"JVM_DefineArchivedModules\");\n+  Modules::define_archived_modules(platform_loader, system_loader, CHECK);\n+JVM_END\n+\n@@ -3390,1 +3392,0 @@\n-  assert(THREAD->is_Java_thread(), \"sanity check\");\n@@ -3395,1 +3396,1 @@\n-  return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);\n+  return ObjectSynchronizer::current_thread_holds_lock(thread, h_obj);\n@@ -3806,1 +3807,1 @@\n-  HeapShared::initialize_from_archived_subgraph(k);\n+  HeapShared::initialize_from_archived_subgraph(k, THREAD);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3317,1 +3317,1 @@\n-      JavaThread* current_thread = (JavaThread*)thread;\n+      JavaThread* current_thread = thread->as_Java_thread();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -666,1 +666,1 @@\n-      obj = (oop)mon->object();\n+      obj = mon->object();\n@@ -672,1 +672,1 @@\n-    obj = (oop)mon->object();\n+    obj = mon->object();\n@@ -744,1 +744,1 @@\n-      wait_obj = (oop)mon->object();\n+      wait_obj = mon->object();\n@@ -755,1 +755,1 @@\n-      pending_obj = (oop)mon->object();\n+      pending_obj = mon->object();\n@@ -1085,1 +1085,1 @@\n-            JavaThread *wjava_thread = (JavaThread *)t;\n+            JavaThread *wjava_thread = t->as_Java_thread();\n@@ -1276,2 +1276,1 @@\n-  assert(target->is_Java_thread(), \"just checking\");\n-  JavaThread *jt = (JavaThread *)target;\n+  JavaThread *jt = target->as_Java_thread();\n@@ -1443,1 +1442,1 @@\n-    oop obj = (oop)mon->object();\n+    oop obj = mon->object();\n@@ -1534,2 +1533,1 @@\n-  assert(target->is_Java_thread(), \"just checking\");\n-  JavaThread *jt = (JavaThread *)target;\n+  JavaThread *jt = target->as_Java_thread();\n@@ -1545,2 +1543,1 @@\n-  assert(target->is_Java_thread(), \"just checking\");\n-  JavaThread *jt = (JavaThread *)target;\n+  JavaThread *jt = target->as_Java_thread();\n@@ -1556,2 +1553,1 @@\n-  assert(target->is_Java_thread(), \"just checking\");\n-  JavaThread *jt = (JavaThread *)target;\n+  JavaThread *jt = target->as_Java_thread();\n@@ -1576,2 +1572,1 @@\n-  assert(target->is_Java_thread(), \"just checking\");\n-  JavaThread *jt = (JavaThread *)target;\n+  JavaThread *jt = target->as_Java_thread();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-    assert(thread->is_Java_thread(), \"debugger thread should be a Java Thread\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2094,2 +2094,1 @@\n-      assert(th->is_Java_thread(), \"sanity\");\n-      JavaThread* jt = (JavaThread*)th;\n+      JavaThread* jt = th->as_Java_thread();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -556,0 +556,1 @@\n+  { \"InsertMemBarAfterArraycopy\",    JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n@@ -1461,1 +1462,8 @@\n-    log_info(cds)(\"Using optimized module handling disabled due to incompatible property: %s=%s\", key, value);\n+    log_info(cds)(\"optimized module handling: disabled due to incompatible property: %s=%s\", key, value);\n+  }\n+  if (strcmp(key, \"jdk.module.showModuleResolution\") == 0 ||\n+      strcmp(key, \"jdk.module.illegalAccess\") == 0 ||\n+      strcmp(key, \"jdk.module.validation\") == 0 ||\n+      strcmp(key, \"java.system.class.loader\") == 0) {\n+    MetaspaceShared::disable_full_module_graph();\n+    log_info(cds)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n@@ -2520,1 +2528,1 @@\n-      log_info(cds)(\"Using optimized module handling disabled due to bootclasspath was appended\");\n+      log_info(cds)(\"optimized module handling: disabled because bootclasspath was appended\");\n@@ -3928,4 +3936,1 @@\n-\n-  \/\/ Initialize ranges and constraints\n-  JVMFlagRangeList::init();\n-  JVMFlagConstraintList::init();\n+  JVMFlag::check_all_flag_declarations();\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -730,2 +730,1 @@\n-  assert(THREAD->is_Java_thread(), \"must be called by a JavaThread\");\n-  JavaThread* thread = (JavaThread*)THREAD;\n+  JavaThread* thread = THREAD->as_Java_thread();\n@@ -745,1 +744,1 @@\n-  BiasedLocking::walk_stack_and_revoke(obj(), (JavaThread*) thread);\n+  BiasedLocking::walk_stack_and_revoke(obj(), thread);\n@@ -835,1 +834,1 @@\n-        BiasedLocking::Condition cond = single_revoke_with_handshake(obj, (JavaThread*)THREAD, blt);\n+        BiasedLocking::Condition cond = single_revoke_with_handshake(obj, THREAD->as_Java_thread(), blt);\n@@ -844,1 +843,1 @@\n-      VM_BulkRevokeBias bulk_revoke(&obj, (JavaThread*)THREAD,\n+      VM_BulkRevokeBias bulk_revoke(&obj, THREAD->as_Java_thread(),\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -838,1 +838,1 @@\n-    JavaThread* jt = (JavaThread*)thread;\n+    JavaThread* jt = thread->as_Java_thread();\n@@ -1787,2 +1787,1 @@\n-    assert(THREAD->is_Java_thread(), \"only a java thread can be here\");\n-    JavaThread* thread = (JavaThread*)THREAD;\n+    JavaThread* thread = THREAD->as_Java_thread();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -698,4 +698,4 @@\n-  frame* _fr;\n-  OopClosure* _f;\n-  int    _max_locals;\n-  int    _max_stack;\n+  const frame* _fr;\n+  OopClosure*  _f;\n+  int          _max_locals;\n+  int          _max_stack;\n@@ -704,1 +704,1 @@\n-  InterpreterFrameClosure(frame* fr, int max_locals, int max_stack,\n+  InterpreterFrameClosure(const frame* fr, int max_locals, int max_stack,\n@@ -739,1 +739,0 @@\n-  frame* fr()       { return _fr; }\n@@ -745,4 +744,4 @@\n-  OopClosure* _f;        \/\/ Closure to invoke\n-  int    _offset;        \/\/ TOS-relative offset, decremented with each argument\n-  bool   _has_receiver;  \/\/ true if the callee has a receiver\n-  frame* _fr;\n+  OopClosure*  _f;             \/\/ Closure to invoke\n+  int          _offset;        \/\/ TOS-relative offset, decremented with each argument\n+  bool         _has_receiver;  \/\/ true if the callee has a receiver\n+  const frame* _fr;\n@@ -763,1 +762,1 @@\n-  InterpretedArgumentOopFinder(Symbol* signature, bool has_receiver, frame* fr, OopClosure* f) : SignatureIterator(signature), _has_receiver(has_receiver) {\n+  InterpretedArgumentOopFinder(Symbol* signature, bool has_receiver, const frame* fr, OopClosure* f) : SignatureIterator(signature), _has_receiver(has_receiver) {\n@@ -799,4 +798,4 @@\n-  bool   _is_static;\n-  int    _offset;\n-  frame* _fr;\n-  OopClosure* _f;\n+  bool         _is_static;\n+  int          _offset;\n+  const frame* _fr;\n+  OopClosure*  _f;\n@@ -819,1 +818,1 @@\n-  EntryFrameOopFinder(frame* frame, Symbol* signature, bool is_static) : SignatureIterator(signature) {\n+  EntryFrameOopFinder(const frame* frame, Symbol* signature, bool is_static) : SignatureIterator(signature) {\n@@ -841,1 +840,1 @@\n-void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) {\n+void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) const {\n@@ -939,1 +938,1 @@\n-void frame::oops_interpreted_arguments_do(Symbol* signature, bool has_receiver, OopClosure* f) {\n+void frame::oops_interpreted_arguments_do(Symbol* signature, bool has_receiver, OopClosure* f) const {\n@@ -944,1 +943,1 @@\n-void frame::oops_code_blob_do(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* reg_map) {\n+void frame::oops_code_blob_do(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* reg_map) const {\n@@ -1018,1 +1017,1 @@\n-                                       const RegisterMap* reg_map, OopClosure* f) {\n+                                       const RegisterMap* reg_map, OopClosure* f) const {\n@@ -1067,1 +1066,1 @@\n-void frame::oops_entry_do(OopClosure* f, const RegisterMap* map) {\n+void frame::oops_entry_do(OopClosure* f, const RegisterMap* map) const {\n@@ -1081,1 +1080,1 @@\n-void frame::oops_do_internal(OopClosure* f, CodeBlobClosure* cf, RegisterMap* map, bool use_interpreter_oop_map_cache) {\n+void frame::oops_do_internal(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* map, bool use_interpreter_oop_map_cache) const {\n@@ -1100,1 +1099,1 @@\n-void frame::nmethods_do(CodeBlobClosure* cf) {\n+void frame::nmethods_do(CodeBlobClosure* cf) const {\n@@ -1108,1 +1107,1 @@\n-void frame::metadata_do(MetadataClosure* f) {\n+void frame::metadata_do(MetadataClosure* f) const {\n@@ -1117,1 +1116,1 @@\n-void frame::verify(const RegisterMap* map) {\n+void frame::verify(const RegisterMap* map) const {\n@@ -1131,1 +1130,1 @@\n-  oops_do_internal(&VerifyOopClosure::verify_oop, NULL, (RegisterMap*)map, false);\n+  oops_do_internal(&VerifyOopClosure::verify_oop, NULL, map, false);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":25,"deletions":26,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -362,2 +362,2 @@\n-  void oops_compiled_arguments_do(Symbol* signature, bool has_receiver, bool has_appendix, const RegisterMap* reg_map, OopClosure* f);\n-  void oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache = true);\n+  void oops_compiled_arguments_do(Symbol* signature, bool has_receiver, bool has_appendix, const RegisterMap* reg_map, OopClosure* f) const;\n+  void oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache = true) const;\n@@ -367,1 +367,1 @@\n-  void oops_interpreted_arguments_do(Symbol* signature, bool has_receiver, OopClosure* f);\n+  void oops_interpreted_arguments_do(Symbol* signature, bool has_receiver, OopClosure* f) const;\n@@ -370,3 +370,3 @@\n-  void oops_do_internal(OopClosure* f, CodeBlobClosure* cf, RegisterMap* map, bool use_interpreter_oop_map_cache);\n-  void oops_entry_do(OopClosure* f, const RegisterMap* map);\n-  void oops_code_blob_do(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* map);\n+  void oops_do_internal(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* map, bool use_interpreter_oop_map_cache) const;\n+  void oops_entry_do(OopClosure* f, const RegisterMap* map) const;\n+  void oops_code_blob_do(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* map) const;\n@@ -376,2 +376,2 @@\n-  void oops_do(OopClosure* f, CodeBlobClosure* cf, RegisterMap* map) { oops_do_internal(f, cf, map, true); }\n-  void nmethods_do(CodeBlobClosure* cf);\n+  void oops_do(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* map) const { oops_do_internal(f, cf, map, true); }\n+  void nmethods_do(CodeBlobClosure* cf) const;\n@@ -380,1 +380,1 @@\n-  void metadata_do(MetadataClosure* f);\n+  void metadata_do(MetadataClosure* f) const;\n@@ -383,1 +383,1 @@\n-  void verify(const RegisterMap* map);\n+  void verify(const RegisterMap* map) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,0 +41,10 @@\n+\/\/ develop_pd\/product_pd flags are the same as develop\/product, except that their default values\n+\/\/ are specified in platform-dependent header files.\n+\n+\/\/ Flags must be declared with the following number of parameters:\n+\/\/ non-pd flags:\n+\/\/    (type, name, default_value, doc), or\n+\/\/    (type, name, default_value, extra_attrs, doc)\n+\/\/ pd flags:\n+\/\/    (type, name, doc), or\n+\/\/    (type, name, extra_attrs, doc)\n@@ -47,9 +57,13 @@\n-\/\/ Note: Diagnostic options not meant for VM tuning or for product modes.\n-\/\/ They are to be used for VM quality assurance or field diagnosis\n-\/\/ of VM bugs.  They are hidden so that users will not be encouraged to\n-\/\/ try them as if they were VM ordinary execution options.  However, they\n-\/\/ are available in the product version of the VM.  Under instruction\n-\/\/ from support engineers, VM customers can turn them on to collect\n-\/\/ diagnostic information about VM problems.  To use a VM diagnostic\n-\/\/ option, you must first specify +UnlockDiagnosticVMOptions.\n-\/\/ (This master switch also affects the behavior of -Xprintflags.)\n+\/\/ The optional extra_attrs parameter may have one of the following values:\n+\/\/ DIAGNOSTIC, EXPERIMENTAL, or MANAGEABLE. Currently extra_attrs can be used\n+\/\/ only with product\/product_pd flags.\n+\/\/\n+\/\/ DIAGNOSTIC options are not meant for VM tuning or for product modes.\n+\/\/    They are to be used for VM quality assurance or field diagnosis\n+\/\/    of VM bugs.  They are hidden so that users will not be encouraged to\n+\/\/    try them as if they were VM ordinary execution options.  However, they\n+\/\/    are available in the product version of the VM.  Under instruction\n+\/\/    from support engineers, VM customers can turn them on to collect\n+\/\/    diagnostic information about VM problems.  To use a VM diagnostic\n+\/\/    option, you must first specify +UnlockDiagnosticVMOptions.\n+\/\/    (This master switch also affects the behavior of -Xprintflags.)\n@@ -57,1 +71,1 @@\n-\/\/ experimental flags are in support of features that are not\n+\/\/ EXPERIMENTAL flags are in support of features that are not\n@@ -73,1 +87,1 @@\n-\/\/ manageable flags are writeable external product flags.\n+\/\/ MANAGEABLE flags are writeable external product flags.\n@@ -87,14 +101,1 @@\n-\/\/ product_rw flags are writeable internal product flags.\n-\/\/    They are like \"manageable\" flags but for internal\/private use.\n-\/\/    The list of product_rw flags are internal\/private flags which\n-\/\/    may be changed\/removed in a future release.  It can be set\n-\/\/    through the management interface to get\/set value\n-\/\/    when the name of flag is supplied.\n-\/\/\n-\/\/    A flag can be made as \"product_rw\" only if\n-\/\/    - the VM implementation supports dynamic setting of the flag.\n-\/\/      This implies that the VM must *always* query the flag variable\n-\/\/      and not reuse state related to the flag state at any given time.\n-\/\/\n-\/\/ Note that when there is a need to support develop flags to be writeable,\n-\/\/ it can be done in the same way as product_rw.\n+\n@@ -115,15 +116,10 @@\n-#define RUNTIME_FLAGS(develop, \\\n-                      develop_pd, \\\n-                      product, \\\n-                      product_pd, \\\n-                      diagnostic, \\\n-                      diagnostic_pd, \\\n-                      experimental, \\\n-                      notproduct, \\\n-                      manageable, \\\n-                      product_rw, \\\n-                      lp64_product, \\\n-                      range, \\\n-                      constraint) \\\n-                                                                            \\\n-  lp64_product(bool, UseCompressedOops, false,                              \\\n+#ifdef _LP64\n+#define LP64_RUNTIME_FLAGS(develop,                                         \\\n+                           develop_pd,                                      \\\n+                           product,                                         \\\n+                           product_pd,                                      \\\n+                           notproduct,                                      \\\n+                           range,                                           \\\n+                           constraint)                                      \\\n+                                                                            \\\n+  product(bool, UseCompressedOops, false,                                   \\\n@@ -133,1 +129,1 @@\n-  lp64_product(bool, UseCompressedClassPointers, false,                     \\\n+  product(bool, UseCompressedClassPointers, false,                          \\\n@@ -137,0 +133,29 @@\n+  product(intx, ObjectAlignmentInBytes, 8,                                  \\\n+          \"Default object alignment in bytes, 8 is minimum\")                \\\n+          range(8, 256)                                                     \\\n+          constraint(ObjectAlignmentInBytesConstraintFunc, AtParse)\n+\n+#else\n+\/\/ !_LP64\n+\n+#define LP64_RUNTIME_FLAGS(develop,                                         \\\n+                           develop_pd,                                      \\\n+                           product,                                         \\\n+                           product_pd,                                      \\\n+                           notproduct,                                      \\\n+                           range,                                           \\\n+                           constraint)\n+const bool UseCompressedOops = false;\n+const bool UseCompressedClassPointers = false;\n+const intx ObjectAlignmentInBytes = 8;\n+\n+#endif \/\/ _LP64\n+\n+#define RUNTIME_FLAGS(develop,                                              \\\n+                      develop_pd,                                           \\\n+                      product,                                              \\\n+                      product_pd,                                           \\\n+                      notproduct,                                           \\\n+                      range,                                                \\\n+                      constraint)                                           \\\n+                                                                            \\\n@@ -146,5 +171,0 @@\n-  lp64_product(intx, ObjectAlignmentInBytes, 8,                             \\\n-          \"Default object alignment in bytes, 8 is minimum\")                \\\n-          range(8, 256)                                                     \\\n-          constraint(ObjectAlignmentInBytesConstraintFunc,AtParse)          \\\n-                                                                            \\\n@@ -154,1 +174,1 @@\n-  diagnostic(uint, HandshakeTimeout, 0,                                     \\\n+  product(uint, HandshakeTimeout, 0, DIAGNOSTIC,                            \\\n@@ -157,1 +177,1 @@\n-  experimental(bool, AlwaysSafeConstructors, false,                         \\\n+  product(bool, AlwaysSafeConstructors, false, EXPERIMENTAL,                \\\n@@ -160,1 +180,1 @@\n-  diagnostic(bool, UnlockDiagnosticVMOptions, trueInDebug,                  \\\n+  product(bool, UnlockDiagnosticVMOptions, trueInDebug, DIAGNOSTIC,         \\\n@@ -163,1 +183,1 @@\n-  experimental(bool, UnlockExperimentalVMOptions, false,                    \\\n+  product(bool, UnlockExperimentalVMOptions, false, EXPERIMENTAL,           \\\n@@ -192,1 +212,1 @@\n-          range(os::vm_allocation_granularity(), NOT_LP64(2*G) LP64_ONLY(8192*G)) \\\n+          constraint(NUMAInterleaveGranularityConstraintFunc, AtParse)      \\\n@@ -223,1 +243,1 @@\n-  diagnostic(bool, UseGHASHIntrinsics, false,                               \\\n+  product(bool, UseGHASHIntrinsics, false, DIAGNOSTIC,                      \\\n@@ -246,4 +266,1 @@\n-  develop(bool, TraceLongCompiles, false,                                   \\\n-          \"Print out every time compilation is longer than \"                \\\n-          \"a given threshold\")                                              \\\n-  diagnostic(bool, SafepointALot, false,                                    \\\n+  product(bool, SafepointALot, false, DIAGNOSTIC,                           \\\n@@ -254,1 +271,1 @@\n-  diagnostic(bool, HandshakeALot, false,                                    \\\n+  product(bool, HandshakeALot, false, DIAGNOSTIC,                           \\\n@@ -268,1 +285,1 @@\n-  diagnostic(bool, ForceUnreachable, false,                                 \\\n+  product(bool, ForceUnreachable, false, DIAGNOSTIC,                        \\\n@@ -288,1 +305,1 @@\n-  diagnostic(bool, InlineArrayCopy, true,                                   \\\n+  product(bool, InlineArrayCopy, true, DIAGNOSTIC,                          \\\n@@ -292,1 +309,1 @@\n-  diagnostic(bool, InlineObjectHash, true,                                  \\\n+  product(bool, InlineObjectHash, true, DIAGNOSTIC,                         \\\n@@ -296,1 +313,1 @@\n-  diagnostic(bool, InlineNatives, true,                                     \\\n+  product(bool, InlineNatives, true, DIAGNOSTIC,                            \\\n@@ -299,1 +316,1 @@\n-  diagnostic(bool, InlineMathNatives, true,                                 \\\n+  product(bool, InlineMathNatives, true, DIAGNOSTIC,                        \\\n@@ -302,1 +319,1 @@\n-  diagnostic(bool, InlineClassNatives, true,                                \\\n+  product(bool, InlineClassNatives, true, DIAGNOSTIC,                       \\\n@@ -305,1 +322,1 @@\n-  diagnostic(bool, InlineThreadNatives, true,                               \\\n+  product(bool, InlineThreadNatives, true, DIAGNOSTIC,                      \\\n@@ -308,1 +325,1 @@\n-  diagnostic(bool, InlineUnsafeOps, true,                                   \\\n+  product(bool, InlineUnsafeOps, true, DIAGNOSTIC,                          \\\n@@ -317,1 +334,1 @@\n-  diagnostic(bool, UseAESIntrinsics, false,                                 \\\n+  product(bool, UseAESIntrinsics, false, DIAGNOSTIC,                        \\\n@@ -320,1 +337,1 @@\n-  diagnostic(bool, UseAESCTRIntrinsics, false,                              \\\n+  product(bool, UseAESCTRIntrinsics, false, DIAGNOSTIC,                     \\\n@@ -323,1 +340,1 @@\n-  diagnostic(bool, UseMD5Intrinsics, false,                                 \\\n+  product(bool, UseMD5Intrinsics, false, DIAGNOSTIC,                        \\\n@@ -326,1 +343,1 @@\n-  diagnostic(bool, UseSHA1Intrinsics, false,                                \\\n+  product(bool, UseSHA1Intrinsics, false, DIAGNOSTIC,                       \\\n@@ -330,1 +347,1 @@\n-  diagnostic(bool, UseSHA256Intrinsics, false,                              \\\n+  product(bool, UseSHA256Intrinsics, false, DIAGNOSTIC,                     \\\n@@ -334,1 +351,1 @@\n-  diagnostic(bool, UseSHA512Intrinsics, false,                              \\\n+  product(bool, UseSHA512Intrinsics, false, DIAGNOSTIC,                     \\\n@@ -338,1 +355,1 @@\n-  diagnostic(bool, UseCRC32Intrinsics, false,                               \\\n+  product(bool, UseCRC32Intrinsics, false, DIAGNOSTIC,                      \\\n@@ -341,1 +358,1 @@\n-  diagnostic(bool, UseCRC32CIntrinsics, false,                              \\\n+  product(bool, UseCRC32CIntrinsics, false, DIAGNOSTIC,                     \\\n@@ -344,1 +361,1 @@\n-  diagnostic(bool, UseAdler32Intrinsics, false,                             \\\n+  product(bool, UseAdler32Intrinsics, false, DIAGNOSTIC,                    \\\n@@ -347,1 +364,1 @@\n-  diagnostic(bool, UseVectorizedMismatchIntrinsic, false,                   \\\n+  product(bool, UseVectorizedMismatchIntrinsic, false, DIAGNOSTIC,          \\\n@@ -350,1 +367,1 @@\n-  diagnostic(bool, UseCopySignIntrinsic, false,                             \\\n+  product(bool, UseCopySignIntrinsic, false, DIAGNOSTIC,                    \\\n@@ -353,1 +370,1 @@\n-  diagnostic(bool, UseSignumIntrinsic, false,                               \\\n+  product(bool, UseSignumIntrinsic, false, DIAGNOSTIC,                      \\\n@@ -356,1 +373,1 @@\n-  diagnostic(ccstrlist, DisableIntrinsic, \"\",                               \\\n+  product(ccstrlist, DisableIntrinsic, \"\", DIAGNOSTIC,                      \\\n@@ -359,1 +376,1 @@\n-  diagnostic(ccstrlist, ControlIntrinsic, \"\",                               \\\n+  product(ccstrlist, ControlIntrinsic, \"\", DIAGNOSTIC,                      \\\n@@ -392,1 +409,1 @@\n-  diagnostic(bool, AbortVMOnSafepointTimeout, false,                        \\\n+  product(bool, AbortVMOnSafepointTimeout, false, DIAGNOSTIC,               \\\n@@ -395,1 +412,1 @@\n-  diagnostic(bool, AbortVMOnVMOperationTimeout, false,                      \\\n+  product(bool, AbortVMOnVMOperationTimeout, false, DIAGNOSTIC,             \\\n@@ -398,1 +415,1 @@\n-  diagnostic(intx, AbortVMOnVMOperationTimeoutDelay, 1000,                  \\\n+  product(intx, AbortVMOnVMOperationTimeoutDelay, 1000, DIAGNOSTIC,         \\\n@@ -421,1 +438,1 @@\n-  diagnostic(bool, LogEvents, true,                                         \\\n+  product(bool, LogEvents, true, DIAGNOSTIC,                                \\\n@@ -424,1 +441,1 @@\n-  diagnostic(uintx, LogEventsBufferEntries, 20,                             \\\n+  product(uintx, LogEventsBufferEntries, 20, DIAGNOSTIC,                    \\\n@@ -428,1 +445,1 @@\n-  diagnostic(bool, BytecodeVerificationRemote, true,                        \\\n+  product(bool, BytecodeVerificationRemote, true, DIAGNOSTIC,               \\\n@@ -431,1 +448,1 @@\n-  diagnostic(bool, BytecodeVerificationLocal, false,                        \\\n+  product(bool, BytecodeVerificationLocal, false, DIAGNOSTIC,               \\\n@@ -518,1 +535,1 @@\n-  manageable(bool, HeapDumpBeforeFullGC, false,                             \\\n+  product(bool, HeapDumpBeforeFullGC, false, MANAGEABLE,                    \\\n@@ -521,1 +538,1 @@\n-  manageable(bool, HeapDumpAfterFullGC, false,                              \\\n+  product(bool, HeapDumpAfterFullGC, false, MANAGEABLE,                     \\\n@@ -524,1 +541,1 @@\n-  manageable(bool, HeapDumpOnOutOfMemoryError, false,                       \\\n+  product(bool, HeapDumpOnOutOfMemoryError, false, MANAGEABLE,              \\\n@@ -527,1 +544,1 @@\n-  manageable(ccstr, HeapDumpPath, NULL,                                     \\\n+  product(ccstr, HeapDumpPath, NULL, MANAGEABLE,                            \\\n@@ -538,1 +555,1 @@\n-  diagnostic(bool, PrintNMTStatistics, false,                               \\\n+  product(bool, PrintNMTStatistics, false, DIAGNOSTIC,                      \\\n@@ -541,1 +558,1 @@\n-  diagnostic(bool, LogCompilation, false,                                   \\\n+  product(bool, LogCompilation, false, DIAGNOSTIC,                          \\\n@@ -547,1 +564,1 @@\n-  diagnostic(intx, RepeatCompilation, 0,                                    \\\n+  product(intx, RepeatCompilation, 0, DIAGNOSTIC,                           \\\n@@ -549,1 +566,1 @@\n-          range(0, max_jint)                                                 \\\n+          range(0, max_jint)                                                \\\n@@ -554,1 +571,1 @@\n-  diagnostic(intx, ScavengeRootsInCode, 2,                                  \\\n+  product(intx, ScavengeRootsInCode, 2, DIAGNOSTIC,                         \\\n@@ -563,1 +580,1 @@\n-  diagnostic(bool, PrintCompilation2, false,                                \\\n+  product(bool, PrintCompilation2, false, DIAGNOSTIC,                       \\\n@@ -566,1 +583,1 @@\n-  diagnostic(bool, PrintAdapterHandlers, false,                             \\\n+  product(bool, PrintAdapterHandlers, false, DIAGNOSTIC,                    \\\n@@ -569,1 +586,1 @@\n-  diagnostic(bool, VerifyAdapterCalls, trueInDebug,                         \\\n+  product(bool, VerifyAdapterCalls, trueInDebug, DIAGNOSTIC,                \\\n@@ -575,1 +592,1 @@\n-  diagnostic(bool, PrintAssembly, false,                                    \\\n+  product(bool, PrintAssembly, false, DIAGNOSTIC,                           \\\n@@ -578,1 +595,1 @@\n-  diagnostic(ccstr, PrintAssemblyOptions, NULL,                             \\\n+  product(ccstr, PrintAssemblyOptions, NULL, DIAGNOSTIC,                    \\\n@@ -584,1 +601,1 @@\n-  diagnostic(bool, PrintNMethods, false,                                    \\\n+  product(bool, PrintNMethods, false, DIAGNOSTIC,                           \\\n@@ -587,1 +604,1 @@\n-  diagnostic(bool, PrintNativeNMethods, false,                              \\\n+  product(bool, PrintNativeNMethods, false, DIAGNOSTIC,                     \\\n@@ -619,1 +636,1 @@\n-  diagnostic(bool, PrintCodeHeapAnalytics, false,                           \\\n+  product(bool, PrintCodeHeapAnalytics, false, DIAGNOSTIC,                  \\\n@@ -622,1 +639,1 @@\n-  diagnostic(bool, PrintStubCode, false,                                    \\\n+  product(bool, PrintStubCode, false, DIAGNOSTIC,                           \\\n@@ -631,1 +648,1 @@\n-  manageable(bool, ShowCodeDetailsInExceptionMessages, true,                \\\n+  product(bool, ShowCodeDetailsInExceptionMessages, true, MANAGEABLE,       \\\n@@ -678,1 +695,1 @@\n-  diagnostic(bool, DynamicallyResizeSystemDictionaries, true,               \\\n+  product(bool, DynamicallyResizeSystemDictionaries, true, DIAGNOSTIC,      \\\n@@ -693,1 +710,1 @@\n-  experimental(bool, DisablePrimordialThreadGuardPages, false,              \\\n+  product(bool, DisablePrimordialThreadGuardPages, false, EXPERIMENTAL,     \\\n@@ -699,1 +716,1 @@\n-  diagnostic(intx, AsyncDeflationInterval, 250,                             \\\n+  product(intx, AsyncDeflationInterval, 250, DIAGNOSTIC,                    \\\n@@ -704,1 +721,1 @@\n-  experimental(intx, MonitorUsedDeflationThreshold, 90,                     \\\n+  product(intx, MonitorUsedDeflationThreshold, 90, EXPERIMENTAL,            \\\n@@ -710,1 +727,1 @@\n-  experimental(intx, hashCode, 5,                                           \\\n+  product(intx, hashCode, 5, EXPERIMENTAL,                                  \\\n@@ -813,1 +830,1 @@\n-  diagnostic(bool, PrintBiasedLockingStatistics, false,                     \\\n+  product(bool, PrintBiasedLockingStatistics, false, DIAGNOSTIC,            \\\n@@ -835,1 +852,1 @@\n-  diagnostic(intx, DiagnoseSyncOnPrimitiveWrappers, 0,                      \\\n+  product(intx, DiagnoseSyncOnPrimitiveWrappers, 0, DIAGNOSTIC,             \\\n@@ -939,1 +956,1 @@\n-  manageable(bool, PrintClassHistogram, false,                              \\\n+  product(bool, PrintClassHistogram, false, MANAGEABLE,                     \\\n@@ -942,1 +959,1 @@\n-  experimental(double, ObjectCountCutOffPercent, 0.5,                       \\\n+  product(double, ObjectCountCutOffPercent, 0.5, EXPERIMENTAL,              \\\n@@ -949,1 +966,1 @@\n-  diagnostic(bool, TraceJVMTIObjectTagging, false,                          \\\n+  product(bool, TraceJVMTIObjectTagging, false, DIAGNOSTIC,                 \\\n@@ -952,1 +969,1 @@\n-  diagnostic(bool, VerifyBeforeIteration, false,                            \\\n+  product(bool, VerifyBeforeIteration, false, DIAGNOSTIC,                   \\\n@@ -960,1 +977,1 @@\n-  diagnostic(bool, CIPrintCompileQueue, false,                              \\\n+  product(bool, CIPrintCompileQueue, false, DIAGNOSTIC,                     \\\n@@ -1010,1 +1027,1 @@\n-  diagnostic(bool, ReduceNumberOfCompilerThreads, true,                     \\\n+  product(bool, ReduceNumberOfCompilerThreads, true, DIAGNOSTIC,            \\\n@@ -1014,1 +1031,1 @@\n-  diagnostic(bool, TraceCompilerThreads, false,                             \\\n+  product(bool, TraceCompilerThreads, false, DIAGNOSTIC,                    \\\n@@ -1033,1 +1050,1 @@\n-  diagnostic_pd(bool, ImplicitNullChecks,                                   \\\n+  product_pd(bool, ImplicitNullChecks, DIAGNOSTIC,                          \\\n@@ -1042,1 +1059,1 @@\n-  diagnostic(bool, EnableThreadSMRExtraValidityChecks, true,                \\\n+  product(bool, EnableThreadSMRExtraValidityChecks, true, DIAGNOSTIC,       \\\n@@ -1045,1 +1062,1 @@\n-  diagnostic(bool, EnableThreadSMRStatistics, trueInDebug,                  \\\n+  product(bool, EnableThreadSMRStatistics, trueInDebug, DIAGNOSTIC,         \\\n@@ -1063,1 +1080,1 @@\n-  diagnostic(bool, PrintInlining, false,                                    \\\n+  product(bool, PrintInlining, false, DIAGNOSTIC,                           \\\n@@ -1072,1 +1089,1 @@\n-  diagnostic(bool, LogTouchedMethods, false,                                \\\n+  product(bool, LogTouchedMethods, false, DIAGNOSTIC,                       \\\n@@ -1075,1 +1092,1 @@\n-  diagnostic(bool, PrintTouchedMethodsAtExit, false,                        \\\n+  product(bool, PrintTouchedMethodsAtExit, false, DIAGNOSTIC,               \\\n@@ -1084,1 +1101,1 @@\n-  diagnostic(bool, PrintMethodFlushingStatistics, false,                    \\\n+  product(bool, PrintMethodFlushingStatistics, false, DIAGNOSTIC,           \\\n@@ -1087,1 +1104,1 @@\n-  diagnostic(intx, HotMethodDetectionLimit, 100000,                         \\\n+  product(intx, HotMethodDetectionLimit, 100000, DIAGNOSTIC,                \\\n@@ -1092,1 +1109,1 @@\n-  diagnostic(intx, MinPassesBeforeFlush, 10,                                \\\n+  product(intx, MinPassesBeforeFlush, 10, DIAGNOSTIC,                       \\\n@@ -1100,1 +1117,1 @@\n-  diagnostic(bool, StressCodeAging, false,                                  \\\n+  product(bool, StressCodeAging, false, DIAGNOSTIC,                         \\\n@@ -1106,1 +1123,1 @@\n-  diagnostic(bool, DebugNonSafepoints, trueInDebug,                         \\\n+  product(bool, DebugNonSafepoints, trueInDebug, DIAGNOSTIC,                \\\n@@ -1132,1 +1149,1 @@\n-  diagnostic(bool, SerializeVMOutput, true,                                 \\\n+  product(bool, SerializeVMOutput, true, DIAGNOSTIC,                        \\\n@@ -1135,1 +1152,1 @@\n-  diagnostic(bool, DisplayVMOutput, true,                                   \\\n+  product(bool, DisplayVMOutput, true, DIAGNOSTIC,                          \\\n@@ -1138,1 +1155,1 @@\n-  diagnostic(bool, LogVMOutput, false,                                      \\\n+  product(bool, LogVMOutput, false, DIAGNOSTIC,                             \\\n@@ -1141,1 +1158,1 @@\n-  diagnostic(ccstr, LogFile, NULL,                                          \\\n+  product(ccstr, LogFile, NULL, DIAGNOSTIC,                                 \\\n@@ -1171,1 +1188,1 @@\n-  diagnostic(bool, VerifyStringTableAtExit, false,                          \\\n+  product(bool, VerifyStringTableAtExit, false, DIAGNOSTIC,                 \\\n@@ -1181,1 +1198,1 @@\n-  diagnostic(ccstr, AbortVMOnException, NULL,                               \\\n+  product(ccstr, AbortVMOnException, NULL, DIAGNOSTIC,                      \\\n@@ -1185,1 +1202,1 @@\n-  diagnostic(ccstr, AbortVMOnExceptionMessage, NULL,                        \\\n+  product(ccstr, AbortVMOnExceptionMessage, NULL, DIAGNOSTIC,               \\\n@@ -1269,1 +1286,1 @@\n-  diagnostic(bool, PrintInterpreter, false,                                 \\\n+  product(bool, PrintInterpreter, false, DIAGNOSTIC,                        \\\n@@ -1301,1 +1318,1 @@\n-  diagnostic(bool, PrintSignatureHandlers, false,                           \\\n+  product(bool, PrintSignatureHandlers, false, DIAGNOSTIC,                  \\\n@@ -1349,1 +1366,1 @@\n-  diagnostic(bool, PrintMethodData, false,                                  \\\n+  product(bool, PrintMethodData, false, DIAGNOSTIC,                         \\\n@@ -1453,1 +1470,1 @@\n-  diagnostic(intx, GuaranteedSafepointInterval, 1000,                       \\\n+  product(intx, GuaranteedSafepointInterval, 1000, DIAGNOSTIC,              \\\n@@ -1460,2 +1477,1 @@\n-  LP64_ONLY(range(0, max_intx\/MICROUNITS))                                  \\\n-  NOT_LP64(range(0, max_intx))                                              \\\n+          range(0, max_intx LP64_ONLY(\/MICROUNITS))                         \\\n@@ -1514,1 +1530,1 @@\n-  diagnostic(uintx, MallocMaxTestWords,     0,                              \\\n+  product(uintx, MallocMaxTestWords,     0, DIAGNOSTIC,                     \\\n@@ -1538,1 +1554,1 @@\n-  experimental(intx, PerMethodSpecTrapLimit,  5000,                         \\\n+  product(intx, PerMethodSpecTrapLimit,  5000, EXPERIMENTAL,                \\\n@@ -1547,1 +1563,1 @@\n-  experimental(intx, SpecTrapLimitExtraEntries,  3,                         \\\n+  product(intx, SpecTrapLimitExtraEntries,  3, EXPERIMENTAL,                \\\n@@ -1554,1 +1570,1 @@\n-  diagnostic_pd(intx, InlineFrequencyCount,                                 \\\n+  product_pd(intx, InlineFrequencyCount, DIAGNOSTIC,                        \\\n@@ -1585,1 +1601,1 @@\n-  manageable(uintx, MinHeapFreeRatio, 40,                                   \\\n+  product(uintx, MinHeapFreeRatio, 40, MANAGEABLE,                          \\\n@@ -1592,1 +1608,1 @@\n-  manageable(uintx, MaxHeapFreeRatio, 70,                                   \\\n+  product(uintx, MaxHeapFreeRatio, 70, MANAGEABLE,                          \\\n@@ -1692,1 +1708,1 @@\n-          range(os::vm_page_size(), max_uintx)                              \\\n+          constraint(VMPageSizeConstraintFunc, AtParse)                     \\\n@@ -1703,1 +1719,1 @@\n-          range(os::vm_page_size(), max_uintx)                              \\\n+          constraint(VMPageSizeConstraintFunc, AtParse)                     \\\n@@ -1715,1 +1731,1 @@\n-          range(os::vm_page_size(), max_uintx)                              \\\n+          constraint(VMPageSizeConstraintFunc, AtParse)                     \\\n@@ -1721,1 +1737,1 @@\n-  diagnostic_pd(uintx, CodeCacheMinBlockLength,                             \\\n+  product_pd(uintx, CodeCacheMinBlockLength, DIAGNOSTIC,                    \\\n@@ -1743,1 +1759,1 @@\n-  experimental(bool, UseAOT, false,                                         \\\n+  product(bool, UseAOT, false, EXPERIMENTAL,                                \\\n@@ -1746,1 +1762,1 @@\n-  experimental(ccstrlist, AOTLibrary, NULL,                                 \\\n+  product(ccstrlist, AOTLibrary, NULL, EXPERIMENTAL,                        \\\n@@ -1749,1 +1765,1 @@\n-  experimental(bool, PrintAOT, false,                                       \\\n+  product(bool, PrintAOT, false, EXPERIMENTAL,                              \\\n@@ -1755,1 +1771,1 @@\n-  diagnostic(bool, UseAOTStrictLoading, false,                              \\\n+  product(bool, UseAOTStrictLoading, false, DIAGNOSTIC,                     \\\n@@ -1799,1 +1815,1 @@\n-  diagnostic(ccstr, CompilerDirectivesFile, NULL,                           \\\n+  product(ccstr, CompilerDirectivesFile, NULL, DIAGNOSTIC,                  \\\n@@ -1840,1 +1856,1 @@\n-  diagnostic(bool, AbortVMOnCompilationFailure, false,                      \\\n+  product(bool, AbortVMOnCompilationFailure, false, DIAGNOSTIC,             \\\n@@ -1921,1 +1937,1 @@\n-  experimental(bool, UseCriticalJavaThreadPriority, false,                  \\\n+  product(bool, UseCriticalJavaThreadPriority, false, EXPERIMENTAL,         \\\n@@ -1924,1 +1940,1 @@\n-  experimental(bool, UseCriticalCompilerThreadPriority, false,              \\\n+  product(bool, UseCriticalCompilerThreadPriority, false, EXPERIMENTAL,     \\\n@@ -1935,4 +1951,0 @@\n-  \/* Background Compilation *\/                                              \\\n-  develop(intx, LongCompileThreshold,     50,                               \\\n-          \"Used with +TraceLongCompiles\")                                   \\\n-                                                                            \\\n@@ -2033,1 +2045,1 @@\n-  diagnostic(intx, Tier0AOTInvocationThreshold, 200,                        \\\n+  product(intx, Tier0AOTInvocationThreshold, 200, DIAGNOSTIC,               \\\n@@ -2040,1 +2052,1 @@\n-  diagnostic(intx, Tier0AOTMinInvocationThreshold, 100,                     \\\n+  product(intx, Tier0AOTMinInvocationThreshold, 100, DIAGNOSTIC,            \\\n@@ -2047,1 +2059,1 @@\n-  diagnostic(intx, Tier0AOTCompileThreshold, 2000,                          \\\n+  product(intx, Tier0AOTCompileThreshold, 2000, DIAGNOSTIC,                 \\\n@@ -2055,1 +2067,1 @@\n-  diagnostic(intx, Tier0AOTBackEdgeThreshold,  60000,                       \\\n+  product(intx, Tier0AOTBackEdgeThreshold,  60000, DIAGNOSTIC,              \\\n@@ -2080,1 +2092,1 @@\n-  diagnostic(intx, Tier40InvocationThreshold, 5000,                         \\\n+  product(intx, Tier40InvocationThreshold, 5000, DIAGNOSTIC,                \\\n@@ -2086,1 +2098,1 @@\n-  diagnostic(intx, Tier40MinInvocationThreshold, 600,                       \\\n+  product(intx, Tier40MinInvocationThreshold, 600, DIAGNOSTIC,              \\\n@@ -2092,1 +2104,1 @@\n-  diagnostic(intx, Tier40CompileThreshold, 10000,                           \\\n+  product(intx, Tier40CompileThreshold, 10000, DIAGNOSTIC,                  \\\n@@ -2098,1 +2110,1 @@\n-  diagnostic(intx, Tier40BackEdgeThreshold, 15000,                          \\\n+  product(intx, Tier40BackEdgeThreshold, 15000, DIAGNOSTIC,                 \\\n@@ -2104,1 +2116,1 @@\n-  diagnostic(intx, Tier0Delay, 5,                                           \\\n+  product(intx, Tier0Delay, 5, DIAGNOSTIC,                                  \\\n@@ -2199,1 +2211,1 @@\n-  diagnostic(bool, UseNewCode, false,                                       \\\n+  product(bool, UseNewCode, false, DIAGNOSTIC,                              \\\n@@ -2202,1 +2214,1 @@\n-  diagnostic(bool, UseNewCode2, false,                                      \\\n+  product(bool, UseNewCode2, false, DIAGNOSTIC,                             \\\n@@ -2205,1 +2217,1 @@\n-  diagnostic(bool, UseNewCode3, false,                                      \\\n+  product(bool, UseNewCode3, false, DIAGNOSTIC,                             \\\n@@ -2264,1 +2276,1 @@\n-  manageable(bool, PrintConcurrentLocks, false,                             \\\n+  product(bool, PrintConcurrentLocks, false, MANAGEABLE,                    \\\n@@ -2305,1 +2317,1 @@\n-  diagnostic(bool, AllowArchivingWithJavaAgent, false,                      \\\n+  product(bool, AllowArchivingWithJavaAgent, false, DIAGNOSTIC,             \\\n@@ -2308,1 +2320,1 @@\n-  diagnostic(bool, PrintMethodHandleStubs, false,                           \\\n+  product(bool, PrintMethodHandleStubs, false, DIAGNOSTIC,                  \\\n@@ -2311,1 +2323,1 @@\n-  diagnostic(bool, VerifyMethodHandles, trueInDebug,                        \\\n+  product(bool, VerifyMethodHandles, trueInDebug, DIAGNOSTIC,               \\\n@@ -2314,1 +2326,1 @@\n-  diagnostic(bool, ShowHiddenFrames, false,                                 \\\n+  product(bool, ShowHiddenFrames, false, DIAGNOSTIC,                        \\\n@@ -2317,1 +2329,1 @@\n-  experimental(bool, TrustFinalNonStaticFields, false,                      \\\n+  product(bool, TrustFinalNonStaticFields, false, EXPERIMENTAL,             \\\n@@ -2320,1 +2332,1 @@\n-  diagnostic(bool, FoldStableValues, true,                                  \\\n+  product(bool, FoldStableValues, true, DIAGNOSTIC,                         \\\n@@ -2323,1 +2335,1 @@\n-  diagnostic(int, UseBootstrapCallInfo, 1,                                  \\\n+  product(int, UseBootstrapCallInfo, 1, DIAGNOSTIC,                         \\\n@@ -2331,1 +2343,1 @@\n-  diagnostic(bool, PauseAtStartup,      false,                              \\\n+  product(bool, PauseAtStartup,      false, DIAGNOSTIC,                     \\\n@@ -2335,1 +2347,1 @@\n-  diagnostic(ccstr, PauseAtStartupFile, NULL,                               \\\n+  product(ccstr, PauseAtStartupFile, NULL, DIAGNOSTIC,                      \\\n@@ -2339,1 +2351,1 @@\n-  diagnostic(bool, PauseAtExit, false,                                      \\\n+  product(bool, PauseAtExit, false, DIAGNOSTIC,                             \\\n@@ -2362,1 +2374,1 @@\n-  experimental(uintx, SymbolTableSize, defaultSymbolTableSize,              \\\n+  product(uintx, SymbolTableSize, defaultSymbolTableSize, EXPERIMENTAL,     \\\n@@ -2374,1 +2386,1 @@\n-  diagnostic(bool, StringDeduplicationResizeALot, false,                    \\\n+  product(bool, StringDeduplicationResizeALot, false, DIAGNOSTIC,           \\\n@@ -2377,1 +2389,1 @@\n-  diagnostic(bool, StringDeduplicationRehashALot, false,                    \\\n+  product(bool, StringDeduplicationRehashALot, false, DIAGNOSTIC,           \\\n@@ -2380,1 +2392,1 @@\n-  diagnostic(bool, WhiteBoxAPI, false,                                      \\\n+  product(bool, WhiteBoxAPI, false, DIAGNOSTIC,                             \\\n@@ -2383,1 +2395,1 @@\n-  experimental(intx, SurvivorAlignmentInBytes, 0,                           \\\n+  product(intx, SurvivorAlignmentInBytes, 0, EXPERIMENTAL,                  \\\n@@ -2404,1 +2416,1 @@\n-  diagnostic(intx, ArchiveRelocationMode, 0,                                \\\n+  product(intx, ArchiveRelocationMode, 0, DIAGNOSTIC,                       \\\n@@ -2412,1 +2424,1 @@\n-  experimental(size_t, ArrayAllocatorMallocLimit, (size_t)-1,               \\\n+  product(size_t, ArrayAllocatorMallocLimit, (size_t)-1, EXPERIMENTAL,      \\\n@@ -2416,1 +2428,1 @@\n-  experimental(bool, AlwaysAtomicAccesses, false,                           \\\n+  product(bool, AlwaysAtomicAccesses, false, EXPERIMENTAL,                  \\\n@@ -2419,1 +2431,1 @@\n-  diagnostic(bool, UseUnalignedAccesses, false,                             \\\n+  product(bool, UseUnalignedAccesses, false, DIAGNOSTIC,                    \\\n@@ -2426,1 +2438,1 @@\n-  diagnostic(bool, CheckIntrinsics, true,                                   \\\n+  product(bool, CheckIntrinsics, true, DIAGNOSTIC,                          \\\n@@ -2439,1 +2451,1 @@\n-  diagnostic_pd(intx, InitArrayShortSize,                                   \\\n+  product_pd(intx, InitArrayShortSize, DIAGNOSTIC,                          \\\n@@ -2446,1 +2458,1 @@\n-  diagnostic(bool, CompilerDirectivesIgnoreCompileCommands, false,          \\\n+  product(bool, CompilerDirectivesIgnoreCompileCommands, false, DIAGNOSTIC, \\\n@@ -2449,1 +2461,1 @@\n-  diagnostic(bool, CompilerDirectivesPrint, false,                          \\\n+  product(bool, CompilerDirectivesPrint, false, DIAGNOSTIC,                 \\\n@@ -2451,1 +2463,1 @@\n-  diagnostic(int,  CompilerDirectivesLimit, 50,                             \\\n+  product(int,  CompilerDirectivesLimit, 50, DIAGNOSTIC,                    \\\n@@ -2458,1 +2470,1 @@\n-  experimental(ccstr, AllocateOldGenAt, NULL,                               \\\n+  product(ccstr, AllocateOldGenAt, NULL, EXPERIMENTAL,                      \\\n@@ -2468,1 +2480,1 @@\n-  diagnostic(bool, ShowRegistersOnAssert, true,                             \\\n+  product(bool, ShowRegistersOnAssert, true, DIAGNOSTIC,                    \\\n@@ -2471,1 +2483,1 @@\n-  diagnostic(bool, UseSwitchProfiling, true,                                \\\n+  product(bool, UseSwitchProfiling, true, DIAGNOSTIC,                       \\\n@@ -2486,1 +2498,1 @@\n-  experimental(bool, UseFastUnorderedTimeStamps, false,                     \\\n+  product(bool, UseFastUnorderedTimeStamps, false, EXPERIMENTAL,            \\\n@@ -2504,1 +2516,1 @@\n-  diagnostic(ccstrlist, ForceNonTearable, \"\",                               \\\n+  product(ccstrlist, ForceNonTearable, \"\", DIAGNOSTIC,                      \\\n@@ -2512,2 +2524,4 @@\n-  diagnostic(bool, DeoptimizeNMethodBarriersALot, false,                    \\\n-                \"Make nmethod barriers deoptimise a lot.\")                  \\\n+  product(bool, DeoptimizeNMethodBarriersALot, false, DIAGNOSTIC,           \\\n+                \"Make nmethod barriers deoptimise a lot.\")\n+\n+\/\/ end of RUNTIME_FLAGS\n@@ -2517,7 +2531,2 @@\n-#define DECLARE_PRODUCT_FLAG(type, name, value, doc)      extern \"C\" type name;\n-#define DECLARE_PD_PRODUCT_FLAG(type, name, doc)          extern \"C\" type name;\n-#define DECLARE_DIAGNOSTIC_FLAG(type, name, value, doc)   extern \"C\" type name;\n-#define DECLARE_PD_DIAGNOSTIC_FLAG(type, name, doc)       extern \"C\" type name;\n-#define DECLARE_EXPERIMENTAL_FLAG(type, name, value, doc) extern \"C\" type name;\n-#define DECLARE_MANAGEABLE_FLAG(type, name, value, doc)   extern \"C\" type name;\n-#define DECLARE_PRODUCT_RW_FLAG(type, name, value, doc)   extern \"C\" type name;\n+#define DECLARE_PRODUCT_FLAG(type, name, value, ...)      extern \"C\" type name;\n+#define DECLARE_PD_PRODUCT_FLAG(type, name, ...)          extern \"C\" type name;\n@@ -2525,3 +2534,3 @@\n-#define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    const type name = value;\n-#define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        const type name = pd_##name;\n-#define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   const type name = value;\n+#define DECLARE_DEVELOPER_FLAG(type, name, value, ...)    const type name = value;\n+#define DECLARE_PD_DEVELOPER_FLAG(type, name, ...)        const type name = pd_##name;\n+#define DECLARE_NOTPRODUCT_FLAG(type, name, value, ...)   const type name = value;\n@@ -2529,3 +2538,3 @@\n-#define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern \"C\" type name;\n-#define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern \"C\" type name;\n-#define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern \"C\" type name;\n+#define DECLARE_DEVELOPER_FLAG(type, name, value, ...)    extern \"C\" type name;\n+#define DECLARE_PD_DEVELOPER_FLAG(type, name, ...)        extern \"C\" type name;\n+#define DECLARE_NOTPRODUCT_FLAG(type, name, value, ...)   extern \"C\" type name;\n@@ -2533,18 +2542,6 @@\n-\/\/ Special LP64 flags, product only needed for now.\n-#ifdef _LP64\n-#define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) extern \"C\" type name;\n-#else\n-#define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) const type name = value;\n-#endif \/\/ _LP64\n-ALL_FLAGS(DECLARE_DEVELOPER_FLAG,     \\\n-          DECLARE_PD_DEVELOPER_FLAG,  \\\n-          DECLARE_PRODUCT_FLAG,       \\\n-          DECLARE_PD_PRODUCT_FLAG,    \\\n-          DECLARE_DIAGNOSTIC_FLAG,    \\\n-          DECLARE_PD_DIAGNOSTIC_FLAG, \\\n-          DECLARE_EXPERIMENTAL_FLAG,  \\\n-          DECLARE_NOTPRODUCT_FLAG,    \\\n-          DECLARE_MANAGEABLE_FLAG,    \\\n-          DECLARE_PRODUCT_RW_FLAG,    \\\n-          DECLARE_LP64_PRODUCT_FLAG,  \\\n-          IGNORE_RANGE,               \\\n+ALL_FLAGS(DECLARE_DEVELOPER_FLAG,\n+          DECLARE_PD_DEVELOPER_FLAG,\n+          DECLARE_PRODUCT_FLAG,\n+          DECLARE_PD_PRODUCT_FLAG,\n+          DECLARE_NOTPRODUCT_FLAG,\n+          IGNORE_RANGE,\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":237,"deletions":240,"binary":false,"changes":477,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  JavaThread* thread = (JavaThread *)THREAD;\n+  JavaThread* thread = THREAD->as_Java_thread();\n@@ -92,1 +92,1 @@\n-  _thread       = (JavaThread *)thread;\n+  _thread       = thread;\n@@ -362,2 +362,1 @@\n-  JavaThread* thread = (JavaThread*)THREAD;\n-  assert(thread->is_Java_thread(), \"must be called by a java thread\");\n+  JavaThread* thread = THREAD->as_Java_thread();\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-           is_frame_handle((JavaThread*)thread, handle))) {\n+           is_frame_handle(thread->as_Java_thread(), handle))) {\n@@ -305,1 +305,1 @@\n-          JavaThread::current()->thread_state() == _thread_in_native);\n+          thread->as_Java_thread()->thread_state() == _thread_in_native);\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1044,1 +1044,1 @@\n-            JvmtiExport::clear_detected_exception((JavaThread*)THREAD);\n+            JvmtiExport::clear_detected_exception(THREAD->as_Java_thread());\n@@ -1158,1 +1158,1 @@\n-      JvmtiExport::clear_detected_exception((JavaThread*)THREAD);\n+      JvmtiExport::clear_detected_exception(THREAD->as_Java_thread());\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -697,1 +697,0 @@\n-  assert(thread->is_Java_thread(), \"not a Java thread\");\n@@ -787,1 +786,0 @@\n-  assert(thread->is_Java_thread(), \"polling reference encountered by VM thread\");\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -956,1 +956,1 @@\n-      oop obj = ((JavaThread*)thread)->threadObj();\n+      oop obj = thread->as_Java_thread()->threadObj();\n@@ -3515,2 +3515,1 @@\n-  assert(thread->is_Java_thread(), \"Only Java threads have a stack reserved zone\");\n-  thread->enable_stack_reserved_zone();\n+    thread->enable_stack_reserved_zone();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -465,2 +465,1 @@\n-  assert(self->is_Java_thread(), \"invariant\");\n-  assert(((JavaThread *) self)->thread_state() == _thread_in_Java, \"invariant\");\n+  assert(self->as_Java_thread()->thread_state() == _thread_in_Java, \"invariant\");\n@@ -480,1 +479,1 @@\n-    assert(mon->object() == obj, \"invariant\");\n+    assert(mon->object() == oop(obj), \"invariant\");\n@@ -516,2 +515,1 @@\n-  assert(self->is_Java_thread(), \"invariant\");\n-  assert(((JavaThread *) self)->thread_state() == _thread_in_Java, \"invariant\");\n+  assert(self->as_Java_thread()->thread_state() == _thread_in_Java, \"invariant\");\n@@ -578,2 +576,1 @@\n-  assert(current->is_Java_thread(), \"must be for java object synchronization\");\n-  JavaThread* self = (JavaThread*) current;\n+  JavaThread* self = current->as_Java_thread();\n@@ -709,1 +706,1 @@\n-        assert(((oop)(m->object()))->mark() == mark, \"invariant\");\n+        assert(m->object()->mark() == mark, \"invariant\");\n@@ -1460,1 +1457,1 @@\n-      f->do_oop((oop*)mid->object_addr());\n+      f->do_oop(mid->object_addr());\n@@ -1928,1 +1925,1 @@\n-    \/\/ Note that we allocate the objectmonitor speculatively, _before_ attempting\n+    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_ attempting\n@@ -1930,3 +1927,3 @@\n-    \/\/ allocated the objectmonitor, and then finally STed the address of the\n-    \/\/ objectmonitor into the mark.  This was correct, but artificially lengthened\n-    \/\/ the interval in which INFLATED appeared in the mark, thus increasing\n+    \/\/ allocated the ObjectMonitor, and then finally STed the address of the\n+    \/\/ ObjectMonitor into the mark.  This was correct, but artificially lengthened\n+    \/\/ the interval in which INFLATING appeared in the mark, thus increasing\n@@ -1935,1 +1932,1 @@\n-    \/\/ We now use per-thread private objectmonitor free lists.\n+    \/\/ We now use per-thread private ObjectMonitor free lists.\n@@ -1938,1 +1935,1 @@\n-    \/\/ multiple objectmonitors en-mass from the global free list to its local free list.\n+    \/\/ multiple ObjectMonitors en-mass from the global free list to its local free list.\n@@ -1948,1 +1945,1 @@\n-      \/\/ Optimistically prepare the objectmonitor - anticipate successful CAS\n+      \/\/ Optimistically prepare the ObjectMonitor - anticipate successful CAS\n@@ -2185,1 +2182,1 @@\n-  const oop obj = (oop) mid->object();\n+  const oop obj = mid->object();\n@@ -2462,1 +2459,0 @@\n-  assert(Thread::current()->is_Java_thread(), \"precondition\");\n@@ -2907,1 +2903,1 @@\n-  const oop obj = (oop)n->object();\n+  const oop obj = n->object();\n@@ -3017,1 +3013,1 @@\n-        const oop obj = (oop) cur->object();\n+        const oop obj = cur->object();\n@@ -3047,1 +3043,1 @@\n-        const oop obj = (oop) cur->object();\n+        const oop obj = cur->object();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -359,2 +359,2 @@\n-    ((JavaThread*) this)->set_stack_overflow_limit();\n-    ((JavaThread*) this)->set_reserved_stack_activation(stack_base());\n+    as_Java_thread()->set_stack_overflow_limit();\n+    as_Java_thread()->set_reserved_stack_activation(stack_base());\n@@ -487,1 +487,1 @@\n-         !((JavaThread *) thread)->on_thread_list() ||\n+         !thread->as_Java_thread()->on_thread_list() ||\n@@ -489,1 +489,1 @@\n-         ThreadsSMRSupport::is_a_protected_JavaThread_with_lock((JavaThread *) thread),\n+         ThreadsSMRSupport::is_a_protected_JavaThread_with_lock(thread->as_Java_thread()),\n@@ -518,1 +518,1 @@\n-      java_lang_Thread::set_thread_status(((JavaThread*)thread)->threadObj(),\n+      java_lang_Thread::set_thread_status(thread->as_Java_thread()->threadObj(),\n@@ -531,1 +531,1 @@\n-    JavaThread* target = (JavaThread*)thr;\n+    JavaThread* target = thr->as_Java_thread();\n@@ -1009,1 +1009,1 @@\n-  if (((JavaThread*)this)->thread_state() != _thread_in_vm) {\n+  if (this->as_Java_thread()->thread_state() != _thread_in_vm) {\n@@ -1034,1 +1034,1 @@\n-  return os::create_main_thread((JavaThread*)this);\n+  return os::create_main_thread(this->as_Java_thread());\n@@ -2283,1 +2283,1 @@\n-    return (JavaThread*) thread;\n+    return thread->as_Java_thread();\n@@ -2287,2 +2287,1 @@\n-    JavaThread *ret=op == NULL ? NULL : (JavaThread *)op->calling_thread();\n-    assert(ret->is_Java_thread(), \"must be a Java thread\");\n+    JavaThread *ret = op == NULL ? NULL : op->calling_thread()->as_Java_thread();\n@@ -2559,2 +2558,1 @@\n-  assert(_anchor.walkable() ||\n-         (is_Java_thread() && !((JavaThread*)this)->has_last_Java_frame()),\n+  assert(_anchor.walkable() || !has_last_Java_frame(),\n@@ -3210,4 +3208,3 @@\n-    Thread *cur = Thread::current();\n-    if (!(cur->is_Java_thread() && cur == this)) {\n-      \/\/ Current JavaThreads are allowed to get their own name without\n-      \/\/ the Threads_lock.\n+    \/\/ Current JavaThreads are allowed to get their own name without\n+    \/\/ the Threads_lock.\n+    if (Thread::current() != this) {\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+class JavaThread;\n+\n@@ -505,0 +507,2 @@\n+  inline JavaThread* as_Java_thread();\n+  inline const JavaThread* as_Java_thread() const;\n@@ -2120,3 +2124,1 @@\n-  Thread* thread = Thread::current();\n-  assert(thread->is_Java_thread(), \"just checking\");\n-  return (JavaThread*)thread;\n+  return Thread::current()->as_Java_thread();\n@@ -2219,0 +2221,10 @@\n+inline JavaThread* Thread::as_Java_thread() {\n+  assert(is_Java_thread(), \"incorrect cast to JavaThread\");\n+  return static_cast<JavaThread*>(this);\n+}\n+\n+inline const JavaThread* Thread::as_Java_thread() const {\n+  assert(is_Java_thread(), \"incorrect cast to const JavaThread\");\n+  return static_cast<const JavaThread*>(this);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -153,3 +153,1 @@\n-  JavaThread *thread = (JavaThread *)calling_thread();\n-  assert(thread->is_Java_thread(), \"must be a Java thread\");\n-  thread->make_zombies();\n+  calling_thread()->as_Java_thread()->make_zombies();\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -341,3 +341,3 @@\n-  \/********************************\/                                                                                                 \\\n-  \/* MethodOop-related structures *\/                                                                                                 \\\n-  \/********************************\/                                                                                                 \\\n+  \/*****************************\/                                                                                                    \\\n+  \/* Method related structures *\/                                                                                                    \\\n+  \/*****************************\/                                                                                                    \\\n@@ -1287,3 +1287,3 @@\n-  \/*************************************\/                                 \\\n-  \/* MethodOop-related data structures *\/                                 \\\n-  \/*************************************\/                                 \\\n+  \/**********************************\/                                    \\\n+  \/* Method related data structures *\/                                    \\\n+  \/**********************************\/                                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1099,1 +1099,1 @@\n-  JavaThread* thread = (JavaThread*) THREAD;\n+  JavaThread* thread = THREAD->as_Java_thread();\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -990,6 +990,6 @@\n-template<class T> inline T MAX2(T a, T b)           { return (a > b) ? a : b; }\n-template<class T> inline T MIN2(T a, T b)           { return (a < b) ? a : b; }\n-template<class T> inline T MAX3(T a, T b, T c)      { return MAX2(MAX2(a, b), c); }\n-template<class T> inline T MIN3(T a, T b, T c)      { return MIN2(MIN2(a, b), c); }\n-template<class T> inline T MAX4(T a, T b, T c, T d) { return MAX2(MAX3(a, b, c), d); }\n-template<class T> inline T MIN4(T a, T b, T c, T d) { return MIN2(MIN3(a, b, c), d); }\n+template<class T> constexpr T MAX2(T a, T b)           { return (a > b) ? a : b; }\n+template<class T> constexpr T MIN2(T a, T b)           { return (a < b) ? a : b; }\n+template<class T> constexpr T MAX3(T a, T b, T c)      { return MAX2(MAX2(a, b), c); }\n+template<class T> constexpr T MIN3(T a, T b, T c)      { return MIN2(MIN2(a, b), c); }\n+template<class T> constexpr T MAX4(T a, T b, T c, T d) { return MAX2(MAX3(a, b, c), d); }\n+template<class T> constexpr T MIN4(T a, T b, T c, T d) { return MIN2(MIN3(a, b, c), d); }\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"metaprogramming\/isIntegral.hpp\"\n-#include \"metaprogramming\/isSigned.hpp\"\n@@ -34,0 +32,2 @@\n+#include <limits>\n+#include <type_traits>\n@@ -37,2 +37,3 @@\n-template <typename T>\n-bool is_power_of_2(T x) {\n+\/\/ Returns true iff there exists integer i such that (T(1) << i) == x.\n+template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr bool is_power_of_2(T x) {\n@@ -68,7 +69,4 @@\n-\/\/ Round down to the closest power of two greater to or equal to the given\n-\/\/ value.\n-\n-\/\/ Signed version: 0 is an invalid input, negative values are invalid\n-template <typename T>\n-inline typename EnableIf<IsSigned<T>::value, T>::type round_down_power_of_2(T value) {\n-  STATIC_ASSERT(IsIntegral<T>::value);\n+\/\/ Round down to the closest power of two less than or equal to the given value.\n+\/\/ precondition: value > 0.\n+template<typename T, ENABLE_IF(std::is_integral<T>::value)>\n+inline T round_down_power_of_2(T value) {\n@@ -77,11 +75,0 @@\n-  assert(lz < sizeof(T) * BitsPerByte, \"Sanity\");\n-  return T(1) << (sizeof(T) * BitsPerByte - 1 - lz);\n-}\n-\n-\/\/ Unsigned version: 0 is an invalid input\n-template <typename T>\n-inline typename EnableIf<!IsSigned<T>::value, T>::type round_down_power_of_2(T value) {\n-  STATIC_ASSERT(IsIntegral<T>::value);\n-  assert(value != 0, \"Invalid value\");\n-  uint32_t lz = count_leading_zeros(value);\n-  assert(lz < sizeof(T) * BitsPerByte, \"Sanity\");\n@@ -91,10 +78,5 @@\n-\/\/ Round up to the closest power of two greater to or equal to\n-\/\/ the given value.\n-\n-\/\/ Signed version: 0 is an invalid input, negative values are invalid,\n-\/\/ overflows with assert if value is larger than 2^30 or 2^62 for 32- and\n-\/\/ 64-bit integers, respectively\n-template <typename T>\n-inline typename EnableIf<IsSigned<T>::value, T>::type round_up_power_of_2(T value) {\n-  STATIC_ASSERT(IsIntegral<T>::value);\n-  STATIC_ASSERT(IsSigned<T>::value);\n+\/\/ Round up to the closest power of two greater to or equal to the given value.\n+\/\/ precondition: value > 0.\n+\/\/ precondition: value <= maximum power of two representable by T.\n+template<typename T, ENABLE_IF(std::is_integral<T>::value)>\n+inline T round_up_power_of_2(T value) {\n@@ -102,0 +84,2 @@\n+  const T max_value = std::numeric_limits<T>::max();\n+  assert(value <= (max_value - (max_value >> 1)), \"Overflow\");\n@@ -106,18 +90,0 @@\n-  assert(lz < sizeof(T) * BitsPerByte, \"Sanity\");\n-  assert(lz > 1, \"Will overflow\");\n-  return T(1) << (sizeof(T) * BitsPerByte - lz);\n-}\n-\n-\/\/ Unsigned version: 0 is an invalid input, overflows with assert if value\n-\/\/ is larger than 2^31 or 2^63 for 32- and 64-bit integers, respectively\n-template <typename T>\n-inline typename EnableIf<!IsSigned<T>::value, T>::type round_up_power_of_2(T value) {\n-  STATIC_ASSERT(IsIntegral<T>::value);\n-  STATIC_ASSERT(!IsSigned<T>::value);\n-  assert(value != 0, \"Invalid value\");\n-  if (is_power_of_2(value)) {\n-    return value;\n-  }\n-  uint32_t lz = count_leading_zeros(value);\n-  assert(lz < sizeof(T) * BitsPerByte, \"Sanity\");\n-  assert(lz > 0, \"Will overflow\");\n@@ -127,26 +93,3 @@\n-\/\/ Helper function to get the maximum positive value. Implemented here\n-\/\/ since using std::numeric_limits<T>::max() seems problematic on some\n-\/\/ platforms.\n-\n-template <typename T> T max_value() {\n-  if (IsSigned<T>::value) {\n-    \/\/ Highest positive power of two expressible in the type\n-    uint64_t val = static_cast<T>(1) << (sizeof(T) * BitsPerByte - 2);\n-    \/\/ Fill lower bits with ones\n-    val |= val >> 1;\n-    val |= val >> 2;\n-    val |= val >> 4;\n-    if (sizeof(T) >= 2)  val |= val >> 8;\n-    if (sizeof(T) >= 4)  val |= val >> 16;\n-    if (sizeof(T) == 8)  val |= val >> 32;\n-    return (T)val;\n-  } else {\n-    return ~(static_cast<T>(0));\n-  }\n-}\n-\n-\n-\/\/ Accepts 0 (returns 1), overflows with assert if value is larger than\n-\/\/ or equal to 2^31 (signed: 2^30) or 2^63 (signed: 2^62), for 32-\n-\/\/ and 64-bit integers, respectively\n-template <typename T>\n+\/\/ precondition: if signed, value >= 0.\n+\/\/ precondition: value < maximum power of two representable by T.\n+template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n@@ -155,1 +98,1 @@\n-  assert(value != max_value<T>(), \"Overflow\");\n+  assert(value < std::numeric_limits<T>::max(), \"Overflow\");\n","filename":"src\/hotspot\/share\/utilities\/powerOfTwo.hpp","additions":20,"deletions":77,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2251,0 +2251,3 @@\n+            public void bindToLoader(ModuleLayer layer, ClassLoader loader) {\n+                layer.bindToLoader(loader);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -298,10 +298,3 @@\n-        String name = tree.getName().toString();\n-        if (name.startsWith(\"#\")) {\n-            int v = StringUtils.toLowerCase(name).startsWith(\"#x\")\n-                    ? Integer.parseInt(name.substring(2), 16)\n-                    : Integer.parseInt(name.substring(1), 10);\n-            if (!Entity.isValid(v)) {\n-                env.messages.error(HTML, tree, \"dc.entity.invalid\", name);\n-            }\n-        } else if (!Entity.isValid(name)) {\n-            env.messages.error(HTML, tree, \"dc.entity.invalid\", name);\n+        String s = env.trees.getCharacters(tree);\n+        if (s == null) {\n+            env.messages.error(HTML, tree, \"dc.entity.invalid\", tree.getName());\n@@ -310,0 +303,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/doclint\/Checker.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -244,0 +244,6 @@\n+    \/**\n+     * Flags an erroneous TypeSymbol as viable for recovery.\n+     * TypeSymbols only.\n+     *\/\n+    public static final long RECOVERABLE = 1L<<40;\n+\n@@ -535,0 +541,1 @@\n+        RECOVERABLE(Flags.RECOVERABLE),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+    final AttrRecover attrRecover;\n@@ -159,0 +160,1 @@\n+        attrRecover = AttrRecover.instance(context);\n@@ -442,1 +444,1 @@\n-                    null, DeferredAttr.AttributionMode.ANALYZER,\n+                    null, DeferredAttr.AttributionMode.ATTRIB_TO_TREE,\n@@ -444,0 +446,1 @@\n+            attrRecover.doRecovery();\n@@ -761,0 +764,1 @@\n+        attrRecover.doRecovery();\n@@ -2166,0 +2170,1 @@\n+            attrRecover.doRecovery();\n@@ -3245,0 +3250,1 @@\n+            attrRecover.doRecovery();\n@@ -4461,4 +4467,1 @@\n-                Type pt = resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, sym, env.info.pendingResolutionPhase));\n-                Type owntype = checkIdInternal(tree, site, sym, pt, env, resultInfo);\n-                resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));\n-                return owntype;\n+                return attrRecover.recoverMethodInvocation(tree, site, sym, env, resultInfo);\n@@ -5070,1 +5073,3 @@\n-        if (tree.errs != null)\n+        if (tree.errs != null) {\n+            Env<AttrContext> errEnv = env.dup(env.tree);\n+            errEnv.info.returnResult = unknownExprInfo;\n@@ -5072,1 +5077,2 @@\n-                attribTree(err, env, new ResultInfo(KindSelector.ERR, pt()));\n+                attribTree(err, errEnv, new ResultInfo(KindSelector.ERR, pt()));\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+    AttrRecover attrRecover;\n@@ -129,0 +130,1 @@\n+        attrRecover = AttrRecover.instance(context);\n@@ -4109,6 +4111,6 @@\n-            Symbol sym = bestCandidate();\n-            return types.createErrorType(name, location, sym != null ? sym.type : syms.errSymbol.type).tsym;\n-        }\n-\n-        protected Symbol bestCandidate() {\n-            return errCandidate().fst;\n+            Pair<Symbol, JCDiagnostic> cand = errCandidate();\n+            TypeSymbol errSymbol = types.createErrorType(name, location, cand != null ? cand.fst.type : syms.errSymbol.type).tsym;\n+            if (cand != null) {\n+                attrRecover.wrongMethodSymbolCandidate(errSymbol, cand.fst, cand.snd);\n+            }\n+            return errSymbol;\n@@ -4247,1 +4249,1 @@\n-        protected Symbol bestCandidate() {\n+        protected Pair<Symbol, JCDiagnostic> errCandidate() {\n@@ -4251,1 +4253,2 @@\n-                return filteredCandidates.keySet().iterator().next();\n+                return Pair.of(filteredCandidates.keySet().iterator().next(),\n+                               filteredCandidates.values().iterator().next());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -619,1 +619,0 @@\n-        JNITypeParser sourceSig = new JNITypeParser(type().signature());\n@@ -623,2 +622,5 @@\n-        if (destSig.isArray() && !sourceSig.isArray()) {\n-            throw new InvalidTypeException(\"Can't assign non-array value to an array\");\n+        if (destSig.isArray()) {\n+            JNITypeParser sourceSig = new JNITypeParser(type().signature());\n+            if (!sourceSig.isArray()) {\n+                throw new InvalidTypeException(\"Can't assign non-array value to an array\");\n+            }\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ObjectReferenceImpl.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}