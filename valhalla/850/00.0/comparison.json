{"files":[{"patch":"@@ -114,0 +114,1 @@\n+    --enable-preview -source $(JDK_SOURCE_TARGET_VERSION) \\\n@@ -120,0 +121,1 @@\n+    --enable-preview -source $(JDK_SOURCE_TARGET_VERSION) \\\n","filename":"make\/Docs.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -854,1 +854,1 @@\n-            var jdk_subdir = (o.jdk_subdir != null ? o.jdk_subdir : \"jdk-\" + data.version);\n+            var jdk_subdir = \"jdk-\" + data.version;\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,0 +99,9 @@\n+        --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.java.lang.constant=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.components=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.classfile.impl=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED \\\n+        --add-exports java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -15100,2 +15100,1 @@\n-      __ fcvtsh($tmp$$FloatRegister, $src$$FloatRegister);\n-      __ smov($dst$$Register, $tmp$$FloatRegister, __ H, 0);\n+      __ flt_to_flt16($dst$$Register, $src$$FloatRegister, $tmp$$FloatRegister);\n@@ -15113,2 +15112,1 @@\n-      __ mov($tmp$$FloatRegister, __ H, 0, $src$$Register);\n-      __ fcvths($dst$$FloatRegister, $tmp$$FloatRegister);\n+      __ flt16_to_flt($dst$$FloatRegister, $src$$Register, $tmp$$FloatRegister);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2001,1 +2001,1 @@\n-void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op) {\n+void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {\n@@ -2005,0 +2005,2 @@\n+  case lir_f2hf: __ flt_to_flt16(dest->as_register(), value->as_float_reg(), tmp->as_float_reg()); break;\n+  case lir_hf2f: __ flt16_to_flt(dest->as_float_reg(), value->as_register(), tmp->as_float_reg()); break;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -773,1 +773,3 @@\n-    case vmIntrinsics::_dsqrt_strict: {\n+    case vmIntrinsics::_dsqrt_strict:\n+    case vmIntrinsics::_floatToFloat16:\n+    case vmIntrinsics::_float16ToFloat: {\n@@ -777,0 +779,1 @@\n+      LIR_Opr src = value.result();\n@@ -782,1 +785,1 @@\n-          __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);\n+          __ sqrt(src, dst, LIR_OprFact::illegalOpr);\n@@ -786,1 +789,13 @@\n-          __ abs(value.result(), dst, LIR_OprFact::illegalOpr);\n+          __ abs(src, dst, LIR_OprFact::illegalOpr);\n+          break;\n+        }\n+        case vmIntrinsics::_floatToFloat16: {\n+          LIR_Opr tmp = new_register(T_FLOAT);\n+          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n+          __ f2hf(src, dst, tmp);\n+          break;\n+        }\n+        case vmIntrinsics::_float16ToFloat: {\n+          LIR_Opr tmp = new_register(T_FLOAT);\n+          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n+          __ hf2f(src, dst, tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -521,0 +521,4 @@\n+  void flt_to_flt16(Register dst, FloatRegister src, FloatRegister tmp) {\n+    fcvtsh(tmp, src);\n+    smov(dst, tmp, H, 0);\n+  }\n@@ -522,1 +526,4 @@\n-public:\n+  void flt16_to_flt(FloatRegister dst, Register src, FloatRegister tmp) {\n+    mov(tmp, H, 0, src);\n+    fcvths(dst, tmp);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -150,2 +150,0 @@\n-  if (!InlineIntrinsics) return NULL; \/\/ Generate a vanilla entry\n-\n@@ -304,0 +302,34 @@\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() {\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n+  \/\/ r19_sender_sp: sender sp\n+  \/\/ stack:\n+  \/\/        [ arg ] <-- esp\n+  \/\/        [ arg ]\n+  \/\/ retaddr in lr\n+  \/\/ result in v0\n+\n+  address entry_point = __ pc();\n+  __ ldrw(c_rarg0, Address(esp));\n+  __ flt16_to_flt(v0, c_rarg0, v1);\n+  __ mov(sp, r19_sender_sp); \/\/ Restore caller's SP\n+  __ br(lr);\n+  return entry_point;\n+}\n+\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() {\n+  assert(VM_Version::supports_float16(), \"this intrinsic is not supported\");\n+  \/\/ r19_sender_sp: sender sp\n+  \/\/ stack:\n+  \/\/        [ arg ] <-- esp\n+  \/\/        [ arg ]\n+  \/\/ retaddr in lr\n+  \/\/ result in c_rarg0\n+\n+  address entry_point = __ pc();\n+  __ ldrs(v0, Address(esp));\n+  __ flt_to_flt16(c_rarg0, v0, v1);\n+  __ mov(sp, r19_sender_sp); \/\/ Restore caller's SP\n+  __ br(lr);\n+  return entry_point;\n+}\n+\n@@ -929,2 +961,2 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -932,3 +964,3 @@\n-    \/\/ rmethod: Method*\n-    \/\/ r19_sender_sp: senderSP must preserved for slow path\n-    \/\/ esp: args\n+  \/\/ rmethod: Method*\n+  \/\/ r19_sender_sp: senderSP must preserved for slow path\n+  \/\/ esp: args\n@@ -936,3 +968,3 @@\n-    Label slow_path;\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+  Label slow_path;\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n@@ -940,2 +972,2 @@\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n@@ -943,4 +975,4 @@\n-    \/\/ Load parameters\n-    const Register crc = c_rarg0;  \/\/ crc\n-    const Register val = c_rarg1;  \/\/ source java byte value\n-    const Register tbl = c_rarg2;  \/\/ scratch\n+  \/\/ Load parameters\n+  const Register crc = c_rarg0;  \/\/ crc\n+  const Register val = c_rarg1;  \/\/ source java byte value\n+  const Register tbl = c_rarg2;  \/\/ scratch\n@@ -948,3 +980,3 @@\n-    \/\/ Arguments are reversed on java expression stack\n-    __ ldrw(val, Address(esp, 0));              \/\/ byte value\n-    __ ldrw(crc, Address(esp, wordSize));       \/\/ Initial CRC\n+  \/\/ Arguments are reversed on java expression stack\n+  __ ldrw(val, Address(esp, 0));              \/\/ byte value\n+  __ ldrw(crc, Address(esp, wordSize));       \/\/ Initial CRC\n@@ -952,3 +984,3 @@\n-    uint64_t offset;\n-    __ adrp(tbl, ExternalAddress(StubRoutines::crc_table_addr()), offset);\n-    __ add(tbl, tbl, offset);\n+  uint64_t offset;\n+  __ adrp(tbl, ExternalAddress(StubRoutines::crc_table_addr()), offset);\n+  __ add(tbl, tbl, offset);\n@@ -956,3 +988,3 @@\n-    __ mvnw(crc, crc); \/\/ ~crc\n-    __ update_byte_crc32(crc, val, tbl);\n-    __ mvnw(crc, crc); \/\/ ~crc\n+  __ mvnw(crc, crc); \/\/ ~crc\n+  __ update_byte_crc32(crc, val, tbl);\n+  __ mvnw(crc, crc); \/\/ ~crc\n@@ -960,1 +992,1 @@\n-    \/\/ result in c_rarg0\n+  \/\/ result in c_rarg0\n@@ -962,2 +994,2 @@\n-    __ andr(sp, r19_sender_sp, -16);\n-    __ ret(lr);\n+  __ andr(sp, r19_sender_sp, -16);\n+  __ ret(lr);\n@@ -965,6 +997,4 @@\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -979,2 +1009,2 @@\n-  if (UseCRC32Intrinsics) {\n-    address entry = __ pc();\n+  assert(UseCRC32Intrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -982,32 +1012,2 @@\n-    \/\/ rmethod,: Method*\n-    \/\/ r19_sender_sp: senderSP must preserved for slow path\n-\n-    Label slow_path;\n-    \/\/ If we need a safepoint check, generate full interpreter entry.\n-    __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n-\n-    \/\/ We don't generate local frame and don't align stack because\n-    \/\/ we call stub code and there is no safepoint on this path.\n-\n-    \/\/ Load parameters\n-    const Register crc = c_rarg0;  \/\/ crc\n-    const Register buf = c_rarg1;  \/\/ source java byte array address\n-    const Register len = c_rarg2;  \/\/ length\n-    const Register off = len;      \/\/ offset (never overlaps with 'len')\n-\n-    \/\/ Arguments are reversed on java expression stack\n-    \/\/ Calculate address of start element\n-    if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n-      __ ldr(buf, Address(esp, 2*wordSize)); \/\/ long buf\n-      __ ldrw(off, Address(esp, wordSize)); \/\/ offset\n-      __ add(buf, buf, off); \/\/ + offset\n-      __ ldrw(crc,   Address(esp, 4*wordSize)); \/\/ Initial CRC\n-    } else {\n-      __ ldr(buf, Address(esp, 2*wordSize)); \/\/ byte[] array\n-      __ add(buf, buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ ldrw(off, Address(esp, wordSize)); \/\/ offset\n-      __ add(buf, buf, off); \/\/ + offset\n-      __ ldrw(crc,   Address(esp, 3*wordSize)); \/\/ Initial CRC\n-    }\n-    \/\/ Can now load 'len' since we're finished with 'off'\n-    __ ldrw(len, Address(esp, 0x0)); \/\/ Length\n+  \/\/ rmethod,: Method*\n+  \/\/ r19_sender_sp: senderSP must preserved for slow path\n@@ -1015,1 +1015,29 @@\n-    __ andr(sp, r19_sender_sp, -16); \/\/ Restore the caller's SP\n+  Label slow_path;\n+  \/\/ If we need a safepoint check, generate full interpreter entry.\n+  __ safepoint_poll(slow_path, false \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n+\n+  \/\/ We don't generate local frame and don't align stack because\n+  \/\/ we call stub code and there is no safepoint on this path.\n+\n+  \/\/ Load parameters\n+  const Register crc = c_rarg0;  \/\/ crc\n+  const Register buf = c_rarg1;  \/\/ source java byte array address\n+  const Register len = c_rarg2;  \/\/ length\n+  const Register off = len;      \/\/ offset (never overlaps with 'len')\n+\n+  \/\/ Arguments are reversed on java expression stack\n+  \/\/ Calculate address of start element\n+  if (kind == Interpreter::java_util_zip_CRC32_updateByteBuffer) {\n+    __ ldr(buf, Address(esp, 2*wordSize)); \/\/ long buf\n+    __ ldrw(off, Address(esp, wordSize)); \/\/ offset\n+    __ add(buf, buf, off); \/\/ + offset\n+    __ ldrw(crc,   Address(esp, 4*wordSize)); \/\/ Initial CRC\n+  } else {\n+    __ ldr(buf, Address(esp, 2*wordSize)); \/\/ byte[] array\n+    __ add(buf, buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ ldrw(off, Address(esp, wordSize)); \/\/ offset\n+    __ add(buf, buf, off); \/\/ + offset\n+    __ ldrw(crc,   Address(esp, 3*wordSize)); \/\/ Initial CRC\n+  }\n+  \/\/ Can now load 'len' since we're finished with 'off'\n+  __ ldrw(len, Address(esp, 0x0)); \/\/ Length\n@@ -1017,2 +1045,1 @@\n-    \/\/ We are frameless so we can just jump to the stub.\n-    __ b(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()));\n+  __ andr(sp, r19_sender_sp, -16); \/\/ Restore the caller's SP\n@@ -1020,6 +1047,7 @@\n-    \/\/ generate a vanilla native entry as the slow path\n-    __ bind(slow_path);\n-    __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n-    return entry;\n-  }\n-  return NULL;\n+  \/\/ We are frameless so we can just jump to the stub.\n+  __ b(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32()));\n+\n+  \/\/ generate a vanilla native entry as the slow path\n+  __ bind(slow_path);\n+  __ jump_to_entry(Interpreter::entry_for_kind(Interpreter::native));\n+  return entry;\n@@ -1036,10 +1064,2 @@\n-  if (UseCRC32CIntrinsics) {\n-    address entry = __ pc();\n-\n-    \/\/ Prepare jump to stub using parameters from the stack\n-    const Register crc = c_rarg0; \/\/ initial crc\n-    const Register buf = c_rarg1; \/\/ source java byte array address\n-    const Register len = c_rarg2; \/\/ len argument to the kernel\n-\n-    const Register end = len; \/\/ index of last element to process\n-    const Register off = crc; \/\/ offset\n+  assert(UseCRC32CIntrinsics, \"this intrinsic is not supported\");\n+  address entry = __ pc();\n@@ -1047,11 +1067,19 @@\n-    __ ldrw(end, Address(esp)); \/\/ int end\n-    __ ldrw(off, Address(esp, wordSize)); \/\/ int offset\n-    __ sub(len, end, off);\n-    __ ldr(buf, Address(esp, 2*wordSize)); \/\/ byte[] buf | long buf\n-    __ add(buf, buf, off); \/\/ + offset\n-    if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n-      __ ldrw(crc, Address(esp, 4*wordSize)); \/\/ long crc\n-    } else {\n-      __ add(buf, buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n-      __ ldrw(crc, Address(esp, 3*wordSize)); \/\/ long crc\n-    }\n+  \/\/ Prepare jump to stub using parameters from the stack\n+  const Register crc = c_rarg0; \/\/ initial crc\n+  const Register buf = c_rarg1; \/\/ source java byte array address\n+  const Register len = c_rarg2; \/\/ len argument to the kernel\n+\n+  const Register end = len; \/\/ index of last element to process\n+  const Register off = crc; \/\/ offset\n+\n+  __ ldrw(end, Address(esp)); \/\/ int end\n+  __ ldrw(off, Address(esp, wordSize)); \/\/ int offset\n+  __ sub(len, end, off);\n+  __ ldr(buf, Address(esp, 2*wordSize)); \/\/ byte[] buf | long buf\n+  __ add(buf, buf, off); \/\/ + offset\n+  if (kind == Interpreter::java_util_zip_CRC32C_updateDirectByteBuffer) {\n+    __ ldrw(crc, Address(esp, 4*wordSize)); \/\/ long crc\n+  } else {\n+    __ add(buf, buf, arrayOopDesc::base_offset_in_bytes(T_BYTE)); \/\/ + header size\n+    __ ldrw(crc, Address(esp, 3*wordSize)); \/\/ long crc\n+  }\n@@ -1059,1 +1087,1 @@\n-    __ andr(sp, r19_sender_sp, -16); \/\/ Restore the caller's SP\n+  __ andr(sp, r19_sender_sp, -16); \/\/ Restore the caller's SP\n@@ -1061,2 +1089,2 @@\n-    \/\/ Jump to the stub.\n-    __ b(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()));\n+  \/\/ Jump to the stub.\n+  __ b(CAST_FROM_FN_PTR(address, StubRoutines::updateBytesCRC32C()));\n@@ -1064,3 +1092,1 @@\n-    return entry;\n-  }\n-  return NULL;\n+  return entry;\n@@ -1708,0 +1734,6 @@\n+\/\/ Not supported\n+address TemplateInterpreterGenerator::generate_Float_intBitsToFloat_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Float_floatToRawIntBits_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_longBitsToDouble_entry() { return nullptr; }\n+address TemplateInterpreterGenerator::generate_Double_doubleToRawLongBits_entry() { return nullptr; }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":136,"deletions":104,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2640,0 +2640,4 @@\n+  } else if (code == lir_f2hf) {\n+    __ flt_to_flt16(dest->as_register(), value->as_xmm_float_reg(), tmp->as_xmm_float_reg());\n+  } else if (code == lir_hf2f) {\n+    __ flt16_to_flt(dest->as_xmm_float_reg(), value->as_register());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -860,0 +860,4 @@\n+  if (x->id() == vmIntrinsics::_floatToFloat16) {\n+    tmp = new_register(T_FLOAT);\n+    __ move(LIR_OprFact::floatConst(-0.0), tmp);\n+  }\n@@ -869,0 +873,6 @@\n+    case vmIntrinsics::_floatToFloat16:\n+      __ f2hf(calc_input, calc_result, tmp);\n+      break;\n+    case vmIntrinsics::_float16ToFloat:\n+      __ hf2f(calc_input, calc_result, LIR_OprFact::illegalOpr);\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -199,0 +199,5 @@\n+  void incrementl(AddressLiteral dst, Register rscratch = noreg);\n+  void incrementl(ArrayAddress   dst, Register rscratch);\n+\n+  void incrementq(AddressLiteral dst, Register rscratch = noreg);\n+\n@@ -226,2 +231,7 @@\n-  void incrementl(AddressLiteral dst, Register rscratch = noreg);\n-  void incrementl(ArrayAddress   dst, Register rscratch);\n+  void flt_to_flt16(Register dst, XMMRegister src, XMMRegister tmp) {\n+    \/\/ Use separate tmp XMM register because caller may\n+    \/\/ requires src XMM register to be unchanged (as in x86.ad).\n+    vcvtps2ph(tmp, src, 0x04, Assembler::AVX_128bit);\n+    movdl(dst, tmp);\n+    movswl(dst, dst);\n+  }\n@@ -229,1 +239,4 @@\n-  void incrementq(AddressLiteral dst, Register rscratch = noreg);\n+  void flt16_to_flt(XMMRegister dst, Register src) {\n+    movdl(dst, src);\n+    vcvtph2ps(dst, dst, Assembler::AVX_128bit);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3539,0 +3539,49 @@\n+\/**\n+*  Arguments:\n+*\n+*  Input:\n+*    c_rarg0   - float16  jshort\n+*\n+*  Output:\n+*       xmm0   - float\n+*\/\n+address StubGenerator::generate_float16ToFloat() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"float16ToFloat\");\n+\n+  address start = __ pc();\n+\n+  BLOCK_COMMENT(\"Entry:\");\n+  \/\/ No need for RuntimeStub frame since it is called only during JIT compilation\n+\n+  \/\/ Load value into xmm0 and convert\n+  __ flt16_to_flt(xmm0, c_rarg0);\n+\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\/**\n+*  Arguments:\n+*\n+*  Input:\n+*       xmm0   - float\n+*\n+*  Output:\n+*        rax   - float16  jshort\n+*\/\n+address StubGenerator::generate_floatToFloat16() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"floatToFloat16\");\n+\n+  address start = __ pc();\n+\n+  BLOCK_COMMENT(\"Entry:\");\n+  \/\/ No need for RuntimeStub frame since it is called only during JIT compilation\n+\n+  \/\/ Convert and put result into rax\n+  __ flt_to_flt16(rax, xmm0, xmm1);\n+\n+  __ ret(0);\n+\n+  return start;\n+}\n@@ -3914,0 +3963,10 @@\n+  if (VM_Version::supports_float16()) {\n+    \/\/ For results consistency both intrinsics should be enabled.\n+    \/\/ vmIntrinsics checks InlineIntrinsics flag, no need to check it here.\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_float16ToFloat) &&\n+        vmIntrinsics::is_intrinsic_available(vmIntrinsics::_floatToFloat16)) {\n+      StubRoutines::_hf2f = generate_float16ToFloat();\n+      StubRoutines::_f2hf = generate_floatToFloat16();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,0 +477,2 @@\n+  address generate_float16ToFloat();\n+  address generate_floatToFloat16();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -3223,0 +3224,16 @@\n+\n+bool VM_Version::is_intrinsic_supported(vmIntrinsicID id) {\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+  switch (id) {\n+  case vmIntrinsics::_floatToFloat16:\n+  case vmIntrinsics::_float16ToFloat:\n+    if (!supports_float16()) {\n+      return false;\n+    }\n+    break;\n+  default:\n+    break;\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1686,1 +1686,1 @@\n-      if (!VM_Version::supports_f16c() && !VM_Version::supports_avx512vl()) {\n+      if (!VM_Version::supports_float16()) {\n@@ -3704,3 +3704,1 @@\n-    __ vcvtps2ph($tmp$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n-    __ movdl($dst$$Register, $tmp$$XMMRegister);\n-    __ movswl($dst$$Register, $dst$$Register);\n+    __ flt_to_flt16($dst$$Register, $src$$XMMRegister, $tmp$$XMMRegister);\n@@ -3748,2 +3746,1 @@\n-    __ movdl($dst$$XMMRegister, $src$$Register);\n-    __ vcvtph2ps($dst$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_128bit);\n+    __ flt16_to_flt($dst$$XMMRegister, $src$$Register);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -603,0 +603,2 @@\n+    case lir_f2hf:\n+    case lir_hf2f:\n@@ -1911,0 +1913,2 @@\n+     case lir_f2hf:                  s = \"f2hf\";          break;\n+     case lir_hf2f:                  s = \"hf2f\";          break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -970,0 +970,2 @@\n+      , lir_f2hf\n+      , lir_hf2f\n@@ -2415,0 +2417,2 @@\n+  void f2hf(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_f2hf, from, tmp, to)); }\n+  void hf2f(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_hf2f, from, tmp, to)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -865,0 +865,2 @@\n+    case lir_f2hf:\n+    case lir_hf2f:\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3481,0 +3481,4 @@\n+  \/\/ Use java.lang.Math intrinsics code since it works for these intrinsics too.\n+  case vmIntrinsics::_floatToFloat16: \/\/ fall through\n+  case vmIntrinsics::_float16ToFloat: do_MathIntrinsic(x); break;\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -6734,0 +6734,2 @@\n+        case lir_f2hf:\n+        case lir_hf2f:\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -259,1 +259,0 @@\n-    FREE_C_HEAP_ARRAY(const char, default_base_archive_name);\n@@ -1114,1 +1113,1 @@\n-      warning(\n+      log_warning(cds)(\n@@ -1120,1 +1119,1 @@\n-        warning(\n+        log_warning(cds)(\n@@ -1205,1 +1204,1 @@\n-      warning(\"Archived non-system classes are disabled because the \"\n+      log_warning(cds)(\"Archived non-system classes are disabled because the \"\n@@ -2460,1 +2459,1 @@\n-    log_info(cds)(\"UseSharedSpaces: Unable to allocate region, range is not within java heap.\");\n+    log_info(cds)(\"Unable to allocate region, range is not within java heap.\");\n@@ -2467,1 +2466,1 @@\n-    log_info(cds)(\"UseSharedSpaces: Unable to allocate region, java heap range is already in use.\");\n+    log_info(cds)(\"Unable to allocate region, java heap range is already in use.\");\n@@ -2483,1 +2482,1 @@\n-      log_info(cds)(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n+      log_info(cds)(\"Unable to map at required address in java heap. \"\n@@ -2493,1 +2492,1 @@\n-      log_info(cds)(\"UseSharedSpaces: mapped heap regions are corrupt\");\n+      log_info(cds)(\"mapped heap regions are corrupt\");\n@@ -2719,1 +2718,1 @@\n-    warning(\"Archived non-system classes are disabled because the \"\n+    log_warning(cds)(\"Archived non-system classes are disabled because the \"\n@@ -2758,1 +2757,1 @@\n-    warning(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n+    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -565,1 +565,1 @@\n-    warning(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n+    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n@@ -946,1 +946,1 @@\n-      warning(\"-XX:ArchiveClassesAtExit is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n+      log_warning(cds)(\"-XX:ArchiveClassesAtExit is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -805,1 +805,0 @@\n-                                               const char* path,\n@@ -856,1 +855,1 @@\n-      add_to_app_classpath_entries(current, path, new_entry, check_for_duplicates);\n+      add_to_app_classpath_entries(current, new_entry, check_for_duplicates);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1542,2 +1542,3 @@\n-void java_lang_Thread_FieldHolder::set_daemon(oop holder) {\n-  holder->bool_field_put(_daemon_offset, true);\n+void java_lang_Thread_FieldHolder::set_daemon(oop holder, bool val) {\n+  assert(val, \"daemon status is never turned off\");\n+  holder->bool_field_put(_daemon_offset, val);\n@@ -1676,1 +1677,2 @@\n-    return java_thread->obj_field(_holder_offset);\n+  \/\/ Note: may return null if the thread is still attaching\n+  return java_thread->obj_field(_holder_offset);\n@@ -1707,0 +1709,24 @@\n+\/\/ Convenience macros for setting and getting Thread fields that\n+\/\/ are actually stored in the FieldHolder object of the thread.\n+\/\/ The FieldHolder can be null whilst a thread is attaching via\n+\/\/ JNI, and when the main thread is attaching.\n+\n+\/\/ The default value should be the default\/zero initialized value\n+\/\/ of the field as it would be in java.lang.Thread.FieldHolder.\n+#define GET_FIELDHOLDER_FIELD(java_thread, field, default_val)  \\\n+  {                                                             \\\n+    oop holder = java_lang_Thread::holder(java_thread);         \\\n+    if (holder != nullptr)                                      \\\n+      return java_lang_Thread_FieldHolder::field(holder);       \\\n+    else                                                        \\\n+      return default_val;                                       \\\n+  }\n+\n+\/\/ We should never be trying to set a field of an attaching thread.\n+#define SET_FIELDHOLDER_FIELD(java_thread, field, value)        \\\n+  {                                                             \\\n+    oop holder = java_lang_Thread::holder(java_thread);         \\\n+    assert(holder != nullptr, \"Thread not fully initialized\");  \\\n+    java_lang_Thread_FieldHolder::set_##field(holder, value);   \\\n+  }\n+\n@@ -1709,3 +1735,1 @@\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != nullptr, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::priority(holder);\n+  GET_FIELDHOLDER_FIELD(java_thread, priority, (ThreadPriority)0);\n@@ -1716,3 +1740,1 @@\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != nullptr, \"Java Thread not initialized\");\n-  java_lang_Thread_FieldHolder::set_priority(holder, priority);\n+  SET_FIELDHOLDER_FIELD(java_thread, priority, priority)\n@@ -1723,3 +1745,1 @@\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != nullptr, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::threadGroup(holder);\n+  GET_FIELDHOLDER_FIELD(java_thread, threadGroup, nullptr);\n@@ -1736,3 +1756,1 @@\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != nullptr, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::is_daemon(holder);\n+  GET_FIELDHOLDER_FIELD(java_thread, is_daemon, false);\n@@ -1743,3 +1761,1 @@\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != nullptr, \"Java Thread not initialized\");\n-  java_lang_Thread_FieldHolder::set_daemon(holder);\n+  SET_FIELDHOLDER_FIELD(java_thread, daemon, true);\n@@ -1758,3 +1774,1 @@\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != nullptr, \"Java Thread not initialized\");\n-  return java_lang_Thread_FieldHolder::stackSize(holder);\n+  GET_FIELDHOLDER_FIELD(java_thread, stackSize, 0);\n@@ -1765,3 +1779,1 @@\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != nullptr, \"Java Thread not initialized\");\n-  java_lang_Thread_FieldHolder::set_thread_status(holder, status);\n+  SET_FIELDHOLDER_FIELD(java_thread, thread_status, status);\n@@ -1777,6 +1789,1 @@\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  if (holder == nullptr) {\n-    return JavaThreadStatus::NEW;  \/\/ Java Thread not initialized\n-  } else {\n-    return java_lang_Thread_FieldHolder::get_thread_status(holder);\n-  }\n+  GET_FIELDHOLDER_FIELD(java_thread, get_thread_status, JavaThreadStatus::NEW \/* not initialized *\/);\n@@ -1918,3 +1925,1 @@\n-  oop holder = java_lang_Thread::holder(java_thread);\n-  assert(holder != nullptr, \"Java Thread not initialized\");\n-  JavaThreadStatus status = java_lang_Thread_FieldHolder::get_thread_status(holder);\n+  JavaThreadStatus status = get_thread_status(java_thread);\n@@ -2812,4 +2817,5 @@\n-Handle java_lang_Throwable::get_cause_with_stack_trace(Handle throwable, TRAPS) {\n-  \/\/ Call to JVM to fill in the stack trace and clear declaringClassObject to\n-  \/\/ not keep classes alive in the stack trace.\n-  \/\/ call this:  public StackTraceElement[] getStackTrace()\n+Handle java_lang_Throwable::create_initialization_error(JavaThread* current, Handle throwable) {\n+  \/\/ Creates an ExceptionInInitializerError to be recorded as the initialization error when class initialization\n+  \/\/ failed due to the passed in 'throwable'. We cannot save 'throwable' directly due to issues with keeping alive\n+  \/\/ all objects referenced via its stacktrace. So instead we save a new EIIE instance, with the same message and\n+  \/\/ symbolic stacktrace of 'throwable'.\n@@ -2818,13 +2824,1 @@\n-  JavaValue result(T_ARRAY);\n-  JavaCalls::call_virtual(&result, throwable,\n-                          vmClasses::Throwable_klass(),\n-                          vmSymbols::getStackTrace_name(),\n-                          vmSymbols::getStackTrace_signature(),\n-                          CHECK_NH);\n-  Handle stack_trace(THREAD, result.get_oop());\n-  assert(stack_trace->is_objArray(), \"Should be an array\");\n-\n-  \/\/ Throw ExceptionInInitializerError as the cause with this exception in\n-  \/\/ the message and stack trace.\n-\n-  \/\/ Now create the message with the original exception and thread name.\n+  \/\/ Now create the message from the original exception and thread name.\n@@ -2832,1 +2826,1 @@\n-  ResourceMark rm(THREAD);\n+  ResourceMark rm(current);\n@@ -2837,1 +2831,1 @@\n-    st.print(\"[in thread \\\"%s\\\"]\", THREAD->name());\n+    st.print(\"[in thread \\\"%s\\\"]\", current->name());\n@@ -2839,1 +2833,1 @@\n-    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), THREAD->name());\n+    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), current->name());\n@@ -2843,4 +2837,4 @@\n-  Handle h_cause = Exceptions::new_exception(THREAD, exception_name, st.as_string());\n-\n-  \/\/ If new_exception returns a different exception while creating the exception, return null.\n-  if (h_cause->klass()->name() != exception_name) {\n+  Handle init_error = Exceptions::new_exception(current, exception_name, st.as_string());\n+  \/\/ If new_exception returns a different exception while creating the exception,\n+  \/\/ abandon the attempt to save the initialization error and return null.\n+  if (init_error->klass()->name() != exception_name) {\n@@ -2848,1 +2842,1 @@\n-                          h_cause->klass()->external_name());\n+                        init_error->klass()->external_name());\n@@ -2851,4 +2845,23 @@\n-  java_lang_Throwable::set_stacktrace(h_cause(), stack_trace());\n-  \/\/ Clear backtrace because the stacktrace should be used instead.\n-  set_backtrace(h_cause(), nullptr);\n-  return h_cause;\n+\n+  \/\/ Call to java to fill in the stack trace and clear declaringClassObject to\n+  \/\/ not keep classes alive in the stack trace.\n+  \/\/ call this:  public StackTraceElement[] getStackTrace()\n+  JavaValue result(T_ARRAY);\n+  JavaCalls::call_virtual(&result, throwable,\n+                          vmClasses::Throwable_klass(),\n+                          vmSymbols::getStackTrace_name(),\n+                          vmSymbols::getStackTrace_signature(),\n+                          current);\n+  if (!current->has_pending_exception()){\n+    Handle stack_trace(current, result.get_oop());\n+    assert(stack_trace->is_objArray(), \"Should be an array\");\n+    java_lang_Throwable::set_stacktrace(init_error(), stack_trace());\n+    \/\/ Clear backtrace because the stacktrace should be used instead.\n+    set_backtrace(init_error(), nullptr);\n+  } else {\n+    log_info(class, init)(\"Exception thrown while getting stack trace for initialization exception %s\",\n+                        init_error->klass()->external_name());\n+    current->clear_pending_exception();\n+  }\n+\n+  return init_error;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":75,"deletions":62,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-  static void set_daemon(oop holder);\n+  static void set_daemon(oop holder, bool val);\n@@ -472,1 +472,1 @@\n-  static void set_thread_status(oop holder, JavaThreadStatus);\n+  static void set_thread_status(oop holder, JavaThreadStatus status);\n@@ -632,1 +632,1 @@\n-  static Handle get_cause_with_stack_trace(Handle throwable, TRAPS);\n+  static Handle create_initialization_error(JavaThread* current, Handle throwable);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -959,6 +960,3 @@\n-  {\n-    MutexLocker mu_r(THREAD, Compile_lock);\n-    \/\/ Add to class hierarchy, and do possible deoptimizations.\n-    add_to_hierarchy(k);\n-    \/\/ But, do not add to dictionary.\n-  }\n+  \/\/ Add to class hierarchy, and do possible deoptimizations.\n+  add_to_hierarchy(THREAD, k);\n+  \/\/ But, do not add to dictionary.\n@@ -1568,1 +1566,3 @@\n-  \/\/ Add the new class. We need recompile lock during update of CHA.\n+  \/\/ Add to class hierarchy, and do possible deoptimizations.\n+  add_to_hierarchy(THREAD, k);\n+\n@@ -1571,4 +1571,0 @@\n-\n-    \/\/ Add to class hierarchy, and do possible deoptimizations.\n-    add_to_hierarchy(k);\n-\n@@ -1691,2 +1687,1 @@\n-\/\/ is held, to ensure that the compiler is not using the class hierarchy, and that deoptimization will kick in\n-\/\/ before a new class is used.\n+\/\/ is grabbed, to ensure that the compiler is not using the class hierarchy.\n@@ -1694,1 +1689,1 @@\n-void SystemDictionary::add_to_hierarchy(InstanceKlass* k) {\n+void SystemDictionary::add_to_hierarchy(JavaThread* current, InstanceKlass* k) {\n@@ -1696,2 +1691,8 @@\n-  if (Universe::is_fully_initialized()) {\n-    assert_locked_or_safepoint(Compile_lock);\n+  assert(!SafepointSynchronize::is_at_safepoint(), \"must NOT be at safepoint\");\n+\n+  \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n+  \/\/ deopt is completed before anyone links this class.\n+  \/\/ Linking is done with _init_monitor held, by loading and deopting with it\n+  \/\/ held we make sure the deopt is completed before linking.\n+  if (!UseVtableBasedCHA) {\n+    k->init_monitor()->lock();\n@@ -1700,4 +1701,8 @@\n-  k->set_init_state(InstanceKlass::loaded);\n-  \/\/ make sure init_state store is already done.\n-  \/\/ The compiler reads the hierarchy outside of the Compile_lock.\n-  \/\/ Access ordering is used to add to hierarchy.\n+  DeoptimizationScope deopt_scope;\n+  {\n+    MutexLocker ml(current, Compile_lock);\n+\n+    k->set_init_state(InstanceKlass::loaded);\n+    \/\/ make sure init_state store is already done.\n+    \/\/ The compiler reads the hierarchy outside of the Compile_lock.\n+    \/\/ Access ordering is used to add to hierarchy.\n@@ -1705,3 +1710,12 @@\n-  \/\/ Link into hierarchy.\n-  k->append_to_sibling_list();                    \/\/ add to superklass\/sibling list\n-  k->process_interfaces();                        \/\/ handle all \"implements\" declarations\n+    \/\/ Link into hierarchy.\n+    k->append_to_sibling_list();                    \/\/ add to superklass\/sibling list\n+    k->process_interfaces();                        \/\/ handle all \"implements\" declarations\n+\n+    \/\/ Now mark all code that depended on old class hierarchy.\n+    \/\/ Note: must be done *after* linking k into the hierarchy (was bug 12\/9\/97)\n+    if (Universe::is_fully_initialized()) {\n+      CodeCache::mark_dependents_on(&deopt_scope, k);\n+    }\n+  }\n+  \/\/ Perform the deopt handshake outside Compile_lock.\n+  deopt_scope.deoptimize_marked();\n@@ -1709,4 +1723,2 @@\n-  \/\/ Now flush all code that depended on old class hierarchy.\n-  \/\/ Note: must be done *after* linking k into the hierarchy (was bug 12\/9\/97)\n-  if (Universe::is_fully_initialized()) {\n-    CodeCache::flush_dependents_on(k);\n+  if (!UseVtableBasedCHA) {\n+    k->init_monitor()->unlock();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -376,2 +376,2 @@\n-  \/\/ Setup link to hierarchy\n-  static void add_to_hierarchy(InstanceKlass* k);\n+  \/\/ Setup link to hierarchy and deoptimize\n+  static void add_to_hierarchy(JavaThread* current, InstanceKlass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -316,0 +317,4 @@\n+  case vmIntrinsics::_floatToFloat16:\n+  case vmIntrinsics::_float16ToFloat:\n+    if (!InlineIntrinsics) return true;\n+    break;\n@@ -656,3 +661,2 @@\n-bool vmIntrinsics::is_disabled_by_flags(const methodHandle& method) {\n-  vmIntrinsics::ID id = method->intrinsic_id();\n-  return is_disabled_by_flags(id);\n+bool vmIntrinsics::is_intrinsic_available(vmIntrinsics::ID id) {\n+  return VM_Version::is_intrinsic_supported(id) && !is_disabled_by_flags(id);\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1543,4 +1543,1 @@\n-  static bool is_disabled_by_flags(const methodHandle& method);\n-  static bool is_intrinsic_available(vmIntrinsics::ID id) {\n-    return !is_disabled_by_flags(id);\n-  }\n+  static bool is_intrinsic_available(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n-    _mark_for_deoptimization_status(not_marked),\n+    _deoptimization_status(not_marked),\n+    _deoptimization_generation(0),\n@@ -69,1 +70,2 @@\n-    _mark_for_deoptimization_status(not_marked),\n+    _deoptimization_status(not_marked),\n+    _deoptimization_generation(0),\n@@ -116,6 +118,4 @@\n-void CompiledMethod::mark_for_deoptimization(bool inc_recompile_counts) {\n-  \/\/ assert(can_be_deoptimized(), \"\"); \/\/ in some places we check before marking, in others not.\n-  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n-                 Mutex::_no_safepoint_check_flag);\n-  if (_mark_for_deoptimization_status != deoptimize_done) { \/\/ can't go backwards\n-     _mark_for_deoptimization_status = (inc_recompile_counts ? deoptimize : deoptimize_noupdate);\n+void CompiledMethod::set_deoptimized_done() {\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  if (_deoptimization_status != deoptimize_done) { \/\/ can't go backwards\n+    Atomic::store(&_deoptimization_status, deoptimize_done);\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-\n+  friend class DeoptimizationScope;\n@@ -146,1 +146,1 @@\n-  enum MarkForDeoptimizationStatus : u1 {\n+  enum DeoptimizationStatus : u1 {\n@@ -153,1 +153,3 @@\n-  MarkForDeoptimizationStatus _mark_for_deoptimization_status; \/\/ Used for stack deoptimization\n+  volatile DeoptimizationStatus _deoptimization_status; \/\/ Used for stack deoptimization\n+  \/\/ Used to track in which deoptimize handshake this method will be deoptimized.\n+  uint64_t                      _deoptimization_generation;\n@@ -177,0 +179,5 @@\n+private:\n+  DeoptimizationStatus deoptimization_status() const {\n+    return Atomic::load(&_deoptimization_status);\n+  }\n+\n@@ -252,5 +259,3 @@\n-  bool  is_marked_for_deoptimization() const { return _mark_for_deoptimization_status != not_marked; }\n-  void  mark_for_deoptimization(bool inc_recompile_counts = true);\n-\n-  bool  has_been_deoptimized() const { return _mark_for_deoptimization_status == deoptimize_done; }\n-  void  mark_deoptimized() { _mark_for_deoptimization_status = deoptimize_done; }\n+  bool  is_marked_for_deoptimization() const { return deoptimization_status() != not_marked; }\n+  bool  has_been_deoptimized() const { return deoptimization_status() == deoptimize_done; }\n+  void  set_deoptimized_done();\n@@ -264,2 +269,2 @@\n-    return _mark_for_deoptimization_status != deoptimize_noupdate &&\n-           _mark_for_deoptimization_status != deoptimize_done;\n+    DeoptimizationStatus status = deoptimization_status();\n+    return status != deoptimize_noupdate && status != deoptimize_done;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1169,1 +1169,1 @@\n-      context_type = InstanceKlass::cast(context_type->implementor());\n+      context_type = context_type->implementor();\n@@ -1600,1 +1600,1 @@\n-  if (lm == nullptr && ctxk->is_instance_klass()) {\n+  if (lm == nullptr) {\n@@ -1602,2 +1602,1 @@\n-    lm = InstanceKlass::cast(ctxk)->lookup_method_in_ordered_interfaces(m->name(),\n-                                                                        m->signature());\n+    lm = ctxk->lookup_method_in_ordered_interfaces(m->name(), m->signature());\n@@ -2178,1 +2177,1 @@\n-    Klass* k = str.klass();\n+    InstanceKlass* k = str.klass();\n@@ -2207,1 +2206,1 @@\n-  Klass* type = (_changes.is_klass_change() ? _changes.as_klass_change()->type() : (Klass*) nullptr);\n+  InstanceKlass* type = (_changes.is_klass_change() ? _changes.as_klass_change()->type() : (InstanceKlass*) nullptr);\n@@ -2218,1 +2217,1 @@\n-    _ti_base = InstanceKlass::cast(_klass)->transitive_interfaces();\n+    _ti_base = _klass->transitive_interfaces();\n@@ -2228,1 +2227,1 @@\n-      _klass = _klass->super();\n+      _klass = _klass->java_super();\n@@ -2258,3 +2257,3 @@\n-    Klass* d = str.klass();\n-    assert(!InstanceKlass::cast(d)->is_marked_dependent(), \"checking\");\n-    InstanceKlass::cast(d)->set_is_marked_dependent(true);\n+    InstanceKlass* d = str.klass();\n+    assert(!d->is_marked_dependent(), \"checking\");\n+    d->set_is_marked_dependent(true);\n@@ -2268,2 +2267,2 @@\n-    Klass* d = str.klass();\n-    InstanceKlass::cast(d)->set_is_marked_dependent(false);\n+    InstanceKlass* d = str.klass();\n+    d->set_is_marked_dependent(false);\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -616,2 +616,2 @@\n-          Klass* klass = deps.context_type();\n-          if (klass == nullptr) {\n+          InstanceKlass* ik = deps.context_type();\n+          if (ik == nullptr) {\n@@ -621,1 +621,1 @@\n-          InstanceKlass::cast(klass)->add_dependent_nmethod(nm);\n+          ik->add_dependent_nmethod(nm);\n@@ -1172,0 +1172,2 @@\n+    \/\/ Don't deopt this again.\n+    set_deoptimized_done();\n@@ -1179,0 +1181,6 @@\n+\n+  \/\/ If post call nops have been already patched, we can just bail-out.\n+  if (has_been_deoptimized()) {\n+    return;\n+  }\n+\n@@ -1214,1 +1222,1 @@\n-  mark_deoptimized();\n+  set_deoptimized_done();\n@@ -1500,2 +1508,2 @@\n-        Klass* klass = deps.context_type();\n-        if (klass == nullptr) {\n+        InstanceKlass* ik = deps.context_type();\n+        if (ik == nullptr) {\n@@ -1506,1 +1514,1 @@\n-        InstanceKlass::cast(klass)->clean_dependency_context();\n+        ik->clean_dependency_context();\n@@ -2491,1 +2499,1 @@\n-    Klass* ctxk = deps.context_type();\n+    InstanceKlass* ctxk = deps.context_type();\n@@ -2493,1 +2501,1 @@\n-      if (ctxk->is_instance_klass() && InstanceKlass::cast(ctxk)->is_dependent_nmethod(this)) {\n+      if (ctxk->is_dependent_nmethod(this)) {\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1021,1 +1021,1 @@\n-  MemRegion old_mr = heap->old_gen()->reserved();\n+  MemRegion old_mr = heap->old_gen()->committed();\n@@ -1023,1 +1023,1 @@\n-    ct->clear(old_mr);\n+    ct->clear_MemRegion(old_mr);\n@@ -1025,1 +1025,1 @@\n-    ct->invalidate(old_mr);\n+    ct->dirty_MemRegion(old_mr);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-    assert(_lab_alignment_reserve != ~(size_t)0, \"uninitialized\");\n+    assert(_lab_alignment_reserve != SIZE_MAX, \"uninitialized\");\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+    java_lang_math_sqrt_strict,                                 \/\/ implementation of java.lang.StrictMath.sqrt(x)\n@@ -91,0 +92,2 @@\n+    java_lang_Float_float16ToFloat,                             \/\/ implementation of java.lang.Float.float16ToFloat()\n+    java_lang_Float_floatToFloat16,                             \/\/ implementation of java.lang.Float.floatToFloat16()\n@@ -106,0 +109,3 @@\n+  \/\/ Conversion from the above enum to vmIntrinsics::ID\n+  static vmIntrinsics::ID method_intrinsic(MethodKind kind);\n+\n@@ -115,3 +121,0 @@\n-  static address    _native_entry_begin;                        \/\/ Region for native entry code\n-  static address    _native_entry_end;\n-\n@@ -160,0 +163,2 @@\n+      case vmIntrinsics::_floatToFloat16       : \/\/ fall thru\n+      case vmIntrinsics::_float16ToFloat       : \/\/ fall thru\n@@ -222,1 +227,0 @@\n-  static bool       in_native_entry(address pc)                 { return _native_entry_begin <= pc && pc < _native_entry_end; }\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -181,3 +181,3 @@\n-#define method_entry(kind)                                                                   \\\n-  { CodeletMark cm(_masm, \"method entry point (kind = \" #kind \")\");                          \\\n-    Interpreter::_entry_table[Interpreter::kind] = generate_method_entry(Interpreter::kind); \\\n+#define method_entry(kind)                                                                          \\\n+  { CodeletMark cm(_masm, \"method entry point (kind = \" #kind \")\");                                 \\\n+    Interpreter::_entry_table[Interpreter::kind] = generate_method_entry(Interpreter::kind, false); \\\n@@ -198,0 +198,1 @@\n+  method_entry(java_lang_math_sqrt_strict)\n@@ -205,3 +206,0 @@\n-#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n-  method_entry(java_lang_Thread_currentThread)\n-#endif\n@@ -210,9 +208,0 @@\n-  \/\/ all native method kinds (must be one contiguous block)\n-  Interpreter::_native_entry_begin = Interpreter::code()->code_end();\n-  method_entry(native)\n-  method_entry(native_synchronized)\n-  Interpreter::_native_entry_end = Interpreter::code()->code_end();\n-\n-  method_entry(java_util_zip_CRC32_update)\n-  method_entry(java_util_zip_CRC32_updateBytes)\n-  method_entry(java_util_zip_CRC32_updateByteBuffer)\n@@ -222,4 +211,2 @@\n-  method_entry(java_lang_Float_intBitsToFloat);\n-  method_entry(java_lang_Float_floatToRawIntBits);\n-  method_entry(java_lang_Double_longBitsToDouble);\n-  method_entry(java_lang_Double_doubleToRawLongBits);\n+  method_entry(java_lang_Float_float16ToFloat);\n+  method_entry(java_lang_Float_floatToFloat16);\n@@ -229,0 +216,25 @@\n+  \/\/ all native method kinds\n+#define native_method_entry(kind)                                                                  \\\n+  { CodeletMark cm(_masm, \"native method entry point (kind = \" #kind \")\");                         \\\n+    Interpreter::_entry_table[Interpreter::kind] = generate_method_entry(Interpreter::kind, true); \\\n+  }\n+\n+  native_method_entry(native)\n+  native_method_entry(native_synchronized)\n+\n+  \/\/ Entries to intrinsics for native methods should follow\n+  \/\/ entries for `native` methods to use the same address in case\n+  \/\/ intrinsic is disabled.\n+  native_method_entry(java_lang_Thread_currentThread)\n+\n+  native_method_entry(java_util_zip_CRC32_update)\n+  native_method_entry(java_util_zip_CRC32_updateBytes)\n+  native_method_entry(java_util_zip_CRC32_updateByteBuffer)\n+\n+  native_method_entry(java_lang_Float_intBitsToFloat)\n+  native_method_entry(java_lang_Float_floatToRawIntBits)\n+  native_method_entry(java_lang_Double_longBitsToDouble)\n+  native_method_entry(java_lang_Double_doubleToRawLongBits)\n+\n+#undef native_method_entry\n+\n@@ -398,1 +410,1 @@\n-                                        AbstractInterpreter::MethodKind kind) {\n+                                        AbstractInterpreter::MethodKind kind, bool native) {\n@@ -400,1 +412,0 @@\n-  bool native = false;\n@@ -405,4 +416,4 @@\n-  case Interpreter::zerolocals             :                                          break;\n-  case Interpreter::zerolocals_synchronized:                synchronized = true;      break;\n-  case Interpreter::native                 : native = true;                           break;\n-  case Interpreter::native_synchronized    : native = true; synchronized = true;      break;\n+  case Interpreter::zerolocals             :                           break;\n+  case Interpreter::zerolocals_synchronized: synchronized = true;      break;\n+  case Interpreter::native                 :                           break;\n+  case Interpreter::native_synchronized    : synchronized = true;      break;\n@@ -413,0 +424,21 @@\n+  default:\n+    entry_point = generate_intrinsic_entry(kind); \/\/ process the rest\n+    break;\n+  }\n+\n+  if (entry_point) {\n+    return entry_point;\n+  }\n+\n+  \/\/ We expect the normal and native entry points to be generated first so we can reuse them.\n+  if (native) {\n+    entry_point = Interpreter::entry_for_kind(synchronized ? Interpreter::native_synchronized : Interpreter::native);\n+    if (entry_point == nullptr) {\n+      entry_point = generate_native_entry(synchronized);\n+    }\n+  } else {\n+    entry_point = Interpreter::entry_for_kind(synchronized ? Interpreter::zerolocals_synchronized : Interpreter::zerolocals);\n+    if (entry_point == nullptr) {\n+      entry_point = generate_normal_entry(synchronized);\n+    }\n+  }\n@@ -414,0 +446,12 @@\n+  return entry_point;\n+}\n+\n+\/\/ Generate intrinsic method entries\n+address TemplateInterpreterGenerator::generate_intrinsic_entry(AbstractInterpreter::MethodKind kind) {\n+  if (!InlineIntrinsics || !vmIntrinsics::is_intrinsic_available(AbstractInterpreter::method_intrinsic(kind))) {\n+    return nullptr;\n+  }\n+\n+  address entry_point = nullptr;\n+\n+  switch (kind) {\n@@ -425,0 +469,2 @@\n+  case Interpreter::java_lang_math_sqrt_strict\n+                                           : entry_point = generate_math_entry(Interpreter::java_lang_math_sqrt); break;\n@@ -428,1 +474,1 @@\n-                                           : native = true; entry_point = generate_CRC32_update_entry();  break;\n+                                           : entry_point = generate_CRC32_update_entry();  break;\n@@ -432,1 +478,1 @@\n-                                           : native = true; entry_point = generate_CRC32_updateBytes_entry(kind); break;\n+                                           : entry_point = generate_CRC32_updateBytes_entry(kind); break;\n@@ -437,1 +483,0 @@\n-#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n@@ -440,1 +485,4 @@\n-#endif\n+  case Interpreter::java_lang_Float_float16ToFloat\n+                                           : entry_point = generate_Float_float16ToFloat_entry(); break;\n+  case Interpreter::java_lang_Float_floatToFloat16\n+                                           : entry_point = generate_Float_floatToFloat16_entry(); break;\n@@ -442,2 +490,1 @@\n-#ifdef IA32\n-  \/\/ On other platforms the normal entry is used to enter these methods.\n+  \/\/ On other platforms the native entry is used to enter these methods.\n@@ -446,1 +493,1 @@\n-                                           : native = true; entry_point = generate_Float_intBitsToFloat_entry(); break;\n+                                           : entry_point = generate_Float_intBitsToFloat_entry(); break;\n@@ -448,1 +495,1 @@\n-                                           : native = true; entry_point = generate_Float_floatToRawIntBits_entry(); break;\n+                                           : entry_point = generate_Float_floatToRawIntBits_entry(); break;\n@@ -450,1 +497,1 @@\n-                                           : native = true; entry_point = generate_Double_longBitsToDouble_entry(); break;\n+                                           : entry_point = generate_Double_longBitsToDouble_entry(); break;\n@@ -452,9 +499,1 @@\n-                                           : native = true; entry_point = generate_Double_doubleToRawLongBits_entry(); break;\n-#else\n-  case Interpreter::java_lang_Float_intBitsToFloat:\n-  case Interpreter::java_lang_Float_floatToRawIntBits:\n-  case Interpreter::java_lang_Double_longBitsToDouble:\n-  case Interpreter::java_lang_Double_doubleToRawLongBits:\n-    native = true;\n-    break;\n-#endif \/\/ !IA32\n+                                           : entry_point = generate_Double_doubleToRawLongBits_entry(); break;\n@@ -462,1 +501,1 @@\n-    fatal(\"unexpected method kind: %d\", kind);\n+    fatal(\"unexpected intrinsic method kind: %d\", kind);\n@@ -465,18 +504,0 @@\n-\n-  if (entry_point) {\n-    return entry_point;\n-  }\n-\n-  \/\/ We expect the normal and native entry points to be generated first so we can reuse them.\n-  if (native) {\n-    entry_point = Interpreter::entry_for_kind(synchronized ? Interpreter::native_synchronized : Interpreter::native);\n-    if (entry_point == nullptr) {\n-      entry_point = generate_native_entry(synchronized);\n-    }\n-  } else {\n-    entry_point = Interpreter::entry_for_kind(synchronized ? Interpreter::zerolocals_synchronized : Interpreter::zerolocals);\n-    if (entry_point == nullptr) {\n-      entry_point = generate_normal_entry(synchronized);\n-    }\n-  }\n-\n@@ -485,0 +506,1 @@\n+\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":84,"deletions":62,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -579,0 +579,19 @@\n+C2V_VMENTRY_NULL(jobject, lookupJClass, (JNIEnv* env, jobject, jlong jclass_value))\n+    if (jclass_value == 0L) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"jclass must not be zero\");\n+    }\n+    jclass mirror = reinterpret_cast<jclass>(jclass_value);\n+    \/\/ Since the jclass_value is passed as a jlong, we perform additional checks to prevent the caller from accidentally\n+    \/\/ sending a value that is not a JNI handle.\n+    if (JNIHandles::handle_type(thread, mirror) == JNIInvalidRefType) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"jclass is not a valid JNI reference\");\n+    }\n+    oop obj = JNIHandles::resolve(mirror);\n+    if (!java_lang_Class::is_instance(obj)) {\n+        JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"jclass must be a reference to the Class object\");\n+    }\n+    JVMCIKlassHandle klass(THREAD, java_lang_Class::as_Klass(obj));\n+    JVMCIObject result = JVMCIENV->get_jvmci_type(klass, JVMCI_CHECK_NULL);\n+    return JVMCIENV->get_jobject(result);\n+C2V_END\n+\n@@ -2829,0 +2848,1 @@\n+  {CC \"lookupJClass\",                                 CC \"(J)\" HS_RESOLVED_TYPE,                                                            FN_PTR(lookupJClass)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -1116,3 +1117,4 @@\n-  Handle cause = java_lang_Throwable::get_cause_with_stack_trace(exception, THREAD);\n-  if (HAS_PENDING_EXCEPTION || cause.is_null()) {\n-    CLEAR_PENDING_EXCEPTION;\n+  Handle init_error = java_lang_Throwable::create_initialization_error(current, exception);\n+  ResourceMark rm(THREAD);\n+  if (init_error.is_null()) {\n+    log_trace(class, init)(\"Initialization error is null for class %s\", external_name());\n@@ -1123,2 +1125,2 @@\n-  OopHandle elem = OopHandle(Universe::vm_global(), cause());\n-  bool created = false;\n+  OopHandle elem = OopHandle(Universe::vm_global(), init_error());\n+  bool created;\n@@ -1127,1 +1129,0 @@\n-  ResourceMark rm(THREAD);\n@@ -1373,3 +1374,5 @@\n-  \/\/ Now flush all code that assume the class is not linked.\n-  \/\/ Set state under the Compile_lock also.\n-    MutexLocker ml(current, Compile_lock);\n+    DeoptimizationScope deopt_scope;\n+    {\n+      \/\/ Now mark all code that assumes the class is not linked.\n+      \/\/ Set state under the Compile_lock also.\n+      MutexLocker ml(current, Compile_lock);\n@@ -1378,2 +1381,2 @@\n-    set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n-    set_init_state(state);\n+      set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n+      set_init_state(state);\n@@ -1381,1 +1384,4 @@\n-    CodeCache::flush_dependents_on(this);\n+      CodeCache::mark_dependents_on(&deopt_scope, this);\n+    }\n+    \/\/ Perform the deopt handshake outside Compile_lock.\n+    deopt_scope.deoptimize_marked();\n@@ -2529,2 +2535,2 @@\n-int InstanceKlass::mark_dependent_nmethods(KlassDepChange& changes) {\n-  return dependencies().mark_dependent_nmethods(changes);\n+void InstanceKlass::mark_dependent_nmethods(DeoptimizationScope* deopt_scope, KlassDepChange& changes) {\n+  dependencies().mark_dependent_nmethods(deopt_scope, changes);\n@@ -2610,1 +2616,15 @@\n-  it->push(&_methods);\n+#if INCLUDE_CDS\n+  \/\/ For \"old\" classes with methods containing the jsr bytecode, the _methods array will\n+  \/\/ be rewritten during runtime (see Rewriter::rewrite_jsrs()). So setting the _methods to\n+  \/\/ be writable. The length check on the _methods is necessary because classes which\n+  \/\/ don't have any methods share the Universe::_the_empty_method_array which is in the RO region.\n+  if (_methods != nullptr && _methods->length() > 0 &&\n+      !can_be_verified_at_dumptime() && methods_contain_jsr_bytecode()) {\n+    \/\/ To handle jsr bytecode, new Method* maybe stored into _methods\n+    it->push(&_methods, MetaspaceClosure::_writable);\n+  } else {\n+#endif\n+    it->push(&_methods);\n+#if INCLUDE_CDS\n+  }\n+#endif\n@@ -2837,0 +2857,15 @@\n+\n+bool InstanceKlass::methods_contain_jsr_bytecode() const {\n+  Thread* thread = Thread::current();\n+  for (int i = 0; i < _methods->length(); i++) {\n+    methodHandle m(thread, _methods->at(i));\n+    BytecodeStream bcs(m);\n+    while (!bcs.is_last_bytecode()) {\n+      Bytecodes::Code opcode = bcs.next();\n+      if (opcode == Bytecodes::_jsr || opcode == Bytecodes::_jsr_w) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n@@ -3497,1 +3532,1 @@\n-int InstanceKlass::mark_osr_nmethods(const Method* m) {\n+int InstanceKlass::mark_osr_nmethods(DeoptimizationScope* deopt_scope, const Method* m) {\n@@ -3505,1 +3540,1 @@\n-      osr->mark_for_deoptimization();\n+      deopt_scope->mark(osr);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":52,"deletions":17,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+class DeoptimizationScope;\n@@ -925,1 +926,1 @@\n-  int  mark_dependent_nmethods(KlassDepChange& changes);\n+  void mark_dependent_nmethods(DeoptimizationScope* deopt_scope, KlassDepChange& changes);\n@@ -934,1 +935,1 @@\n-  int mark_osr_nmethods(const Method* m);\n+  int mark_osr_nmethods(DeoptimizationScope* deopt_scope, const Method* m);\n@@ -1224,0 +1225,1 @@\n+  bool methods_contain_jsr_bytecode() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2075,1 +2075,1 @@\n-    CodeCache::flush_dependents_on_method(mh);\n+    CodeCache::mark_dependents_on_method_for_breakpoint(mh);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -977,4 +977,0 @@\n-  int mark_osr_nmethods() {\n-    return method_holder()->mark_osr_nmethods(this);\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-  AddNode *progress = NULL;             \/\/ Progress flag\n+  AddNode *progress = nullptr;             \/\/ Progress flag\n@@ -244,1 +244,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -256,1 +256,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -285,1 +285,1 @@\n-      Node* sub = SubNode::make(NULL, NULL, bt);\n+      Node* sub = SubNode::make(nullptr, nullptr, bt);\n@@ -316,3 +316,3 @@\n-    Node* add_in1 = NULL;\n-    Node* add_in2 = NULL;\n-    Node* mul_in = NULL;\n+    Node* add_in1 = nullptr;\n+    Node* add_in2 = nullptr;\n+    Node* mul_in = nullptr;\n@@ -342,1 +342,1 @@\n-    if (mul_in != NULL) {\n+    if (mul_in != nullptr) {\n@@ -351,1 +351,1 @@\n-      in1->in(1) != NULL && in1->in(1) == in2->in(1)) {\n+      in1->in(1) != nullptr && in1->in(1) == in2->in(1)) {\n@@ -354,1 +354,1 @@\n-    if (rshift != NULL && lshift != NULL) {\n+    if (rshift != nullptr && lshift != nullptr) {\n@@ -359,2 +359,2 @@\n-      if (lshift_t != NULL && lshift_t->is_con() &&\n-          rshift_t != NULL && rshift_t->is_con() &&\n+      if (lshift_t != nullptr && lshift_t->is_con() &&\n+          rshift_t != nullptr && rshift_t->is_con() &&\n@@ -508,1 +508,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -523,1 +523,1 @@\n-  return commute(phase, this) ? this : NULL;\n+  return commute(phase, this) ? this : nullptr;\n@@ -540,1 +540,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -554,1 +554,1 @@\n-  return commute(phase, this) ? this : NULL;\n+  return commute(phase, this) ? this : nullptr;\n@@ -568,1 +568,1 @@\n-  if( phase->type( in(Address) ) == Type::TOP ) return NULL;\n+  if( phase->type( in(Address) ) == Type::TOP ) return nullptr;\n@@ -579,1 +579,1 @@\n-    if( t == Type::TOP ) return NULL;\n+    if( t == Type::TOP ) return nullptr;\n@@ -584,1 +584,1 @@\n-      if( temp_t2 == Type::TOP ) return NULL;\n+      if( temp_t2 == Type::TOP ) return nullptr;\n@@ -605,1 +605,1 @@\n-    \/\/ If this is a NULL+long form (from unsafe accesses), switch to a rawptr.\n+    \/\/ If this is a null+long form (from unsafe accesses), switch to a rawptr.\n@@ -626,1 +626,1 @@\n-  return NULL;                  \/\/ No progress\n+  return nullptr;                  \/\/ No progress\n@@ -632,1 +632,1 @@\n-  if (in(Address) == NULL)  return TypePtr::BOTTOM;\n+  if (in(Address) == nullptr)  return TypePtr::BOTTOM;\n@@ -682,1 +682,1 @@\n-\/\/ Return the base, or NULL if failure.\n+\/\/ Return the base, or null if failure.\n@@ -698,1 +698,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -748,2 +748,2 @@\n-  if (lshift_t != NULL && lshift_t->is_con() &&\n-      rshift_t != NULL && rshift_t->is_con() &&\n+  if (lshift_t != nullptr && lshift_t->is_con() &&\n+      rshift_t != nullptr && rshift_t->is_con() &&\n@@ -756,1 +756,1 @@\n-    if (shift_t != NULL && shift_t->is_con() &&\n+    if (shift_t != nullptr && shift_t->is_con() &&\n@@ -761,1 +761,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -772,1 +772,1 @@\n-    if (shift != NULL) {\n+    if (shift != nullptr) {\n@@ -775,1 +775,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -782,1 +782,1 @@\n-    if (shift != NULL) {\n+    if (shift != nullptr) {\n@@ -786,1 +786,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -838,1 +838,1 @@\n-    if (shift != NULL) {\n+    if (shift != nullptr) {\n@@ -841,1 +841,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -848,1 +848,1 @@\n-    if (shift != NULL) {\n+    if (shift != nullptr) {\n@@ -852,1 +852,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1020,1 +1020,1 @@\n-  assert(is_int == (gvn.type(b)->isa_int() != NULL), \"inconsistent inputs\");\n+  assert(is_int == (gvn.type(b)->isa_int() != nullptr), \"inconsistent inputs\");\n@@ -1022,1 +1022,1 @@\n-  Node* hook = NULL;\n+  Node* hook = nullptr;\n@@ -1029,1 +1029,1 @@\n-  Node* res = NULL;\n+  Node* res = nullptr;\n@@ -1039,1 +1039,1 @@\n-    Node* cmp = NULL;\n+    Node* cmp = nullptr;\n@@ -1046,1 +1046,1 @@\n-    res = gvn.transform(CMoveNode::make(NULL, bol, a, b, t));\n+    res = gvn.transform(CMoveNode::make(nullptr, bol, a, b, t));\n@@ -1048,1 +1048,1 @@\n-  if (hook != NULL) {\n+  if (hook != nullptr) {\n@@ -1057,1 +1057,1 @@\n-  assert(is_int == (gvn.type(b)->isa_int() != NULL), \"inconsistent inputs\");\n+  assert(is_int == (gvn.type(b)->isa_int() != nullptr), \"inconsistent inputs\");\n@@ -1060,1 +1060,1 @@\n-  Node* hook = NULL;\n+  Node* hook = nullptr;\n@@ -1067,1 +1067,1 @@\n-  Node* cmp = NULL;\n+  Node* cmp = nullptr;\n@@ -1075,2 +1075,2 @@\n-  Node* res = gvn.transform(CMoveNode::make(NULL, bol, sub, zero, t));\n-  if (hook != NULL) {\n+  Node* res = gvn.transform(CMoveNode::make(nullptr, bol, sub, zero, t));\n+  if (hook != nullptr) {\n@@ -1123,1 +1123,1 @@\n-    if (t == Type::TOP) return NULL;  \/\/ No progress\n+    if (t == Type::TOP) return nullptr;  \/\/ No progress\n@@ -1135,1 +1135,1 @@\n-    if (t == Type::TOP) return NULL;  \/\/ No progress\n+    if (t == Type::TOP) return nullptr;  \/\/ No progress\n@@ -1153,1 +1153,1 @@\n-      if (t == Type::TOP) return NULL;  \/\/ No progress\n+      if (t == Type::TOP) return nullptr;  \/\/ No progress\n@@ -1163,1 +1163,1 @@\n-    if (x == y && tx != NULL &&\n+    if (x == y && tx != nullptr &&\n@@ -1171,1 +1171,1 @@\n-    if (x == y && tx != NULL &&\n+    if (x == y && tx != nullptr &&\n@@ -1177,1 +1177,1 @@\n- return NULL;\n+ return nullptr;\n@@ -1185,1 +1185,1 @@\n-  Node *progress = NULL;\n+  Node *progress = nullptr;\n@@ -1206,1 +1206,1 @@\n-    if( t == Type::TOP ) return NULL;  \/\/ No progress\n+    if( t == Type::TOP ) return nullptr;  \/\/ No progress\n@@ -1218,1 +1218,1 @@\n-    if( t == Type::TOP ) return NULL;  \/\/ No progress\n+    if( t == Type::TOP ) return nullptr;  \/\/ No progress\n@@ -1236,1 +1236,1 @@\n-      if( t == Type::TOP ) return NULL;  \/\/ No progress\n+      if( t == Type::TOP ) return nullptr;  \/\/ No progress\n@@ -1246,1 +1246,1 @@\n-    if (x == y && tx != NULL &&\n+    if (x == y && tx != nullptr &&\n@@ -1254,1 +1254,1 @@\n-    if (x == y && tx != NULL &&\n+    if (x == y && tx != nullptr &&\n@@ -1260,1 +1260,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":61,"deletions":61,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  : CallNode(arraycopy_type(), NULL, TypePtr::BOTTOM),\n+  : CallNode(arraycopy_type(), nullptr, TypePtr::BOTTOM),\n@@ -140,1 +140,1 @@\n-      assert (ary_src != NULL, \"not an array or instance?\");\n+      assert (ary_src != nullptr, \"not an array or instance?\");\n@@ -147,1 +147,1 @@\n-             (UseFlatArray && ary_src->elem()->make_oopptr() != NULL && ary_src->elem()->make_oopptr()->can_be_inline_type()) ||\n+             (UseFlatArray && ary_src->elem()->make_oopptr() != nullptr && ary_src->elem()->make_oopptr()->can_be_inline_type()) ||\n@@ -184,1 +184,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -194,2 +194,2 @@\n-  if (inst_src == NULL) {\n-    return NULL;\n+  if (inst_src == nullptr) {\n+    return nullptr;\n@@ -275,2 +275,2 @@\n-    if (ary_src  == NULL || ary_src->elem()  == Type::BOTTOM ||\n-        ary_dest == NULL || ary_dest->elem() == Type::BOTTOM) {\n+    if (ary_src  == nullptr || ary_src->elem()  == Type::BOTTOM ||\n+        ary_dest == nullptr || ary_dest->elem() == Type::BOTTOM) {\n@@ -339,1 +339,1 @@\n-    assert(ary_src != NULL, \"should be a clone\");\n+    assert(ary_src != nullptr, \"should be a clone\");\n@@ -344,1 +344,1 @@\n-    if (ary_src->elem()->make_oopptr() != NULL &&\n+    if (ary_src->elem()->make_oopptr() != nullptr &&\n@@ -396,1 +396,1 @@\n-    assert(src_offset != NULL && dest_offset != NULL, \"should be\");\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"should be\");\n@@ -529,1 +529,1 @@\n-      if (callprojs->fallthrough_ioproj != NULL) {\n+      if (callprojs->fallthrough_ioproj != nullptr) {\n@@ -532,1 +532,1 @@\n-      if (callprojs->fallthrough_memproj != NULL) {\n+      if (callprojs->fallthrough_memproj != nullptr) {\n@@ -535,1 +535,1 @@\n-      if (callprojs->fallthrough_catchproj != NULL) {\n+      if (callprojs->fallthrough_catchproj != nullptr) {\n@@ -563,1 +563,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -569,1 +569,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -581,1 +581,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -584,7 +584,7 @@\n-  assert(in(TypeFunc::Control) != NULL &&\n-         in(TypeFunc::Memory) != NULL &&\n-         in(ArrayCopyNode::Src) != NULL &&\n-         in(ArrayCopyNode::Dest) != NULL &&\n-         in(ArrayCopyNode::Length) != NULL &&\n-         in(ArrayCopyNode::SrcPos) != NULL &&\n-         in(ArrayCopyNode::DestPos) != NULL, \"broken inputs\");\n+  assert(in(TypeFunc::Control) != nullptr &&\n+         in(TypeFunc::Memory) != nullptr &&\n+         in(ArrayCopyNode::Src) != nullptr &&\n+         in(ArrayCopyNode::Dest) != nullptr &&\n+         in(ArrayCopyNode::Length) != nullptr &&\n+         in(ArrayCopyNode::SrcPos) != nullptr &&\n+         in(ArrayCopyNode::DestPos) != nullptr, \"broken inputs\");\n@@ -596,3 +596,3 @@\n-      (in(ArrayCopyNode::SrcPos) != NULL && in(ArrayCopyNode::SrcPos)->is_top()) ||\n-      (in(ArrayCopyNode::DestPos) != NULL && in(ArrayCopyNode::DestPos)->is_top())) {\n-    return NULL;\n+      (in(ArrayCopyNode::SrcPos) != nullptr && in(ArrayCopyNode::SrcPos)->is_top()) ||\n+      (in(ArrayCopyNode::DestPos) != nullptr && in(ArrayCopyNode::DestPos)->is_top())) {\n+    return nullptr;\n@@ -604,1 +604,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -615,1 +615,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -619,2 +619,2 @@\n-  if (mem != NULL) {\n-    return (mem == NodeSentinel) ? NULL : mem;\n+  if (mem != nullptr) {\n+    return (mem == NodeSentinel) ? nullptr : mem;\n@@ -623,4 +623,4 @@\n-  Node* adr_src = NULL;\n-  Node* base_src = NULL;\n-  Node* adr_dest = NULL;\n-  Node* base_dest = NULL;\n+  Node* adr_src = nullptr;\n+  Node* base_src = nullptr;\n+  Node* adr_dest = nullptr;\n+  Node* base_dest = nullptr;\n@@ -628,1 +628,1 @@\n-  const Type* value_type = NULL;\n+  const Type* value_type = nullptr;\n@@ -634,3 +634,3 @@\n-    assert(adr_src == NULL, \"no node can be left behind\");\n-    assert(adr_dest == NULL, \"no node can be left behind\");\n-    return NULL;\n+    assert(adr_src == nullptr, \"no node can be left behind\");\n+    assert(adr_dest == nullptr, \"no node can be left behind\");\n+    return nullptr;\n@@ -639,2 +639,2 @@\n-  JVMState* new_jvms = NULL;\n-  SafePointNode* new_map = NULL;\n+  JVMState* new_jvms = nullptr;\n+  SafePointNode* new_map = nullptr;\n@@ -668,2 +668,2 @@\n-  SafePointNode* backward_map = NULL;\n-  SafePointNode* forward_map = NULL;\n+  SafePointNode* backward_map = nullptr;\n+  SafePointNode* forward_map = nullptr;\n@@ -725,1 +725,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -750,1 +750,1 @@\n-  if (n != NULL &&\n+  if (n != nullptr &&\n@@ -768,2 +768,2 @@\n-  CallNode* call = NULL;\n-  guarantee(c != NULL, \"step_over_gc_barrier failed, there must be something to step to.\");\n+  CallNode* call = nullptr;\n+  guarantee(c != nullptr, \"step_over_gc_barrier failed, there must be something to step to.\");\n@@ -772,1 +772,1 @@\n-      if (c->in(i) != NULL) {\n+      if (c->in(i) != nullptr) {\n@@ -786,1 +786,1 @@\n-    assert(c == mb->in(0) || (ac != NULL && ac->is_clonebasic() && !use_ReduceInitialCardMarks), \"only for clone\");\n+    assert(c == mb->in(0) || (ac != nullptr && ac->is_clonebasic() && !use_ReduceInitialCardMarks), \"only for clone\");\n@@ -813,1 +813,1 @@\n-  if (dest_pos_t == NULL || len_t == NULL || ary_t == NULL) {\n+  if (dest_pos_t == nullptr || len_t == nullptr || ary_t == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":51,"deletions":51,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,2 +147,2 @@\n-                             Node* src_klass = NULL, Node* dest_klass = NULL,\n-                             Node* src_length = NULL, Node* dest_length = NULL);\n+                             Node* src_klass = nullptr, Node* dest_klass = nullptr,\n+                             Node* src_length = nullptr, Node* dest_length = nullptr);\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-\/\/ practice.  One array will map to a reaching def Node (or NULL for\n+\/\/ practice.  One array will map to a reaching def Node (or null for\n@@ -83,1 +83,1 @@\n-                                \/\/ or NULL if dead\/conflict\n+                                \/\/ or null if dead\/conflict\n@@ -88,1 +88,1 @@\n-                                \/\/ or NULL if dead\/conflict\n+                                \/\/ or null if dead\/conflict\n@@ -92,1 +92,1 @@\n-    _b(NULL), _next(NULL), C(c) { }\n+    _b(nullptr), _next(nullptr), C(c) { }\n@@ -169,1 +169,1 @@\n-  assert( _b == NULL, \"merging into a happy flow\" );\n+  assert( _b == nullptr, \"merging into a happy flow\" );\n@@ -174,1 +174,1 @@\n-  \/\/ is OptoReg::Bad or NULL depending.\n+  \/\/ is OptoReg::Bad or null depending.\n@@ -181,1 +181,1 @@\n-      _defs[i] = NULL;\n+      _defs[i] = nullptr;\n@@ -217,1 +217,1 @@\n-  MachCallNode *mcall = n->is_MachCall() ? n->as_MachCall() : NULL;\n+  MachCallNode *mcall = n->is_MachCall() ? n->as_MachCall() : nullptr;\n@@ -471,1 +471,1 @@\n-        MachNode *m = n->is_Mach() ? n->as_Mach() : NULL;\n+        MachNode *m = n->is_Mach() ? n->as_Mach() : nullptr;\n@@ -497,1 +497,1 @@\n-            const TypePtr *adr_type = NULL;\n+            const TypePtr *adr_type = nullptr;\n@@ -508,1 +508,1 @@\n-              \/\/ (base == NULL) OR the fp is used in a non-memory context\n+              \/\/ (base == nullptr) OR the fp is used in a non-memory context\n@@ -564,1 +564,1 @@\n-        if (block->get_node(j)->jvms() && (*safehash)[block->get_node(j)] == NULL) {\n+        if (block->get_node(j)->jvms() && (*safehash)[block->get_node(j)] == nullptr) {\n@@ -599,1 +599,1 @@\n-  Dict *safehash = NULL;        \/\/ Used for assert only\n+  Dict *safehash = nullptr;        \/\/ Used for assert only\n@@ -604,1 +604,1 @@\n-  OopFlow *free_list = NULL;    \/\/ Free, unused\n+  OopFlow *free_list = nullptr;    \/\/ Free, unused\n@@ -648,1 +648,1 @@\n-    OopFlow *flow = NULL;       \/\/ Flag for finding optimized flow\n+    OopFlow *flow = nullptr;       \/\/ Flag for finding optimized flow\n@@ -682,1 +682,1 @@\n-      assert( flow->_b == NULL, \"oopFlow is not free\" );\n+      assert( flow->_b == nullptr, \"oopFlow is not free\" );\n@@ -684,1 +684,1 @@\n-      flow->_next = NULL;\n+      flow->_next = nullptr;\n@@ -694,1 +694,1 @@\n-    flow->_b = NULL;\n+    flow->_b = nullptr;\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  _caller_jvms(NULL),\n+  _caller_jvms(nullptr),\n@@ -53,2 +53,2 @@\n-  _subtrees(c->comp_arena(), 2, 0, NULL),\n-  _msg(NULL)\n+  _subtrees(c->comp_arena(), 2, 0, nullptr),\n+  _msg(nullptr)\n@@ -60,1 +60,1 @@\n-  if (caller_jvms != NULL) {\n+  if (caller_jvms != nullptr) {\n@@ -67,1 +67,1 @@\n-  assert((caller_tree == NULL ? 0 : caller_tree->stack_depth() + 1) == stack_depth(), \"correct (redundant) depth parameter\");\n+  assert((caller_tree == nullptr ? 0 : caller_tree->stack_depth() + 1) == stack_depth(), \"correct (redundant) depth parameter\");\n@@ -71,1 +71,1 @@\n-  for( ; caller != NULL; caller = ((InlineTree *)(caller->caller_tree())) ) {\n+  for( ; caller != nullptr; caller = ((InlineTree *)(caller->caller_tree())) ) {\n@@ -201,1 +201,1 @@\n-  const char* fail_msg = NULL;\n+  const char* fail_msg = nullptr;\n@@ -224,1 +224,1 @@\n-  if (fail_msg == NULL && callee_method->has_unloaded_classes_in_signature()) {\n+  if (fail_msg == nullptr && callee_method->has_unloaded_classes_in_signature()) {\n@@ -228,1 +228,1 @@\n-  if (fail_msg != NULL) {\n+  if (fail_msg != nullptr) {\n@@ -284,1 +284,1 @@\n-  if (caller_tree() != NULL &&\n+  if (caller_tree() != nullptr &&\n@@ -287,1 +287,1 @@\n-    while (top->caller_tree() != NULL) top = top->caller_tree();\n+    while (top->caller_tree() != nullptr) top = top->caller_tree();\n@@ -450,2 +450,2 @@\n-    Node* callee_argument0 = is_compiled_lambda_form ? jvms->map()->argument(jvms, 0)->uncast() : NULL;\n-    for (JVMState* j = jvms->caller(); j != NULL && j->has_method(); j = j->caller()) {\n+    Node* callee_argument0 = is_compiled_lambda_form ? jvms->map()->argument(jvms, 0)->uncast() : nullptr;\n+    for (JVMState* j = jvms->caller(); j != nullptr && j->has_method(); j = j->caller()) {\n@@ -490,1 +490,1 @@\n-  if (callee_method == NULL) {\n+  if (callee_method == nullptr) {\n@@ -532,1 +532,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -539,2 +539,2 @@\n-  assert(inline_msg != NULL, \"just checking\");\n-  if (C->log() != NULL) {\n+  assert(inline_msg != nullptr, \"just checking\");\n+  if (C->log() != nullptr) {\n@@ -551,1 +551,1 @@\n-    guarantee(callee_method != NULL, \"would crash in CompilerEvent::InlineEvent::post\");\n+    guarantee(callee_method != nullptr, \"would crash in CompilerEvent::InlineEvent::post\");\n@@ -554,1 +554,1 @@\n-      while (top->caller_tree() != NULL) { top = top->caller_tree(); }\n+      while (top->caller_tree() != nullptr) { top = top->caller_tree(); }\n@@ -568,1 +568,1 @@\n-  assert(callee_method != NULL, \"caller checks for optimized virtual!\");\n+  assert(callee_method != nullptr, \"caller checks for optimized virtual!\");\n@@ -571,2 +571,2 @@\n-  if (jvms->caller() == NULL) {\n-    assert(_caller_jvms == NULL, \"redundant instance state\");\n+  if (jvms->caller() == nullptr) {\n+    assert(_caller_jvms == nullptr, \"redundant instance state\");\n@@ -590,1 +590,1 @@\n-  if (msg() != NULL) {\n+  if (msg() != nullptr) {\n@@ -600,1 +600,1 @@\n-    if (msg() == NULL) {\n+    if (msg() == nullptr) {\n@@ -612,1 +612,1 @@\n-    if (msg() == NULL) {\n+    if (msg() == nullptr) {\n@@ -624,1 +624,1 @@\n-  if (old_ilt != NULL) {\n+  if (old_ilt != nullptr) {\n@@ -628,1 +628,1 @@\n-  if (caller_jvms->method() != NULL) {\n+  if (caller_jvms->method() != nullptr) {\n@@ -663,1 +663,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -672,1 +672,1 @@\n-  InlineTree* ilt = new InlineTree(C, NULL, C->method(), NULL, -1, MaxInlineLevel);\n+  InlineTree* ilt = new InlineTree(C, nullptr, C->method(), nullptr, -1, MaxInlineLevel);\n@@ -691,1 +691,1 @@\n-    if (sub == NULL) {\n+    if (sub == nullptr) {\n@@ -695,1 +695,1 @@\n-      guarantee(sub != NULL, \"should be a sub-ilt here\");\n+      guarantee(sub != nullptr, \"should be a sub-ilt here\");\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-  notproduct(ccstr, PrintIdealGraphFile, NULL,                              \\\n+  notproduct(ccstr, PrintIdealGraphFile, nullptr,                           \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    if (C.failure_reason() != NULL) {\n+    if (C.failure_reason() != nullptr) {\n@@ -183,1 +183,1 @@\n-bool C2Compiler::is_intrinsic_supported(const methodHandle& method, bool is_virtual) {\n+bool C2Compiler::is_intrinsic_supported(const methodHandle& method) {\n@@ -191,14 +191,0 @@\n-  \/\/ Only Object.hashCode and Object.clone intrinsics implement also a virtual\n-  \/\/ dispatch because calling both methods is expensive but both methods are\n-  \/\/ frequently overridden. All other intrinsics implement only a non-virtual\n-  \/\/ dispatch.\n-  if (is_virtual) {\n-    switch (id) {\n-    case vmIntrinsics::_hashCode:\n-    case vmIntrinsics::_clone:\n-      break;\n-    default:\n-      return false;\n-    }\n-  }\n-\n@@ -232,1 +218,1 @@\n-    if (StubRoutines::unsafe_arraycopy() == NULL) return false;\n+    if (StubRoutines::unsafe_arraycopy() == nullptr) return false;\n@@ -486,1 +472,1 @@\n-    if (vmClasses::reflect_CallerSensitive_klass() == NULL) return false;\n+    if (vmClasses::reflect_CallerSensitive_klass() == nullptr) return false;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-    assert(InlineTree::check_can_parse(method) == NULL, \"parse must be possible\");\n+    assert(InlineTree::check_can_parse(method) == nullptr, \"parse must be possible\");\n@@ -97,1 +97,1 @@\n-    return NULL;  \/\/ bailing out of the compile; do not try to parse\n+    return nullptr;  \/\/ bailing out of the compile; do not try to parse\n@@ -105,2 +105,2 @@\n-    while (exits.pop_exception_state() != NULL) ;\n-    return NULL;\n+    while (exits.pop_exception_state() != nullptr) ;\n+    return nullptr;\n@@ -131,1 +131,1 @@\n-      _call_node(NULL),\n+      _call_node(nullptr),\n@@ -161,1 +161,1 @@\n-  if (kit.C->log() != NULL) {\n+  if (kit.C->log() != nullptr) {\n@@ -212,1 +212,1 @@\n-    : CallGenerator(method), _vtable_index(vtable_index), _separate_io_proj(separate_io_proj), _call_node(NULL)\n+    : CallGenerator(method), _vtable_index(vtable_index), _separate_io_proj(separate_io_proj), _call_node(nullptr)\n@@ -235,1 +235,1 @@\n-  if (kit.C->log() != NULL) {\n+  if (kit.C->log() != nullptr) {\n@@ -251,1 +251,1 @@\n-                      NULL, \"null receiver\");\n+                      nullptr, \"null receiver\");\n@@ -260,1 +260,1 @@\n-  ciMethodData *caller_md = (caller == NULL) ? NULL : caller->method_data();\n+  ciMethodData *caller_md = (caller == nullptr) ? nullptr : caller->method_data();\n@@ -307,1 +307,1 @@\n-  if (InlineTree::check_can_parse(m) != NULL)  return NULL;\n+  if (InlineTree::check_can_parse(m) != nullptr)  return nullptr;\n@@ -315,1 +315,1 @@\n-  if (InlineTree::check_can_parse(m) != NULL)  return NULL;\n+  if (InlineTree::check_can_parse(m) != nullptr)  return nullptr;\n@@ -411,1 +411,1 @@\n-    LateInlineCallGenerator(callee, NULL), _caller(caller), _input_not_const(input_not_const) {}\n+    LateInlineCallGenerator(callee, nullptr), _caller(caller), _input_not_const(input_not_const) {}\n@@ -452,1 +452,1 @@\n-  if (cg != NULL) {\n+  if (cg != nullptr) {\n@@ -458,1 +458,1 @@\n-      assert(cg != NULL, \"inline call generator expected\");\n+      assert(cg != nullptr, \"inline call generator expected\");\n@@ -497,1 +497,1 @@\n-    _unique_id(0), _inline_cg(NULL), _callee(NULL), _is_pure_call(false), _prof_factor(prof_factor) {\n+    _unique_id(0), _inline_cg(nullptr), _callee(nullptr), _is_pure_call(false), _prof_factor(prof_factor) {\n@@ -509,1 +509,1 @@\n-    assert(_callee == NULL, \"repeated inlining attempt\");\n+    assert(_callee == nullptr, \"repeated inlining attempt\");\n@@ -519,1 +519,1 @@\n-    if (call_node() != NULL) {\n+    if (call_node() != nullptr) {\n@@ -579,1 +579,1 @@\n-                                        NULL \/*speculative_receiver_type*\/,\n+                                        nullptr \/*speculative_receiver_type*\/,\n@@ -582,1 +582,1 @@\n-  if (cg != NULL) {\n+  if (cg != nullptr) {\n@@ -609,1 +609,1 @@\n-  assert(_callee != NULL, \"required\"); \/\/ set up in CallDynamicJavaNode::Ideal\n+  assert(_callee != nullptr, \"required\"); \/\/ set up in CallDynamicJavaNode::Ideal\n@@ -618,2 +618,2 @@\n-  if (call == NULL || call->outcnt() == 0 ||\n-      call->in(0) == NULL || call->in(0)->is_top()) {\n+  if (call == nullptr || call->outcnt() == 0 ||\n+      call->in(0) == nullptr || call->in(0)->is_top()) {\n@@ -650,1 +650,1 @@\n-      (callprojs->exobj != NULL && call->find_edge(callprojs->exobj) != -1)) {\n+      (callprojs->exobj != nullptr && call->find_edge(callprojs->exobj) != -1)) {\n@@ -663,1 +663,1 @@\n-    if (callprojs->resproj[i] != NULL) {\n+    if (callprojs->resproj[i] != nullptr) {\n@@ -742,1 +742,1 @@\n-    Node* buffer_oop = NULL;\n+    Node* buffer_oop = nullptr;\n@@ -756,1 +756,1 @@\n-        buffer_oop = arg_kit.new_instance(klass_node, NULL, NULL, \/* deoptimize_on_exception *\/ true);\n+        buffer_oop = arg_kit.new_instance(klass_node, nullptr, nullptr, \/* deoptimize_on_exception *\/ true);\n@@ -763,1 +763,1 @@\n-    if (old_nn != NULL) {\n+    if (old_nn != nullptr) {\n@@ -771,1 +771,1 @@\n-    if (new_jvms == NULL)  return;  \/\/ no change\n+    if (new_jvms == nullptr)  return;  \/\/ no change\n@@ -793,1 +793,1 @@\n-    if (vt != NULL) {\n+    if (vt != nullptr) {\n@@ -799,1 +799,1 @@\n-          assert(buffer_oop != NULL, \"should have allocated a buffer\");\n+          assert(buffer_oop != nullptr, \"should have allocated a buffer\");\n@@ -818,1 +818,1 @@\n-          assert(alloc != NULL, \"must have an allocation node\");\n+          assert(alloc != nullptr, \"must have an allocation node\");\n@@ -838,1 +838,1 @@\n-      DEBUG_ONLY(buffer_oop = NULL);\n+      DEBUG_ONLY(buffer_oop = nullptr);\n@@ -842,1 +842,1 @@\n-    assert(buffer_oop == NULL, \"unused buffer allocation\");\n+    assert(buffer_oop == nullptr, \"unused buffer allocation\");\n@@ -994,1 +994,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1009,1 +1009,1 @@\n-  Node* slow_ctl = NULL;\n+  Node* slow_ctl = nullptr;\n@@ -1018,2 +1018,2 @@\n-  SafePointNode* slow_map = NULL;\n-  JVMState* slow_jvms = NULL;\n+  SafePointNode* slow_map = nullptr;\n+  JVMState* slow_jvms = nullptr;\n@@ -1025,2 +1025,2 @@\n-        return NULL;  \/\/ might happen because of NodeCountInliningCutoff\n-      assert(slow_jvms != NULL, \"must be\");\n+        return nullptr;  \/\/ might happen because of NodeCountInliningCutoff\n+      assert(slow_jvms != nullptr, \"must be\");\n@@ -1045,1 +1045,1 @@\n-  if (new_jvms == NULL) {\n+  if (new_jvms == nullptr) {\n@@ -1055,1 +1055,1 @@\n-  if (slow_map == NULL) {\n+  if (slow_map == nullptr) {\n@@ -1136,1 +1136,1 @@\n-  if (cg != NULL) {\n+  if (cg != nullptr) {\n@@ -1192,1 +1192,1 @@\n-        if (recv_toop != NULL) {\n+        if (recv_toop != nullptr) {\n@@ -1199,1 +1199,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -1237,1 +1237,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1266,1 +1266,1 @@\n-        ciKlass* speculative_receiver_type = NULL;\n+        ciKlass* speculative_receiver_type = nullptr;\n@@ -1281,1 +1281,1 @@\n-          speculative_receiver_type = (receiver_type != NULL) ? receiver_type->speculative_type() : NULL;\n+          speculative_receiver_type = (receiver_type != nullptr) ? receiver_type->speculative_type() : nullptr;\n@@ -1305,1 +1305,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1339,1 +1339,1 @@\n-  \/\/    if (receiver == NULL)\n+  \/\/    if (receiver == nullptr)\n@@ -1354,1 +1354,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1398,1 +1398,1 @@\n-      if (new_jvms == NULL) {\n+      if (new_jvms == nullptr) {\n@@ -1409,1 +1409,1 @@\n-    if (else_ctrl == NULL) {\n+    if (else_ctrl == nullptr) {\n@@ -1424,2 +1424,2 @@\n-      return NULL;  \/\/ might happen because of NodeCountInliningCutoff\n-    assert(new_jvms != NULL, \"must be\");\n+      return nullptr;  \/\/ might happen because of NodeCountInliningCutoff\n+    assert(new_jvms != nullptr, \"must be\");\n@@ -1488,1 +1488,1 @@\n-      Node* m = NULL;\n+      Node* m = nullptr;\n@@ -1558,1 +1558,1 @@\n-    kit.uncommon_trap(_reason, _action, NULL, \"monomorphic vcall checkcast\", false, keep_exact_action);\n+    kit.uncommon_trap(_reason, _action, nullptr, \"monomorphic vcall checkcast\", false, keep_exact_action);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":58,"deletions":58,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-  virtual CallNode* call_node() const { return NULL; }\n+  virtual CallNode* call_node() const { return nullptr; }\n@@ -88,1 +88,1 @@\n-  virtual CallGenerator* inline_cg()    const                             { ShouldNotReachHere(); return NULL;  }\n+  virtual CallGenerator* inline_cg()    const                             { ShouldNotReachHere(); return nullptr;  }\n@@ -123,1 +123,1 @@\n-  \/\/ If the result is NULL, it means that this CallGenerator was unable\n+  \/\/ If the result is null, it means that this CallGenerator was unable\n@@ -173,1 +173,1 @@\n-  virtual Node* generate_predicate(JVMState* jvms, int predicate) { return NULL; };\n+  virtual Node* generate_predicate(JVMState* jvms, int predicate) { return nullptr; };\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -105,1 +105,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -164,1 +164,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -214,1 +214,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -259,1 +259,1 @@\n-  assert(method != NULL, \"must be valid call site\");\n+  assert(method != nullptr, \"must be valid call site\");\n@@ -265,1 +265,1 @@\n-  _depth  = 1 + (caller == NULL ? 0 : caller->depth());\n+  _depth  = 1 + (caller == nullptr ? 0 : caller->depth());\n@@ -274,1 +274,1 @@\n-  _method(NULL) {\n+  _method(nullptr) {\n@@ -278,1 +278,1 @@\n-  _caller = NULL;\n+  _caller = nullptr;\n@@ -307,1 +307,1 @@\n-    if (p->_method == NULL)          return true;   \/\/ bci is irrelevant\n+    if (p->_method == nullptr)       return true;   \/\/ bci is irrelevant\n@@ -313,1 +313,1 @@\n-    assert(p != NULL && q != NULL, \"depth check ensures we don't run off end\");\n+    assert(p != nullptr && q != nullptr, \"depth check ensures we don't run off end\");\n@@ -334,1 +334,1 @@\n-  for (const JVMState* jvmp = this; jvmp != NULL; jvmp = jvmp->caller()) {\n+  for (const JVMState* jvmp = this; jvmp != nullptr; jvmp = jvmp->caller()) {\n@@ -346,1 +346,1 @@\n-  if (n == NULL) { st->print(\" NULL\"); return; }\n+  if (n == nullptr) { st->print(\" null\"); return; }\n@@ -369,1 +369,1 @@\n-      st->print(\" %s%d]=#NULL\",msg,i);\n+      st->print(\" %s%d]=#null\",msg,i);\n@@ -472,1 +472,1 @@\n-      ciInstanceKlass *iklass = NULL;\n+      ciInstanceKlass *iklass = nullptr;\n@@ -506,1 +506,1 @@\n-        if (iklass != NULL && iklass->is_inlinetype()) {\n+        if (iklass != nullptr && iklass->is_inlinetype()) {\n@@ -510,1 +510,1 @@\n-            format_helper(regalloc, st, init_node, \":\", -1, NULL);\n+            format_helper(regalloc, st, init_node, \":\", -1, nullptr);\n@@ -515,1 +515,1 @@\n-        if (iklass != NULL) {\n+        if (iklass != nullptr) {\n@@ -525,1 +525,1 @@\n-          if (iklass != NULL) {\n+          if (iklass != nullptr) {\n@@ -539,1 +539,1 @@\n-  if (caller() != NULL) caller()->format(regalloc, n, st);\n+  if (caller() != nullptr) caller()->format(regalloc, n, st);\n@@ -544,1 +544,1 @@\n-  if (_method != NULL) {\n+  if (_method != nullptr) {\n@@ -556,2 +556,2 @@\n-        if (endcn == NULL)  endcn = strchr(name, '(');\n-        if (endcn == NULL)  endcn = name + strlen(name);\n+        if (endcn == nullptr)  endcn = strchr(name, '(');\n+        if (endcn == nullptr)  endcn = name + strlen(name);\n@@ -570,1 +570,1 @@\n-  if (caller() != NULL)  caller()->dump_spec(st);\n+  if (caller() != nullptr)  caller()->dump_spec(st);\n@@ -576,1 +576,1 @@\n-                  ((caller() == NULL) || (caller()->map() != _map));\n+                  ((caller() == nullptr) || (caller()->map() != _map));\n@@ -581,1 +581,1 @@\n-      while (ex != NULL && ex->len() > ex->req()) {\n+      while (ex != nullptr && ex->len() > ex->req()) {\n@@ -588,1 +588,1 @@\n-  if (caller() != NULL) {\n+  if (caller() != nullptr) {\n@@ -593,1 +593,1 @@\n-  if (_method == NULL) {\n+  if (_method == nullptr) {\n@@ -630,1 +630,1 @@\n-  for (JVMState* p = n; p->_caller != NULL; p = p->_caller) {\n+  for (JVMState* p = n; p->_caller != nullptr; p = p->_caller) {\n@@ -642,1 +642,1 @@\n-  for (JVMState* p = this; p != NULL; p = p->_caller) {\n+  for (JVMState* p = this; p != nullptr; p = p->_caller) {\n@@ -656,1 +656,1 @@\n-  for (JVMState* jvms = this; jvms != NULL; jvms = jvms->caller()) {\n+  for (JVMState* jvms = this; jvms != nullptr; jvms = jvms->caller()) {\n@@ -675,1 +675,1 @@\n-  while (jvms != NULL) {\n+  while (jvms != nullptr) {\n@@ -720,1 +720,1 @@\n-  if (tf() != NULL)  tf()->dump_on(st);\n+  if (tf() != nullptr)  tf()->dump_on(st);\n@@ -722,1 +722,1 @@\n-  if (jvms() != NULL)  jvms()->dump_spec(st);\n+  if (jvms() != nullptr)  jvms()->dump_spec(st);\n@@ -803,1 +803,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -816,1 +816,1 @@\n-  assert((t_oop != NULL), \"sanity\");\n+  assert((t_oop != nullptr), \"sanity\");\n@@ -819,1 +819,1 @@\n-    Node* dest = NULL;\n+    Node* dest = nullptr;\n@@ -832,1 +832,1 @@\n-    guarantee(dest != NULL, \"Call had only one ptr in, broken IR!\");\n+    guarantee(dest != nullptr, \"Call had only one ptr in, broken IR!\");\n@@ -848,1 +848,1 @@\n-      if ((proj == NULL) || (phase->type(proj)->is_instptr()->instance_klass() != boxing_klass)) {\n+      if ((proj == nullptr) || (phase->type(proj)->is_instptr()->instance_klass() != boxing_klass)) {\n@@ -852,1 +852,1 @@\n-    if (is_CallJava() && as_CallJava()->method() != NULL) {\n+    if (is_CallJava() && as_CallJava()->method() != nullptr) {\n@@ -859,2 +859,2 @@\n-      Node* proj = returns_pointer() ? proj_out_or_null(TypeFunc::Parms) : NULL;\n-      if (proj != NULL) {\n+      Node* proj = returns_pointer() ? proj_out_or_null(TypeFunc::Parms) : nullptr;\n+      if (proj != nullptr) {\n@@ -862,2 +862,2 @@\n-        if ((inst_t != NULL) && (!inst_t->klass_is_exact() ||\n-                                 (inst_t->instance_klass() == boxing_klass))) {\n+        if ((inst_t != nullptr) && (!inst_t->klass_is_exact() ||\n+                                   (inst_t->instance_klass() == boxing_klass))) {\n@@ -870,1 +870,1 @@\n-        if ((inst_t != NULL) && (!inst_t->klass_is_exact() ||\n+        if ((inst_t != nullptr) && (!inst_t->klass_is_exact() ||\n@@ -893,1 +893,1 @@\n-  if (jvms() != NULL) {\n+  if (jvms() != nullptr) {\n@@ -905,1 +905,1 @@\n-\/\/ or returns NULL if there is no one.\n+\/\/ or returns null if there is no one.\n@@ -907,1 +907,1 @@\n-  Node *cast = NULL;\n+  Node *cast = nullptr;\n@@ -910,2 +910,2 @@\n-  if (p == NULL)\n-    return NULL;\n+  if (p == nullptr)\n+    return nullptr;\n@@ -916,1 +916,1 @@\n-      if (cast != NULL) {\n+      if (cast != nullptr) {\n@@ -959,2 +959,2 @@\n-        if (cn != NULL && cn->is_Catch()) {\n-          ProjNode *cpn = NULL;\n+        if (cn != nullptr && cn->is_Catch()) {\n+          ProjNode *cpn = nullptr;\n@@ -982,1 +982,1 @@\n-          assert(projs->exobj == NULL, \"only one\");\n+          assert(projs->exobj == nullptr, \"only one\");\n@@ -1006,5 +1006,5 @@\n-  assert(!do_asserts || projs->fallthrough_proj      != NULL, \"must be found\");\n-  assert(!do_asserts || projs->fallthrough_catchproj != NULL, \"must be found\");\n-  assert(!do_asserts || projs->fallthrough_memproj   != NULL, \"must be found\");\n-  assert(!do_asserts || projs->fallthrough_ioproj    != NULL, \"must be found\");\n-  assert(!do_asserts || projs->catchall_catchproj    != NULL, \"must be found\");\n+  assert(!do_asserts || projs->fallthrough_proj      != nullptr, \"must be found\");\n+  assert(!do_asserts || projs->fallthrough_catchproj != nullptr, \"must be found\");\n+  assert(!do_asserts || projs->fallthrough_memproj   != nullptr, \"must be found\");\n+  assert(!do_asserts || projs->fallthrough_ioproj    != nullptr, \"must be found\");\n+  assert(!do_asserts || projs->catchall_catchproj    != nullptr, \"must be found\");\n@@ -1013,2 +1013,2 @@\n-    assert(!do_asserts || projs->catchall_memproj    != NULL, \"must be found\");\n-    assert(!do_asserts || projs->catchall_ioproj     != NULL, \"must be found\");\n+    assert(!do_asserts || projs->catchall_memproj    != nullptr, \"must be found\");\n+    assert(!do_asserts || projs->catchall_ioproj     != nullptr, \"must be found\");\n@@ -1023,1 +1023,1 @@\n-  if (cg != NULL) {\n+  if (cg != nullptr) {\n@@ -1032,1 +1032,1 @@\n-  if (_name != NULL && strstr(_name, \"arraycopy\") != 0) {\n+  if (_name != nullptr && strstr(_name, \"arraycopy\") != 0) {\n@@ -1060,1 +1060,1 @@\n-    if (old_in != NULL && old_in->is_SafePointScalarObject()) {\n+    if (old_in != nullptr && old_in->is_SafePointScalarObject()) {\n@@ -1074,2 +1074,2 @@\n-  set_jvms(sfpt->jvms() != NULL ? sfpt->jvms()->clone_deep(C) : NULL);\n-  for (JVMState *jvms = this->jvms(); jvms != NULL; jvms = jvms->caller()) {\n+  set_jvms(sfpt->jvms() != nullptr ? sfpt->jvms()->clone_deep(C) : nullptr);\n+  for (JVMState *jvms = this->jvms(); jvms != nullptr; jvms = jvms->caller()) {\n@@ -1087,1 +1087,1 @@\n-  if (method() == NULL) {\n+  if (method() == nullptr) {\n@@ -1138,1 +1138,1 @@\n-  if (can_reshape && cg != NULL) {\n+  if (can_reshape && cg != nullptr) {\n@@ -1149,1 +1149,1 @@\n-        set_generator(NULL);\n+        set_generator(nullptr);\n@@ -1157,1 +1157,1 @@\n-        set_generator(NULL);\n+        set_generator(nullptr);\n@@ -1167,1 +1167,1 @@\n-  if (_name != NULL && !strcmp(_name, \"uncommon_trap\")) {\n+  if (_name != nullptr && !strcmp(_name, \"uncommon_trap\")) {\n@@ -1175,1 +1175,1 @@\n-        call->in(TypeFunc::Parms) != NULL &&\n+        call->in(TypeFunc::Parms) != nullptr &&\n@@ -1192,1 +1192,1 @@\n-  if (ctl == NULL || ctl->is_top() || mem == NULL || mem->is_top() || !mem->is_MergeMem()) {\n+  if (ctl == nullptr || ctl->is_top() || mem == nullptr || mem->is_top() || !mem->is_MergeMem()) {\n@@ -1218,1 +1218,1 @@\n-  MemBarNode* membar = NULL;\n+  MemBarNode* membar = nullptr;\n@@ -1220,1 +1220,1 @@\n-    if (call == NULL || call->is_top()) {\n+    if (call == nullptr || call->is_top()) {\n@@ -1241,1 +1241,1 @@\n-  if (alloc_mem == NULL || alloc_mem->is_top()) {\n+  if (alloc_mem == nullptr || alloc_mem->is_top()) {\n@@ -1288,1 +1288,1 @@\n-  CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, \"uncommon_trap\", NULL);\n+  CallNode* unc = new CallStaticJavaNode(OptoRuntime::uncommon_trap_Type(), call_addr, \"uncommon_trap\", nullptr);\n@@ -1313,1 +1313,1 @@\n-  if (_name != NULL) {\n+  if (_name != nullptr) {\n@@ -1347,1 +1347,1 @@\n-  if (can_reshape && cg != NULL) {\n+  if (can_reshape && cg != nullptr) {\n@@ -1380,1 +1380,1 @@\n-      set_generator(NULL);\n+      set_generator(nullptr);\n@@ -1414,1 +1414,1 @@\n-  if (_entry_point == NULL) {\n+  if (_entry_point == nullptr) {\n@@ -1455,1 +1455,1 @@\n-  return entry_point() == NULL && idx == TypeFunc::Parms;\n+  return entry_point() == nullptr && idx == TypeFunc::Parms;\n@@ -1483,1 +1483,1 @@\n-  assert(n == NULL || n->Opcode() == Op_SafePoint, \"correct value for next_exception\");\n+  assert(n == nullptr || n->Opcode() == Op_SafePoint, \"correct value for next_exception\");\n@@ -1485,1 +1485,1 @@\n-    if (n != NULL)  add_prec(n);\n+    if (n != nullptr)  add_prec(n);\n@@ -1495,1 +1495,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1498,1 +1498,1 @@\n-    assert(n == NULL || n->Opcode() == Op_SafePoint, \"no other uses of prec edges\");\n+    assert(n == nullptr || n->Opcode() == Op_SafePoint, \"no other uses of prec edges\");\n@@ -1507,1 +1507,1 @@\n-  assert(_jvms == NULL || ((uintptr_t)_jvms->map() & 1) || _jvms->map() == this, \"inconsistent JVMState\");\n+  assert(_jvms == nullptr || ((uintptr_t)_jvms->map() & 1) || _jvms->map() == this, \"inconsistent JVMState\");\n@@ -1513,1 +1513,1 @@\n-  if (phase->C->scalarize_in_safepoints() && can_reshape && jvms() != NULL) {\n+  if (phase->C->scalarize_in_safepoints() && can_reshape && jvms() != nullptr) {\n@@ -1521,1 +1521,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1533,1 +1533,1 @@\n-    if (out_c != NULL && !out_c->is_OuterStripMinedLoopEnd()) {\n+    if (out_c != nullptr && !out_c->is_OuterStripMinedLoopEnd()) {\n@@ -1685,1 +1685,1 @@\n-  if (alloc != NULL && !alloc->is_Allocate()\n+  if (alloc != nullptr && !alloc->is_Allocate()\n@@ -1719,1 +1719,1 @@\n-  if (cached != NULL) {\n+  if (cached != nullptr) {\n@@ -1746,1 +1746,1 @@\n-  : CallNode(atype, NULL, TypeRawPtr::BOTTOM)\n+  : CallNode(atype, nullptr, TypeRawPtr::BOTTOM)\n@@ -1767,2 +1767,2 @@\n-  \/\/ DefaultValue defaults to NULL\n-  \/\/ RawDefaultValue defaults to NULL\n+  \/\/ DefaultValue defaults to nullptr\n+  \/\/ RawDefaultValue defaults to nullptr\n@@ -1774,1 +1774,1 @@\n-  assert(initializer != NULL &&\n+  assert(initializer != nullptr &&\n@@ -1778,1 +1778,1 @@\n-  if (analyzer == NULL) {\n+  if (analyzer == nullptr) {\n@@ -1789,1 +1789,1 @@\n-  Node* mark_node = NULL;\n+  Node* mark_node = nullptr;\n@@ -1804,1 +1804,1 @@\n-\/\/ a CastII is appropriate, return NULL.\n+\/\/ a CastII is appropriate, return null.\n@@ -1807,1 +1807,1 @@\n-  assert(length != NULL, \"length is not null\");\n+  assert(length != nullptr, \"length is not null\");\n@@ -1812,1 +1812,1 @@\n-  if (ary_type != NULL && length_type != NULL) {\n+  if (ary_type != nullptr && length_type != nullptr) {\n@@ -1825,1 +1825,1 @@\n-      \/\/ Return NULL if new nodes are not allowed\n+      \/\/ Return null if new nodes are not allowed\n@@ -1827,1 +1827,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1832,1 +1832,1 @@\n-      if (init != NULL) {\n+      if (init != nullptr) {\n@@ -1973,2 +1973,2 @@\n-  if (ctrl == NULL)\n-    return NULL;\n+  if (ctrl == nullptr)\n+    return nullptr;\n@@ -1979,1 +1979,1 @@\n-      if (n == NULL)\n+      if (n == nullptr)\n@@ -2002,2 +2002,2 @@\n-  ProjNode *ctrl_proj = (ctrl->is_Proj()) ? ctrl->as_Proj() : NULL;\n-  if (ctrl_proj != NULL && ctrl_proj->_con == TypeFunc::Control) {\n+  ProjNode *ctrl_proj = (ctrl->is_Proj()) ? ctrl->as_Proj() : nullptr;\n+  if (ctrl_proj != nullptr && ctrl_proj->_con == TypeFunc::Control) {\n@@ -2005,1 +2005,1 @@\n-    if (n != NULL && n->is_Unlock()) {\n+    if (n != nullptr && n->is_Unlock()) {\n@@ -2025,1 +2025,1 @@\n-  LockNode *lock_result = NULL;\n+  LockNode *lock_result = nullptr;\n@@ -2029,1 +2029,1 @@\n-    assert(ctrl != NULL, \"invalid control graph\");\n+    assert(ctrl != nullptr, \"invalid control graph\");\n@@ -2037,1 +2037,1 @@\n-      if (ctrl->req() == 3 && ctrl->in(1) != NULL && ctrl->in(2) != NULL) {\n+      if (ctrl->req() == 3 && ctrl->in(1) != nullptr && ctrl->in(2) != nullptr) {\n@@ -2076,1 +2076,1 @@\n-      Node* lock1_node = NULL;\n+      Node* lock1_node = nullptr;\n@@ -2087,1 +2087,1 @@\n-      if (lock1_node != NULL && lock1_node->is_Lock()) {\n+      if (lock1_node != nullptr && lock1_node->is_Lock()) {\n@@ -2112,1 +2112,1 @@\n-    if (in_node != NULL) {\n+    if (in_node != nullptr) {\n@@ -2167,1 +2167,1 @@\n-  \/\/ perform any generic optimizations first (returns 'this' or NULL)\n+  \/\/ perform any generic optimizations first (returns 'this' or null)\n@@ -2169,1 +2169,1 @@\n-  if (result != NULL)  return result;\n+  if (result != nullptr)  return result;\n@@ -2171,1 +2171,1 @@\n-  if (in(0) && in(0)->is_top())  return NULL;\n+  if (in(0) && in(0)->is_top())  return nullptr;\n@@ -2184,1 +2184,1 @@\n-    if (cgr != NULL && cgr->not_global_escape(obj_node())) {\n+    if (cgr != nullptr && cgr->not_global_escape(obj_node())) {\n@@ -2203,1 +2203,1 @@\n-    if (iter != NULL && !is_eliminated()) {\n+    if (iter != nullptr && !is_eliminated()) {\n@@ -2283,1 +2283,1 @@\n-  return is_nested_lock_region(NULL);\n+  return is_nested_lock_region(nullptr);\n@@ -2286,1 +2286,1 @@\n-\/\/ p is used for access to compilation log; no logging if NULL\n+\/\/ p is used for access to compilation log; no logging if null\n@@ -2299,2 +2299,2 @@\n-  LockNode* unique_lock = NULL;\n-  Node* bad_lock = NULL;\n+  LockNode* unique_lock = nullptr;\n+  Node* bad_lock = nullptr;\n@@ -2309,1 +2309,1 @@\n-    this->log_lock_optimization(c, \"eliminate_lock_INLR_2b\", (unique_lock != NULL ? unique_lock : bad_lock));\n+    this->log_lock_optimization(c, \"eliminate_lock_INLR_2b\", (unique_lock != nullptr ? unique_lock : bad_lock));\n@@ -2318,1 +2318,1 @@\n-      if (unique_lock != NULL) {\n+      if (unique_lock != nullptr) {\n@@ -2322,1 +2322,1 @@\n-      if (bad_lock != NULL) {\n+      if (bad_lock != nullptr) {\n@@ -2363,1 +2363,1 @@\n-  \/\/ perform any generic optimizations first (returns 'this' or NULL)\n+  \/\/ perform any generic optimizations first (returns 'this' or null)\n@@ -2365,1 +2365,1 @@\n-  if (result != NULL)  return result;\n+  if (result != nullptr)  return result;\n@@ -2367,1 +2367,1 @@\n-  if (in(0) && in(0)->is_top())  return NULL;\n+  if (in(0) && in(0)->is_top())  return nullptr;\n@@ -2381,1 +2381,1 @@\n-    if (cgr != NULL && cgr->not_global_escape(obj_node())) {\n+    if (cgr != nullptr && cgr->not_global_escape(obj_node())) {\n@@ -2396,1 +2396,1 @@\n-  if (C == NULL) {\n+  if (C == nullptr) {\n@@ -2400,1 +2400,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -2403,2 +2403,2 @@\n-    int box_id = box != NULL ? box->_idx : -1;\n-    int obj_id = obj != NULL ? obj->_idx : -1;\n+    int box_id = box != nullptr ? box->_idx : -1;\n+    int obj_id = obj != nullptr ? obj->_idx : -1;\n@@ -2409,1 +2409,1 @@\n-          kind_as_string(), box_id, obj_id, (bad_lock != NULL ? bad_lock->_idx : -1));\n+          kind_as_string(), box_id, obj_id, (bad_lock != nullptr ? bad_lock->_idx : -1));\n@@ -2413,1 +2413,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":138,"deletions":138,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -249,1 +249,1 @@\n-  bool              has_method() const { return _method != NULL; }\n+  bool              has_method() const { return _method != nullptr; }\n@@ -337,1 +337,1 @@\n-  assert(s != nullptr, \"assign NULL value to _jvms\");\n+  assert(s != nullptr, \"assign null value to _jvms\");\n@@ -342,2 +342,2 @@\n-                \/\/ A plain safepoint advertises no memory effects (NULL):\n-                const TypePtr* adr_type = NULL)\n+                \/\/ A plain safepoint advertises no memory effects (null):\n+                const TypePtr* adr_type = nullptr)\n@@ -355,1 +355,1 @@\n-    if (jvms() != NULL) {\n+    if (jvms() != nullptr) {\n@@ -436,1 +436,1 @@\n-  bool is_killed() { return in(TypeFunc::Control) == NULL; }\n+  bool is_killed() { return in(TypeFunc::Control) == nullptr; }\n@@ -444,1 +444,1 @@\n-  bool                   has_exceptions() const { return next_exception() != NULL; }\n+  bool                   has_exceptions() const { return next_exception() != nullptr; }\n@@ -533,1 +533,1 @@\n-    assert(jvms != NULL, \"missed JVMS\");\n+    assert(jvms != nullptr, \"missed JVMS\");\n@@ -608,1 +608,1 @@\n-  const char*     _name;        \/\/ Printable name, if _method is NULL\n+  const char*     _name;        \/\/ Printable name, if _method is null\n@@ -615,2 +615,2 @@\n-      _generator(NULL),\n-      _name(NULL)\n+      _generator(nullptr),\n+      _name(nullptr)\n@@ -655,1 +655,1 @@\n-  \/\/ or returns NULL if there is no one.\n+  \/\/ or returns null if there is no one.\n@@ -745,1 +745,1 @@\n-    if (C->eliminate_boxing() && (method != NULL) && method->is_boxing_method()) {\n+    if (C->eliminate_boxing() && (method != nullptr) && method->is_boxing_method()) {\n@@ -762,1 +762,1 @@\n-    : CallJavaNode(tf, addr, NULL) {\n+    : CallJavaNode(tf, addr, nullptr) {\n@@ -774,1 +774,1 @@\n-    return is_macro() && (method() != NULL) && method()->is_boxing_method();\n+    return is_macro() && (method() != nullptr) && method()->is_boxing_method();\n@@ -978,1 +978,1 @@\n-    return (allo == NULL) ? NULL : allo->in(KlassNode);\n+    return (allo == nullptr) ? nullptr : allo->in(KlassNode);\n@@ -999,1 +999,1 @@\n-  \/\/ ArgEscape. In case allocation's InitializeNode is NULL, check\n+  \/\/ ArgEscape. In case allocation's InitializeNode is null, check\n@@ -1004,2 +1004,2 @@\n-    InitializeNode* init = NULL;\n-    return _is_non_escaping || (((init = initialization()) != NULL) && init->does_not_escape());\n+    InitializeNode* init = nullptr;\n+    return _is_non_escaping || (((init = initialization()) != nullptr) && init->does_not_escape());\n@@ -1051,2 +1051,2 @@\n-    return (allo == NULL || !allo->is_AllocateArray())\n-           ? NULL : allo->as_AllocateArray();\n+    return (allo == nullptr || !allo->is_AllocateArray())\n+           ? nullptr : allo->as_AllocateArray();\n@@ -1089,1 +1089,1 @@\n-    : CallNode(tf, NULL, TypeRawPtr::BOTTOM),\n+    : CallNode(tf, nullptr, TypeRawPtr::BOTTOM),\n@@ -1093,1 +1093,1 @@\n-    _counter = NULL;\n+    _counter = nullptr;\n@@ -1112,1 +1112,1 @@\n-  void log_lock_optimization(Compile* c, const char * tag, Node* bad_lock = NULL) const;\n+  void log_lock_optimization(Compile* c, const char * tag, Node* bad_lock = nullptr) const;\n@@ -1186,1 +1186,1 @@\n-    , _dbg_jvms(NULL)\n+    , _dbg_jvms(nullptr)\n@@ -1202,1 +1202,1 @@\n-  JVMState* dbg_jvms() const { return NULL; }\n+  JVMState* dbg_jvms() const { return nullptr; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  if (dom != NULL) {\n+  if (dom != nullptr) {\n@@ -109,1 +109,1 @@\n-  if (vt != NULL && phase->type(vt)->filter_speculative(_type) != Type::TOP) {\n+  if (vt != nullptr && phase->type(vt)->filter_speculative(_type) != Type::TOP) {\n@@ -117,1 +117,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -164,1 +164,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -178,1 +178,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -183,1 +183,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -188,2 +188,2 @@\n-  if (ctl == NULL) {\n-    return NULL;\n+  if (ctl == nullptr) {\n+    return nullptr;\n@@ -195,1 +195,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -197,2 +197,2 @@\n-  if (type()->isa_rawptr() && (gvn->type_or_null(val) == NULL || gvn->type(val)->isa_oopptr())) {\n-    return NULL;\n+  if (type()->isa_rawptr() && (gvn->type_or_null(val) == nullptr || gvn->type(val)->isa_oopptr())) {\n+    return nullptr;\n@@ -205,1 +205,1 @@\n-        u->in(0) != NULL &&\n+        u->in(0) != nullptr &&\n@@ -219,1 +219,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -265,1 +265,1 @@\n-    if (in(0) != NULL && in(0)->in(0) != NULL && in(0)->in(0)->is_If()) {\n+    if (in(0) != nullptr && in(0)->in(0) != nullptr && in(0)->in(0)->is_If()) {\n@@ -327,1 +327,1 @@\n-  if (existing != NULL) {\n+  if (existing != nullptr) {\n@@ -336,1 +336,1 @@\n-  if (progress != NULL) {\n+  if (progress != nullptr) {\n@@ -346,1 +346,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -393,1 +393,1 @@\n-  if (progress != NULL) {\n+  if (progress != nullptr) {\n@@ -403,1 +403,1 @@\n-  if (in1 != NULL && in1->Opcode() == Op_ConvI2L) {\n+  if (in1 != nullptr && in1->Opcode() == Op_ConvI2L) {\n@@ -448,1 +448,1 @@\n-  if (in_type != NULL && my_type != NULL) {\n+  if (in_type != nullptr && my_type != nullptr) {\n@@ -455,1 +455,1 @@\n-      if (my_type == NULL) {\n+      if (my_type == nullptr) {\n@@ -532,1 +532,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -570,1 +570,1 @@\n-  return (in(0) && remove_dead_region(phase, can_reshape)) ? this : NULL;\n+  return (in(0) && remove_dead_region(phase, can_reshape)) ? this : nullptr;\n@@ -580,1 +580,1 @@\n-  Node* cast= NULL;\n+  Node* cast= nullptr;\n@@ -601,2 +601,2 @@\n-  const TypeInteger* rx = NULL;\n-  const TypeInteger* ry = NULL;\n+  const TypeInteger* rx = nullptr;\n+  const TypeInteger* ry = nullptr;\n@@ -605,1 +605,1 @@\n-    if (igvn == NULL) {\n+    if (igvn == nullptr) {\n@@ -609,1 +609,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -623,1 +623,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -625,1 +625,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -634,1 +634,1 @@\n-  if (in_type != NULL &&\n+  if (in_type != nullptr &&\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,1 +194,1 @@\n-  CastX2PNode( Node *n ) : Node(NULL, n) {}\n+  CastX2PNode( Node *n ) : Node(nullptr, n) {}\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-    return NULL;\n-  Node *progress = NULL;        \/\/ Progress flag\n+    return nullptr;\n+  Node *progress = nullptr;        \/\/ Progress flag\n@@ -95,1 +95,1 @@\n-          return NULL;        \/\/ Only flatten if no Phi users\n+          return nullptr;        \/\/ Only flatten if no Phi users\n@@ -130,1 +130,1 @@\n-\/\/ Helper function: Return any PhiNode that uses this region or NULL\n+\/\/ Helper function: Return any PhiNode that uses this region or null\n@@ -140,1 +140,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -145,1 +145,1 @@\n-\/\/ Helper function: Return the only PhiNode that uses this region or NULL\n+\/\/ Helper function: Return the only PhiNode that uses this region or null\n@@ -148,1 +148,1 @@\n-  PhiNode* only_phi = NULL;\n+  PhiNode* only_phi = nullptr;\n@@ -153,1 +153,1 @@\n-      if (only_phi == NULL) {\n+      if (only_phi == nullptr) {\n@@ -156,1 +156,1 @@\n-        return NULL;  \/\/ multiple phis\n+        return nullptr;  \/\/ multiple phis\n@@ -169,3 +169,3 @@\n-  min     = NULL;\n-  max     = NULL;\n-  val     = NULL;\n+  min     = nullptr;\n+  max     = nullptr;\n+  val     = nullptr;\n@@ -183,2 +183,2 @@\n-          if( min == NULL ) {\n-            min     = n->Opcode() == Op_ConI ? (ConNode*)n : NULL;\n+          if( min == nullptr ) {\n+            min     = n->Opcode() == Op_ConI ? (ConNode*)n : nullptr;\n@@ -187,1 +187,1 @@\n-            max     = n->Opcode() == Op_ConI ? (ConNode*)n : NULL;\n+            max     = n->Opcode() == Op_ConI ? (ConNode*)n : nullptr;\n@@ -224,2 +224,2 @@\n-  top_if = NULL;\n-  bot_if = NULL;\n+  top_if = nullptr;\n+  bot_if = nullptr;\n@@ -237,3 +237,3 @@\n-    if( in10 != NULL && in10->is_If() &&\n-        in20 != NULL && in20->is_If() &&\n-        in30 != NULL && in30->is_If() && in10 == in20 &&\n+    if( in10 != nullptr && in10->is_If() &&\n+        in20 != nullptr && in20->is_If() &&\n+        in30 != nullptr && in30->is_If() && in10 == in20 &&\n@@ -242,1 +242,1 @@\n-      Node *in1000 = (in100 != NULL && in100->is_Proj()) ? in100->in(0) : NULL;\n+      Node *in1000 = (in100 != nullptr && in100->is_Proj()) ? in100->in(0) : nullptr;\n@@ -244,1 +244,1 @@\n-      if( in1000 != NULL && in1000->is_If() &&\n+      if( in1000 != nullptr && in1000->is_If() &&\n@@ -253,1 +253,1 @@\n-  return (top_if != NULL);\n+  return (top_if != nullptr);\n@@ -261,1 +261,1 @@\n-  convf2i = NULL;\n+  convf2i = nullptr;\n@@ -322,1 +322,1 @@\n-  assert(req() == 2 || (req() == 3 && in(1) != NULL && in(2) == top), \"sanity check arguments\");\n+  assert(req() == 2 || (req() == 3 && in(1) != nullptr && in(2) == top), \"sanity check arguments\");\n@@ -346,1 +346,1 @@\n-    if (n != NULL && n->is_Phi()) {\n+    if (n != nullptr && n->is_Phi()) {\n@@ -356,1 +356,1 @@\n-        if (u != NULL && (u->is_Phi() || u->is_CFG())) {\n+        if (u != nullptr && (u->is_Phi() || u->is_CFG())) {\n@@ -386,1 +386,1 @@\n-      if (m != NULL && m->is_CFG()) {\n+      if (m != nullptr && m->is_CFG()) {\n@@ -472,1 +472,1 @@\n-    MergeMemNode* m = NULL;\n+    MergeMemNode* m = nullptr;\n@@ -490,1 +490,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -497,1 +497,1 @@\n-  if( !can_reshape && !in(0) ) return NULL;     \/\/ Already degraded to a Copy\n+  if( !can_reshape && !in(0) ) return nullptr;     \/\/ Already degraded to a Copy\n@@ -504,1 +504,1 @@\n-    has_phis = (has_phi() != NULL);       \/\/ Cache result\n+    has_phis = (has_phi() != nullptr);       \/\/ Cache result\n@@ -507,1 +507,1 @@\n-      if (phi != NULL) {\n+      if (phi != nullptr) {\n@@ -509,1 +509,1 @@\n-        if (m != NULL) {\n+        if (m != nullptr) {\n@@ -529,1 +529,1 @@\n-            set_req(j, NULL);\n+            set_req(j, nullptr);\n@@ -537,1 +537,1 @@\n-  \/\/ Remove TOP or NULL input paths. If only 1 input path remains, this Region\n+  \/\/ Remove TOP or null input paths. If only 1 input path remains, this Region\n@@ -548,1 +548,1 @@\n-    if( n != NULL ) {\n+    if( n != nullptr ) {\n@@ -566,1 +566,1 @@\n-        set_req_X(i, NULL, phase); \/\/ Ignore TOP inputs\n+        set_req_X(i, nullptr, phase); \/\/ Ignore TOP inputs\n@@ -588,1 +588,1 @@\n-            n->set_req_X(i,NULL,igvn);\/\/ Correct DU info\n+            n->set_req_X(i,nullptr,igvn);\/\/ Correct DU info\n@@ -634,1 +634,1 @@\n-    set_req(0, NULL);           \/\/ Null control input for region copy\n+    set_req(0, nullptr);        \/\/ Null control input for region copy\n@@ -636,2 +636,2 @@\n-      \/\/ No inputs or all inputs are NULL.\n-      return NULL;\n+      \/\/ No inputs or all inputs are null.\n+      return nullptr;\n@@ -645,1 +645,1 @@\n-        if (outer_sfpt != NULL && outer_out != NULL) {\n+        if (outer_sfpt != nullptr && outer_out != nullptr) {\n@@ -654,1 +654,1 @@\n-        if (opaq != NULL) {\n+        if (opaq != nullptr) {\n@@ -672,1 +672,1 @@\n-        assert(parent_ctrl != NULL, \"Region is a copy of some non-null control\");\n+        assert(parent_ctrl != nullptr, \"Region is a copy of some non-null control\");\n@@ -695,1 +695,1 @@\n-            assert( n->req() == 2 &&  n->in(1) != NULL, \"Only one data input expected\" );\n+            assert( n->req() == 2 &&  n->in(1) != nullptr, \"Only one data input expected\" );\n@@ -721,1 +721,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -730,1 +730,1 @@\n-    if (m != NULL)  return m;\n+    if (m != nullptr)  return m;\n@@ -737,1 +737,1 @@\n-    if (phi != NULL) {          \/\/ One Phi user\n+    if (phi != nullptr) {          \/\/ One Phi user\n@@ -750,2 +750,2 @@\n-          Node   *top_in = NULL;   \/\/ value being compared against\n-          Node   *bot_in = NULL;\n+          Node   *top_in = nullptr;   \/\/ value being compared against\n+          Node   *bot_in = nullptr;\n@@ -756,1 +756,1 @@\n-              assert( gvn != NULL, \"Only had DefUse info in IterGVN\");\n+              assert( gvn != nullptr, \"Only had DefUse info in IterGVN\");\n@@ -798,1 +798,1 @@\n-  return modified ? this : NULL;\n+  return modified ? this : nullptr;\n@@ -886,2 +886,2 @@\n-  Node* region = NULL;\n-  if (req() == 3 && in(1) != NULL && in(2) != NULL) {\n+  Node* region = nullptr;\n+  if (req() == 3 && in(1) != nullptr && in(2) != nullptr) {\n@@ -891,1 +891,1 @@\n-    if (region == NULL || region->outcnt() != 2 || region->req() != 3) {\n+    if (region == nullptr || region->outcnt() != 2 || region->req() != 3) {\n@@ -898,1 +898,1 @@\n-    if (phi == NULL) {\n+    if (phi == nullptr) {\n@@ -913,1 +913,1 @@\n-  if (region == NULL || region->in(idx1) == NULL || region->in(idx2) == NULL) {\n+  if (region == nullptr || region->in(idx1) == nullptr || region->in(idx2) == nullptr) {\n@@ -920,2 +920,2 @@\n-  if (proj1 == NULL || proj1->outcnt() != 1 ||\n-      proj2 == NULL || proj2->outcnt() != 1) {\n+  if (proj1 == nullptr || proj1->outcnt() != 1 ||\n+      proj2 == nullptr || proj2->outcnt() != 1) {\n@@ -927,2 +927,2 @@\n-  if (iff1 == NULL || iff1->outcnt() != 2 ||\n-      iff2 == NULL || iff2->outcnt() != 2) {\n+  if (iff1 == nullptr || iff1->outcnt() != 2 ||\n+      iff2 == nullptr || iff2->outcnt() != 2) {\n@@ -939,1 +939,1 @@\n-  if (bol1 == NULL || bol2 == NULL) {\n+  if (bol1 == nullptr || bol2 == nullptr) {\n@@ -1026,1 +1026,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1041,1 +1041,1 @@\n-  if (at == NULL || at == TypePtr::BOTTOM)  return at;\n+  if (at == nullptr || at == TypePtr::BOTTOM)  return at;\n@@ -1053,1 +1053,1 @@\n-    if (r->in(j) != NULL)\n+    if (r->in(j) != nullptr)\n@@ -1060,1 +1060,1 @@\n-  const TypePtr* at = NULL;\n+  const TypePtr* at = nullptr;\n@@ -1066,1 +1066,1 @@\n-  const TypePtr* at = NULL;\n+  const TypePtr* at = nullptr;\n@@ -1089,1 +1089,1 @@\n-  assert(t_oop != NULL && t_oop->is_known_instance(), \"expecting instance oopptr\");\n+  assert(t_oop != nullptr && t_oop->is_known_instance(), \"expecting instance oopptr\");\n@@ -1118,1 +1118,1 @@\n-      if (in == NULL || igvn->type(in) == Type::TOP)\n+      if (in == nullptr || igvn->type(in) == Type::TOP)\n@@ -1120,3 +1120,3 @@\n-      Node *opt = MemNode::optimize_simple_memory_chain(in, t_oop, NULL, igvn);\n-      PhiNode *optphi = opt->is_Phi() ? opt->as_Phi() : NULL;\n-      if (optphi != NULL && optphi->adr_type() == TypePtr::BOTTOM) {\n+      Node *opt = MemNode::optimize_simple_memory_chain(in, t_oop, nullptr, igvn);\n+      PhiNode *optphi = opt->is_Phi() ? opt->as_Phi() : nullptr;\n+      if (optphi != nullptr && optphi->adr_type() == TypePtr::BOTTOM) {\n@@ -1124,1 +1124,1 @@\n-        if (opt == NULL) {\n+        if (opt == nullptr) {\n@@ -1155,1 +1155,1 @@\n-    if (n == NULL)  continue;\n+    if (n == nullptr)  continue;\n@@ -1165,1 +1165,1 @@\n-      assert((nat != NULL) == (at != NULL), \"\");\n+      assert((nat != nullptr) == (at != nullptr), \"\");\n@@ -1177,1 +1177,1 @@\n-  assert((_type == Type::MEMORY) == (_adr_type != NULL), \"adr_type for memory phis only\");\n+  assert((_type == Type::MEMORY) == (_adr_type != nullptr), \"adr_type for memory phis only\");\n@@ -1181,1 +1181,1 @@\n-  assert(_adr_type == NULL || _adr_type->isa_aryptr() == NULL ||\n+  assert(_adr_type == nullptr || _adr_type->isa_aryptr() == nullptr ||\n@@ -1213,1 +1213,1 @@\n-  BaseCountedLoopNode* l = r->is_BaseCountedLoop() ? r->as_BaseCountedLoop() : NULL;\n+  BaseCountedLoopNode* l = r->is_BaseCountedLoop() ? r->as_BaseCountedLoop() : nullptr;\n@@ -1215,1 +1215,1 @@\n-    \/\/ protect against init_trip() or limit() returning NULL\n+    \/\/ protect against init_trip() or limit() returning null\n@@ -1220,1 +1220,1 @@\n-      if (init != NULL && limit != NULL && stride != NULL) {\n+      if (init != nullptr && limit != nullptr && stride != nullptr) {\n@@ -1224,1 +1224,1 @@\n-        if (lo != NULL && hi != NULL && stride_t != NULL) { \/\/ Dying loops might have TOP here\n+        if (lo != nullptr && hi != nullptr && stride_t != nullptr) { \/\/ Dying loops might have TOP here\n@@ -1278,2 +1278,2 @@\n-    } else if (l->in(LoopNode::LoopBackControl) != NULL &&\n-               in(LoopNode::EntryControl) != NULL &&\n+    } else if (l->in(LoopNode::LoopBackControl) != nullptr &&\n+               in(LoopNode::EntryControl) != nullptr &&\n@@ -1406,2 +1406,2 @@\n-  if (id == NULL)\n-    return NULL;\n+  if (id == nullptr)\n+    return nullptr;\n@@ -1413,1 +1413,1 @@\n-  if (ctl != NULL && ctl->in(0) == iff) {\n+  if (ctl != nullptr && ctl->in(0) == iff) {\n@@ -1418,1 +1418,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1437,1 +1437,1 @@\n-  if (uin != NULL) {\n+  if (uin != nullptr) {\n@@ -1445,1 +1445,1 @@\n-    if (id != NULL) {\n+    if (id != nullptr) {\n@@ -1452,1 +1452,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -1471,1 +1471,1 @@\n-            u = NULL;\n+            u = nullptr;\n@@ -1475,1 +1475,1 @@\n-        if (u != NULL) {\n+        if (u != nullptr) {\n@@ -1501,1 +1501,1 @@\n-  Node* input = NULL; \/\/ The unique direct input (maybe uncasted = ConstraintCasts removed)\n+  Node* input = nullptr; \/\/ The unique direct input (maybe uncasted = ConstraintCasts removed)\n@@ -1505,1 +1505,1 @@\n-    if (rc == NULL || phase->type(rc) == Type::TOP)\n+    if (rc == nullptr || phase->type(rc) == Type::TOP)\n@@ -1508,1 +1508,1 @@\n-    if (n == NULL)\n+    if (n == nullptr)\n@@ -1515,1 +1515,1 @@\n-      while (un != NULL && un->req() == 2 && un->is_ConstraintCast()) {\n+      while (un != nullptr && un->req() == 2 && un->is_ConstraintCast()) {\n@@ -1525,1 +1525,1 @@\n-    if (un == NULL || un == this || phase->type(un) == Type::TOP) {\n+    if (un == nullptr || un == this || phase->type(un) == Type::TOP) {\n@@ -1529,1 +1529,1 @@\n-    if (input == NULL) {\n+    if (input == nullptr) {\n@@ -1535,1 +1535,1 @@\n-  if (input == NULL) {\n+  if (input == nullptr) {\n@@ -1544,1 +1544,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1574,1 +1574,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1581,1 +1581,1 @@\n-    } else return NULL;\n+    } else return nullptr;\n@@ -1585,2 +1585,2 @@\n-    } else return NULL;\n-  } else return NULL;\n+    } else return nullptr;\n+  } else return nullptr;\n@@ -1592,1 +1592,1 @@\n-  } else return NULL;\n+  } else return nullptr;\n@@ -1621,1 +1621,1 @@\n-  if (region->has_unique_phi() != phi)  return NULL;\n+  if (region->has_unique_phi() != phi)  return nullptr;\n@@ -1625,2 +1625,2 @@\n-  if (region->in(1)->outcnt() != 1) return NULL;\n-  if (region->in(2)->outcnt() != 1) return NULL;\n+  if (region->in(1)->outcnt() != 1) return nullptr;\n+  if (region->in(2)->outcnt() != 1) return nullptr;\n@@ -1629,2 +1629,2 @@\n-  if (b->_test._test != BoolTest::lt)  return NULL;\n-  if (cmp->Opcode() != Op_CmpI)        return NULL;\n+  if (b->_test._test != BoolTest::lt)  return nullptr;\n+  if (cmp->Opcode() != Op_CmpI)        return nullptr;\n@@ -1643,1 +1643,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1646,1 +1646,1 @@\n-  Node *y = NULL;\n+  Node *y = nullptr;\n@@ -1651,1 +1651,1 @@\n-  } else return NULL;\n+  } else return nullptr;\n@@ -1655,1 +1655,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1686,1 +1686,1 @@\n-    default:           return NULL;                              break;\n+    default:           return nullptr;                           break;\n@@ -1694,1 +1694,1 @@\n-    default:           return NULL;                              break;\n+    default:           return nullptr;                           break;\n@@ -1699,1 +1699,1 @@\n-  const Type *tzero = NULL;\n+  const Type *tzero = nullptr;\n@@ -1705,1 +1705,1 @@\n-  default: return NULL;\n+  default: return nullptr;\n@@ -1709,1 +1709,1 @@\n-  Node *x = NULL;\n+  Node *x = nullptr;\n@@ -1718,1 +1718,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1723,1 +1723,1 @@\n-  if( phi_root->in(phi_x_idx) != x ) return NULL;\n+  if( phi_root->in(phi_x_idx) != x ) return nullptr;\n@@ -1732,1 +1732,1 @@\n-  if (!is_sub || phase->type(sub->in(1)) != tzero || sub->in(2) != x) return NULL;\n+  if (!is_sub || phase->type(sub->in(1)) != tzero || sub->in(2) != x) return nullptr;\n@@ -1754,1 +1754,1 @@\n-  } else return NULL;\n+  } else return nullptr;\n@@ -1800,1 +1800,1 @@\n-    return NULL;                \/\/ Bail out on funny non-value stuff\n+    return nullptr;             \/\/ Bail out on funny non-value stuff\n@@ -1802,1 +1802,1 @@\n-    return NULL;                \/\/ third unequal input to be worth doing\n+    return nullptr;             \/\/ third unequal input to be worth doing\n@@ -1808,2 +1808,2 @@\n-    if( !n ) return NULL;\n-    if( phase->type(n) == Type::TOP ) return NULL;\n+    if( !n ) return nullptr;\n+    if( phase->type(n) == Type::TOP ) return nullptr;\n@@ -1814,1 +1814,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1822,2 +1822,2 @@\n-    if( !n ) return NULL;\n-    if( phase->type(n) == Type::TOP ) return NULL;\n+    if( !n ) return nullptr;\n+    if( phase->type(n) == Type::TOP ) return nullptr;\n@@ -1826,2 +1826,2 @@\n-      if (PhaseIdealLoop::find_predicate(r->in(i)) != NULL) {\n-        return NULL;            \/\/ don't split loop entry path\n+      if (PhaseIdealLoop::find_predicate(r->in(i)) != nullptr) {\n+        return nullptr;            \/\/ don't split loop entry path\n@@ -1834,1 +1834,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1887,1 +1887,1 @@\n-  if (in != NULL && !in->is_dead_loop_safe()) {\n+  if (in != nullptr && !in->is_dead_loop_safe()) {\n@@ -1896,1 +1896,1 @@\n-      if (m != NULL && !m->is_dead_loop_safe()) {\n+      if (m != nullptr && !m->is_dead_loop_safe()) {\n@@ -1899,1 +1899,1 @@\n-        Node *m1 = (m->is_AddP() && m->req() > 3) ? m->in(1) : NULL;\n+        Node *m1 = (m->is_AddP() && m->req() > 3) ? m->in(1) : nullptr;\n@@ -1902,1 +1902,1 @@\n-        if (m1 != NULL && m1 == m->in(2) &&\n+        if (m1 != nullptr && m1 == m->in(2) &&\n@@ -1945,1 +1945,1 @@\n-      if (m != NULL && !m->is_dead_loop_safe()) { \/\/ Only look for unsafe cases.\n+      if (m != nullptr && !m->is_dead_loop_safe()) { \/\/ Only look for unsafe cases.\n@@ -1964,1 +1964,1 @@\n-    if (rc != NULL &&\n+    if (rc != nullptr &&\n@@ -1968,1 +1968,1 @@\n-      } else if (rc->in(0) != NULL &&\n+      } else if (rc->in(0) != nullptr &&\n@@ -1972,1 +1972,1 @@\n-        } else if (rc->in(0)->in(1) != NULL &&\n+        } else if (rc->in(0)->in(1) != nullptr &&\n@@ -1976,1 +1976,1 @@\n-          } else if (rc->in(0)->in(1)->in(1) != NULL &&\n+          } else if (rc->in(0)->in(1)->in(1) != nullptr &&\n@@ -2066,2 +2066,2 @@\n-  assert(r != NULL && r->is_Region(), \"this phi must have a region\");\n-  assert(r->in(0) == NULL || !r->in(0)->is_Root(), \"not a specially hidden merge\");\n+  assert(r != nullptr && r->is_Region(), \"this phi must have a region\");\n+  assert(r->in(0) == nullptr || !r->in(0)->is_Root(), \"not a specially hidden merge\");\n@@ -2072,1 +2072,1 @@\n-    return NULL;                \/\/ No change\n+    return nullptr;                \/\/ No change\n@@ -2078,1 +2078,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2089,1 +2089,1 @@\n-  Node* progress = NULL;        \/\/ Record if any progress made\n+  Node* progress = nullptr;        \/\/ Record if any progress made\n@@ -2094,1 +2094,1 @@\n-    if (rc == NULL || phase->type(rc) == Type::TOP) {\n+    if (rc == nullptr || phase->type(rc) == Type::TOP) {\n@@ -2097,1 +2097,1 @@\n-        if (can_reshape && igvn != NULL) {\n+        if (can_reshape && igvn != nullptr) {\n@@ -2115,1 +2115,1 @@\n-  if (uin == NULL && can_reshape &&\n+  if (uin == nullptr && can_reshape &&\n@@ -2126,3 +2126,3 @@\n-      return NULL;              \/\/ Identity will return TOP\n-  } else if (uin != NULL) {\n-    \/\/ Only one not-NULL unique input path is left.\n+      return nullptr;              \/\/ Identity will return TOP\n+  } else if (uin != nullptr) {\n+    \/\/ Only one not-null unique input path is left.\n@@ -2131,1 +2131,1 @@\n-    if (outcnt() > 0 && r->in(0) != NULL) {\n+    if (outcnt() > 0 && r->in(0) != nullptr) {\n@@ -2140,1 +2140,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2152,1 +2152,1 @@\n-      Node* cast = NULL;\n+      Node* cast = nullptr;\n@@ -2174,1 +2174,1 @@\n-            if (cast != NULL) {\n+            if (cast != nullptr) {\n@@ -2180,1 +2180,1 @@\n-          if (cast == NULL) {\n+          if (cast == nullptr) {\n@@ -2187,1 +2187,1 @@\n-      assert(cast != NULL, \"cast should be set\");\n+      assert(cast != nullptr, \"cast should be set\");\n@@ -2211,1 +2211,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2214,1 +2214,1 @@\n-  Node* opt = NULL;\n+  Node* opt = nullptr;\n@@ -2224,1 +2224,1 @@\n-    if( unsafe_id != NULL && is_unsafe_data_reference(unsafe_id) )\n+    if( unsafe_id != nullptr && is_unsafe_data_reference(unsafe_id) )\n@@ -2228,1 +2228,1 @@\n-    if( opt == NULL )\n+    if( opt == nullptr )\n@@ -2232,1 +2232,1 @@\n-    if( opt == NULL )\n+    if( opt == nullptr )\n@@ -2236,1 +2236,1 @@\n-    if( opt == NULL && can_reshape )\n+    if( opt == nullptr && can_reshape )\n@@ -2241,1 +2241,1 @@\n-    if( opt != NULL ) {\n+    if( opt != nullptr ) {\n@@ -2251,1 +2251,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2262,2 +2262,2 @@\n-    assert(opt == NULL || opt == this, \"do not elide phi\");\n-    if (opt != NULL)  return opt;\n+    assert(opt == nullptr || opt == this, \"do not elide phi\");\n+    if (opt != nullptr)  return opt;\n@@ -2266,1 +2266,1 @@\n-  if (in(1) != NULL && in(1)->Opcode() == Op_AddP && can_reshape) {\n+  if (in(1) != nullptr && in(1)->Opcode() == Op_AddP && can_reshape) {\n@@ -2282,1 +2282,1 @@\n-    if (base != NULL && address != NULL && offset != NULL &&\n+    if (base != nullptr && address != nullptr && offset != nullptr &&\n@@ -2290,1 +2290,1 @@\n-        if (in(i) == NULL ||\n+        if (in(i) == nullptr ||\n@@ -2292,3 +2292,3 @@\n-            in(i)->in(AddPNode::Base) == NULL ||\n-            in(i)->in(AddPNode::Address) == NULL ||\n-            in(i)->in(AddPNode::Offset) == NULL ||\n+            in(i)->in(AddPNode::Base) == nullptr ||\n+            in(i)->in(AddPNode::Address) == nullptr ||\n+            in(i)->in(AddPNode::Offset) == nullptr ||\n@@ -2302,1 +2302,1 @@\n-          base = NULL;\n+          base = nullptr;\n@@ -2305,1 +2305,1 @@\n-          offset = NULL;\n+          offset = nullptr;\n@@ -2308,1 +2308,1 @@\n-          address = NULL;\n+          address = nullptr;\n@@ -2314,1 +2314,1 @@\n-      if (doit && base == NULL) {\n+      if (doit && base == nullptr) {\n@@ -2321,2 +2321,2 @@\n-            if (base2 != NULL && !base2->is_top()) {\n-              if (base == NULL)\n+            if (base2 != nullptr && !base2->is_top()) {\n+              if (base == nullptr)\n@@ -2331,2 +2331,2 @@\n-        if (base == NULL) {\n-          base = new PhiNode(in(0), base_type, NULL);\n+        if (base == nullptr) {\n+          base = new PhiNode(in(0), base_type, nullptr);\n@@ -2338,2 +2338,2 @@\n-        if (address == NULL) {\n-          address = new PhiNode(in(0), address_type, NULL);\n+        if (address == nullptr) {\n+          address = new PhiNode(in(0), address_type, nullptr);\n@@ -2345,2 +2345,2 @@\n-        if (offset == NULL) {\n-          offset = new PhiNode(in(0), TypeX_X, NULL);\n+        if (offset == nullptr) {\n+          offset = new PhiNode(in(0), TypeX_X, nullptr);\n@@ -2363,1 +2363,1 @@\n-  if (progress == NULL && can_reshape && type() == Type::MEMORY) {\n+  if (progress == nullptr && can_reshape && type() == Type::MEMORY) {\n@@ -2375,1 +2375,1 @@\n-        return NULL; \/\/ Delay optimization until graph is cleaned.\n+        return nullptr; \/\/ Delay optimization until graph is cleaned.\n@@ -2446,1 +2446,1 @@\n-        assert(igvn != NULL, \"sanity check\");\n+        assert(igvn != nullptr, \"sanity check\");\n@@ -2511,1 +2511,1 @@\n-      Node *new_in = MemNode::optimize_memory_chain(ii, at, NULL, phase);\n+      Node *new_in = MemNode::optimize_memory_chain(ii, at, nullptr, phase);\n@@ -2522,1 +2522,1 @@\n-  if ((UseCompressedOops || UseCompressedClassPointers) && can_reshape && progress == NULL) {\n+  if ((UseCompressedOops || UseCompressedClassPointers) && can_reshape && progress == nullptr) {\n@@ -2552,1 +2552,1 @@\n-        Node* new_ii = NULL;\n+        Node* new_ii = nullptr;\n@@ -2589,1 +2589,1 @@\n-    ciInlineKlass* vk = NULL;\n+    ciInlineKlass* vk = nullptr;\n@@ -2613,1 +2613,1 @@\n-        if (n == NULL) {\n+        if (n == nullptr) {\n@@ -2618,1 +2618,1 @@\n-          if (n->in(0) != NULL && n->in(0)->is_top()) {\n+          if (n->in(0) != nullptr && n->in(0)->is_top()) {\n@@ -2627,2 +2627,2 @@\n-        if (n->is_InlineType() && (vk == NULL || vk == t->inline_klass())) {\n-          vk = (vk == NULL) ? t->inline_klass() : vk;\n+        if (n->is_InlineType() && (vk == nullptr || vk == t->inline_klass())) {\n+          vk = (vk == nullptr) ? t->inline_klass() : vk;\n@@ -2643,1 +2643,1 @@\n-    while (casts.size() != 0 && can_optimize && t != NULL) {\n+    while (casts.size() != 0 && can_optimize && t != nullptr) {\n@@ -2649,1 +2649,1 @@\n-    if (can_optimize && vk != NULL) {\n+    if (can_optimize && vk != nullptr) {\n@@ -2657,1 +2657,1 @@\n-  if (EnableVectorReboxing && can_reshape && progress == NULL && type()->isa_oopptr()) {\n+  if (EnableVectorReboxing && can_reshape && progress == nullptr && type()->isa_oopptr()) {\n@@ -2682,1 +2682,1 @@\n-      if (def == NULL) {\n+      if (def == nullptr) {\n@@ -2698,1 +2698,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2716,1 +2716,1 @@\n-  VectorBoxNode* cached_vbox = NULL;\n+  VectorBoxNode* cached_vbox = nullptr;\n@@ -2723,1 +2723,1 @@\n-      if (in == NULL) {\n+      if (in == nullptr) {\n@@ -2731,1 +2731,1 @@\n-        if (cached_vbox == NULL) {\n+        if (cached_vbox == nullptr) {\n@@ -2736,1 +2736,1 @@\n-          return NULL; \/\/ not optimizable: vector type mismatch\n+          return nullptr; \/\/ not optimizable: vector type mismatch\n@@ -2739,1 +2739,1 @@\n-          return NULL; \/\/ not optimizable: box type mismatch\n+          return nullptr; \/\/ not optimizable: box type mismatch\n@@ -2742,1 +2742,1 @@\n-        return NULL; \/\/ not optimizable: neither Phi nor VectorBox\n+        return nullptr; \/\/ not optimizable: neither Phi nor VectorBox\n@@ -2778,1 +2778,1 @@\n-  return (in(0) != NULL && in(0)->is_BaseCountedLoop() &&\n+  return (in(0) != nullptr && in(0)->is_BaseCountedLoop() &&\n@@ -2863,1 +2863,1 @@\n-  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+  return remove_dead_region(phase, can_reshape) ? this : nullptr;\n@@ -2900,1 +2900,1 @@\n-  \/\/ () virtual or interface call with NULL receiver\n+  \/\/ () virtual or interface call with null receiver\n@@ -2958,1 +2958,1 @@\n-  \/\/ a NULL receiver to a v-call, or passing bad types to a slow-check-cast.\n+  \/\/ a null receiver to a v-call, or passing bad types to a slow-check-cast.\n@@ -3027,1 +3027,1 @@\n-    if (fallthru != NULL) {\n+    if (fallthru != nullptr) {\n@@ -3032,1 +3032,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3047,1 +3047,1 @@\n-    if (n != NULL && OptoReg::is_valid(ra->get_reg_first(n))) {\n+    if (n != nullptr && OptoReg::is_valid(ra->get_reg_first(n))) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":217,"deletions":217,"binary":false,"changes":434,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    if (r == NULL)\n+    if (r == nullptr)\n@@ -105,1 +105,1 @@\n-    return NULL;  \/\/ not a copy!\n+    return nullptr;  \/\/ not a copy!\n@@ -107,2 +107,2 @@\n-  PhiNode* has_phi() const;        \/\/ returns an arbitrary phi user, or NULL\n-  PhiNode* has_unique_phi() const; \/\/ returns the unique phi user, or NULL\n+  PhiNode* has_phi() const;        \/\/ returns an arbitrary phi user, or null\n+  PhiNode* has_unique_phi() const; \/\/ returns the unique phi user, or null\n@@ -184,1 +184,1 @@\n-  PhiNode( Node *r, const Type *t, const TypePtr* at = NULL,\n+  PhiNode( Node *r, const Type *t, const TypePtr* at = nullptr,\n@@ -203,1 +203,1 @@\n-  static PhiNode* make( Node* r, Node* x, const Type *t, const TypePtr* at = NULL );\n+  static PhiNode* make( Node* r, Node* x, const Type *t, const TypePtr* at = nullptr );\n@@ -216,1 +216,1 @@\n-  \/\/ Ignore casts if it helps.  Return NULL on failure.\n+  \/\/ Ignore casts if it helps.  Return null on failure.\n@@ -220,1 +220,1 @@\n-    if (uin == NULL) {\n+    if (uin == nullptr) {\n@@ -431,1 +431,1 @@\n-  \/\/ Returns NULL is it couldn't improve the type.\n+  \/\/ Returns null is it couldn't improve the type.\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    if (_defs != NULL) {\n+    if (_defs != nullptr) {\n@@ -203,1 +203,1 @@\n-       NULL\n+       nullptr\n@@ -237,1 +237,1 @@\n-      buckets[i][j] = NULL;\n+      buckets[i][j] = nullptr;\n@@ -382,1 +382,1 @@\n-    _live = NULL;                 \/\/ Mark live as being not available\n+    _live = nullptr;              \/\/ Mark live as being not available\n@@ -400,1 +400,1 @@\n-    _live = NULL;\n+    _live = nullptr;\n@@ -439,1 +439,1 @@\n-    _live = NULL;\n+    _live = nullptr;\n@@ -477,1 +477,1 @@\n-      _live = NULL;\n+      _live = nullptr;\n@@ -547,1 +547,1 @@\n-      _live = NULL;\n+      _live = nullptr;\n@@ -625,1 +625,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -685,3 +685,3 @@\n-  _live = NULL;\n-  _ifg = NULL;\n-  C->set_indexSet_arena(NULL);  \/\/ ResourceArea is at end of scope\n+  _live = nullptr;\n+  _ifg = nullptr;\n+  C->set_indexSet_arena(nullptr);  \/\/ ResourceArea is at end of scope\n@@ -794,1 +794,1 @@\n-        if (trace_spilling() && lrg._def != NULL) {\n+        if (trace_spilling() && lrg._def != nullptr) {\n@@ -796,2 +796,2 @@\n-          if (lrg._defs == NULL) {\n-            lrg._defs = new (_ifg->_arena) GrowableArray<Node*>(_ifg->_arena, 2, 0, NULL);\n+          if (lrg._defs == nullptr) {\n+            lrg._defs = new (_ifg->_arena) GrowableArray<Node*>(_ifg->_arena, 2, 0, nullptr);\n@@ -805,1 +805,1 @@\n-        \/\/ via rematerialization.  Flag as NULL for no def found\n+        \/\/ via rematerialization.  Flag as null for no def found\n@@ -847,1 +847,1 @@\n-        assert(n_type->isa_vect() == NULL || lrg._is_vector ||\n+        assert(n_type->isa_vect() == nullptr || lrg._is_vector ||\n@@ -1066,1 +1066,1 @@\n-        assert(n->in(k)->bottom_type()->isa_vect() == NULL || is_vect ||\n+        assert(n->in(k)->bottom_type()->isa_vect() == nullptr || is_vect ||\n@@ -1095,1 +1095,1 @@\n-            (lrg._def == NULL || lrg.is_multidef() || !lrg._def->is_SpillCopy()) &&\n+            (lrg._def == nullptr || lrg.is_multidef() || !lrg._def->is_SpillCopy()) &&\n@@ -1780,1 +1780,1 @@\n-  \/\/ pointers derived from NULL!  These are always along paths that\n+  \/\/ pointers derived from null!  These are always along paths that\n@@ -1787,1 +1787,1 @@\n-  if (tj == NULL || tj->offset() == 0) {\n+  if (tj == nullptr || tj->offset() == 0) {\n@@ -1791,1 +1791,1 @@\n-  \/\/ Derived is NULL+offset?  Base is NULL!\n+  \/\/ Derived is null+offset?  Base is null!\n@@ -1794,2 +1794,2 @@\n-    assert(base != NULL, \"sanity\");\n-    if (base->in(0) == NULL) {\n+    assert(base != nullptr, \"sanity\");\n+    if (base->in(0) == nullptr) {\n@@ -1820,1 +1820,1 @@\n-    assert(base->in(0) == _cfg.get_root_node() && _cfg.get_block_for_node(base) == _cfg.get_block_for_node(C->top()), \"base NULL should be shared\");\n+    assert(base->in(0) == _cfg.get_root_node() && _cfg.get_block_for_node(base) == _cfg.get_block_for_node(C->top()), \"base null should be shared\");\n@@ -1869,1 +1869,1 @@\n-          !(phi->in(j)->is_Con() && base->in(j)->is_Con()) ) \/\/ allow different NULLs\n+          !(phi->in(j)->is_Con() && base->in(j)->is_Con()) ) \/\/ allow different nulls\n@@ -2431,1 +2431,1 @@\n-        if (jvms != NULL) {\n+        if (jvms != nullptr) {\n@@ -2455,1 +2455,1 @@\n-                    \/\/ Derived is NULL+non-zero offset, base must be NULL.\n+                    \/\/ Derived is null+non-zero offset, base must be null.\n@@ -2459,1 +2459,1 @@\n-                    \/\/ Base either ConP(NULL) or loadConP\n+                    \/\/ Base either ConP(nullptr) or loadConP\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  if (_mach_constant_base_node == NULL) {\n+  if (_mach_constant_base_node == nullptr) {\n@@ -157,1 +157,1 @@\n-    if (cg != NULL) {\n+    if (cg != nullptr) {\n@@ -165,1 +165,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -232,1 +232,1 @@\n-  if (xtty != NULL)  xtty->head(\"statistics type='intrinsic'\");\n+  if (xtty != nullptr)  xtty->head(\"statistics type='intrinsic'\");\n@@ -246,1 +246,1 @@\n-  if (xtty != NULL)  xtty->tail(\"statistics\");\n+  if (xtty != nullptr)  xtty->tail(\"statistics\");\n@@ -251,1 +251,1 @@\n-    if (xtty != NULL)  xtty->head(\"statistics type='opto'\");\n+    if (xtty != nullptr)  xtty->head(\"statistics type='opto'\");\n@@ -261,1 +261,1 @@\n-    if (xtty != NULL)  xtty->tail(\"statistics\");\n+    if (xtty != nullptr)  xtty->tail(\"statistics\");\n@@ -299,1 +299,1 @@\n-  useful.map( estimated_worklist_size, NULL );  \/\/ preallocate space\n+  useful.map( estimated_worklist_size, nullptr );  \/\/ preallocate space\n@@ -302,1 +302,1 @@\n-  if (root() != NULL)     { useful.push(root()); }\n+  if (root() != nullptr)  { useful.push(root()); }\n@@ -304,1 +304,1 @@\n-  if( cached_top_node() ) { useful.push(cached_top_node()); }\n+  if (cached_top_node())  { useful.push(cached_top_node()); }\n@@ -352,1 +352,1 @@\n-  assert(dead != NULL && dead->is_Call(), \"sanity\");\n+  assert(dead != nullptr && dead->is_Call(), \"sanity\");\n@@ -451,1 +451,1 @@\n-  if (_modified_nodes != NULL) {\n+  if (_modified_nodes != nullptr) {\n@@ -458,1 +458,1 @@\n-  if (_modified_nodes != NULL) {\n+  if (_modified_nodes != nullptr) {\n@@ -487,1 +487,1 @@\n-  assert(env->compiler_data() == NULL, \"compile already active?\");\n+  assert(env->compiler_data() == nullptr, \"compile already active?\");\n@@ -491,1 +491,1 @@\n-  compile->set_type_dict(NULL);\n+  compile->set_type_dict(nullptr);\n@@ -495,3 +495,3 @@\n-  compile->set_last_tf(NULL, NULL);\n-  compile->set_indexSet_arena(NULL);\n-  compile->set_indexSet_free_block_list(NULL);\n+  compile->set_last_tf(nullptr, nullptr);\n+  compile->set_indexSet_arena(nullptr);\n+  compile->set_indexSet_free_block_list(nullptr);\n@@ -508,1 +508,1 @@\n-  _compile->env()->set_compiler_data(NULL);\n+  _compile->env()->set_compiler_data(nullptr);\n@@ -571,1 +571,1 @@\n-  if (xtty != NULL) {\n+  if (xtty != nullptr) {\n@@ -586,1 +586,1 @@\n-  if (xtty != NULL) {\n+  if (xtty != nullptr) {\n@@ -607,4 +607,4 @@\n-                  _ilt(NULL),\n-                  _stub_function(NULL),\n-                  _stub_name(NULL),\n-                  _stub_entry_point(NULL),\n+                  _ilt(nullptr),\n+                  _stub_function(nullptr),\n+                  _stub_name(nullptr),\n+                  _stub_entry_point(nullptr),\n@@ -630,12 +630,12 @@\n-                  _failure_reason(NULL),\n-                  _intrinsics        (comp_arena(), 0, 0, NULL),\n-                  _macro_nodes       (comp_arena(), 8, 0, NULL),\n-                  _predicate_opaqs   (comp_arena(), 8, 0, NULL),\n-                  _skeleton_predicate_opaqs (comp_arena(), 8, 0, NULL),\n-                  _expensive_nodes   (comp_arena(), 8, 0, NULL),\n-                  _for_post_loop_igvn(comp_arena(), 8, 0, NULL),\n-                  _inline_type_nodes (comp_arena(), 8, 0, NULL),\n-                  _unstable_if_traps (comp_arena(), 8, 0, NULL),\n-                  _coarsened_locks   (comp_arena(), 8, 0, NULL),\n-                  _congraph(NULL),\n-                  NOT_PRODUCT(_igv_printer(NULL) COMMA)\n+                  _failure_reason(nullptr),\n+                  _intrinsics        (comp_arena(), 0, 0, nullptr),\n+                  _macro_nodes       (comp_arena(), 8, 0, nullptr),\n+                  _predicate_opaqs   (comp_arena(), 8, 0, nullptr),\n+                  _skeleton_predicate_opaqs (comp_arena(), 8, 0, nullptr),\n+                  _expensive_nodes   (comp_arena(), 8, 0, nullptr),\n+                  _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n+                  _inline_type_nodes (comp_arena(), 8, 0, nullptr),\n+                  _unstable_if_traps (comp_arena(), 8, 0, nullptr),\n+                  _coarsened_locks   (comp_arena(), 8, 0, nullptr),\n+                  _congraph(nullptr),\n+                  NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n@@ -646,1 +646,1 @@\n-                  _mach_constant_base_node(NULL),\n+                  _mach_constant_base_node(nullptr),\n@@ -648,6 +648,6 @@\n-                  _initial_gvn(NULL),\n-                  _for_igvn(NULL),\n-                  _late_inlines(comp_arena(), 2, 0, NULL),\n-                  _string_late_inlines(comp_arena(), 2, 0, NULL),\n-                  _boxing_late_inlines(comp_arena(), 2, 0, NULL),\n-                  _vector_reboxing_late_inlines(comp_arena(), 2, 0, NULL),\n+                  _initial_gvn(nullptr),\n+                  _for_igvn(nullptr),\n+                  _late_inlines(comp_arena(), 2, 0, nullptr),\n+                  _string_late_inlines(comp_arena(), 2, 0, nullptr),\n+                  _boxing_late_inlines(comp_arena(), 2, 0, nullptr),\n+                  _vector_reboxing_late_inlines(comp_arena(), 2, 0, nullptr),\n@@ -657,1 +657,1 @@\n-                  _print_inlining_list(NULL),\n+                  _print_inlining_list(nullptr),\n@@ -659,2 +659,2 @@\n-                  _print_inlining_output(NULL),\n-                  _replay_inline_data(NULL),\n+                  _print_inlining_output(nullptr),\n+                  _replay_inline_data(nullptr),\n@@ -664,1 +664,1 @@\n-                  _output(NULL)\n+                  _output(nullptr)\n@@ -680,1 +680,1 @@\n-  TraceTime t2(NULL, &_t_methodCompilation, CITime, false);\n+  TraceTime t2(nullptr, &_t_methodCompilation, CITime, false);\n@@ -740,1 +740,1 @@\n-    CallGenerator* cg = NULL;\n+    CallGenerator* cg = nullptr;\n@@ -761,1 +761,1 @@\n-      if (cg == NULL) {\n+      if (cg == nullptr) {\n@@ -768,1 +768,1 @@\n-    if (cg == NULL) {\n+    if (cg == nullptr) {\n@@ -776,1 +776,1 @@\n-    if ((jvms = cg->generate(jvms)) == NULL) {\n+    if ((jvms = cg->generate(jvms)) == nullptr) {\n@@ -820,1 +820,1 @@\n-  set_default_node_notes(NULL);\n+  set_default_node_notes(nullptr);\n@@ -840,1 +840,1 @@\n-    if (_log != NULL) {\n+    if (_log != nullptr) {\n@@ -865,1 +865,1 @@\n-  if (directive->DumpInlineOption && (ilt() != NULL)) {\n+  if (directive->DumpInlineOption && (ilt() != nullptr)) {\n@@ -905,1 +905,1 @@\n-    _method(NULL),\n+    _method(nullptr),\n@@ -909,1 +909,1 @@\n-    _stub_entry_point(NULL),\n+    _stub_entry_point(nullptr),\n@@ -928,3 +928,3 @@\n-    _failure_reason(NULL),\n-    _congraph(NULL),\n-    NOT_PRODUCT(_igv_printer(NULL) COMMA)\n+    _failure_reason(nullptr),\n+    _congraph(nullptr),\n+    NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n@@ -935,1 +935,1 @@\n-    _mach_constant_base_node(NULL),\n+    _mach_constant_base_node(nullptr),\n@@ -937,2 +937,2 @@\n-    _initial_gvn(NULL),\n-    _for_igvn(NULL),\n+    _initial_gvn(nullptr),\n+    _for_igvn(nullptr),\n@@ -941,1 +941,1 @@\n-    _print_inlining_list(NULL),\n+    _print_inlining_list(nullptr),\n@@ -943,2 +943,2 @@\n-    _print_inlining_output(NULL),\n-    _replay_inline_data(NULL),\n+    _print_inlining_output(nullptr),\n+    _replay_inline_data(nullptr),\n@@ -948,1 +948,1 @@\n-    _output(NULL),\n+    _output(nullptr),\n@@ -955,2 +955,2 @@\n-  TraceTime t1(NULL, &_t_totalCompilation, CITime, false);\n-  TraceTime t2(NULL, &_t_stubCompilation, CITime, false);\n+  TraceTime t1(nullptr, &_t_totalCompilation, CITime, false);\n+  TraceTime t2(nullptr, &_t_stubCompilation, CITime, false);\n@@ -992,1 +992,1 @@\n-  _regalloc = NULL;\n+  _regalloc = nullptr;\n@@ -994,4 +994,4 @@\n-  _tf      = NULL;  \/\/ filled in later\n-  _top     = NULL;  \/\/ cached later\n-  _matcher = NULL;  \/\/ filled in later\n-  _cfg     = NULL;  \/\/ filled in later\n+  _tf      = nullptr;  \/\/ filled in later\n+  _top     = nullptr;  \/\/ cached later\n+  _matcher = nullptr;  \/\/ filled in later\n+  _cfg     = nullptr;  \/\/ filled in later\n@@ -1001,3 +1001,3 @@\n-  _node_note_array = NULL;\n-  _default_node_notes = NULL;\n-  DEBUG_ONLY( _modified_nodes = NULL; ) \/\/ Used in Optimize()\n+  _node_note_array = nullptr;\n+  _default_node_notes = nullptr;\n+  DEBUG_ONLY( _modified_nodes = nullptr; ) \/\/ Used in Optimize()\n@@ -1005,1 +1005,1 @@\n-  _immutable_memory = NULL; \/\/ filled in at first inquiry\n+  _immutable_memory = nullptr; \/\/ filled in at first inquiry\n@@ -1010,1 +1010,1 @@\n-  _type_verify = NULL;\n+  _type_verify = nullptr;\n@@ -1014,2 +1014,2 @@\n-  \/\/ First set TOP to NULL to give safe behavior during creation of RootNode\n-  set_cached_top_node(NULL);\n+  \/\/ First set TOP to null to give safe behavior during creation of RootNode\n+  set_cached_top_node(nullptr);\n@@ -1019,1 +1019,1 @@\n-  set_recent_alloc(NULL, NULL);\n+  set_recent_alloc(nullptr, nullptr);\n@@ -1069,1 +1069,1 @@\n-  if (UseRTMLocking && has_method() && (method()->method_data_or_null() != NULL)) {\n+  if (UseRTMLocking && has_method() && (method()->method_data_or_null() != nullptr)) {\n@@ -1089,1 +1089,1 @@\n-                        (comp_arena(), 8, 0, NULL));\n+                        (comp_arena(), 8, 0, nullptr));\n@@ -1102,1 +1102,1 @@\n-  _alias_types[AliasIdxTop]->Init(AliasIdxTop, NULL);\n+  _alias_types[AliasIdxTop]->Init(AliasIdxTop, nullptr);\n@@ -1108,2 +1108,2 @@\n-  \/\/ A NULL adr_type hits in the cache right away.  Preload the right answer.\n-  probe_alias_cache(NULL)->_index = AliasIdxTop;\n+  \/\/ A null adr_type hits in the cache right away.  Preload the right answer.\n+  probe_alias_cache(nullptr)->_index = AliasIdxTop;\n@@ -1134,1 +1134,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1140,1 +1140,1 @@\n-  if (_immutable_memory != NULL) {\n+  if (_immutable_memory != nullptr) {\n@@ -1152,1 +1152,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1158,1 +1158,1 @@\n-  if (tn != NULL)  verify_top(tn);\n+  if (tn != nullptr)  verify_top(tn);\n@@ -1163,3 +1163,3 @@\n-  if (_top != NULL)     _top->setup_is_top();\n-  if (old_top != NULL)  old_top->setup_is_top();\n-  assert(_top == NULL || top()->is_top(), \"\");\n+  if (_top != nullptr)     _top->setup_is_top();\n+  if (old_top != nullptr)  old_top->setup_is_top();\n+  assert(_top == nullptr || top()->is_top(), \"\");\n@@ -1178,2 +1178,2 @@\n-  \/\/ Return if CompileLog is NULL and PrintIdealNodeCount is false.\n-  if ((_log == NULL) && (! PrintIdealNodeCount)) {\n+  \/\/ Return if CompileLog is null and PrintIdealNodeCount is false.\n+  if ((_log == nullptr) && (! PrintIdealNodeCount)) {\n@@ -1197,1 +1197,1 @@\n-    if (_log != NULL) {\n+    if (_log != nullptr) {\n@@ -1207,1 +1207,1 @@\n-          if (_log != NULL) {\n+          if (_log != nullptr) {\n@@ -1218,1 +1218,1 @@\n-        if (_log != NULL) {\n+        if (_log != nullptr) {\n@@ -1227,1 +1227,1 @@\n-    if (_log != NULL) {\n+    if (_log != nullptr) {\n@@ -1233,1 +1233,1 @@\n-  if (_modified_nodes != NULL && !_inlining_incrementally && !n->is_Con()) {\n+  if (_modified_nodes != nullptr && !_inlining_incrementally && !n->is_Con()) {\n@@ -1239,1 +1239,1 @@\n-  if (_modified_nodes != NULL) {\n+  if (_modified_nodes != nullptr) {\n@@ -1247,1 +1247,1 @@\n-  if (tn != NULL) {\n+  if (tn != nullptr) {\n@@ -1250,1 +1250,1 @@\n-    assert(tn->in(0) != NULL, \"must have live top node\");\n+    assert(tn->in(0) != nullptr, \"must have live top node\");\n@@ -1259,1 +1259,1 @@\n-  guarantee(arr != NULL, \"\");\n+  guarantee(arr != nullptr, \"\");\n@@ -1274,1 +1274,1 @@\n-  if (source == NULL || dest == NULL)  return false;\n+  if (source == nullptr || dest == nullptr)  return false;\n@@ -1281,1 +1281,1 @@\n-  if (dest != NULL && dest != source && dest->debug_orig() == NULL) {\n+  if (dest != nullptr && dest != source && dest->debug_orig() == nullptr) {\n@@ -1286,1 +1286,1 @@\n-  if (node_note_array() == NULL)\n+  if (node_note_array() == nullptr)\n@@ -1292,1 +1292,1 @@\n-  if (source_notes == NULL || source_notes->is_clear())  return false;\n+  if (source_notes == nullptr || source_notes->is_clear())  return false;\n@@ -1294,1 +1294,1 @@\n-  if (dest_notes == NULL || dest_notes->is_clear()) {\n+  if (dest_notes == nullptr || dest_notes->is_clear()) {\n@@ -1328,1 +1328,1 @@\n-  bool is_known_inst = tj->isa_oopptr() != NULL &&\n+  bool is_known_inst = tj->isa_oopptr() != nullptr &&\n@@ -1411,1 +1411,1 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,Type::Offset(offset), ta->field_offset());\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,Type::Offset(offset), ta->field_offset());\n@@ -1415,1 +1415,1 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,Type::Offset(offset), ta->field_offset());\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,Type::Offset(offset), ta->field_offset());\n@@ -1420,1 +1420,1 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,NULL,false,Type::Offset(offset), Type::Offset(Type::OffsetBot));\n+      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,nullptr,false,Type::Offset(offset), Type::Offset(Type::OffsetBot));\n@@ -1432,1 +1432,1 @@\n-    if (ptr == TypePtr::NotNull || ta->klass_is_exact() || ta->speculative() != NULL) {\n+    if (ptr == TypePtr::NotNull || ta->klass_is_exact() || ta->speculative() != nullptr) {\n@@ -1469,1 +1469,1 @@\n-    if (to->speculative() != NULL) {\n+    if (to->speculative() != nullptr) {\n@@ -1477,1 +1477,1 @@\n-        tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()->Object_klass(), false, NULL, Type::Offset(offset));\n+        tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()->Object_klass(), false, nullptr, Type::Offset(offset));\n@@ -1483,1 +1483,1 @@\n-        to = NULL;\n+        to = nullptr;\n@@ -1492,1 +1492,1 @@\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, NULL, Type::Offset(offset), to->instance_id());\n+          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, true, nullptr, Type::Offset(offset), to->instance_id());\n@@ -1494,1 +1494,1 @@\n-          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, NULL, Type::Offset(offset));\n+          tj = to = TypeInstPtr::make(to->ptr(), canonical_holder, false, nullptr, Type::Offset(offset));\n@@ -1570,2 +1570,2 @@\n-  _field = NULL;\n-  _element = NULL;\n+  _field = nullptr;\n+  _element = nullptr;\n@@ -1573,2 +1573,2 @@\n-  const TypeOopPtr *atoop = (at != NULL) ? at->isa_oopptr() : NULL;\n-  if (atoop != NULL && atoop->is_known_instance()) {\n+  const TypeOopPtr *atoop = (at != nullptr) ? at->isa_oopptr() : nullptr;\n+  if (atoop != nullptr && atoop->is_known_instance()) {\n@@ -1583,1 +1583,1 @@\n-  if (element() != NULL) {\n+  if (element() != nullptr) {\n@@ -1586,1 +1586,1 @@\n-  } if (field() != NULL) {\n+  } if (field() != nullptr) {\n@@ -1607,1 +1607,1 @@\n-  if (field() != NULL && tjp) {\n+  if (field() != nullptr && tjp) {\n@@ -1655,1 +1655,1 @@\n-  AliasCacheEntry* ace = NULL;\n+  AliasCacheEntry* ace = nullptr;\n@@ -1664,1 +1664,1 @@\n-  if (adr_type == NULL)             return alias_type(AliasIdxTop);\n+  if (adr_type == nullptr)          return alias_type(AliasIdxTop);\n@@ -1697,1 +1697,1 @@\n-    if (no_create)  return NULL;\n+    if (no_create)  return nullptr;\n@@ -1710,1 +1710,1 @@\n-    ciField* field = NULL;\n+    ciField* field = nullptr;\n@@ -1750,1 +1750,1 @@\n-      if (tinst->const_oop() != NULL &&\n+      if (tinst->const_oop() != nullptr &&\n@@ -1765,2 +1765,2 @@\n-    assert(field == NULL ||\n-           original_field == NULL ||\n+    assert(field == nullptr ||\n+           original_field == nullptr ||\n@@ -1771,1 +1771,1 @@\n-    if (field != NULL) {\n+    if (field != nullptr) {\n@@ -1789,1 +1789,1 @@\n-    if (face->_adr_type == NULL) {\n+    if (face->_adr_type == nullptr) {\n@@ -1820,1 +1820,1 @@\n-  if (adr_type == NULL)             return true;\n+  if (adr_type == nullptr)             return true;\n@@ -1823,1 +1823,1 @@\n-  return find_alias_type(adr_type, true, NULL) != NULL;\n+  return find_alias_type(adr_type, true, nullptr) != nullptr;\n@@ -1830,1 +1830,1 @@\n-  if (adr_type == NULL)                 return true;  \/\/ NULL serves as TypePtr::TOP\n+  if (adr_type == nullptr)              return true;  \/\/ null serves as TypePtr::TOP\n@@ -1848,1 +1848,1 @@\n-  if (adr_type == NULL)                 return false; \/\/ NULL serves as TypePtr::TOP\n+  if (adr_type == nullptr)              return false; \/\/ null serves as TypePtr::TOP\n@@ -1953,1 +1953,1 @@\n-    Node* ret = NULL;\n+    Node* ret = nullptr;\n@@ -1957,1 +1957,1 @@\n-        assert(ret == NULL, \"only one return\");\n+        assert(ret == nullptr, \"only one return\");\n@@ -1961,1 +1961,1 @@\n-    if (ret != NULL) {\n+    if (ret != nullptr) {\n@@ -2069,1 +2069,1 @@\n-      const TypePtr* adr_type = NULL;\n+      const TypePtr* adr_type = nullptr;\n@@ -2086,1 +2086,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -2100,1 +2100,1 @@\n-      if (ace->_adr_type != NULL &&\n+      if (ace->_adr_type != nullptr &&\n@@ -2102,2 +2102,2 @@\n-        ace->_adr_type = NULL;\n-        ace->_index = (i != 0) ? 0 : AliasIdxTop; \/\/ Make sure the NULL adr_type resolves to AliasIdxTop\n+        ace->_adr_type = nullptr;\n+        ace->_index = (i != 0) ? 0 : AliasIdxTop; \/\/ Make sure the nullptr adr_type resolves to AliasIdxTop\n@@ -2113,1 +2113,1 @@\n-      const TypePtr* adr_type = NULL;\n+      const TypePtr* adr_type = nullptr;\n@@ -2147,1 +2147,1 @@\n-      MergeMemNode* mm = NULL;\n+      MergeMemNode* mm = nullptr;\n@@ -2166,1 +2166,1 @@\n-            Node* place_holder = NULL;\n+            Node* place_holder = nullptr;\n@@ -2178,1 +2178,1 @@\n-                    if (place_holder == NULL) {\n+                    if (place_holder == nullptr) {\n@@ -2260,1 +2260,1 @@\n-                MemBarNode* mb = new MemBarCPUOrderNode(this, j, NULL);\n+                MemBarNode* mb = new MemBarCPUOrderNode(this, j, nullptr);\n@@ -2282,1 +2282,1 @@\n-              if (place_holder != NULL) {\n+              if (place_holder != nullptr) {\n@@ -2319,1 +2319,1 @@\n-        if (m != NULL) {\n+        if (m != nullptr) {\n@@ -2561,1 +2561,1 @@\n-        if (do_print_inlining || log() != NULL) {\n+        if (do_print_inlining || log() != nullptr) {\n@@ -2614,1 +2614,1 @@\n-  \/\/ Tracking and verification of modified nodes is disabled by setting \"_modified_nodes == NULL\"\n+  \/\/ Tracking and verification of modified nodes is disabled by setting \"_modified_nodes == nullptr\"\n@@ -2619,1 +2619,1 @@\n-  _modified_nodes = NULL;\n+  _modified_nodes = nullptr;\n@@ -2656,1 +2656,1 @@\n-  if (r != NULL) {\n+  if (r != nullptr) {\n@@ -2659,1 +2659,1 @@\n-      if (n != NULL && n->is_SafePoint()) {\n+      if (n != nullptr && n->is_SafePoint()) {\n@@ -2806,1 +2806,1 @@\n-      if (congraph() != NULL && macro_count() > 0) {\n+      if (congraph() != nullptr && macro_count() > 0) {\n@@ -2932,1 +2932,1 @@\n-  DEBUG_ONLY( _modified_nodes = NULL; )\n+  DEBUG_ONLY( _modified_nodes = nullptr; )\n@@ -3107,1 +3107,1 @@\n-  Node* mask = pn->is_predicated_vector() ? pn->in(pn->req()-1) : NULL;\n+  Node* mask = pn->is_predicated_vector() ? pn->in(pn->req()-1) : nullptr;\n@@ -3153,1 +3153,1 @@\n-  assert(n != NULL, \"\");\n+  assert(n != nullptr, \"\");\n@@ -3269,3 +3269,3 @@\n-  Node* parent_pred = parent_is_predicated ? n->in(n->req()-1) : NULL;\n-  Node* left_child_pred = left_child_predicated ? n->in(1)->in(n->in(1)->req()-1) : NULL;\n-  Node* right_child_pred = right_child_predicated ? n->in(1)->in(n->in(1)->req()-1) : NULL;\n+  Node* parent_pred = parent_is_predicated ? n->in(n->req()-1) : nullptr;\n+  Node* left_child_pred = left_child_predicated ? n->in(1)->in(n->in(1)->req()-1) : nullptr;\n+  Node* right_child_pred = right_child_predicated ? n->in(1)->in(n->in(1)->req()-1) : nullptr;\n@@ -3338,2 +3338,2 @@\n-    Node* mask = pn->is_predicated_vector() ? pn->in(pn->req()-1) : NULL;\n-    if (mask == NULL ||\n+    Node* mask = pn->is_predicated_vector() ? pn->in(pn->req()-1) : nullptr;\n+    if (mask == nullptr ||\n@@ -3541,1 +3541,1 @@\n-            if (mem->in(i) != NULL) {\n+            if (mem->in(i) != nullptr) {\n@@ -3595,1 +3595,1 @@\n-    assert( n->in(0) != NULL || alias_idx != Compile::AliasIdxRaw ||\n+    assert( n->in(0) != nullptr || alias_idx != Compile::AliasIdxRaw ||\n@@ -3800,2 +3800,2 @@\n-      bool is_oop   = t->isa_oopptr() != NULL;\n-      bool is_klass = t->isa_klassptr() != NULL;\n+      bool is_oop   = t->isa_oopptr() != nullptr;\n+      bool is_klass = t->isa_klassptr() != nullptr;\n@@ -3805,1 +3805,1 @@\n-        Node* nn = NULL;\n+        Node* nn = nullptr;\n@@ -3814,1 +3814,1 @@\n-          if (m!= NULL && m->Opcode() == op &&\n+          if (m!= nullptr && m->Opcode() == op &&\n@@ -3820,1 +3820,1 @@\n-        if (nn != NULL) {\n+        if (nn != nullptr) {\n@@ -3837,1 +3837,1 @@\n-                assert(out_j == NULL || !out_j->is_AddP() || out_j->in(AddPNode::Base) != addp,\n+                assert(out_j == nullptr || !out_j->is_AddP() || out_j->in(AddPNode::Base) != addp,\n@@ -3861,1 +3861,1 @@\n-    if (n->in(0) != NULL) {\n+    if (n->in(0) != nullptr) {\n@@ -3896,1 +3896,1 @@\n-        \/\/ a narrow oop directly and do implicit NULL check in address:\n+        \/\/ a narrow oop directly and do implicit null check in address:\n@@ -3902,1 +3902,1 @@\n-        \/\/ use it to do implicit NULL check in address:\n+        \/\/ use it to do implicit null check in address:\n@@ -3909,1 +3909,1 @@\n-        \/\/ to keep the information to which NULL check the new DecodeN node\n+        \/\/ to keep the information to which null check the new DecodeN node\n@@ -3940,1 +3940,1 @@\n-      Node* new_in2 = NULL;\n+      Node* new_in2 = nullptr;\n@@ -3955,1 +3955,1 @@\n-          \/\/ will generated code for implicit NULL checks for compressed oops.\n+          \/\/ will generated code for implicit null checks for compressed oops.\n@@ -3961,1 +3961,1 @@\n-          \/\/    CmpP base_reg, NULL\n+          \/\/    CmpP base_reg, nullptr\n@@ -3968,1 +3968,1 @@\n-          \/\/    CmpN narrow_oop_reg, NULL\n+          \/\/    CmpN narrow_oop_reg, nullptr\n@@ -3972,1 +3972,1 @@\n-          \/\/ and the uncommon path (== NULL) will use narrow_oop_reg directly\n+          \/\/ and the uncommon path (== nullptr) will use narrow_oop_reg directly\n@@ -3996,1 +3996,1 @@\n-      if (new_in2 != NULL) {\n+      if (new_in2 != nullptr) {\n@@ -4014,1 +4014,1 @@\n-    assert(n->in(0) == NULL || (UseCompressedOops && !Matcher::narrow_oop_use_complex_address()), \"no control\");\n+    assert(n->in(0) == nullptr || (UseCompressedOops && !Matcher::narrow_oop_use_complex_address()), \"no control\");\n@@ -4049,1 +4049,1 @@\n-        if (non_io_proj  != NULL) {\n+        if (non_io_proj  != nullptr) {\n@@ -4062,1 +4062,1 @@\n-      assert(unique_in != NULL, \"\");\n+      assert(unique_in != nullptr, \"\");\n@@ -4066,1 +4066,1 @@\n-        assert(m != NULL, \"\");\n+        assert(m != nullptr, \"\");\n@@ -4068,1 +4068,1 @@\n-          unique_in = NULL;\n+          unique_in = nullptr;\n@@ -4070,1 +4070,1 @@\n-      if (unique_in != NULL) {\n+      if (unique_in != nullptr) {\n@@ -4230,1 +4230,1 @@\n-      if (t != NULL && t->is_con()) {\n+      if (t != nullptr && t->is_con()) {\n@@ -4236,1 +4236,1 @@\n-        if (t == NULL || t->_lo < 0 || t->_hi > (int)mask) {\n+        if (t == nullptr || t->_lo < 0 || t->_hi > (int)mask) {\n@@ -4290,1 +4290,1 @@\n-          if (k == NULL) {\n+          if (k == nullptr) {\n@@ -4354,2 +4354,2 @@\n-      if (m != NULL && !frc._visited.test_set(m->_idx)) {\n-        if (m->is_SafePoint() && m->as_SafePoint()->jvms() != NULL) {\n+      if (m != nullptr && !frc._visited.test_set(m->_idx)) {\n+        if (m->is_SafePoint() && m->as_SafePoint()->jvms() != nullptr) {\n@@ -4389,1 +4389,1 @@\n-    assert(jvms != NULL, \"sanity\");\n+    assert(jvms != nullptr, \"sanity\");\n@@ -4460,1 +4460,1 @@\n-    _expensive_nodes.at(i)->set_req(0, NULL);\n+    _expensive_nodes.at(i)->set_req(0, nullptr);\n@@ -4553,1 +4553,1 @@\n-        if (in != NULL) {\n+        if (in != nullptr) {\n@@ -4591,1 +4591,1 @@\n-  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this->method() : NULL;\n+  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this->method() : nullptr;\n@@ -4614,1 +4614,1 @@\n-      int mcount = (logmd == NULL)? -1: (int)logmd->trap_count(reason);\n+      int mcount = (logmd == nullptr)? -1: (int)logmd->trap_count(reason);\n@@ -4645,1 +4645,1 @@\n-  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this->method() : NULL;\n+  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this->method() : nullptr;\n@@ -4749,1 +4749,1 @@\n-      if (in != NULL && !visited.member(in)) {\n+      if (in != nullptr && !visited.member(in)) {\n@@ -4752,1 +4752,1 @@\n-      if (in != NULL && !in->is_top()) {\n+      if (in != nullptr && !in->is_top()) {\n@@ -4769,1 +4769,1 @@\n-      } else if (in == NULL) {\n+      } else if (in == nullptr) {\n@@ -4829,1 +4829,1 @@\n-  if (log() != NULL) {\n+  if (log() != nullptr) {\n@@ -4832,1 +4832,1 @@\n-  if (_failure_reason == NULL) {\n+  if (_failure_reason == nullptr) {\n@@ -4840,1 +4840,1 @@\n-  _root = NULL;  \/\/ flush the graph, too\n+  _root = nullptr;  \/\/ flush the graph, too\n@@ -4851,2 +4851,2 @@\n-    C = NULL;\n-    _log = NULL;\n+    C = nullptr;\n+    _log = nullptr;\n@@ -4854,1 +4854,1 @@\n-  if (_log != NULL) {\n+  if (_log != nullptr) {\n@@ -4867,1 +4867,1 @@\n-    _log = NULL;\n+    _log = nullptr;\n@@ -4881,1 +4881,1 @@\n-  if (_log != NULL) {\n+  if (_log != nullptr) {\n@@ -4952,1 +4952,1 @@\n-  if (sizetype != NULL) index_max = sizetype->_hi - 1;\n+  if (sizetype != nullptr) index_max = sizetype->_hi - 1;\n@@ -4961,1 +4961,1 @@\n-  if (ctrl != NULL) {\n+  if (ctrl != nullptr) {\n@@ -5023,1 +5023,1 @@\n-          (print_inlining_current()->cg() != NULL ||\n+          (print_inlining_current()->cg() != nullptr ||\n@@ -5030,1 +5030,1 @@\n-      if (print_inlining_current()->cg() != NULL) {\n+      if (print_inlining_current()->cg() != nullptr) {\n@@ -5072,1 +5072,1 @@\n-    assert(_print_inlining_list != NULL, \"process_print_inlining should be called only once.\");\n+    assert(_print_inlining_list != nullptr, \"process_print_inlining should be called only once.\");\n@@ -5077,1 +5077,1 @@\n-      DEBUG_ONLY(_print_inlining_list->at_put(i, NULL));\n+      DEBUG_ONLY(_print_inlining_list->at_put(i, nullptr));\n@@ -5081,1 +5081,1 @@\n-    _print_inlining_list = NULL;\n+    _print_inlining_list = nullptr;\n@@ -5092,1 +5092,1 @@\n-  if (_print_inlining_output != NULL) {\n+  if (_print_inlining_output != nullptr) {\n@@ -5098,1 +5098,1 @@\n-  if (log() != NULL) {\n+  if (log() != nullptr) {\n@@ -5102,1 +5102,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n@@ -5112,1 +5112,1 @@\n-  if (log() != NULL) {\n+  if (log() != nullptr) {\n@@ -5118,1 +5118,1 @@\n-  if (log() != NULL) {\n+  if (log() != nullptr) {\n@@ -5133,1 +5133,1 @@\n-  if (C->log() != NULL) {\n+  if (C->log() != nullptr) {\n@@ -5143,1 +5143,1 @@\n-  if (inl_tree != NULL) {\n+  if (inl_tree != nullptr) {\n@@ -5153,1 +5153,1 @@\n-  if (inl_tree == NULL) {\n+  if (inl_tree == nullptr) {\n@@ -5273,1 +5273,1 @@\n-      igvn.replace_input_of(n, 0, NULL);\n+      igvn.replace_input_of(n, 0, nullptr);\n@@ -5282,1 +5282,1 @@\n-    igvn.replace_input_of(n, 0, NULL);\n+    igvn.replace_input_of(n, 0, nullptr);\n@@ -5301,1 +5301,1 @@\n-    n->set_req(0, NULL);\n+    n->set_req(0, nullptr);\n@@ -5449,1 +5449,1 @@\n-      assert((t == NULL) || (t == t->remove_speculative()), \"no more speculative types\");\n+      assert((t == nullptr) || (t == t->remove_speculative()), \"no more speculative types\");\n@@ -5471,1 +5471,1 @@\n-  if (!EnableValhalla || ta == NULL || tb == NULL ||\n+  if (!EnableValhalla || ta == nullptr || tb == nullptr ||\n@@ -5478,1 +5478,1 @@\n-    \/\/ new acmp will only return true if both operands are NULL.\n+    \/\/ new acmp will only return true if both operands are nullptr.\n@@ -5480,2 +5480,2 @@\n-    a = phase->transform(new CastP2XNode(NULL, a));\n-    b = phase->transform(new CastP2XNode(NULL, b));\n+    a = phase->transform(new CastP2XNode(nullptr, a));\n+    b = phase->transform(new CastP2XNode(nullptr, b));\n@@ -5486,1 +5486,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -5632,1 +5632,1 @@\n-  if (_method != NULL && should_print_igv(1)) {\n+  if (_method != nullptr && should_print_igv(1)) {\n@@ -5647,1 +5647,1 @@\n-  if (_method != NULL && should_print_igv(1)) {\n+  if (_method != nullptr && should_print_igv(1)) {\n@@ -5680,2 +5680,2 @@\n-IdealGraphPrinter* Compile::_debug_file_printer = NULL;\n-IdealGraphPrinter* Compile::_debug_network_printer = NULL;\n+IdealGraphPrinter* Compile::_debug_file_printer = nullptr;\n+IdealGraphPrinter* Compile::_debug_network_printer = nullptr;\n@@ -5733,1 +5733,1 @@\n-  if (_debug_file_printer == NULL) {\n+  if (_debug_file_printer == nullptr) {\n@@ -5743,1 +5743,1 @@\n-  if (_debug_network_printer == NULL) {\n+  if (_debug_network_printer == nullptr) {\n@@ -5754,1 +5754,1 @@\n-  if (type != NULL && phase->type(value)->higher_equal(type)) {\n+  if (type != nullptr && phase->type(value)->higher_equal(type)) {\n@@ -5757,1 +5757,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":248,"deletions":248,"binary":false,"changes":496,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  void insert(node_idx_t key, uint64_t val)      { assert(_dict->operator[](_2p(key)) == NULL, \"key existed\"); _dict->Insert(_2p(key), (void*)val); }\n+  void insert(node_idx_t key, uint64_t val)      { assert(_dict->operator[](_2p(key)) == nullptr, \"key existed\"); _dict->Insert(_2p(key), (void*)val); }\n@@ -221,1 +221,1 @@\n-  \/\/ Variant of TraceTime(NULL, &_t_accumulator, CITime);\n+  \/\/ Variant of TraceTime(nullptr, &_t_accumulator, CITime);\n@@ -270,1 +270,1 @@\n-      assert(_element == NULL, \"\");\n+      assert(_element == nullptr, \"\");\n@@ -296,3 +296,3 @@\n-  address               _stub_function;         \/\/ VM entry for stub being compiled, or NULL\n-  const char*           _stub_name;             \/\/ Name of stub or adapter being compiled, or NULL\n-  address               _stub_entry_point;      \/\/ Compile code entry for generated stub, or NULL\n+  address               _stub_function;         \/\/ VM entry for stub being compiled, or null\n+  const char*           _stub_name;             \/\/ Name of stub or adapter being compiled, or null\n+  address               _stub_entry_point;      \/\/ Compile code entry for generated stub, or null\n@@ -386,1 +386,1 @@\n-  RootNode*             _root;                  \/\/ Unique root of compilation, or NULL after bail-out.\n+  RootNode*             _root;                  \/\/ Unique root of compilation, or null after bail-out.\n@@ -447,1 +447,1 @@\n-      : _cg(NULL), _ss(default_stream_buffer_size) {}\n+      : _cg(nullptr), _ss(default_stream_buffer_size) {}\n@@ -494,1 +494,1 @@\n-  void print_inlining(ciMethod* method, int inline_level, int bci, const char* msg = NULL) {\n+  void print_inlining(ciMethod* method, int inline_level, int bci, const char* msg = nullptr) {\n@@ -564,3 +564,3 @@\n-  bool              is_method_compilation() const { return (_method != NULL && !_method->flags().is_native()); }\n-  const TypeFunc*   tf() const                  { assert(_tf!=NULL, \"\"); return _tf; }\n-  void         init_tf(const TypeFunc* tf)      { assert(_tf==NULL, \"\"); _tf = tf; }\n+  bool              is_method_compilation() const { return (_method != nullptr && !_method->flags().is_native()); }\n+  const TypeFunc*   tf() const                  { assert(_tf!=nullptr, \"\"); return _tf; }\n+  void         init_tf(const TypeFunc* tf)      { assert(_tf==nullptr, \"\"); _tf = tf; }\n@@ -647,2 +647,2 @@\n-  bool              has_scalarized_args() const  { return _method != NULL && _method->has_scalarized_args(); }\n-  bool              needs_stack_repair()  const  { return _method != NULL && _method->get_Method()->c2_needs_stack_repair(); }\n+  bool              has_scalarized_args() const  { return _method != nullptr && _method->has_scalarized_args(); }\n+  bool              needs_stack_repair()  const  { return _method != nullptr && _method->get_Method()->c2_needs_stack_repair(); }\n@@ -655,1 +655,1 @@\n-    return method() != NULL && method()->has_option(option);\n+    return method() != nullptr && method()->has_option(option);\n@@ -783,1 +783,1 @@\n-  bool        failing() const        { return _env->failing() || _failure_reason != NULL; }\n+  bool        failing() const        { return _env->failing() || _failure_reason != nullptr; }\n@@ -787,1 +787,1 @@\n-    return (r == _failure_reason) || (r != NULL && _failure_reason != NULL && strcmp(r, _failure_reason) == 0);\n+    return (r == _failure_reason) || (r != nullptr && _failure_reason != nullptr && strcmp(r, _failure_reason) == 0);\n@@ -849,1 +849,1 @@\n-  bool                  has_mach_constant_base_node() const { return _mach_constant_base_node != NULL; }\n+  bool                  has_mach_constant_base_node() const { return _mach_constant_base_node != nullptr; }\n@@ -893,1 +893,1 @@\n-    return (m == _last_tf_m) ? _last_tf : NULL;\n+    return (m == _last_tf_m) ? _last_tf : nullptr;\n@@ -896,1 +896,1 @@\n-    assert(m != NULL || tf == NULL, \"\");\n+    assert(m != nullptr || tf == nullptr, \"\");\n@@ -902,1 +902,1 @@\n-  AliasType*        alias_type(const TypePtr* adr_type, ciField* field = NULL, bool uncached = false) { return find_alias_type(adr_type, false, field, uncached); }\n+  AliasType*        alias_type(const TypePtr* adr_type, ciField* field = nullptr, bool uncached = false) { return find_alias_type(adr_type, false, field, uncached); }\n@@ -906,1 +906,1 @@\n-  int               get_alias_index(const TypePtr* at, bool uncached = false) { return alias_type(at, NULL, uncached)->index(); }\n+  int               get_alias_index(const TypePtr* at, bool uncached = false) { return alias_type(at, nullptr, uncached)->index(); }\n@@ -918,1 +918,1 @@\n-                                   JVMState* jvms, bool allow_inline, float profile_factor, ciKlass* speculative_receiver_type = NULL,\n+                                   JVMState* jvms, bool allow_inline, float profile_factor, ciKlass* speculative_receiver_type = nullptr,\n@@ -948,1 +948,1 @@\n-                      ciMethodData* logmd = NULL);\n+                      ciMethodData* logmd = nullptr);\n@@ -1090,1 +1090,1 @@\n-  bool has_method() { return method() != NULL; }\n+  bool has_method() { return method() != nullptr; }\n@@ -1209,1 +1209,1 @@\n-                              Node* ctrl = NULL);\n+                              Node* ctrl = nullptr);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -53,1 +53,1 @@\n-  if( tp != NULL ) {\n+  if(tp != nullptr) {\n@@ -73,1 +73,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -99,1 +99,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -126,1 +126,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -162,1 +162,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -179,5 +179,3 @@\n-  if( t == Type::TOP ) return Type::TOP;\n-  if( t == Type::FLOAT ) return TypeInt::SHORT;\n-  const TypeF *tf = t->is_float_constant();\n-  return TypeInt::make( SharedRuntime::f2hf( tf->getf() ) );\n-}\n+  if (t == Type::TOP) return Type::TOP;\n+  if (t == Type::FLOAT) return TypeInt::SHORT;\n+  if (StubRoutines::f2hf_adr() == nullptr) return bottom_type();\n@@ -185,3 +183,2 @@\n-\/\/------------------------------Identity---------------------------------------\n-Node* ConvF2HFNode::Identity(PhaseGVN* phase) {\n-  return (in(1)->Opcode() == Op_ConvHF2F) ? in(1)->in(1) : this;\n+  const TypeF *tf = t->is_float_constant();\n+  return TypeInt::make( StubRoutines::f2hf(tf->getf()) );\n@@ -216,1 +213,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -245,1 +242,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -252,4 +249,3 @@\n-  if( t == Type::TOP ) return Type::TOP;\n-  if( t == TypeInt::SHORT ) return Type::FLOAT;\n-  const TypeInt *ti = t->is_int();\n-  if ( ti->is_con() ) return TypeF::make( SharedRuntime::hf2f( ti->get_con() ) );\n+  if (t == Type::TOP) return Type::TOP;\n+  if (t == TypeInt::SHORT) return Type::FLOAT;\n+  if (StubRoutines::hf2f_adr() == nullptr) return bottom_type();\n@@ -257,0 +253,4 @@\n+  const TypeInt *ti = t->is_int();\n+  if (ti->is_con()) {\n+    return TypeF::make( StubRoutines::hf2f(ti->get_con()) );\n+  }\n@@ -307,1 +307,1 @@\n-    if (in_type != NULL &&\n+    if (in_type != nullptr &&\n@@ -585,1 +585,1 @@\n-  if (existing != NULL) {\n+  if (existing != nullptr) {\n@@ -650,2 +650,2 @@\n-  const TypeInteger* rx = NULL;\n-  const TypeInteger* ry = NULL;\n+  const TypeInteger* rx = nullptr;\n+  const TypeInteger* ry = nullptr;\n@@ -653,1 +653,1 @@\n-    if (igvn == NULL) {\n+    if (igvn == nullptr) {\n@@ -657,1 +657,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -673,1 +673,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -738,1 +738,1 @@\n-    if (andl->outcnt() > 1) return NULL;\n+    if (andl->outcnt() > 1) return nullptr;\n@@ -743,2 +743,2 @@\n-    if (phase->type(x) == Type::TOP)  return NULL;\n-    if (phase->type(y) == Type::TOP)  return NULL;\n+    if (phase->type(x) == Type::TOP)  return nullptr;\n+    if (phase->type(y) == Type::TOP)  return nullptr;\n@@ -753,1 +753,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-\/\/ Return NULL if no transformation occurs.\n+\/\/ Return null if no transformation occurs.\n@@ -104,1 +104,1 @@\n-  Node *q = NULL;\n+  Node *q = nullptr;\n@@ -337,1 +337,1 @@\n-\/\/ Return NULL if no transformation occurs.\n+\/\/ Return null if no transformation occurs.\n@@ -348,1 +348,1 @@\n-  Node *q = NULL;\n+  Node *q = nullptr;\n@@ -463,1 +463,1 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n@@ -466,2 +466,2 @@\n-  if( t == TypeInt::ONE )       \/\/ Identity?\n-    return NULL;                \/\/ Skip it\n+  if( t == TypeInt::ONE )      \/\/ Identity?\n+    return nullptr;            \/\/ Skip it\n@@ -470,1 +470,1 @@\n-  if( !ti ) return NULL;\n+  if( !ti ) return nullptr;\n@@ -475,1 +475,1 @@\n-    set_req(0, NULL);           \/\/ Yank control input\n+    set_req(0, nullptr);           \/\/ Yank control input\n@@ -479,1 +479,1 @@\n-  if( !ti->is_con() ) return NULL;\n+  if( !ti->is_con() ) return nullptr;\n@@ -482,1 +482,1 @@\n-  if (i == 0) return NULL;      \/\/ Dividing by zero constant does not idealize\n+  if (i == 0) return nullptr;   \/\/ Dividing by zero constant does not idealize\n@@ -485,1 +485,1 @@\n-  if( i == min_jint ) return NULL;\n+  if( i == min_jint ) return nullptr;\n@@ -569,1 +569,1 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n@@ -573,1 +573,1 @@\n-    return NULL;                \/\/ Skip it\n+    return nullptr;             \/\/ Skip it\n@@ -576,1 +576,1 @@\n-  if( !tl ) return NULL;\n+  if( !tl ) return nullptr;\n@@ -581,1 +581,1 @@\n-    set_req(0, NULL);           \/\/ Yank control input\n+    set_req(0, nullptr);         \/\/ Yank control input\n@@ -585,1 +585,1 @@\n-  if( !tl->is_con() ) return NULL;\n+  if( !tl->is_con() ) return nullptr;\n@@ -588,1 +588,1 @@\n-  if (l == 0) return NULL;      \/\/ Dividing by zero constant does not idealize\n+  if (l == 0) return nullptr;   \/\/ Dividing by zero constant does not idealize\n@@ -591,1 +591,1 @@\n-  if( l == min_jlong ) return NULL;\n+  if( l == min_jlong ) return nullptr;\n@@ -720,1 +720,1 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n@@ -724,1 +724,1 @@\n-    return NULL;                \/\/ Skip it\n+    return nullptr;              \/\/ Skip it\n@@ -727,2 +727,2 @@\n-  if( !tf ) return NULL;\n-  if( tf->base() != Type::FloatCon ) return NULL;\n+  if( !tf ) return nullptr;\n+  if( tf->base() != Type::FloatCon ) return nullptr;\n@@ -731,1 +731,1 @@\n-  if( tf->is_nan() || !tf->is_finite() ) return NULL;\n+  if( tf->is_nan() || !tf->is_finite() ) return nullptr;\n@@ -738,1 +738,1 @@\n-  if( frexp((double)f, &exp) != 0.5 ) return NULL;\n+  if( frexp((double)f, &exp) != 0.5 ) return nullptr;\n@@ -741,1 +741,1 @@\n-  if( exp < -126 || exp > 126 ) return NULL;\n+  if( exp < -126 || exp > 126 ) return nullptr;\n@@ -812,1 +812,1 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n@@ -816,1 +816,1 @@\n-    return NULL;                \/\/ Skip it\n+    return nullptr;              \/\/ Skip it\n@@ -819,2 +819,2 @@\n-  if( !td ) return NULL;\n-  if( td->base() != Type::DoubleCon ) return NULL;\n+  if( !td ) return nullptr;\n+  if( td->base() != Type::DoubleCon ) return nullptr;\n@@ -823,1 +823,1 @@\n-  if( td->is_nan() || !td->is_finite() ) return NULL;\n+  if( td->is_nan() || !td->is_finite() ) return nullptr;\n@@ -830,1 +830,1 @@\n-  if( frexp(d, &exp) != 0.5 ) return NULL;\n+  if( frexp(d, &exp) != 0.5 ) return nullptr;\n@@ -833,1 +833,1 @@\n-  if( exp < -1021 || exp > 1022 ) return NULL;\n+  if( exp < -1021 || exp > 1022 ) return nullptr;\n@@ -879,1 +879,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -918,1 +918,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -928,1 +928,1 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n@@ -932,1 +932,1 @@\n-  if( t == Type::TOP ) return NULL;\n+  if( t == Type::TOP ) return nullptr;\n@@ -938,1 +938,1 @@\n-    set_req(0, NULL);        \/\/ Yank control input\n+    set_req(0, nullptr);        \/\/ Yank control input\n@@ -943,1 +943,1 @@\n-  if( !ti->is_con() ) return NULL;\n+  if( !ti->is_con() ) return nullptr;\n@@ -996,1 +996,1 @@\n-  if( con == 0 || con == min_jint ) return NULL;\n+  if( con == 0 || con == min_jint ) return nullptr;\n@@ -1023,1 +1023,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1027,1 +1027,1 @@\n-    Node *mult = NULL;\n+    Node *mult = nullptr;\n@@ -1091,1 +1091,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1100,1 +1100,1 @@\n-  if( in(0) && in(0)->is_top() )  return NULL;\n+  if( in(0) && in(0)->is_top() )  return nullptr;\n@@ -1104,1 +1104,1 @@\n-  if( t == Type::TOP ) return NULL;\n+  if( t == Type::TOP ) return nullptr;\n@@ -1110,1 +1110,1 @@\n-    set_req(0, NULL);        \/\/ Yank control input\n+    set_req(0, nullptr);        \/\/ Yank control input\n@@ -1115,1 +1115,1 @@\n-  if( !tl->is_con() ) return NULL;\n+  if( !tl->is_con() ) return nullptr;\n@@ -1170,1 +1170,1 @@\n-  if( con == 0 || con == min_jlong ) return NULL;\n+  if( con == 0 || con == min_jlong ) return nullptr;\n@@ -1197,1 +1197,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1201,1 +1201,1 @@\n-    Node *mult = NULL;\n+    Node *mult = nullptr;\n@@ -1309,1 +1309,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,1 +199,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) { return NULL; }\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape) { return nullptr; }\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  assert(callee != NULL, \"failed method resolution\");\n+  assert(callee != nullptr, \"failed method resolution\");\n@@ -107,1 +107,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -129,1 +129,1 @@\n-  CallGenerator* cg_intrinsic = NULL;\n+  CallGenerator* cg_intrinsic = nullptr;\n@@ -132,1 +132,1 @@\n-    if (cg != NULL) {\n+    if (cg != nullptr) {\n@@ -137,1 +137,1 @@\n-        if (inline_cg != NULL) {\n+        if (inline_cg != nullptr) {\n@@ -147,1 +147,1 @@\n-        cg = NULL;\n+        cg = nullptr;\n@@ -185,1 +185,1 @@\n-        if (cg != NULL && is_virtual_or_interface && !callee->is_static()) {\n+        if (cg != nullptr && is_virtual_or_interface && !callee->is_static()) {\n@@ -191,1 +191,1 @@\n-        if (cg != NULL) {\n+        if (cg != nullptr) {\n@@ -214,1 +214,1 @@\n-      ciMethod* receiver_method = NULL;\n+      ciMethod* receiver_method = nullptr;\n@@ -217,1 +217,1 @@\n-      if (speculative_receiver_type != NULL) {\n+      if (speculative_receiver_type != nullptr) {\n@@ -225,2 +225,2 @@\n-          if (receiver_method == NULL) {\n-            speculative_receiver_type = NULL;\n+          if (receiver_method == nullptr) {\n+            speculative_receiver_type = nullptr;\n@@ -233,1 +233,1 @@\n-          speculative_receiver_type = NULL;\n+          speculative_receiver_type = nullptr;\n@@ -236,1 +236,1 @@\n-      if (receiver_method == NULL &&\n+      if (receiver_method == nullptr &&\n@@ -244,1 +244,1 @@\n-      if (receiver_method != NULL) {\n+      if (receiver_method != nullptr) {\n@@ -248,1 +248,1 @@\n-        if (hit_cg != NULL) {\n+        if (hit_cg != nullptr) {\n@@ -250,2 +250,2 @@\n-          CallGenerator* next_hit_cg = NULL;\n-          ciMethod* next_receiver_method = NULL;\n+          CallGenerator* next_hit_cg = nullptr;\n+          ciMethod* next_receiver_method = nullptr;\n@@ -255,1 +255,1 @@\n-            if (next_receiver_method != NULL) {\n+            if (next_receiver_method != nullptr) {\n@@ -259,1 +259,1 @@\n-              if (next_hit_cg != NULL && !next_hit_cg->is_inline() &&\n+              if (next_hit_cg != nullptr && !next_hit_cg->is_inline() &&\n@@ -262,1 +262,1 @@\n-                  next_hit_cg = NULL;\n+                  next_hit_cg = nullptr;\n@@ -269,2 +269,2 @@\n-                                               : Deoptimization::reason_class_check(speculative_receiver_type != NULL));\n-          if ((morphism == 1 || (morphism == 2 && next_hit_cg != NULL)) &&\n+                                               : Deoptimization::reason_class_check(speculative_receiver_type != nullptr));\n+          if ((morphism == 1 || (morphism == 2 && next_hit_cg != nullptr)) &&\n@@ -283,3 +283,3 @@\n-          if (miss_cg != NULL) {\n-            if (next_hit_cg != NULL) {\n-              assert(speculative_receiver_type == NULL, \"shouldn't end up here if we used speculation\");\n+          if (miss_cg != nullptr) {\n+            if (next_hit_cg != nullptr) {\n+              assert(speculative_receiver_type == nullptr, \"shouldn't end up here if we used speculation\");\n@@ -291,2 +291,2 @@\n-            if (miss_cg != NULL) {\n-              ciKlass* k = speculative_receiver_type != NULL ? speculative_receiver_type : profile.receiver(0);\n+            if (miss_cg != nullptr) {\n+              ciKlass* k = speculative_receiver_type != nullptr ? speculative_receiver_type : profile.receiver(0);\n@@ -294,1 +294,1 @@\n-              float hit_prob = speculative_receiver_type != NULL ? 1.0 : profile.receiver_prob(0);\n+              float hit_prob = speculative_receiver_type != nullptr ? 1.0 : profile.receiver_prob(0);\n@@ -296,1 +296,1 @@\n-              if (cg != NULL)  return cg;\n+              if (cg != nullptr)  return cg;\n@@ -322,1 +322,1 @@\n-      if (singleton != NULL) {\n+      if (singleton != nullptr) {\n@@ -328,1 +328,1 @@\n-        if (cha_monomorphic_target != NULL &&\n+        if (cha_monomorphic_target != nullptr &&\n@@ -342,1 +342,1 @@\n-          if (hit_cg != NULL && cg != NULL) {\n+          if (hit_cg != nullptr && cg != nullptr) {\n@@ -353,1 +353,1 @@\n-    if (allow_intrinsics && cg_intrinsic != NULL) {\n+    if (allow_intrinsics && cg_intrinsic != nullptr) {\n@@ -377,1 +377,1 @@\n-    if (cg != NULL && is_virtual_or_interface && !callee->is_static()) {\n+    if (cg != nullptr && is_virtual_or_interface && !callee->is_static()) {\n@@ -423,1 +423,1 @@\n-            if (m != NULL &&\n+            if (m != nullptr &&\n@@ -513,1 +513,1 @@\n-  ciSignature*     declared_signature = NULL;\n+  ciSignature*     declared_signature = nullptr;\n@@ -518,1 +518,1 @@\n-  assert(declared_signature != NULL, \"cannot be null\");\n+  assert(declared_signature != nullptr, \"cannot be null\");\n@@ -539,1 +539,1 @@\n-  assert(holder_klass->is_interface() || holder_klass->super() == NULL || (bc() != Bytecodes::_invokeinterface), \"must match bc\");\n+  assert(holder_klass->is_interface() || holder_klass->super() == nullptr || (bc() != Bytecodes::_invokeinterface), \"must match bc\");\n@@ -569,1 +569,1 @@\n-  ciKlass* speculative_receiver_type = NULL;\n+  ciKlass* speculative_receiver_type = nullptr;\n@@ -583,1 +583,1 @@\n-    speculative_receiver_type = receiver_type != NULL ? receiver_type->speculative_type() : NULL;\n+    speculative_receiver_type = receiver_type != nullptr ? receiver_type->speculative_type() : nullptr;\n@@ -587,1 +587,1 @@\n-  ciKlass* receiver_constraint = NULL;\n+  ciKlass* receiver_constraint = nullptr;\n@@ -599,1 +599,1 @@\n-  if (receiver_constraint != NULL) {\n+  if (receiver_constraint != nullptr) {\n@@ -602,1 +602,1 @@\n-    Node* bad_type_ctrl = NULL;\n+    Node* bad_type_ctrl = nullptr;\n@@ -604,1 +604,1 @@\n-    if (bad_type_ctrl != NULL) {\n+    if (bad_type_ctrl != nullptr) {\n@@ -632,1 +632,1 @@\n-  orig_callee = callee = NULL;\n+  orig_callee = callee = nullptr;\n@@ -654,1 +654,1 @@\n-  Node* receiver = has_receiver ? argument(0) : NULL;\n+  Node* receiver = has_receiver ? argument(0) : nullptr;\n@@ -657,1 +657,1 @@\n-  if (receiver != NULL && !call_does_dispatch && !cg->is_string_late_inline()) {\n+  if (receiver != nullptr && !call_does_dispatch && !cg->is_string_late_inline()) {\n@@ -664,1 +664,1 @@\n-  if (new_jvms == NULL) {\n+  if (new_jvms == nullptr) {\n@@ -678,1 +678,1 @@\n-    if (new_jvms == NULL) {\n+    if (new_jvms == nullptr) {\n@@ -704,1 +704,1 @@\n-    if (receiver != NULL && cg->is_virtual()) {\n+    if (receiver != nullptr && cg->is_virtual()) {\n@@ -733,1 +733,1 @@\n-            if (arg_type != NULL && !arg_type->higher_equal(sig_type)) {\n+            if (arg_type != nullptr && !arg_type->higher_equal(sig_type)) {\n@@ -766,1 +766,1 @@\n-      if (C->log() != NULL) {\n+      if (C->log() != nullptr) {\n@@ -803,1 +803,1 @@\n-  GrowableArray<const Type*>* extypes = new (C->node_arena()) GrowableArray<const Type*>(C->node_arena(), 8, 0, NULL);\n+  GrowableArray<const Type*>* extypes = new (C->node_arena()) GrowableArray<const Type*>(C->node_arena(), 8, 0, nullptr);\n@@ -913,1 +913,1 @@\n-  assert(stopped(), \"call set_map(NULL) first\");\n+  assert(stopped(), \"call set_map(nullptr) first\");\n@@ -922,2 +922,2 @@\n-  NOT_PRODUCT(if (ex_type==NULL) tty->print_cr(\"*** Exception not InstPtr\"));\n-  if (ex_type == NULL)\n+  NOT_PRODUCT(if (ex_type==nullptr) tty->print_cr(\"*** Exception not InstPtr\"));\n+  if (ex_type == nullptr)\n@@ -936,1 +936,1 @@\n-  Node* ex_klass_node = NULL;\n+  Node* ex_klass_node = nullptr;\n@@ -939,1 +939,1 @@\n-    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -951,1 +951,1 @@\n-        if (ex_in == top() || ex_in == NULL) {\n+        if (ex_in == top() || ex_in == nullptr) {\n@@ -957,1 +957,1 @@\n-        Node* k = _gvn.transform( LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+        Node* k = _gvn.transform( LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -1042,1 +1042,1 @@\n-                    NULL, NULL,\n+                    nullptr, nullptr,\n@@ -1105,1 +1105,1 @@\n-  if (optimized_virtual_method != NULL) {\n+  if (optimized_virtual_method != nullptr) {\n@@ -1129,2 +1129,2 @@\n-  if (receiver_type == NULL) {\n-    return NULL; \/\/ no receiver type info\n+  if (receiver_type == nullptr) {\n+    return nullptr; \/\/ no receiver type info\n@@ -1146,1 +1146,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1162,1 +1162,1 @@\n-  if (cha_monomorphic_target != NULL) {\n+  if (cha_monomorphic_target != nullptr) {\n@@ -1183,1 +1183,1 @@\n-    if (exact_method != NULL) {\n+    if (exact_method != nullptr) {\n@@ -1188,1 +1188,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":69,"deletions":69,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  _nodes(C->comp_arena(), C->unique(), C->unique(), NULL),\n+  _nodes(C->comp_arena(), C->unique(), C->unique(), nullptr),\n@@ -60,1 +60,1 @@\n-  \/\/ Add ConP(#NULL) and ConN(#NULL) nodes.\n+  \/\/ Add ConP and ConN null oop nodes\n@@ -99,1 +99,1 @@\n-  \/\/ Add ConP#NULL and ConN#NULL nodes before ConnectionGraph construction\n+  \/\/ Add ConP and ConN null oop nodes before ConnectionGraph construction\n@@ -104,1 +104,1 @@\n-  if (C->congraph() != NULL) {\n+  if (C->congraph() != nullptr) {\n@@ -143,1 +143,1 @@\n-  ideal_nodes.map(C->live_nodes(), NULL);  \/\/ preallocate space\n+  ideal_nodes.map(C->live_nodes(), nullptr);  \/\/ preallocate space\n@@ -145,1 +145,1 @@\n-  if (C->root() != NULL) {\n+  if (C->root() != nullptr) {\n@@ -164,1 +164,1 @@\n-      _nodes.at_put_grow(addp->_idx, NULL, NULL);\n+      _nodes.at_put_grow(addp->_idx, nullptr, nullptr);\n@@ -170,1 +170,1 @@\n-    if (ptn != NULL && ptn != phantom_obj) {\n+    if (ptn != nullptr && ptn != phantom_obj) {\n@@ -418,1 +418,1 @@\n-  for (JVMState* jvms = sfn->jvms(); jvms != NULL; jvms = jvms->caller()) {\n+  for (JVMState* jvms = sfn->jvms(); jvms != nullptr; jvms = jvms->caller()) {\n@@ -436,1 +436,1 @@\n-        if (m != NULL && not_global_escape(m)) {\n+        if (m != nullptr && not_global_escape(m)) {\n@@ -448,1 +448,1 @@\n-  if (call->method() != NULL) {\n+  if (call->method() != nullptr) {\n@@ -458,1 +458,1 @@\n-    assert(name != NULL, \"no name\");\n+    assert(name != nullptr, \"no name\");\n@@ -465,1 +465,1 @@\n-        if (at->isa_oopptr() != NULL) {\n+        if (at->isa_oopptr() != nullptr) {\n@@ -481,1 +481,1 @@\n-  if (t->make_ptr() != NULL) {\n+  if (t->make_ptr() != nullptr) {\n@@ -487,1 +487,1 @@\n-      assert((ptnode_adr(adr->_idx) == NULL ||\n+      assert((ptnode_adr(adr->_idx) == nullptr ||\n@@ -503,1 +503,1 @@\n-  if (n_ptn != NULL) {\n+  if (n_ptn != nullptr) {\n@@ -524,1 +524,1 @@\n-        if (name != NULL && strcmp(name, \"uncommon_trap\") == 0) {\n+        if (name != nullptr && strcmp(name, \"uncommon_trap\") == 0) {\n@@ -532,1 +532,1 @@\n-           n->as_Call()->proj_out_or_null(TypeFunc::Parms) != NULL) ||\n+           n->as_Call()->proj_out_or_null(TypeFunc::Parms) != nullptr) ||\n@@ -566,1 +566,1 @@\n-      if (ptn_base == NULL) {\n+      if (ptn_base == nullptr) {\n@@ -639,1 +639,1 @@\n-      if (t->make_ptr() != NULL) {\n+      if (t->make_ptr() != nullptr) {\n@@ -737,1 +737,1 @@\n-         (n_ptn != NULL) && (n_ptn->ideal_node() != NULL),\n+         (n_ptn != nullptr) && (n_ptn->ideal_node() != nullptr),\n@@ -748,1 +748,1 @@\n-      assert(ptn_base != NULL, \"field's base should be registered\");\n+      assert(ptn_base != nullptr, \"field's base should be registered\");\n@@ -759,1 +759,1 @@\n-      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(1), NULL);\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(1), nullptr);\n@@ -765,2 +765,2 @@\n-        if (in == NULL) {\n-          continue;  \/\/ ignore NULL\n+        if (in == nullptr) {\n+          continue;  \/\/ ignore null\n@@ -773,1 +773,1 @@\n-        assert(ptn != NULL, \"node should be registered\");\n+        assert(ptn != nullptr, \"node should be registered\");\n@@ -782,2 +782,2 @@\n-      assert(_igvn->type(n)->make_ptr() != NULL, \"Unexpected node type\");\n-      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(MemNode::Address), NULL);\n+      assert(_igvn->type(n)->make_ptr() != nullptr, \"Unexpected node type\");\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(MemNode::Address), nullptr);\n@@ -789,1 +789,1 @@\n-      assert(n->as_Phi()->type()->make_ptr() != NULL, \"Unexpected node type\");\n+      assert(n->as_Phi()->type()->make_ptr() != nullptr, \"Unexpected node type\");\n@@ -792,2 +792,2 @@\n-        if (in == NULL) {\n-          continue;  \/\/ ignore NULL\n+        if (in == nullptr) {\n+          continue;  \/\/ ignore null\n@@ -800,1 +800,1 @@\n-        assert(ptn != NULL, \"node should be registered\");\n+        assert(ptn != nullptr, \"node should be registered\");\n@@ -809,1 +809,1 @@\n-      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(0), NULL);\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(0), nullptr);\n@@ -817,1 +817,1 @@\n-      add_local_var_and_edge(n, PointsToNode::GlobalEscape, n->in(TypeFunc::Parms), NULL);\n+      add_local_var_and_edge(n, PointsToNode::GlobalEscape, n->in(TypeFunc::Parms), nullptr);\n@@ -824,2 +824,2 @@\n-      assert(_igvn->type(n)->make_ptr() != NULL, \"Unexpected node type\");\n-      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(MemNode::Address), NULL);\n+      assert(_igvn->type(n)->make_ptr() != nullptr, \"Unexpected node type\");\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(MemNode::Address), nullptr);\n@@ -856,1 +856,1 @@\n-                 at->isa_ptr() != NULL, \"expecting a pointer\");\n+                 at->isa_ptr() != nullptr, \"expecting a pointer\");\n@@ -861,1 +861,1 @@\n-          assert(ptn != NULL, \"node should be registered\");\n+          assert(ptn != nullptr, \"node should be registered\");\n@@ -903,1 +903,1 @@\n-  if (adr_type == NULL) {\n+  if (adr_type == nullptr) {\n@@ -941,1 +941,1 @@\n-  if (adr_type == NULL) {\n+  if (adr_type == nullptr) {\n@@ -943,1 +943,1 @@\n-    assert(adr_type != NULL, \"dead node should not be on list\");\n+    assert(adr_type != nullptr, \"dead node should not be on list\");\n@@ -954,1 +954,1 @@\n-    assert(adr_ptn != NULL &&\n+    assert(adr_ptn != nullptr &&\n@@ -958,1 +958,1 @@\n-    assert(ptn != NULL, \"node should be registered\");\n+    assert(ptn != nullptr, \"node should be registered\");\n@@ -965,1 +965,1 @@\n-    assert(ptn != NULL, \"node should be registered\");\n+    assert(ptn != nullptr, \"node should be registered\");\n@@ -969,1 +969,1 @@\n-    assert(adr_ptn != NULL, \"node should be registered\");\n+    assert(adr_ptn != nullptr, \"node should be registered\");\n@@ -989,1 +989,1 @@\n-    assert(kt != NULL, \"TypeKlassPtr  required.\");\n+    assert(kt != nullptr, \"TypeKlassPtr  required.\");\n@@ -1058,1 +1058,1 @@\n-    if (meth == NULL) {\n+    if (meth == nullptr) {\n@@ -1092,1 +1092,1 @@\n-          if (d->field_at(i)->isa_ptr() != NULL &&\n+          if (d->field_at(i)->isa_ptr() != nullptr &&\n@@ -1142,1 +1142,1 @@\n-        if (arg == NULL) {\n+        if (arg == nullptr) {\n@@ -1161,1 +1161,1 @@\n-        assert(arg_ptn != NULL, \"should be registered\");\n+        assert(arg_ptn != nullptr, \"should be registered\");\n@@ -1165,1 +1165,1 @@\n-                 aat->isa_ptr() != NULL, \"expecting an Ptr\");\n+                 aat->isa_ptr() != nullptr, \"expecting an Ptr\");\n@@ -1168,2 +1168,2 @@\n-                               (aat->isa_aryptr() && (aat->isa_aryptr()->elem() == Type::BOTTOM || aat->isa_aryptr()->elem()->make_oopptr() != NULL)) ||\n-                               (aat->isa_aryptr() && aat->isa_aryptr()->elem() != NULL &&\n+                               (aat->isa_aryptr() && (aat->isa_aryptr()->elem() == Type::BOTTOM || aat->isa_aryptr()->elem()->make_oopptr() != nullptr)) ||\n+                               (aat->isa_aryptr() && aat->isa_aryptr()->elem() != nullptr &&\n@@ -1188,1 +1188,1 @@\n-                (call->as_CallLeaf()->_name != NULL &&\n+                (call->as_CallLeaf()->_name != nullptr &&\n@@ -1256,1 +1256,1 @@\n-            assert(src_ptn != NULL, \"should be registered\");\n+            assert(src_ptn != nullptr, \"should be registered\");\n@@ -1275,1 +1275,1 @@\n-      assert((name == NULL || strcmp(name, \"uncommon_trap\") != 0), \"normal calls only\");\n+      assert((name == nullptr || strcmp(name, \"uncommon_trap\") != 0), \"normal calls only\");\n@@ -1278,1 +1278,1 @@\n-      if ((meth != NULL) && meth->is_boxing_method()) {\n+      if ((meth != nullptr) && meth->is_boxing_method()) {\n@@ -1281,1 +1281,1 @@\n-      BCEscapeAnalyzer* call_analyzer = (meth !=NULL) ? meth->get_bcea() : NULL;\n+      BCEscapeAnalyzer* call_analyzer = (meth !=nullptr) ? meth->get_bcea() : nullptr;\n@@ -1283,1 +1283,1 @@\n-      if (call_analyzer != NULL) {\n+      if (call_analyzer != nullptr) {\n@@ -1291,1 +1291,1 @@\n-          if (at->isa_ptr() != NULL &&\n+          if (at->isa_ptr() != nullptr &&\n@@ -1294,1 +1294,1 @@\n-            if (call_ptn != NULL) { \/\/ Is call's result used?\n+            if (call_ptn != nullptr) { \/\/ Is call's result used?\n@@ -1296,1 +1296,1 @@\n-              assert(arg_ptn != NULL, \"node should be registered\");\n+              assert(arg_ptn != nullptr, \"node should be registered\");\n@@ -1300,1 +1300,1 @@\n-          if (at->isa_oopptr() != NULL &&\n+          if (at->isa_oopptr() != nullptr &&\n@@ -1314,1 +1314,1 @@\n-        if (call_ptn != NULL && call_ptn->is_LocalVar()) {\n+        if (call_ptn != nullptr && call_ptn->is_LocalVar()) {\n@@ -1332,1 +1332,1 @@\n-        if (at->isa_oopptr() != NULL) {\n+        if (at->isa_oopptr() != nullptr) {\n@@ -1337,1 +1337,1 @@\n-          assert(ptnode_adr(arg->_idx) != NULL, \"should be defined already\");\n+          assert(ptnode_adr(arg->_idx) != nullptr, \"should be defined already\");\n@@ -1449,1 +1449,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -1463,1 +1463,1 @@\n-  \/\/ Find fields initialized by NULL for non-escaping Allocations.\n+  \/\/ Find fields initialized by null for non-escaping Allocations.\n@@ -1471,2 +1471,2 @@\n-        \/\/ Adding references to NULL object does not change escape states\n-        \/\/ since it does not escape. Also no fields are added to NULL object.\n+        \/\/ Adding references to null object does not change escape states\n+        \/\/ since it does not escape. Also no fields are added to null object.\n@@ -1482,1 +1482,1 @@\n-      if (ini != NULL)\n+      if (ini != nullptr)\n@@ -1598,1 +1598,1 @@\n-      if (jobj == null_obj) { \/\/ NULL object does not have field edges\n+      if (jobj == null_obj) { \/\/ null object does not have field edges\n@@ -1619,1 +1619,1 @@\n-            if (jobj == null_obj) { \/\/ NULL object does not have field edges\n+            if (jobj == null_obj) { \/\/ null object does not have field edges\n@@ -1694,1 +1694,1 @@\n-        \/\/ NULL object node does not have fields.\n+        \/\/ null object node does not have fields.\n@@ -1728,1 +1728,1 @@\n-      assert(base == null_obj, \"only NULL ptr base expected here\");\n+      assert(base == null_obj, \"only null ptr base expected here\");\n@@ -1748,1 +1748,1 @@\n-    if (alloc->as_Allocate()->in(AllocateNode::DefaultValue) != NULL) {\n+    if (alloc->as_Allocate()->in(AllocateNode::DefaultValue) != nullptr) {\n@@ -1752,1 +1752,1 @@\n-      assert(init_val != NULL, \"default value should be registered\");\n+      assert(init_val != nullptr, \"default value should be registered\");\n@@ -1760,1 +1760,1 @@\n-  if (alloc->is_CallStaticJava() && alloc->as_CallStaticJava()->method() == NULL) {\n+  if (alloc->is_CallStaticJava() && alloc->as_CallStaticJava()->method() == nullptr) {\n@@ -1786,1 +1786,1 @@\n-  if (!alloc->is_Allocate() || alloc->as_Allocate()->in(AllocateNode::DefaultValue) != NULL) {\n+  if (!alloc->is_Allocate() || alloc->as_Allocate()->in(AllocateNode::DefaultValue) != nullptr) {\n@@ -1795,2 +1795,2 @@\n-  \/\/ a corresponding NULL if field's value if it is not recorded.\n-  \/\/ Connection Graph does not record a default initialization by NULL\n+  \/\/ a corresponding null if field's value if it is not recorded.\n+  \/\/ Connection Graph does not record a default initialization by null\n@@ -1808,1 +1808,1 @@\n-        \/\/ always add reference to NULL to all Field nodes since we don't\n+        \/\/ always add reference to null to all Field nodes since we don't\n@@ -1831,2 +1831,2 @@\n-        Node* value = NULL;\n-        if (ini != NULL) {\n+        Node* value = nullptr;\n+        if (ini != nullptr) {\n@@ -1839,1 +1839,1 @@\n-          if (store != NULL && store->is_Store() &&\n+          if (store != nullptr && store->is_Store() &&\n@@ -1846,2 +1846,2 @@\n-              assert((val != NULL), \"should be processed already\");\n-              PointsToNode* missed_obj = NULL;\n+              assert((val != nullptr), \"should be processed already\");\n+              PointsToNode* missed_obj = nullptr;\n@@ -1869,1 +1869,1 @@\n-              if (missed_obj != NULL) {\n+              if (missed_obj != nullptr) {\n@@ -1887,1 +1887,1 @@\n-            \/\/ stores which follow loads. For now, add initial value NULL so\n+            \/\/ stores which follow loads. For now, add initial value null so\n@@ -1891,2 +1891,2 @@\n-        if (value == NULL) {\n-          \/\/ A field's initializing value was not recorded. Add NULL.\n+        if (value == nullptr) {\n+          \/\/ A field's initializing value was not recorded. Add null.\n@@ -2182,1 +2182,1 @@\n-      if (alloc->in(AllocateNode::InlineType) != NULL) {\n+      if (alloc->in(AllocateNode::InlineType) != nullptr) {\n@@ -2212,1 +2212,1 @@\n-  if (jobj1 != NULL) {\n+  if (jobj1 != nullptr) {\n@@ -2226,1 +2226,1 @@\n-  if (jobj2 != NULL) {\n+  if (jobj2 != nullptr) {\n@@ -2236,2 +2236,2 @@\n-  if (jobj1 != NULL && jobj1 != phantom_obj &&\n-      jobj2 != NULL && jobj2 != phantom_obj &&\n+  if (jobj1 != nullptr && jobj1 != phantom_obj &&\n+      jobj2 != nullptr && jobj2 != phantom_obj &&\n@@ -2286,1 +2286,1 @@\n-  if (ptadr != NULL) {\n+  if (ptadr != nullptr) {\n@@ -2297,1 +2297,1 @@\n-  if (ptadr != NULL) {\n+  if (ptadr != nullptr) {\n@@ -2308,1 +2308,1 @@\n-  if (ptadr != NULL) {\n+  if (ptadr != nullptr) {\n@@ -2325,1 +2325,1 @@\n-  assert((src != null_obj) && (dst != null_obj), \"not for ConP NULL\");\n+  assert((src != null_obj) && (dst != null_obj), \"not for ConP null\");\n@@ -2327,1 +2327,1 @@\n-  if (ptadr != NULL) {\n+  if (ptadr != nullptr) {\n@@ -2350,1 +2350,1 @@\n-        adr_type->isa_aryptr()->elem()->make_oopptr() != NULL) {\n+        adr_type->isa_aryptr()->elem()->make_oopptr() != nullptr) {\n@@ -2352,1 +2352,1 @@\n-      if (find_second_addp(n, n->in(AddPNode::Base)) == NULL) {\n+      if (find_second_addp(n, n->in(AddPNode::Base)) == nullptr) {\n@@ -2359,1 +2359,1 @@\n-      if (field != NULL) {\n+      if (field != nullptr) {\n@@ -2374,1 +2374,1 @@\n-      } else if (find_second_addp(n, n->in(AddPNode::Base)) != NULL) {\n+      } else if (find_second_addp(n, n->in(AddPNode::Base)) != nullptr) {\n@@ -2400,1 +2400,1 @@\n-\/\/ Returns unique pointed java object or NULL.\n+\/\/ Returns unique pointed java object or null.\n@@ -2406,1 +2406,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2409,2 +2409,2 @@\n-  if (ptn == NULL) {\n-    return NULL;\n+  if (ptn == nullptr) {\n+    return nullptr;\n@@ -2417,1 +2417,1 @@\n-  JavaObjectNode* jobj = NULL;\n+  JavaObjectNode* jobj = nullptr;\n@@ -2421,1 +2421,1 @@\n-      if (jobj == NULL) {\n+      if (jobj == nullptr) {\n@@ -2424,1 +2424,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2465,1 +2465,1 @@\n-  if (ptn == NULL) {\n+  if (ptn == nullptr) {\n@@ -2539,1 +2539,1 @@\n-  assert(_igvn->type(addp)->isa_oopptr() == NULL, \"should be raw access\");\n+  assert(_igvn->type(addp)->isa_oopptr() == nullptr, \"should be raw access\");\n@@ -2559,1 +2559,1 @@\n-  if (adr->is_AddP() && adr_type->isa_oopptr() == NULL && is_captured_store_address(adr)) {\n+  if (adr->is_AddP() && adr_type->isa_oopptr() == nullptr && is_captured_store_address(adr)) {\n@@ -2659,1 +2659,1 @@\n-             (uncast_base->is_Mem() && (uncast_base->bottom_type()->isa_rawptr() != NULL)) ||\n+             (uncast_base->is_Mem() && (uncast_base->bottom_type()->isa_rawptr() != nullptr)) ||\n@@ -2703,1 +2703,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2713,1 +2713,1 @@\n-  assert(base_t != NULL && base_t->is_known_instance(), \"expecting instance oopptr\");\n+  assert(base_t != nullptr && base_t->is_known_instance(), \"expecting instance oopptr\");\n@@ -2715,1 +2715,1 @@\n-  if (t == NULL) {\n+  if (t == nullptr) {\n@@ -2722,1 +2722,1 @@\n-    if (base_t->isa_aryptr() != NULL) {\n+    if (base_t->isa_aryptr() != nullptr) {\n@@ -2762,1 +2762,1 @@\n-    if (tinst == NULL) {\n+    if (tinst == nullptr) {\n@@ -2791,1 +2791,1 @@\n-        assert(adr->is_AddP() && atype != NULL &&\n+        assert(adr->is_AddP() && atype != nullptr &&\n@@ -2819,1 +2819,1 @@\n-  if (result != NULL && C->get_alias_index(result->adr_type()) == alias_idx) {\n+  if (result != nullptr && C->get_alias_index(result->adr_type()) == alias_idx) {\n@@ -2824,1 +2824,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -2842,1 +2842,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2846,1 +2846,1 @@\n-  result = PhiNode::make(orig_phi->in(0), NULL, Type::MEMORY, atype);\n+  result = PhiNode::make(orig_phi->in(0), nullptr, Type::MEMORY, atype);\n@@ -2876,1 +2876,1 @@\n-      if (mem != NULL && mem->is_Phi()) {\n+      if (mem != nullptr && mem->is_Phi()) {\n@@ -2892,1 +2892,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2899,1 +2899,1 @@\n-    assert( result->in(0) != NULL && result->in(0) == phi->in(0), \"regions must match\");\n+    assert( result->in(0) != nullptr && result->in(0) == phi->in(0), \"regions must match\");\n@@ -2905,1 +2905,1 @@\n-      assert((phi->in(i) == NULL) == (in == NULL), \"inputs must correspond.\");\n+      assert((phi->in(i) == nullptr) == (in == nullptr), \"inputs must correspond.\");\n@@ -2945,1 +2945,1 @@\n-  assert(tp != NULL, \"ptr type\");\n+  assert(tp != nullptr, \"ptr type\");\n@@ -2974,1 +2974,1 @@\n-      if ((tp != NULL && C->get_alias_index(tp) == alias_idx) ||\n+      if ((tp != nullptr && C->get_alias_index(tp) == alias_idx) ||\n@@ -2995,1 +2995,1 @@\n-      assert(tp != NULL, \"ptr type\");\n+      assert(tp != nullptr, \"ptr type\");\n@@ -2997,1 +2997,1 @@\n-      assert(get_map(use->_idx) != NULL || idx == alias_idx,\n+      assert(get_map(use->_idx) != nullptr || idx == alias_idx,\n@@ -3002,1 +3002,1 @@\n-      assert(tp != NULL, \"ptr type\");\n+      assert(tp != nullptr, \"ptr type\");\n@@ -3018,1 +3018,1 @@\n-  if (orig_mem == NULL) {\n+  if (orig_mem == nullptr) {\n@@ -3024,1 +3024,1 @@\n-  bool is_instance = (toop != NULL) && toop->is_known_instance();\n+  bool is_instance = (toop != nullptr) && toop->is_known_instance();\n@@ -3026,1 +3026,1 @@\n-  Node *prev = NULL;\n+  Node *prev = nullptr;\n@@ -3038,1 +3038,1 @@\n-      assert (at->isa_ptr() != NULL, \"pointer type required.\");\n+      assert (at->isa_ptr() != nullptr, \"pointer type required.\");\n@@ -3043,1 +3043,1 @@\n-      if (!is_instance && (at->isa_oopptr() == NULL ||\n+      if (!is_instance && (at->isa_oopptr() == nullptr ||\n@@ -3067,1 +3067,1 @@\n-        if (alloc == NULL || alloc->_idx != (uint)toop->instance_id()) {\n+        if (alloc == nullptr || alloc->_idx != (uint)toop->instance_id()) {\n@@ -3093,1 +3093,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -3100,1 +3100,1 @@\n-      if (un != NULL) {\n+      if (un != nullptr) {\n@@ -3115,1 +3115,1 @@\n-      Node* adr = NULL;\n+      Node* adr = nullptr;\n@@ -3125,1 +3125,1 @@\n-        assert(at->isa_ptr() != NULL, \"pointer type required.\");\n+        assert(at->isa_ptr() != nullptr, \"pointer type required.\");\n@@ -3138,1 +3138,1 @@\n-        assert(at->isa_ptr() != NULL, \"pointer type required.\");\n+        assert(at->isa_ptr() != nullptr, \"pointer type required.\");\n@@ -3288,1 +3288,1 @@\n-      if (n == NULL) {            \/\/ No uses except Initialize node\n+      if (n == nullptr) {            \/\/ No uses except Initialize node\n@@ -3313,1 +3313,1 @@\n-        Node *cast2 = NULL;\n+        Node *cast2 = nullptr;\n@@ -3321,1 +3321,1 @@\n-        if (cast2 != NULL) {\n+        if (cast2 != nullptr) {\n@@ -3332,1 +3332,1 @@\n-      if (t == NULL) {\n+      if (t == nullptr) {\n@@ -3376,1 +3376,1 @@\n-            if (addp2 != NULL) {\n+            if (addp2 != nullptr) {\n@@ -3388,1 +3388,1 @@\n-        assert (raw_result != NULL, \"must have an allocation result\");\n+        assert (raw_result != nullptr, \"must have an allocation result\");\n@@ -3393,1 +3393,1 @@\n-            if (addp2 != NULL) {\n+            if (addp2 != nullptr) {\n@@ -3405,1 +3405,1 @@\n-      if (jobj == NULL || jobj == phantom_obj) {\n+      if (jobj == nullptr || jobj == phantom_obj) {\n@@ -3409,1 +3409,1 @@\n-        assert(jobj != NULL && jobj != phantom_obj, \"escaped allocation\");\n+        assert(jobj != nullptr && jobj != phantom_obj, \"escaped allocation\");\n@@ -3426,1 +3426,1 @@\n-      if (jobj == NULL || jobj == phantom_obj) {\n+      if (jobj == nullptr || jobj == phantom_obj) {\n@@ -3429,1 +3429,1 @@\n-        assert(jobj != NULL && jobj != phantom_obj, \"escaped allocation\");\n+        assert(jobj != nullptr && jobj != phantom_obj, \"escaped allocation\");\n@@ -3437,1 +3437,1 @@\n-        assert(tinst != NULL && tinst->is_known_instance() &&\n+        assert(tinst != nullptr && tinst->is_known_instance() &&\n@@ -3447,1 +3447,1 @@\n-        if (tn_t != NULL && tinst->maybe_java_subtype_of(tn_t)) {\n+        if (tn_t != nullptr && tinst->maybe_java_subtype_of(tn_t)) {\n@@ -3451,1 +3451,1 @@\n-            if (tinst == NULL) {\n+            if (tinst == nullptr) {\n@@ -3467,1 +3467,1 @@\n-                 tn_t != NULL && !tinst->maybe_java_subtype_of(tn_t),\n+                 tn_t != nullptr && !tinst->maybe_java_subtype_of(tn_t),\n@@ -3489,1 +3489,1 @@\n-        if (addp2 != NULL) {\n+        if (addp2 != nullptr) {\n@@ -3554,1 +3554,1 @@\n-    if (jobj != NULL) {\n+    if (jobj != nullptr) {\n@@ -3556,1 +3556,1 @@\n-      if (base != NULL) {\n+      if (base != nullptr) {\n@@ -3566,1 +3566,1 @@\n-    if (jobj != NULL) {\n+    if (jobj != nullptr) {\n@@ -3568,1 +3568,1 @@\n-      if (base != NULL) {\n+      if (base != nullptr) {\n@@ -3594,1 +3594,1 @@\n-      if (n == NULL) {\n+      if (n == nullptr) {\n@@ -3601,2 +3601,2 @@\n-      assert(n != NULL && n->Opcode() == Op_SCMemProj, \"memory projection required\");\n-    } else if (n->is_CallLeaf() && n->as_CallLeaf()->_name != NULL &&\n+      assert(n != nullptr && n->Opcode() == Op_SCMemProj, \"memory projection required\");\n+    } else if (n->is_CallLeaf() && n->as_CallLeaf()->_name != nullptr &&\n@@ -3612,1 +3612,1 @@\n-      assert (addr_t->isa_ptr() != NULL, \"pointer type required.\");\n+      assert (addr_t->isa_ptr() != nullptr, \"pointer type required.\");\n@@ -3629,1 +3629,1 @@\n-        assert(n != NULL && n->Opcode() == Op_SCMemProj, \"memory projection required\");\n+        assert(n != nullptr && n->Opcode() == Op_SCMemProj, \"memory projection required\");\n@@ -3656,1 +3656,1 @@\n-      } else if (use->is_CallLeaf() && use->as_CallLeaf()->_name != NULL &&\n+      } else if (use->is_CallLeaf() && use->as_CallLeaf()->_name != nullptr &&\n@@ -3694,2 +3694,2 @@\n-      Node* cur = NULL;\n-      if (mem == NULL || mem->is_top()) {\n+      Node* cur = nullptr;\n+      if (mem == nullptr || mem->is_top()) {\n@@ -3703,1 +3703,1 @@\n-          assert (at->isa_ptr() != NULL, \"pointer type required.\");\n+          assert (at->isa_ptr() != nullptr, \"pointer type required.\");\n@@ -3706,1 +3706,1 @@\n-            if (cur == NULL) {\n+            if (cur == nullptr) {\n@@ -3717,1 +3717,1 @@\n-      nmm->set_memory_at(i, (cur != NULL) ? cur : mem);\n+      nmm->set_memory_at(i, (cur != nullptr) ? cur : mem);\n@@ -3787,1 +3787,1 @@\n-    assert(nmem != NULL, \"sanity\");\n+    assert(nmem != nullptr, \"sanity\");\n@@ -3887,1 +3887,1 @@\n-  if (_node == NULL) {\n+  if (_node == nullptr) {\n@@ -3899,1 +3899,1 @@\n-    if (ptn == NULL || !ptn->is_JavaObject()) {\n+    if (ptn == nullptr || !ptn->is_JavaObject()) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":180,"deletions":180,"binary":false,"changes":360,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-        if (buse != NULL) {\n+        if (buse != nullptr) {\n@@ -80,1 +80,1 @@\n-  assert(in0 != NULL, \"Only control-dependent\");\n+  assert(in0 != nullptr, \"Only control-dependent\");\n@@ -82,1 +82,1 @@\n-  if (p != NULL && p != n) {    \/\/ Control from a block projection?\n+  if (p != nullptr && p != n) {    \/\/ Control from a block projection?\n@@ -112,1 +112,1 @@\n-  assert(n != NULL && d != NULL, \"blocks must exist\");\n+  assert(n != nullptr && d != nullptr, \"blocks must exist\");\n@@ -215,1 +215,1 @@\n-      Node* n = NULL;\n+      Node* n = nullptr;\n@@ -218,1 +218,1 @@\n-        if (m == NULL) continue;\n+        if (m == nullptr) continue;\n@@ -223,1 +223,1 @@\n-          if (n == NULL) {\n+          if (n == nullptr) {\n@@ -234,1 +234,1 @@\n-      if (n != NULL) {\n+      if (n != nullptr) {\n@@ -242,1 +242,1 @@\n-      \/\/ process all inputs that are non NULL\n+      \/\/ process all inputs that are non null\n@@ -244,1 +244,1 @@\n-        if (node->in(i) != NULL) {\n+        if (node->in(i) != nullptr) {\n@@ -257,1 +257,1 @@\n-  if (b1 == NULL)  return;\n+  if (b1 == nullptr)  return;\n@@ -260,1 +260,1 @@\n-  while (tmp != b1 && tmp != NULL) {\n+  while (tmp != b1 && tmp != nullptr) {\n@@ -268,1 +268,1 @@\n-      if (inn == NULL)  continue;  \/\/ Ignore NULL, missing inputs\n+      if (inn == nullptr)  continue;  \/\/ Ignore null, missing inputs\n@@ -283,1 +283,1 @@\n-  Block* deepb           = NULL;        \/\/ Deepest block so far\n+  Block* deepb           = nullptr;     \/\/ Deepest block so far\n@@ -287,1 +287,1 @@\n-    if (inn == NULL)  continue;         \/\/ Ignore NULL, missing inputs\n+    if (inn == nullptr)  continue;      \/\/ Ignore null, missing inputs\n@@ -289,1 +289,1 @@\n-    assert(inb != NULL, \"must already have scheduled this input\");\n+    assert(inb != nullptr, \"must already have scheduled this input\");\n@@ -299,1 +299,1 @@\n-  assert(deepb != NULL, \"must be at least one input to n\");\n+  assert(deepb != nullptr, \"must be at least one input to n\");\n@@ -328,1 +328,1 @@\n-        if (control_input != NULL) {\n+        if (control_input != nullptr) {\n@@ -348,1 +348,1 @@\n-        if (in == NULL) {\n+        if (in == nullptr) {\n@@ -404,1 +404,1 @@\n-\/\/ As a convenient boundary condition, return 'this' if LCA is NULL.\n+\/\/ As a convenient boundary condition, return 'this' if LCA is null.\n@@ -407,1 +407,1 @@\n-  if (LCA == NULL || LCA == this)  return this;\n+  if (LCA == nullptr || LCA == this)  return this;\n@@ -431,1 +431,1 @@\n-  if (buse == NULL)    return LCA;   \/\/ Unused killing Projs have no use block\n+  if (buse == nullptr) return LCA;   \/\/ Unused killing Projs have no use block\n@@ -510,3 +510,3 @@\n-  if (base != NULL)  mem_inputs[mem_inputs_length++] = base;\n-  if (index != NULL) mem_inputs[mem_inputs_length++] = index;\n-  if (store != NULL) mem_inputs[mem_inputs_length++] = store;\n+  if (base != nullptr)  mem_inputs[mem_inputs_length++] = base;\n+  if (index != nullptr) mem_inputs[mem_inputs_length++] = index;\n+  if (store != nullptr) mem_inputs[mem_inputs_length++] = store;\n@@ -522,1 +522,1 @@\n-    if (load->in(0) != NULL) mem_inputs[mem_inputs_length++] = load->in(0);\n+    if (load->in(0) != nullptr) mem_inputs[mem_inputs_length++] = load->in(0);\n@@ -524,1 +524,1 @@\n-    Block* deepb           = NULL;        \/\/ Deepest block so far\n+    Block* deepb           = nullptr;        \/\/ Deepest block so far\n@@ -557,1 +557,1 @@\n-    assert(if_true != NULL, \"null check without null projection\");\n+    assert(if_true != nullptr, \"null check without null projection\");\n@@ -559,1 +559,1 @@\n-    assert(null_block_region != NULL, \"null check without null region\");\n+    assert(null_block_region != nullptr, \"null check without null region\");\n@@ -583,1 +583,1 @@\n-  assert(LCA != NULL, \"\");\n+  assert(LCA != nullptr, \"\");\n@@ -653,1 +653,1 @@\n-  worklist_mem.push(NULL);\n+  worklist_mem.push(nullptr);\n@@ -668,1 +668,1 @@\n-        initial_mem = NULL;  \/\/ only process initial memory once\n+        initial_mem = nullptr;  \/\/ only process initial memory once\n@@ -711,1 +711,1 @@\n-          if (mcj->_method == NULL) {\n+          if (mcj->_method == nullptr) {\n@@ -740,1 +740,1 @@\n-    assert(store_block != NULL, \"unused killing projections skipped above\");\n+    assert(store_block != nullptr, \"unused killing projections skipped above\");\n@@ -890,1 +890,1 @@\n-  \/\/ If the _stack is empty, then just return NULL: finished.\n+  \/\/ If the _stack is empty, then just return null: finished.\n@@ -892,1 +892,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -914,1 +914,1 @@\n-    Node *unvisited = NULL;  \/\/ Unvisited anti-dependent Node, if any\n+    Node *unvisited = nullptr;  \/\/ Unvisited anti-dependent Node, if any\n@@ -1183,1 +1183,1 @@\n-  MachNode* mach = self->is_Mach() ? self->as_Mach() : NULL;\n+  MachNode* mach = self->is_Mach() ? self->as_Mach() : nullptr;\n@@ -1209,1 +1209,1 @@\n-    if (LCA == NULL) {\n+    if (LCA == nullptr) {\n@@ -1212,1 +1212,1 @@\n-      C->record_method_not_compilable(\"late schedule failed: LCA == NULL\");\n+      C->record_method_not_compilable(\"late schedule failed: LCA is null\");\n@@ -1317,1 +1317,1 @@\n-    MachNode* mach = self->is_Mach() ? self->as_Mach() : NULL;\n+    MachNode* mach = self->is_Mach() ? self->as_Mach() : nullptr;\n@@ -1329,1 +1329,1 @@\n-        if (def != NULL && def->bottom_type()->base() == Type::RawPtr) {\n+        if (def != nullptr && def->bottom_type()->base() == Type::RawPtr) {\n@@ -1387,1 +1387,1 @@\n-    Block *LCA = NULL;\n+    Block *LCA = nullptr;\n@@ -1394,1 +1394,1 @@\n-      guarantee(LCA != NULL, \"There must be a LCA\");\n+      guarantee(LCA != nullptr, \"There must be a LCA\");\n@@ -1400,1 +1400,1 @@\n-    if (mach != NULL && mach->is_MachTemp()) {\n+    if (mach != nullptr && mach->is_MachTemp()) {\n@@ -1435,1 +1435,1 @@\n-      assert(LCA != NULL, \"a valid LCA must exist\");\n+      assert(LCA != nullptr, \"a valid LCA must exist\");\n@@ -1448,1 +1448,1 @@\n-    if (mach != NULL && must_clone[mach->ideal_Opcode()])\n+    if (mach != nullptr && must_clone[mach->ideal_Opcode()])\n@@ -1451,1 +1451,1 @@\n-    Block* late = NULL;\n+    Block* late = nullptr;\n@@ -1531,2 +1531,2 @@\n-  \/\/ Detect implicit-null-check opportunities.  Basically, find NULL checks\n-  \/\/ with suitable memory ops nearby.  Use the memory op to do the NULL check.\n+  \/\/ Detect implicit-null-check opportunities.  Basically, find null checks\n+  \/\/ with suitable memory ops nearby.  Use the memory op to do the null check.\n@@ -1552,1 +1552,1 @@\n-  intptr_t *recalc_pressure_nodes = NULL;\n+  intptr_t *recalc_pressure_nodes = nullptr;\n@@ -1605,1 +1605,1 @@\n-      _regalloc = NULL;\n+      _regalloc = nullptr;\n@@ -1609,1 +1609,1 @@\n-  _regalloc = NULL;\n+  _regalloc = nullptr;\n@@ -1750,1 +1750,1 @@\n-    assert(block->_loop == NULL, \"clear _loop expected\");\n+    assert(block->_loop == nullptr, \"clear _loop expected\");\n@@ -1783,1 +1783,1 @@\n-        assert(loop_head->_loop == NULL, \"just checking\");\n+        assert(loop_head->_loop == nullptr, \"just checking\");\n@@ -1806,1 +1806,1 @@\n-    if (lp == NULL) {\n+    if (lp == nullptr) {\n@@ -1815,1 +1815,1 @@\n-      if (lp->parent() == NULL) {\n+      if (lp->parent() == nullptr) {\n@@ -1834,1 +1834,1 @@\n-  if (pred_loop == NULL) {\n+  if (pred_loop == nullptr) {\n@@ -1843,1 +1843,1 @@\n-    while (pred_loop->_parent != NULL && pred_loop->_parent != this) {\n+    while (pred_loop->_parent != nullptr && pred_loop->_parent != this) {\n@@ -1847,1 +1847,1 @@\n-    if (pred_loop->_parent == NULL) {\n+    if (pred_loop->_parent == nullptr) {\n@@ -1855,1 +1855,1 @@\n-      assert(pred_loop->_parent == this && _parent == NULL, \"just checking\");\n+      assert(pred_loop->_parent == this && _parent == nullptr, \"just checking\");\n@@ -1863,1 +1863,1 @@\n-  assert(_parent == NULL, \"no parent yet\");\n+  assert(_parent == nullptr, \"no parent yet\");\n@@ -1867,1 +1867,1 @@\n-  if (ch == NULL) {\n+  if (ch == nullptr) {\n@@ -1870,1 +1870,1 @@\n-    while (ch->_sibling != NULL) { ch = ch->_sibling; }\n+    while (ch->_sibling != nullptr) { ch = ch->_sibling; }\n@@ -1881,1 +1881,1 @@\n-  while (ch != NULL) {\n+  while (ch != nullptr) {\n@@ -1900,1 +1900,1 @@\n-  while (ch != NULL) {\n+  while (ch != nullptr) {\n@@ -2230,1 +2230,1 @@\n-  while (ch != NULL) {\n+  while (ch != nullptr) {\n@@ -2238,1 +2238,1 @@\n-  if (_child != NULL) {\n+  if (_child != nullptr) {\n@@ -2248,2 +2248,2 @@\n-  if (_child != NULL)   _child->dump_tree();\n-  if (_sibling != NULL) _sibling->dump_tree();\n+  if (_child != nullptr)   _child->dump_tree();\n+  if (_sibling != nullptr) _sibling->dump_tree();\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":71,"deletions":71,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-  \/\/ as soon as last_Java_sp != NULL the has_last_Java_frame is true and\n+  \/\/ as soon as last_Java_sp != nullptr the has_last_Java_frame is true and\n@@ -237,1 +237,1 @@\n-    Node* vm_result = make_load(NULL, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);\n+    Node* vm_result = make_load(nullptr, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);\n@@ -246,1 +246,1 @@\n-  Node* pending = make_load(NULL, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);\n+  Node* pending = make_load(nullptr, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);\n@@ -257,1 +257,1 @@\n-  assert (StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert (StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -270,1 +270,1 @@\n-  Node *ret = NULL;\n+  Node *ret = nullptr;\n","filename":"src\/hotspot\/share\/opto\/generateOptoStub.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    _gvn((gvn != NULL) ? *gvn : *C->initial_gvn()),\n+    _gvn((gvn != nullptr) ? *gvn : *C->initial_gvn()),\n@@ -66,1 +66,1 @@\n-  assert(gvn == NULL || !gvn->is_IterGVN() || gvn->is_IterGVN()->delay_transform(), \"delay transform should be enabled\");\n+  assert(gvn == nullptr || !gvn->is_IterGVN() || gvn->is_IterGVN()->delay_transform(), \"delay transform should be enabled\");\n@@ -68,1 +68,1 @@\n-  if (_exceptions != NULL)  jvms->map()->set_next_exception(NULL);\n+  if (_exceptions != nullptr)  jvms->map()->set_next_exception(nullptr);\n@@ -71,1 +71,1 @@\n-  if (_gvn.is_IterGVN() != NULL) {\n+  if (_gvn.is_IterGVN() != nullptr) {\n@@ -86,2 +86,2 @@\n-  _exceptions = NULL;\n-  set_map(NULL);\n+  _exceptions = nullptr;\n+  set_map(nullptr);\n@@ -134,1 +134,1 @@\n-  if (parse == NULL) {\n+  if (parse == nullptr) {\n@@ -154,1 +154,1 @@\n-  if (reg == NULL)  return false;\n+  if (reg == nullptr)  return false;\n@@ -157,1 +157,1 @@\n-    if (reg == NULL)  return false;\n+    if (reg == nullptr)  return false;\n@@ -159,1 +159,1 @@\n-  return reg->is_Region() && reg->in(0) != NULL && reg->in(0)->is_Root();\n+  return reg->is_Region() && reg->in(0) != nullptr && reg->in(0)->is_Root();\n@@ -163,1 +163,1 @@\n-  if (map() == NULL)  return;  \/\/ null map is OK\n+  if (map() == nullptr)  return;  \/\/ null map is OK\n@@ -170,1 +170,1 @@\n-  assert(ex_map->next_exception() == NULL, \"not already part of a chain\");\n+  assert(ex_map->next_exception() == nullptr, \"not already part of a chain\");\n@@ -176,1 +176,1 @@\n-\/\/ Set _map to NULL, signalling a stop to further bytecode execution.\n+\/\/ Set _map to null, signalling a stop to further bytecode execution.\n@@ -180,1 +180,1 @@\n-  if (dead_map != NULL) {\n+  if (dead_map != nullptr) {\n@@ -188,1 +188,1 @@\n-\/\/ Tell if _map is NULL, or control is top.\n+\/\/ Tell if _map is null, or control is top.\n@@ -190,1 +190,1 @@\n-  if (map() == NULL)           return true;\n+  if (map() == nullptr)        return true;\n@@ -199,1 +199,1 @@\n-  for (JVMState* jvmsp = jvms(); jvmsp != NULL; jvmsp = jvmsp->caller()) {\n+  for (JVMState* jvmsp = jvms(); jvmsp != nullptr; jvmsp = jvmsp->caller()) {\n@@ -255,1 +255,1 @@\n-  if (ex_map == NULL || ex_map->control() == top()) {\n+  if (ex_map == nullptr || ex_map->control() == top()) {\n@@ -274,1 +274,1 @@\n-  for (SafePointNode* e2 = _exceptions; e2 != NULL; e2 = e2->next_exception()) {\n+  for (SafePointNode* e2 = _exceptions; e2 != nullptr; e2 = e2->next_exception()) {\n@@ -292,3 +292,3 @@\n-  if (ex_map != NULL) {\n-    jvms->map()->set_next_exception(NULL);\n-    for (SafePointNode* next_map; ex_map != NULL; ex_map = next_map) {\n+  if (ex_map != nullptr) {\n+    jvms->map()->set_next_exception(nullptr);\n+    for (SafePointNode* next_map; ex_map != nullptr; ex_map = next_map) {\n@@ -296,1 +296,1 @@\n-      ex_map->set_next_exception(NULL);\n+      ex_map->set_next_exception(nullptr);\n@@ -304,1 +304,1 @@\n-  if (map() == NULL) {\n+  if (map() == nullptr) {\n@@ -310,1 +310,1 @@\n-      _map->set_next_exception(NULL);\n+      _map->set_next_exception(nullptr);\n@@ -315,1 +315,1 @@\n-      JVMState* jvms = new (C) JVMState(_method, NULL);\n+      JVMState* jvms = new (C) JVMState(_method, nullptr);\n@@ -330,1 +330,1 @@\n-  _exceptions = NULL;   \/\/ done with this set of exceptions\n+  _exceptions = nullptr;   \/\/ done with this set of exceptions\n@@ -352,1 +352,1 @@\n-\/\/ having a control input of its exception map, rather than NULL.  Such\n+\/\/ having a control input of its exception map, rather than null.  Such\n@@ -504,1 +504,1 @@\n-  if (method != NULL && bci != InvocationEntryBci)\n+  if (method != nullptr && bci != InvocationEntryBci)\n@@ -534,1 +534,1 @@\n-                    (ciKlass*)NULL, (char*)NULL, must_throw);\n+                    (ciKlass*)nullptr, (char*)nullptr, must_throw);\n@@ -581,1 +581,1 @@\n-    ciInstance* ex_obj = NULL;\n+    ciInstance* ex_obj = nullptr;\n@@ -602,1 +602,1 @@\n-    if (ex_obj != NULL) {\n+    if (ex_obj != nullptr) {\n@@ -611,1 +611,1 @@\n-      if (C->log() != NULL)\n+      if (C->log() != nullptr)\n@@ -647,1 +647,1 @@\n-  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? C->method() : NULL;\n+  ciMethod* m = Deoptimization::reason_is_speculate(reason) ? C->method() : nullptr;\n@@ -653,1 +653,1 @@\n-    if (C->log() != NULL)\n+    if (C->log() != nullptr)\n@@ -665,1 +665,1 @@\n-  uncommon_trap(reason, action, (ciKlass*)NULL, (char*)NULL, must_throw);\n+  uncommon_trap(reason, action, (ciKlass*)nullptr, (char*)nullptr, must_throw);\n@@ -675,1 +675,1 @@\n-  kit->set_map(clone_map ? kit->clone_map() : NULL);\n+  kit->set_map(clone_map ? kit->clone_map() : nullptr);\n@@ -679,1 +679,1 @@\n-  int block = (parser == NULL || parser->block() == NULL) ? -1 : parser->block()->rpo();\n+  int block = (parser == nullptr || parser->block() == nullptr) ? -1 : parser->block()->rpo();\n@@ -688,1 +688,1 @@\n-  int block = (parser == NULL || parser->block() == NULL) ? -1 : parser->block()->rpo();\n+  int block = (parser == nullptr || parser->block() == nullptr) ? -1 : parser->block()->rpo();\n@@ -733,1 +733,1 @@\n-  if (map() == NULL)  return NULL;\n+  if (map() == nullptr)  return nullptr;\n@@ -778,1 +778,1 @@\n-  _map->set_next_exception(NULL);\n+  _map->set_next_exception(nullptr);\n@@ -801,1 +801,1 @@\n-  if (method() == NULL || method()->code_size() == 0) {\n+  if (method() == nullptr || method()->code_size() == 0) {\n@@ -829,1 +829,1 @@\n-  if (method() == NULL || method()->code_size() == 0) {\n+  if (method() == nullptr || method()->code_size() == 0) {\n@@ -836,1 +836,1 @@\n-  for (JVMState* jvms = this->jvms(); jvms != NULL; jvms = jvms->caller()) {\n+  for (JVMState* jvms = this->jvms(); jvms != nullptr; jvms = jvms->caller()) {\n@@ -869,1 +869,1 @@\n-  if (cur_method != NULL && cur_bci != InvocationEntryBci) {\n+  if (cur_method != nullptr && cur_bci != InvocationEntryBci) {\n@@ -963,1 +963,1 @@\n-  for (JVMState* in_jvms = youngest_jvms; in_jvms != NULL; ) {\n+  for (JVMState* in_jvms = youngest_jvms; in_jvms != nullptr; ) {\n@@ -1112,1 +1112,1 @@\n-      ciSignature* declared_signature = NULL;\n+      ciSignature* declared_signature = nullptr;\n@@ -1114,1 +1114,1 @@\n-      assert(declared_signature != NULL, \"cannot be null\");\n+      assert(declared_signature != nullptr, \"cannot be null\");\n@@ -1221,1 +1221,1 @@\n-  if (akls != NULL)  return akls;\n+  if (akls != nullptr)  return akls;\n@@ -1223,1 +1223,1 @@\n-  return _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+  return _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -1231,1 +1231,1 @@\n-  if (alloc == NULL) {\n+  if (alloc == nullptr) {\n@@ -1261,2 +1261,2 @@\n-\/\/ Helper function to do a NULL pointer check.  Returned value is\n-\/\/ the incoming address with NULL casted away.  You are allowed to use the\n+\/\/ Helper function to do a null pointer check.  Returned value is\n+\/\/ the incoming address with null casted away.  You are allowed to use the\n@@ -1274,1 +1274,1 @@\n-  assert(!assert_null || null_control == NULL, \"not both at once\");\n+  assert(!assert_null || null_control == nullptr, \"not both at once\");\n@@ -1296,1 +1296,1 @@\n-    bool do_replace_in_map = (null_control == NULL || (*null_control) == top());\n+    bool do_replace_in_map = (null_control == nullptr || (*null_control) == top());\n@@ -1300,2 +1300,2 @@\n-  \/\/ Construct NULL check\n-  Node *chk = NULL;\n+  \/\/ Construct null check\n+  Node *chk = nullptr;\n@@ -1312,1 +1312,1 @@\n-      if (tp != NULL && !tp->is_loaded()\n+      if (tp != nullptr && !tp->is_loaded()\n@@ -1314,1 +1314,1 @@\n-          && !assert_null && null_control == NULL) {\n+          && !assert_null && null_control == nullptr) {\n@@ -1344,2 +1344,2 @@\n-        \/\/ See if mixing in the NULL pointer changes type.\n-        \/\/ If so, then the NULL pointer was not allowed in the original\n+        \/\/ See if mixing in the null pointer changes type.\n+        \/\/ If so, then the null pointer was not allowed in the original\n@@ -1360,1 +1360,1 @@\n-  assert(chk != NULL, \"sanity check\");\n+  assert(chk != nullptr, \"sanity check\");\n@@ -1393,1 +1393,1 @@\n-      if (cfg == NULL)  break;  \/\/ Quit at region nodes\n+      if (cfg == nullptr)  break;  \/\/ Quit at region nodes\n@@ -1418,1 +1418,1 @@\n-  if (null_control != NULL || too_many_traps(reason)) {\n+  if (null_control != nullptr || too_many_traps(reason)) {\n@@ -1423,1 +1423,1 @@\n-             method() != NULL &&\n+             method() != nullptr &&\n@@ -1429,1 +1429,1 @@\n-  if (null_control != NULL) {\n+  if (null_control != nullptr) {\n@@ -1448,1 +1448,1 @@\n-                    NULL, \"assert_null\");\n+                    nullptr, \"assert_null\");\n@@ -1470,1 +1470,1 @@\n-    if (null_control == NULL || (*null_control) == top())\n+    if (null_control == nullptr || (*null_control) == top())\n@@ -1575,1 +1575,1 @@\n-  debug_only( map()->set_memory((Node*)NULL) );\n+  debug_only( map()->set_memory((Node*)nullptr) );\n@@ -1611,1 +1611,1 @@\n-  const TypePtr* adr_type = NULL; \/\/ debug-mode-only argument\n+  const TypePtr* adr_type = nullptr; \/\/ debug-mode-only argument\n@@ -1633,1 +1633,1 @@\n-  const TypePtr* adr_type = NULL;\n+  const TypePtr* adr_type = nullptr;\n@@ -1665,1 +1665,1 @@\n-  \/\/ Transformation of a value which could be NULL pointer (CastPP #NULL)\n+  \/\/ Transformation of a value which could be null pointer (CastPP #null)\n@@ -1676,1 +1676,1 @@\n-  assert(val != NULL, \"not dead path\");\n+  assert(val != nullptr, \"not dead path\");\n@@ -1724,1 +1724,1 @@\n-  C2ParseAccess access(this, decorators | C2_READ_ACCESS, bt, NULL, addr);\n+  C2ParseAccess access(this, decorators | C2_READ_ACCESS, bt, nullptr, addr);\n@@ -1943,1 +1943,1 @@\n-  if (call->method() == NULL || call->method()->return_type()->basic_type() == T_VOID) {\n+  if (call->method() == nullptr || call->method()->return_type()->basic_type() == T_VOID) {\n@@ -1974,1 +1974,1 @@\n-  Node* m = narrow_mem == NULL ? memory : narrow_mem;\n+  Node* m = narrow_mem == nullptr ? memory : narrow_mem;\n@@ -1985,1 +1985,1 @@\n-\/\/ If keep_mem is not NULL, use it for the output state,\n+\/\/ If keep_mem is not null, use it for the output state,\n@@ -1987,1 +1987,1 @@\n-\/\/ If hook_mem is NULL, this call produces no memory effects at all.\n+\/\/ If hook_mem is null, this call produces no memory effects at all.\n@@ -2001,1 +2001,1 @@\n-    if (hook_mem != NULL) {\n+    if (hook_mem != nullptr) {\n@@ -2015,1 +2015,1 @@\n-    assert(hook_mem == NULL, \"\");\n+    assert(hook_mem == nullptr, \"\");\n@@ -2036,1 +2036,1 @@\n-  JVMState* ejvms = NULL;\n+  JVMState* ejvms = nullptr;\n@@ -2057,1 +2057,1 @@\n-  if (callprojs->fallthrough_catchproj != NULL) {\n+  if (callprojs->fallthrough_catchproj != nullptr) {\n@@ -2060,1 +2060,1 @@\n-  if (callprojs->fallthrough_memproj != NULL) {\n+  if (callprojs->fallthrough_memproj != nullptr) {\n@@ -2068,1 +2068,1 @@\n-  if (callprojs->fallthrough_ioproj != NULL) {\n+  if (callprojs->fallthrough_ioproj != nullptr) {\n@@ -2073,1 +2073,1 @@\n-  if (callprojs->resproj[0] != NULL && result != NULL) {\n+  if (callprojs->resproj[0] != nullptr && result != nullptr) {\n@@ -2081,1 +2081,1 @@\n-  if (ejvms == NULL) {\n+  if (ejvms == nullptr) {\n@@ -2083,1 +2083,1 @@\n-    if (callprojs->catchall_catchproj != NULL) {\n+    if (callprojs->catchall_catchproj != nullptr) {\n@@ -2086,1 +2086,1 @@\n-    if (callprojs->catchall_memproj != NULL) {\n+    if (callprojs->catchall_memproj != nullptr) {\n@@ -2089,1 +2089,1 @@\n-    if (callprojs->catchall_ioproj != NULL) {\n+    if (callprojs->catchall_ioproj != nullptr) {\n@@ -2093,1 +2093,1 @@\n-    if (callprojs->exobj != NULL) {\n+    if (callprojs->exobj != nullptr) {\n@@ -2105,1 +2105,1 @@\n-    if (callprojs->catchall_catchproj != NULL) {\n+    if (callprojs->catchall_catchproj != nullptr) {\n@@ -2109,1 +2109,1 @@\n-    if (callprojs->catchall_memproj != NULL) {\n+    if (callprojs->catchall_memproj != nullptr) {\n@@ -2114,1 +2114,1 @@\n-    if (callprojs->catchall_ioproj != NULL) {\n+    if (callprojs->catchall_ioproj != nullptr) {\n@@ -2119,1 +2119,1 @@\n-    if (callprojs->exobj != NULL) {\n+    if (callprojs->exobj != nullptr) {\n@@ -2134,1 +2134,1 @@\n-  if (callprojs->fallthrough_catchproj != NULL && !final_ctl->is_top() && do_replaced_nodes) {\n+  if (callprojs->fallthrough_catchproj != nullptr && !final_ctl->is_top() && do_replaced_nodes) {\n@@ -2169,1 +2169,1 @@\n-  if (stopped())  return NULL; \/\/ trap reachable?\n+  if (stopped())  return nullptr; \/\/ trap reachable?\n@@ -2202,1 +2202,1 @@\n-      if (C->log() != NULL) {\n+      if (C->log() != nullptr) {\n@@ -2234,2 +2234,2 @@\n-  if (log != NULL) {\n-    int kid = (klass == NULL)? -1: log->identify(klass);\n+  if (log != nullptr) {\n+    int kid = (klass == nullptr)? -1: log->identify(klass);\n@@ -2241,1 +2241,1 @@\n-    if (comment != NULL)  log->print(\" comment='%s'\", comment);\n+    if (comment != nullptr)  log->print(\" comment='%s'\", comment);\n@@ -2247,1 +2247,1 @@\n-  if (i0 != NULL && i0->is_If()) {        \/\/ Found a guarding if test?\n+  if (i0 != nullptr && i0->is_If()) {        \/\/ Found a guarding if test?\n@@ -2264,1 +2264,1 @@\n-  const TypePtr* no_memory_effects = NULL;\n+  const TypePtr* no_memory_effects = nullptr;\n@@ -2299,1 +2299,1 @@\n-  if (ctrl != NULL && ctrl->is_Region() && ctrl->req() == 2 &&\n+  if (ctrl != nullptr && ctrl->is_Region() && ctrl->req() == 2 &&\n@@ -2306,1 +2306,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2345,1 +2345,1 @@\n-      if (speculative != NULL) {\n+      if (speculative != nullptr) {\n@@ -2389,1 +2389,1 @@\n-    if (data != NULL) {\n+    if (data != nullptr) {\n@@ -2391,2 +2391,2 @@\n-        ciKlass* array_type = NULL;\n-        ciKlass* element_type = NULL;\n+        ciKlass* array_type = nullptr;\n+        ciKlass* element_type = nullptr;\n@@ -2408,1 +2408,1 @@\n-            if (receiver != NULL) {\n+            if (receiver != nullptr) {\n@@ -2438,1 +2438,1 @@\n-      ciKlass* better_type = NULL;\n+      ciKlass* better_type = nullptr;\n@@ -2458,1 +2458,1 @@\n-      ciKlass* better_type = NULL;\n+      ciKlass* better_type = nullptr;\n@@ -2476,1 +2476,1 @@\n-  ciKlass* better_type = NULL;\n+  ciKlass* better_type = nullptr;\n@@ -2535,1 +2535,1 @@\n-\/\/              [in]     NULL\n+\/\/              [in]     null\n@@ -2573,1 +2573,1 @@\n-  \/\/ Initial NULL check taken path\n+  \/\/ Initial null check taken path\n@@ -2580,1 +2580,1 @@\n-    \/\/ recompile; the offending check-cast will be compiled to handle NULLs.\n+    \/\/ recompile; the offending check-cast will be compiled to handle nulls.\n@@ -2582,1 +2582,1 @@\n-    \/\/ method will be compiled to handle NULLs.\n+    \/\/ method will be compiled to handle nulls.\n@@ -2589,1 +2589,1 @@\n-    (*null_control) = top();    \/\/ NULL path is dead\n+    (*null_control) = top();    \/\/ null path is dead\n@@ -2620,1 +2620,1 @@\n-                                  \/\/ The first NULL ends the list.\n+                                  \/\/ The first null ends the list.\n@@ -2625,1 +2625,1 @@\n-  assert(call_addr != NULL, \"must not call NULL targets\");\n+  assert(call_addr != nullptr, \"must not call null targets\");\n@@ -2630,1 +2630,1 @@\n-  if (call_name == NULL) {\n+  if (call_name == nullptr) {\n@@ -2653,1 +2653,1 @@\n-  Node* prev_mem = NULL;\n+  Node* prev_mem = nullptr;\n@@ -2662,9 +2662,9 @@\n-  \/\/ Hook each parm in order.  Stop looking at the first NULL.\n-  if (parm0 != NULL) { call->init_req(TypeFunc::Parms+0, parm0);\n-  if (parm1 != NULL) { call->init_req(TypeFunc::Parms+1, parm1);\n-  if (parm2 != NULL) { call->init_req(TypeFunc::Parms+2, parm2);\n-  if (parm3 != NULL) { call->init_req(TypeFunc::Parms+3, parm3);\n-  if (parm4 != NULL) { call->init_req(TypeFunc::Parms+4, parm4);\n-  if (parm5 != NULL) { call->init_req(TypeFunc::Parms+5, parm5);\n-  if (parm6 != NULL) { call->init_req(TypeFunc::Parms+6, parm6);\n-  if (parm7 != NULL) { call->init_req(TypeFunc::Parms+7, parm7);\n+  \/\/ Hook each parm in order.  Stop looking at the first null.\n+  if (parm0 != nullptr) { call->init_req(TypeFunc::Parms+0, parm0);\n+  if (parm1 != nullptr) { call->init_req(TypeFunc::Parms+1, parm1);\n+  if (parm2 != nullptr) { call->init_req(TypeFunc::Parms+2, parm2);\n+  if (parm3 != nullptr) { call->init_req(TypeFunc::Parms+3, parm3);\n+  if (parm4 != nullptr) { call->init_req(TypeFunc::Parms+4, parm4);\n+  if (parm5 != nullptr) { call->init_req(TypeFunc::Parms+5, parm5);\n+  if (parm6 != nullptr) { call->init_req(TypeFunc::Parms+6, parm6);\n+  if (parm7 != nullptr) { call->init_req(TypeFunc::Parms+7, parm7);\n@@ -2672,1 +2672,1 @@\n-  assert(call->in(call->req()-1) != NULL, \"must initialize all parms\");\n+  assert(call->in(call->req()-1) != nullptr, \"must initialize all parms\");\n@@ -2733,1 +2733,1 @@\n-          phi = PhiNode::make(region, NULL, Type::MEMORY, mms.adr_type(C));\n+          phi = PhiNode::make(region, nullptr, Type::MEMORY, mms.adr_type(C));\n@@ -2788,1 +2788,1 @@\n-  Node* cmp = NULL;\n+  Node* cmp = nullptr;\n@@ -2865,1 +2865,1 @@\n-  Node *chk_off = gvn.transform(new LoadINode(NULL, m, p1, gvn.type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered));\n+  Node *chk_off = gvn.transform(new LoadINode(nullptr, m, p1, gvn.type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered));\n@@ -2873,2 +2873,2 @@\n-  \/\/ Worst-case type is a little odd: NULL is allowed as a result (usually\n-  \/\/ klass loads can never produce a NULL).\n+  \/\/ Worst-case type is a little odd: null is allowed as a result (usually\n+  \/\/ klass loads can never produce a null).\n@@ -2889,1 +2889,1 @@\n-  if (might_be_cache && mem != NULL) {\n+  if (might_be_cache && mem != nullptr) {\n@@ -2892,1 +2892,1 @@\n-  Node *nkls = gvn.transform(LoadKlassNode::make(gvn, NULL, kmem, p2, gvn.type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n+  Node *nkls = gvn.transform(LoadKlassNode::make(gvn, nullptr, kmem, p2, gvn.type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -2975,1 +2975,1 @@\n-  if (sub_t->make_oopptr() != NULL && sub_t->make_oopptr()->is_inlinetypeptr()) {\n+  if (sub_t->make_oopptr() != nullptr && sub_t->make_oopptr()->is_inlinetypeptr()) {\n@@ -3065,1 +3065,1 @@\n-    if (receiver_type != NULL && !receiver_type->higher_equal(recv_type)) { \/\/ ignore redundant casts\n+    if (receiver_type != nullptr && !receiver_type->higher_equal(recv_type)) { \/\/ ignore redundant casts\n@@ -3080,1 +3080,1 @@\n-\/\/ recompile; the offending check will be recompiled to handle NULLs.\n+\/\/ recompile; the offending check will be recompiled to handle nulls.\n@@ -3093,1 +3093,1 @@\n-    if (data == NULL)\n+    if (data == nullptr)\n@@ -3112,1 +3112,1 @@\n-  Node* init_state = LoadNode::make(_gvn, NULL, immutable_memory(), adr,\n+  Node* init_state = LoadNode::make(_gvn, nullptr, immutable_memory(), adr,\n@@ -3131,1 +3131,1 @@\n-  Node* init_thread = LoadNode::make(_gvn, NULL, immutable_memory(), adr,\n+  Node* init_thread = LoadNode::make(_gvn, nullptr, immutable_memory(), adr,\n@@ -3159,1 +3159,1 @@\n-                  NULL);\n+                  nullptr);\n@@ -3170,1 +3170,1 @@\n-  if (!UseTypeProfile || !TypeProfileCasts) return NULL;\n+  if (!UseTypeProfile || !TypeProfileCasts) return nullptr;\n@@ -3172,1 +3172,1 @@\n-  Deoptimization::DeoptReason reason = Deoptimization::reason_class_check(spec_klass != NULL);\n+  Deoptimization::DeoptReason reason = Deoptimization::reason_class_check(spec_klass != nullptr);\n@@ -3176,1 +3176,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3183,1 +3183,1 @@\n-  if (exact_kls == NULL) {\n+  if (exact_kls == nullptr) {\n@@ -3185,2 +3185,2 @@\n-      ciKlass* array_type = NULL;\n-      ciKlass* element_type = NULL;\n+      ciKlass* array_type = nullptr;\n+      ciKlass* element_type = nullptr;\n@@ -3196,2 +3196,2 @@\n-  if (exact_kls != NULL) {\/\/ no cast failures here\n-    if (require_klass == NULL ||\n+  if (exact_kls != nullptr) {\/\/ no cast failures here\n+    if (require_klass == nullptr ||\n@@ -3220,1 +3220,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3238,2 +3238,2 @@\n-  \/\/ type == NULL if profiling tells us this object is always null\n-  if (type != NULL) {\n+  \/\/ type is null if profiling tells us this object is always null\n+  if (type != nullptr) {\n@@ -3245,1 +3245,1 @@\n-      Node* not_null_obj = NULL;\n+      Node* not_null_obj = nullptr;\n@@ -3293,1 +3293,1 @@\n-  ciProfileData* data = NULL;\n+  ciProfileData* data = nullptr;\n@@ -3306,1 +3306,1 @@\n-  if (stopped()) {              \/\/ Doing instance-of on a NULL?\n+  if (stopped()) {              \/\/ Doing instance-of on a null?\n@@ -3325,1 +3325,1 @@\n-    if (subk != NULL && subk->is_loaded()) {\n+    if (subk != nullptr && subk->is_loaded()) {\n@@ -3336,2 +3336,2 @@\n-    if (spec_obj_type != NULL || (ProfileDynamicTypes && data != NULL)) {\n-      Node* cast_obj = maybe_cast_profiled_receiver(not_null_obj, NULL, spec_obj_type, safe_for_replace);\n+    if (spec_obj_type != nullptr || (ProfileDynamicTypes && data != nullptr)) {\n+      Node* cast_obj = maybe_cast_profiled_receiver(not_null_obj, nullptr, spec_obj_type, safe_for_replace);\n@@ -3342,1 +3342,1 @@\n-      if (cast_obj != NULL) {\n+      if (cast_obj != nullptr) {\n@@ -3385,1 +3385,1 @@\n-  bool safe_for_replace = (failure_control == NULL);\n+  bool safe_for_replace = (failure_control == nullptr);\n@@ -3395,1 +3395,1 @@\n-    const TypeKlassPtr* kptr = NULL;\n+    const TypeKlassPtr* kptr = nullptr;\n@@ -3403,1 +3403,1 @@\n-    if (kptr != NULL) {\n+    if (kptr != nullptr) {\n@@ -3422,1 +3422,1 @@\n-        if (t->isa_oopptr() != NULL && !t->is_oopptr()->maybe_null()) {\n+        if (t->isa_oopptr() != nullptr && !t->is_oopptr()->maybe_null()) {\n@@ -3438,2 +3438,2 @@\n-  ciProfileData* data = NULL;\n-  if (failure_control == NULL) {        \/\/ use MDO in regular case only\n+  ciProfileData* data = nullptr;\n+  if (failure_control == nullptr) {        \/\/ use MDO in regular case only\n@@ -3459,1 +3459,1 @@\n-  bool never_see_null = ((failure_control == NULL)  \/\/ regular case only\n+  bool never_see_null = ((failure_control == nullptr)  \/\/ regular case only\n@@ -3471,1 +3471,1 @@\n-  Node* not_null_obj = NULL;\n+  Node* not_null_obj = nullptr;\n@@ -3480,1 +3480,1 @@\n-  if (stopped()) {              \/\/ Doing instance-of on a NULL?\n+  if (stopped()) {              \/\/ Doing instance-of on a null?\n@@ -3497,1 +3497,1 @@\n-  Node* cast_obj = NULL;\n+  Node* cast_obj = nullptr;\n@@ -3507,1 +3507,1 @@\n-    if (spec_obj_type != NULL || data != NULL) {\n+    if (spec_obj_type != nullptr || data != nullptr) {\n@@ -3509,2 +3509,2 @@\n-      if (cast_obj != NULL) {\n-        if (failure_control != NULL) \/\/ failure is now impossible\n+      if (cast_obj != nullptr) {\n+        if (failure_control != nullptr) \/\/ failure is now impossible\n@@ -3518,1 +3518,1 @@\n-  if (cast_obj == NULL) {\n+  if (cast_obj == nullptr) {\n@@ -3525,1 +3525,1 @@\n-    if (failure_control == NULL) {\n+    if (failure_control == nullptr) {\n@@ -3529,1 +3529,1 @@\n-        Node* obj_klass = NULL;\n+        Node* obj_klass = nullptr;\n@@ -3548,1 +3548,1 @@\n-  \/\/ A merge of NULL or Casted-NotNull obj\n+  \/\/ A merge of null or Casted-NotNull obj\n@@ -3570,1 +3570,1 @@\n-    Node* array = NULL;\n+    Node* array = nullptr;\n@@ -3579,1 +3579,1 @@\n-      if (region->req() == 3 && region->in(2) != NULL && region->in(2)->in(0) != NULL) {\n+      if (region->req() == 3 && region->in(2) != nullptr && region->in(2)->in(0) != nullptr) {\n@@ -3581,1 +3581,1 @@\n-        if (iff != NULL) {\n+        if (iff != nullptr) {\n@@ -3586,1 +3586,1 @@\n-    if (array != NULL) {\n+    if (array != nullptr) {\n@@ -3588,1 +3588,1 @@\n-      if (ary_t != NULL) {\n+      if (ary_t != nullptr) {\n@@ -3619,1 +3619,1 @@\n-  Node* mark = make_load(NULL, mark_adr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+  Node* mark = make_load(nullptr, mark_adr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n@@ -3636,1 +3636,1 @@\n-  Node* lh_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lh_adr, lh_adr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n+  Node* lh_val = _gvn.transform(LoadNode::make(_gvn, nullptr, immutable_memory(), lh_adr, lh_adr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n@@ -3753,1 +3753,1 @@\n-    return NULL;                \/\/ Not locking things?\n+    return nullptr;                \/\/ Not locking things?\n@@ -3756,1 +3756,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3856,1 +3856,1 @@\n-\/\/ and return (Node*)NULL.  Otherwise, load the non-constant\n+\/\/ and return null.  Otherwise, load the non-constant\n@@ -3862,1 +3862,1 @@\n-  if (!StressReflectiveCode && inst_klass != NULL) {\n+  if (!StressReflectiveCode && inst_klass != nullptr) {\n@@ -3866,1 +3866,1 @@\n-    if (UseFlatArray && !xklass && ary_type != NULL && !ary_type->is_null_free()) {\n+    if (UseFlatArray && !xklass && ary_type != nullptr && !ary_type->is_null_free()) {\n@@ -3886,1 +3886,1 @@\n-        return (Node*) NULL;\n+        return (Node*) nullptr;\n@@ -3892,1 +3892,1 @@\n-  return make_load(NULL, lhp, TypeInt::INT, T_INT, MemNode::unordered);\n+  return make_load(nullptr, lhp, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -3905,1 +3905,1 @@\n-  if (init_out_raw != NULL) {\n+  if (init_out_raw != nullptr) {\n@@ -3970,1 +3970,1 @@\n-          \/\/ Pass NULL for init_out. Having per flat array element field memory edges as uses of the Initialize node\n+          \/\/ Pass nullptr for init_out. Having per flat array element field memory edges as uses of the Initialize node\n@@ -3973,1 +3973,1 @@\n-          hook_memory_on_init(*this, fieldidx, minit_in, NULL);\n+          hook_memory_on_init(*this, fieldidx, minit_in, nullptr);\n@@ -4042,1 +4042,1 @@\n-  bool  layout_is_con = (layout_val == NULL);\n+  bool  layout_is_con = (layout_val == nullptr);\n@@ -4044,1 +4044,1 @@\n-  if (extra_slow_test == NULL)  extra_slow_test = intcon(0);\n+  if (extra_slow_test == nullptr)  extra_slow_test = intcon(0);\n@@ -4046,1 +4046,1 @@\n-  \/\/ Node for 1) or NEVER (return a NULL) or perhaps (in the reflective\n+  \/\/ Node for 1) or NEVER (return a null) or perhaps (in the reflective\n@@ -4048,1 +4048,1 @@\n-  Node* initial_slow_test = NULL;\n+  Node* initial_slow_test = nullptr;\n@@ -4067,1 +4067,1 @@\n-  Node* size = NULL;\n+  Node* size = nullptr;\n@@ -4079,1 +4079,1 @@\n-  if (return_size_val != NULL) {\n+  if (return_size_val != nullptr) {\n@@ -4116,1 +4116,1 @@\n-  bool  layout_is_con = (layout_val == NULL);\n+  bool  layout_is_con = (layout_val == nullptr);\n@@ -4131,1 +4131,1 @@\n-    layout_val = NULL;\n+    layout_val = nullptr;\n@@ -4158,1 +4158,1 @@\n-  Node* header_size = NULL;\n+  Node* header_size = nullptr;\n@@ -4180,1 +4180,1 @@\n-  Node* elem_shift = NULL;\n+  Node* elem_shift = nullptr;\n@@ -4197,1 +4197,1 @@\n-    if (tilen != NULL && tilen->_lo < 0) {\n+    if (tilen != nullptr && tilen->_lo < 0) {\n@@ -4234,1 +4234,1 @@\n-  if (elem_shift != NULL)\n+  if (elem_shift != nullptr)\n@@ -4243,1 +4243,1 @@\n-  if (return_size_val != NULL) {\n+  if (return_size_val != nullptr) {\n@@ -4270,3 +4270,3 @@\n-  Node* default_value = NULL;\n-  Node* raw_default_value = NULL;\n-  if (ary_ptr != NULL && ary_ptr->klass_is_exact()) {\n+  Node* default_value = nullptr;\n+  Node* raw_default_value = nullptr;\n+  if (ary_ptr != nullptr && ary_ptr->klass_is_exact()) {\n@@ -4308,1 +4308,1 @@\n-  if (default_value != NULL) {\n+  if (default_value != nullptr) {\n@@ -4341,1 +4341,1 @@\n-  if (ary_type->isa_aryptr() && length_type != NULL) {\n+  if (ary_type->isa_aryptr() && length_type != nullptr) {\n@@ -4358,2 +4358,2 @@\n-  if (ptr == NULL) {     \/\/ reduce dumb test in callers\n-    return NULL;\n+  if (ptr == nullptr) {     \/\/ reduce dumb test in callers\n+    return nullptr;\n@@ -4367,1 +4367,1 @@\n-    if (ptr == NULL) return NULL;\n+    if (ptr == nullptr) return nullptr;\n@@ -4369,1 +4369,1 @@\n-  \/\/ Return NULL for allocations with several casts:\n+  \/\/ Return null for allocations with several casts:\n@@ -4375,1 +4375,1 @@\n-    if (allo != NULL && allo->is_Allocate()) {\n+    if (allo != nullptr && allo->is_Allocate()) {\n@@ -4380,1 +4380,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4387,1 +4387,1 @@\n-  if (base == NULL)  return NULL;\n+  if (base == nullptr)  return nullptr;\n@@ -4400,1 +4400,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4406,1 +4406,1 @@\n-  if (rawoop == NULL)  return NULL;\n+  if (rawoop == nullptr)  return nullptr;\n@@ -4414,1 +4414,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4489,1 +4489,1 @@\n-                                                     false, NULL, Type::Offset(0));\n+                                                     false, nullptr, Type::Offset(0));\n@@ -4506,1 +4506,1 @@\n-                                                     false, NULL, Type::Offset(0));\n+                                                     false, nullptr, Type::Offset(0));\n@@ -4518,1 +4518,1 @@\n-                                                     false, NULL, Type::Offset(0));\n+                                                     false, nullptr, Type::Offset(0));\n@@ -4528,1 +4528,1 @@\n-                                                     false, NULL, Type::Offset(0));\n+                                                     false, nullptr, Type::Offset(0));\n@@ -4629,1 +4629,1 @@\n-    return NULL; \/\/ Field not marked as constant.\n+    return nullptr; \/\/ Field not marked as constant.\n@@ -4631,1 +4631,1 @@\n-  ciInstance* holder = NULL;\n+  ciInstance* holder = nullptr;\n@@ -4634,1 +4634,1 @@\n-    if (const_oop != NULL && const_oop->is_instance()) {\n+    if (const_oop != nullptr && const_oop->is_instance()) {\n@@ -4640,1 +4640,1 @@\n-  if (con_type != NULL) {\n+  if (con_type != nullptr) {\n@@ -4649,1 +4649,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4656,1 +4656,1 @@\n-  Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+  Node* load = make_load(nullptr, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":235,"deletions":235,"binary":false,"changes":470,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    assert(_map != NULL, \"must call stopped() to test for reset compiler map\");\n+    assert(_map != nullptr, \"must call stopped() to test for reset compiler map\");\n@@ -85,1 +85,1 @@\n-  GraphKit(JVMState* jvms, PhaseGVN* gvn = NULL);     \/\/ the JVM state on which to operate\n+  GraphKit(JVMState* jvms, PhaseGVN* gvn = nullptr);     \/\/ the JVM state on which to operate\n@@ -93,1 +93,1 @@\n-    assert((_gvn.is_IterGVN() == NULL) || (_gvn.C->for_igvn()->size() == _worklist_size),\n+    assert((_gvn.is_IterGVN() == nullptr) || (_gvn.C->for_igvn()->size() == _worklist_size),\n@@ -98,2 +98,2 @@\n-  virtual Parse*          is_Parse()          const { return NULL; }\n-  virtual LibraryCallKit* is_LibraryCallKit() const { return NULL; }\n+  virtual Parse*          is_Parse()          const { return nullptr; }\n+  virtual LibraryCallKit* is_LibraryCallKit() const { return nullptr; }\n@@ -144,1 +144,1 @@\n-  bool               has_exceptions() const { return _exceptions != NULL; }\n+  bool               has_exceptions() const { return _exceptions != nullptr; }\n@@ -155,1 +155,1 @@\n-                                        _method = jvms->has_method() ? jvms->method() : NULL; }\n+                                        _method = jvms->has_method() ? jvms->method() : nullptr; }\n@@ -194,1 +194,1 @@\n-  \/\/ Set _map to NULL, signalling a stop to further bytecode execution.\n+  \/\/ Set _map to null, signalling a stop to further bytecode execution.\n@@ -196,1 +196,1 @@\n-  SafePointNode* stop() { SafePointNode* m = map(); set_map(NULL); return m; }\n+  SafePointNode* stop() { SafePointNode* m = map(); set_map(nullptr); return m; }\n@@ -198,1 +198,1 @@\n-  \/\/ Stop, but first smash the map's inputs to NULL, to mark it dead.\n+  \/\/ Stop, but first smash the map's inputs to null, to mark it dead.\n@@ -201,1 +201,1 @@\n-  \/\/ Tell if _map is NULL, or control is top.\n+  \/\/ Tell if _map is null, or control is top.\n@@ -233,1 +233,1 @@\n-    if (ex_map != NULL) {\n+    if (ex_map != nullptr) {\n@@ -235,1 +235,1 @@\n-      ex_map->set_next_exception(NULL);\n+      ex_map->set_next_exception(nullptr);\n@@ -258,1 +258,1 @@\n-    if (_exceptions == NULL)  return NULL;\n+    if (_exceptions == nullptr)  return nullptr;\n@@ -261,1 +261,1 @@\n-    while ((ex_map = pop_exception_state()) != NULL) {\n+    while ((ex_map = pop_exception_state()) != nullptr) {\n@@ -365,1 +365,1 @@\n-  \/\/ Helper function to do a NULL pointer check or ZERO check based on type.\n+  \/\/ Helper function to do a null pointer check or ZERO check based on type.\n@@ -371,1 +371,1 @@\n-                          Node* *null_control = NULL,\n+                          Node* *null_control = nullptr,\n@@ -375,1 +375,1 @@\n-    return null_check_common(value, type, false, NULL, !_gvn.type(value)->speculative_maybe_null());\n+    return null_check_common(value, type, false, nullptr, !_gvn.type(value)->speculative_maybe_null());\n@@ -393,1 +393,1 @@\n-    return null_check_common(value, type, true, NULL, _gvn.type(value)->speculative_always_null());\n+    return null_check_common(value, type, true, nullptr, _gvn.type(value)->speculative_always_null());\n@@ -426,1 +426,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -491,1 +491,1 @@\n-    else                   return NULL;\n+    else                   return nullptr;\n@@ -561,1 +561,1 @@\n-    assert(adr_type != NULL, \"use other make_load factory\");\n+    assert(adr_type != nullptr, \"use other make_load factory\");\n@@ -589,1 +589,1 @@\n-    assert(adr_type != NULL, \"use other store_to_memory factory\");\n+    assert(adr_type != nullptr, \"use other store_to_memory factory\");\n@@ -624,1 +624,1 @@\n-                       Node* ctl = NULL);\n+                       Node* ctl = nullptr);\n@@ -674,1 +674,1 @@\n-                              const TypeInt* sizetype = NULL,\n+                              const TypeInt* sizetype = nullptr,\n@@ -676,1 +676,1 @@\n-                              Node* ctrl = NULL);\n+                              Node* ctrl = nullptr);\n@@ -731,1 +731,1 @@\n-    set_predefined_output_for_runtime_call(call, NULL, NULL);\n+    set_predefined_output_for_runtime_call(call, nullptr, nullptr);\n@@ -736,1 +736,1 @@\n-  Node* set_predefined_input_for_runtime_call(SafePointNode* call, Node* narrow_mem = NULL);\n+  Node* set_predefined_input_for_runtime_call(SafePointNode* call, Node* narrow_mem = nullptr);\n@@ -752,1 +752,1 @@\n-                     ciKlass* klass = NULL, const char* reason_string = NULL,\n+                     ciKlass* klass = nullptr, const char* reason_string = nullptr,\n@@ -758,1 +758,1 @@\n-                     ciKlass* klass = NULL, const char* reason_string = NULL,\n+                     ciKlass* klass = nullptr, const char* reason_string = nullptr,\n@@ -767,1 +767,1 @@\n-                           ciKlass* klass = NULL, const char* reason_string = NULL,\n+                           ciKlass* klass = nullptr, const char* reason_string = nullptr,\n@@ -814,5 +814,5 @@\n-                          const TypePtr* adr_type, \/\/ NULL if no memory effects\n-                          Node* parm0 = NULL, Node* parm1 = NULL,\n-                          Node* parm2 = NULL, Node* parm3 = NULL,\n-                          Node* parm4 = NULL, Node* parm5 = NULL,\n-                          Node* parm6 = NULL, Node* parm7 = NULL);\n+                          const TypePtr* adr_type, \/\/ null if no memory effects\n+                          Node* parm0 = nullptr, Node* parm1 = nullptr,\n+                          Node* parm2 = nullptr, Node* parm3 = nullptr,\n+                          Node* parm4 = nullptr, Node* parm5 = nullptr,\n+                          Node* parm6 = nullptr, Node* parm7 = nullptr);\n@@ -840,2 +840,2 @@\n-  Node* insert_mem_bar(int opcode, Node* precedent = NULL);\n-  Node* insert_mem_bar_volatile(int opcode, int alias_idx, Node* precedent = NULL);\n+  Node* insert_mem_bar(int opcode, Node* precedent = nullptr);\n+  Node* insert_mem_bar_volatile(int opcode, int alias_idx, Node* precedent = nullptr);\n@@ -855,1 +855,1 @@\n-  Node* gen_checkcast(Node *subobj, Node* superkls, Node* *failure_control = NULL, bool null_free = false);\n+  Node* gen_checkcast(Node *subobj, Node* superkls, Node* *failure_control = nullptr, bool null_free = false);\n@@ -884,2 +884,2 @@\n-                     Node* slow_test = NULL,\n-                     Node* *return_size_val = NULL,\n+                     Node* slow_test = nullptr,\n+                     Node* *return_size_val = nullptr,\n@@ -887,1 +887,1 @@\n-                     InlineTypeNode* inline_type_node = NULL);\n+                     InlineTypeNode* inline_type_node = nullptr);\n@@ -889,1 +889,1 @@\n-                  Node* *return_size_val = NULL,\n+                  Node* *return_size_val = nullptr,\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-  _cvstate = NULL;\n+  _cvstate = nullptr;\n@@ -50,1 +50,1 @@\n-  assert(_initial_memory == NULL || _initial_memory->Opcode() == Op_MergeMem, \"memory must be pre-split\");\n+  assert(_initial_memory == nullptr || _initial_memory->Opcode() == Op_MergeMem, \"memory must be pre-split\");\n@@ -75,2 +75,2 @@\n-  if (left->bottom_type()->isa_ptr() == NULL) {\n-    if (left->bottom_type()->isa_int() != NULL) {\n+  if (left->bottom_type()->isa_ptr() == nullptr) {\n+    if (left->bottom_type()->isa_int() != nullptr) {\n@@ -79,1 +79,1 @@\n-      assert(left->bottom_type()->isa_long() != NULL, \"what else?\");\n+      assert(left->bottom_type()->isa_long() != nullptr, \"what else?\");\n@@ -207,1 +207,1 @@\n-  assert(_cvstate != NULL, \"must declare variables before labels\");\n+  assert(_cvstate != nullptr, \"must declare variables before labels\");\n@@ -233,1 +233,1 @@\n-  while (slot < reg->req() && reg->in(slot) != NULL) slot++;\n+  while (slot < reg->req() && reg->in(slot) != nullptr) slot++;\n@@ -250,1 +250,1 @@\n-    if (m == NULL) {\n+    if (m == nullptr) {\n@@ -252,1 +252,1 @@\n-    } else if (l == NULL || m == l) {\n+    } else if (l == nullptr || m == l) {\n@@ -331,1 +331,1 @@\n-  for (uint i = 0; i < m->req(); i++) m->set_req(i, NULL);\n+  for (uint i = 0; i < m->req(); i++) m->set_req(i, nullptr);\n@@ -361,1 +361,1 @@\n-  const TypePtr* adr_type = NULL; \/\/ debug-mode-only argument\n+  const TypePtr* adr_type = nullptr; \/\/ debug-mode-only argument\n@@ -373,1 +373,1 @@\n-  const TypePtr* adr_type = NULL;\n+  const TypePtr* adr_type = nullptr;\n@@ -392,1 +392,1 @@\n-  const TypePtr* adr_type = NULL;\n+  const TypePtr* adr_type = nullptr;\n@@ -416,2 +416,2 @@\n-  assert(join_region != NULL, \"join region must exist\");\n-  if (join->in(TypeFunc::I_O) == NULL ) {\n+  assert(join_region != nullptr, \"join region must exist\");\n+  if (join->in(TypeFunc::I_O) == nullptr ) {\n@@ -420,1 +420,1 @@\n-  if (join->in(TypeFunc::Memory) == NULL ) {\n+  if (join->in(TypeFunc::Memory) == nullptr ) {\n@@ -508,4 +508,4 @@\n-  if (parm0 != NULL)  call->init_req(TypeFunc::Parms+0, parm0);\n-  if (parm1 != NULL)  call->init_req(TypeFunc::Parms+1, parm1);\n-  if (parm2 != NULL)  call->init_req(TypeFunc::Parms+2, parm2);\n-  if (parm3 != NULL)  call->init_req(TypeFunc::Parms+3, parm3);\n+  if (parm0 != nullptr)  call->init_req(TypeFunc::Parms+0, parm0);\n+  if (parm1 != nullptr)  call->init_req(TypeFunc::Parms+1, parm1);\n+  if (parm2 != nullptr)  call->init_req(TypeFunc::Parms+2, parm2);\n+  if (parm3 != nullptr)  call->init_req(TypeFunc::Parms+3, parm3);\n@@ -529,1 +529,1 @@\n-  Node* res = NULL;\n+  Node* res = nullptr;\n@@ -560,4 +560,4 @@\n-  if (parm0 != NULL)  call->init_req(TypeFunc::Parms+0, parm0);\n-  if (parm1 != NULL)  call->init_req(TypeFunc::Parms+1, parm1);\n-  if (parm2 != NULL)  call->init_req(TypeFunc::Parms+2, parm2);\n-  if (parm3 != NULL)  call->init_req(TypeFunc::Parms+3, parm3);\n+  if (parm0 != nullptr)  call->init_req(TypeFunc::Parms+0, parm0);\n+  if (parm1 != nullptr)  call->init_req(TypeFunc::Parms+1, parm1);\n+  if (parm2 != nullptr)  call->init_req(TypeFunc::Parms+2, parm2);\n+  if (parm3 != nullptr)  call->init_req(TypeFunc::Parms+3, parm3);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,1 +162,1 @@\n-  void dead(IdealVariable& v)           { set(v, (Node*)NULL); }\n+  void dead(IdealVariable& v)           { set(v, (Node*)nullptr); }\n@@ -252,3 +252,3 @@\n-                       Node* parm1 = NULL,\n-                       Node* parm2 = NULL,\n-                       Node* parm3 = NULL);\n+                       Node* parm1 = nullptr,\n+                       Node* parm2 = nullptr,\n+                       Node* parm3 = nullptr);\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-  if( !i1->is_Bool() ) return NULL;\n+  if( !i1->is_Bool() ) return nullptr;\n@@ -85,1 +85,1 @@\n-  if( !cmp->is_Cmp() ) return NULL;\n+  if( !cmp->is_Cmp() ) return nullptr;\n@@ -87,1 +87,1 @@\n-  if( i1 == NULL || !i1->is_Phi() ) return NULL;\n+  if( i1 == nullptr || !i1->is_Phi() ) return nullptr;\n@@ -90,1 +90,1 @@\n-  if( !con2->is_Con() ) return NULL;\n+  if( !con2->is_Con() ) return nullptr;\n@@ -92,1 +92,1 @@\n-  Node *con1=NULL;\n+  Node *con1=nullptr;\n@@ -96,1 +96,1 @@\n-    if( !con1 ) return NULL;    \/\/ Do not optimize partially collapsed merges\n+    if( !con1 ) return nullptr;    \/\/ Do not optimize partially collapsed merges\n@@ -103,1 +103,1 @@\n-  if( i4 >= phi->req() ) return NULL; \/\/ Found no constants\n+  if( i4 >= phi->req() ) return nullptr; \/\/ Found no constants\n@@ -114,1 +114,1 @@\n-  if( !t->singleton() ) return NULL;\n+  if( !t->singleton() ) return nullptr;\n@@ -119,1 +119,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -125,1 +125,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -142,1 +142,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -148,1 +148,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -160,2 +160,2 @@\n-        if (v->in(0) == NULL) {\n-          return NULL;\n+        if (v->in(0) == nullptr) {\n+          return nullptr;\n@@ -170,3 +170,3 @@\n-      \/\/if( vop == Op_Phi ) {     \/\/ Phi from another merge point might be OK\n-      \/\/  Node *r = v->in(0);     \/\/ Get controlling point\n-      \/\/  if( !r ) return NULL;   \/\/ Degraded to a copy\n+      \/\/if( vop == Op_Phi ) {        \/\/ Phi from another merge point might be OK\n+      \/\/  Node *r = v->in(0);        \/\/ Get controlling point\n+      \/\/  if( !r ) return nullptr;   \/\/ Degraded to a copy\n@@ -193,1 +193,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -201,1 +201,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -208,1 +208,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -217,1 +217,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -246,1 +246,1 @@\n-    if (proj != NULL) {\n+    if (proj != nullptr) {\n@@ -249,1 +249,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -256,1 +256,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -264,1 +264,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -339,2 +339,2 @@\n-  cmp->set_req(1,NULL);  \/\/ Whack the inputs to cmp because it will be dead\n-  cmp->set_req(2,NULL);\n+  cmp->set_req(1,nullptr);  \/\/ Whack the inputs to cmp because it will be dead\n+  cmp->set_req(2,nullptr);\n@@ -343,2 +343,2 @@\n-  Node *phi_s = NULL;     \/\/ do not construct unless needed\n-  Node *phi_f = NULL;     \/\/ do not construct unless needed\n+  Node *phi_s = nullptr;     \/\/ do not construct unless needed\n+  Node *phi_f = nullptr;     \/\/ do not construct unless needed\n@@ -349,1 +349,1 @@\n-    Node *proj = NULL;\n+    Node *proj = nullptr;\n@@ -362,1 +362,1 @@\n-    guarantee(proj != NULL, \"sanity\");\n+    guarantee(proj != nullptr, \"sanity\");\n@@ -366,1 +366,1 @@\n-      if( phi_s == NULL ) {\n+      if( phi_s == nullptr ) {\n@@ -378,1 +378,1 @@\n-      if( phi_f == NULL ) {\n+      if( phi_f == nullptr ) {\n@@ -434,1 +434,1 @@\n-      r->set_req(0, NULL);\n+      r->set_req(0, nullptr);\n@@ -455,1 +455,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -458,1 +458,1 @@\n-  if (b == NULL || !b->is_Bool())  return NULL;\n+  if (b == nullptr || !b->is_Bool())  return nullptr;\n@@ -461,2 +461,2 @@\n-  if (cmp == NULL)  return NULL;\n-  if (cmp->Opcode() != Op_CmpU)  return NULL;\n+  if (cmp == nullptr)  return nullptr;\n+  if (cmp->Opcode() != Op_CmpU)  return nullptr;\n@@ -472,1 +472,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -474,2 +474,2 @@\n-  if (l->is_top())  return NULL;   \/\/ Top input means dead test\n-  if (r->Opcode() != Op_LoadRange && !is_RangeCheck())  return NULL;\n+  if (l->is_top())  return nullptr;   \/\/ Top input means dead test\n+  if (r->Opcode() != Op_LoadRange && !is_RangeCheck())  return nullptr;\n@@ -488,1 +488,1 @@\n-\/\/ offset.  Return 2 if we had to negate the test.  Index is NULL if the check\n+\/\/ offset.  Return 2 if we had to negate the test.  Index is null if the check\n@@ -492,2 +492,2 @@\n-  Node* l = NULL;\n-  Node* r = NULL;\n+  Node* l = nullptr;\n+  Node* r = nullptr;\n@@ -496,1 +496,1 @@\n-  if (iftrap == NULL) {\n+  if (iftrap == nullptr) {\n@@ -504,1 +504,1 @@\n-  if (iftrap->is_uncommon_trap_proj(Deoptimization::Reason_range_check) == NULL) {\n+  if (iftrap->is_uncommon_trap_proj(Deoptimization::Reason_range_check) == nullptr) {\n@@ -521,1 +521,1 @@\n-    ind = NULL;\n+    ind = nullptr;\n@@ -566,1 +566,1 @@\n-\/\/ Walk up the dominator tree one step.  Return NULL at root or true\n+\/\/ Walk up the dominator tree one step.  Return null at root or true\n@@ -579,1 +579,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -582,1 +582,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -601,1 +601,1 @@\n-    if (din3 != NULL && din3 == din4 && din3->is_If()) \/\/ Regions not degraded to a copy\n+    if (din3 != nullptr && din3 == din4 && din3->is_If()) \/\/ Regions not degraded to a copy\n@@ -606,1 +606,1 @@\n-  return NULL;                  \/\/ Dead loop?  Or hit root?\n+  return nullptr;                  \/\/ Dead loop?  Or hit root?\n@@ -623,1 +623,1 @@\n-          if (cmp2_t != NULL) {\n+          if (cmp2_t != nullptr) {\n@@ -631,1 +631,1 @@\n-              if (val_t != NULL && !val_t->singleton() && cmp2_t->is_con()) {\n+              if (val_t != nullptr && !val_t->singleton() && cmp2_t->is_con()) {\n@@ -639,1 +639,1 @@\n-              return NULL;\n+              return nullptr;\n@@ -672,1 +672,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -715,1 +715,1 @@\n-  return in(1) != NULL &&\n+  return in(1) != nullptr &&\n@@ -717,1 +717,1 @@\n-    in(1)->in(1) != NULL &&\n+    in(1)->in(1) != nullptr &&\n@@ -719,1 +719,1 @@\n-    in(1)->in(1)->in(2) != NULL &&\n+    in(1)->in(1)->in(2) != nullptr &&\n@@ -728,1 +728,1 @@\n-  return ctrl != NULL &&\n+  return ctrl != nullptr &&\n@@ -730,1 +730,1 @@\n-    ctrl->in(0) != NULL &&\n+    ctrl->in(0) != nullptr &&\n@@ -735,1 +735,1 @@\n-    ctrl->in(0)->in(1)->in(1)->in(1) != NULL &&\n+    ctrl->in(0)->in(1)->in(1)->in(1) != nullptr &&\n@@ -744,3 +744,3 @@\n-  RegionNode* region = (otherproj_ctrl_use != NULL && otherproj_ctrl_use->is_Region()) ? otherproj_ctrl_use->as_Region() : NULL;\n-  success = NULL;\n-  fail = NULL;\n+  RegionNode* region = (otherproj_ctrl_use != nullptr && otherproj_ctrl_use->is_Region()) ? otherproj_ctrl_use->as_Region() : nullptr;\n+  success = nullptr;\n+  fail = nullptr;\n@@ -748,1 +748,1 @@\n-  if (otherproj->outcnt() == 1 && region != NULL && !region->has_phi()) {\n+  if (otherproj->outcnt() == 1 && region != nullptr && !region->has_phi()) {\n@@ -751,1 +751,1 @@\n-      if (success == NULL && proj->outcnt() == 1 && proj->unique_out() == region) {\n+      if (success == nullptr && proj->outcnt() == 1 && proj->unique_out() == region) {\n@@ -753,1 +753,1 @@\n-      } else if (fail == NULL) {\n+      } else if (fail == nullptr) {\n@@ -756,1 +756,1 @@\n-        success = fail = NULL;\n+        success = fail = nullptr;\n@@ -760,1 +760,1 @@\n-  return success != NULL && fail != NULL;\n+  return success != nullptr && fail != nullptr;\n@@ -775,1 +775,1 @@\n-  if ((dom_caller == NULL) != (caller == NULL)) {\n+  if ((dom_caller == nullptr) != (caller == nullptr)) {\n@@ -779,1 +779,1 @@\n-  } else if (dom_caller != NULL && !dom_caller->same_calls_as(caller)) {\n+  } else if (dom_caller != nullptr && !dom_caller->same_calls_as(caller)) {\n@@ -799,1 +799,1 @@\n-    if (call != NULL) {\n+    if (call != nullptr) {\n@@ -803,1 +803,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -811,1 +811,1 @@\n-  if (otherproj->outcnt() == 1 && dom_unc != NULL) {\n+  if (otherproj->outcnt() == 1 && dom_unc != nullptr) {\n@@ -817,1 +817,1 @@\n-    CallStaticJavaNode* unc = NULL;\n+    CallStaticJavaNode* unc = nullptr;\n@@ -819,1 +819,1 @@\n-    if (unc_proj != NULL && unc_proj->outcnt() == 1) {\n+    if (unc_proj != nullptr && unc_proj->outcnt() == 1) {\n@@ -826,1 +826,1 @@\n-        assert(r->has_phi() == NULL, \"simple region shouldn't have a phi\");\n+        assert(r->has_phi() == nullptr, \"simple region shouldn't have a phi\");\n@@ -896,2 +896,2 @@\n-  Node* adjusted_lim = NULL;\n-  if (lo_type != NULL && hi_type != NULL && hi_type->_lo > lo_type->_hi &&\n+  Node* adjusted_lim = nullptr;\n+  if (lo_type != nullptr && hi_type != nullptr && hi_type->_lo > lo_type->_hi &&\n@@ -942,1 +942,1 @@\n-  } else if (lo_type != NULL && hi_type != NULL && lo_type->_lo > hi_type->_hi &&\n+  } else if (lo_type != nullptr && hi_type != nullptr && lo_type->_lo > hi_type->_hi &&\n@@ -1002,1 +1002,1 @@\n-    if (failtype != NULL) {\n+    if (failtype != nullptr) {\n@@ -1004,1 +1004,1 @@\n-      if (type2 != NULL) {\n+      if (type2 != nullptr) {\n@@ -1014,2 +1014,2 @@\n-    lo = NULL;\n-    hi = NULL;\n+    lo = nullptr;\n+    hi = nullptr;\n@@ -1023,1 +1023,1 @@\n-    if (adjusted_lim == NULL) {\n+    if (adjusted_lim == nullptr) {\n@@ -1097,2 +1097,2 @@\n-  Node* l = NULL;\n-  Node* r = NULL;\n+  Node* l = nullptr;\n+  Node* r = nullptr;\n@@ -1100,1 +1100,1 @@\n-  if (success->in(0)->as_If()->range_check_trap_proj(flip_test, l, r) != NULL) {\n+  if (success->in(0)->as_If()->range_check_trap_proj(flip_test, l, r) != nullptr) {\n@@ -1155,1 +1155,1 @@\n-        for (int i = 0; i < 10 && ctrl != NULL && ctrl != fail; i++) {\n+        for (int i = 0; i < 10 && ctrl != nullptr && ctrl != fail; i++) {\n@@ -1185,1 +1185,1 @@\n-      } else if (use->in(0) == NULL && (igvn->type(use)->isa_long() ||\n+      } else if (use->in(0) == nullptr && (igvn->type(use)->isa_long() ||\n@@ -1200,3 +1200,3 @@\n-  if (in(1) != NULL &&\n-      in(1)->in(1) != NULL &&\n-      in(1)->in(1)->in(2) != NULL) {\n+  if (in(1) != nullptr &&\n+      in(1)->in(1) != nullptr &&\n+      in(1)->in(1)->in(2) != nullptr) {\n@@ -1205,3 +1205,3 @@\n-        ((other->in(0) != NULL && other->in(0) == proj) ||\n-         (other->in(0) == NULL &&\n-          other->in(2) != NULL &&\n+        ((other->in(0) != nullptr && other->in(0) == proj) ||\n+         (other->in(0) == nullptr &&\n+          other->in(2) != nullptr &&\n@@ -1209,1 +1209,1 @@\n-          other->in(2)->in(1) != NULL &&\n+          other->in(2)->in(1) != nullptr &&\n@@ -1220,2 +1220,2 @@\n-  if (other->in(MemNode::Address) != NULL &&\n-      proj->in(0)->in(1) != NULL &&\n+  if (other->in(MemNode::Address) != nullptr &&\n+      proj->in(0)->in(1) != nullptr &&\n@@ -1223,1 +1223,1 @@\n-      proj->in(0)->in(1)->in(1) != NULL &&\n+      proj->in(0)->in(1)->in(1) != nullptr &&\n@@ -1225,1 +1225,1 @@\n-      proj->in(0)->in(1)->in(1)->in(2) != NULL &&\n+      proj->in(0)->in(1)->in(1)->in(2) != nullptr &&\n@@ -1253,1 +1253,1 @@\n-  if (proj == NULL) {\n+  if (proj == nullptr) {\n@@ -1257,1 +1257,1 @@\n-  if (unc != NULL && proj->outcnt() <= 2) {\n+  if (unc != nullptr && proj->outcnt() <= 2) {\n@@ -1263,1 +1263,1 @@\n-      assert(dom_unc != NULL, \"is_uncommon_trap_if_pattern returned NULL\");\n+      assert(dom_unc != nullptr, \"is_uncommon_trap_if_pattern returned null\");\n@@ -1318,1 +1318,1 @@\n-  if (Opcode() != Op_If) return NULL;\n+  if (Opcode() != Op_If) return nullptr;\n@@ -1325,2 +1325,2 @@\n-      ProjNode* success = NULL;\n-      ProjNode* fail = NULL;\n+      ProjNode* success = nullptr;\n+      ProjNode* fail = nullptr;\n@@ -1338,5 +1338,5 @@\n-      return NULL;\n-    } else if (ctrl->in(0) != NULL &&\n-               ctrl->in(0)->in(0) != NULL) {\n-      ProjNode* success = NULL;\n-      ProjNode* fail = NULL;\n+      return nullptr;\n+    } else if (ctrl->in(0) != nullptr &&\n+               ctrl->in(0)->in(0) != nullptr) {\n+      ProjNode* success = nullptr;\n+      ProjNode* fail = nullptr;\n@@ -1359,1 +1359,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1368,1 +1368,1 @@\n-  if( !i1->is_Bool() ) return NULL;\n+  if( !i1->is_Bool() ) return nullptr;\n@@ -1372,1 +1372,1 @@\n-  if( cmp->Opcode() != Op_CmpI ) return NULL;\n+  if( cmp->Opcode() != Op_CmpI ) return nullptr;\n@@ -1378,1 +1378,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1382,1 +1382,1 @@\n-  if( !i1->is_Phi() ) return NULL;\n+  if( !i1->is_Phi() ) return nullptr;\n@@ -1385,1 +1385,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1389,1 +1389,1 @@\n-  if( true_path == 0 ) return NULL;\n+  if( true_path == 0 ) return nullptr;\n@@ -1394,1 +1394,1 @@\n-  if (phi->in(0)->in(1)->in(0) == iff) return NULL;\n+  if (phi->in(0)->in(1)->in(0) == iff) return nullptr;\n@@ -1403,1 +1403,1 @@\n-  else if( bol->_test._test != BoolTest::eq ) return NULL;\n+  else if( bol->_test._test != BoolTest::eq ) return nullptr;\n@@ -1410,1 +1410,1 @@\n-    if( phi2_t != TypeInt::ONE ) return NULL;\n+    if( phi2_t != TypeInt::ONE ) return nullptr;\n@@ -1414,2 +1414,2 @@\n-    if( phi1_t != TypeInt::ONE  ) return NULL;\n-    if( phi2_t != TypeInt::ZERO ) return NULL;\n+    if( phi1_t != TypeInt::ONE  ) return nullptr;\n+    if( phi2_t != TypeInt::ZERO ) return nullptr;\n@@ -1439,1 +1439,1 @@\n-  if (!can_reshape)  return NULL;\n+  if (!can_reshape)  return nullptr;\n@@ -1442,1 +1442,1 @@\n-  if (in(0)->is_top())  return NULL;\n+  if (in(0)->is_top())  return nullptr;\n@@ -1444,1 +1444,1 @@\n-  if (in(1)->is_top())  return NULL;\n+  if (in(1)->is_top())  return nullptr;\n@@ -1446,1 +1446,1 @@\n-  if (in(1)->is_Con())  return NULL;\n+  if (in(1)->is_Con())  return nullptr;\n@@ -1448,1 +1448,1 @@\n-  if (outcnt() < 2)  return NULL;\n+  if (outcnt() < 2)  return nullptr;\n@@ -1452,1 +1452,1 @@\n-  if (idt_if != NULL)  return idt_if;\n+  if (idt_if != nullptr)  return idt_if;\n@@ -1457,1 +1457,1 @@\n-  if (s != NULL)  return s;\n+  if (s != nullptr)  return s;\n@@ -1477,1 +1477,1 @@\n-  if (in(0) == NULL) return NULL;     \/\/ Dead loop?\n+  if (in(0) == nullptr) return nullptr;     \/\/ Dead loop?\n@@ -1481,1 +1481,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1490,1 +1490,1 @@\n-        cmp->in(2) != NULL && \/\/ make sure cmp is not already dead\n+        cmp->in(2) != nullptr && \/\/ make sure cmp is not already dead\n@@ -1498,1 +1498,1 @@\n-  if (prev_dom != NULL) {\n+  if (prev_dom != nullptr) {\n@@ -1524,2 +1524,2 @@\n-  if (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != NULL ||\n-      unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != NULL) {\n+  if (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != nullptr ||\n+      unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != nullptr) {\n@@ -1580,1 +1580,1 @@\n-    if (dist < 0) return NULL;\n+    if (dist < 0) return nullptr;\n@@ -1585,1 +1585,1 @@\n-    if (!dom) return NULL;\n+    if (!dom) return nullptr;\n@@ -1590,1 +1590,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1594,1 +1594,1 @@\n-  if (dist > 2) { \/\/ Add to count of NULL checks elided\n+  if (dist > 2) { \/\/ Add to count of null checks elided\n@@ -1638,1 +1638,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1642,1 +1642,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1646,1 +1646,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1650,1 +1650,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1654,1 +1654,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1657,1 +1657,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1665,1 +1665,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1669,1 +1669,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1746,1 +1746,1 @@\n-      if (head != NULL && head->is_BaseCountedLoop() && head->in(LoopNode::LoopBackControl) == this) {\n+      if (head != nullptr && head->is_BaseCountedLoop() && head->in(LoopNode::LoopBackControl) == this) {\n@@ -1771,1 +1771,1 @@\n-  assert(iff->in(0) != NULL, \"If must be live\");\n+  assert(iff->in(0) != nullptr, \"If must be live\");\n@@ -1773,1 +1773,1 @@\n-  if (iff->outcnt() != 2)  return NULL; \/\/ Malformed projections.\n+  if (iff->outcnt() != 2)  return nullptr; \/\/ Malformed projections.\n@@ -1780,2 +1780,2 @@\n-  if (iff->is_BaseCountedLoopEnd())  return NULL;\n-  if (!iff->in(1)->is_Bool())  return NULL; \/\/ Happens for partially optimized IF tests\n+  if (iff->is_BaseCountedLoopEnd())  return nullptr;\n+  if (!iff->in(1)->is_Bool())  return nullptr; \/\/ Happens for partially optimized IF tests\n@@ -1786,1 +1786,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1791,1 +1791,1 @@\n-  if( !new_b->is_Bool() ) return NULL;\n+  if( !new_b->is_Bool() ) return nullptr;\n@@ -1865,1 +1865,1 @@\n-        if (dom == this) return NULL; \/\/ dead loop\n+        if (dom == this) return nullptr; \/\/ dead loop\n@@ -1902,1 +1902,1 @@\n-      if (!phase->C->allow_range_check_smearing())  return NULL;\n+      if (!phase->C->allow_range_check_smearing())  return nullptr;\n@@ -1906,1 +1906,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1913,1 +1913,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1934,1 +1934,1 @@\n-              return NULL;\n+              return nullptr;\n@@ -1981,2 +1981,2 @@\n-    if (prev_dom == NULL) {\n-      return NULL;\n+    if (prev_dom == nullptr) {\n+      return nullptr;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":165,"deletions":165,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-\/\/ i.e. will grab into the base of the heap if it represents NULL.\n+\/\/ i.e. will grab into the base of the heap if it represents null.\n@@ -46,1 +46,1 @@\n-  if (CompressedOops::base() != NULL) { \/\/ Implies UseCompressedOops.\n+  if (CompressedOops::base() != nullptr) { \/\/ Implies UseCompressedOops.\n@@ -50,1 +50,1 @@\n-        \/\/ decode NULL to point to the heap base (Decode_NN).\n+        \/\/ decode null to point to the heap base (Decode_NN).\n@@ -81,2 +81,2 @@\n-\/\/ Detect implicit-null-check opportunities.  Basically, find NULL checks\n-\/\/ with suitable memory ops nearby.  Use the memory op to do the NULL check.\n+\/\/ Detect implicit-null-check opportunities.  Basically, find null checks\n+\/\/ with suitable memory ops nearby.  Use the memory op to do the null check.\n@@ -153,1 +153,1 @@\n-  assert(!is_decoden || (val->in(0) == NULL) && val->is_Mach() &&\n+  assert(!is_decoden || (val->in(0) == nullptr) && val->is_Mach() &&\n@@ -158,1 +158,1 @@\n-  MachNode *best = NULL;        \/\/ Best found so far\n+  MachNode *best = nullptr;        \/\/ Best found so far\n@@ -227,1 +227,1 @@\n-        if (oper == NULL || oper == (MachOper*)-1) {\n+        if (oper == nullptr || oper == (MachOper*)-1) {\n@@ -250,1 +250,1 @@\n-    if (ctrl != NULL && !(ctrl == not_null_block->head() ||\n+    if (ctrl != nullptr && !(ctrl == not_null_block->head() ||\n@@ -258,1 +258,1 @@\n-      const TypePtr *adr_type = NULL;  \/\/ Do not need this return value here\n+      const TypePtr *adr_type = nullptr;  \/\/ Do not need this return value here\n@@ -260,1 +260,1 @@\n-      if (base == NULL || base == NodeSentinel) {\n+      if (base == nullptr || base == NodeSentinel) {\n@@ -361,1 +361,1 @@\n-      continue;                 \/\/ Already being used as a NULL check\n+      continue;                 \/\/ Already being used as a null check\n@@ -365,1 +365,1 @@\n-    if (best == NULL || get_block_for_node(mach)->_dom_depth < get_block_for_node(best)->_dom_depth) {\n+    if (best == nullptr || get_block_for_node(mach)->_dom_depth < get_block_for_node(best)->_dom_depth) {\n@@ -371,1 +371,1 @@\n-  if (best == NULL) {\n+  if (best == nullptr) {\n@@ -443,1 +443,1 @@\n-  \/\/ Don't change it in other cases: NULL or dominating control.\n+  \/\/ Don't change it in other cases: null or dominating control.\n@@ -445,1 +445,1 @@\n-  if (ctrl != NULL && get_block_for_node(ctrl) == not_null_block) {\n+  if (ctrl != nullptr && get_block_for_node(ctrl) == not_null_block) {\n@@ -463,4 +463,4 @@\n-  \/\/   (IfTrue  (If (Bool NE (CmpP ptr NULL))))\n-  \/\/   (IfFalse (If (Bool EQ (CmpP ptr NULL))))\n-  \/\/ NULL checks are always branch-if-eq.  If we see a IfTrue projection\n-  \/\/ then we are replacing a 'ne' test with a 'eq' NULL check test.\n+  \/\/   (IfTrue  (If (Bool NE (CmpP ptr null))))\n+  \/\/   (IfFalse (If (Bool EQ (CmpP ptr null))))\n+  \/\/ null checks are always branch-if-eq.  If we see a IfTrue projection\n+  \/\/ then we are replacing a 'ne' test with a 'eq' null check test.\n@@ -474,1 +474,1 @@\n-    Node *tmp = new Node(C->top()); \/\/ Use not NULL input\n+    Node *tmp = new Node(C->top()); \/\/ Use not null input\n@@ -478,1 +478,1 @@\n-    tmp->destruct(NULL);\n+    tmp->destruct(nullptr);\n@@ -494,1 +494,1 @@\n-    old_tst->set_req(i3, NULL);\n+    old_tst->set_req(i3, nullptr);\n@@ -553,1 +553,1 @@\n-  bool block_size_threshold_ok = (recalc_pressure_nodes != NULL) && (block->number_of_nodes() > 10);\n+  bool block_size_threshold_ok = (recalc_pressure_nodes != nullptr) && (block->number_of_nodes() > 10);\n@@ -723,1 +723,1 @@\n-    if (src_n == NULL) continue;\n+    if (src_n == nullptr) continue;\n@@ -783,1 +783,1 @@\n-        _regalloc->lower_pressure(block, 0, lrg_src, NULL, _regalloc->_sched_int_pressure, _regalloc->_sched_float_pressure);\n+        _regalloc->lower_pressure(block, 0, lrg_src, nullptr, _regalloc->_sched_int_pressure, _regalloc->_sched_float_pressure);\n@@ -785,1 +785,1 @@\n-        _regalloc->lower_pressure(block, 0, lrg_src, NULL, _regalloc->_scratch_int_pressure, _regalloc->_scratch_float_pressure);\n+        _regalloc->lower_pressure(block, 0, lrg_src, nullptr, _regalloc->_scratch_int_pressure, _regalloc->_scratch_float_pressure);\n@@ -833,1 +833,1 @@\n-  Node* call = NULL;\n+  Node* call = nullptr;\n@@ -843,1 +843,1 @@\n-  if (call == NULL)  return;    \/\/ No next call (e.g., block end is near)\n+  if (call == nullptr)  return;    \/\/ No next call (e.g., block end is near)\n@@ -914,1 +914,1 @@\n-  const char *save_policy = NULL;\n+  const char *save_policy = nullptr;\n@@ -984,1 +984,1 @@\n-  bool block_size_threshold_ok = (recalc_pressure_nodes != NULL) && (block->number_of_nodes() > 10);\n+  bool block_size_threshold_ok = (recalc_pressure_nodes != nullptr) && (block->number_of_nodes() > 10);\n@@ -1030,1 +1030,1 @@\n-            if (oop_store != NULL) {\n+            if (oop_store != nullptr) {\n@@ -1050,1 +1050,1 @@\n-        if (x != NULL && get_block_for_node(x) == block && n->find_prec_edge(x) != -1) {\n+        if (x != nullptr && get_block_for_node(x) == block && n->find_prec_edge(x) != -1) {\n@@ -1287,1 +1287,1 @@\n-  Node *fixup = NULL;\n+  Node *fixup = nullptr;\n@@ -1312,1 +1312,1 @@\n-          fixup = NULL;\n+          fixup = nullptr;\n@@ -1319,1 +1319,1 @@\n-    if (fixup == NULL) {\n+    if (fixup == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -81,4 +81,4 @@\n-    is_available = compiler != NULL && compiler->is_intrinsic_supported(mh, is_virtual) &&\n-                   !C->directive()->is_intrinsic_disabled(mh) &&\n-                   !vmIntrinsics::is_disabled_by_flags(mh);\n-\n+    is_available = compiler != nullptr && compiler->is_intrinsic_available(mh, C->directive());\n+    if (is_available && is_virtual) {\n+      is_available = vmIntrinsics::does_virtual_dispatch(id);\n+    }\n@@ -95,1 +95,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -168,1 +168,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -202,1 +202,1 @@\n-    return slow_ctl; \/\/ Could be NULL if the check folds.\n+    return slow_ctl; \/\/ Could be null if the check folds.\n@@ -227,1 +227,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -816,2 +816,2 @@\n-\/\/ or NULL if it is obvious that the slow path can never be taken.\n-\/\/ Also, if region and the slow control are not NULL, the slow edge\n+\/\/ or null if it is obvious that the slow path can never be taken.\n+\/\/ Also, if region and the slow control are not null, the slow edge\n@@ -822,1 +822,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -829,1 +829,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -837,1 +837,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -840,1 +840,1 @@\n-  if (region != NULL)\n+  if (region != nullptr)\n@@ -859,1 +859,1 @@\n-    return NULL;                \/\/ already stopped\n+    return nullptr;                \/\/ already stopped\n@@ -861,1 +861,1 @@\n-    return NULL;                \/\/ index is already adequately typed\n+    return nullptr;                \/\/ index is already adequately typed\n@@ -865,1 +865,1 @@\n-  if (is_neg != NULL && pos_index != NULL) {\n+  if (is_neg != nullptr && pos_index != nullptr) {\n@@ -893,1 +893,1 @@\n-    return NULL;                \/\/ already stopped\n+    return nullptr;                \/\/ already stopped\n@@ -896,1 +896,1 @@\n-    return NULL;                \/\/ common case of whole-array copy\n+    return nullptr;                \/\/ common case of whole-array copy\n@@ -944,1 +944,1 @@\n-      ? LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(),\n+      ? LoadNode::make(_gvn, nullptr, immutable_memory(), p, p->bottom_type()->is_ptr(),\n@@ -946,1 +946,1 @@\n-      : make_load(NULL, p, p->bottom_type()->is_ptr(), T_ADDRESS, MemNode::unordered));\n+      : make_load(nullptr, p, p->bottom_type()->is_ptr(), T_ADDRESS, MemNode::unordered));\n@@ -974,1 +974,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n@@ -992,1 +992,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1048,2 +1048,2 @@\n-    Node* if_ne = generate_slow_guard(bol, NULL);\n-    if (if_ne != NULL) {\n+    Node* if_ne = generate_slow_guard(bol, nullptr);\n+    if (if_ne != nullptr) {\n@@ -1202,1 +1202,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1248,1 +1248,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1254,2 +1254,2 @@\n-    Node* if_lt = generate_slow_guard(bol, NULL);\n-    if (if_lt != NULL) {\n+    Node* if_lt = generate_slow_guard(bol, nullptr);\n+    if (if_lt != nullptr) {\n@@ -1281,2 +1281,2 @@\n-  Node* if_gt = generate_slow_guard(bol, NULL);\n-  if (if_gt != NULL) {\n+  Node* if_gt = generate_slow_guard(bol, nullptr);\n+  if (if_gt != nullptr) {\n@@ -1290,2 +1290,2 @@\n-    Node* if_zero = generate_slow_guard(bol, NULL);\n-    if (if_zero != NULL) {\n+    Node* if_zero = generate_slow_guard(bol, nullptr);\n+    if (if_zero != nullptr) {\n@@ -1299,1 +1299,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1347,2 +1347,2 @@\n-  Node* if_lt = generate_slow_guard(bol, NULL);\n-  if (if_lt != NULL) {\n+  Node* if_lt = generate_slow_guard(bol, nullptr);\n+  if (if_lt != nullptr) {\n@@ -1423,1 +1423,1 @@\n-  Node* count = NULL;\n+  Node* count = nullptr;\n@@ -1430,1 +1430,1 @@\n-  if (alloc != NULL) {\n+  if (alloc != nullptr) {\n@@ -1473,1 +1473,1 @@\n-  Node* newcopy = NULL;\n+  Node* newcopy = nullptr;\n@@ -1507,1 +1507,1 @@\n-    guarantee(alloc != NULL, \"created above\");\n+    guarantee(alloc != nullptr, \"created above\");\n@@ -1607,1 +1607,1 @@\n-    if (alloc != NULL) {\n+    if (alloc != nullptr) {\n@@ -1640,1 +1640,1 @@\n-  Node* ch = is_store ? argument(2) : NULL;\n+  Node* ch = is_store ? argument(2) : nullptr;\n@@ -1684,1 +1684,1 @@\n-      n = _gvn.transform(new RoundDoubleNode(NULL, n));\n+      n = _gvn.transform(new RoundDoubleNode(nullptr, n));\n@@ -1701,1 +1701,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -1725,1 +1725,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -1746,1 +1746,1 @@\n-  Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : NULL;\n+  Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : nullptr;\n@@ -1748,1 +1748,1 @@\n-  const TypePtr* no_memory_effects = NULL;\n+  const TypePtr* no_memory_effects = nullptr;\n@@ -1751,1 +1751,1 @@\n-                                 a, top(), b, b ? top() : NULL);\n+                                 a, top(), b, b ? top() : nullptr);\n@@ -1766,1 +1766,1 @@\n-  if (d != NULL) {\n+  if (d != nullptr) {\n@@ -1786,1 +1786,1 @@\n-      Node* if_pow = generate_slow_guard(test, NULL);\n+      Node* if_pow = generate_slow_guard(test, nullptr);\n@@ -1791,1 +1791,1 @@\n-      if (if_pow != NULL) {\n+      if (if_pow != nullptr) {\n@@ -1793,1 +1793,1 @@\n-        address target = StubRoutines::dpow() != NULL ? StubRoutines::dpow() :\n+        address target = StubRoutines::dpow() != nullptr ? StubRoutines::dpow() :\n@@ -1795,1 +1795,1 @@\n-        const TypePtr* no_memory_effects = NULL;\n+        const TypePtr* no_memory_effects = nullptr;\n@@ -1816,1 +1816,1 @@\n-  return StubRoutines::dpow() != NULL ?\n+  return StubRoutines::dpow() != nullptr ?\n@@ -1825,1 +1825,1 @@\n-    return StubRoutines::dsin() != NULL ?\n+    return StubRoutines::dsin() != nullptr ?\n@@ -1829,1 +1829,1 @@\n-    return StubRoutines::dcos() != NULL ?\n+    return StubRoutines::dcos() != nullptr ?\n@@ -1833,1 +1833,1 @@\n-    return StubRoutines::dtan() != NULL ?\n+    return StubRoutines::dtan() != nullptr ?\n@@ -1837,1 +1837,1 @@\n-    return StubRoutines::dexp() != NULL ?\n+    return StubRoutines::dexp() != nullptr ?\n@@ -1841,1 +1841,1 @@\n-    return StubRoutines::dlog() != NULL ?\n+    return StubRoutines::dlog() != nullptr ?\n@@ -1845,1 +1845,1 @@\n-    return StubRoutines::dlog10() != NULL ?\n+    return StubRoutines::dlog10() != nullptr ?\n@@ -1888,1 +1888,1 @@\n-  Node* call = make_runtime_call(RC_NO_LEAF, ftype, func, NULL, TypeRawPtr::BOTTOM, argument(0));\n+  Node* call = make_runtime_call(RC_NO_LEAF, ftype, func, nullptr, TypeRawPtr::BOTTOM, argument(0));\n@@ -1977,1 +1977,1 @@\n-  Node* result_val = NULL;\n+  Node* result_val = nullptr;\n@@ -1997,2 +1997,2 @@\n-  if (base != NULL)  base_type = _gvn.type(base)->isa_ptr();\n-  if (base_type == NULL) {\n+  if (base != nullptr)  base_type = _gvn.type(base)->isa_ptr();\n+  if (base_type == nullptr) {\n@@ -2002,1 +2002,1 @@\n-    \/\/ Since this is a NULL+long form, we have to switch to a rawptr.\n+    \/\/ Since this is a null+long form, we have to switch to a rawptr.\n@@ -2015,1 +2015,1 @@\n-    if (offset_type != NULL &&\n+    if (offset_type != nullptr &&\n@@ -2025,1 +2025,1 @@\n-    \/\/ Otherwise, it might either be oop+off or NULL+addr.\n+    \/\/ Otherwise, it might either be oop+off or null+addr.\n@@ -2090,1 +2090,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -2116,1 +2116,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -2134,1 +2134,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -2150,1 +2150,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -2198,1 +2198,1 @@\n-  ciKlass* sharpened_klass = NULL;\n+  ciKlass* sharpened_klass = nullptr;\n@@ -2202,1 +2202,1 @@\n-  if (alias_type->field() != NULL) {\n+  if (alias_type->field() != nullptr) {\n@@ -2209,1 +2209,1 @@\n-  const TypeOopPtr* result = NULL;\n+  const TypeOopPtr* result = nullptr;\n@@ -2215,1 +2215,1 @@\n-      if (elem_type != NULL && elem_type->is_loaded()) {\n+      if (elem_type != nullptr && elem_type->is_loaded()) {\n@@ -2224,1 +2224,1 @@\n-  if (result == NULL && sharpened_klass != NULL && sharpened_klass->is_loaded()) {\n+  if (result == nullptr && sharpened_klass != nullptr && sharpened_klass->is_loaded()) {\n@@ -2231,1 +2231,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -2318,1 +2318,1 @@\n-  ciInlineKlass* inline_klass = NULL;\n+  ciInlineKlass* inline_klass = nullptr;\n@@ -2321,1 +2321,1 @@\n-    if (cls == NULL || cls->const_oop() == NULL) {\n+    if (cls == nullptr || cls->const_oop() == nullptr) {\n@@ -2347,1 +2347,1 @@\n-        if (field != NULL) {\n+        if (field != nullptr) {\n@@ -2382,1 +2382,1 @@\n-    if (type != T_OBJECT && (inline_klass == NULL || !inline_klass->has_object_fields())) {\n+    if (type != T_OBJECT && (inline_klass == nullptr || !inline_klass->has_object_fields())) {\n@@ -2393,1 +2393,1 @@\n-  \/\/ Can base be NULL? Otherwise, always on-heap access.\n+  \/\/ Can base be null? Otherwise, always on-heap access.\n@@ -2400,1 +2400,1 @@\n-  Node* val = is_store ? argument(4 + (type == T_PRIMITIVE_OBJECT ? 1 : 0)) : NULL;\n+  Node* val = is_store ? argument(4 + (type == T_PRIMITIVE_OBJECT ? 1 : 0)) : nullptr;\n@@ -2422,1 +2422,1 @@\n-  ciField* field = NULL;\n+  ciField* field = nullptr;\n@@ -2427,1 +2427,1 @@\n-    if (instptr->const_oop() != NULL &&\n+    if (instptr->const_oop() != nullptr &&\n@@ -2435,1 +2435,1 @@\n-    if (field != NULL) {\n+    if (field != nullptr) {\n@@ -2439,1 +2439,1 @@\n-    if (field != NULL && bt == T_PRIMITIVE_OBJECT && !field->is_flattened()) {\n+    if (field != nullptr && bt == T_PRIMITIVE_OBJECT && !field->is_flattened()) {\n@@ -2473,1 +2473,1 @@\n-      if (field == NULL || field->type() != inline_klass) {\n+      if (field == nullptr || field->type() != inline_klass) {\n@@ -2510,1 +2510,1 @@\n-      if (tjp != NULL) {\n+      if (tjp != nullptr) {\n@@ -2514,1 +2514,1 @@\n-      value_type = NULL;\n+      value_type = nullptr;\n@@ -2528,1 +2528,1 @@\n-    Node* p = NULL;\n+    Node* p = nullptr;\n@@ -2531,1 +2531,1 @@\n-    if (heap_base_oop != top() && field != NULL && field->is_constant() && !field->is_flattened() && !mismatched) {\n+    if (heap_base_oop != top() && field != nullptr && field->is_constant() && !field->is_flattened() && !mismatched) {\n@@ -2536,1 +2536,1 @@\n-    if (p == NULL) { \/\/ Could not constant fold the load\n+    if (p == nullptr) { \/\/ Could not constant fold the load\n@@ -2543,1 +2543,1 @@\n-          p = InlineTypeNode::make_from_flattened(this, inline_klass, base, adr, NULL, 0, decorators);\n+          p = InlineTypeNode::make_from_flattened(this, inline_klass, base, adr, nullptr, 0, decorators);\n@@ -2548,1 +2548,1 @@\n-        if (ptr != NULL && ptr->is_inlinetypeptr()) {\n+        if (ptr != nullptr && ptr->is_inlinetypeptr()) {\n@@ -2556,2 +2556,2 @@\n-           heap_base_oop == top() ||                  \/\/ - heap_base_oop is NULL or\n-           (can_access_non_heap && field == NULL))    \/\/ - heap_base_oop is potentially NULL\n+           heap_base_oop == top() ||                  \/\/ - heap_base_oop is null or\n+           (can_access_non_heap && field == nullptr)) \/\/ - heap_base_oop is potentially null\n@@ -2576,1 +2576,1 @@\n-      p = gvn().transform(new CastP2XNode(NULL, p));\n+      p = gvn().transform(new CastP2XNode(nullptr, p));\n@@ -2596,1 +2596,1 @@\n-        val->as_InlineType()->store_flattened(this, base, adr, NULL, 0, decorators);\n+        val->as_InlineType()->store_flattened(this, base, adr, nullptr, 0, decorators);\n@@ -2639,1 +2639,1 @@\n-  if (AllocateNode::Ideal_allocation(vt->get_oop(), &_gvn) == NULL) {\n+  if (AllocateNode::Ideal_allocation(vt->get_oop(), &_gvn) == nullptr) {\n@@ -2767,5 +2767,5 @@\n-  Node* receiver = NULL;\n-  Node* base     = NULL;\n-  Node* offset   = NULL;\n-  Node* oldval   = NULL;\n-  Node* newval   = NULL;\n+  Node* receiver = nullptr;\n+  Node* base     = nullptr;\n+  Node* offset   = nullptr;\n+  Node* oldval   = nullptr;\n+  Node* newval   = nullptr;\n@@ -2789,1 +2789,1 @@\n-      oldval   = NULL;\n+      oldval   = nullptr;\n@@ -2832,1 +2832,1 @@\n-        if (tjp != NULL) {\n+        if (tjp != nullptr) {\n@@ -2857,1 +2857,1 @@\n-    if (oldval != NULL && oldval->is_InlineType()) {\n+    if (oldval != nullptr && oldval->is_InlineType()) {\n@@ -2863,1 +2863,1 @@\n-    if (newval != NULL && newval->is_InlineType()) {\n+    if (newval != nullptr && newval->is_InlineType()) {\n@@ -2870,1 +2870,1 @@\n-    \/\/ Transformation of a value which could be NULL pointer (CastPP #NULL)\n+    \/\/ Transformation of a value which could be null pointer (CastPP #null)\n@@ -2876,1 +2876,1 @@\n-    if (oldval != NULL && _gvn.type(oldval) == TypePtr::NULL_PTR) {\n+    if (oldval != nullptr && _gvn.type(oldval) == TypePtr::NULL_PTR) {\n@@ -2882,1 +2882,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n@@ -2948,1 +2948,1 @@\n-  if (klsptr == NULL) {\n+  if (klsptr == nullptr) {\n@@ -3014,1 +3014,1 @@\n-  Node* kls = load_klass_from_mirror(cls, false, NULL, 0);\n+  Node* kls = load_klass_from_mirror(cls, false, nullptr, 0);\n@@ -3018,1 +3018,1 @@\n-  Node* test = NULL;\n+  Node* test = nullptr;\n@@ -3026,1 +3026,1 @@\n-    Node* inst = make_load(NULL, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);\n+    Node* inst = make_load(nullptr, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);\n@@ -3031,1 +3031,1 @@\n-  Node* obj = NULL;\n+  Node* obj = nullptr;\n@@ -3033,1 +3033,1 @@\n-  if (tkls != NULL && tkls->instance_klass()->is_inlinetype()) {\n+  if (tkls != nullptr && tkls->instance_klass()->is_inlinetype()) {\n@@ -3047,1 +3047,1 @@\n-  const TypePtr* no_memory_effects = NULL;\n+  const TypePtr* no_memory_effects = nullptr;\n@@ -3083,1 +3083,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n@@ -3113,1 +3113,1 @@\n-    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n@@ -3144,2 +3144,2 @@\n- * if (h_event_writer == NULL) {\n- *   return NULL;\n+ * if (h_event_writer == nullptr) {\n+ *   return nullptr;\n@@ -3421,1 +3421,1 @@\n-  result_value->init_req(_false_path, null()); \/\/ return NULL\n+  result_value->init_req(_false_path, null()); \/\/ return null\n@@ -3563,1 +3563,1 @@\n-  Node* junk = NULL;\n+  Node* junk = nullptr;\n@@ -3570,1 +3570,1 @@\n-  Node* junk = NULL;\n+  Node* junk = nullptr;\n@@ -3583,1 +3583,1 @@\n-    = make_load(NULL, p, p->bottom_type()->is_ptr(), T_OBJECT, MemNode::unordered);\n+    = make_load(nullptr, p, p->bottom_type()->is_ptr(), T_OBJECT, MemNode::unordered);\n@@ -3586,1 +3586,1 @@\n-  access_store_at(NULL, thread_obj_handle, adr_type, arr, _gvn.type(arr), T_OBJECT, IN_NATIVE | MO_UNORDERED);\n+  access_store_at(nullptr, thread_obj_handle, adr_type, arr, _gvn.type(arr), T_OBJECT, IN_NATIVE | MO_UNORDERED);\n@@ -3602,1 +3602,1 @@\n-  \/\/ return _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(),\n+  \/\/ return _gvn.transform(LoadNode::make(_gvn, nullptr, immutable_memory(), p, p->bottom_type()->is_ptr(),\n@@ -3604,1 +3604,1 @@\n-  return make_load(NULL, p, p->bottom_type()->is_ptr(), T_ADDRESS, MemNode::unordered);\n+  return make_load(nullptr, p, p->bottom_type()->is_ptr(), T_ADDRESS, MemNode::unordered);\n@@ -3641,1 +3641,1 @@\n-\/\/ If the region is NULL, force never_see_null = true.\n+\/\/ If the region is null, force never_see_null = true.\n@@ -3647,1 +3647,1 @@\n-  if (region == NULL)  never_see_null = true;\n+  if (region == nullptr)  never_see_null = true;\n@@ -3650,1 +3650,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n@@ -3653,1 +3653,1 @@\n-  if (region != NULL) {\n+  if (region != nullptr) {\n@@ -3669,1 +3669,1 @@\n-  Node* mods = make_load(NULL, modp, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* mods = make_load(nullptr, modp, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -3736,1 +3736,1 @@\n-  if (mirror_con == NULL)  return false;  \/\/ cannot happen?\n+  if (mirror_con == nullptr)  return false;  \/\/ cannot happen?\n@@ -3789,1 +3789,1 @@\n-    query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);\n+    query_value = make_load(nullptr, p, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -3794,1 +3794,1 @@\n-    if (generate_interface_guard(kls, region) != NULL)\n+    if (generate_interface_guard(kls, region) != nullptr)\n@@ -3803,1 +3803,1 @@\n-    if (generate_array_guard(kls, region) != NULL)\n+    if (generate_array_guard(kls, region) != nullptr)\n@@ -3816,1 +3816,1 @@\n-    if (generate_hidden_class_guard(kls, region) != NULL)\n+    if (generate_hidden_class_guard(kls, region) != nullptr)\n@@ -3831,1 +3831,1 @@\n-    if (generate_interface_guard(kls, region) != NULL)\n+    if (generate_interface_guard(kls, region) != nullptr)\n@@ -3834,1 +3834,1 @@\n-    if (generate_array_guard(kls, region) != NULL)\n+    if (generate_array_guard(kls, region) != nullptr)\n@@ -3839,1 +3839,1 @@\n-    kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n+    kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -3854,1 +3854,1 @@\n-    query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);\n+    query_value = make_load(nullptr, p, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -3879,1 +3879,1 @@\n-  if (mirror_con == NULL) {\n+  if (mirror_con == nullptr) {\n@@ -3885,1 +3885,1 @@\n-  if (tm != NULL) {\n+  if (tm != nullptr) {\n@@ -3907,1 +3907,1 @@\n-  if (mirror_con == NULL) {\n+  if (mirror_con == nullptr) {\n@@ -3910,1 +3910,1 @@\n-  if (obj == NULL || obj->is_top()) {\n+  if (obj == nullptr || obj->is_top()) {\n@@ -3919,2 +3919,2 @@\n-  if (tm != NULL && tm->is_klass() &&\n-      tp != NULL) {\n+  if (tm != nullptr && tm->is_klass() &&\n+      tp != nullptr) {\n@@ -3960,1 +3960,1 @@\n-  \/\/ Not-subtype or the mirror's klass ptr is NULL (in case it is a primitive).\n+  \/\/ Not-subtype or the mirror's klass ptr is nullptr (in case it is a primitive).\n@@ -3976,2 +3976,2 @@\n-      Node* ctrl_val_mirror = generate_fair_guard(is_val_mirror(mirror), NULL);\n-      if (ctrl_val_mirror != NULL) {\n+      Node* ctrl_val_mirror = generate_fair_guard(is_val_mirror(mirror), nullptr);\n+      if (ctrl_val_mirror != nullptr) {\n@@ -4060,1 +4060,1 @@\n-    Node* kls = LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, adr_type, kls_type);\n+    Node* kls = LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, adr_type, kls_type);\n@@ -4117,1 +4117,1 @@\n-    if (ctl == NULL || ctl == top()) {\n+    if (ctl == nullptr || ctl == top()) {\n@@ -4120,1 +4120,1 @@\n-    } else if (phi->in(i) == NULL) {\n+    } else if (phi->in(i) == nullptr) {\n@@ -4134,1 +4134,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4140,1 +4140,1 @@\n-  if (layout_val == NULL) {\n+  if (layout_val == nullptr) {\n@@ -4152,1 +4152,1 @@\n-      return NULL;                       \/\/ never a branch\n+      return nullptr;                       \/\/ never a branch\n@@ -4155,1 +4155,1 @@\n-      if (region != NULL)\n+      if (region != nullptr)\n@@ -4228,1 +4228,1 @@\n-    CallJavaNode* slow_call = NULL;\n+    CallJavaNode* slow_call = nullptr;\n@@ -4280,1 +4280,1 @@\n-  Node* non_array = generate_non_array_guard(load_object_klass(array), NULL);\n+  Node* non_array = generate_non_array_guard(load_object_klass(array), nullptr);\n@@ -4282,1 +4282,1 @@\n-  if (non_array != NULL) {\n+  if (non_array != nullptr) {\n@@ -4313,1 +4313,1 @@\n-  Node* newcopy = NULL;\n+  Node* newcopy = nullptr;\n@@ -4328,1 +4328,1 @@\n-    Node* klass_node = load_klass_from_mirror(array_type_mirror, false, NULL, 0);\n+    Node* klass_node = load_klass_from_mirror(array_type_mirror, false, nullptr, 0);\n@@ -4345,1 +4345,1 @@\n-                        (orig_t == NULL || (!orig_t->is_not_flat() && (!orig_t->is_flat() || orig_t->elem()->inline_klass()->contains_oops()))) &&\n+                        (orig_t == nullptr || (!orig_t->is_not_flat() && (!orig_t->is_flat() || orig_t->elem()->inline_klass()->contains_oops()))) &&\n@@ -4349,1 +4349,1 @@\n-    if (not_objArray != NULL) {\n+    if (not_objArray != nullptr) {\n@@ -4377,1 +4377,1 @@\n-      if (orig_t != NULL && orig_t->is_flat()) {\n+      if (orig_t != nullptr && orig_t->is_flat()) {\n@@ -4386,1 +4386,1 @@\n-      } else if (UseFlatArray && (orig_t == NULL || !orig_t->is_not_flat()) &&\n+      } else if (UseFlatArray && (orig_t == nullptr || !orig_t->is_not_flat()) &&\n@@ -4392,1 +4392,1 @@\n-        if (orig_t != NULL) {\n+        if (orig_t != nullptr) {\n@@ -4438,1 +4438,1 @@\n-          if (t_original->speculative_type() != NULL) {\n+          if (t_original->speculative_type() != nullptr) {\n@@ -4502,1 +4502,1 @@\n-  Node* target_call = make_load(NULL, entry_addr, TypePtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+  Node* target_call = make_load(nullptr, entry_addr, TypePtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n@@ -4634,1 +4634,1 @@\n-  \/\/ The control of the load must be NULL. Otherwise, the load can move before\n+  \/\/ The control of the load must be null. Otherwise, the load can move before\n@@ -4636,1 +4636,1 @@\n-  Node* no_ctrl = NULL;\n+  Node* no_ctrl = nullptr;\n@@ -4753,1 +4753,1 @@\n-  for (int n = 1; caller_jvms != NULL; caller_jvms = caller_jvms->caller(), n++) {\n+  for (int n = 1; caller_jvms != nullptr; caller_jvms = caller_jvms->caller(), n++) {\n@@ -4810,1 +4810,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n@@ -4912,1 +4912,1 @@\n-  Node* result = NULL;\n+  Node* result = nullptr;\n@@ -4950,1 +4950,1 @@\n-    bool is_prim_array = (addr_t != NULL) && (addr_t->elem() != Type::BOTTOM);\n+    bool is_prim_array = (addr_t != nullptr) && (addr_t->elem() != Type::BOTTOM);\n@@ -5020,1 +5020,1 @@\n-  assert(obj_size != NULL, \"\");\n+  assert(obj_size != nullptr, \"\");\n@@ -5024,1 +5024,1 @@\n-  AllocateNode* alloc = NULL;\n+  AllocateNode* alloc = nullptr;\n@@ -5030,1 +5030,1 @@\n-    guarantee(alloc != NULL && alloc->maybe_set_complete(&_gvn), \"\");\n+    guarantee(alloc != nullptr && alloc->maybe_set_complete(&_gvn), \"\");\n@@ -5041,1 +5041,1 @@\n-  if (alloc != NULL) {\n+  if (alloc != nullptr) {\n@@ -5091,1 +5091,1 @@\n-        obj_type->speculative_type() != NULL &&\n+        obj_type->speculative_type() != nullptr &&\n@@ -5128,2 +5128,2 @@\n-    Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)NULL);\n-    if (array_ctl != NULL) {\n+    Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)nullptr);\n+    if (array_ctl != nullptr) {\n@@ -5138,1 +5138,1 @@\n-          (ary_ptr == NULL || (!ary_ptr->is_not_flat() && (!ary_ptr->is_flat() || ary_ptr->elem()->inline_klass()->contains_oops())))) {\n+          (ary_ptr == nullptr || (!ary_ptr->is_not_flat() && (!ary_ptr->is_flat() || ary_ptr->elem()->inline_klass()->contains_oops())))) {\n@@ -5146,1 +5146,1 @@\n-        Node* obj_size  = NULL;\n+        Node* obj_size  = nullptr;\n@@ -5153,2 +5153,2 @@\n-          Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);\n-          if (is_obja != NULL) {\n+          Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)nullptr);\n+          if (is_obja != nullptr) {\n@@ -5217,1 +5217,1 @@\n-      Node* obj_size  = NULL;\n+      Node* obj_size  = nullptr;\n@@ -5221,1 +5221,1 @@\n-      Node* alloc_obj = new_instance(obj_klass, NULL, &obj_size, \/*deoptimize_on_exception=*\/true);\n+      Node* alloc_obj = new_instance(obj_klass, nullptr, &obj_size, \/*deoptimize_on_exception=*\/true);\n@@ -5265,1 +5265,1 @@\n-  if (alloc != NULL) {\n+  if (alloc != nullptr) {\n@@ -5309,1 +5309,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -5345,1 +5345,1 @@\n-  if (saved_jvms_before_guards != NULL && !stopped()) {\n+  if (saved_jvms_before_guards != nullptr && !stopped()) {\n@@ -5348,1 +5348,1 @@\n-    assert(alloc != NULL, \"only with a tightly coupled allocation\");\n+    assert(alloc != nullptr, \"only with a tightly coupled allocation\");\n@@ -5376,1 +5376,1 @@\n-    Node* prev_cast = NULL;\n+    Node* prev_cast = nullptr;\n@@ -5382,1 +5382,1 @@\n-        if (prev_cast == NULL) {\n+        if (prev_cast == nullptr) {\n@@ -5410,1 +5410,1 @@\n-    if (ary_type->isa_aryptr() && length_type != NULL) {\n+    if (ary_type->isa_aryptr() && length_type != nullptr) {\n@@ -5505,4 +5505,4 @@\n-  \/\/ if alloc == NULL we don't have to worry about a tightly coupled allocation so we can emit all needed guards\n-  \/\/ if saved_jvms_before_guards != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation\n-  \/\/ if saved_jvms_before_guards == NULL and alloc != NULL, we can't emit any guards\n-  bool can_emit_guards = (alloc == NULL || saved_jvms_before_guards != NULL);\n+  \/\/ if alloc == null we don't have to worry about a tightly coupled allocation so we can emit all needed guards\n+  \/\/ if saved_jvms_before_guards is not null (then alloc is not null) then we can handle guards and a tightly coupled allocation\n+  \/\/ if saved_jvms_before_guards is null and alloc is not null, we can't emit any guards\n+  bool can_emit_guards = (alloc == nullptr || saved_jvms_before_guards != nullptr);\n@@ -5524,1 +5524,1 @@\n-  src  = saved_jvms_before_guards != NULL ? null_check_oop(src, &null_ctl, true, true) : null_check(src, T_ARRAY);\n+  src  = saved_jvms_before_guards != nullptr ? null_check_oop(src, &null_ctl, true, true) : null_check(src, T_ARRAY);\n@@ -5529,1 +5529,1 @@\n-    \/\/ if saved_jvms_before_guards == NULL and alloc != NULL, we don't emit any\n+    \/\/ if saved_jvms_before_guards is null and alloc is not null, we don't emit any\n@@ -5547,1 +5547,1 @@\n-  bool has_src = (top_src != NULL && top_src->elem() != Type::BOTTOM);\n+  bool has_src = (top_src != nullptr && top_src->elem() != Type::BOTTOM);\n@@ -5549,1 +5549,1 @@\n-  bool has_dest = (top_dest != NULL && top_dest->elem() != Type::BOTTOM);\n+  bool has_dest = (top_dest != nullptr && top_dest->elem() != Type::BOTTOM);\n@@ -5565,1 +5565,1 @@\n-    ciKlass* src_k = NULL;\n+    ciKlass* src_k = nullptr;\n@@ -5568,1 +5568,1 @@\n-      if (src_k != NULL && src_k->is_array_klass()) {\n+      if (src_k != nullptr && src_k->is_array_klass()) {\n@@ -5573,1 +5573,1 @@\n-    ciKlass* dest_k = NULL;\n+    ciKlass* dest_k = nullptr;\n@@ -5576,1 +5576,1 @@\n-      if (dest_k != NULL && dest_k->is_array_klass()) {\n+      if (dest_k != nullptr && dest_k->is_array_klass()) {\n@@ -5587,1 +5587,1 @@\n-        has_src = (top_src != NULL && top_src->elem() != Type::BOTTOM);\n+        has_src = (top_src != nullptr && top_src->elem() != Type::BOTTOM);\n@@ -5594,1 +5594,1 @@\n-        has_dest = (top_dest != NULL && top_dest->elem() != Type::BOTTOM);\n+        has_dest = (top_dest != nullptr && top_dest->elem() != Type::BOTTOM);\n@@ -5615,2 +5615,2 @@\n-      ciKlass* src_k = NULL;\n-      ciKlass* dest_k = NULL;\n+      ciKlass* src_k = nullptr;\n+      ciKlass* dest_k = nullptr;\n@@ -5619,1 +5619,1 @@\n-        if (src_k != NULL && src_k->is_array_klass()) {\n+        if (src_k != nullptr && src_k->is_array_klass()) {\n@@ -5625,1 +5625,1 @@\n-        if (dest_k != NULL && dest_k->is_array_klass()) {\n+        if (dest_k != nullptr && dest_k->is_array_klass()) {\n@@ -5647,1 +5647,1 @@\n-  if (saved_jvms_before_guards != NULL) {\n+  if (saved_jvms_before_guards != nullptr) {\n@@ -5710,2 +5710,2 @@\n-      assert(top_dest == NULL || !top_dest->is_flat() || top_src->is_flat(), \"src array must be flat\");\n-      if (top_src != NULL && top_src->is_flat()) {\n+      assert(top_dest == nullptr || !top_dest->is_flat() || top_src->is_flat(), \"src array must be flat\");\n+      if (top_src != nullptr && top_src->is_flat()) {\n@@ -5713,1 +5713,1 @@\n-        if (top_dest != NULL && !top_dest->is_flat()) {\n+        if (top_dest != nullptr && !top_dest->is_flat()) {\n@@ -5720,1 +5720,1 @@\n-      } else if (top_src == NULL || !top_src->is_not_flat()) {\n+      } else if (top_src == nullptr || !top_src->is_not_flat()) {\n@@ -5723,1 +5723,1 @@\n-        assert(top_dest == NULL || !top_dest->is_flat(), \"dest array must not be flat\");\n+        assert(top_dest == nullptr || !top_dest->is_flat(), \"dest array must not be flat\");\n@@ -5725,1 +5725,1 @@\n-        if (top_src != NULL) {\n+        if (top_src != nullptr) {\n@@ -5746,1 +5746,1 @@\n-  ArrayCopyNode* ac = ArrayCopyNode::make(this, true, src, src_offset, dest, dest_offset, length, alloc != NULL, negative_length_guard_generated,\n+  ArrayCopyNode* ac = ArrayCopyNode::make(this, true, src, src_offset, dest, dest_offset, length, alloc != nullptr, negative_length_guard_generated,\n@@ -5773,2 +5773,2 @@\n-  if (stopped())             return NULL;  \/\/ no fast path\n-  if (!C->do_aliasing())     return NULL;  \/\/ no MergeMems around\n+  if (stopped())             return nullptr;  \/\/ no fast path\n+  if (!C->do_aliasing())     return nullptr;  \/\/ no MergeMems around\n@@ -5777,1 +5777,1 @@\n-  if (alloc == NULL)  return NULL;\n+  if (alloc == nullptr)  return nullptr;\n@@ -5784,1 +5784,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -5788,1 +5788,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -5795,1 +5795,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -5889,1 +5889,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -5997,1 +5997,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -6044,1 +6044,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -6091,1 +6091,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -6147,1 +6147,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -6197,2 +6197,2 @@\n-  address stubAddr = NULL;\n-  const char* stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char* stubName = nullptr;\n@@ -6201,1 +6201,1 @@\n-  if (stubAddr == NULL) {\n+  if (stubAddr == nullptr) {\n@@ -6262,2 +6262,2 @@\n-  if (obja_t == NULL || obja_t->elem() == Type::BOTTOM ||\n-      objb_t == NULL || objb_t->elem() == Type::BOTTOM ||\n+  if (obja_t == nullptr || obja_t->elem() == Type::BOTTOM ||\n+      objb_t == nullptr || objb_t->elem() == Type::BOTTOM ||\n@@ -6331,1 +6331,1 @@\n-      call_stub_path = generate_guard(bol_gt, NULL, PROB_MIN);\n+      call_stub_path = generate_guard(bol_gt, nullptr, PROB_MIN);\n@@ -6356,1 +6356,1 @@\n-  if (call_stub_path != NULL) {\n+  if (call_stub_path != nullptr) {\n@@ -6527,2 +6527,2 @@\n-  Node* table = load_field_from_object(NULL, \"byteTable\", \"[I\", \/*decorators*\/ IN_HEAP, \/*is_static*\/ true, crc32c_class);\n-  assert (table != NULL, \"wrong version of java.util.zip.CRC32C\");\n+  Node* table = load_field_from_object(nullptr, \"byteTable\", \"[I\", \/*decorators*\/ IN_HEAP, \/*is_static*\/ true, crc32c_class);\n+  assert (table != nullptr, \"wrong version of java.util.zip.CRC32C\");\n@@ -6718,2 +6718,2 @@\n-                                        decorators, \/*is_static*\/ false, NULL);\n-  if (result == NULL) return false;\n+                                        decorators, \/*is_static*\/ false, nullptr);\n+  if (result == nullptr) return false;\n@@ -6741,2 +6741,2 @@\n-                                          decorators, \/*is_static*\/ false, NULL);\n-  if (referent == NULL) return false;\n+                                          decorators, \/*is_static*\/ false, nullptr);\n+  if (referent == nullptr) return false;\n@@ -6773,1 +6773,1 @@\n-  if (fromKls == NULL) {\n+  if (fromKls == nullptr) {\n@@ -6775,1 +6775,1 @@\n-    assert(tinst != NULL, \"obj is null\");\n+    assert(tinst != nullptr, \"obj is null\");\n@@ -6785,2 +6785,2 @@\n-  assert(field != NULL, \"undefined field %s %s %s\", fieldTypeString, fromKls->name()->as_utf8(), fieldName);\n-  if (field == NULL) return (Node *) NULL;\n+  assert(field != nullptr, \"undefined field %s %s %s\", fieldTypeString, fromKls->name()->as_utf8(), fieldName);\n+  if (field == nullptr) return (Node *) nullptr;\n@@ -6821,2 +6821,2 @@\n-                                                 ciInstanceKlass * fromKls \/* NULL *\/) {\n-  if (fromKls == NULL) {\n+                                                 ciInstanceKlass * fromKls \/* nullptr *\/) {\n+  if (fromKls == nullptr) {\n@@ -6824,1 +6824,1 @@\n-    assert(tinst != NULL, \"obj is null\");\n+    assert(tinst != nullptr, \"obj is null\");\n@@ -6836,1 +6836,1 @@\n-  assert(field != NULL, \"undefined field\");\n+  assert(field != nullptr, \"undefined field\");\n@@ -6855,1 +6855,1 @@\n-  address stubAddr = NULL;\n+  address stubAddr = nullptr;\n@@ -6871,1 +6871,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -6892,2 +6892,2 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n-    assert(src_offset != NULL && dest_offset != NULL, \"\");\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"\");\n@@ -6901,1 +6901,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -6913,2 +6913,2 @@\n-  address stubAddr = NULL;\n-  const char *stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char *stubName = nullptr;\n@@ -6930,1 +6930,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -6951,2 +6951,2 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n-    assert(src_offset != NULL && dest_offset != NULL, \"\");\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"\");\n@@ -6963,1 +6963,1 @@\n-  if (embeddedCipherObj == NULL) return false;\n+  if (embeddedCipherObj == nullptr) return false;\n@@ -6967,1 +6967,1 @@\n-  assert(tinst != NULL, \"CBC obj is null\");\n+  assert(tinst != nullptr, \"CBC obj is null\");\n@@ -6980,1 +6980,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -6984,1 +6984,1 @@\n-  if (objRvec == NULL) return false;\n+  if (objRvec == nullptr) return false;\n@@ -7001,2 +7001,2 @@\n-  address stubAddr = NULL;\n-  const char *stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char *stubName = nullptr;\n@@ -7019,1 +7019,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -7037,2 +7037,2 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n-    assert(src_offset != NULL && dest_offset != NULL, \"\");\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"\");\n@@ -7049,1 +7049,1 @@\n-  if (embeddedCipherObj == NULL) return false;\n+  if (embeddedCipherObj == nullptr) return false;\n@@ -7053,1 +7053,1 @@\n-  assert(tinst != NULL, \"ECB obj is null\");\n+  assert(tinst != nullptr, \"ECB obj is null\");\n@@ -7066,1 +7066,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -7085,2 +7085,2 @@\n-  address stubAddr = NULL;\n-  const char *stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char *stubName = nullptr;\n@@ -7091,1 +7091,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -7109,2 +7109,2 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n-    assert(src_offset != NULL && dest_offset != NULL, \"\");\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n+    assert(src_offset != nullptr && dest_offset != nullptr, \"\");\n@@ -7120,1 +7120,1 @@\n-  if (embeddedCipherObj == NULL) return false;\n+  if (embeddedCipherObj == nullptr) return false;\n@@ -7123,1 +7123,1 @@\n-  assert(tinst != NULL, \"CTR obj is null\");\n+  assert(tinst != nullptr, \"CTR obj is null\");\n@@ -7134,1 +7134,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -7137,1 +7137,1 @@\n-  if (obj_counter == NULL) return false;\n+  if (obj_counter == nullptr) return false;\n@@ -7141,1 +7141,1 @@\n-  if (saved_encCounter == NULL) return false;\n+  if (saved_encCounter == nullptr) return false;\n@@ -7165,3 +7165,3 @@\n-  assert (objSessionK != NULL, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n-  if (objSessionK == NULL) {\n-    return (Node *) NULL;\n+  assert (objSessionK != nullptr, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n+  if (objSessionK == nullptr) {\n+    return (Node *) nullptr;\n@@ -7173,2 +7173,2 @@\n-  assert (objAESCryptKey != NULL, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n-  if (objAESCryptKey == NULL) return (Node *) NULL;\n+  assert (objAESCryptKey != nullptr, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n+  if (objAESCryptKey == nullptr) return (Node *) nullptr;\n@@ -7191,1 +7191,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for null already.\n@@ -7204,1 +7204,1 @@\n-  assert(tinst != NULL, \"CBCobj is null\");\n+  assert(tinst != nullptr, \"CBCobj is null\");\n@@ -7226,1 +7226,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -7230,1 +7230,1 @@\n-    return instof_false;  \/\/ even if it is NULL\n+    return instof_false;  \/\/ even if it is null\n@@ -7240,1 +7240,1 @@\n-  Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);\n+  Node* src_dest_conjoint = generate_guard(bool_src_dest, nullptr, PROB_MIN);\n@@ -7257,1 +7257,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for null already.\n@@ -7267,1 +7267,1 @@\n-  assert(tinst != NULL, \"ECBobj is null\");\n+  assert(tinst != nullptr, \"ECBobj is null\");\n@@ -7284,1 +7284,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -7288,1 +7288,1 @@\n-    return instof_false;  \/\/ even if it is NULL\n+    return instof_false;  \/\/ even if it is null\n@@ -7299,1 +7299,1 @@\n-  Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);\n+  Node* src_dest_conjoint = generate_guard(bool_src_dest, nullptr, PROB_MIN);\n@@ -7317,1 +7317,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for null already.\n@@ -7327,1 +7327,1 @@\n-  assert(tinst != NULL, \"CTRobj is null\");\n+  assert(tinst != nullptr, \"CTRobj is null\");\n@@ -7343,1 +7343,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -7345,1 +7345,1 @@\n-  return instof_false; \/\/ even if it is NULL\n+  return instof_false; \/\/ even if it is null\n@@ -7368,1 +7368,1 @@\n-  assert(state_start, \"state is NULL\");\n+  assert(state_start, \"state is null\");\n@@ -7370,1 +7370,1 @@\n-  assert(subkeyH_start, \"subkeyH is NULL\");\n+  assert(subkeyH_start, \"subkeyH is null\");\n@@ -7372,1 +7372,1 @@\n-  assert(data_start, \"data is NULL\");\n+  assert(data_start, \"data is null\");\n@@ -7397,1 +7397,1 @@\n-  assert(state_start, \"state is NULL\");\n+  assert(state_start, \"state is null\");\n@@ -7399,1 +7399,1 @@\n-  assert(result_start, \"result is NULL\");\n+  assert(result_start, \"result is null\");\n@@ -7432,1 +7432,1 @@\n-  assert(src_start, \"source array is NULL\");\n+  assert(src_start, \"source array is null\");\n@@ -7434,1 +7434,1 @@\n-  assert(dest_start, \"destination array is NULL\");\n+  assert(dest_start, \"destination array is null\");\n@@ -7465,1 +7465,1 @@\n-  assert(src_start, \"source array is NULL\");\n+  assert(src_start, \"source array is null\");\n@@ -7467,1 +7467,1 @@\n-  assert(dest_start, \"destination array is NULL\");\n+  assert(dest_start, \"destination array is null\");\n@@ -7501,1 +7501,1 @@\n-  assert(input_start, \"input array is NULL\");\n+  assert(input_start, \"input array is null\");\n@@ -7503,1 +7503,1 @@\n-  assert(acc_start, \"acc array is NULL\");\n+  assert(acc_start, \"acc array is null\");\n@@ -7505,1 +7505,1 @@\n-  assert(r_start, \"r array is NULL\");\n+  assert(r_start, \"r array is null\");\n@@ -7551,2 +7551,2 @@\n-  Node* state = NULL;\n-  Node* block_size = NULL;\n+  Node* state = nullptr;\n+  Node* block_size = nullptr;\n@@ -7587,1 +7587,1 @@\n-    if (block_size == NULL) return false;\n+    if (block_size == nullptr) return false;\n@@ -7593,1 +7593,1 @@\n-  if (state == NULL) return false;\n+  if (state == nullptr) return false;\n@@ -7595,2 +7595,2 @@\n-  assert(stubAddr != NULL, \"Stub is generated\");\n-  if (stubAddr == NULL) return false;\n+  assert(stubAddr != nullptr, \"Stub is generated\");\n+  if (stubAddr == nullptr) return false;\n@@ -7600,1 +7600,1 @@\n-  if (block_size == NULL) {\n+  if (block_size == nullptr) {\n@@ -7624,1 +7624,1 @@\n-  Node* digestBase_obj = argument(0); \/\/ The receiver was checked for NULL already.\n+  Node* digestBase_obj = argument(0); \/\/ The receiver was checked for null already.\n@@ -7643,3 +7643,3 @@\n-  const char* klass_digestBase_name = NULL;\n-  const char* stub_name = NULL;\n-  address     stub_addr = NULL;\n+  const char* klass_digestBase_name = nullptr;\n+  const char* stub_name = nullptr;\n+  address     stub_addr = nullptr;\n@@ -7689,3 +7689,3 @@\n-  if (klass_digestBase_name != NULL) {\n-    assert(stub_addr != NULL, \"Stub is generated\");\n-    if (stub_addr == NULL) return false;\n+  if (klass_digestBase_name != nullptr) {\n+    assert(stub_addr != nullptr, \"Stub is generated\");\n+    if (stub_addr == nullptr) return false;\n@@ -7695,1 +7695,1 @@\n-    assert(tinst != NULL, \"digestBase_obj is not instance???\");\n+    assert(tinst != nullptr, \"digestBase_obj is not instance???\");\n@@ -7716,1 +7716,1 @@\n-  if (state == NULL) return false;\n+  if (state == nullptr) return false;\n@@ -7718,1 +7718,1 @@\n-  Node* block_size = NULL;\n+  Node* block_size = nullptr;\n@@ -7721,1 +7721,1 @@\n-    if (block_size == NULL) return false;\n+    if (block_size == nullptr) return false;\n@@ -7726,1 +7726,1 @@\n-  if (block_size == NULL) {\n+  if (block_size == nullptr) {\n@@ -7748,2 +7748,2 @@\n-  address stubAddr = NULL;\n-  const char *stubName = NULL;\n+  address stubAddr = nullptr;\n+  const char *stubName = nullptr;\n@@ -7753,1 +7753,1 @@\n-  if (stubAddr == NULL) return false;\n+  if (stubAddr == nullptr) return false;\n@@ -7777,2 +7777,2 @@\n-  if (inOfs != NULL || ctOfs != NULL || outOfs != NULL) {\n-    assert(inOfs != NULL && ctOfs != NULL && outOfs != NULL, \"\");\n+  if (inOfs != nullptr || ctOfs != nullptr || outOfs != nullptr) {\n+    assert(inOfs != nullptr && ctOfs != nullptr && outOfs != nullptr, \"\");\n@@ -7793,1 +7793,1 @@\n-  if (embeddedCipherObj == NULL || counter == NULL || subkeyHtbl == NULL || state == NULL) {\n+  if (embeddedCipherObj == nullptr || counter == nullptr || subkeyHtbl == nullptr || state == nullptr) {\n@@ -7798,1 +7798,1 @@\n-  assert(tinst != NULL, \"GCTR obj is null\");\n+  assert(tinst != nullptr, \"GCTR obj is null\");\n@@ -7809,1 +7809,1 @@\n-  if (k_start == NULL) return false;\n+  if (k_start == nullptr) return false;\n@@ -7840,1 +7840,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for null already.\n@@ -7844,1 +7844,1 @@\n-  assert(embeddedCipherObj != NULL, \"embeddedCipherObj is null\");\n+  assert(embeddedCipherObj != nullptr, \"embeddedCipherObj is null\");\n@@ -7850,1 +7850,1 @@\n-  assert(tinst != NULL, \"GCTR obj is null\");\n+  assert(tinst != nullptr, \"GCTR obj is null\");\n@@ -7866,1 +7866,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -7868,1 +7868,1 @@\n-  return instof_false; \/\/ even if it is NULL\n+  return instof_false; \/\/ even if it is null\n@@ -7881,2 +7881,2 @@\n-  assert (digest_state != NULL, \"wrong version of sun.security.provider.MD5\/SHA\/SHA2\/SHA5\/SHA3\");\n-  if (digest_state == NULL) return (Node *) NULL;\n+  assert (digest_state != nullptr, \"wrong version of sun.security.provider.MD5\/SHA\/SHA2\/SHA5\/SHA3\");\n+  if (digest_state == nullptr) return (Node *) nullptr;\n@@ -7892,1 +7892,1 @@\n-  assert (block_size != NULL, \"sanity\");\n+  assert (block_size != nullptr, \"sanity\");\n@@ -7906,1 +7906,1 @@\n-  \/\/ The receiver was checked for NULL already.\n+  \/\/ The receiver was checked for null already.\n@@ -7911,1 +7911,1 @@\n-  assert(tinst != NULL, \"digestBaseObj is null\");\n+  assert(tinst != nullptr, \"digestBaseObj is null\");\n@@ -7914,1 +7914,1 @@\n-  const char* klass_name = NULL;\n+  const char* klass_name = nullptr;\n@@ -7950,2 +7950,2 @@\n-  ciKlass* klass = NULL;\n-  if (klass_name != NULL) {\n+  ciKlass* klass = nullptr;\n+  if (klass_name != nullptr) {\n@@ -7954,1 +7954,1 @@\n-  if ((klass == NULL) || !klass->is_loaded()) {\n+  if ((klass == nullptr) || !klass->is_loaded()) {\n@@ -7965,1 +7965,1 @@\n-  Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);\n+  Node* instof_false = generate_guard(bool_instof, nullptr, PROB_MIN);\n@@ -7967,1 +7967,1 @@\n-  return instof_false;  \/\/ even if it is NULL\n+  return instof_false;  \/\/ even if it is null\n@@ -7972,4 +7972,4 @@\n-  Node *a = NULL;\n-  Node *b = NULL;\n-  Node *c = NULL;\n-  Node* result = NULL;\n+  Node *a = nullptr;\n+  Node *b = nullptr;\n+  Node *c = nullptr;\n+  Node* result = nullptr;\n@@ -8002,1 +8002,1 @@\n-  Node* n = NULL;\n+  Node* n = nullptr;\n@@ -8035,1 +8035,1 @@\n-  if ( md != NULL && md->is_mature() && md->invocation_count() > 0 ) {\n+  if ( md != nullptr && md->is_mature() && md->invocation_count() > 0 ) {\n@@ -8061,3 +8061,3 @@\n-  Node *a = NULL;\n-  Node *b = NULL;\n-  Node *n = NULL;\n+  Node *a = nullptr;\n+  Node *b = nullptr;\n+  Node *n = nullptr;\n@@ -8112,2 +8112,2 @@\n-  const TypeAryPtr* ary = NULL;\n-  ciArray* aobj = NULL;\n+  const TypeAryPtr* ary = nullptr;\n+  ciArray* aobj = nullptr;\n@@ -8115,2 +8115,2 @@\n-      && (ary = counts->bottom_type()->isa_aryptr()) != NULL\n-      && (aobj = ary->const_oop()->as_array()) != NULL\n+      && (ary = counts->bottom_type()->isa_aryptr()) != nullptr\n+      && (aobj = ary->const_oop()->as_array()) != nullptr\n@@ -8122,1 +8122,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -8203,1 +8203,1 @@\n-  int   layout_is_con = (layout_val == NULL);\n+  int   layout_is_con = (layout_val == nullptr);\n@@ -8251,2 +8251,2 @@\n-    Node* array_ctl = generate_array_guard(klass_node, NULL);\n-    if (array_ctl != NULL) {\n+    Node* array_ctl = generate_array_guard(klass_node, nullptr);\n+    if (array_ctl != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":380,"deletions":380,"binary":false,"changes":760,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-      _result(NULL)\n+      _result(nullptr)\n@@ -89,1 +89,1 @@\n-      ciSignature* declared_signature = NULL;\n+      ciSignature* declared_signature = nullptr;\n@@ -110,1 +110,1 @@\n-    if (!stopped() && res != NULL) {\n+    if (!stopped() && res != nullptr) {\n@@ -128,1 +128,1 @@\n-  void  set_result(Node* n) { assert(_result == NULL, \"only set once\"); _result = n; }\n+  void  set_result(Node* n) { assert(_result == nullptr, \"only set once\"); _result = n; }\n@@ -140,1 +140,1 @@\n-                                Node* *pos_index = NULL);\n+                                Node* *pos_index = nullptr);\n@@ -207,2 +207,2 @@\n-  Node* load_field_from_object(Node* fromObj, const char* fieldName, const char* fieldTypeString, DecoratorSet decorators = IN_HEAP, bool is_static = false, ciInstanceKlass* fromKls = NULL);\n-  Node* field_address_from_object(Node* fromObj, const char* fieldName, const char* fieldTypeString, bool is_exact = true, bool is_static = false, ciInstanceKlass* fromKls = NULL);\n+  Node* load_field_from_object(Node* fromObj, const char* fieldName, const char* fieldTypeString, DecoratorSet decorators = IN_HEAP, bool is_static = false, ciInstanceKlass* fromKls = nullptr);\n+  Node* field_address_from_object(Node* fromObj, const char* fieldName, const char* fieldTypeString, bool is_exact = true, bool is_static = false, ciInstanceKlass* fromKls = nullptr);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-  LockNode* lock = NULL;\n+  LockNode* lock = nullptr;\n@@ -99,2 +99,2 @@\n-          if ((unique_lock != NULL) && alock->is_Lock()) {\n-            if (lock == NULL) {\n+          if ((unique_lock != nullptr) && alock->is_Lock()) {\n+            if (lock == nullptr) {\n@@ -105,1 +105,1 @@\n-              if (bad_lock != NULL) {\n+              if (bad_lock != nullptr) {\n@@ -111,1 +111,1 @@\n-          if (bad_lock != NULL) {\n+          if (bad_lock != nullptr) {\n@@ -135,1 +135,1 @@\n-  if (unique_lock != NULL && has_one_lock) {\n+  if (unique_lock != nullptr && has_one_lock) {\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,2 +83,2 @@\n-    _rtm_counters = NULL;\n-    _stack_rtm_counters = NULL;\n+    _rtm_counters = nullptr;\n+    _stack_rtm_counters = nullptr;\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-  if (phase->find_unswitching_candidate(this, unswitch_iffs) == NULL) {\n+  if (phase->find_unswitching_candidate(this, unswitch_iffs) == nullptr) {\n@@ -100,1 +100,1 @@\n-  IfNode* unswitch_iff = NULL;\n+  IfNode* unswitch_iff = nullptr;\n@@ -121,1 +121,1 @@\n-  if (unswitch_iff != NULL) {\n+  if (unswitch_iff != nullptr) {\n@@ -127,1 +127,1 @@\n-  if (unswitch_iff == NULL || unswitch_iff->is_flat_array_check(&_igvn)) {\n+  if (unswitch_iff == nullptr || unswitch_iff->is_flat_array_check(&_igvn)) {\n@@ -130,1 +130,1 @@\n-      if (n != NULL && n != unswitch_iff && n->is_flat_array_check(&_igvn) &&\n+      if (n != nullptr && n != unswitch_iff && n->is_flat_array_check(&_igvn) &&\n@@ -133,1 +133,1 @@\n-        if (unswitch_iff == NULL) {\n+        if (unswitch_iff == nullptr) {\n@@ -150,3 +150,3 @@\n-  if (find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check) != NULL\n-      || (UseProfiledLoopPredicate && find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate) != NULL)\n-      || (UseLoopPredicate && find_predicate_insertion_point(entry, Deoptimization::Reason_predicate) != NULL)) {\n+  if (find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check) != nullptr\n+      || (UseProfiledLoopPredicate && find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate) != nullptr)\n+      || (UseLoopPredicate && find_predicate_insertion_point(entry, Deoptimization::Reason_predicate) != nullptr)) {\n@@ -164,1 +164,1 @@\n-  assert(unswitch_iff != NULL && unswitch_iff == unswitch_iffs.at(0), \"should be at least one\");\n+  assert(unswitch_iff != nullptr && unswitch_iff == unswitch_iffs.at(0), \"should be at least one\");\n@@ -191,1 +191,1 @@\n-  if (predicate == NULL) {\n+  if (predicate == nullptr) {\n@@ -202,1 +202,1 @@\n-      if (predicate != NULL) {\n+      if (predicate != nullptr) {\n@@ -208,1 +208,1 @@\n-      if (predicate != NULL) {\n+      if (predicate != nullptr) {\n@@ -420,3 +420,3 @@\n-  _lp(NULL),\n-  _iff(NULL),\n-  _lp_reserved(NULL),\n+  _lp(nullptr),\n+  _iff(nullptr),\n+  _lp_reserved(nullptr),\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -151,3 +151,3 @@\n-    return req() == 3 && in(0) != NULL &&\n-      in(1) != NULL && phase->type(in(1)) != Type::TOP &&\n-      in(2) != NULL && phase->type(in(2)) != Type::TOP;\n+    return req() == 3 && in(0) != nullptr &&\n+      in(1) != nullptr && phase->type(in(1)) != Type::TOP &&\n+      in(2) != nullptr && phase->type(in(2)) != Type::TOP;\n@@ -162,4 +162,4 @@\n-  virtual IfTrueNode* outer_loop_tail() const { ShouldNotReachHere(); return NULL; }\n-  virtual OuterStripMinedLoopEndNode* outer_loop_end() const { ShouldNotReachHere(); return NULL; }\n-  virtual IfFalseNode* outer_loop_exit() const { ShouldNotReachHere(); return NULL; }\n-  virtual SafePointNode* outer_safepoint() const { ShouldNotReachHere(); return NULL; }\n+  virtual IfTrueNode* outer_loop_tail() const { ShouldNotReachHere(); return nullptr; }\n+  virtual OuterStripMinedLoopEndNode* outer_loop_end() const { ShouldNotReachHere(); return nullptr; }\n+  virtual IfFalseNode* outer_loop_exit() const { ShouldNotReachHere(); return nullptr; }\n+  virtual SafePointNode* outer_safepoint() const { ShouldNotReachHere(); return nullptr; }\n@@ -390,6 +390,6 @@\n-  Node *cmp_node() const            { return (in(TestValue)->req() >=2) ? in(TestValue)->in(1) : NULL; }\n-  Node* incr() const                { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(1) : NULL; }\n-  Node* limit() const               { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(2) : NULL; }\n-  Node* stride() const              { Node* tmp = incr(); return (tmp && tmp->req() == 3) ? tmp->in(2) : NULL; }\n-  Node* init_trip() const           { Node* tmp = phi(); return (tmp && tmp->req() == 3) ? tmp->in(1) : NULL; }\n-  bool stride_is_con() const        { Node *tmp = stride(); return (tmp != NULL && tmp->is_Con()); }\n+  Node *cmp_node() const            { return (in(TestValue)->req() >=2) ? in(TestValue)->in(1) : nullptr; }\n+  Node* incr() const                { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(1) : nullptr; }\n+  Node* limit() const               { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(2) : nullptr; }\n+  Node* stride() const              { Node* tmp = incr(); return (tmp && tmp->req() == 3) ? tmp->in(2) : nullptr; }\n+  Node* init_trip() const           { Node* tmp = phi(); return (tmp && tmp->req() == 3) ? tmp->in(1) : nullptr; }\n+  bool stride_is_con() const        { Node *tmp = stride(); return (tmp != nullptr && tmp->is_Con()); }\n@@ -405,1 +405,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -413,2 +413,2 @@\n-    if (iv_phi == NULL) {\n-      return NULL;\n+    if (iv_phi == nullptr) {\n+      return nullptr;\n@@ -418,1 +418,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -421,1 +421,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -477,1 +477,1 @@\n-  if (bctrl == NULL) return NULL;\n+  if (bctrl == nullptr) return nullptr;\n@@ -481,1 +481,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -485,1 +485,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -492,1 +492,1 @@\n-  assert(cle != NULL, \"loopexit is NULL\");\n+  assert(cle != nullptr, \"loopexit is null\");\n@@ -498,1 +498,1 @@\n-  return cle != NULL ? cle->init_trip() : NULL;\n+  return cle != nullptr ? cle->init_trip() : nullptr;\n@@ -502,1 +502,1 @@\n-  return cle != NULL ? cle->stride() : NULL;\n+  return cle != nullptr ? cle->stride() : nullptr;\n@@ -507,1 +507,1 @@\n-  return cle != NULL && cle->stride_is_con();\n+  return cle != nullptr && cle->stride_is_con();\n@@ -511,1 +511,1 @@\n-  return cle != NULL ? cle->limit() : NULL;\n+  return cle != nullptr ? cle->limit() : nullptr;\n@@ -515,1 +515,1 @@\n-  return cle != NULL ? cle->incr() : NULL;\n+  return cle != nullptr ? cle->incr() : nullptr;\n@@ -519,1 +519,1 @@\n-  return cle != NULL ? cle->phi() : NULL;\n+  return cle != nullptr ? cle->phi() : nullptr;\n@@ -524,1 +524,1 @@\n-  return cle != NULL ? cle->stride_con() : 0;\n+  return cle != nullptr ? cle->stride_con() : 0;\n@@ -637,2 +637,2 @@\n-      _safepts(NULL),\n-      _required_safept(NULL),\n+      _safepts(nullptr),\n+      _required_safept(nullptr),\n@@ -641,2 +641,2 @@\n-    precond(_head != NULL);\n-    precond(_tail != NULL);\n+    precond(_head != nullptr);\n+    precond(_tail != nullptr);\n@@ -768,1 +768,1 @@\n-  bool is_associative(Node* n, Node* base=NULL);\n+  bool is_associative(Node* n, Node* base=nullptr);\n@@ -776,1 +776,1 @@\n-  bool is_root() { return _parent == NULL; }\n+  bool is_root() { return _parent == nullptr; }\n@@ -780,1 +780,1 @@\n-  bool is_innermost() { return is_loop() && _child == NULL; }\n+  bool is_innermost() { return is_loop() && _child == nullptr; }\n@@ -920,2 +920,2 @@\n-    \/\/ Fast-path NULL lca\n-    if( lca != NULL && lca != n ) {\n+    \/\/ Fast-path null lca\n+    if( lca != nullptr && lca != n ) {\n@@ -932,1 +932,1 @@\n-    if (ctrl != NULL) {\n+    if (ctrl != nullptr) {\n@@ -976,2 +976,2 @@\n-    guarantee(n != NULL, \"No Node.\");\n-    return _nodes[n->_idx] != NULL;\n+    guarantee(n != nullptr, \"No Node.\");\n+    return _nodes[n->_idx] != nullptr;\n@@ -996,2 +996,2 @@\n-      if (old_loop->_child == NULL) old_loop->_body.yank(n);\n-      if (new_loop->_child == NULL) new_loop->_body.push(n);\n+      if (old_loop->_child == nullptr) old_loop->_body.yank(n);\n+      if (new_loop->_child == nullptr) new_loop->_body.push(n);\n@@ -1140,2 +1140,2 @@\n-    assert(n != NULL,\"Bad immediate dominator info.\");\n-    while (n->in(0) == NULL) { \/\/ Skip dead CFG nodes\n+    assert(n != nullptr,\"Bad immediate dominator info.\");\n+    while (n->in(0) == nullptr) { \/\/ Skip dead CFG nodes\n@@ -1143,1 +1143,1 @@\n-      assert(n != NULL,\"Bad immediate dominator info.\");\n+      assert(n != nullptr,\"Bad immediate dominator info.\");\n@@ -1159,1 +1159,1 @@\n-    guarantee(d != NULL, \"Null dominator info.\");\n+    guarantee(d != nullptr, \"Null dominator info.\");\n@@ -1209,1 +1209,1 @@\n-  virtual Node* transform(Node* n) { return NULL; }\n+  virtual Node* transform(Node* n) { return nullptr; }\n@@ -1256,1 +1256,1 @@\n-  \/\/   When side_by_size_idom is NULL, the dominator tree is constructed for\n+  \/\/   When side_by_size_idom is null, the dominator tree is constructed for\n@@ -1271,1 +1271,1 @@\n-                  CloneLoopMode mode, Node* side_by_side_idom = NULL);\n+                  CloneLoopMode mode, Node* side_by_side_idom = nullptr);\n@@ -1326,1 +1326,1 @@\n-  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale = NULL, int depth = 0);\n+  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale = nullptr, int depth = 0);\n@@ -1331,1 +1331,1 @@\n-      if (p_scale != NULL) {\n+      if (p_scale != nullptr) {\n@@ -1571,1 +1571,1 @@\n-  void do_split_if(Node *iff, RegionNode** new_false_region = NULL, RegionNode** new_true_region = NULL);\n+  void do_split_if(Node *iff, RegionNode** new_false_region = nullptr, RegionNode** new_true_region = nullptr);\n@@ -1582,1 +1582,1 @@\n-  const TypeInt* filtered_type( Node *n ) { return filtered_type(n, NULL); }\n+  const TypeInt* filtered_type( Node *n ) { return filtered_type(n, nullptr); }\n@@ -1787,1 +1787,1 @@\n-    precond(_phase != NULL);\n+    precond(_phase != nullptr);\n@@ -1886,1 +1886,1 @@\n-  if (_tail->in(0) == NULL) {\n+  if (_tail->in(0) == nullptr) {\n@@ -1894,1 +1894,1 @@\n-  if (_head->in(0) == NULL) {\n+  if (_head->in(0) == nullptr) {\n@@ -1916,1 +1916,1 @@\n-  bool done() { return _curnt == NULL; }       \/\/ Finished iterating?\n+  bool done() { return _curnt == nullptr; }       \/\/ Finished iterating?\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":58,"deletions":58,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -62,1 +62,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -72,1 +72,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -82,1 +82,1 @@\n-  if (t_oop != NULL && t_oop->is_known_instance_field()) {\n+  if (t_oop != nullptr && t_oop->is_known_instance_field()) {\n@@ -86,1 +86,1 @@\n-    phi = new PhiNode(region, type, NULL, iid, index, offset);\n+    phi = new PhiNode(region, type, nullptr, iid, index, offset);\n@@ -93,1 +93,1 @@\n-    Node* the_clone = NULL;\n+    Node* the_clone = nullptr;\n@@ -158,1 +158,1 @@\n-    if (x != the_clone && the_clone != NULL)\n+    if (x != the_clone && the_clone != nullptr)\n@@ -165,1 +165,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -186,2 +186,2 @@\n-      old_ctrl = NULL;\n-      old_loop = NULL;               \/\/ Not in any prior loop\n+      old_ctrl = nullptr;\n+      old_loop = nullptr;               \/\/ Not in any prior loop\n@@ -204,1 +204,1 @@\n-        (old_loop == NULL || !new_loop->is_member(old_loop))) {\n+        (old_loop == nullptr || !new_loop->is_member(old_loop))) {\n@@ -246,1 +246,1 @@\n-  assert(n->in(0) == NULL, \"divisions with zero check should already have bailed out earlier in split-if\");\n+  assert(n->in(0) == nullptr, \"divisions with zero check should already have bailed out earlier in split-if\");\n@@ -302,1 +302,1 @@\n-  if (dp == NULL)\n+  if (dp == nullptr)\n@@ -308,3 +308,3 @@\n-      (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != NULL ||\n-       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != NULL ||\n-       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_range_check) != NULL)) {\n+      (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != nullptr ||\n+       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != nullptr ||\n+       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_range_check) != nullptr)) {\n@@ -355,1 +355,1 @@\n-    return NULL;                \/\/ No Phi inputs; nowhere to clone thru\n+    return nullptr;                \/\/ No Phi inputs; nowhere to clone thru\n@@ -381,1 +381,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -400,1 +400,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -403,2 +403,2 @@\n-    if (scale_t != NULL && scale_t->is_con() && scale_t->get_con() >= 16) {\n-      return NULL;              \/\/ Dont bother with byte\/short masking\n+    if (scale_t != nullptr && scale_t->is_con() && scale_t->get_con() >= 16) {\n+      return nullptr;              \/\/ Dont bother with byte\/short masking\n@@ -411,1 +411,1 @@\n-      return NULL;  \/\/ happens w\/ evil ZKM loops\n+      return nullptr;  \/\/ happens w\/ evil ZKM loops\n@@ -425,1 +425,1 @@\n-    if (add->Opcode() != Op_Add(bt)) return NULL;\n+    if (add->Opcode() != Op_Add(bt)) return nullptr;\n@@ -441,1 +441,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -444,1 +444,1 @@\n-      return NULL;              \/\/ No invariant part of the add?\n+      return nullptr;              \/\/ No invariant part of the add?\n@@ -460,1 +460,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -468,1 +468,1 @@\n-  if (!has_ctrl(n))  return NULL;\n+  if (!has_ctrl(n))  return nullptr;\n@@ -476,1 +476,1 @@\n-  if (n->req() < 3 || n->req() > 4) return NULL;\n+  if (n->req() < 3 || n->req() > 4) return nullptr;\n@@ -489,1 +489,1 @@\n-    return NULL;                \/\/ Leave well enough alone\n+    return nullptr;                \/\/ Leave well enough alone\n@@ -496,1 +496,1 @@\n-    return NULL;                \/\/ No loop-invariant inputs\n+    return nullptr;                \/\/ No loop-invariant inputs\n@@ -500,1 +500,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -504,1 +504,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -568,1 +568,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -574,1 +574,1 @@\n-  Node * nn = NULL;\n+  Node * nn = nullptr;\n@@ -637,1 +637,1 @@\n-  if (region->req() != 3) return NULL;\n+  if (region->req() != 3) return nullptr;\n@@ -642,1 +642,1 @@\n-  if (!lp || !rp) return NULL;\n+  if (!lp || !rp) return nullptr;\n@@ -644,1 +644,1 @@\n-  if (lp_c == NULL || lp_c != rp->in(0) || !lp_c->is_If()) return NULL;\n+  if (lp_c == nullptr || lp_c != rp->in(0) || !lp_c->is_If()) return nullptr;\n@@ -649,2 +649,2 @@\n-  if (lp->outcnt() > 1) return NULL;\n-  if (rp->outcnt() > 1) return NULL;\n+  if (lp->outcnt() > 1) return nullptr;\n+  if (rp->outcnt() > 1) return nullptr;\n@@ -695,1 +695,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -700,1 +700,1 @@\n-      return NULL;              \/\/ In particular, can't do memory or I\/O\n+      return nullptr;              \/\/ In particular, can't do memory or I\/O\n@@ -737,1 +737,1 @@\n-    return NULL; \/\/ Ignore loop predicate checks (the Opaque4 ensures they will go away)\n+    return nullptr; \/\/ Ignore loop predicate checks (the Opaque4 ensures they will go away)\n@@ -742,1 +742,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -746,1 +746,1 @@\n-  if (phis > 1 && (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) return NULL;\n+  if (phis > 1 && (cmp_op == Op_CmpF || cmp_op == Op_CmpD)) return nullptr;\n@@ -751,1 +751,1 @@\n-    if (cost >= ConditionalMoveLimit) return NULL; \/\/ Too much goo\n+    if (cost >= ConditionalMoveLimit) return nullptr; \/\/ Too much goo\n@@ -766,1 +766,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -774,1 +774,1 @@\n-    PhiNode* phi = NULL;\n+    PhiNode* phi = nullptr;\n@@ -782,1 +782,1 @@\n-    if (phi == NULL || _igvn.type(phi) == Type::TOP) {\n+    if (phi == nullptr || _igvn.type(phi) == Type::TOP) {\n@@ -792,1 +792,1 @@\n-        if (m != NULL && !is_dominator(get_ctrl(m), cmov_ctrl)) {\n+        if (m != nullptr && !is_dominator(get_ctrl(m), cmov_ctrl)) {\n@@ -847,1 +847,1 @@\n-      n->in(0) != NULL) {\n+      n->in(0) != nullptr) {\n@@ -877,1 +877,1 @@\n-      assert(n_loop->_tail != NULL, \"need a tail\");\n+      assert(n_loop->_tail != nullptr, \"need a tail\");\n@@ -923,1 +923,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -928,1 +928,1 @@\n-  if (n->is_Store() && n->in(0) != NULL) {\n+  if (n->is_Store() && n->in(0) != nullptr) {\n@@ -940,1 +940,1 @@\n-        Node* phi = NULL;\n+        Node* phi = nullptr;\n@@ -951,1 +951,1 @@\n-              if (phi != NULL) {\n+              if (phi != nullptr) {\n@@ -960,1 +960,1 @@\n-        if (phi != NULL) {\n+        if (phi != nullptr) {\n@@ -1134,1 +1134,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -1153,1 +1153,1 @@\n-    if (dom_cast != NULL && is_dominator(get_ctrl(dom_cast), get_ctrl(n))) {\n+    if (dom_cast != nullptr && is_dominator(get_ctrl(dom_cast), get_ctrl(n))) {\n@@ -1364,1 +1364,1 @@\n-\/\/ Return: NULL if it's not the case, or the exit of outer strip-mined loop\n+\/\/ Return: null if it's not the case, or the exit of outer strip-mined loop\n@@ -1366,1 +1366,1 @@\n-  Node* out_le = NULL;\n+  Node* out_le = nullptr;\n@@ -1371,1 +1371,1 @@\n-      if (loop != NULL && loop->is_strip_mined()) {\n+      if (loop != nullptr && loop->is_strip_mined()) {\n@@ -1518,2 +1518,2 @@\n-      \/\/ Can't split CMove with different control edge.\n-      if (iff->in(0) != NULL && iff->in(0) != n_ctrl ) {\n+      \/\/ Can't split CMove with different control.\n+      if (get_ctrl(iff) != n_ctrl) {\n@@ -1548,1 +1548,1 @@\n-    guarantee(bolphi != NULL, \"null boolean phi node\");\n+    guarantee(bolphi != nullptr, \"null boolean phi node\");\n@@ -1600,1 +1600,1 @@\n-          if (out_le != NULL) {\n+          if (out_le != nullptr) {\n@@ -1746,1 +1746,1 @@\n-  if (cl == NULL) {\n+  if (cl == nullptr) {\n@@ -1752,1 +1752,1 @@\n-  if (cl->is_canonical_loop_entry() == NULL) {\n+  if (cl->is_canonical_loop_entry() == nullptr) {\n@@ -1775,1 +1775,1 @@\n-    if (n->in(0) != NULL) {\n+    if (n->in(0) != nullptr) {\n@@ -1791,1 +1791,1 @@\n-        Node* outer_loop_clone = NULL;\n+        Node* outer_loop_clone = nullptr;\n@@ -1796,1 +1796,1 @@\n-          Node* x_ctrl = NULL;\n+          Node* x_ctrl = nullptr;\n@@ -1839,1 +1839,1 @@\n-              if (outer_loop_clone != NULL) {\n+              if (outer_loop_clone != nullptr) {\n@@ -1846,1 +1846,1 @@\n-          } else if (n->in(0) != NULL){\n+          } else if (n->in(0) != nullptr){\n@@ -1860,1 +1860,1 @@\n-          if (x->in(0) == NULL && !x->is_DecodeNarrowPtr() &&\n+          if (x->in(0) == nullptr && !x->is_DecodeNarrowPtr() &&\n@@ -1864,1 +1864,1 @@\n-            Node* cast = NULL;\n+            Node* cast = nullptr;\n@@ -1867,1 +1867,1 @@\n-              if (in != NULL && n_loop->is_member(get_loop(get_ctrl(in)))) {\n+              if (in != nullptr && n_loop->is_member(get_loop(get_ctrl(in)))) {\n@@ -1871,1 +1871,1 @@\n-              if (cast != NULL) {\n+              if (cast != nullptr) {\n@@ -1881,1 +1881,1 @@\n-                      assert(u->find_out_with(Op_AddP) == NULL, \"more than 2 chained AddP nodes?\");\n+                      assert(u->find_out_with(Op_AddP) == nullptr, \"more than 2 chained AddP nodes?\");\n@@ -1888,1 +1888,1 @@\n-            assert(cast != NULL, \"must have added a cast to pin the node\");\n+            assert(cast != nullptr, \"must have added a cast to pin the node\");\n@@ -1901,1 +1901,1 @@\n-  Node* early_ctrl = NULL;\n+  Node* early_ctrl = nullptr;\n@@ -1907,1 +1907,1 @@\n-    Node* c = NULL;\n+    Node* c = nullptr;\n@@ -1915,1 +1915,1 @@\n-        if (in != NULL) {\n+        if (in != nullptr) {\n@@ -1920,1 +1920,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n@@ -1922,1 +1922,1 @@\n-      if (early_ctrl == NULL || is_dominator(early_ctrl, c)) {\n+      if (early_ctrl == nullptr || is_dominator(early_ctrl, c)) {\n@@ -2044,2 +2044,2 @@\n-  Node* sample_opaque = NULL;\n-  Node *sample_bool = NULL;\n+  Node* sample_opaque = nullptr;\n+  Node *sample_bool = nullptr;\n@@ -2067,2 +2067,2 @@\n-    Node *n1 = sample_opaque == NULL ? phi->in(i)->in(1)->in(1) : phi->in(i)->in(1)->in(1)->in(1);\n-    Node *n2 = sample_opaque == NULL ? phi->in(i)->in(1)->in(2) : phi->in(i)->in(1)->in(1)->in(2);\n+    Node *n1 = sample_opaque == nullptr ? phi->in(i)->in(1)->in(1) : phi->in(i)->in(1)->in(1)->in(1);\n+    Node *n2 = sample_opaque == nullptr ? phi->in(i)->in(1)->in(2) : phi->in(i)->in(1)->in(1)->in(2);\n@@ -2108,1 +2108,1 @@\n-  if (sample_opaque != NULL) {\n+  if (sample_opaque != nullptr) {\n@@ -2219,1 +2219,1 @@\n-    if (loop->_head->as_Loop()->is_strip_mined() && outer_loop->is_member(use_loop) && !loop->is_member(use_loop) && old_new[use->_idx] == NULL) {\n+    if (loop->_head->as_Loop()->is_strip_mined() && outer_loop->is_member(use_loop) && !loop->is_member(use_loop) && old_new[use->_idx] == nullptr) {\n@@ -2324,1 +2324,1 @@\n-        if( hit == NULL ) {\n+        if( hit == nullptr ) {\n@@ -2361,2 +2361,2 @@\n-    assert(check_old_new || old_new[u->_idx] == NULL, \"shouldn't have been cloned\");\n-    if (!u->is_CFG() && (!check_old_new || old_new[u->_idx] == NULL)) {\n+    assert(check_old_new || old_new[u->_idx] == nullptr, \"shouldn't have been cloned\");\n+    if (!u->is_CFG() && (!check_old_new || old_new[u->_idx] == nullptr)) {\n@@ -2373,1 +2373,1 @@\n-          if (u_c != NULL) {\n+          if (u_c != nullptr) {\n@@ -2399,1 +2399,1 @@\n-    Node* new_sfpt = NULL;\n+    Node* new_sfpt = nullptr;\n@@ -2454,1 +2454,1 @@\n-             (n->in(i) == NULL ||\n+             (n->in(i) == nullptr ||\n@@ -2457,1 +2457,1 @@\n-              (old_new[n->in(i)->_idx] != NULL && old_new[n->in(i)->_idx]->_idx >= new_counter))) {\n+              (old_new[n->in(i)->_idx] != nullptr && old_new[n->in(i)->_idx]->_idx >= new_counter))) {\n@@ -2464,1 +2464,1 @@\n-        assert(old_new[n->_idx] == NULL || n == sfpt || old_new[n->_idx]->_idx < new_counter, \"no clone yet\");\n+        assert(old_new[n->_idx] == nullptr || n == sfpt || old_new[n->_idx]->_idx < new_counter, \"no clone yet\");\n@@ -2466,1 +2466,1 @@\n-        if (m != NULL) {\n+        if (m != nullptr) {\n@@ -2468,1 +2468,1 @@\n-            if (m->in(i) != NULL && old_new[m->in(i)->_idx] != NULL) {\n+            if (m->in(i) != nullptr && old_new[m->in(i)->_idx] != nullptr) {\n@@ -2514,1 +2514,1 @@\n-      if (n->in(0) != NULL) {\n+      if (n->in(0) != nullptr) {\n@@ -2546,1 +2546,1 @@\n-\/\/   When side_by_size_idom is NULL, the dominator tree is constructed for\n+\/\/   When side_by_size_idom is null, the dominator tree is constructed for\n@@ -2560,1 +2560,1 @@\n-    if (mname != NULL) {\n+    if (mname != nullptr) {\n@@ -2601,3 +2601,3 @@\n-  Node_List *split_if_set = NULL;\n-  Node_List *split_bool_set = NULL;\n-  Node_List *split_cex_set = NULL;\n+  Node_List *split_if_set = nullptr;\n+  Node_List *split_bool_set = nullptr;\n+  Node_List *split_cex_set = nullptr;\n@@ -2648,1 +2648,1 @@\n-      split_up(b, b->in(0), NULL);\n+      split_up(b, b->in(0), nullptr);\n@@ -2686,1 +2686,1 @@\n-        Node* newuse = NULL;\n+        Node* newuse = nullptr;\n@@ -2702,1 +2702,1 @@\n-        if (newuse == NULL) {\n+        if (newuse == nullptr) {\n@@ -2707,1 +2707,1 @@\n-        if (C->do_vector_loop() && cm != NULL) {\n+        if (C->do_vector_loop() && cm != nullptr) {\n@@ -2760,1 +2760,1 @@\n-        set_idom(r, (side_by_side_idom == NULL) ? newuse->in(0) : side_by_side_idom, dd_r);\n+        set_idom(r, (side_by_side_idom == nullptr) ? newuse->in(0) : side_by_side_idom, dd_r);\n@@ -2778,1 +2778,1 @@\n-        if (old_new[dom->_idx] != NULL) {\n+        if (old_new[dom->_idx] != nullptr) {\n@@ -2787,1 +2787,1 @@\n-        if (n != NULL) {\n+        if (n != nullptr) {\n@@ -2790,1 +2790,1 @@\n-            if (old_new[n->_idx] != NULL) {\n+            if (old_new[n->_idx] != nullptr) {\n@@ -2812,1 +2812,1 @@\n-    if (C->do_vector_loop() && cm != NULL) {\n+    if (C->do_vector_loop() && cm != nullptr) {\n@@ -2826,4 +2826,4 @@\n-  Node* trunc1 = NULL;\n-  Node* trunc2 = NULL;\n-  const TypeInteger* ttype = NULL;\n-  if (!iff->is_If() || iff->in(1) == NULL || !iff->in(1)->is_Bool()) {\n+  Node* trunc1 = nullptr;\n+  Node* trunc2 = nullptr;\n+  const TypeInteger* ttype = nullptr;\n+  if (!iff->is_If() || iff->in(1) == nullptr || !iff->in(1)->is_Bool()) {\n@@ -2841,1 +2841,1 @@\n-  Node* add2 = NULL;\n+  Node* add2 = nullptr;\n@@ -2870,1 +2870,1 @@\n-  if (add2 != NULL) {\n+  if (add2 != nullptr) {\n@@ -2883,2 +2883,2 @@\n-  Node* unique = NULL;\n-  if (!n) return NULL;\n+  Node* unique = nullptr;\n+  if (!n) return nullptr;\n@@ -2888,2 +2888,2 @@\n-      if (unique != NULL) {\n-        return NULL;\n+      if (unique != nullptr) {\n+        return nullptr;\n@@ -2921,1 +2921,1 @@\n-  guarantee(live_proj != NULL, \"null projection\");\n+  guarantee(live_proj != nullptr, \"null projection\");\n@@ -2963,1 +2963,1 @@\n-  proj->set_req(0, NULL);  \/\/ temporary disconnect\n+  proj->set_req(0, nullptr);  \/\/ temporary disconnect\n@@ -2983,1 +2983,1 @@\n-  guarantee(new_exit != NULL, \"null exit node\");\n+  guarantee(new_exit != nullptr, \"null exit node\");\n@@ -3024,1 +3024,1 @@\n-  proj->set_req(0, NULL);  \/\/ temporary disconnect\n+  proj->set_req(0, nullptr);  \/\/ temporary disconnect\n@@ -3032,1 +3032,1 @@\n-  IfNode* dum_if = new IfNode(reg, short_circuit_if(NULL, proj), iff->_prob, iff->_fcnt);\n+  IfNode* dum_if = new IfNode(reg, short_circuit_if(nullptr, proj), iff->_prob, iff->_fcnt);\n@@ -3085,1 +3085,1 @@\n-  if (bol->_test._test != BoolTest::lt) return NULL;\n+  if (bol->_test._test != BoolTest::lt) return nullptr;\n@@ -3087,1 +3087,1 @@\n-  if (cmpu->Opcode() != Op_CmpU) return NULL;\n+  if (cmpu->Opcode() != Op_CmpU) return nullptr;\n@@ -3089,1 +3089,1 @@\n-  if (stride == 0) return NULL;\n+  if (stride == 0) return nullptr;\n@@ -3092,1 +3092,1 @@\n-  guarantee(lp_proj != NULL, \"null loop node\");\n+  guarantee(lp_proj != nullptr, \"null loop node\");\n@@ -3099,1 +3099,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3103,1 +3103,1 @@\n-  Node* limit = NULL;\n+  Node* limit = nullptr;\n@@ -3112,1 +3112,1 @@\n-  guarantee(reg != NULL, \"null region node\");\n+  guarantee(reg != nullptr, \"null region node\");\n@@ -3335,1 +3335,1 @@\n-  if( hit == NULL ) {\n+  if( hit == nullptr ) {\n@@ -3671,2 +3671,2 @@\n-  IfNode *peel_if = NULL;\n-  IfNode *peel_if_cmpu = NULL;\n+  IfNode *peel_if = nullptr;\n+  IfNode *peel_if_cmpu = nullptr;\n@@ -3696,3 +3696,3 @@\n-  IfNode* new_peel_if = NULL;\n-  if (peel_if == NULL) {\n-    if (!PartialPeelAtUnsignedTests || peel_if_cmpu == NULL) {\n+  IfNode* new_peel_if = nullptr;\n+  if (peel_if == nullptr) {\n+    if (!PartialPeelAtUnsignedTests || peel_if_cmpu == nullptr) {\n@@ -3702,1 +3702,1 @@\n-    if (new_peel_if == NULL) {\n+    if (new_peel_if == nullptr) {\n@@ -3709,1 +3709,1 @@\n-  if (first_not_peeled == NULL || first_not_peeled == head) {\n+  if (first_not_peeled == nullptr || first_not_peeled == head) {\n@@ -3816,1 +3816,1 @@\n-          if (n->in(0) == NULL && !n->is_Load() && !n->is_CMove()) {\n+          if (n->in(0) == nullptr && !n->is_Load() && !n->is_CMove()) {\n@@ -3854,1 +3854,1 @@\n-                    new_phi_cnt, old_phi_cnt, new_peel_if != NULL?'T':'F');\n+                    new_phi_cnt, old_phi_cnt, new_peel_if != nullptr?'T':'F');\n@@ -3857,1 +3857,1 @@\n-    if (new_peel_if != NULL) {\n+    if (new_peel_if != nullptr) {\n@@ -3930,1 +3930,1 @@\n-              if (old_new[use->_idx] != NULL) { \/\/ null for dead code\n+              if (old_new[use->_idx] != nullptr) { \/\/ null for dead code\n@@ -3964,1 +3964,1 @@\n-    if (!n->is_CFG()           && n->in(0) != NULL        &&\n+    if (!n->is_CFG()           && n->in(0) != nullptr        &&\n@@ -4095,2 +4095,2 @@\n-  Node* region = NULL;\n-  IfNode* exit_test = NULL;\n+  Node* region = nullptr;\n+  IfNode* exit_test = nullptr;\n@@ -4112,1 +4112,1 @@\n-    if (region == NULL) {\n+    if (region == nullptr) {\n@@ -4120,1 +4120,1 @@\n-    if (back_control == NULL) {\n+    if (back_control == nullptr) {\n@@ -4126,2 +4126,2 @@\n-    Node* incr = NULL;\n-    Node* limit = NULL;\n+    Node* incr = nullptr;\n+    Node* limit = nullptr;\n@@ -4129,1 +4129,1 @@\n-    if (cmp == NULL || cmp->Opcode() != Op_CmpI) {\n+    if (cmp == nullptr || cmp->Opcode() != Op_CmpI) {\n@@ -4148,3 +4148,3 @@\n-      Node* trunc1 = NULL;\n-      Node* trunc2 = NULL;\n-      const TypeInteger* iv_trunc_t = NULL;\n+      Node* trunc1 = nullptr;\n+      Node* trunc2 = nullptr;\n+      const TypeInteger* iv_trunc_t = nullptr;\n@@ -4156,1 +4156,1 @@\n-      Node* xphi = NULL;\n+      Node* xphi = nullptr;\n@@ -4159,1 +4159,1 @@\n-      if (stride == NULL) {\n+      if (stride == nullptr) {\n@@ -4163,4 +4163,4 @@\n-      PhiNode* phi = loop_iv_phi(xphi, NULL, head, loop);\n-      if (phi == NULL ||\n-          (trunc1 == NULL && phi->in(LoopNode::LoopBackControl) != incr) ||\n-          (trunc1 != NULL && phi->in(LoopNode::LoopBackControl) != trunc1)) {\n+      PhiNode* phi = loop_iv_phi(xphi, nullptr, head, loop);\n+      if (phi == nullptr ||\n+          (trunc1 == nullptr && phi->in(LoopNode::LoopBackControl) != incr) ||\n+          (trunc1 != nullptr && phi->in(LoopNode::LoopBackControl) != trunc1)) {\n@@ -4236,1 +4236,1 @@\n-  clone_loop_body(wq, old_new, NULL);\n+  clone_loop_body(wq, old_new, nullptr);\n@@ -4252,1 +4252,1 @@\n-  Node* dom = NULL;\n+  Node* dom = nullptr;\n@@ -4261,1 +4261,1 @@\n-    if (dom == NULL) {\n+    if (dom == nullptr) {\n@@ -4277,1 +4277,1 @@\n-      if (backedge == NULL) {\n+      if (backedge == nullptr) {\n@@ -4289,1 +4289,1 @@\n-  fix_ctrl_uses(wq, loop, old_new, ControlAroundStripMined, outer_head, NULL, worklist);\n+  fix_ctrl_uses(wq, loop, old_new, ControlAroundStripMined, outer_head, nullptr, worklist);\n@@ -4291,3 +4291,3 @@\n-  Node_List *split_if_set = NULL;\n-  Node_List *split_bool_set = NULL;\n-  Node_List *split_cex_set = NULL;\n+  Node_List *split_if_set = nullptr;\n+  Node_List *split_bool_set = nullptr;\n+  Node_List *split_cex_set = nullptr;\n@@ -4298,1 +4298,1 @@\n-  if (exit_test != NULL) {\n+  if (exit_test != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":174,"deletions":174,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-TypeOopPtr *MachOper::oop() const { return NULL; }\n+TypeOopPtr *MachOper::oop() const { return nullptr; }\n@@ -83,1 +83,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -189,1 +189,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -217,1 +217,1 @@\n-  if( rm == NULL || (int)opcnt != cisc_operand() ) {\n+  if( rm == nullptr || (int)opcnt != cisc_operand() ) {\n@@ -231,3 +231,3 @@\n-    base = NULL;\n-    index = NULL;\n-    if (oper != NULL) {\n+    base = nullptr;\n+    index = nullptr;\n+    if (oper != nullptr) {\n@@ -262,2 +262,2 @@\n-  if (oper == NULL) {\n-    \/\/ Base has been set to NULL\n+  if (oper == nullptr) {\n+    \/\/ Base has been set to null\n@@ -270,1 +270,1 @@\n-    \/\/ Base may be NULL, even if offset turns out to be != 0\n+    \/\/ Base may be null, even if offset turns out to be != 0\n@@ -276,1 +276,1 @@\n-    if (index != NULL) {\n+    if (index != nullptr) {\n@@ -283,1 +283,1 @@\n-        assert(base == NULL, \"Memory references through narrow oops have no base\");\n+        assert(base == nullptr, \"Memory references through narrow oops have no base\");\n@@ -286,1 +286,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -291,1 +291,1 @@\n-        if (ti == NULL) {\n+        if (ti == nullptr) {\n@@ -305,2 +305,2 @@\n-      const TypePtr *t_disp = oper->disp_as_type();  \/\/ only !NULL for indOffset32X\n-      if (t_disp != NULL) {\n+      const TypePtr *t_disp = oper->disp_as_type();  \/\/ only not null for indOffset32X\n+      if (t_disp != nullptr) {\n@@ -316,1 +316,1 @@\n-      } else if( base == NULL && offset != 0 && offset != Type::OffsetBot ) {\n+      } else if( base == nullptr && offset != 0 && offset != Type::OffsetBot ) {\n@@ -319,1 +319,1 @@\n-        if( tp != NULL) {\n+        if( tp != nullptr) {\n@@ -344,2 +344,2 @@\n-  if (base == NULL) {\n-    \/\/ NULL base, zero offset means no memory at all (a null pointer!)\n+  if (base == nullptr) {\n+    \/\/ null base, zero offset means no memory at all (a null pointer!)\n@@ -347,1 +347,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -349,1 +349,1 @@\n-    \/\/ NULL base, any offset means any pointer whatever\n+    \/\/ null base, any offset means any pointer whatever\n@@ -382,1 +382,1 @@\n-  if (tp == NULL) {\n+  if (tp == nullptr) {\n@@ -527,1 +527,1 @@\n-    if (_opnds[i] != NULL) {\n+    if (_opnds[i] != nullptr) {\n@@ -551,1 +551,1 @@\n-  if (_bottom_type != NULL) {\n+  if (_bottom_type != nullptr) {\n@@ -554,1 +554,1 @@\n-    st->print(\" NULL\");\n+    st->print(\" null\");\n@@ -629,1 +629,1 @@\n-    if (ctrl == NULL)  return NULL; \/\/ node is dead\n+    if (ctrl == nullptr)  return nullptr; \/\/ node is dead\n@@ -633,1 +633,1 @@\n-      assert(adr_type != NULL, \"source must have adr_type\");\n+      assert(adr_type != nullptr, \"source must have adr_type\");\n@@ -638,1 +638,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -702,1 +702,1 @@\n-  if (tf() != NULL)  tf()->dump_on(st);\n+  if (tf() != nullptr)  tf()->dump_on(st);\n@@ -704,1 +704,1 @@\n-  if (jvms() != NULL)  jvms()->dump_spec(st);\n+  if (jvms() != nullptr)  jvms()->dump_spec(st);\n@@ -805,1 +805,1 @@\n-  if (_name != NULL && !strcmp(_name, \"uncommon_trap\")) {\n+  if (_name != nullptr && !strcmp(_name, \"uncommon_trap\")) {\n@@ -825,1 +825,1 @@\n-  if (_name != NULL) {\n+  if (_name != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,1 +170,1 @@\n-  virtual const TypePtr *disp_as_type() const { return NULL; }\n+  virtual const TypePtr *disp_as_type() const { return nullptr; }\n@@ -203,1 +203,1 @@\n-    if (o == NULL)                   return true;\n+    if (o == nullptr)                   return true;\n@@ -216,1 +216,1 @@\n-  MachNode() : Node((uint)0), _barrier(0), _num_opnds(0), _opnds(NULL) {\n+  MachNode() : Node((uint)0), _barrier(0), _num_opnds(0), _opnds(nullptr) {\n@@ -268,1 +268,1 @@\n-  virtual const RegMask *cisc_RegMask() const { return NULL; }\n+  virtual const RegMask *cisc_RegMask() const { return nullptr; }\n@@ -338,1 +338,1 @@\n-  \/\/ If there are no such, return NULL.  If there are multiple addresses\n+  \/\/ If there are no such, return null.  If there are multiple addresses\n@@ -350,2 +350,2 @@\n-  \/\/ are set to NodeSentinel. If (MachOper *) NULL is returned, base and\n-  \/\/ index are set to NULL.\n+  \/\/ are set to NodeSentinel. If null is returned, base and\n+  \/\/ index are set to null.\n@@ -355,1 +355,1 @@\n-  \/\/ By default, returns NULL, which means there is no such operand.\n+  \/\/ By default, returns null, which means there is no such operand.\n@@ -357,1 +357,1 @@\n-  virtual const MachOper* memory_operand() const { return NULL; }\n+  virtual const MachOper* memory_operand() const { return nullptr; }\n@@ -404,1 +404,1 @@\n-  virtual const class Type *bottom_type() const { return _opnds == NULL ? Type::CONTROL : MachNode::bottom_type(); }\n+  virtual const class Type *bottom_type() const { return _opnds == nullptr ? Type::CONTROL : MachNode::bottom_type(); }\n@@ -639,1 +639,1 @@\n-    add_req(NULL);\n+    add_req(nullptr);\n@@ -707,1 +707,1 @@\n-    add_req(NULL);\n+    add_req(nullptr);\n@@ -733,1 +733,1 @@\n-  virtual MachNode *short_branch_version() { return NULL; }\n+  virtual MachNode *short_branch_version() { return nullptr; }\n@@ -878,1 +878,1 @@\n-  MachSafePointNode() : MachReturnNode(), _oop_map(NULL), _jvms(NULL), _jvmadj(0), _has_ea_local_in_scope(false) {\n+  MachSafePointNode() : MachReturnNode(), _oop_map(nullptr), _jvms(nullptr), _jvmadj(0), _has_ea_local_in_scope(false) {\n@@ -991,1 +991,1 @@\n-      assert(_method != NULL, \"method should be set\");\n+      assert(_method != nullptr, \"method should be set\");\n@@ -995,1 +995,1 @@\n-    return 0; \/\/ Use symbolic info from bytecode (resolved_method == NULL).\n+    return 0; \/\/ Use symbolic info from bytecode (resolved_method is null).\n@@ -1045,1 +1045,1 @@\n-  const char *_name;            \/\/ Printable name, if _method is NULL\n+  const char *_name;            \/\/ Printable name, if _method is null\n@@ -1104,1 +1104,1 @@\n-    add_req(NULL);\n+    add_req(nullptr);\n@@ -1136,1 +1136,1 @@\n-  virtual Label *label() const { assert(_label != NULL, \"need Label\"); return _label; }\n+  virtual Label *label() const { assert(_label != nullptr, \"need Label\"); return _label; }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-    } else if (j >= req && uin == NULL) {\n+    } else if (j >= req && uin == nullptr) {\n@@ -137,3 +137,3 @@\n-  if (parm0 != NULL)  call->init_req(TypeFunc::Parms+0, parm0);\n-  if (parm1 != NULL)  call->init_req(TypeFunc::Parms+1, parm1);\n-  if (parm2 != NULL)  call->init_req(TypeFunc::Parms+2, parm2);\n+  if (parm0 != nullptr)  call->init_req(TypeFunc::Parms+0, parm0);\n+  if (parm1 != nullptr)  call->init_req(TypeFunc::Parms+1, parm1);\n+  if (parm2 != nullptr)  call->init_req(TypeFunc::Parms+2, parm2);\n@@ -184,1 +184,1 @@\n-        ArrayCopyNode* ac = NULL;\n+        ArrayCopyNode* ac = nullptr;\n@@ -186,1 +186,1 @@\n-          if (ac != NULL) {\n+          if (ac != nullptr) {\n@@ -224,1 +224,1 @@\n-        if (init != NULL) {\n+        if (init != nullptr) {\n@@ -233,1 +233,1 @@\n-      Node* adr = NULL;\n+      Node* adr = nullptr;\n@@ -246,1 +246,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -256,1 +256,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -275,1 +275,1 @@\n-  Node* res = NULL;\n+  Node* res = nullptr;\n@@ -293,1 +293,1 @@\n-      Node* adr = NULL;\n+      Node* adr = nullptr;\n@@ -312,1 +312,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -333,1 +333,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -341,1 +341,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -348,1 +348,1 @@\n-\/\/ Returns the computed Phi, or NULL if it cannot compute it.\n+\/\/ Returns the computed Phi, or null if it cannot compute it.\n@@ -366,1 +366,1 @@\n-  if (new_phi != NULL)\n+  if (new_phi != nullptr)\n@@ -370,1 +370,1 @@\n-    return NULL; \/\/ Give up: phi tree too deep\n+    return nullptr; \/\/ Give up: phi tree too deep\n@@ -376,1 +376,1 @@\n-  GrowableArray <Node *> values(length, length, NULL);\n+  GrowableArray <Node *> values(length, length, nullptr);\n@@ -379,1 +379,1 @@\n-  PhiNode *phi = new PhiNode(mem->in(0), phi_type, NULL, mem->_idx, instance_id, alias_idx, offset);\n+  PhiNode *phi = new PhiNode(mem->in(0), phi_type, nullptr, mem->_idx, instance_id, alias_idx, offset);\n@@ -385,1 +385,1 @@\n-    if (in == NULL || in->is_top()) {\n+    if (in == nullptr || in->is_top()) {\n@@ -392,1 +392,1 @@\n-        if (default_value != NULL) {\n+        if (default_value != nullptr) {\n@@ -395,1 +395,1 @@\n-          assert(alloc->in(AllocateNode::RawDefaultValue) == NULL, \"default value may not be null\");\n+          assert(alloc->in(AllocateNode::RawDefaultValue) == nullptr, \"default value may not be null\");\n@@ -403,2 +403,2 @@\n-      if (val == NULL) {\n-        return NULL;  \/\/ can't find a value on this path\n+      if (val == nullptr) {\n+        return nullptr;  \/\/ can't find a value on this path\n@@ -418,1 +418,1 @@\n-        if (default_value != NULL) {\n+        if (default_value != nullptr) {\n@@ -421,1 +421,1 @@\n-          assert(alloc->in(AllocateNode::RawDefaultValue) == NULL, \"default value may not be null\");\n+          assert(alloc->in(AllocateNode::RawDefaultValue) == nullptr, \"default value may not be null\");\n@@ -426,2 +426,2 @@\n-        if (val == NULL) {\n-          return NULL;\n+        if (val == nullptr) {\n+          return nullptr;\n@@ -435,1 +435,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -438,2 +438,2 @@\n-        if (res == NULL) {\n-          return NULL;\n+        if (res == nullptr) {\n+          return nullptr;\n@@ -445,1 +445,1 @@\n-        return NULL;  \/\/ unknown node on this path\n+        return nullptr;  \/\/ unknown node on this path\n@@ -476,1 +476,1 @@\n-      return NULL;  \/\/ found a loop, give up\n+      return nullptr;  \/\/ found a loop, give up\n@@ -483,1 +483,1 @@\n-      if (mem == NULL) {\n+      if (mem == nullptr) {\n@@ -492,1 +492,1 @@\n-      assert(atype != NULL, \"address type must be oopptr\");\n+      assert(atype != nullptr, \"address type must be oopptr\");\n@@ -499,1 +499,1 @@\n-      Node *unique_input = NULL;\n+      Node *unique_input = nullptr;\n@@ -503,1 +503,1 @@\n-        if (n == NULL || n == top || n == mem) {\n+        if (n == nullptr || n == top || n == mem) {\n@@ -505,1 +505,1 @@\n-        } else if (unique_input == NULL) {\n+        } else if (unique_input == nullptr) {\n@@ -512,1 +512,1 @@\n-      if (unique_input != NULL && unique_input != top) {\n+      if (unique_input != nullptr && unique_input != top) {\n@@ -524,1 +524,1 @@\n-  if (mem != NULL) {\n+  if (mem != nullptr) {\n@@ -528,1 +528,1 @@\n-      if (default_value != NULL) {\n+      if (default_value != nullptr) {\n@@ -531,1 +531,1 @@\n-      assert(alloc->in(AllocateNode::RawDefaultValue) == NULL, \"default value may not be null\");\n+      assert(alloc->in(AllocateNode::RawDefaultValue) == nullptr, \"default value may not be null\");\n@@ -542,1 +542,1 @@\n-      if (phi != NULL) {\n+      if (phi != nullptr) {\n@@ -564,1 +564,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -577,1 +577,1 @@\n-    Node* value = NULL;\n+    Node* value = nullptr;\n@@ -590,1 +590,1 @@\n-      if (value != NULL && ft->isa_narrowoop()) {\n+      if (value != nullptr && ft->isa_narrowoop()) {\n@@ -599,1 +599,1 @@\n-    if (value != NULL) {\n+    if (value != nullptr) {\n@@ -603,1 +603,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -613,2 +613,2 @@\n-  NOT_PRODUCT( const char* fail_eliminate = NULL; )\n-  DEBUG_ONLY( Node* disq_node = NULL; )\n+  NOT_PRODUCT( const char* fail_eliminate = nullptr; )\n+  DEBUG_ONLY( Node* disq_node = nullptr; )\n@@ -619,2 +619,2 @@\n-  const TypeOopPtr* res_type = NULL;\n-  if (res == NULL) {\n+  const TypeOopPtr* res_type = nullptr;\n+  if (res == nullptr) {\n@@ -628,1 +628,1 @@\n-    if (res_type == NULL) {\n+    if (res_type == nullptr) {\n@@ -684,1 +684,1 @@\n-        if (sfptMem == NULL || sfptMem->is_top()) {\n+        if (sfptMem == nullptr || sfptMem->is_top()) {\n@@ -686,1 +686,1 @@\n-          NOT_PRODUCT(fail_eliminate = \"NULL or TOP memory\";)\n+          NOT_PRODUCT(fail_eliminate = \"null or TOP memory\";)\n@@ -740,1 +740,1 @@\n-      if (res == NULL)\n+      if (res == nullptr)\n@@ -746,1 +746,1 @@\n-      if (res == NULL)\n+      if (res == nullptr)\n@@ -751,1 +751,1 @@\n-      if (disq_node != NULL) {\n+      if (disq_node != nullptr) {\n@@ -766,1 +766,1 @@\n-  ciInstanceKlass* iklass = NULL;\n+  ciInstanceKlass* iklass = nullptr;\n@@ -771,1 +771,1 @@\n-  const Type* field_type = NULL;\n+  const Type* field_type = nullptr;\n@@ -774,3 +774,3 @@\n-  assert(res == NULL || res->is_CheckCastPP(), \"unexpected AllocateNode result\");\n-  const TypeOopPtr* res_type = NULL;\n-  if (res != NULL) { \/\/ Could be NULL when there are no users\n+  assert(res == nullptr || res->is_CheckCastPP(), \"unexpected AllocateNode result\");\n+  const TypeOopPtr* res_type = nullptr;\n+  if (res != nullptr) { \/\/ Could be null when there are no users\n@@ -780,1 +780,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -808,1 +808,1 @@\n-    assert(sfpt->jvms() != NULL, \"missed JVMS\");\n+    assert(sfpt->jvms() != nullptr, \"missed JVMS\");\n@@ -824,2 +824,2 @@\n-      ciField* field = NULL;\n-      if (iklass != NULL) {\n+      ciField* field = nullptr;\n+      if (iklass != nullptr) {\n@@ -836,1 +836,1 @@\n-          } else if (field != NULL && field->is_static_constant()) {\n+          } else if (field != nullptr && field->is_static_constant()) {\n@@ -841,1 +841,1 @@\n-            assert(field_type != NULL, \"field singleton type must be consistent\");\n+            assert(field_type != nullptr, \"field singleton type must be consistent\");\n@@ -856,1 +856,1 @@\n-      Node* field_val = NULL;\n+      Node* field_val = nullptr;\n@@ -865,1 +865,1 @@\n-      if (field_val == NULL) {\n+      if (field_val == nullptr) {\n@@ -903,1 +903,1 @@\n-          if (field != NULL) {\n+          if (field != nullptr) {\n@@ -914,1 +914,1 @@\n-          if (res == NULL)\n+          if (res == nullptr)\n@@ -950,1 +950,1 @@\n-  bool allow_oop = (res_type != NULL) && !res_type->is_flat();\n+  bool allow_oop = (res_type != nullptr) && !res_type->is_flat();\n@@ -961,1 +961,1 @@\n-  if (ctl_proj != NULL) {\n+  if (ctl_proj != nullptr) {\n@@ -964,1 +964,1 @@\n-  if (mem_proj != NULL) {\n+  if (mem_proj != nullptr) {\n@@ -973,1 +973,1 @@\n-  if (res != NULL) {\n+  if (res != nullptr) {\n@@ -989,1 +989,1 @@\n-              if (mb != NULL && mb->req() <= MemBarNode::Precedent && mb->in(MemBarNode::Precedent) == n) {\n+              if (mb != nullptr && mb->req() <= MemBarNode::Precedent && mb->in(MemBarNode::Precedent) == n) {\n@@ -1070,1 +1070,1 @@\n-  if (_callprojs->resproj[0] != NULL && _callprojs->resproj[0]->outcnt() != 0) {\n+  if (_callprojs->resproj[0] != nullptr && _callprojs->resproj[0]->outcnt() != 0) {\n@@ -1090,1 +1090,1 @@\n-        if (ctrl_proj != NULL) {\n+        if (ctrl_proj != nullptr) {\n@@ -1093,1 +1093,1 @@\n-          \/\/ If the InitializeNode has no memory out, it will die, and tmp will become NULL\n+          \/\/ If the InitializeNode has no memory out, it will die, and tmp will become null\n@@ -1095,1 +1095,1 @@\n-          assert(tmp == NULL || tmp == _callprojs->fallthrough_catchproj, \"allocation control projection\");\n+          assert(tmp == nullptr || tmp == _callprojs->fallthrough_catchproj, \"allocation control projection\");\n@@ -1099,1 +1099,1 @@\n-        if (mem_proj != NULL) {\n+        if (mem_proj != nullptr) {\n@@ -1120,1 +1120,1 @@\n-  if (_callprojs->fallthrough_catchproj != NULL) {\n+  if (_callprojs->fallthrough_catchproj != nullptr) {\n@@ -1123,1 +1123,1 @@\n-  if (_callprojs->fallthrough_memproj != NULL) {\n+  if (_callprojs->fallthrough_memproj != nullptr) {\n@@ -1126,1 +1126,1 @@\n-  if (_callprojs->catchall_memproj != NULL) {\n+  if (_callprojs->catchall_memproj != nullptr) {\n@@ -1129,1 +1129,1 @@\n-  if (_callprojs->fallthrough_ioproj != NULL) {\n+  if (_callprojs->fallthrough_ioproj != nullptr) {\n@@ -1132,1 +1132,1 @@\n-  if (_callprojs->catchall_ioproj != NULL) {\n+  if (_callprojs->catchall_ioproj != nullptr) {\n@@ -1135,1 +1135,1 @@\n-  if (_callprojs->catchall_catchproj != NULL) {\n+  if (_callprojs->catchall_catchproj != nullptr) {\n@@ -1162,1 +1162,1 @@\n-  bool boxing_alloc = (res == NULL) && C->eliminate_boxing() &&\n+  bool boxing_alloc = (res == nullptr) && C->eliminate_boxing() &&\n@@ -1165,1 +1165,1 @@\n-  if (!alloc->_is_scalar_replaceable && (!boxing_alloc || (res != NULL))) {\n+  if (!alloc->_is_scalar_replaceable && (!boxing_alloc || (res != nullptr))) {\n@@ -1177,1 +1177,1 @@\n-    assert(res == NULL || inline_alloc, \"sanity\");\n+    assert(res == nullptr || inline_alloc, \"sanity\");\n@@ -1192,1 +1192,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1196,1 +1196,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n@@ -1219,1 +1219,1 @@\n-  if (!C->eliminate_boxing() || boxing->proj_out_or_null(TypeFunc::Parms) != NULL) {\n+  if (!C->eliminate_boxing() || boxing->proj_out_or_null(TypeFunc::Parms) != nullptr) {\n@@ -1223,1 +1223,1 @@\n-  assert(boxing->result_cast() == NULL, \"unexpected boxing node result\");\n+  assert(boxing->result_cast() == nullptr, \"unexpected boxing node result\");\n@@ -1230,1 +1230,1 @@\n-  assert(t != NULL, \"sanity\");\n+  assert(t != nullptr, \"sanity\");\n@@ -1233,1 +1233,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -1237,1 +1237,1 @@\n-    while (p != NULL) {\n+    while (p != nullptr) {\n@@ -1269,1 +1269,1 @@\n-  mem = StoreNode::make(_igvn, ctl, mem, adr, NULL, value, bt, MemNode::unordered);\n+  mem = StoreNode::make(_igvn, ctl, mem, adr, nullptr, value, bt, MemNode::unordered);\n@@ -1342,1 +1342,1 @@\n-  assert(ctrl != NULL, \"must have control\");\n+  assert(ctrl != nullptr, \"must have control\");\n@@ -1347,4 +1347,4 @@\n-  Node *result_region = NULL;\n-  Node *result_phi_rawmem = NULL;\n-  Node *result_phi_rawoop = NULL;\n-  Node *result_phi_i_o = NULL;\n+  Node *result_region = nullptr;\n+  Node *result_phi_rawmem = nullptr;\n+  Node *result_phi_rawoop = nullptr;\n+  Node *result_phi_i_o = nullptr;\n@@ -1362,1 +1362,1 @@\n-    initial_slow_test = NULL;\n+    initial_slow_test = nullptr;\n@@ -1370,1 +1370,1 @@\n-    initial_slow_test = NULL;\n+    initial_slow_test = nullptr;\n@@ -1373,1 +1373,1 @@\n-  bool allocation_has_use = (alloc->result_cast() != NULL);\n+  bool allocation_has_use = (alloc->result_cast() != nullptr);\n@@ -1376,1 +1376,1 @@\n-    if (init != NULL) {\n+    if (init != nullptr) {\n@@ -1379,1 +1379,1 @@\n-    if (expand_fast_path && (initial_slow_test == NULL)) {\n+    if (expand_fast_path && (initial_slow_test == nullptr)) {\n@@ -1387,1 +1387,1 @@\n-        if (res != NULL) {\n+        if (res != nullptr) {\n@@ -1400,1 +1400,1 @@\n-  Node *slow_region = NULL;\n+  Node *slow_region = nullptr;\n@@ -1404,1 +1404,1 @@\n-  if (initial_slow_test != NULL ) {\n+  if (initial_slow_test != nullptr ) {\n@@ -1458,1 +1458,1 @@\n-      Node* needgc_ctrl = NULL;\n+      Node* needgc_ctrl = nullptr;\n@@ -1461,1 +1461,1 @@\n-      intx prefetch_lines = length != NULL ? AllocatePrefetchLines : AllocateInstancePrefetchLines;\n+      intx prefetch_lines = length != nullptr ? AllocatePrefetchLines : AllocateInstancePrefetchLines;\n@@ -1467,1 +1467,1 @@\n-      if (initial_slow_test != NULL) {\n+      if (initial_slow_test != nullptr) {\n@@ -1486,1 +1486,1 @@\n-      assert (initial_slow_test != NULL, \"sanity\");\n+      assert (initial_slow_test != nullptr, \"sanity\");\n@@ -1512,1 +1512,1 @@\n-  if (length != NULL) {\n+  if (length != nullptr) {\n@@ -1525,1 +1525,1 @@\n-  if (valid_length_test != NULL) {\n+  if (valid_length_test != nullptr) {\n@@ -1554,1 +1554,1 @@\n-  if (expand_fast_path && _callprojs->fallthrough_memproj != NULL) {\n+  if (expand_fast_path && _callprojs->fallthrough_memproj != nullptr) {\n@@ -1559,2 +1559,2 @@\n-  if (_callprojs->catchall_memproj != NULL) {\n-    if (_callprojs->fallthrough_memproj == NULL) {\n+  if (_callprojs->catchall_memproj != nullptr) {\n+    if (_callprojs->fallthrough_memproj == nullptr) {\n@@ -1573,1 +1573,1 @@\n-  if (_callprojs->fallthrough_ioproj != NULL) {\n+  if (_callprojs->fallthrough_ioproj != nullptr) {\n@@ -1578,2 +1578,2 @@\n-  if (_callprojs->catchall_ioproj != NULL) {\n-    if (_callprojs->fallthrough_ioproj == NULL) {\n+  if (_callprojs->catchall_ioproj != nullptr) {\n+    if (_callprojs->fallthrough_ioproj == nullptr) {\n@@ -1603,1 +1603,1 @@\n-  if (_callprojs->fallthrough_catchproj != NULL) {\n+  if (_callprojs->fallthrough_catchproj != nullptr) {\n@@ -1611,1 +1611,1 @@\n-  if (_callprojs->resproj[0] == NULL) {\n+  if (_callprojs->resproj[0] == nullptr) {\n@@ -1640,1 +1640,1 @@\n-  if (_callprojs->resproj[0] != NULL) {\n+  if (_callprojs->resproj[0] != nullptr) {\n@@ -1650,1 +1650,1 @@\n-  if (_callprojs->fallthrough_catchproj != NULL) {\n+  if (_callprojs->fallthrough_catchproj != nullptr) {\n@@ -1654,1 +1654,1 @@\n-  if (_callprojs->catchall_catchproj != NULL) {\n+  if (_callprojs->catchall_catchproj != nullptr) {\n@@ -1658,1 +1658,1 @@\n-  if (_callprojs->fallthrough_proj != NULL) {\n+  if (_callprojs->fallthrough_proj != nullptr) {\n@@ -1663,1 +1663,1 @@\n-  if (_callprojs->fallthrough_memproj != NULL) {\n+  if (_callprojs->fallthrough_memproj != nullptr) {\n@@ -1667,1 +1667,1 @@\n-  if (_callprojs->fallthrough_ioproj != NULL) {\n+  if (_callprojs->fallthrough_ioproj != nullptr) {\n@@ -1671,1 +1671,1 @@\n-  if (_callprojs->catchall_memproj != NULL) {\n+  if (_callprojs->catchall_memproj != nullptr) {\n@@ -1675,1 +1675,1 @@\n-  if (_callprojs->catchall_ioproj != NULL) {\n+  if (_callprojs->catchall_ioproj != nullptr) {\n@@ -1709,2 +1709,2 @@\n-    (init == NULL || !init->is_complete_with_arraycopy())) {\n-    if (init == NULL || init->req() < InitializeNode::RawStores) {\n+    (init == nullptr || !init->is_complete_with_arraycopy())) {\n+    if (init == nullptr || init->req() < InitializeNode::RawStores) {\n@@ -1753,1 +1753,1 @@\n-      if (init_ctrl != NULL) {\n+      if (init_ctrl != nullptr) {\n@@ -1756,1 +1756,1 @@\n-      if (init_mem != NULL) {\n+      if (init_mem != nullptr) {\n@@ -1811,1 +1811,1 @@\n-  if (length != NULL) {         \/\/ Arrays need length field\n+  if (length != nullptr) {         \/\/ Arrays need length field\n@@ -1825,1 +1825,1 @@\n-  if (init == NULL) {\n+  if (init == nullptr) {\n@@ -2013,1 +2013,1 @@\n-  expand_allocate_common(alloc, NULL,\n+  expand_allocate_common(alloc, nullptr,\n@@ -2015,1 +2015,1 @@\n-                         OptoRuntime::new_instance_Java(), NULL);\n+                         OptoRuntime::new_instance_Java(), nullptr);\n@@ -2025,2 +2025,2 @@\n-  if (init != NULL && init->is_complete_with_arraycopy() &&\n-      ary_klass_t && ary_klass_t->elem()->isa_klassptr() == NULL) {\n+  if (init != nullptr && init->is_complete_with_arraycopy() &&\n+      ary_klass_t && ary_klass_t->elem()->isa_klassptr() == nullptr) {\n@@ -2059,1 +2059,1 @@\n-      oldbox->as_BoxLock()->is_simple_lock_region(NULL, obj, NULL)) {\n+      oldbox->as_BoxLock()->is_simple_lock_region(nullptr, obj, nullptr)) {\n@@ -2151,1 +2151,1 @@\n-      if (alock->jvms() != NULL) {\n+      if (alock->jvms() != nullptr) {\n@@ -2179,1 +2179,1 @@\n-          if (C->log() != NULL)\n+          if (C->log() != nullptr)\n@@ -2219,1 +2219,1 @@\n-  Node* unc_ctrl = generate_slow_guard(ctrl, bol, NULL);\n+  Node* unc_ctrl = generate_slow_guard(ctrl, bol, nullptr);\n@@ -2223,1 +2223,1 @@\n-  const TypePtr* no_memory_effects = NULL;\n+  const TypePtr* no_memory_effects = nullptr;\n@@ -2280,1 +2280,1 @@\n-  guarantee(ctrl != NULL, \"missing control projection, cannot replace_node() with NULL\");\n+  guarantee(ctrl != nullptr, \"missing control projection, cannot replace_node() with null\");\n@@ -2286,2 +2286,2 @@\n-         _callprojs->fallthrough_proj != NULL &&\n-         _callprojs->fallthrough_memproj != NULL,\n+         _callprojs->fallthrough_proj != nullptr &&\n+         _callprojs->fallthrough_memproj != nullptr,\n@@ -2302,1 +2302,1 @@\n-    assert(membar != NULL && membar->Opcode() == Op_MemBarAcquireLock, \"\");\n+    assert(membar != nullptr && membar->Opcode() == Op_MemBarAcquireLock, \"\");\n@@ -2365,2 +2365,2 @@\n-                                  OptoRuntime::complete_monitor_locking_Java(), NULL, slow_path,\n-                                  obj, box, NULL);\n+                                  OptoRuntime::complete_monitor_locking_Java(), nullptr, slow_path,\n+                                  obj, box, nullptr);\n@@ -2374,2 +2374,2 @@\n-  assert(_callprojs->fallthrough_ioproj == NULL && _callprojs->catchall_ioproj == NULL &&\n-         _callprojs->catchall_memproj == NULL && _callprojs->catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n+  assert(_callprojs->fallthrough_ioproj == nullptr && _callprojs->catchall_ioproj == nullptr &&\n+         _callprojs->catchall_memproj == nullptr && _callprojs->catchall_catchproj == nullptr, \"Unexpected projection from Lock\");\n@@ -2429,2 +2429,2 @@\n-  assert(_callprojs->fallthrough_ioproj == NULL && _callprojs->catchall_ioproj == NULL &&\n-         _callprojs->catchall_memproj == NULL && _callprojs->catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n+  assert(_callprojs->fallthrough_ioproj == nullptr && _callprojs->catchall_ioproj == nullptr &&\n+         _callprojs->catchall_memproj == nullptr && _callprojs->catchall_catchproj == nullptr, \"Unexpected projection from Lock\");\n@@ -2463,1 +2463,1 @@\n-  if (ret == NULL) {\n+  if (ret == nullptr) {\n@@ -2500,1 +2500,1 @@\n-  Node* needgc_ctrl = NULL; \/\/ needgc means slowcase, i.e. allocation failed\n+  Node* needgc_ctrl = nullptr; \/\/ needgc means slowcase, i.e. allocation failed\n@@ -2504,2 +2504,2 @@\n-    Node* fast_oop_ctrl = NULL;\n-    Node* fast_oop_rawmem = NULL;\n+    Node* fast_oop_ctrl = nullptr;\n+    Node* fast_oop_rawmem = nullptr;\n@@ -2510,1 +2510,1 @@\n-    Node* layout_val = make_load(NULL, mem, klass_node, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);\n+    Node* layout_val = make_load(nullptr, mem, klass_node, in_bytes(Klass::layout_helper_offset()), TypeInt::INT, T_INT);\n@@ -2527,1 +2527,1 @@\n-                                        NULL,\n+                                        nullptr,\n@@ -2597,3 +2597,3 @@\n-  Node* fast_ctl = NULL;\n-  Node* fast_res = NULL;\n-  MergeMemNode* fast_mem = NULL;\n+  Node* fast_ctl = nullptr;\n+  Node* fast_res = nullptr;\n+  MergeMemNode* fast_mem = nullptr;\n@@ -2665,1 +2665,1 @@\n-  assert(check->in(SubTypeCheckNode::Control) == NULL, \"should be pinned\");\n+  assert(check->in(SubTypeCheckNode::Control) == nullptr, \"should be pinned\");\n@@ -2684,1 +2684,1 @@\n-    Node* subklass = NULL;\n+    Node* subklass = nullptr;\n@@ -2689,1 +2689,1 @@\n-      subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+      subklass = _igvn.transform(LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -2692,1 +2692,1 @@\n-    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, NULL, _igvn);\n+    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn);\n@@ -2713,1 +2713,1 @@\n-  bool array_inputs = _igvn.type(check->in(FlatArrayCheckNode::ArrayOrKlass))->isa_oopptr() != NULL;\n+  bool array_inputs = _igvn.type(check->in(FlatArrayCheckNode::ArrayOrKlass))->isa_oopptr() != nullptr;\n@@ -2721,1 +2721,1 @@\n-      assert(t != NULL, \"Mixing array and klass inputs\");\n+      assert(t != nullptr, \"Mixing array and klass inputs\");\n@@ -2724,1 +2724,1 @@\n-      Node* mark_load = _igvn.transform(LoadNode::make(_igvn, NULL, mem, mark_adr, mark_adr->bottom_type()->is_ptr(), TypeX_X, TypeX_X->basic_type(), MemNode::unordered));\n+      Node* mark_load = _igvn.transform(LoadNode::make(_igvn, nullptr, mem, mark_adr, mark_adr->bottom_type()->is_ptr(), TypeX_X, TypeX_X->basic_type(), MemNode::unordered));\n@@ -2779,1 +2779,1 @@\n-      Node* klass = NULL;\n+      Node* klass = nullptr;\n@@ -2782,1 +2782,1 @@\n-      if (t->isa_oopptr() != NULL) {\n+      if (t->isa_oopptr() != nullptr) {\n@@ -2784,1 +2784,1 @@\n-        klass = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+        klass = transform_later(LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -2790,1 +2790,1 @@\n-      Node* lh_val = _igvn.transform(LoadNode::make(_igvn, NULL, C->immutable_memory(), lh_addr, lh_addr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n+      Node* lh_val = _igvn.transform(LoadNode::make(_igvn, nullptr, C->immutable_memory(), lh_addr, lh_addr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n@@ -2947,1 +2947,1 @@\n-               ifn->proj_out(1)->is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != NULL, \"\");\n+               ifn->proj_out(1)->is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != nullptr, \"\");\n@@ -3004,1 +3004,1 @@\n-    if (_igvn.type(n) == Type::TOP || (n->in(0) != NULL && n->in(0)->is_top())) {\n+    if (_igvn.type(n) == Type::TOP || (n->in(0) != nullptr && n->in(0)->is_top())) {\n@@ -3064,1 +3064,1 @@\n-    if (_igvn.type(n) == Type::TOP || (n->in(0) != NULL && n->in(0)->is_top())) {\n+    if (_igvn.type(n) == Type::TOP || (n->in(0) != nullptr && n->in(0)->is_top())) {\n@@ -3119,1 +3119,1 @@\n-  ideal_nodes.map(C->live_nodes(), NULL);\n+  ideal_nodes.map(C->live_nodes(), nullptr);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":186,"deletions":186,"binary":false,"changes":372,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,4 +70,4 @@\n-                       Node* parm0 = NULL, Node* parm1 = NULL,\n-                       Node* parm2 = NULL, Node* parm3 = NULL,\n-                       Node* parm4 = NULL, Node* parm5 = NULL,\n-                       Node* parm6 = NULL, Node* parm7 = NULL);\n+                       Node* parm0 = nullptr, Node* parm1 = nullptr,\n+                       Node* parm2 = nullptr, Node* parm3 = nullptr,\n+                       Node* parm4 = nullptr, Node* parm5 = nullptr,\n+                       Node* parm6 = nullptr, Node* parm7 = nullptr);\n@@ -117,1 +117,1 @@\n-  void insert_mem_bar(Node** ctrl, Node** mem, int opcode, Node* precedent = NULL);\n+  void insert_mem_bar(Node** ctrl, Node** mem, int opcode, Node* precedent = nullptr);\n@@ -151,1 +151,1 @@\n-                           RegionNode* slow_region = NULL);\n+                           RegionNode* slow_region = nullptr);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,9 +87,9 @@\n-  \/\/ Hook each parm in order.  Stop looking at the first NULL.\n-  if (parm0 != NULL) { call->init_req(TypeFunc::Parms+0, parm0);\n-  if (parm1 != NULL) { call->init_req(TypeFunc::Parms+1, parm1);\n-  if (parm2 != NULL) { call->init_req(TypeFunc::Parms+2, parm2);\n-  if (parm3 != NULL) { call->init_req(TypeFunc::Parms+3, parm3);\n-  if (parm4 != NULL) { call->init_req(TypeFunc::Parms+4, parm4);\n-  if (parm5 != NULL) { call->init_req(TypeFunc::Parms+5, parm5);\n-  if (parm6 != NULL) { call->init_req(TypeFunc::Parms+6, parm6);\n-  if (parm7 != NULL) { call->init_req(TypeFunc::Parms+7, parm7);\n+  \/\/ Hook each parm in order.  Stop looking at the first null.\n+  if (parm0 != nullptr) { call->init_req(TypeFunc::Parms+0, parm0);\n+  if (parm1 != nullptr) { call->init_req(TypeFunc::Parms+1, parm1);\n+  if (parm2 != nullptr) { call->init_req(TypeFunc::Parms+2, parm2);\n+  if (parm3 != nullptr) { call->init_req(TypeFunc::Parms+3, parm3);\n+  if (parm4 != nullptr) { call->init_req(TypeFunc::Parms+4, parm4);\n+  if (parm5 != nullptr) { call->init_req(TypeFunc::Parms+5, parm5);\n+  if (parm6 != nullptr) { call->init_req(TypeFunc::Parms+6, parm6);\n+  if (parm7 != nullptr) { call->init_req(TypeFunc::Parms+7, parm7);\n@@ -97,1 +97,1 @@\n-  assert(call->in(call->req()-1) != NULL, \"must initialize all parms\");\n+  assert(call->in(call->req()-1) != nullptr, \"must initialize all parms\");\n@@ -110,2 +110,2 @@\n-\/\/ or NULL if it is obvious that the slow path can never be taken.\n-\/\/ Also, if region and the slow control are not NULL, the slow edge\n+\/\/ or null if it is obvious that the slow path can never be taken.\n+\/\/ Also, if region and the slow control are not null, the slow edge\n@@ -116,1 +116,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -122,1 +122,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -131,1 +131,1 @@\n-  if (region != NULL) {\n+  if (region != nullptr) {\n@@ -207,2 +207,2 @@\n-  Node* inline_block = NULL;\n-  Node* stub_block = NULL;\n+  Node* inline_block = nullptr;\n+  Node* stub_block = nullptr;\n@@ -211,1 +211,1 @@\n-  const TypeInt* lty = NULL;\n+  const TypeInt* lty = nullptr;\n@@ -242,1 +242,1 @@\n-  inline_block  = generate_guard(ctrl, bol_le, NULL, PROB_FAIR);\n+  inline_block  = generate_guard(ctrl, bol_le, nullptr, PROB_FAIR);\n@@ -277,1 +277,1 @@\n-  if ((*ctrl)->is_top())  return NULL;\n+  if ((*ctrl)->is_top())  return nullptr;\n@@ -280,1 +280,1 @@\n-    return NULL;                \/\/ index is already adequately typed\n+    return nullptr;                \/\/ index is already adequately typed\n@@ -286,1 +286,1 @@\n-  Node* is_notp = generate_guard(ctrl, bol_le, NULL, PROB_MIN);\n+  Node* is_notp = generate_guard(ctrl, bol_le, nullptr, PROB_MIN);\n@@ -293,1 +293,1 @@\n-  Node* klass = transform_later(LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+  Node* klass = transform_later(LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -295,1 +295,1 @@\n-  Node* lh_val = _igvn.transform(LoadNode::make(_igvn, NULL, C->immutable_memory(), lh_addr, lh_addr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n+  Node* lh_val = _igvn.transform(LoadNode::make(_igvn, nullptr, C->immutable_memory(), lh_addr, lh_addr->bottom_type()->is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));\n@@ -346,2 +346,2 @@\n-  if (src_offset_inttype != NULL && src_offset_inttype->is_con() &&\n-      dest_offset_inttype != NULL && dest_offset_inttype->is_con()) {\n+  if (src_offset_inttype != nullptr && src_offset_inttype->is_con() &&\n+      dest_offset_inttype != nullptr && dest_offset_inttype->is_con()) {\n@@ -355,1 +355,1 @@\n-  } else if (src_offset == dest_offset && src_offset != NULL) {\n+  } else if (src_offset == dest_offset && src_offset != nullptr) {\n@@ -409,1 +409,1 @@\n-  if (slow_region == NULL) {\n+  if (slow_region == nullptr) {\n@@ -417,2 +417,2 @@\n-  Node* default_value = NULL;\n-  Node* raw_default_value = NULL;\n+  Node* default_value = nullptr;\n+  Node* raw_default_value = nullptr;\n@@ -429,1 +429,1 @@\n-      && alloc != NULL\n+      && alloc != nullptr\n@@ -456,1 +456,1 @@\n-    alloc                  = NULL;\n+    alloc                  = nullptr;\n@@ -488,3 +488,3 @@\n-  Node* checked_mem     = NULL;\n-  Node* checked_i_o     = NULL;\n-  Node* checked_value   = NULL;\n+  Node* checked_mem     = nullptr;\n+  Node* checked_i_o     = nullptr;\n+  Node* checked_value   = nullptr;\n@@ -498,1 +498,1 @@\n-    if (cv == NULL)  cv = intcon(-1);  \/\/ failure (no stub available)\n+    if (cv == nullptr)  cv = intcon(-1);  \/\/ failure (no stub available)\n@@ -507,1 +507,1 @@\n-  if (not_pos != NULL) {\n+  if (not_pos != nullptr) {\n@@ -529,1 +529,1 @@\n-                             intcon(0), NULL,\n+                             intcon(0), nullptr,\n@@ -568,1 +568,1 @@\n-                           NULL);\n+                           nullptr);\n@@ -576,1 +576,1 @@\n-    Node* tail_ctl = NULL;\n+    Node* tail_ctl = nullptr;\n@@ -580,2 +580,2 @@\n-      tail_ctl = generate_slow_guard(ctrl, bol_lt, NULL);\n-      assert(tail_ctl != NULL || !(*ctrl)->is_top(), \"must be an outcome\");\n+      tail_ctl = generate_slow_guard(ctrl, bol_lt, nullptr);\n+      assert(tail_ctl != nullptr || !(*ctrl)->is_top(), \"must be an outcome\");\n@@ -585,1 +585,1 @@\n-    if (!(*ctrl)->is_top() && alloc != NULL && basic_elem_type != T_OBJECT) {\n+    if (!(*ctrl)->is_top() && alloc != nullptr && basic_elem_type != T_OBJECT) {\n@@ -610,2 +610,2 @@\n-    if (tail_ctl != NULL) {\n-      Node* notail_ctl = (*ctrl)->is_top() ? NULL : *ctrl;\n+    if (tail_ctl != nullptr) {\n+      Node* notail_ctl = (*ctrl)->is_top() ? nullptr : *ctrl;\n@@ -613,1 +613,1 @@\n-      if (notail_ctl == NULL) {\n+      if (notail_ctl == nullptr) {\n@@ -618,1 +618,1 @@\n-                             dest_tail, NULL,\n+                             dest_tail, nullptr,\n@@ -630,1 +630,1 @@\n-                             dest_tail, NULL,\n+                             dest_tail, nullptr,\n@@ -659,1 +659,1 @@\n-      assert(src_klass != NULL && dest_klass != NULL, \"should have klasses\");\n+      assert(src_klass != nullptr && dest_klass != nullptr, \"should have klasses\");\n@@ -682,1 +682,1 @@\n-        Node* n1 = LoadKlassNode::make(_igvn, NULL, C->immutable_memory(), p1, TypeRawPtr::BOTTOM);\n+        Node* n1 = LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), p1, TypeRawPtr::BOTTOM);\n@@ -689,1 +689,1 @@\n-        if (cv == NULL)  cv = intcon(-1);  \/\/ failure (no stub available)\n+        if (cv == nullptr)  cv = intcon(-1);  \/\/ failure (no stub available)\n@@ -699,1 +699,1 @@\n-    if (!bs->array_copy_requires_gc_barriers(alloc != NULL, copy_type, false, false, BarrierSetC2::Expansion)) {\n+    if (!bs->array_copy_requires_gc_barriers(alloc != nullptr, copy_type, false, false, BarrierSetC2::Expansion)) {\n@@ -725,1 +725,1 @@\n-  assert(slow_region != NULL, \"allocated on entry\");\n+  assert(slow_region != nullptr, \"allocated on entry\");\n@@ -768,1 +768,1 @@\n-    if (alloc != NULL) {\n+    if (alloc != nullptr) {\n@@ -810,1 +810,1 @@\n-                           intcon(0), NULL,\n+                           intcon(0), nullptr,\n@@ -830,1 +830,1 @@\n-    if (result_region->in(i) == NULL) {\n+    if (result_region->in(i) == nullptr) {\n@@ -842,1 +842,1 @@\n-  DEBUG_ONLY(mem = NULL);\n+  DEBUG_ONLY(mem = nullptr);\n@@ -856,1 +856,1 @@\n-  if (alloc != NULL && !alloc->initialization()->does_not_escape()) {\n+  if (alloc != nullptr && !alloc->initialization()->does_not_escape()) {\n@@ -872,1 +872,1 @@\n-  if (_callprojs->fallthrough_ioproj != NULL) {\n+  if (_callprojs->fallthrough_ioproj != nullptr) {\n@@ -880,1 +880,1 @@\n-    ArrayCopyNode* ac = NULL;\n+    ArrayCopyNode* ac = nullptr;\n@@ -882,1 +882,1 @@\n-    assert(ac == NULL, \"no arraycopy anymore\");\n+    assert(ac == nullptr, \"no arraycopy anymore\");\n@@ -906,1 +906,1 @@\n-\/\/   slice_len          number of elements to store (or NULL)\n+\/\/   slice_len          number of elements to store (or null)\n@@ -909,3 +909,3 @@\n-\/\/ Exactly one of slice_len or dest_size must be non-NULL.\n-\/\/ If dest_size is non-NULL, zeroing extends to the end of the object.\n-\/\/ If slice_len is non-NULL, the slice_idx value must be a constant.\n+\/\/ Exactly one of slice_len or dest_size must be non-null.\n+\/\/ If dest_size is non-null, zeroing extends to the end of the object.\n+\/\/ If slice_len is non-null, the slice_idx value must be a constant.\n@@ -922,3 +922,3 @@\n-  assert((slice_len != NULL? 1: 0) + (dest_size != NULL? 1: 0) == 1, \"\");\n-  if (slice_len == NULL)  slice_len = top();\n-  if (dest_size == NULL)  dest_size = top();\n+  assert((slice_len != nullptr? 1: 0) + (dest_size != nullptr? 1: 0) == 1, \"\");\n+  if (slice_len == nullptr)  slice_len = top();\n+  if (dest_size == nullptr)  dest_size = top();\n@@ -1003,2 +1003,2 @@\n-        if (val == NULL) {\n-          assert(raw_val == NULL, \"val may not be null\");\n+        if (val == nullptr) {\n+          assert(raw_val == nullptr, \"val may not be null\");\n@@ -1091,1 +1091,1 @@\n-  bool disjoint_bases = true;   \/\/ since alloc != NULL\n+  bool disjoint_bases = true;   \/\/ since alloc isn't null\n@@ -1094,1 +1094,1 @@\n-                               sptr, NULL, dptr, NULL, countx, dest_uninitialized);\n+                               sptr, nullptr, dptr, nullptr, countx, dest_uninitialized);\n@@ -1148,2 +1148,2 @@\n-  \/\/ could be NULL. Skip clone and update NULL fallthrough_ioproj.\n-  if (_callprojs->fallthrough_ioproj != NULL) {\n+  \/\/ could be nullptr. Skip clone and update nullptr fallthrough_ioproj.\n+  if (_callprojs->fallthrough_ioproj != nullptr) {\n@@ -1153,1 +1153,1 @@\n-    *io = NULL;\n+    *io = nullptr;\n@@ -1166,1 +1166,1 @@\n-  if ((*ctrl)->is_top())  return NULL;\n+  if ((*ctrl)->is_top())  return nullptr;\n@@ -1169,2 +1169,2 @@\n-  if (copyfunc_addr == NULL) { \/\/ Stub was not generated, go slow path.\n-    return NULL;\n+  if (copyfunc_addr == nullptr) { \/\/ Stub was not generated, go slow path.\n+    return nullptr;\n@@ -1179,1 +1179,1 @@\n-  Node* n3 = new LoadINode(NULL, *mem \/*memory(p3)*\/, p3, _igvn.type(p3)->is_ptr(), TypeInt::INT, MemNode::unordered);\n+  Node* n3 = new LoadINode(nullptr, *mem \/*memory(p3)*\/, p3, _igvn.type(p3)->is_ptr(), TypeInt::INT, MemNode::unordered);\n@@ -1204,1 +1204,1 @@\n-  if ((*ctrl)->is_top()) return NULL;\n+  if ((*ctrl)->is_top()) return nullptr;\n@@ -1208,2 +1208,2 @@\n-  if (copyfunc_addr == NULL) { \/\/ Stub was not generated, go slow path.\n-    return NULL;\n+  if (copyfunc_addr == nullptr) { \/\/ Stub was not generated, go slow path.\n+    return nullptr;\n@@ -1236,1 +1236,1 @@\n-  if (src_offset != NULL || dest_offset != NULL) {\n+  if (src_offset != nullptr || dest_offset != nullptr) {\n@@ -1247,2 +1247,2 @@\n-  Node* result_memory = NULL;\n-  RegionNode* exit_block = NULL;\n+  Node* result_memory = nullptr;\n+  RegionNode* exit_block = nullptr;\n@@ -1288,1 +1288,1 @@\n-    bs->array_copy_requires_gc_barriers(dest_length != NULL, T_OBJECT, false, false, BarrierSetC2::Optimization);\n+    bs->array_copy_requires_gc_barriers(dest_length != nullptr, T_OBJECT, false, false, BarrierSetC2::Optimization);\n@@ -1300,1 +1300,1 @@\n-      if (dest_length != NULL) {\n+      if (dest_length != nullptr) {\n@@ -1328,1 +1328,1 @@\n-  MergeMemNode* merge_mem = NULL;\n+  MergeMemNode* merge_mem = nullptr;\n@@ -1340,1 +1340,1 @@\n-    if (top_dest != NULL && top_dest->elem() != Type::BOTTOM) {\n+    if (top_dest != nullptr && top_dest->elem() != Type::BOTTOM) {\n@@ -1345,1 +1345,1 @@\n-    if (top_src != NULL && top_src->is_flat()) {\n+    if (top_src != nullptr && top_src->is_flat()) {\n@@ -1350,2 +1350,2 @@\n-    AllocateArrayNode* alloc = NULL;\n-    Node* dest_length = NULL;\n+    AllocateArrayNode* alloc = nullptr;\n+    Node* dest_length = nullptr;\n@@ -1354,1 +1354,1 @@\n-      assert(alloc != NULL, \"expect alloc\");\n+      assert(alloc != nullptr, \"expect alloc\");\n@@ -1359,1 +1359,1 @@\n-    const TypePtr* adr_type = NULL;\n+    const TypePtr* adr_type = nullptr;\n@@ -1361,1 +1361,1 @@\n-      assert(dest_length != NULL || StressReflectiveCode, \"must be tightly coupled\");\n+      assert(dest_length != nullptr || StressReflectiveCode, \"must be tightly coupled\");\n@@ -1386,1 +1386,1 @@\n-  AllocateArrayNode* alloc = NULL;\n+  AllocateArrayNode* alloc = nullptr;\n@@ -1389,1 +1389,1 @@\n-    assert(alloc != NULL, \"expect alloc\");\n+    assert(alloc != nullptr, \"expect alloc\");\n@@ -1407,1 +1407,1 @@\n-  if (top_src != NULL && top_src->elem() != Type::BOTTOM) {\n+  if (top_src != nullptr && top_src->elem() != Type::BOTTOM) {\n@@ -1410,1 +1410,1 @@\n-  if (top_dest != NULL && top_dest->elem() != Type::BOTTOM) {\n+  if (top_dest != nullptr && top_dest->elem() != Type::BOTTOM) {\n@@ -1432,1 +1432,1 @@\n-    Node* mem = generate_arraycopy(ac, NULL, &ctrl, merge_mem, &io,\n+    Node* mem = generate_arraycopy(ac, nullptr, &ctrl, merge_mem, &io,\n@@ -1435,1 +1435,1 @@\n-                                   NULL,\n+                                   nullptr,\n@@ -1453,1 +1453,1 @@\n-       bs->array_copy_requires_gc_barriers(alloc != NULL, T_OBJECT, false, false, BarrierSetC2::Optimization))) {\n+       bs->array_copy_requires_gc_barriers(alloc != nullptr, T_OBJECT, false, false, BarrierSetC2::Optimization))) {\n@@ -1462,1 +1462,1 @@\n-    if (_callprojs->fallthrough_ioproj != NULL) {\n+    if (_callprojs->fallthrough_ioproj != nullptr) {\n@@ -1514,1 +1514,1 @@\n-    assert(alen != NULL, \"need src len\");\n+    assert(alen != nullptr, \"need src len\");\n@@ -1522,1 +1522,1 @@\n-    assert(alen != NULL, \"need dest len\");\n+    assert(alen != nullptr, \"need dest len\");\n@@ -1548,2 +1548,2 @@\n-  const TypePtr* adr_type = NULL;\n-  Node* dest_length = (alloc != NULL) ? alloc->in(AllocateNode::ALength) : NULL;\n+  const TypePtr* adr_type = nullptr;\n+  Node* dest_length = (alloc != nullptr) ? alloc->in(AllocateNode::ALength) : nullptr;\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":108,"deletions":108,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -86,46 +86,46 @@\n-  idealreg2spillmask  [Op_RegI] = NULL;\n-  idealreg2spillmask  [Op_RegN] = NULL;\n-  idealreg2spillmask  [Op_RegL] = NULL;\n-  idealreg2spillmask  [Op_RegF] = NULL;\n-  idealreg2spillmask  [Op_RegD] = NULL;\n-  idealreg2spillmask  [Op_RegP] = NULL;\n-  idealreg2spillmask  [Op_VecA] = NULL;\n-  idealreg2spillmask  [Op_VecS] = NULL;\n-  idealreg2spillmask  [Op_VecD] = NULL;\n-  idealreg2spillmask  [Op_VecX] = NULL;\n-  idealreg2spillmask  [Op_VecY] = NULL;\n-  idealreg2spillmask  [Op_VecZ] = NULL;\n-  idealreg2spillmask  [Op_RegFlags] = NULL;\n-  idealreg2spillmask  [Op_RegVectMask] = NULL;\n-\n-  idealreg2debugmask  [Op_RegI] = NULL;\n-  idealreg2debugmask  [Op_RegN] = NULL;\n-  idealreg2debugmask  [Op_RegL] = NULL;\n-  idealreg2debugmask  [Op_RegF] = NULL;\n-  idealreg2debugmask  [Op_RegD] = NULL;\n-  idealreg2debugmask  [Op_RegP] = NULL;\n-  idealreg2debugmask  [Op_VecA] = NULL;\n-  idealreg2debugmask  [Op_VecS] = NULL;\n-  idealreg2debugmask  [Op_VecD] = NULL;\n-  idealreg2debugmask  [Op_VecX] = NULL;\n-  idealreg2debugmask  [Op_VecY] = NULL;\n-  idealreg2debugmask  [Op_VecZ] = NULL;\n-  idealreg2debugmask  [Op_RegFlags] = NULL;\n-  idealreg2debugmask  [Op_RegVectMask] = NULL;\n-\n-  idealreg2mhdebugmask[Op_RegI] = NULL;\n-  idealreg2mhdebugmask[Op_RegN] = NULL;\n-  idealreg2mhdebugmask[Op_RegL] = NULL;\n-  idealreg2mhdebugmask[Op_RegF] = NULL;\n-  idealreg2mhdebugmask[Op_RegD] = NULL;\n-  idealreg2mhdebugmask[Op_RegP] = NULL;\n-  idealreg2mhdebugmask[Op_VecA] = NULL;\n-  idealreg2mhdebugmask[Op_VecS] = NULL;\n-  idealreg2mhdebugmask[Op_VecD] = NULL;\n-  idealreg2mhdebugmask[Op_VecX] = NULL;\n-  idealreg2mhdebugmask[Op_VecY] = NULL;\n-  idealreg2mhdebugmask[Op_VecZ] = NULL;\n-  idealreg2mhdebugmask[Op_RegFlags] = NULL;\n-  idealreg2mhdebugmask[Op_RegVectMask] = NULL;\n-\n-  debug_only(_mem_node = NULL;)   \/\/ Ideal memory node consumed by mach node\n+  idealreg2spillmask  [Op_RegI] = nullptr;\n+  idealreg2spillmask  [Op_RegN] = nullptr;\n+  idealreg2spillmask  [Op_RegL] = nullptr;\n+  idealreg2spillmask  [Op_RegF] = nullptr;\n+  idealreg2spillmask  [Op_RegD] = nullptr;\n+  idealreg2spillmask  [Op_RegP] = nullptr;\n+  idealreg2spillmask  [Op_VecA] = nullptr;\n+  idealreg2spillmask  [Op_VecS] = nullptr;\n+  idealreg2spillmask  [Op_VecD] = nullptr;\n+  idealreg2spillmask  [Op_VecX] = nullptr;\n+  idealreg2spillmask  [Op_VecY] = nullptr;\n+  idealreg2spillmask  [Op_VecZ] = nullptr;\n+  idealreg2spillmask  [Op_RegFlags] = nullptr;\n+  idealreg2spillmask  [Op_RegVectMask] = nullptr;\n+\n+  idealreg2debugmask  [Op_RegI] = nullptr;\n+  idealreg2debugmask  [Op_RegN] = nullptr;\n+  idealreg2debugmask  [Op_RegL] = nullptr;\n+  idealreg2debugmask  [Op_RegF] = nullptr;\n+  idealreg2debugmask  [Op_RegD] = nullptr;\n+  idealreg2debugmask  [Op_RegP] = nullptr;\n+  idealreg2debugmask  [Op_VecA] = nullptr;\n+  idealreg2debugmask  [Op_VecS] = nullptr;\n+  idealreg2debugmask  [Op_VecD] = nullptr;\n+  idealreg2debugmask  [Op_VecX] = nullptr;\n+  idealreg2debugmask  [Op_VecY] = nullptr;\n+  idealreg2debugmask  [Op_VecZ] = nullptr;\n+  idealreg2debugmask  [Op_RegFlags] = nullptr;\n+  idealreg2debugmask  [Op_RegVectMask] = nullptr;\n+\n+  idealreg2mhdebugmask[Op_RegI] = nullptr;\n+  idealreg2mhdebugmask[Op_RegN] = nullptr;\n+  idealreg2mhdebugmask[Op_RegL] = nullptr;\n+  idealreg2mhdebugmask[Op_RegF] = nullptr;\n+  idealreg2mhdebugmask[Op_RegD] = nullptr;\n+  idealreg2mhdebugmask[Op_RegP] = nullptr;\n+  idealreg2mhdebugmask[Op_VecA] = nullptr;\n+  idealreg2mhdebugmask[Op_VecS] = nullptr;\n+  idealreg2mhdebugmask[Op_VecD] = nullptr;\n+  idealreg2mhdebugmask[Op_VecX] = nullptr;\n+  idealreg2mhdebugmask[Op_VecY] = nullptr;\n+  idealreg2mhdebugmask[Op_VecZ] = nullptr;\n+  idealreg2mhdebugmask[Op_RegFlags] = nullptr;\n+  idealreg2mhdebugmask[Op_RegVectMask] = nullptr;\n+\n+  debug_only(_mem_node = nullptr;)   \/\/ Ideal memory node consumed by mach node\n@@ -175,1 +175,1 @@\n-      if (in != NULL) {\n+      if (in != nullptr) {\n@@ -192,1 +192,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -360,1 +360,1 @@\n-  \/\/ Create new ideal node ConP #NULL even if it does exist in old space\n+  \/\/ Create new ideal node ConP #null even if it does exist in old space\n@@ -371,1 +371,1 @@\n-  if (_old_node_note_array != NULL) {\n+  if (_old_node_note_array != nullptr) {\n@@ -374,1 +374,1 @@\n-                            0, NULL));\n+                            0, nullptr));\n@@ -391,1 +391,1 @@\n-    if (xroot == NULL) {\n+    if (xroot == nullptr) {\n@@ -408,2 +408,2 @@\n-      \/\/ Generate new mach node for ConP #NULL\n-      assert(new_ideal_null != NULL, \"sanity\");\n+      \/\/ Generate new mach node for ConP #null\n+      assert(new_ideal_null != nullptr, \"sanity\");\n@@ -414,1 +414,1 @@\n-      assert(_mach_null != NULL, \"\");\n+      assert(_mach_null != nullptr, \"\");\n@@ -416,1 +416,1 @@\n-      C->set_root(xroot->is_Root() ? xroot->as_Root() : NULL);\n+      C->set_root(xroot->is_Root() ? xroot->as_Root() : nullptr);\n@@ -423,1 +423,1 @@\n-  if (C->top() == NULL || C->root() == NULL) {\n+  if (C->top() == nullptr || C->root() == nullptr) {\n@@ -1060,1 +1060,1 @@\n-      if (n1at != NULL) {\n+      if (n1at != nullptr) {\n@@ -1111,1 +1111,1 @@\n-      nat = NULL;\n+      nat = nullptr;\n@@ -1134,1 +1134,1 @@\n-  mstack.push(n, Visit, NULL, -1);  \/\/ set NULL as parent to indicate root\n+  mstack.push(n, Visit, nullptr, -1);  \/\/ set null as parent to indicate root\n@@ -1137,1 +1137,1 @@\n-    if (C->failing()) return NULL;\n+    if (C->failing()) return nullptr;\n@@ -1154,2 +1154,2 @@\n-            if (C->failing())  return NULL;\n-            if (m == NULL) { Matcher::soft_match_failure(); return NULL; }\n+            if (C->failing())  return nullptr;\n+            if (m == nullptr) { Matcher::soft_match_failure(); return nullptr; }\n@@ -1160,1 +1160,1 @@\n-            if (n->is_Proj() && n->in(0) != NULL && n->in(0)->is_Multi()) {       \/\/ Projections?\n+            if (n->is_Proj() && n->in(0) != nullptr && n->in(0)->is_Multi()) {       \/\/ Projections?\n@@ -1162,1 +1162,1 @@\n-              RegMask* mask = NULL;\n+              RegMask* mask = nullptr;\n@@ -1168,1 +1168,1 @@\n-              if (m->in(0) != NULL) \/\/ m might be top\n+              if (m->in(0) != nullptr) \/\/ m might be top\n@@ -1180,1 +1180,1 @@\n-          if (_old_node_note_array != NULL) {\n+          if (_old_node_note_array != nullptr) {\n@@ -1198,1 +1198,1 @@\n-        if (m == NULL) break;\n+        if (m == nullptr) break;\n@@ -1206,1 +1206,1 @@\n-        if (m == NULL || C->node_arena()->contains(m)) continue;\n+        if (m == nullptr || C->node_arena()->contains(m)) continue;\n@@ -1241,1 +1241,1 @@\n-        if(m != NULL)\n+        if(m != nullptr)\n@@ -1249,1 +1249,1 @@\n-      if (p != NULL) { \/\/ root doesn't have parent\n+      if (p != nullptr) { \/\/ root doesn't have parent\n@@ -1295,2 +1295,2 @@\n-  MachSafePointNode *msfpt = NULL;\n-  MachCallNode      *mcall = NULL;\n+  MachSafePointNode *msfpt = nullptr;\n+  MachCallNode      *mcall = nullptr;\n@@ -1301,1 +1301,1 @@\n-  ciMethod*        method = NULL;\n+  ciMethod*        method = nullptr;\n@@ -1310,2 +1310,2 @@\n-    if (C->failing())  return NULL;\n-    if( m == NULL ) { Matcher::soft_match_failure(); return NULL; }\n+    if (C->failing())  return nullptr;\n+    if( m == nullptr ) { Matcher::soft_match_failure(); return nullptr; }\n@@ -1351,2 +1351,2 @@\n-    call = NULL;\n-    domain = NULL;\n+    call = nullptr;\n+    domain = nullptr;\n@@ -1354,1 +1354,1 @@\n-    if (C->failing())  return NULL;\n+    if (C->failing())  return nullptr;\n@@ -1379,1 +1379,1 @@\n-  if( call != NULL && call->is_CallRuntime() )\n+  if( call != nullptr && call->is_CallRuntime() )\n@@ -1386,1 +1386,1 @@\n-  int adj = (call != NULL && call->entry_point() == NULL) ? 1 : 0;\n+  int adj = (call != nullptr && call->entry_point() == nullptr) ? 1 : 0;\n@@ -1495,1 +1495,1 @@\n-  assert((mcall == NULL) || (mcall->jvms() == NULL) ||\n+  assert((mcall == nullptr) || (mcall->jvms() == nullptr) ||\n@@ -1534,1 +1534,1 @@\n-  _mem_node = n->is_Store() ? (Node*)n : NULL;\n+  _mem_node = n->is_Store() ? (Node*)n : nullptr;\n@@ -1539,2 +1539,2 @@\n-  s->_kids[0] = NULL;\n-  s->_kids[1] = NULL;\n+  s->_kids[0] = nullptr;\n+  s->_kids[1] = nullptr;\n@@ -1545,1 +1545,1 @@\n-  if (C->failing())  return NULL;\n+  if (C->failing())  return nullptr;\n@@ -1565,1 +1565,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1612,1 +1612,1 @@\n-    Node* mem_control = (m->is_Load()) ? m->in(MemNode::Memory)->in(0) : NULL;\n+    Node* mem_control = (m->is_Load()) ? m->in(MemNode::Memory)->in(0) : nullptr;\n@@ -1666,1 +1666,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1676,1 +1676,1 @@\n-  Node *input_mem = NULL;\n+  Node *input_mem = nullptr;\n@@ -1682,1 +1682,1 @@\n-      if( input_mem == NULL ) {\n+      if( input_mem == nullptr ) {\n@@ -1704,2 +1704,2 @@\n-    s->_kids[0] = NULL;\n-    s->_kids[1] = NULL;\n+    s->_kids[0] = nullptr;\n+    s->_kids[1] = nullptr;\n@@ -1730,1 +1730,1 @@\n-      if( control == NULL && m->in(0) != NULL && m->req() > 1 )\n+      if( control == nullptr && m->in(0) != nullptr && m->req() > 1 )\n@@ -1734,1 +1734,1 @@\n-      if (C->failing()) return NULL;\n+      if (C->failing()) return nullptr;\n@@ -1762,1 +1762,1 @@\n-  if (!leaf->is_Con() && !leaf->is_DecodeNarrowPtr()) return NULL;\n+  if (!leaf->is_Con() && !leaf->is_DecodeNarrowPtr()) return nullptr;\n@@ -1765,1 +1765,1 @@\n-  if (_shared_nodes.Size() <= leaf->_idx) return NULL;\n+  if (_shared_nodes.Size() <= leaf->_idx) return nullptr;\n@@ -1767,1 +1767,1 @@\n-  if (last != NULL && rule == last->rule()) {\n+  if (last != nullptr && rule == last->rule()) {\n@@ -1773,1 +1773,1 @@\n-    if (xroot == NULL) {\n+    if (xroot == nullptr) {\n@@ -1775,1 +1775,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1782,1 +1782,1 @@\n-      if (control == NULL || control == C->root()) {\n+      if (control == nullptr || control == C->root()) {\n@@ -1786,1 +1786,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1791,1 +1791,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1817,1 +1817,1 @@\n-  if (shared_node != NULL) {\n+  if (shared_node != nullptr) {\n@@ -1823,1 +1823,1 @@\n-  guarantee(mach != NULL, \"Missing MachNode\");\n+  guarantee(mach != nullptr, \"Missing MachNode\");\n@@ -1825,1 +1825,1 @@\n-  assert( mach->_opnds[0] != NULL, \"Missing result operand\" );\n+  assert( mach->_opnds[0] != nullptr, \"Missing result operand\" );\n@@ -1848,1 +1848,1 @@\n-    if (oper != NULL && oper != (MachOper*)-1) {\n+    if (oper != nullptr && oper != (MachOper*)-1) {\n@@ -1850,1 +1850,1 @@\n-      Node* m = NULL;\n+      Node* m = nullptr;\n@@ -1855,1 +1855,1 @@\n-        assert(m != NULL && m->is_Mem(), \"expecting memory node\");\n+        assert(m != nullptr && m->is_Mem(), \"expecting memory node\");\n@@ -1894,1 +1894,1 @@\n-      mach->set_req(i,NULL);\n+      mach->set_req(i,nullptr);\n@@ -1927,1 +1927,1 @@\n-    if (n->in(i) != NULL) {\n+    if (n->in(i) != nullptr) {\n@@ -1974,2 +1974,2 @@\n-  if( s->_leaf->in(0) != NULL && s->_leaf->req() > 1) {\n-    if( mach->in(0) == NULL )\n+  if( s->_leaf->in(0) != nullptr && s->_leaf->req() > 1) {\n+    if( mach->in(0) == nullptr )\n@@ -1982,1 +1982,1 @@\n-    if( newstate == NULL ) break;      \/\/ Might only have 1 child\n+    if( newstate == nullptr ) break;      \/\/ Might only have 1 child\n@@ -2037,1 +2037,1 @@\n-  assert( kid == NULL || s->_leaf->in(0) == NULL, \"internal operands have no control\" );\n+  assert( kid == nullptr || s->_leaf->in(0) == nullptr, \"internal operands have no control\" );\n@@ -2040,1 +2040,1 @@\n-  if( kid == NULL && !_swallowed[rule] ) {\n+  if( kid == nullptr && !_swallowed[rule] ) {\n@@ -2061,1 +2061,1 @@\n-  for (uint i = 0; kid != NULL && i < 2; kid = s->_kids[1], i++) {   \/\/ binary tree\n+  for (uint i = 0; kid != nullptr && i < 2; kid = s->_kids[1], i++) {   \/\/ binary tree\n@@ -2101,1 +2101,1 @@\n-  if (n != NULL && m != NULL) {\n+  if (n != nullptr && m != nullptr) {\n@@ -2181,2 +2181,2 @@\n-        if (m == NULL) {\n-          continue;  \/\/ Ignore NULLs\n+        if (m == nullptr) {\n+          continue;  \/\/ Ignore nulls\n@@ -2612,1 +2612,1 @@\n-          \/\/ use it to do implicit NULL check in address.\n+          \/\/ use it to do implicit null check in address.\n@@ -2622,1 +2622,1 @@\n-              val->set_req(0, NULL); \/\/ Unpin now.\n+              val->set_req(0, nullptr); \/\/ Unpin now.\n@@ -2624,1 +2624,1 @@\n-              \/\/ a regular case: CmpP(DecodeN, NULL).\n+              \/\/ a regular case: CmpP(DecodeN, null).\n@@ -2638,1 +2638,1 @@\n-\/\/ Its possible that the value being NULL checked is not the root of a match\n+\/\/ Its possible that the value being null checked is not the root of a match\n@@ -2650,1 +2650,1 @@\n-        assert(val->is_DecodeNarrowPtr() && val->in(0) == NULL, \"sanity\");\n+        assert(val->is_DecodeNarrowPtr() && val->in(0) == nullptr, \"sanity\");\n@@ -2655,1 +2655,1 @@\n-        new_val->set_req(0, NULL);\n+        new_val->set_req(0, nullptr);\n@@ -2681,1 +2681,1 @@\n-          CompressedOops::base() != NULL);\n+          CompressedOops::base() != nullptr);\n@@ -2687,1 +2687,1 @@\n-  if (t == NULL) {\n+  if (t == nullptr) {\n@@ -2689,1 +2689,1 @@\n-    return NULL; \/\/ not supported\n+    return nullptr; \/\/ not supported\n@@ -2698,6 +2698,6 @@\n-    case Op_RegN: spill = new LoadNNode(NULL, mem, fp, atp, t->is_narrowoop(), mo); break;\n-    case Op_RegI: spill = new LoadINode(NULL, mem, fp, atp, t->is_int(),       mo); break;\n-    case Op_RegP: spill = new LoadPNode(NULL, mem, fp, atp, t->is_ptr(),       mo); break;\n-    case Op_RegF: spill = new LoadFNode(NULL, mem, fp, atp, t,                 mo); break;\n-    case Op_RegD: spill = new LoadDNode(NULL, mem, fp, atp, t,                 mo); break;\n-    case Op_RegL: spill = new LoadLNode(NULL, mem, fp, atp, t->is_long(),      mo); break;\n+    case Op_RegN: spill = new LoadNNode(nullptr, mem, fp, atp, t->is_narrowoop(), mo); break;\n+    case Op_RegI: spill = new LoadINode(nullptr, mem, fp, atp, t->is_int(),       mo); break;\n+    case Op_RegP: spill = new LoadPNode(nullptr, mem, fp, atp, t->is_ptr(),       mo); break;\n+    case Op_RegF: spill = new LoadFNode(nullptr, mem, fp, atp, t,                 mo); break;\n+    case Op_RegD: spill = new LoadDNode(nullptr, mem, fp, atp, t,                 mo); break;\n+    case Op_RegL: spill = new LoadLNode(nullptr, mem, fp, atp, t->is_long(),      mo); break;\n@@ -2710,1 +2710,1 @@\n-    case Op_VecZ: spill = new LoadVectorNode(NULL, mem, fp, atp, t->is_vect()); break;\n+    case Op_VecZ: spill = new LoadVectorNode(nullptr, mem, fp, atp, t->is_vect()); break;\n@@ -2716,1 +2716,1 @@\n-  assert(mspill != NULL, \"matching failed: %d\", ideal_reg);\n+  assert(mspill != nullptr, \"matching failed: %d\", ideal_reg);\n@@ -2752,1 +2752,1 @@\n-  Node* def = NULL;\n+  Node* def = nullptr;\n@@ -2794,1 +2794,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -2850,1 +2850,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -2873,1 +2873,1 @@\n-  Node* ctrl = NULL;\n+  Node* ctrl = nullptr;\n@@ -2883,1 +2883,1 @@\n-  assert((ctrl != NULL), \"missing control projection\");\n+  assert((ctrl != nullptr), \"missing control projection\");\n@@ -2956,1 +2956,1 @@\n-  Node *ifFalse = NULL;\n+  Node *ifFalse = nullptr;\n@@ -2968,3 +2968,3 @@\n-  while (reg != NULL && cnt > 0) {\n-    CallNode *call = NULL;\n-    RegionNode *nxt_reg = NULL;\n+  while (reg != nullptr && cnt > 0) {\n+    CallNode *call = nullptr;\n+    RegionNode *nxt_reg = nullptr;\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":146,"deletions":146,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,1 @@\n-    _nodes.map(idx_limit-1, NULL);\n+    _nodes.map(idx_limit-1, nullptr);\n@@ -155,1 +155,1 @@\n-    return _nodes.at(n->_idx) != NULL;\n+    return _nodes.at(n->_idx) != nullptr;\n@@ -173,1 +173,1 @@\n-  \/\/ Mach node for ConP #NULL\n+  \/\/ Mach node for ConP #null\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-  if (adr == NULL)  return NULL; \/\/ node is dead\n-  const TypePtr* cross_check = NULL;\n+  if (adr == nullptr)  return nullptr; \/\/ node is dead\n+  const TypePtr* cross_check = nullptr;\n@@ -78,1 +78,1 @@\n-  if (adr != NULL) {\n+  if (adr != nullptr) {\n@@ -88,1 +88,1 @@\n-  if (in(Address) == NULL)  return; \/\/ node is dead\n+  if (in(Address) == nullptr)  return; \/\/ node is dead\n@@ -91,2 +91,2 @@\n-  const TypePtr* _adr_type = NULL;\n-  if (in(Address) != NULL)\n+  const TypePtr* _adr_type = nullptr;\n+  if (in(Address) != nullptr)\n@@ -114,2 +114,2 @@\n-  if (adr_type == NULL) {\n-    st->print(\"NULL\");\n+  if (adr_type == nullptr) {\n+    st->print(\"null\");\n@@ -119,1 +119,1 @@\n-    Compile::AliasType* atp = NULL;\n+    Compile::AliasType* atp = nullptr;\n@@ -121,1 +121,1 @@\n-    if (atp == NULL)\n+    if (atp == nullptr)\n@@ -145,1 +145,1 @@\n-  assert((t_oop != NULL), \"sanity\");\n+  assert((t_oop != nullptr), \"sanity\");\n@@ -148,2 +148,2 @@\n-                             (load != NULL) && load->is_Load() &&\n-                             (phase->is_IterGVN() != NULL);\n+                             (load != nullptr) && load->is_Load() &&\n+                             (phase->is_IterGVN() != nullptr);\n@@ -154,1 +154,1 @@\n-  Node *prev = NULL;\n+  Node *prev = nullptr;\n@@ -175,1 +175,1 @@\n-        if ((alloc == NULL) || (alloc->_idx == instance_id)) {\n+        if ((alloc == nullptr) || (alloc->_idx == instance_id)) {\n@@ -188,1 +188,1 @@\n-        ArrayCopyNode* ac = NULL;\n+        ArrayCopyNode* ac = nullptr;\n@@ -206,1 +206,1 @@\n-      result = step_through_mergemem(phase, result->as_MergeMem(), t_oop, NULL, tty);\n+      result = step_through_mergemem(phase, result->as_MergeMem(), t_oop, nullptr, tty);\n@@ -214,1 +214,1 @@\n-  if (t_oop == NULL)\n+  if (t_oop == nullptr)\n@@ -219,1 +219,1 @@\n-  if (is_instance && igvn != NULL && result->is_Phi()) {\n+  if (is_instance && igvn != nullptr && result->is_Phi()) {\n@@ -261,1 +261,1 @@\n-    bool consistent =  adr_check == NULL || adr_check->empty() ||\n+    bool consistent =  adr_check == nullptr || adr_check->empty() ||\n@@ -264,1 +264,1 @@\n-    if( !consistent && adr_check != NULL && !adr_check->empty() &&\n+    if( !consistent && adr_check != nullptr && !adr_check->empty() &&\n@@ -275,2 +275,2 @@\n-      if( adr_check == NULL ) {\n-        st->print(\"NULL\");\n+      if( adr_check == nullptr ) {\n+        st->print(\"null\");\n@@ -321,3 +321,3 @@\n-  if (ctl && can_reshape && igvn != NULL) {\n-    Node* bol = NULL;\n-    Node* cmp = NULL;\n+  if (ctl && can_reshape && igvn != nullptr) {\n+    Node* bol = nullptr;\n+    Node* cmp = nullptr;\n@@ -331,2 +331,2 @@\n-        (bol != NULL && igvn->_worklist.member(bol)) ||\n-        (cmp != NULL && igvn->_worklist.member(cmp)) ) {\n+        (bol != nullptr && igvn->_worklist.member(bol)) ||\n+        (cmp != nullptr && igvn->_worklist.member(cmp)) ) {\n@@ -336,1 +336,1 @@\n-      return NodeSentinel; \/\/ caller will return NULL\n+      return NodeSentinel; \/\/ caller will return null\n@@ -341,1 +341,1 @@\n-  if (phase->type( mem ) == Type::TOP) return NodeSentinel; \/\/ caller will return NULL\n+  if (phase->type( mem ) == Type::TOP) return NodeSentinel; \/\/ caller will return null\n@@ -344,1 +344,1 @@\n-  if (can_reshape && igvn != NULL && igvn->_worklist.member(mem)) {\n+  if (can_reshape && igvn != nullptr && igvn->_worklist.member(mem)) {\n@@ -348,1 +348,1 @@\n-    return NodeSentinel; \/\/ caller will return NULL\n+    return NodeSentinel; \/\/ caller will return null\n@@ -353,1 +353,1 @@\n-  if (t_adr == Type::TOP)              return NodeSentinel; \/\/ caller will return NULL\n+  if (t_adr == Type::TOP)              return NodeSentinel; \/\/ caller will return null\n@@ -358,1 +358,1 @@\n-    assert(ctl != NULL, \"unsafe accesses should be control dependent\");\n+    assert(ctl != nullptr, \"unsafe accesses should be control dependent\");\n@@ -373,1 +373,1 @@\n-  if (can_reshape && igvn != NULL &&\n+  if (can_reshape && igvn != nullptr &&\n@@ -379,1 +379,1 @@\n-    return NodeSentinel; \/\/ caller will return NULL\n+    return NodeSentinel; \/\/ caller will return null\n@@ -389,1 +389,1 @@\n-  Node* base = NULL;\n+  Node* base = nullptr;\n@@ -393,1 +393,1 @@\n-  if (base != NULL && phase->type(base)->higher_equal(TypePtr::NULL_PTR) &&\n+  if (base != nullptr && phase->type(base)->higher_equal(TypePtr::NULL_PTR) &&\n@@ -397,1 +397,1 @@\n-    return NodeSentinel; \/\/ caller will return NULL\n+    return NodeSentinel; \/\/ caller will return null\n@@ -425,1 +425,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -436,1 +436,1 @@\n-  if (dom == NULL || dom->is_top() || sub == NULL || sub->is_top())\n+  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top())\n@@ -441,1 +441,1 @@\n-  if (dom == NULL || dom->is_top())\n+  if (dom == nullptr || dom->is_top())\n@@ -458,1 +458,1 @@\n-  \/\/ 'sub' should have sub->in(0) != NULL.\n+  \/\/ 'sub' should have sub->in(0) != nullptr.\n@@ -465,1 +465,1 @@\n-  if (sub == NULL || sub->is_top())\n+  if (sub == nullptr || sub->is_top())\n@@ -493,1 +493,1 @@\n-        if (n == NULL || n->is_top())\n+        if (n == nullptr || n->is_top())\n@@ -507,1 +507,1 @@\n-        if (m != NULL) {\n+        if (m != nullptr) {\n@@ -516,1 +516,1 @@\n-          if (m == NULL || m->is_top())\n+          if (m == nullptr || m->is_top())\n@@ -538,1 +538,1 @@\n-  if (a1 == NULL && a2 == NULL) {           \/\/ neither an allocation\n+  if (a1 == nullptr && a2 == nullptr) {           \/\/ neither an allocation\n@@ -540,1 +540,1 @@\n-  } else if (a1 != NULL && a2 != NULL) {    \/\/ both allocations\n+  } else if (a1 != nullptr && a2 != nullptr) {    \/\/ both allocations\n@@ -542,1 +542,1 @@\n-  } else if (a1 != NULL) {                  \/\/ one allocation a1\n+  } else if (a1 != nullptr) {                  \/\/ one allocation a1\n@@ -545,1 +545,1 @@\n-  } else { \/\/(a2 != NULL)                   \/\/ one allocation a2\n+  } else { \/\/(a2 != null)                   \/\/ one allocation a2\n@@ -559,1 +559,1 @@\n-\/\/ Otherwise return NULL.\n+\/\/ Otherwise return null.\n@@ -562,1 +562,1 @@\n-  if (ac != NULL) {\n+  if (ac != nullptr) {\n@@ -570,1 +570,1 @@\n-    if (ary_t != NULL && ld_addp->is_AddP()) {\n+    if (ary_t != nullptr && ld_addp->is_AddP()) {\n@@ -586,2 +586,2 @@\n-    \/\/ dependent on the runtime range check. This is achieved by returning NULL.\n-  } else if (mem->is_Proj() && mem->in(0) != NULL && mem->in(0)->is_ArrayCopy()) {\n+    \/\/ dependent on the runtime range check. This is achieved by returning null.\n+  } else if (mem->is_Proj() && mem->in(0) != nullptr && mem->in(0)->is_ArrayCopy()) {\n@@ -613,1 +613,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -617,1 +617,1 @@\n-  if (mem->is_Proj() && mem->in(0) != NULL && (mem->in(0)->Opcode() == Op_MemBarStoreStore ||\n+  if (mem->is_Proj() && mem->in(0) != nullptr && (mem->in(0)->Opcode() == Op_MemBarStoreStore ||\n@@ -619,1 +619,1 @@\n-    if (ld_alloc != NULL) {\n+    if (ld_alloc != nullptr) {\n@@ -622,3 +622,3 @@\n-      ArrayCopyNode* ac = NULL;\n-      if (mb->in(0) != NULL && mb->in(0)->is_Proj() &&\n-          mb->in(0)->in(0) != NULL && mb->in(0)->in(0)->is_ArrayCopy()) {\n+      ArrayCopyNode* ac = nullptr;\n+      if (mb->in(0) != nullptr && mb->in(0)->is_Proj() &&\n+          mb->in(0)->in(0) != nullptr && mb->in(0)->in(0)->is_ArrayCopy()) {\n@@ -636,1 +636,1 @@\n-      if (ac != NULL && ac->is_clonebasic()) {\n+      if (ac != nullptr && ac->is_clonebasic()) {\n@@ -638,1 +638,1 @@\n-        if (alloc != NULL && alloc == ld_alloc) {\n+        if (alloc != nullptr && alloc == ld_alloc) {\n@@ -644,1 +644,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -668,1 +668,1 @@\n-    return NULL;            \/\/ cannot unalias unless there are precise offsets\n+    return nullptr;            \/\/ cannot unalias unless there are precise offsets\n@@ -686,1 +686,1 @@\n-      if (st_base == NULL)\n+      if (st_base == nullptr)\n@@ -729,1 +729,1 @@\n-      if (st_alloc == NULL)\n+      if (st_alloc == nullptr)\n@@ -735,1 +735,1 @@\n-      else if (alloc != NULL)\n+      else if (alloc != nullptr)\n@@ -760,1 +760,1 @@\n-    } else if (find_previous_arraycopy(phase, alloc, mem, false) != NULL) {\n+    } else if (find_previous_arraycopy(phase, alloc, mem, false) != nullptr) {\n@@ -767,1 +767,1 @@\n-    } else if (addr_t != NULL && addr_t->is_known_instance_field()) {\n+    } else if (addr_t != nullptr && addr_t->is_known_instance_field()) {\n@@ -777,1 +777,1 @@\n-        ArrayCopyNode* ac = NULL;\n+        ArrayCopyNode* ac = nullptr;\n@@ -804,1 +804,1 @@\n-  return NULL;              \/\/ bail out\n+  return nullptr;              \/\/ bail out\n@@ -811,1 +811,1 @@\n-  if (t == Type::TOP)  return NULL; \/\/ does not touch memory any more?\n+  if (t == Type::TOP)  return nullptr; \/\/ does not touch memory any more?\n@@ -813,1 +813,1 @@\n-  if (!VerifyAliases || VMError::is_error_reported() || Node::in_dump())  cross_check = NULL;\n+  if (!VerifyAliases || VMError::is_error_reported() || Node::in_dump())  cross_check = nullptr;\n@@ -816,2 +816,2 @@\n-  if (tp == NULL) {\n-    assert(cross_check == NULL || cross_check == TypePtr::BOTTOM, \"expected memory type must be wide\");\n+  if (tp == nullptr) {\n+    assert(cross_check == nullptr || cross_check == TypePtr::BOTTOM, \"expected memory type must be wide\");\n@@ -823,1 +823,1 @@\n-    if (cross_check != NULL &&\n+    if (cross_check != nullptr &&\n@@ -918,1 +918,1 @@\n-  assert( ctl != NULL || C->get_alias_index(adr_type) != Compile::AliasIdxRaw ||\n+  assert( ctl != nullptr || C->get_alias_index(adr_type) != Compile::AliasIdxRaw ||\n@@ -922,1 +922,1 @@\n-  LoadNode* load = NULL;\n+  LoadNode* load = nullptr;\n@@ -949,1 +949,1 @@\n-  assert(load != NULL, \"LoadNode should have been created\");\n+  assert(load != nullptr, \"LoadNode should have been created\");\n@@ -975,2 +975,2 @@\n-  if ((atp != NULL) && (atp->index() >= Compile::AliasIdxRaw)) {\n-    bool non_volatile = (atp->field() != NULL) && !atp->field()->is_volatile();\n+  if ((atp != nullptr) && (atp->index() >= Compile::AliasIdxRaw)) {\n+    bool non_volatile = (atp->field() != nullptr) && !atp->field()->is_volatile();\n@@ -978,1 +978,1 @@\n-                         (tp != NULL) && (tp->isa_aryptr() != NULL) &&\n+                         (tp != nullptr) && (tp->isa_aryptr() != nullptr) &&\n@@ -995,1 +995,1 @@\n-  if (ac != NULL) {\n+  if (ac != nullptr) {\n@@ -1003,1 +1003,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1009,1 +1009,1 @@\n-      assert(ld_alloc != NULL, \"need an alloc\");\n+      assert(ld_alloc != nullptr, \"need an alloc\");\n@@ -1052,1 +1052,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1069,1 +1069,1 @@\n-  Compile::AliasType* atp = (tp != NULL) ? phase->C->alias_type(tp) : NULL;\n+  Compile::AliasType* atp = (tp != nullptr) ? phase->C->alias_type(tp) : nullptr;\n@@ -1073,1 +1073,1 @@\n-    Node* result = NULL;\n+    Node* result = nullptr;\n@@ -1110,1 +1110,1 @@\n-    if (result != NULL) {\n+    if (result != nullptr) {\n@@ -1125,5 +1125,5 @@\n-        if (ld_base == NULL)                                   return NULL;\n-        if (st_base == NULL)                                   return NULL;\n-        if (!ld_base->eqv_uncast(st_base, \/*keep_deps=*\/true)) return NULL;\n-        if (ld_off != st_off)                                  return NULL;\n-        if (ld_off == Type::OffsetBot)                         return NULL;\n+        if (ld_base == nullptr)                                return nullptr;\n+        if (st_base == nullptr)                                return nullptr;\n+        if (!ld_base->eqv_uncast(st_base, \/*keep_deps=*\/true)) return nullptr;\n+        if (ld_off != st_off)                                  return nullptr;\n+        if (ld_off == Type::OffsetBot)                         return nullptr;\n@@ -1145,1 +1145,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1152,1 +1152,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1170,1 +1170,1 @@\n-      if (default_value != NULL) {\n+      if (default_value != nullptr) {\n@@ -1173,1 +1173,1 @@\n-      assert(ld_alloc->in(AllocateNode::RawDefaultValue) == NULL, \"default value may not be null\");\n+      assert(ld_alloc->in(AllocateNode::RawDefaultValue) == nullptr, \"default value may not be null\");\n@@ -1175,1 +1175,1 @@\n-        if (ReduceBulkZeroing || find_array_copy_clone(phase, ld_alloc, in(MemNode::Memory)) == NULL) {\n+        if (ReduceBulkZeroing || find_array_copy_clone(phase, ld_alloc, in(MemNode::Memory)) == nullptr) {\n@@ -1191,1 +1191,1 @@\n-      if ((alloc != NULL) && (alloc == ld_alloc)) {\n+      if ((alloc != nullptr) && (alloc == ld_alloc)) {\n@@ -1194,1 +1194,1 @@\n-        if (st != NULL) {\n+        if (st != nullptr) {\n@@ -1202,1 +1202,1 @@\n-        (tp != NULL) && tp->is_ptr_to_boxed_value()) {\n+        (tp != nullptr) && tp->is_ptr_to_boxed_value()) {\n@@ -1207,1 +1207,1 @@\n-      if (base != NULL && base->is_Proj() &&\n+      if (base != nullptr && base->is_Proj() &&\n@@ -1218,1 +1218,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1227,1 +1227,1 @@\n-    if( t_oop != NULL &&\n+    if( t_oop != nullptr &&\n@@ -1246,1 +1246,1 @@\n-  if (base != NULL && base->is_InlineType() && offset > oopDesc::klass_offset_in_bytes()) {\n+  if (base != nullptr && base->is_InlineType() && offset > oopDesc::klass_offset_in_bytes()) {\n@@ -1248,1 +1248,1 @@\n-    if (value != NULL) {\n+    if (value != nullptr) {\n@@ -1298,1 +1298,1 @@\n-      if (base == NULL) {\n+      if (base == nullptr) {\n@@ -1319,1 +1319,1 @@\n-  const Type* rt = NULL;\n+  const Type* rt = nullptr;\n@@ -1327,1 +1327,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1337,1 +1337,1 @@\n-  const Type* rt = NULL;\n+  const Type* rt = nullptr;\n@@ -1347,1 +1347,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1371,1 +1371,1 @@\n-  if (raw_type == NULL) {\n+  if (raw_type == nullptr) {\n@@ -1405,1 +1405,1 @@\n-  if (raw_type == NULL) {\n+  if (raw_type == nullptr) {\n@@ -1423,1 +1423,1 @@\n-  if ((base == NULL) || base->is_Phi()) {\n+  if ((base == nullptr) || base->is_Phi()) {\n@@ -1427,1 +1427,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1439,1 +1439,1 @@\n-      return NULL; \/\/ Complex address\n+      return nullptr; \/\/ Complex address\n@@ -1443,1 +1443,1 @@\n-    if ((cache_base != NULL) && cache_base->is_DecodeN()) {\n+    if ((cache_base != nullptr) && cache_base->is_DecodeN()) {\n@@ -1447,1 +1447,1 @@\n-    if ((cache_base != NULL) && cache_base->is_Con()) {\n+    if ((cache_base != nullptr) && cache_base->is_Con()) {\n@@ -1449,1 +1449,1 @@\n-      if ((base_type != NULL) && base_type->is_autobox_cache()) {\n+      if ((base_type != nullptr) && base_type->is_autobox_cache()) {\n@@ -1474,1 +1474,1 @@\n-              return NULL; \/\/ should not happen since cache is array indexed by value\n+              return nullptr; \/\/ should not happen since cache is array indexed by value\n@@ -1478,1 +1478,1 @@\n-              return NULL; \/\/ should not happen since cache is array indexed by value\n+              return nullptr; \/\/ should not happen since cache is array indexed by value\n@@ -1530,1 +1530,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1535,1 +1535,1 @@\n-  if (region == NULL) {\n+  if (region == nullptr) {\n@@ -1541,1 +1541,1 @@\n-    if (rc == NULL || phase->type(rc) == Type::TOP)\n+    if (rc == nullptr || phase->type(rc) == Type::TOP)\n@@ -1544,1 +1544,1 @@\n-    if (in == NULL || phase->type(in) == Type::TOP)\n+    if (in == nullptr || phase->type(in) == Type::TOP)\n@@ -1555,1 +1555,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1561,1 +1561,1 @@\n-  assert((t_oop != NULL) &&\n+  assert((t_oop != nullptr) &&\n@@ -1568,1 +1568,1 @@\n-  bool base_is_phi = (base != NULL) && base->is_Phi();\n+  bool base_is_phi = (base != nullptr) && base->is_Phi();\n@@ -1570,1 +1570,1 @@\n-                           (base != NULL) && (base == address->in(AddPNode::Base)) &&\n+                           (base != nullptr) && (base == address->in(AddPNode::Base)) &&\n@@ -1575,1 +1575,1 @@\n-    return NULL; \/\/ memory is not Phi\n+    return nullptr; \/\/ memory is not Phi\n@@ -1580,1 +1580,1 @@\n-      return NULL; \/\/ Wait stable graph\n+      return nullptr; \/\/ Wait stable graph\n@@ -1605,1 +1605,1 @@\n-      return NULL; \/\/ Wait stable graph\n+      return nullptr; \/\/ Wait stable graph\n@@ -1612,1 +1612,1 @@\n-          return NULL; \/\/ Wait stable graph\n+          return nullptr; \/\/ Wait stable graph\n@@ -1624,1 +1624,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1634,1 +1634,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1640,1 +1640,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1648,1 +1648,1 @@\n-      return NULL; \/\/ complex graph\n+      return nullptr; \/\/ complex graph\n@@ -1664,1 +1664,1 @@\n-  Node* phi = new PhiNode(region, this_type, NULL, mem->_idx, this_iid, this_index, this_offset);\n+  Node* phi = new PhiNode(region, this_type, nullptr, mem->_idx, this_iid, this_index, this_offset);\n@@ -1667,1 +1667,1 @@\n-    Node* the_clone = NULL;\n+    Node* the_clone = nullptr;\n@@ -1670,1 +1670,1 @@\n-        in != NULL && in->is_OuterStripMinedLoop()) {\n+        in != nullptr && in->is_OuterStripMinedLoop()) {\n@@ -1674,1 +1674,1 @@\n-    if (in == NULL || in == C->top()) {\n+    if (in == nullptr || in == C->top()) {\n@@ -1683,1 +1683,1 @@\n-        x->set_req(0, NULL);\n+        x->set_req(0, nullptr);\n@@ -1735,1 +1735,1 @@\n-    if (x != the_clone && the_clone != NULL) {\n+    if (x != the_clone && the_clone != nullptr) {\n@@ -1750,2 +1750,2 @@\n-    if (alloc != NULL && mem->is_Proj() &&\n-        mem->in(0) != NULL &&\n+    if (alloc != nullptr && mem->is_Proj() &&\n+        mem->in(0) != nullptr &&\n@@ -1753,1 +1753,1 @@\n-        alloc->initialization()->proj_out_or_null(0) != NULL) {\n+        alloc->initialization()->proj_out_or_null(0) != nullptr) {\n@@ -1757,1 +1757,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1768,1 +1768,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1771,1 +1771,1 @@\n-  if (p)  return (p == NodeSentinel) ? NULL : p;\n+  if (p)  return (p == NodeSentinel) ? nullptr : p;\n@@ -1782,1 +1782,1 @@\n-  if( ctrl != NULL && ctrl->Opcode() == Op_SafePoint &&\n+  if( ctrl != nullptr && ctrl->Opcode() == Op_SafePoint &&\n@@ -1793,1 +1793,1 @@\n-  if (base != NULL\n+  if (base != nullptr\n@@ -1796,1 +1796,1 @@\n-    if (in(MemNode::Control) != NULL\n+    if (in(MemNode::Control) != nullptr\n@@ -1801,1 +1801,1 @@\n-      set_req(MemNode::Control, NULL);\n+      set_req(MemNode::Control, nullptr);\n@@ -1809,1 +1809,1 @@\n-  if (can_reshape && (addr_t != NULL)) {\n+  if (can_reshape && (addr_t != nullptr)) {\n@@ -1814,1 +1814,1 @@\n-      if (phase->type( opt_mem ) == Type::TOP) return NULL;\n+      if (phase->type( opt_mem ) == Type::TOP) return nullptr;\n@@ -1818,1 +1818,1 @@\n-    if ((t_oop != NULL) &&\n+    if ((t_oop != nullptr) &&\n@@ -1822,1 +1822,1 @@\n-      assert(igvn != NULL, \"must be PhaseIterGVN when can_reshape is true\");\n+      assert(igvn != nullptr, \"must be PhaseIterGVN when can_reshape is true\");\n@@ -1826,1 +1826,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1830,1 +1830,1 @@\n-      if (result != NULL) return result;\n+      if (result != nullptr) return result;\n@@ -1834,1 +1834,1 @@\n-        if (result != NULL) return result;\n+        if (result != nullptr) return result;\n@@ -1842,1 +1842,1 @@\n-  if (in(0) != NULL && !adr_type()->isa_rawptr() && can_reshape) {\n+  if (in(0) != nullptr && !adr_type()->isa_rawptr() && can_reshape) {\n@@ -1847,1 +1847,1 @@\n-          use->in(0) != NULL &&\n+          use->in(0) != nullptr &&\n@@ -1851,1 +1851,1 @@\n-        for (int i = 0; i < 10 && ctl != NULL; i++) {\n+        for (int i = 0; i < 10 && ctl != nullptr; i++) {\n@@ -1875,1 +1875,1 @@\n-  if (prev_mem != NULL) {\n+  if (prev_mem != nullptr) {\n@@ -1877,1 +1877,1 @@\n-    if (value != NULL) {\n+    if (value != nullptr) {\n@@ -1882,1 +1882,1 @@\n-  if (prev_mem != NULL && prev_mem != in(MemNode::Memory)) {\n+  if (prev_mem != nullptr && prev_mem != in(MemNode::Memory)) {\n@@ -1893,1 +1893,1 @@\n-  return progress ? this : NULL;\n+  return progress ? this : nullptr;\n@@ -1920,1 +1920,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1931,1 +1931,1 @@\n-  if (tp == NULL || tp->empty())  return Type::TOP;\n+  if (tp == nullptr || tp->empty())  return Type::TOP;\n@@ -1954,1 +1954,1 @@\n-      if (aobj != NULL && off_beyond_header && adr->is_AddP() && off != Type::OffsetBot) {\n+      if (aobj != nullptr && off_beyond_header && adr->is_AddP() && off != Type::OffsetBot) {\n@@ -1959,1 +1959,1 @@\n-        if (con_type != NULL) {\n+        if (con_type != nullptr) {\n@@ -1980,2 +1980,2 @@\n-    if ((t->isa_int() == NULL) && (t->isa_long() == NULL)\n-        && (_type->isa_vect() == NULL)\n+    if ((t->isa_int() == nullptr) && (t->isa_long() == nullptr)\n+        && (_type->isa_vect() == nullptr)\n@@ -1997,1 +1997,1 @@\n-          if ((base != NULL) && base->is_DecodeN()) {\n+          if ((base != nullptr) && base->is_DecodeN()) {\n@@ -2001,1 +2001,1 @@\n-          if ((base != NULL) && base->is_Con()) {\n+          if ((base != nullptr) && base->is_Con()) {\n@@ -2003,1 +2003,1 @@\n-            if ((base_type != NULL) && base_type->is_autobox_cache()) {\n+            if ((base_type != nullptr) && base_type->is_autobox_cache()) {\n@@ -2030,1 +2030,1 @@\n-    if (!is_mismatched_access() && off != Type::OffsetBot && const_oop != NULL && const_oop->is_instance()) {\n+    if (!is_mismatched_access() && off != Type::OffsetBot && const_oop != nullptr && const_oop->is_instance()) {\n@@ -2032,3 +2032,3 @@\n-      if (mirror_type != NULL) {\n-        const Type* const_oop = NULL;\n-        ciInlineKlass* vk = mirror_type->is_inlinetype() ? mirror_type->as_inline_klass() : NULL;\n+      if (mirror_type != nullptr) {\n+        const Type* const_oop = nullptr;\n+        ciInlineKlass* vk = mirror_type->is_inlinetype() ? mirror_type->as_inline_klass() : nullptr;\n@@ -2036,1 +2036,1 @@\n-        if (vk != NULL && off == vk->default_value_offset()) {\n+        if (vk != nullptr && off == vk->default_value_offset()) {\n@@ -2041,1 +2041,1 @@\n-          const_oop = (vk == NULL) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->ref_instance());\n+          const_oop = (vk == nullptr) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->ref_instance());\n@@ -2043,1 +2043,1 @@\n-          const_oop = (vk == NULL) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->val_instance());\n+          const_oop = (vk == nullptr) ? TypePtr::NULL_PTR : TypeInstPtr::make(vk->val_instance());\n@@ -2045,1 +2045,1 @@\n-        if (const_oop != NULL) {\n+        if (const_oop != nullptr) {\n@@ -2050,1 +2050,1 @@\n-      if (con_type != NULL) {\n+      if (con_type != nullptr) {\n@@ -2074,1 +2074,1 @@\n-      if (tkls != NULL) {\n+      if (tkls != nullptr) {\n@@ -2087,1 +2087,1 @@\n-      if (base != NULL && base->is_Load() && offset == in_bytes(InlineKlass::default_value_offset_offset())) {\n+      if (base != nullptr && base->is_Load() && offset == in_bytes(InlineKlass::default_value_offset_offset())) {\n@@ -2089,1 +2089,1 @@\n-        if (tkls != NULL && tkls->is_loaded() && tkls->klass_is_exact() && tkls->exact_klass()->is_inlinetype() &&\n+        if (tkls != nullptr && tkls->is_loaded() && tkls->klass_is_exact() && tkls->exact_klass()->is_inlinetype() &&\n@@ -2100,1 +2100,1 @@\n-  if (tkls != NULL) {\n+  if (tkls != nullptr) {\n@@ -2123,1 +2123,1 @@\n-      if (aift != NULL)  return aift;\n+      if (aift != nullptr)  return aift;\n@@ -2130,1 +2130,1 @@\n-      ciKlass* klass = NULL;\n+      ciKlass* klass = nullptr;\n@@ -2141,1 +2141,1 @@\n-      if (klass != NULL) {\n+      if (klass != nullptr) {\n@@ -2178,2 +2178,2 @@\n-  bool is_instance = (tinst != NULL) && tinst->is_known_instance_field();\n-  bool is_boxed_value = (tinst != NULL) && tinst->is_ptr_to_boxed_value();\n+  bool is_instance = (tinst != nullptr) && tinst->is_known_instance_field();\n+  bool is_boxed_value = (tinst != nullptr) && tinst->is_ptr_to_boxed_value();\n@@ -2182,1 +2182,1 @@\n-    if (value != NULL && value->is_Con()) {\n+    if (value != nullptr && value->is_Con()) {\n@@ -2188,1 +2188,1 @@\n-  bool is_vect = (_type->isa_vect() != NULL);\n+  bool is_vect = (_type->isa_vect() != nullptr);\n@@ -2200,1 +2200,1 @@\n-  if (alloc != NULL) {\n+  if (alloc != nullptr) {\n@@ -2205,1 +2205,1 @@\n-      if (tkls != NULL && tkls->is_loaded() && tkls->klass_is_exact()) {\n+      if (tkls != nullptr && tkls->is_loaded() && tkls->klass_is_exact()) {\n@@ -2233,1 +2233,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2246,1 +2246,1 @@\n-  if (value != NULL && value->is_Con() &&\n+  if (value != nullptr && value->is_Con() &&\n@@ -2267,1 +2267,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2280,1 +2280,1 @@\n-  if (value != NULL && value->is_Con() &&\n+  if (value != nullptr && value->is_Con() &&\n@@ -2301,1 +2301,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2314,1 +2314,1 @@\n-  if (value != NULL && value->is_Con() &&\n+  if (value != nullptr && value->is_Con() &&\n@@ -2335,1 +2335,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2348,1 +2348,1 @@\n-  if (value != NULL && value->is_Con() &&\n+  if (value != nullptr && value->is_Con() &&\n@@ -2366,1 +2366,1 @@\n-  assert(adr_type != NULL, \"expecting TypeKlassPtr\");\n+  assert(adr_type != nullptr, \"expecting TypeKlassPtr\");\n@@ -2402,1 +2402,1 @@\n-  if (tinst != NULL) {\n+  if (tinst != nullptr) {\n@@ -2413,1 +2413,1 @@\n-      if (t != NULL) {\n+      if (t != nullptr) {\n@@ -2424,1 +2424,1 @@\n-          \/\/ a primitive Class (e.g., int.class) has NULL for a klass field\n+          \/\/ a primitive Class (e.g., int.class) has null for a klass field\n@@ -2441,1 +2441,1 @@\n-  if (tary != NULL && tary->elem() != Type::BOTTOM &&\n+  if (tary != nullptr && tary->elem() != Type::BOTTOM &&\n@@ -2448,1 +2448,1 @@\n-  if (tkls != NULL && !StressReflectiveCode) {\n+  if (tkls != nullptr && !StressReflectiveCode) {\n@@ -2461,1 +2461,1 @@\n-    if (tkls->isa_instklassptr() != NULL && tkls->klass_is_exact() &&\n+    if (tkls->isa_instklassptr() != nullptr && tkls->klass_is_exact() &&\n@@ -2490,1 +2490,1 @@\n-  if (base == NULL)     return this;\n+  if (base == nullptr)     return this;\n@@ -2492,1 +2492,1 @@\n-  if (toop == NULL)     return this;\n+  if (toop == nullptr)     return this;\n@@ -2504,1 +2504,1 @@\n-    if (allocated_klass != NULL) {\n+    if (allocated_klass != nullptr) {\n@@ -2525,1 +2525,1 @@\n-        if (tkls != NULL && !tkls->empty()\n+        if (tkls != nullptr && !tkls->empty()\n@@ -2584,1 +2584,1 @@\n-  if (p)  return (p == NodeSentinel) ? NULL : p;\n+  if (p)  return (p == NodeSentinel) ? nullptr : p;\n@@ -2591,1 +2591,1 @@\n-  if (base == NULL)     return NULL;\n+  if (base == nullptr)     return nullptr;\n@@ -2593,1 +2593,1 @@\n-  if (tary == NULL)     return NULL;\n+  if (tary == nullptr)     return nullptr;\n@@ -2599,1 +2599,1 @@\n-    if (alloc != NULL) {\n+    if (alloc != nullptr) {\n@@ -2609,1 +2609,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2623,1 +2623,1 @@\n-  if (base == NULL)     return this;\n+  if (base == nullptr)     return this;\n@@ -2625,1 +2625,1 @@\n-  if (tary == NULL)     return this;\n+  if (tary == nullptr)     return this;\n@@ -2631,1 +2631,1 @@\n-    if (alloc != NULL) {\n+    if (alloc != nullptr) {\n@@ -2653,1 +2653,1 @@\n-         ctl != NULL, \"raw memory operations should have control edge\");\n+         ctl != nullptr, \"raw memory operations should have control edge\");\n@@ -2684,1 +2684,1 @@\n-    return (StoreNode*)NULL;\n+    return (StoreNode*)nullptr;\n@@ -2708,1 +2708,1 @@\n-  if (p)  return (p == NodeSentinel) ? NULL : p;\n+  if (p)  return (p == NodeSentinel) ? nullptr : p;\n@@ -2767,1 +2767,1 @@\n-      if (moved != NULL) {\n+      if (moved != nullptr) {\n@@ -2788,1 +2788,1 @@\n-  return NULL;                  \/\/ No further progress\n+  return nullptr;                  \/\/ No further progress\n@@ -2845,1 +2845,1 @@\n-      if (prev_mem != NULL) {\n+      if (prev_mem != nullptr) {\n@@ -2847,1 +2847,1 @@\n-        if (prev_val != NULL && prev_val == val) {\n+        if (prev_val != nullptr && prev_val == val) {\n@@ -2857,1 +2857,1 @@\n-  if (result != this && igvn != NULL) {\n+  if (result != this && igvn != nullptr) {\n@@ -2859,1 +2859,1 @@\n-    if (trailing != NULL) {\n+    if (trailing != nullptr) {\n@@ -2862,1 +2862,1 @@\n-      assert(t_oop == NULL || t_oop->is_known_instance_field(), \"only for non escaping objects\");\n+      assert(t_oop == nullptr || t_oop->is_known_instance_field(), \"only for non escaping objects\");\n@@ -2898,1 +2898,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2922,1 +2922,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2933,1 +2933,1 @@\n-  if (adr_oop == NULL)\n+  if (adr_oop == nullptr)\n@@ -2948,1 +2948,1 @@\n-    MemBarNode* trailing_mb = NULL;\n+    MemBarNode* trailing_mb = nullptr;\n@@ -2954,1 +2954,1 @@\n-          assert(trailing_mb == NULL, \"only one\");\n+          assert(trailing_mb == nullptr, \"only one\");\n@@ -2969,1 +2969,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2980,1 +2980,1 @@\n-  if( progress != NULL ) return progress;\n+  if( progress != nullptr ) return progress;\n@@ -2983,1 +2983,1 @@\n-  if( progress != NULL ) return progress;\n+  if( progress != nullptr ) return progress;\n@@ -2995,1 +2995,1 @@\n-  if( progress != NULL ) return progress;\n+  if( progress != nullptr ) return progress;\n@@ -2998,1 +2998,1 @@\n-  if( progress != NULL ) return progress;\n+  if( progress != nullptr ) return progress;\n@@ -3022,1 +3022,1 @@\n-  if (progress != NULL) return progress;\n+  if (progress != nullptr) return progress;\n@@ -3035,1 +3035,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3054,1 +3054,1 @@\n-  if (in(0) == NULL || phase->type(in(0)) == Type::TOP) {\n+  if (in(0) == nullptr || phase->type(in(0)) == Type::TOP) {\n@@ -3110,1 +3110,1 @@\n-  MemBarNode* trailing = NULL;\n+  MemBarNode* trailing = nullptr;\n@@ -3116,1 +3116,1 @@\n-        assert(trailing == NULL, \"only one\");\n+        assert(trailing == nullptr, \"only one\");\n@@ -3137,1 +3137,1 @@\n-LoadStoreConditionalNode::LoadStoreConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex ) : LoadStoreNode(c, mem, adr, val, NULL, TypeInt::BOOL, 5) {\n+LoadStoreConditionalNode::LoadStoreConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ex ) : LoadStoreNode(c, mem, adr, val, nullptr, TypeInt::BOOL, 5) {\n@@ -3154,1 +3154,1 @@\n-  if (adr == NULL)  return NULL; \/\/ node is dead\n+  if (adr == nullptr)  return nullptr; \/\/ node is dead\n@@ -3174,1 +3174,1 @@\n-  if (_is_large) return NULL;\n+  if (_is_large) return nullptr;\n@@ -3178,2 +3178,2 @@\n-  if (!t)  return NULL;\n-  if (!t->is_con())  return NULL;\n+  if (!t)  return nullptr;\n+  if (!t->is_con())  return nullptr;\n@@ -3186,1 +3186,1 @@\n-  if (size <= 0 || size % unit != 0)  return NULL;\n+  if (size <= 0 || size % unit != 0)  return nullptr;\n@@ -3193,1 +3193,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3195,1 +3195,1 @@\n-  if (!IdealizeClearArrayNode) return NULL;\n+  if (!IdealizeClearArrayNode) return nullptr;\n@@ -3197,1 +3197,1 @@\n-  if( phase->type(mem)==Type::TOP ) return NULL;\n+  if( phase->type(mem)==Type::TOP ) return nullptr;\n@@ -3200,1 +3200,1 @@\n-  if( at==Type::TOP ) return NULL;\n+  if( at==Type::TOP ) return nullptr;\n@@ -3203,1 +3203,1 @@\n-  if (atp == NULL)  atp = TypePtr::BOTTOM;\n+  if (atp == nullptr)  atp = TypePtr::BOTTOM;\n@@ -3233,1 +3233,1 @@\n-  assert(alloc != NULL, \"should have allocation\");\n+  assert(alloc != nullptr, \"should have allocation\");\n@@ -3240,1 +3240,1 @@\n-  if (init != NULL)\n+  if (init != nullptr)\n@@ -3262,1 +3262,1 @@\n-    if (val != NULL) {\n+    if (val != nullptr) {\n@@ -3266,1 +3266,1 @@\n-      assert(raw_val == NULL, \"val may not be null\");\n+      assert(raw_val == nullptr, \"val may not be null\");\n@@ -3302,1 +3302,1 @@\n-  if (raw_val == NULL) {\n+  if (raw_val == nullptr) {\n@@ -3333,1 +3333,1 @@\n-    if (val != NULL) {\n+    if (val != nullptr) {\n@@ -3337,1 +3337,1 @@\n-      assert(raw_val == NULL, \"val may not be null\");\n+      assert(raw_val == nullptr, \"val may not be null\");\n@@ -3349,1 +3349,1 @@\n-  : MultiNode(TypeFunc::Parms + (precedent == NULL? 0: 1)),\n+  : MultiNode(TypeFunc::Parms + (precedent == nullptr? 0: 1)),\n@@ -3360,1 +3360,1 @@\n-  if (precedent != NULL)\n+  if (precedent != nullptr)\n@@ -3385,1 +3385,1 @@\n-  default: ShouldNotReachHere(); return NULL;\n+  default: ShouldNotReachHere(); return nullptr;\n@@ -3396,1 +3396,1 @@\n-    if (leading != NULL) {\n+    if (leading != nullptr) {\n@@ -3401,1 +3401,1 @@\n-  if (proj_out_or_null(TypeFunc::Memory) != NULL) {\n+  if (proj_out_or_null(TypeFunc::Memory) != nullptr) {\n@@ -3404,1 +3404,1 @@\n-  if (proj_out_or_null(TypeFunc::Control) != NULL) {\n+  if (proj_out_or_null(TypeFunc::Control) != nullptr) {\n@@ -3416,1 +3416,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3428,1 +3428,1 @@\n-      if ((my_mem != NULL) && (opc == Op_MemBarAcquire) && (my_mem->outcnt() == 1)) {\n+      if ((my_mem != nullptr) && (opc == Op_MemBarAcquire) && (my_mem->outcnt() == 1)) {\n@@ -3440,1 +3440,1 @@\n-          my_mem = NULL;\n+          my_mem = nullptr;\n@@ -3444,1 +3444,1 @@\n-      if (my_mem != NULL && my_mem->is_Mem()) {\n+      if (my_mem != nullptr && my_mem->is_Mem()) {\n@@ -3447,1 +3447,1 @@\n-        if( t_oop != NULL && t_oop->is_known_instance_field() &&\n+        if( t_oop != nullptr && t_oop->is_known_instance_field() &&\n@@ -3456,1 +3456,1 @@\n-      if ((alloc != NULL) && alloc->is_Allocate() &&\n+      if ((alloc != nullptr) && alloc->is_Allocate() &&\n@@ -3471,1 +3471,1 @@\n-  return progress ? this : NULL;\n+  return progress ? this : nullptr;\n@@ -3491,1 +3491,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3521,1 +3521,1 @@\n-      trailing = NULL;\n+      trailing = nullptr;\n@@ -3536,1 +3536,1 @@\n-      if (trailing != NULL && !seen.test_set(trailing->_idx)) {\n+      if (trailing != nullptr && !seen.test_set(trailing->_idx)) {\n@@ -3562,4 +3562,4 @@\n-  while (leading != NULL && (!leading->is_MemBar() || !leading->as_MemBar()->leading())) {\n-    while (leading == NULL || leading->is_top() || seen.test_set(leading->_idx)) {\n-      leading = NULL;\n-      while (regions.size() > 0 && leading == NULL) {\n+  while (leading != nullptr && (!leading->is_MemBar() || !leading->as_MemBar()->leading())) {\n+    while (leading == nullptr || leading->is_top() || seen.test_set(leading->_idx)) {\n+      leading = nullptr;\n+      while (regions.size() > 0 && leading == nullptr) {\n@@ -3575,1 +3575,1 @@\n-      if (leading == NULL) {\n+      if (leading == nullptr) {\n@@ -3577,1 +3577,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -3596,1 +3596,1 @@\n-        if (in != NULL && !in->is_top()) {\n+        if (in != nullptr && !in->is_top()) {\n@@ -3606,1 +3606,1 @@\n-        if (in != NULL && !in->is_top()) {\n+        if (in != nullptr && !in->is_top()) {\n@@ -3612,1 +3612,1 @@\n-  assert(found == 1 || (found == 0 && leading == NULL), \"consistency check failed\");\n+  assert(found == 1 || (found == 0 && leading == nullptr), \"consistency check failed\");\n@@ -3614,2 +3614,2 @@\n-  if (leading == NULL) {\n-    return NULL;\n+  if (leading == nullptr) {\n+    return nullptr;\n@@ -3725,1 +3725,1 @@\n-  \/\/ Note:  allocation() can be NULL, for secondary initialization barriers\n+  \/\/ Note:  allocation() can be null, for secondary initialization barriers\n@@ -3771,1 +3771,1 @@\n-  if (init == NULL || init->is_complete()) {\n+  if (init == nullptr || init->is_complete()) {\n@@ -3803,1 +3803,1 @@\n-  if (base == NULL)     return -1;  \/\/ something is dead,\n+  if (base == nullptr)  return -1;  \/\/ something is dead,\n@@ -3826,1 +3826,1 @@\n-    if (n == NULL)      continue;   \/\/ (can this really happen?)\n+    if (n == nullptr)   continue;   \/\/ (can this really happen?)\n@@ -3839,1 +3839,1 @@\n-    if (ctl != NULL && !ctl->is_top()) {\n+    if (ctl != nullptr && !ctl->is_top()) {\n@@ -3855,1 +3855,1 @@\n-      if (m == NULL || m == n || m->is_top())  continue;\n+      if (m == nullptr || m == n || m->is_top())  continue;\n@@ -3874,1 +3874,1 @@\n-  if (!(ctl != NULL && ctl->is_Proj() && ctl->in(0) == this))\n+  if (!(ctl != nullptr && ctl->is_Proj() && ctl->in(0) == this))\n@@ -3882,1 +3882,1 @@\n-  if (alloc == NULL)\n+  if (alloc == nullptr)\n@@ -3910,1 +3910,1 @@\n-    Node* unique_merge = NULL;\n+    Node* unique_merge = nullptr;\n@@ -3920,1 +3920,1 @@\n-        } else if (n->in(0) != NULL && n->in(0) != ctl) {\n+        } else if (n->in(0) != nullptr && n->in(0) != ctl) {\n@@ -3942,1 +3942,1 @@\n-            if (other_t_adr != NULL) {\n+            if (other_t_adr != nullptr) {\n@@ -3959,1 +3959,1 @@\n-                if (base != NULL) {\n+                if (base != nullptr) {\n@@ -4004,1 +4004,1 @@\n-  assert(allocation() != NULL, \"must be present\");\n+  assert(allocation() != nullptr, \"must be present\");\n@@ -4056,1 +4056,1 @@\n-    return NULL;                \/\/ something is dead\n+    return nullptr;              \/\/ something is dead\n@@ -4100,1 +4100,1 @@\n-  if (start < 0)  return NULL;\n+  if (start < 0)  return nullptr;\n@@ -4106,2 +4106,2 @@\n-  if (i == 0)  return NULL;     \/\/ bail out\n-  Node* prev_mem = NULL;        \/\/ raw memory for the captured store\n+  if (i == 0)  return nullptr;  \/\/ bail out\n+  Node* prev_mem = nullptr;     \/\/ raw memory for the captured store\n@@ -4141,1 +4141,1 @@\n-  assert(check_st == new_st || check_st == NULL, \"must be findable\");\n+  assert(check_st == new_st || check_st == nullptr, \"must be findable\");\n@@ -4269,1 +4269,1 @@\n-        if (con != 0 && st != NULL && st->Opcode() == Op_StoreI) {\n+        if (con != 0 && st != nullptr && st->Opcode() == Op_StoreI) {\n@@ -4278,1 +4278,1 @@\n-          nodes[j] = NULL;      \/\/ undo nodes[j] = st\n+          nodes[j] = nullptr;   \/\/ undo nodes[j] = st\n@@ -4315,1 +4315,1 @@\n-    assert(old != NULL, \"need the prior store\");\n+    assert(old != nullptr, \"need the prior store\");\n@@ -4392,1 +4392,1 @@\n-  if (C->log() != NULL)\n+  if (C->log() != nullptr)\n@@ -4463,1 +4463,1 @@\n-  assert(allocation() != NULL, \"must be present\");\n+  assert(allocation() != nullptr, \"must be present\");\n@@ -4568,1 +4568,1 @@\n-    const Type* val = NULL;\n+    const Type* val = nullptr;\n@@ -4594,2 +4594,2 @@\n-      assert(alloc != NULL, \"must be present\");\n-      if (alloc != NULL && alloc->Opcode() == Op_Allocate) {\n+      assert(alloc != nullptr, \"must be present\");\n+      if (alloc != nullptr && alloc->Opcode() == Op_Allocate) {\n@@ -4619,1 +4619,1 @@\n-  assert(allocation() != NULL, \"must be present\");\n+  assert(allocation() != nullptr, \"must be present\");\n@@ -4695,1 +4695,1 @@\n-\/\/ MergeMem nodes never (?) have control inputs, so in(0) is NULL.\n+\/\/ MergeMem nodes never (?) have control inputs, so in(0) is null.\n@@ -4748,1 +4748,1 @@\n-  \/\/ set_input(0, NULL);  \/\/ no control input\n+  \/\/ set_input(0, nullptr);  \/\/ no control input\n@@ -4757,1 +4757,1 @@\n-  if( new_base != NULL && new_base->is_MergeMem() ) {\n+  if( new_base != nullptr && new_base->is_MergeMem() ) {\n@@ -4807,1 +4807,1 @@\n-  Node *progress = NULL;\n+  Node *progress = nullptr;\n@@ -4813,1 +4813,1 @@\n-    return NULL; \/\/ Dead memory path.\n+    return nullptr; \/\/ Dead memory path.\n@@ -4816,1 +4816,1 @@\n-  if (old_base != NULL && old_base->is_MergeMem())\n+  if (old_base != nullptr && old_base->is_MergeMem())\n@@ -4819,1 +4819,1 @@\n-    old_mbase = NULL;\n+    old_mbase = nullptr;\n@@ -4847,1 +4847,1 @@\n-    if (old_mem != NULL && old_mem->is_MergeMem())\n+    if (old_mem != nullptr && old_mem->is_MergeMem())\n@@ -4850,1 +4850,1 @@\n-      old_mmem = NULL;\n+      old_mmem = nullptr;\n@@ -4865,1 +4865,1 @@\n-    else if (old_mmem != NULL) {\n+    else if (old_mmem != nullptr) {\n@@ -4900,1 +4900,1 @@\n-    if( m != NULL &&\n+    if( m != nullptr &&\n@@ -4962,1 +4962,1 @@\n-    Node* mem = (in(i) != NULL) ? memory_at(i) : base_mem;\n+    Node* mem = (in(i) != nullptr) ? memory_at(i) : base_mem;\n@@ -4986,1 +4986,1 @@\n-  assert(n != NULL, \"\");\n+  assert(n != nullptr, \"\");\n@@ -4996,1 +4996,1 @@\n-    assert(n_adr_type != NULL, \"new memory must have a well-defined adr_type\");\n+    assert(n_adr_type != nullptr, \"new memory must have a well-defined adr_type\");\n@@ -5032,2 +5032,2 @@\n-           || n == NULL || n->bottom_type() == Type::TOP\n-           || n->adr_type() == NULL \/\/ address is TOP\n+           || n == nullptr || n->bottom_type() == Type::TOP\n+           || n->adr_type() == nullptr \/\/ address is TOP\n@@ -5075,1 +5075,1 @@\n-  if (other != NULL) {\n+  if (other != nullptr) {\n@@ -5086,1 +5086,1 @@\n-  if (base_mem != NULL && !base_mem->is_top()) {\n+  if (base_mem != nullptr && !base_mem->is_top()) {\n@@ -5116,1 +5116,1 @@\n-    assert(in(i) != NULL, \"sane slice\");\n+    assert(in(i) != nullptr, \"sane slice\");\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":344,"deletions":344,"binary":false,"changes":688,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-\/\/ Load or Store, possibly throwing a NULL pointer exception\n+\/\/ Load or Store, possibly throwing a null pointer exception\n@@ -95,1 +95,1 @@\n-  virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const { return NULL; }\n+  virtual Node* find_previous_arraycopy(PhaseTransform* phase, Node* ld_alloc, Node*& mem, bool can_see_stored_value) const { return nullptr; }\n@@ -114,1 +114,1 @@\n-  Node *Ideal_common(PhaseGVN *phase, bool can_reshape);  \/\/ Return -1 for short-circuit NULL.\n+  Node *Ideal_common(PhaseGVN *phase, bool can_reshape);  \/\/ Return -1 for short-circuit null.\n@@ -117,1 +117,1 @@\n-  static const TypePtr* calculate_adr_type(const Type* t, const TypePtr* cross_check = NULL);\n+  static const TypePtr* calculate_adr_type(const Type* t, const TypePtr* cross_check = nullptr);\n@@ -269,1 +269,1 @@\n-    assert(t != NULL, \"sanity\");\n+    assert(t != nullptr, \"sanity\");\n@@ -275,1 +275,1 @@\n-  const Type* type() const { assert(_type != NULL, \"sanity\"); return _type; };\n+  const Type* type() const { assert(_type != nullptr, \"sanity\"); return _type; };\n@@ -814,1 +814,1 @@\n-    if (ctrl == NULL)  return NULL; \/\/ node is dead\n+    if (ctrl == nullptr)  return nullptr; \/\/ node is dead\n@@ -1182,1 +1182,1 @@\n-                          Node* precedent = NULL);\n+                          Node* precedent = nullptr);\n@@ -1376,1 +1376,1 @@\n-  \/\/ Return the captured copy, else NULL if there is some sort of problem.\n+  \/\/ Return the captured copy, else null if there is some sort of problem.\n@@ -1381,1 +1381,1 @@\n-  \/\/ if there is no such store.  Return NULL if there is a problem.\n+  \/\/ if there is no such store.  Return null if there is a problem.\n@@ -1445,1 +1445,1 @@\n-  void iteration_setup(const MergeMemNode* other = NULL);\n+  void iteration_setup(const MergeMemNode* other = nullptr);\n@@ -1465,1 +1465,1 @@\n-  void init(MergeMemNode* mm, const MergeMemNode* mm2 = NULL) {\n+  void init(MergeMemNode* mm, const MergeMemNode* mm2 = nullptr) {\n@@ -1479,1 +1479,1 @@\n-    assert(mm2==NULL || mm2->verify_sparse(), \"please, no dups of base\");\n+    assert(mm2==nullptr || mm2->verify_sparse(), \"please, no dups of base\");\n@@ -1486,2 +1486,2 @@\n-    _mem = NULL;\n-    _mem2 = NULL;\n+    _mem = nullptr;\n+    _mem2 = nullptr;\n@@ -1545,1 +1545,1 @@\n-    assert(_mm2 != NULL, \"\");\n+    assert(_mm2 != nullptr, \"\");\n@@ -1616,1 +1616,1 @@\n-    assert((_mm2 != NULL) == have_mm2, \"use other next\");\n+    assert((_mm2 != nullptr) == have_mm2, \"use other next\");\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-  Node* progress = NULL;        \/\/ Progress flag\n+  Node* progress = nullptr;        \/\/ Progress flag\n@@ -126,1 +126,1 @@\n-    if( t2 == Type::TOP ) return NULL;\n+    if( t2 == Type::TOP ) return nullptr;\n@@ -236,1 +236,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -254,1 +254,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -266,1 +266,1 @@\n-  Node *res = NULL;\n+  Node *res = nullptr;\n@@ -296,34 +296,69 @@\n-\/\/------------------------------mul_ring---------------------------------------\n-\/\/ Compute the product type of two integer ranges into this node.\n-const Type *MulINode::mul_ring(const Type *t0, const Type *t1) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  \/\/ Fetch endpoints of all ranges\n-  jint lo0 = r0->_lo;\n-  double a = (double)lo0;\n-  jint hi0 = r0->_hi;\n-  double b = (double)hi0;\n-  jint lo1 = r1->_lo;\n-  double c = (double)lo1;\n-  jint hi1 = r1->_hi;\n-  double d = (double)hi1;\n-\n-  \/\/ Compute all endpoints & check for overflow\n-  int32_t A = java_multiply(lo0, lo1);\n-  if( (double)A != a*c ) return TypeInt::INT; \/\/ Overflow?\n-  int32_t B = java_multiply(lo0, hi1);\n-  if( (double)B != a*d ) return TypeInt::INT; \/\/ Overflow?\n-  int32_t C = java_multiply(hi0, lo1);\n-  if( (double)C != b*c ) return TypeInt::INT; \/\/ Overflow?\n-  int32_t D = java_multiply(hi0, hi1);\n-  if( (double)D != b*d ) return TypeInt::INT; \/\/ Overflow?\n-\n-  if( A < B ) { lo0 = A; hi0 = B; } \/\/ Sort range endpoints\n-  else { lo0 = B; hi0 = A; }\n-  if( C < D ) {\n-    if( C < lo0 ) lo0 = C;\n-    if( D > hi0 ) hi0 = D;\n-  } else {\n-    if( D < lo0 ) lo0 = D;\n-    if( C > hi0 ) hi0 = C;\n+\/\/ Classes to perform mul_ring() for MulI\/MulLNode.\n+\/\/\n+\/\/ This class checks if all cross products of the left and right input of a multiplication have the same \"overflow value\".\n+\/\/ Without overflow\/underflow:\n+\/\/ Product is positive? High signed multiplication result: 0\n+\/\/ Product is negative? High signed multiplication result: -1\n+\/\/\n+\/\/ We normalize these values (see normalize_overflow_value()) such that we get the same \"overflow value\" by adding 1 if\n+\/\/ the product is negative. This allows us to compare all the cross product \"overflow values\". If one is different,\n+\/\/ compared to the others, then we know that this multiplication has a different number of over- or underflows compared\n+\/\/ to the others. In this case, we need to use bottom type and cannot guarantee a better type. Otherwise, we can take\n+\/\/ the min und max of all computed cross products as type of this Mul node.\n+template<typename IntegerType>\n+class IntegerMulRing {\n+  using NativeType = std::conditional_t<std::is_same<TypeInt, IntegerType>::value, jint, jlong>;\n+\n+  NativeType _lo_left;\n+  NativeType _lo_right;\n+  NativeType _hi_left;\n+  NativeType _hi_right;\n+  NativeType _lo_lo_product;\n+  NativeType _lo_hi_product;\n+  NativeType _hi_lo_product;\n+  NativeType _hi_hi_product;\n+  short _widen_left;\n+  short _widen_right;\n+\n+  static const Type* overflow_type();\n+  static NativeType multiply_high_signed_overflow_value(NativeType x, NativeType y);\n+\n+  \/\/ Pre-compute cross products which are used at several places\n+  void compute_cross_products() {\n+    _lo_lo_product = java_multiply(_lo_left, _lo_right);\n+    _lo_hi_product = java_multiply(_lo_left, _hi_right);\n+    _hi_lo_product = java_multiply(_hi_left, _lo_right);\n+    _hi_hi_product = java_multiply(_hi_left, _hi_right);\n+  }\n+\n+  bool cross_products_not_same_overflow() const {\n+    const NativeType lo_lo_high_product = multiply_high_signed_overflow_value(_lo_left, _lo_right);\n+    const NativeType lo_hi_high_product = multiply_high_signed_overflow_value(_lo_left, _hi_right);\n+    const NativeType hi_lo_high_product = multiply_high_signed_overflow_value(_hi_left, _lo_right);\n+    const NativeType hi_hi_high_product = multiply_high_signed_overflow_value(_hi_left, _hi_right);\n+    return lo_lo_high_product != lo_hi_high_product ||\n+           lo_hi_high_product != hi_lo_high_product ||\n+           hi_lo_high_product != hi_hi_high_product;\n+  }\n+\n+  static NativeType normalize_overflow_value(const NativeType x, const NativeType y, NativeType result) {\n+    return java_multiply(x, y) < 0 ? result + 1 : result;\n+  }\n+\n+ public:\n+  IntegerMulRing(const IntegerType* left, const IntegerType* right) : _lo_left(left->_lo), _lo_right(right->_lo),\n+    _hi_left(left->_hi), _hi_right(right->_hi), _widen_left(left->_widen), _widen_right(right->_widen)  {\n+    compute_cross_products();\n+  }\n+\n+  \/\/ Compute the product type by multiplying the two input type ranges. We take the minimum and maximum of all possible\n+  \/\/ values (requires 4 multiplications of all possible combinations of the two range boundary values). If any of these\n+  \/\/ multiplications overflows\/underflows, we need to make sure that they all have the same number of overflows\/underflows\n+  \/\/ If that is not the case, we return the bottom type to cover all values due to the inconsistent overflows\/underflows).\n+  const Type* compute() const {\n+    if (cross_products_not_same_overflow()) {\n+      return overflow_type();\n+    }\n+    const NativeType min = MIN4(_lo_lo_product, _lo_hi_product, _hi_lo_product, _hi_hi_product);\n+    const NativeType max = MAX4(_lo_lo_product, _lo_hi_product, _hi_lo_product, _hi_hi_product);\n+    return IntegerType::make(min, max, MAX2(_widen_left, _widen_right));\n@@ -331,1 +366,6 @@\n-  return TypeInt::make(lo0, hi0, MAX2(r0->_widen,r1->_widen));\n+};\n+\n+\n+template <>\n+const Type* IntegerMulRing<TypeInt>::overflow_type() {\n+  return TypeInt::INT;\n@@ -334,0 +374,31 @@\n+template <>\n+jint IntegerMulRing<TypeInt>::multiply_high_signed_overflow_value(const jint x, const jint y) {\n+  const jlong x_64 = x;\n+  const jlong y_64 = y;\n+  const jlong product = x_64 * y_64;\n+  const jint result = (jint)((uint64_t)product >> 32u);\n+  return normalize_overflow_value(x, y, result);\n+}\n+\n+template <>\n+const Type* IntegerMulRing<TypeLong>::overflow_type() {\n+  return TypeLong::LONG;\n+}\n+\n+template <>\n+jlong IntegerMulRing<TypeLong>::multiply_high_signed_overflow_value(const jlong x, const jlong y) {\n+  const jlong result = multiply_high_signed(x, y);\n+  return normalize_overflow_value(x, y, result);\n+}\n+\n+\/\/ Compute the product type of two integer ranges into this node.\n+const Type* MulINode::mul_ring(const Type* type_left, const Type* type_right) const {\n+  const IntegerMulRing<TypeInt> integer_mul_ring(type_left->is_int(), type_right->is_int());\n+  return integer_mul_ring.compute();\n+}\n+\n+\/\/ Compute the product type of two long ranges into this node.\n+const Type* MulLNode::mul_ring(const Type* type_left, const Type* type_right) const {\n+  const IntegerMulRing<TypeLong> integer_mul_ring(type_left->is_long(), type_right->is_long());\n+  return integer_mul_ring.compute();\n+}\n@@ -349,1 +420,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -360,1 +431,1 @@\n-  Node *res = NULL;\n+  Node *res = nullptr;\n@@ -392,38 +463,0 @@\n-\/\/------------------------------mul_ring---------------------------------------\n-\/\/ Compute the product type of two integer ranges into this node.\n-const Type *MulLNode::mul_ring(const Type *t0, const Type *t1) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-\n-  \/\/ Fetch endpoints of all ranges\n-  jlong lo0 = r0->_lo;\n-  double a = (double)lo0;\n-  jlong hi0 = r0->_hi;\n-  double b = (double)hi0;\n-  jlong lo1 = r1->_lo;\n-  double c = (double)lo1;\n-  jlong hi1 = r1->_hi;\n-  double d = (double)hi1;\n-\n-  \/\/ Compute all endpoints & check for overflow\n-  jlong A = java_multiply(lo0, lo1);\n-  if( (double)A != a*c ) return TypeLong::LONG; \/\/ Overflow?\n-  jlong B = java_multiply(lo0, hi1);\n-  if( (double)B != a*d ) return TypeLong::LONG; \/\/ Overflow?\n-  jlong C = java_multiply(hi0, lo1);\n-  if( (double)C != b*c ) return TypeLong::LONG; \/\/ Overflow?\n-  jlong D = java_multiply(hi0, hi1);\n-  if( (double)D != b*d ) return TypeLong::LONG; \/\/ Overflow?\n-\n-  if( A < B ) { lo0 = A; hi0 = B; } \/\/ Sort range endpoints\n-  else { lo0 = B; hi0 = A; }\n-  if( C < D ) {\n-    if( C < lo0 ) lo0 = C;\n-    if( D > hi0 ) hi0 = D;\n-  } else {\n-    if( D < lo0 ) lo0 = D;\n-    if( C > hi0 ) hi0 = C;\n-  }\n-  return TypeLong::make(lo0, hi0, MAX2(r0->_widen,r1->_widen));\n-}\n-\n@@ -444,1 +477,1 @@\n-  if (t2 != NULL && t2->getf() == 2) {\n+  if (t2 != nullptr && t2->getf() == 2) {\n@@ -467,1 +500,1 @@\n-  if (t2 != NULL && t2->getd() == 2) {\n+  if (t2 != nullptr && t2->getd() == 2) {\n@@ -563,1 +596,1 @@\n-    if (t1 != NULL && t1->_lo >= 0) {\n+    if (t1 != nullptr && t1->_lo >= 0) {\n@@ -588,1 +621,1 @@\n-  if (progress != NULL) {\n+  if (progress != nullptr) {\n@@ -701,1 +734,1 @@\n-    if (t1 != NULL && t1->_lo >= 0) {\n+    if (t1 != nullptr && t1->_lo >= 0) {\n@@ -736,1 +769,1 @@\n-  if (progress != NULL) {\n+  if (progress != nullptr) {\n@@ -788,1 +821,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -795,1 +828,1 @@\n-  if (tcount != NULL && tcount->is_con()) {\n+  if (tcount != nullptr && tcount->is_con()) {\n@@ -839,1 +872,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -870,5 +903,39 @@\n-  \/\/ Check for \"(x>>c0)<<c0\" which just masks off low bits\n-  if( (add1_op == Op_RShiftI || add1_op == Op_URShiftI ) &&\n-      add1->in(2) == in(2) )\n-    \/\/ Convert to \"(x & -(1<<c0))\"\n-    return new AndINode(add1->in(1),phase->intcon( -(1<<con)));\n+  \/\/ Check for \"(x >> C1) << C2\"\n+  if (add1_op == Op_RShiftI || add1_op == Op_URShiftI) {\n+    \/\/ Special case C1 == C2, which just masks off low bits\n+    if (add1->in(2) == in(2)) {\n+      \/\/ Convert to \"(x & -(1 << C2))\"\n+      return new AndINode(add1->in(1), phase->intcon(-(1 << con)));\n+    } else {\n+      int add1Con = 0;\n+      const_shift_count(phase, add1, &add1Con);\n+\n+      \/\/ Wait until the right shift has been sharpened to the correct count\n+      if (add1Con > 0 && add1Con < BitsPerJavaInteger) {\n+        \/\/ As loop parsing can produce LShiftI nodes, we should wait until the graph is fully formed\n+        \/\/ to apply optimizations, otherwise we can inadvertently stop vectorization opportunities.\n+        if (phase->is_IterGVN()) {\n+          if (con > add1Con) {\n+            \/\/ Creates \"(x << (C2 - C1)) & -(1 << C2)\"\n+            Node* lshift = phase->transform(new LShiftINode(add1->in(1), phase->intcon(con - add1Con)));\n+            return new AndINode(lshift, phase->intcon(-(1 << con)));\n+          } else {\n+            assert(con < add1Con, \"must be (%d < %d)\", con, add1Con);\n+            \/\/ Creates \"(x >> (C1 - C2)) & -(1 << C2)\"\n+\n+            \/\/ Handle logical and arithmetic shifts\n+            Node* rshift;\n+            if (add1_op == Op_RShiftI) {\n+              rshift = phase->transform(new RShiftINode(add1->in(1), phase->intcon(add1Con - con)));\n+            } else {\n+              rshift = phase->transform(new URShiftINode(add1->in(1), phase->intcon(add1Con - con)));\n+            }\n+\n+            return new AndINode(rshift, phase->intcon(-(1 << con)));\n+          }\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n+    }\n+  }\n@@ -876,2 +943,2 @@\n-  \/\/ Check for \"((x>>c0) & Y)<<c0\" which just masks off more low bits\n-  if( add1_op == Op_AndI ) {\n+  \/\/ Check for \"((x >> C1) & Y) << C2\"\n+  if (add1_op == Op_AndI) {\n@@ -880,5 +947,24 @@\n-    if( (add2_op == Op_RShiftI || add2_op == Op_URShiftI ) &&\n-        add2->in(2) == in(2) ) {\n-      \/\/ Convert to \"(x & (Y<<c0))\"\n-      Node *y_sh = phase->transform( new LShiftINode( add1->in(2), in(2) ) );\n-      return new AndINode( add2->in(1), y_sh );\n+    if (add2_op == Op_RShiftI || add2_op == Op_URShiftI) {\n+      \/\/ Special case C1 == C2, which just masks off low bits\n+      if (add2->in(2) == in(2)) {\n+        \/\/ Convert to \"(x & (Y << C2))\"\n+        Node* y_sh = phase->transform(new LShiftINode(add1->in(2), phase->intcon(con)));\n+        return new AndINode(add2->in(1), y_sh);\n+      }\n+\n+      int add2Con = 0;\n+      const_shift_count(phase, add2, &add2Con);\n+      if (add2Con > 0 && add2Con < BitsPerJavaInteger) {\n+        if (phase->is_IterGVN()) {\n+          \/\/ Convert to \"((x >> C1) << C2) & (Y << C2)\"\n+\n+          \/\/ Make \"(x >> C1) << C2\", which will get folded away by the rule above\n+          Node* x_sh = phase->transform(new LShiftINode(add2, phase->intcon(con)));\n+          \/\/ Make \"Y << C2\", which will simplify when Y is a constant\n+          Node* y_sh = phase->transform(new LShiftINode(add1->in(2), phase->intcon(con)));\n+\n+          return new AndINode(x_sh, y_sh);\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n@@ -895,1 +981,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -962,1 +1048,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -993,5 +1079,39 @@\n-  \/\/ Check for \"(x>>c0)<<c0\" which just masks off low bits\n-  if( (add1_op == Op_RShiftL || add1_op == Op_URShiftL ) &&\n-      add1->in(2) == in(2) )\n-    \/\/ Convert to \"(x & -(1<<c0))\"\n-    return new AndLNode(add1->in(1),phase->longcon( -(CONST64(1)<<con)));\n+  \/\/ Check for \"(x >> C1) << C2\"\n+  if (add1_op == Op_RShiftL || add1_op == Op_URShiftL) {\n+    \/\/ Special case C1 == C2, which just masks off low bits\n+    if (add1->in(2) == in(2)) {\n+      \/\/ Convert to \"(x & -(1 << C2))\"\n+      return new AndLNode(add1->in(1), phase->longcon(-(CONST64(1) << con)));\n+    } else {\n+      int add1Con = 0;\n+      const_shift_count(phase, add1, &add1Con);\n+\n+      \/\/ Wait until the right shift has been sharpened to the correct count\n+      if (add1Con > 0 && add1Con < BitsPerJavaLong) {\n+        \/\/ As loop parsing can produce LShiftI nodes, we should wait until the graph is fully formed\n+        \/\/ to apply optimizations, otherwise we can inadvertently stop vectorization opportunities.\n+        if (phase->is_IterGVN()) {\n+          if (con > add1Con) {\n+            \/\/ Creates \"(x << (C2 - C1)) & -(1 << C2)\"\n+            Node* lshift = phase->transform(new LShiftLNode(add1->in(1), phase->intcon(con - add1Con)));\n+            return new AndLNode(lshift, phase->longcon(-(CONST64(1) << con)));\n+          } else {\n+            assert(con < add1Con, \"must be (%d < %d)\", con, add1Con);\n+            \/\/ Creates \"(x >> (C1 - C2)) & -(1 << C2)\"\n+\n+            \/\/ Handle logical and arithmetic shifts\n+            Node* rshift;\n+            if (add1_op == Op_RShiftL) {\n+              rshift = phase->transform(new RShiftLNode(add1->in(1), phase->intcon(add1Con - con)));\n+            } else {\n+              rshift = phase->transform(new URShiftLNode(add1->in(1), phase->intcon(add1Con - con)));\n+            }\n+\n+            return new AndLNode(rshift, phase->longcon(-(CONST64(1) << con)));\n+          }\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n+    }\n+  }\n@@ -999,3 +1119,3 @@\n-  \/\/ Check for \"((x>>c0) & Y)<<c0\" which just masks off more low bits\n-  if( add1_op == Op_AndL ) {\n-    Node *add2 = add1->in(1);\n+  \/\/ Check for \"((x >> C1) & Y) << C2\"\n+  if (add1_op == Op_AndL) {\n+    Node* add2 = add1->in(1);\n@@ -1003,5 +1123,24 @@\n-    if( (add2_op == Op_RShiftL || add2_op == Op_URShiftL ) &&\n-        add2->in(2) == in(2) ) {\n-      \/\/ Convert to \"(x & (Y<<c0))\"\n-      Node *y_sh = phase->transform( new LShiftLNode( add1->in(2), in(2) ) );\n-      return new AndLNode( add2->in(1), y_sh );\n+    if (add2_op == Op_RShiftL || add2_op == Op_URShiftL) {\n+      \/\/ Special case C1 == C2, which just masks off low bits\n+      if (add2->in(2) == in(2)) {\n+        \/\/ Convert to \"(x & (Y << C2))\"\n+        Node* y_sh = phase->transform(new LShiftLNode(add1->in(2), phase->intcon(con)));\n+        return new AndLNode(add2->in(1), y_sh);\n+      }\n+\n+      int add2Con = 0;\n+      const_shift_count(phase, add2, &add2Con);\n+      if (add2Con > 0 && add2Con < BitsPerJavaLong) {\n+        if (phase->is_IterGVN()) {\n+          \/\/ Convert to \"((x >> C1) << C2) & (Y << C2)\"\n+\n+          \/\/ Make \"(x >> C1) << C2\", which will get folded away by the rule above\n+          Node* x_sh = phase->transform(new LShiftLNode(add2, phase->intcon(con)));\n+          \/\/ Make \"Y << C2\", which will simplify when Y is a constant\n+          Node* y_sh = phase->transform(new LShiftLNode(add1->in(2), phase->intcon(con)));\n+\n+          return new AndLNode(x_sh, y_sh);\n+        } else {\n+          phase->record_for_igvn(this);\n+        }\n+      }\n@@ -1018,1 +1157,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1086,1 +1225,1 @@\n-      if (t11 == NULL) {\n+      if (t11 == nullptr) {\n@@ -1102,1 +1241,1 @@\n-  if (!t1) return NULL;        \/\/ Left input is an integer\n+  if (!t1) return nullptr;        \/\/ Left input is an integer\n@@ -1106,1 +1245,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1124,1 +1263,1 @@\n-  if( shl->Opcode() != Op_LShiftI ) return NULL;\n+  if( shl->Opcode() != Op_LShiftI ) return nullptr;\n@@ -1160,1 +1299,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1300,1 +1439,1 @@\n-        if (t_x != NULL && 0 <= t_x->_lo && t_x->_hi <= (max_jint>>LogBytesPerWord)) {\n+        if (t_x != nullptr && 0 <= t_x->_lo && t_x->_hi <= (max_jint>>LogBytesPerWord)) {\n@@ -1314,1 +1453,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1386,1 +1525,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1478,1 +1617,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1531,1 +1670,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1725,1 +1864,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1804,1 +1943,1 @@\n-  if (mask == NULL || shift == NULL) {\n+  if (mask == nullptr || shift == nullptr) {\n@@ -1808,1 +1947,1 @@\n-  if (shift == NULL) {\n+  if (shift == nullptr) {\n@@ -1813,1 +1952,1 @@\n-  if (mask_t == NULL || shift_t == NULL) {\n+  if (mask_t == nullptr || shift_t == nullptr) {\n@@ -1820,1 +1959,1 @@\n-    if (val == NULL) {\n+    if (val == nullptr) {\n@@ -1824,1 +1963,1 @@\n-    if (val == NULL) {\n+    if (val == nullptr) {\n@@ -1842,1 +1981,1 @@\n-  if (shift2 == NULL) {\n+  if (shift2 == nullptr) {\n@@ -1875,2 +2014,2 @@\n-  if (add == NULL || mask == NULL) {\n-    return NULL;\n+  if (add == nullptr || mask == nullptr) {\n+    return nullptr;\n@@ -1889,1 +2028,1 @@\n-    if (add1 != NULL && add2 != NULL) {\n+    if (add1 != nullptr && add2 != nullptr) {\n@@ -1899,1 +2038,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":278,"deletions":139,"binary":false,"changes":417,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -68,1 +68,1 @@\n-    if (proj != NULL && (proj->_con == which_proj) && (proj->_is_io_use == is_io_use)) {\n+    if (proj != nullptr && (proj->_con == which_proj) && (proj->_is_io_use == is_io_use)) {\n@@ -72,1 +72,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -79,1 +79,1 @@\n-  assert(p != NULL, \"named projection %u not found\", which_proj);\n+  assert(p != nullptr, \"named projection %u not found\", which_proj);\n@@ -116,1 +116,1 @@\n-  if (in(0) == NULL) return Type::TOP;\n+  if (in(0) == nullptr) return Type::TOP;\n@@ -124,1 +124,1 @@\n-    if (ctrl == NULL)  return NULL; \/\/ node is dead\n+    if (ctrl == nullptr)  return nullptr; \/\/ node is dead\n@@ -128,1 +128,1 @@\n-      assert(adr_type != NULL, \"source must have adr_type\");\n+      assert(adr_type != nullptr, \"source must have adr_type\");\n@@ -133,1 +133,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -145,1 +145,1 @@\n-    } else if (o == NULL) {\n+    } else if (o == nullptr) {\n@@ -158,1 +158,1 @@\n-  if (n == NULL)       return;  \/\/ should be assert, but NodeHash makes bogons\n+  if (n == nullptr)    return;  \/\/ should be assert, but NodeHash makes bogons\n@@ -169,1 +169,1 @@\n-  if (in(0) == NULL) return Type::TOP;\n+  if (in(0) == nullptr) return Type::TOP;\n@@ -186,1 +186,1 @@\n-\/\/ NULL otherwise\n+\/\/ null otherwise\n@@ -192,2 +192,2 @@\n-    if (out == NULL)\n-      return NULL;\n+    if (out == nullptr)\n+      return nullptr;\n@@ -203,1 +203,1 @@\n-      return NULL; \/\/ don't do further after call\n+      return nullptr; \/\/ don't do further after call\n@@ -206,1 +206,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -208,1 +208,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -216,1 +216,1 @@\n-\/\/ NULL otherwise\n+\/\/ null otherwise\n@@ -220,1 +220,1 @@\n-  if (!in0->is_If()) return NULL;\n+  if (!in0->is_If()) return nullptr;\n@@ -222,1 +222,1 @@\n-  if (in0->outcnt() < 2)  return NULL;\n+  if (in0->outcnt() < 2)  return nullptr;\n@@ -229,1 +229,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -235,1 +235,1 @@\n-  if (call != NULL) {\n+  if (call != nullptr) {\n@@ -240,1 +240,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/multnode.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  \/\/ NULL otherwise\n+  \/\/ null otherwise\n@@ -101,1 +101,1 @@\n-  \/\/ NULL otherwise\n+  \/\/ null otherwise\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  _debug_orig = NULL;\n+  _debug_orig = nullptr;\n@@ -99,1 +99,1 @@\n-  _last_del = NULL;\n+  _last_del = nullptr;\n@@ -114,1 +114,1 @@\n-  _last     = NULL;\n+  _last     = nullptr;\n@@ -295,1 +295,1 @@\n-\/\/ The value NULL is reserved for the top node only.\n+\/\/ The value null is reserved for the top node only.\n@@ -317,1 +317,1 @@\n-  if (nn != NULL)  init_node_notes(C, idx, nn);\n+  if (nn != nullptr)  init_node_notes(C, idx, nn);\n@@ -342,1 +342,1 @@\n-    _in = NULL;\n+    _in = nullptr;\n@@ -346,1 +346,1 @@\n-      to[i] = NULL;\n+      to[i] = nullptr;\n@@ -361,1 +361,1 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n@@ -375,2 +375,2 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n-  _in[1] = n1; if (n1 != NULL) n1->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n+  _in[1] = n1; if (n1 != nullptr) n1->add_out((Node *)this);\n@@ -391,3 +391,3 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n-  _in[1] = n1; if (n1 != NULL) n1->add_out((Node *)this);\n-  _in[2] = n2; if (n2 != NULL) n2->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n+  _in[1] = n1; if (n1 != nullptr) n1->add_out((Node *)this);\n+  _in[2] = n2; if (n2 != nullptr) n2->add_out((Node *)this);\n@@ -409,4 +409,4 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n-  _in[1] = n1; if (n1 != NULL) n1->add_out((Node *)this);\n-  _in[2] = n2; if (n2 != NULL) n2->add_out((Node *)this);\n-  _in[3] = n3; if (n3 != NULL) n3->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n+  _in[1] = n1; if (n1 != nullptr) n1->add_out((Node *)this);\n+  _in[2] = n2; if (n2 != nullptr) n2->add_out((Node *)this);\n+  _in[3] = n3; if (n3 != nullptr) n3->add_out((Node *)this);\n@@ -429,5 +429,5 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n-  _in[1] = n1; if (n1 != NULL) n1->add_out((Node *)this);\n-  _in[2] = n2; if (n2 != NULL) n2->add_out((Node *)this);\n-  _in[3] = n3; if (n3 != NULL) n3->add_out((Node *)this);\n-  _in[4] = n4; if (n4 != NULL) n4->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n+  _in[1] = n1; if (n1 != nullptr) n1->add_out((Node *)this);\n+  _in[2] = n2; if (n2 != nullptr) n2->add_out((Node *)this);\n+  _in[3] = n3; if (n3 != nullptr) n3->add_out((Node *)this);\n+  _in[4] = n4; if (n4 != nullptr) n4->add_out((Node *)this);\n@@ -452,6 +452,6 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n-  _in[1] = n1; if (n1 != NULL) n1->add_out((Node *)this);\n-  _in[2] = n2; if (n2 != NULL) n2->add_out((Node *)this);\n-  _in[3] = n3; if (n3 != NULL) n3->add_out((Node *)this);\n-  _in[4] = n4; if (n4 != NULL) n4->add_out((Node *)this);\n-  _in[5] = n5; if (n5 != NULL) n5->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n+  _in[1] = n1; if (n1 != nullptr) n1->add_out((Node *)this);\n+  _in[2] = n2; if (n2 != nullptr) n2->add_out((Node *)this);\n+  _in[3] = n3; if (n3 != nullptr) n3->add_out((Node *)this);\n+  _in[4] = n4; if (n4 != nullptr) n4->add_out((Node *)this);\n+  _in[5] = n5; if (n5 != nullptr) n5->add_out((Node *)this);\n@@ -477,7 +477,7 @@\n-  _in[0] = n0; if (n0 != NULL) n0->add_out((Node *)this);\n-  _in[1] = n1; if (n1 != NULL) n1->add_out((Node *)this);\n-  _in[2] = n2; if (n2 != NULL) n2->add_out((Node *)this);\n-  _in[3] = n3; if (n3 != NULL) n3->add_out((Node *)this);\n-  _in[4] = n4; if (n4 != NULL) n4->add_out((Node *)this);\n-  _in[5] = n5; if (n5 != NULL) n5->add_out((Node *)this);\n-  _in[6] = n6; if (n6 != NULL) n6->add_out((Node *)this);\n+  _in[0] = n0; if (n0 != nullptr) n0->add_out((Node *)this);\n+  _in[1] = n1; if (n1 != nullptr) n1->add_out((Node *)this);\n+  _in[2] = n2; if (n2 != nullptr) n2->add_out((Node *)this);\n+  _in[3] = n3; if (n3 != nullptr) n3->add_out((Node *)this);\n+  _in[4] = n4; if (n4 != nullptr) n4->add_out((Node *)this);\n+  _in[5] = n5; if (n5 != nullptr) n5->add_out((Node *)this);\n+  _in[6] = n6; if (n6 != nullptr) n6->add_out((Node *)this);\n@@ -512,1 +512,1 @@\n-    if (x != NULL) x->add_out(n);\n+    if (x != nullptr) x->add_out(n);\n@@ -561,1 +561,1 @@\n-    if (cg != NULL) {\n+    if (cg != nullptr) {\n@@ -590,1 +590,1 @@\n-    _out = NULL;                           \/\/ marker value for top\n+    _out = nullptr;                           \/\/ marker value for top\n@@ -593,1 +593,1 @@\n-    if (_out == NULL)  _out = NO_OUT_ARRAY;\n+    if (_out == nullptr)  _out = NO_OUT_ARRAY;\n@@ -601,2 +601,2 @@\n-  Compile* compile = (phase != NULL) ? phase->C : Compile::current();\n-  if (phase != NULL && phase->is_IterGVN()) {\n+  Compile* compile = (phase != nullptr) ? phase->C : Compile::current();\n+  if (phase != nullptr && phase->is_IterGVN()) {\n@@ -614,1 +614,1 @@\n-  if (nn != NULL)  nn->clear();\n+  if (nn != nullptr)  nn->clear();\n@@ -619,1 +619,1 @@\n-    set_req(i, NULL);\n+    set_req(i, nullptr);\n@@ -655,1 +655,1 @@\n-  char *out_array = (char*)(_out == NO_OUT_ARRAY? NULL: _out);\n+  char *out_array = (char*)(_out == NO_OUT_ARRAY? nullptr: _out);\n@@ -697,4 +697,4 @@\n-    to[0] = NULL;\n-    to[1] = NULL;\n-    to[2] = NULL;\n-    to[3] = NULL;\n+    to[0] = nullptr;\n+    to[1] = nullptr;\n+    to[2] = nullptr;\n+    to[3] = nullptr;\n@@ -708,1 +708,1 @@\n-  Copy::zero_to_bytes(&_in[_max], (new_max-_max)*sizeof(Node*)); \/\/ NULL all new space\n+  Copy::zero_to_bytes(&_in[_max], (new_max-_max)*sizeof(Node*)); \/\/ null all new space\n@@ -730,1 +730,1 @@\n-  assert(_out != NULL && _out != NO_OUT_ARRAY, \"out must have sensible value\");\n+  assert(_out != nullptr && _out != NO_OUT_ARRAY, \"out must have sensible value\");\n@@ -732,1 +732,1 @@\n-  \/\/Copy::zero_to_bytes(&_out[_outmax], (new_max-_outmax)*sizeof(Node*)); \/\/ NULL all new space\n+  \/\/Copy::zero_to_bytes(&_out[_outmax], (new_max-_outmax)*sizeof(Node*)); \/\/ null all new space\n@@ -746,1 +746,1 @@\n-    if( _in[i] != NULL )\n+    if( _in[i] != nullptr )\n@@ -777,1 +777,1 @@\n-  return outcnt() == 0 || igvn.type(this) == Type::TOP || (in(0) != NULL && in(0)->is_top());\n+  return outcnt() == 0 || igvn.type(this) == Type::TOP || (in(0) != nullptr && in(0)->is_top());\n@@ -786,1 +786,1 @@\n-  if( (_cnt >= _max) || (in(_max-1) != NULL) )\n+  if( (_cnt >= _max) || (in(_max-1) != nullptr) )\n@@ -790,1 +790,1 @@\n-  if( in(_cnt) != NULL ) {       \/\/ Next precedence edge is busy?\n+  if( in(_cnt) != nullptr ) {   \/\/ Next precedence edge is busy?\n@@ -793,1 +793,1 @@\n-      if( in(i) == NULL )       \/\/ Find the NULL at end of prec edge list\n+      if( in(i) == nullptr )    \/\/ Find the null at end of prec edge list\n@@ -798,1 +798,1 @@\n-  if (n != NULL) n->add_out((Node *)this);\n+  if (n != nullptr) n->add_out((Node *)this);\n@@ -818,1 +818,1 @@\n-  if( _in[_cnt] != NULL ) {     \/\/ Next precedence edge is busy?\n+  if( _in[_cnt] != nullptr ) {  \/\/ Next precedence edge is busy?\n@@ -821,1 +821,1 @@\n-      if( _in[i] == NULL )      \/\/ Find the NULL at end of prec edge list\n+      if( _in[i] == nullptr )   \/\/ Find the null at end of prec edge list\n@@ -833,1 +833,1 @@\n-  if (n != NULL && !n->is_top()) {\n+  if (n != nullptr && !n->is_top()) {\n@@ -849,1 +849,1 @@\n-  if (n != NULL) n->del_out((Node *)this);\n+  if (n != nullptr) n->del_out((Node *)this);\n@@ -864,1 +864,1 @@\n-  if (n != NULL) n->del_out((Node *)this);\n+  if (n != nullptr) n->del_out((Node *)this);\n@@ -877,1 +877,1 @@\n-  add_req(NULL);                \/\/ Make space\n+  add_req(nullptr);                \/\/ Make space\n@@ -884,1 +884,1 @@\n-  if (n != NULL) n->add_out((Node *)this); \/\/ Add reciprocal def-use edge\n+  if (n != nullptr) n->add_out((Node *)this); \/\/ Add reciprocal def-use edge\n@@ -903,1 +903,1 @@\n-        if (gvn != NULL) {\n+        if (gvn != nullptr) {\n@@ -909,1 +909,1 @@\n-        assert(gvn == NULL || gvn->is_IterGVN() == NULL, \"no support for igvn here\");\n+        assert(gvn == nullptr || gvn->is_IterGVN() == nullptr, \"no support for igvn here\");\n@@ -935,1 +935,1 @@\n-\/\/ NULL out all inputs to eliminate incoming Def-Use edges.\n+\/\/ null out all inputs to eliminate incoming Def-Use edges.\n@@ -954,1 +954,1 @@\n-    rm_prec(--i);  \/\/ no-op if _in[i] is nullptr\n+    rm_prec(--i);  \/\/ no-op if _in[i] is null\n@@ -991,1 +991,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -996,1 +996,1 @@\n-  return (find_out_with(opcode) != NULL);\n+  return (find_out_with(opcode) != nullptr);\n@@ -1027,1 +1027,1 @@\n-    if (p == NULL || p->req() != 2) {\n+    if (p == nullptr || p->req() != 2) {\n@@ -1043,1 +1043,1 @@\n-\/\/ duplicates removed and NULLs packed down at the end.\n+\/\/ duplicates removed and nulls packed down at the end.\n@@ -1047,1 +1047,1 @@\n-  \/\/ Check for NULL at end\n+  \/\/ Check for null at end\n@@ -1053,1 +1053,1 @@\n-  while( in(i) != NULL ) {\n+  while( in(i) != nullptr ) {\n@@ -1057,2 +1057,2 @@\n-  _in[i] = n;                                \/\/ Stuff prec edge over NULL\n-  if ( n != NULL) n->add_out((Node *)this);  \/\/ Add mirror edge\n+  _in[i] = n;                                   \/\/ Stuff prec edge over null\n+  if ( n != nullptr) n->add_out((Node *)this);  \/\/ Add mirror edge\n@@ -1061,1 +1061,1 @@\n-  while ((++i)<_max) { assert(_in[i] == NULL, \"spec violation: Gap in prec edges (node %d)\", _idx); }\n+  while ((++i)<_max) { assert(_in[i] == nullptr, \"spec violation: Gap in prec edges (node %d)\", _idx); }\n@@ -1068,1 +1068,1 @@\n-\/\/ duplicates removed and NULLs packed down at the end.\n+\/\/ duplicates removed and nulls packed down at the end.\n@@ -1072,1 +1072,1 @@\n-  if (_in[j] == NULL) return;   \/\/ Avoid spec violation: Gap in prec edges.\n+  if (_in[j] == nullptr) return;   \/\/ Avoid spec violation: Gap in prec edges.\n@@ -1085,1 +1085,1 @@\n-JVMState* Node::jvms() const { return NULL; }\n+JVMState* Node::jvms() const { return nullptr; }\n@@ -1090,1 +1090,1 @@\n-  for (JVMState* jvms = this->jvms(); jvms != NULL; jvms = jvms->caller()) {\n+  for (JVMState* jvms = this->jvms(); jvms != nullptr; jvms = jvms->caller()) {\n@@ -1170,1 +1170,1 @@\n-\/\/ return the 'this' pointer instead of NULL.\n+\/\/ return the 'this' pointer instead of null.\n@@ -1174,1 +1174,1 @@\n-\/\/ another Node have the Ideal call make no change and return NULL.\n+\/\/ another Node have the Ideal call make no change and return null.\n@@ -1176,1 +1176,1 @@\n-\/\/ returns NULL instead of doing any graph reshaping.\n+\/\/ returns null instead of doing any graph reshaping.\n@@ -1211,1 +1211,1 @@\n-  return NULL;                  \/\/ Default to being Ideal already\n+  return nullptr;                  \/\/ Default to being Ideal already\n@@ -1247,1 +1247,1 @@\n-  if (ctrl == NULL && this->is_Region())\n+  if (ctrl == nullptr && this->is_Region())\n@@ -1250,1 +1250,1 @@\n-  if (ctrl != NULL && ctrl->is_CatchProj()) {\n+  if (ctrl != nullptr && ctrl->is_CatchProj()) {\n@@ -1253,1 +1253,1 @@\n-    if (ctrl != NULL && !ctrl->is_top())\n+    if (ctrl != nullptr && !ctrl->is_top())\n@@ -1257,1 +1257,1 @@\n-  if (ctrl != NULL && ctrl->is_Proj())\n+  if (ctrl != nullptr && ctrl->is_Proj())\n@@ -1271,1 +1271,1 @@\n-  assert(sub != NULL && sub->is_CFG(), \"expecting control\");\n+  assert(sub != nullptr && sub->is_CFG(), \"expecting control\");\n@@ -1288,1 +1288,1 @@\n-  while (sub != NULL) {\n+  while (sub != nullptr) {\n@@ -1355,1 +1355,1 @@\n-        if (in != NULL && !in->is_top() && in != sub) {\n+        if (in != nullptr && !in->is_top() && in != sub) {\n@@ -1436,1 +1436,1 @@\n-            } else if (in != NULL && !in->is_top()) {\n+            } else if (in != nullptr && !in->is_top()) {\n@@ -1460,1 +1460,1 @@\n-        if (n != NULL && !n->is_top()) { \/\/ Input is valid?\n+        if (n != nullptr && !n->is_top()) { \/\/ Input is valid?\n@@ -1509,1 +1509,1 @@\n-    sum = (sum<<1)-(uintptr_t)in(i);        \/\/ Ignore embedded NULLs\n+    sum = (sum<<1)-(uintptr_t)in(i);        \/\/ Ignore embedded nulls\n@@ -1546,1 +1546,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1556,1 +1556,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1581,1 +1581,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1591,1 +1591,1 @@\n-  if (tp == NULL) {\n+  if (tp == nullptr) {\n@@ -1593,1 +1593,1 @@\n-    assert((tp != NULL), \"unexpected node type\");\n+    assert((tp != nullptr), \"unexpected node type\");\n@@ -1776,2 +1776,2 @@\n-\/\/ the search also includes forward (out) edges. Returns NULL if not found.\n-\/\/ If only_ctrl is set, the search will only be done on control nodes. Returns NULL if\n+\/\/ the search also includes forward (out) edges. Returns null if not found.\n+\/\/ If only_ctrl is set, the search will only be done on control nodes. Returns null if\n@@ -2080,1 +2080,1 @@\n-  tty->print(\"    if nullptr: simple BFS\\n\");\n+  tty->print(\"    if null: simple BFS\\n\");\n@@ -2083,1 +2083,1 @@\n-  tty->print(\"    if nullptr: same as \\\"cdmox@B\\\"\\n\");\n+  tty->print(\"    if null: same as \\\"cdmox@B\\\"\\n\");\n@@ -2457,1 +2457,1 @@\n-    if (n->in(i) != NULL)  return false;\n+    if (n->in(i) != nullptr)  return false;\n@@ -2466,3 +2466,3 @@\n-  if (not_a_node(orig)) orig = NULL;\n-  if (orig != NULL && !C->node_arena()->contains(orig)) orig = NULL;\n-  if (orig == NULL) return;\n+  if (not_a_node(orig)) orig = nullptr;\n+  if (orig != nullptr && !C->node_arena()->contains(orig)) orig = nullptr;\n+  if (orig == nullptr) return;\n@@ -2473,2 +2473,2 @@\n-  if (not_a_node(fast)) fast = NULL;\n-  while (orig != NULL) {\n+  if (not_a_node(fast)) fast = nullptr;\n+  while (orig != nullptr) {\n@@ -2482,4 +2482,4 @@\n-    if (not_a_node(orig)) orig = NULL;\n-    if (orig != NULL && !C->node_arena()->contains(orig)) orig = NULL;\n-    if (orig != NULL) st->print(\",\");\n-    if (fast != NULL) {\n+    if (not_a_node(orig)) orig = nullptr;\n+    if (orig != nullptr && !C->node_arena()->contains(orig)) orig = nullptr;\n+    if (orig != nullptr) st->print(\",\");\n+    if (fast != nullptr) {\n@@ -2488,2 +2488,2 @@\n-      if (not_a_node(fast)) fast = NULL;\n-      if (fast != NULL && fast != orig) {\n+      if (not_a_node(fast)) fast = nullptr;\n+      if (fast != nullptr && fast != orig) {\n@@ -2491,1 +2491,1 @@\n-        if (not_a_node(fast)) fast = NULL;\n+        if (not_a_node(fast)) fast = nullptr;\n@@ -2504,1 +2504,1 @@\n-  if (not_a_node(orig))  orig = NULL;\n+  if (not_a_node(orig))  orig = nullptr;\n@@ -2506,1 +2506,1 @@\n-  while (orig != NULL) {\n+  while (orig != nullptr) {\n@@ -2513,1 +2513,1 @@\n-    if (not_a_node(orig))  orig = NULL;\n+    if (not_a_node(orig))  orig = nullptr;\n@@ -2562,1 +2562,1 @@\n-  if (t != NULL && (t->isa_instptr() || t->isa_instklassptr())) {\n+  if (t != nullptr && (t->isa_instptr() || t->isa_instklassptr())) {\n@@ -2588,2 +2588,2 @@\n-    if (nn != NULL && !nn->is_clear()) {\n-      if (nn->jvms() != NULL) {\n+    if (nn != nullptr && !nn->is_clear()) {\n+      if (nn->jvms() != nullptr) {\n@@ -2609,1 +2609,1 @@\n-    if (d == NULL) {\n+    if (d == nullptr) {\n@@ -2627,1 +2627,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -2643,1 +2643,1 @@\n-    if (u == NULL) {\n+    if (u == nullptr) {\n@@ -2701,1 +2701,1 @@\n-      if (C->cached_top_node() == NULL) {\n+      if (C->cached_top_node() == nullptr) {\n@@ -2797,1 +2797,1 @@\n-  _nodes[_max - 1] = NULL;\n+  _nodes[_max - 1] = nullptr;\n@@ -2804,1 +2804,1 @@\n-    if (nn != NULL) {\n+    if (nn != nullptr) {\n@@ -2819,1 +2819,1 @@\n-      if (n != NULL && n->is_Phi()) {\n+      if (n != nullptr && n->is_Phi()) {\n@@ -2833,1 +2833,1 @@\n-\/\/ be found; Otherwise return NULL;\n+\/\/ be found; Otherwise return null;\n@@ -2856,1 +2856,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2863,1 +2863,1 @@\n-  Node* found = NULL;\n+  Node* found = nullptr;\n@@ -2867,2 +2867,2 @@\n-      if (found != NULL) {\n-        return NULL;\n+      if (found != nullptr) {\n+        return nullptr;\n@@ -2880,1 +2880,1 @@\n-  assert(ctrl != NULL, \"control out is assumed to be unique\");\n+  assert(ctrl != nullptr, \"control out is assumed to be unique\");\n@@ -2885,1 +2885,1 @@\n-  if (in(0) == NULL) {\n+  if (in(0) == nullptr) {\n@@ -2896,1 +2896,1 @@\n-  if (is_Proj() && in(0) == NULL)  {\n+  if (is_Proj() && in(0) == nullptr)  {\n@@ -2949,1 +2949,1 @@\n-      tty->print(\" NULL\");\n+      tty->print(\" null\");\n@@ -2975,1 +2975,1 @@\n-    assert( n != NULL, \"Did not expect null entries in worklist\");\n+    assert( n != nullptr, \"Did not expect null entries in worklist\");\n@@ -3003,1 +3003,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":141,"deletions":141,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-  \/\/ E.g.  new (C,3) FooNode( C, NULL, left, right );\n+  \/\/ E.g.  new (C,3) FooNode( C, nullptr, left, right );\n@@ -277,1 +277,1 @@\n-  Node* clone_with_data_edge(Node* in1, Node* in2 = NULL) const {\n+  Node* clone_with_data_edge(Node* in1, Node* in2 = nullptr) const {\n@@ -279,2 +279,2 @@\n-    if (in1 != NULL)  nn->set_req(1, in1);\n-    if (in2 != NULL)  nn->set_req(2, in2);\n+    if (in1 != nullptr)  nn->set_req(1, in1);\n+    if (in2 != nullptr)  nn->set_req(2, in2);\n@@ -299,1 +299,1 @@\n-  \/\/ for semantic correctness; order is important and NULLs are allowed.\n+  \/\/ for semantic correctness; order is important and nulls are allowed.\n@@ -302,1 +302,1 @@\n-  \/\/ duplicated; they have no embedded NULLs.  Edges from 0 to _cnt-1\n+  \/\/ duplicated; they have no embedded nulls.  Edges from 0 to _cnt-1\n@@ -397,2 +397,2 @@\n-  \/\/ Reference to the i'th input Node.  NULL if out of bounds.\n-  Node* lookup(uint i) const { return ((i < _max) ? _in[i] : NULL); }\n+  \/\/ Reference to the i'th input Node.  null if out of bounds.\n+  Node* lookup(uint i) const { return ((i < _max) ? _in[i] : nullptr); }\n@@ -441,1 +441,1 @@\n-    if (*p != NULL)  (*p)->del_out((Node *)this);\n+    if (*p != nullptr)  (*p)->del_out((Node *)this);\n@@ -443,1 +443,1 @@\n-    if (n != NULL)      n->add_out((Node *)this);\n+    if (n != nullptr)      n->add_out((Node *)this);\n@@ -453,1 +453,1 @@\n-    assert( _in[i] == NULL, \"sanity\");\n+    assert( _in[i] == nullptr, \"sanity\");\n@@ -455,1 +455,1 @@\n-    if (n != NULL)      n->add_out((Node *)this);\n+    if (n != nullptr)      n->add_out((Node *)this);\n@@ -463,2 +463,2 @@\n-      if (_in[i] == NULL) {\n-        DEBUG_ONLY( while ((++i) < len()) assert(_in[i] == NULL, \"Gap in prec edges!\"); )\n+      if (_in[i] == nullptr) {\n+        DEBUG_ONLY( while ((++i) < len()) assert(_in[i] == nullptr, \"Gap in prec edges!\"); )\n@@ -470,1 +470,1 @@\n-  int replace_edge(Node* old, Node* neww, PhaseGVN* gvn = NULL);\n+  int replace_edge(Node* old, Node* neww, PhaseGVN* gvn = nullptr);\n@@ -472,1 +472,1 @@\n-  \/\/ NULL out all inputs to eliminate incoming Def-Use edges.\n+  \/\/ null out all inputs to eliminate incoming Def-Use edges.\n@@ -477,2 +477,2 @@\n-    assert((this == (Node*) Compile::current()->top()) == (_out == NULL), \"\");\n-    return (_out == NULL);\n+    assert((this == (Node*) Compile::current()->top()) == (_out == nullptr), \"\");\n+    return (_out == nullptr);\n@@ -526,1 +526,1 @@\n-    Node *last = NULL;\n+    Node *last = nullptr;\n@@ -529,1 +529,1 @@\n-      if (next == NULL) break;\n+      if (next == nullptr) break;\n@@ -532,2 +532,2 @@\n-    _in[gap] = last; \/\/ Move last slot to empty one.\n-    _in[i] = NULL;   \/\/ NULL out last slot.\n+    _in[gap] = last;  \/\/ Move last slot to empty one.\n+    _in[i] = nullptr; \/\/ null out last slot.\n@@ -560,1 +560,1 @@\n-    if (n == NULL || find_prec_edge(n) != -1) {\n+    if (n == nullptr || find_prec_edge(n) != -1) {\n@@ -564,1 +564,1 @@\n-    if (_in[i] != NULL) _in[i]->del_out((Node *)this);\n+    if (_in[i] != nullptr) _in[i]->del_out((Node *)this);\n@@ -589,1 +589,1 @@\n-  \/\/ NOTE: Required edges can contain embedded NULL pointers.\n+  \/\/ NOTE: Required edges can contain embedded null pointers.\n@@ -849,1 +849,1 @@\n-    assert(is_##type(), \"invalid node class: %s\", Name()); \\\n+    assert(is_##type(), \"invalid node class: %s\", Name());   \\\n@@ -853,1 +853,1 @@\n-    return (is_##type()) ? as_##type() : NULL;               \\\n+    return (is_##type()) ? as_##type() : nullptr;            \\\n@@ -1017,1 +1017,1 @@\n-  bool is_expensive() const { return (_flags & Flag_is_expensive) != 0 && in(0) != NULL; }\n+  bool is_expensive() const { return (_flags & Flag_is_expensive) != 0 && in(0) != nullptr; }\n@@ -1043,1 +1043,1 @@\n-  \/\/ or NULL if none.  The address type is conservatively wide.\n+  \/\/ or null if none.  The address type is conservatively wide.\n@@ -1046,1 +1046,1 @@\n-  virtual const class TypePtr *adr_type() const { return NULL; }\n+  virtual const class TypePtr *adr_type() const { return nullptr; }\n@@ -1104,1 +1104,1 @@\n-  \/\/ be found; Otherwise return NULL;\n+  \/\/ be found; Otherwise return null;\n@@ -1134,1 +1134,1 @@\n-  \/\/ Return JVM State Object if this Node carries debug info, or NULL otherwise\n+  \/\/ Return JVM State Object if this Node carries debug info, or null otherwise\n@@ -1150,1 +1150,1 @@\n-    return (t != NULL && t->is_con()) ? t->get_con() : value_if_unknown;\n+    return (t != nullptr && t->is_con()) ? t->get_con() : value_if_unknown;\n@@ -1155,1 +1155,1 @@\n-    guarantee(t != NULL, \"must be con\");\n+    guarantee(t != nullptr, \"must be con\");\n@@ -1165,1 +1165,1 @@\n-    guarantee(t != NULL, \"must be con\");\n+    guarantee(t != nullptr, \"must be con\");\n@@ -1170,1 +1170,1 @@\n-    return (t != NULL && t->is_con()) ? t->get_con() : value_if_unknown;\n+    return (t != nullptr && t->is_con()) ? t->get_con() : value_if_unknown;\n@@ -1176,1 +1176,1 @@\n-    guarantee(t != NULL && t->is_con(), \"must be con\");\n+    guarantee(t != nullptr && t->is_con(), \"must be con\");\n@@ -1181,1 +1181,1 @@\n-    if (t == NULL || !t->is_con())  return value_if_unknown;\n+    if (t == nullptr || !t->is_con())  return value_if_unknown;\n@@ -1275,1 +1275,1 @@\n-  if (n == NULL)                   return true;\n+  if (n == nullptr)                return true;\n@@ -1535,1 +1535,1 @@\n-\/\/ Abstractly provides an infinite array of Node*'s, initialized to NULL.\n+\/\/ Abstractly provides an infinite array of Node*'s, initialized to null.\n@@ -1552,2 +1552,2 @@\n-  Node *operator[] ( uint i ) const \/\/ Lookup, or NULL for not mapped\n-  { return (i<_max) ? _nodes[i] : (Node*)NULL; }\n+  Node *operator[] ( uint i ) const \/\/ Lookup, or null for not mapped\n+  { return (i<_max) ? _nodes[i] : (Node*)nullptr; }\n@@ -1560,1 +1560,1 @@\n-  \/\/ Clear all entries in _nodes to NULL but keep storage\n+  \/\/ Clear all entries in _nodes to null but keep storage\n@@ -1663,1 +1663,1 @@\n-      return; \/\/ Gracefully handle NULL, -1, 0xabababab, etc.\n+      return; \/\/ Gracefully handle null, -1, 0xabababab, etc.\n@@ -1773,1 +1773,1 @@\n-  Node_Notes(JVMState* jvms = NULL) {\n+  Node_Notes(JVMState* jvms = nullptr) {\n@@ -1782,1 +1782,1 @@\n-    return (_jvms == NULL);\n+    return (_jvms == nullptr);\n@@ -1787,1 +1787,1 @@\n-    _jvms = NULL;\n+    _jvms = nullptr;\n@@ -1806,2 +1806,2 @@\n-    if (source != NULL) {\n-      if (source->jvms() != NULL) {\n+    if (source != nullptr) {\n+      if (source->jvms() != nullptr) {\n@@ -1822,1 +1822,1 @@\n-  int grow_by = (block_idx - (arr == NULL? 0: arr->length()));\n+  int grow_by = (block_idx - (arr == nullptr? 0: arr->length()));\n@@ -1824,1 +1824,1 @@\n-    if (!can_grow) return NULL;\n+    if (!can_grow) return nullptr;\n@@ -1827,1 +1827,1 @@\n-  if (arr == NULL) return NULL;\n+  if (arr == nullptr) return nullptr;\n@@ -1834,1 +1834,1 @@\n-  if (value == NULL || value->is_clear())\n+  if (value == nullptr || value->is_clear())\n@@ -1837,1 +1837,1 @@\n-  assert(loc != NULL, \"\");\n+  assert(loc != nullptr, \"\");\n@@ -1852,1 +1852,1 @@\n-    assert(t != NULL, \"sanity\");\n+    assert(t != nullptr, \"sanity\");\n@@ -1858,1 +1858,1 @@\n-  const Type* type() const { assert(_type != NULL, \"sanity\"); return _type; };\n+  const Type* type() const { assert(_type != nullptr, \"sanity\"); return _type; };\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":56,"deletions":56,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -229,3 +229,3 @@\n-    _oop_map_set(NULL),\n-    _scratch_buffer_blob(NULL),\n-    _scratch_locs_memory(NULL),\n+    _oop_map_set(nullptr),\n+    _scratch_buffer_blob(nullptr),\n+    _scratch_locs_memory(nullptr),\n@@ -237,1 +237,1 @@\n-    _node_bundling_base(NULL),\n+    _node_bundling_base(nullptr),\n@@ -241,1 +241,1 @@\n-    _block(NULL),\n+    _block(nullptr),\n@@ -244,1 +244,1 @@\n-  if (C->stub_name() == NULL) {\n+  if (C->stub_name() == nullptr) {\n@@ -258,2 +258,2 @@\n-  C->set_output(NULL);\n-  if (_scratch_buffer_blob != NULL) {\n+  C->set_output(nullptr);\n+  if (_scratch_buffer_blob != nullptr) {\n@@ -395,1 +395,1 @@\n-  if (cb == NULL || C->failing()) {\n+  if (cb == nullptr || C->failing()) {\n@@ -416,1 +416,1 @@\n-  return (C->stub_function() == NULL &&\n+  return (C->stub_function() == nullptr &&\n@@ -426,1 +426,1 @@\n-  return (C->stub_function() == NULL && C->has_java_calls());\n+  return (C->stub_function() == nullptr && C->has_java_calls());\n@@ -546,1 +546,1 @@\n-          if (mcall->entry_point() != NULL) {\n+          if (mcall->entry_point() != nullptr) {\n@@ -634,2 +634,2 @@\n-      MachNode* mach = (idx == -1) ? NULL: block->get_node(idx)->as_Mach();\n-      if (mach != NULL && mach->may_be_short_branch()) {\n+      MachNode* mach = (idx == -1) ? nullptr: block->get_node(idx)->as_Mach();\n+      if (mach != nullptr && mach->may_be_short_branch()) {\n@@ -699,1 +699,1 @@\n-      if (mach != NULL && (mach->may_be_short_branch() ||\n+      if (mach != nullptr && (mach->may_be_short_branch() ||\n@@ -765,1 +765,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -770,1 +770,1 @@\n-  assert(sv_for_node_id(objs, sv->id()) == NULL, \"Precondition\");\n+  assert(sv_for_node_id(objs, sv->id()) == nullptr, \"Precondition\");\n@@ -799,1 +799,1 @@\n-    if (sv == NULL) {\n+    if (sv == nullptr) {\n@@ -806,1 +806,1 @@\n-      ScopeValue* is_init = NULL;\n+      ScopeValue* is_init = nullptr;\n@@ -809,1 +809,1 @@\n-        assert(init_node != NULL, \"is_init node not found\");\n+        assert(init_node != nullptr, \"is_init node not found\");\n@@ -910,1 +910,1 @@\n-      array->append(new ConstantOopWriteValue(NULL));\n+      array->append(new ConstantOopWriteValue(nullptr));\n@@ -918,1 +918,1 @@\n-        array->append(new ConstantOopWriteValue(NULL));\n+        array->append(new ConstantOopWriteValue(nullptr));\n@@ -1011,1 +1011,1 @@\n-    mcall = NULL;\n+    mcall = nullptr;\n@@ -1037,1 +1037,1 @@\n-  \/\/ Do not skip safepoints with a NULL method, they need monitor info\n+  \/\/ Do not skip safepoints with a null method, they need monitor info\n@@ -1050,1 +1050,1 @@\n-    ciMethod* method = jvms->has_method() ? jvms->method() : NULL;\n+    ciMethod* method = jvms->has_method() ? jvms->method() : nullptr;\n@@ -1053,2 +1053,2 @@\n-    int num_locs = (method == NULL) ? 0 : jvms->loc_size();\n-    int num_exps = (method == NULL) ? 0 : jvms->stk_size();\n+    int num_locs = (method == nullptr) ? 0 : jvms->loc_size();\n+    int num_exps = (method == nullptr) ? 0 : jvms->stk_size();\n@@ -1056,1 +1056,1 @@\n-    assert(method == NULL || jvms->bci() < 0 || num_locs == method->max_locals(),\n+    assert(method == nullptr || jvms->bci() < 0 || num_locs == method->max_locals(),\n@@ -1091,1 +1091,1 @@\n-      ScopeValue *scval = NULL;\n+      ScopeValue *scval = nullptr;\n@@ -1096,1 +1096,1 @@\n-        if (scval == NULL) {\n+        if (scval == nullptr) {\n@@ -1181,1 +1181,1 @@\n-      _pending_jvms = NULL;\n+      _pending_jvms = nullptr;\n@@ -1189,2 +1189,2 @@\n-      if (nn == NULL || nn->jvms() == NULL)  return;\n-      if (_pending_jvms != NULL &&\n+      if (nn == nullptr || nn->jvms() == nullptr)  return;\n+      if (_pending_jvms != nullptr &&\n@@ -1195,1 +1195,1 @@\n-        if (_pending_jvms != NULL &&\n+        if (_pending_jvms != nullptr &&\n@@ -1199,1 +1199,1 @@\n-        _pending_jvms = NULL;\n+        _pending_jvms = nullptr;\n@@ -1201,1 +1201,1 @@\n-          \/\/ This is the only way _pending_jvms can become non-NULL:\n+          \/\/ This is the only way _pending_jvms can become non-null:\n@@ -1210,1 +1210,1 @@\n-      if (_pending_jvms != NULL &&\n+      if (_pending_jvms != nullptr &&\n@@ -1215,1 +1215,1 @@\n-      _pending_jvms = NULL;\n+      _pending_jvms = nullptr;\n@@ -1219,1 +1219,1 @@\n-      if (_pending_jvms != NULL) {\n+      if (_pending_jvms != nullptr) {\n@@ -1222,1 +1222,1 @@\n-      _pending_jvms = NULL;\n+      _pending_jvms = nullptr;\n@@ -1231,1 +1231,1 @@\n-  _pending_jvms = NULL;\n+  _pending_jvms = nullptr;\n@@ -1242,1 +1242,1 @@\n-    ciMethod* method = jvms->has_method() ? jvms->method() : NULL;\n+    ciMethod* method = jvms->has_method() ? jvms->method() : nullptr;\n@@ -1340,1 +1340,1 @@\n-  if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {\n+  if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1342,1 +1342,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1397,1 +1397,1 @@\n-  int* node_offsets      = NULL;\n+  int* node_offsets      = nullptr;\n@@ -1403,1 +1403,1 @@\n-  if (node_offsets != NULL) {\n+  if (node_offsets != nullptr) {\n@@ -1426,1 +1426,1 @@\n-  Node* delay_slot = NULL;\n+  Node* delay_slot = nullptr;\n@@ -1467,1 +1467,1 @@\n-        assert(delay_slot == NULL, \"no use of delay slot node\");\n+        assert(delay_slot == nullptr, \"no use of delay slot node\");\n@@ -1517,1 +1517,1 @@\n-          if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {\n+          if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1531,1 +1531,1 @@\n-          if (mcall->entry_point() != NULL) {\n+          if (mcall->entry_point() != nullptr) {\n@@ -1548,1 +1548,1 @@\n-            if (sfn->jvms()->method() == NULL) {\n+            if (sfn->jvms()->method() == nullptr) {\n@@ -1575,1 +1575,1 @@\n-            assert(delay_slot == NULL, \"not expecting delay slot node\");\n+            assert(delay_slot == nullptr, \"not expecting delay slot node\");\n@@ -1640,1 +1640,1 @@\n-            if (oop_store == NULL) continue;\n+            if (oop_store == nullptr) continue;\n@@ -1671,1 +1671,1 @@\n-      if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {\n+      if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1678,1 +1678,1 @@\n-      if ((node_offsets != NULL) && (n->_idx < node_offset_limit)) {\n+      if ((node_offsets != nullptr) && (n->_idx < node_offset_limit)) {\n@@ -1733,1 +1733,1 @@\n-        guarantee(delay_slot != NULL, \"expecting delay slot node\");\n+        guarantee(delay_slot != nullptr, \"expecting delay slot node\");\n@@ -1740,1 +1740,1 @@\n-        if ((node_offsets != NULL) && (delay_slot->_idx < node_offset_limit)) {\n+        if ((node_offsets != nullptr) && (delay_slot->_idx < node_offset_limit)) {\n@@ -1749,1 +1749,1 @@\n-          if (!mach->is_MachCall() && mach->as_MachSafePoint()->jvms()->method() == NULL) {\n+          if (!mach->is_MachCall() && mach->as_MachSafePoint()->jvms()->method() == nullptr) {\n@@ -1751,1 +1751,1 @@\n-            delay_slot = NULL;\n+            delay_slot = nullptr;\n@@ -1766,1 +1766,1 @@\n-        delay_slot = NULL;\n+        delay_slot = nullptr;\n@@ -1854,1 +1854,1 @@\n-  if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {\n+  if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1876,1 +1876,1 @@\n-      if (C->method() != NULL) {\n+      if (C->method() != nullptr) {\n@@ -1887,1 +1887,1 @@\n-      if (xtty != NULL) {\n+      if (xtty != nullptr) {\n@@ -1891,1 +1891,1 @@\n-      if (C->method() != NULL) {\n+      if (C->method() != nullptr) {\n@@ -1894,1 +1894,1 @@\n-      } else if (C->stub_name() != NULL) {\n+      } else if (C->stub_name() != nullptr) {\n@@ -1901,1 +1901,1 @@\n-      if (xtty != NULL) {\n+      if (xtty != nullptr) {\n@@ -1915,1 +1915,1 @@\n-    Node *n = NULL;\n+    Node *n = nullptr;\n@@ -1976,1 +1976,1 @@\n-      _handler_table.add_subtable(call_return, &handler_bcis, NULL, &handler_pcos);\n+      _handler_table.add_subtable(call_return, &handler_bcis, nullptr, &handler_pcos);\n@@ -2014,1 +2014,1 @@\n-          _next_node(NULL),\n+          _next_node(nullptr),\n@@ -2226,1 +2226,1 @@\n-      tty->print(\"#   ChooseNodeToBundle: NULL\\n\");\n+      tty->print(\"#   ChooseNodeToBundle: null\\n\");\n@@ -2228,1 +2228,1 @@\n-    return (NULL);\n+    return (nullptr);\n@@ -2577,1 +2577,1 @@\n-  _unconditional_delay_slot = NULL;\n+  _unconditional_delay_slot = nullptr;\n@@ -2639,1 +2639,1 @@\n-  Block *succ_bb = NULL;\n+  Block *succ_bb = nullptr;\n@@ -2738,1 +2738,1 @@\n-      guarantee(n != NULL, \"no nodes available\");\n+      guarantee(n != nullptr, \"no nodes available\");\n@@ -2813,1 +2813,1 @@\n-    _reg_node.map(def,NULL); \/\/ Kill live USEs\n+    _reg_node.map(def,nullptr); \/\/ Kill live USEs\n@@ -2890,1 +2890,1 @@\n-  if ((pinch == NULL) || _cfg->get_block_for_node(pinch) != b || \/\/ No pinch-point yet?\n+  if ((pinch == nullptr) || _cfg->get_block_for_node(pinch) != b || \/\/ No pinch-point yet?\n@@ -2900,1 +2900,1 @@\n-  Node *later_def = NULL;\n+  Node *later_def = nullptr;\n@@ -2922,1 +2922,1 @@\n-      pinch->init_req(0, C->top());     \/\/ set not NULL for the next call\n+      pinch->init_req(0, C->top());     \/\/ set not null for the next call\n@@ -2924,1 +2924,1 @@\n-      later_def = NULL;           \/\/ and no later def\n+      later_def = nullptr;           \/\/ and no later def\n@@ -2943,1 +2943,1 @@\n-        pinch->set_req(0,NULL);  \/\/\n+        pinch->set_req(0,nullptr);  \/\/\n@@ -2961,1 +2961,1 @@\n-  if ((pinch != NULL) && _cfg->get_block_for_node(pinch) == b &&\n+  if ((pinch != nullptr) && _cfg->get_block_for_node(pinch) == b &&\n@@ -3013,1 +3013,1 @@\n-  \/\/ compilation.  _reg_node is lazily initialized; it either contains a NULL,\n+  \/\/ compilation.  _reg_node is lazily initialized; it either contains a null,\n@@ -3015,1 +3015,1 @@\n-  \/\/ block.  Leftover node from some prior block is treated like a NULL (no\n+  \/\/ block.  Leftover node from some prior block is treated like a null (no\n@@ -3020,1 +3020,1 @@\n-  Node* end_node         = (_bb_end-1 >= _bb_start) ? b->get_node(last_safept) : NULL;\n+  Node* end_node         = (_bb_end-1 >= _bb_start) ? b->get_node(last_safept) : nullptr;\n@@ -3092,1 +3092,1 @@\n-        if (def != NULL && def->bottom_type()->base() == Type::RawPtr) {\n+        if (def != nullptr && def->bottom_type()->base() == Type::RawPtr) {\n@@ -3151,1 +3151,1 @@\n-    if ((pinch != NULL) && pinch->Opcode() == Op_Node &&\n+    if ((pinch != nullptr) && pinch->Opcode() == Op_Node &&\n@@ -3153,1 +3153,1 @@\n-        (pinch->req() == pinch->len() || pinch->in(pinch->req()) == NULL) ) {\n+        (pinch->req() == pinch->len() || pinch->in(pinch->req()) == nullptr) ) {\n@@ -3156,1 +3156,1 @@\n-      _reg_node.map(k, NULL);\n+      _reg_node.map(k, nullptr);\n@@ -3191,1 +3191,1 @@\n-  pinch->set_req(0, NULL);\n+  pinch->set_req(0, nullptr);\n@@ -3244,1 +3244,1 @@\n-  if ((blob != NULL) && (const_size <= _scratch_const_size)) {\n+  if ((blob != nullptr) && (const_size <= _scratch_const_size)) {\n@@ -3247,1 +3247,1 @@\n-    if (blob != NULL) {\n+    if (blob != nullptr) {\n@@ -3277,1 +3277,1 @@\n-    if (scratch_buffer_blob() == NULL) {\n+    if (scratch_buffer_blob() == nullptr) {\n@@ -3307,1 +3307,1 @@\n-  assert(blob != NULL, \"Initialize BufferBlob at start\");\n+  assert(blob != nullptr, \"Initialize BufferBlob at start\");\n@@ -3316,1 +3316,1 @@\n-  assert(locs_buf != NULL, \"sanity\");\n+  assert(locs_buf != nullptr, \"sanity\");\n@@ -3329,1 +3329,1 @@\n-  Label*   saveL = NULL;\n+  Label*   saveL = nullptr;\n@@ -3357,1 +3357,1 @@\n-  } else if (C->stub_function() != NULL) {\n+  } else if (C->stub_function() != nullptr) {\n@@ -3418,1 +3418,1 @@\n-    if (C->log() != NULL) { \/\/ Print code cache state into compiler log\n+    if (C->log() != nullptr) { \/\/ Print code cache state into compiler log\n@@ -3425,1 +3425,1 @@\n-  if (code_buffer() == NULL) {\n+  if (code_buffer() == nullptr) {\n@@ -3443,1 +3443,1 @@\n-      assert(rs != NULL && rs->is_runtime_stub(), \"sanity check\");\n+      assert(rs != nullptr && rs->is_runtime_stub(), \"sanity check\");\n@@ -3486,1 +3486,1 @@\n-  if (pcs != NULL) {\n+  if (pcs != nullptr) {\n@@ -3505,1 +3505,1 @@\n-  Node *n = NULL;\n+  Node *n = nullptr;\n@@ -3516,1 +3516,1 @@\n-    if ((pcs != NULL) && (n->_idx < pc_limit)) {\n+    if ((pcs != nullptr) && (n->_idx < pc_limit)) {\n@@ -3531,1 +3531,1 @@\n-    Node *delay = NULL;\n+    Node *delay = nullptr;\n@@ -3563,1 +3563,1 @@\n-        if ((pcs != NULL) && (n->_idx < pc_limit)) {\n+        if ((pcs != nullptr) && (n->_idx < pc_limit)) {\n@@ -3580,1 +3580,1 @@\n-        guarantee(delay != NULL, \"no unconditional delay instruction\");\n+        guarantee(delay != nullptr, \"no unconditional delay instruction\");\n@@ -3585,1 +3585,1 @@\n-        if ((pcs != NULL) && (n->_idx < pc_limit)) {\n+        if ((pcs != nullptr) && (n->_idx < pc_limit)) {\n@@ -3596,1 +3596,1 @@\n-        delay = NULL;\n+        delay = nullptr;\n@@ -3607,1 +3607,1 @@\n-    assert(cut_short || delay == NULL, \"no unconditional delay branch\");\n+    assert(cut_short || delay == nullptr, \"no unconditional delay branch\");\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":108,"deletions":108,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-    bool is_merged() const                 { return _start_map != NULL; }\n+    bool is_merged() const                 { return _start_map != nullptr; }\n@@ -198,1 +198,1 @@\n-      if (pred != NULL && is_SEL_backedge(pred)) {\n+      if (pred != nullptr && is_SEL_backedge(pred)) {\n@@ -288,1 +288,1 @@\n-    \/\/ Initialize me by recording the parser's map.  My own map must be NULL.\n+    \/\/ Initialize me by recording the parser's map.  My own map must be null.\n@@ -408,1 +408,1 @@\n-    assert((_alloc_with_final == NULL) || (_alloc_with_final == n), \"different init objects?\");\n+    assert((_alloc_with_final == nullptr) || (_alloc_with_final == n), \"different init objects?\");\n@@ -435,1 +435,1 @@\n-  \/\/ Can return NULL if the flow pass did not complete a block.\n+  \/\/ Can return null if the flow pass did not complete a block.\n@@ -642,1 +642,1 @@\n-    assert(_unc != NULL && Deoptimization::trap_request_reason(_unc->uncommon_trap_request()) == Deoptimization::Reason_unstable_if,\n+    assert(_unc != nullptr && Deoptimization::trap_request_reason(_unc->uncommon_trap_request()) == Deoptimization::Reason_unstable_if,\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-    tty->print_cr(\"%d original NULL checks - %d elided (%2d%%); optimizer leaves %d,\",\n+    tty->print_cr(\"%d original null checks - %d elided (%2d%%); optimizer leaves %d,\",\n@@ -113,1 +113,1 @@\n-    \/\/ Ptr types are mixed together with T_ADDRESS but NULL is\n+    \/\/ Ptr types are mixed together with T_ADDRESS but nullptr is\n@@ -123,1 +123,1 @@\n-  Node *l = NULL;\n+  Node *l = nullptr;\n@@ -163,1 +163,1 @@\n-      (tp != NULL && !tp->is_loaded())) {\n+      (tp != nullptr && !tp->is_loaded())) {\n@@ -179,1 +179,1 @@\n-  if (tp != NULL && !tp->is_same_java_type_as(TypeInstPtr::BOTTOM)) {\n+  if (tp != nullptr && !tp->is_same_java_type_as(TypeInstPtr::BOTTOM)) {\n@@ -181,1 +181,1 @@\n-    Node* bad_type_ctrl = NULL;\n+    Node* bad_type_ctrl = nullptr;\n@@ -284,1 +284,1 @@\n-    if (type->isa_oopptr() != NULL) {\n+    if (type->isa_oopptr() != nullptr) {\n@@ -293,1 +293,1 @@\n-        if (C->log() != NULL) {\n+        if (C->log() != nullptr) {\n@@ -344,1 +344,1 @@\n-    if (type->isa_oopptr() != NULL) {\n+    if (type->isa_oopptr() != nullptr) {\n@@ -406,1 +406,1 @@\n-  _alloc_with_final = NULL;\n+  _alloc_with_final = nullptr;\n@@ -408,2 +408,2 @@\n-  _tf = NULL;\n-  _block = NULL;\n+  _tf = nullptr;\n+  _block = nullptr;\n@@ -459,1 +459,1 @@\n-  if (log != NULL) {\n+  if (log != nullptr) {\n@@ -485,1 +485,1 @@\n-      if (log != NULL)\n+      if (log != nullptr)\n@@ -494,1 +494,1 @@\n-  if (log != NULL && method()->has_exception_handlers()) {\n+  if (log != nullptr && method()->has_exception_handlers()) {\n@@ -498,1 +498,1 @@\n-  assert(InlineTree::check_can_parse(method()) == NULL, \"Can not parse this method, cutout earlier\");\n+  assert(InlineTree::check_can_parse(method()) == nullptr, \"Can not parse this method, cutout earlier\");\n@@ -564,1 +564,1 @@\n-  if (failing() || entry_map == NULL) {\n+  if (failing() || entry_map == nullptr) {\n@@ -612,1 +612,1 @@\n-               t->isa_aryptr() != NULL && !t->is_aryptr()->is_null_free() && !t->is_aryptr()->is_not_null_free()) {\n+               t->isa_aryptr() != nullptr && !t->is_aryptr()->is_null_free() && !t->is_aryptr()->is_not_null_free()) {\n@@ -615,1 +615,1 @@\n-      spec_type = (spec_type != NULL && spec_type->isa_aryptr() != NULL) ? spec_type : t->is_aryptr();\n+      spec_type = (spec_type != nullptr && spec_type->isa_aryptr() != nullptr) ? spec_type : t->is_aryptr();\n@@ -840,1 +840,1 @@\n-\/\/ unknown caller.  The method & bci will be NULL & InvocationEntryBci.\n+\/\/ unknown caller.  The method & bci will be null & InvocationEntryBci.\n@@ -850,1 +850,1 @@\n-  if (old_nn != NULL && has_method()) {\n+  if (old_nn != nullptr && has_method()) {\n@@ -863,1 +863,1 @@\n-    Node* parm = NULL;\n+    Node* parm = nullptr;\n@@ -895,1 +895,1 @@\n-  if (caller_nn == NULL)  return NULL;\n+  if (caller_nn == nullptr)  return nullptr;\n@@ -925,1 +925,1 @@\n-      ret->add_req_batch(NULL, tf()->range_cc()->cnt() - TypeFunc::Parms);\n+      ret->add_req_batch(nullptr, tf()->range_cc()->cnt() - TypeFunc::Parms);\n@@ -981,1 +981,1 @@\n-    while (pop_exception_state() != NULL) ;\n+    while (pop_exception_state() != nullptr) ;\n@@ -988,1 +988,1 @@\n-  while ((ex_map = pop_exception_state()) != NULL) {\n+  while ((ex_map = pop_exception_state()) != nullptr) {\n@@ -1141,1 +1141,1 @@\n-    while ((ex_map = kit.pop_exception_state()) != NULL) {\n+    while ((ex_map = kit.pop_exception_state()) != nullptr) {\n@@ -1176,1 +1176,1 @@\n-    while ((ex_map = caller.pop_exception_state()) != NULL) {\n+    while ((ex_map = caller.pop_exception_state()) != nullptr) {\n@@ -1192,1 +1192,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1206,1 +1206,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1210,1 +1210,1 @@\n-  assert(method() != NULL, \"parser must have a method\");\n+  assert(method() != nullptr, \"parser must have a method\");\n@@ -1213,1 +1213,1 @@\n-  JVMState* jvms = new (C) JVMState(method(), _caller->has_method() ? _caller : NULL);\n+  JVMState* jvms = new (C) JVMState(method(), _caller->has_method() ? _caller : nullptr);\n@@ -1220,1 +1220,1 @@\n-  assert(inmap != NULL, \"must have inmap\");\n+  assert(inmap != nullptr, \"must have inmap\");\n@@ -1276,1 +1276,1 @@\n-    if (receiver_type != NULL && !receiver_type->higher_equal(holder_type)) {\n+    if (receiver_type != nullptr && !receiver_type->higher_equal(holder_type)) {\n@@ -1306,1 +1306,1 @@\n-    Node *lock_obj = NULL;\n+    Node *lock_obj = nullptr;\n@@ -1355,1 +1355,1 @@\n-  _start_map = NULL;\n+  _start_map = nullptr;\n@@ -1359,1 +1359,1 @@\n-  _successors = NULL;\n+  _successors = nullptr;\n@@ -1378,1 +1378,1 @@\n-  _successors = (ns+ne == 0) ? NULL : NEW_RESOURCE_ARRAY(Block*, ns+ne);\n+  _successors = (ns+ne == 0) ? nullptr : NEW_RESOURCE_ARRAY(Block*, ns+ne);\n@@ -1421,1 +1421,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1606,1 +1606,1 @@\n-    if (log != NULL) {\n+    if (log != nullptr) {\n@@ -1641,1 +1641,1 @@\n-    if (log != NULL)\n+    if (log != nullptr)\n@@ -1656,1 +1656,1 @@\n-  if (nn == NULL)  return;\n+  if (nn == nullptr)  return;\n@@ -1665,1 +1665,1 @@\n-  if (jvms != NULL && jvms->bci() != bci) {\n+  if (jvms != nullptr && jvms->bci() != bci) {\n@@ -1677,1 +1677,1 @@\n-  if (target == NULL) { handle_missing_successor(target_bci); return; }\n+  if (target == nullptr) { handle_missing_successor(target_bci); return; }\n@@ -1687,1 +1687,1 @@\n-  if (target == NULL) { handle_missing_successor(target_bci); return; }\n+  if (target == nullptr) { handle_missing_successor(target_bci); return; }\n@@ -1704,1 +1704,1 @@\n-  if (target == NULL) { handle_missing_successor(target_bci); return; }\n+  if (target == nullptr) { handle_missing_successor(target_bci); return; }\n@@ -1745,1 +1745,1 @@\n-      const Type* t = NULL;\n+      const Type* t = nullptr;\n@@ -1751,1 +1751,1 @@\n-      if (t != NULL && t != Type::BOTTOM) {\n+      if (t != nullptr && t != Type::BOTTOM) {\n@@ -1801,2 +1801,2 @@\n-      \/\/ zap all inputs to NULL for debugging (done in Node(uint) constructor)\n-      \/\/ for (int j = 1; j < edges+1; j++) { r->init_req(j, NULL); }\n+      \/\/ zap all inputs to null for debugging (done in Node(uint) constructor)\n+      \/\/ for (int j = 1; j < edges+1; j++) { r->init_req(j, nullptr); }\n@@ -1866,1 +1866,1 @@\n-        phi = NULL;\n+        phi = nullptr;\n@@ -1875,1 +1875,1 @@\n-          assert(phi == NULL, \"the merge contains phis, not vice versa\");\n+          assert(phi == nullptr, \"the merge contains phis, not vice versa\");\n@@ -1879,1 +1879,1 @@\n-          if (phi == NULL) {\n+          if (phi == nullptr) {\n@@ -1902,1 +1902,1 @@\n-      if (phi != NULL && phi->bottom_type()->is_inlinetypeptr()) {\n+      if (phi != nullptr && phi->bottom_type()->is_inlinetypeptr()) {\n@@ -1924,1 +1924,1 @@\n-      } else if (phi != NULL) {\n+      } else if (phi != nullptr) {\n@@ -1969,1 +1969,1 @@\n-  assert(n != NULL, \"\");\n+  assert(n != nullptr, \"\");\n@@ -1976,2 +1976,2 @@\n-  PhiNode* base = NULL;\n-  MergeMemNode* remerge = NULL;\n+  PhiNode* base = nullptr;\n+  MergeMemNode* remerge = nullptr;\n@@ -1985,3 +1985,3 @@\n-      if (remerge == NULL) {\n-        guarantee(base != NULL, \"\");\n-        assert(base->in(0) != NULL, \"should not be xformed away\");\n+      if (remerge == nullptr) {\n+        guarantee(base != nullptr, \"\");\n+        assert(base->in(0) != nullptr, \"should not be xformed away\");\n@@ -2003,1 +2003,1 @@\n-        phi = NULL;\n+        phi = nullptr;\n@@ -2006,1 +2006,1 @@\n-    if (phi != NULL) {\n+    if (phi != nullptr) {\n@@ -2020,1 +2020,1 @@\n-  if (base != NULL && pnum == 1) {\n+  if (base != nullptr && pnum == 1) {\n@@ -2079,1 +2079,1 @@\n-  r->add_req(NULL);\n+  r->add_req(nullptr);\n@@ -2089,1 +2089,1 @@\n-          phi->add_req(NULL);\n+          phi->add_req(nullptr);\n@@ -2095,1 +2095,1 @@\n-        n->add_req(NULL);\n+        n->add_req(nullptr);\n@@ -2113,1 +2113,1 @@\n-  assert(o != NULL, \"\");\n+  assert(o != nullptr, \"\");\n@@ -2115,1 +2115,1 @@\n-  if (o == top())  return NULL; \/\/ TOP always merges into TOP\n+  if (o == top())  return nullptr; \/\/ TOP always merges into TOP\n@@ -2121,1 +2121,1 @@\n-  if (vt != NULL && vt->has_phi_inputs(region)) {\n+  if (vt != nullptr && vt->has_phi_inputs(region)) {\n@@ -2128,1 +2128,1 @@\n-  const Type* t = NULL;\n+  const Type* t = nullptr;\n@@ -2147,1 +2147,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2154,1 +2154,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2157,1 +2157,1 @@\n-  if (vt != NULL && t->is_inlinetypeptr()) {\n+  if (vt != nullptr && t->is_inlinetypeptr()) {\n@@ -2181,1 +2181,1 @@\n-  assert(o != NULL && o != top(), \"\");\n+  assert(o != nullptr && o != top(), \"\");\n@@ -2215,1 +2215,1 @@\n-  assert(receiver != NULL && receiver->bottom_type()->isa_instptr() != NULL,\n+  assert(receiver != nullptr && receiver->bottom_type()->isa_instptr() != nullptr,\n@@ -2219,1 +2219,1 @@\n-  if (tinst != NULL && tinst->is_loaded() && !tinst->klass_is_exact()) {\n+  if (tinst != nullptr && tinst->is_loaded() && !tinst->klass_is_exact()) {\n@@ -2233,1 +2233,1 @@\n-  Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), klass_addr, TypeInstPtr::KLASS));\n+  Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), klass_addr, TypeInstPtr::KLASS));\n@@ -2236,1 +2236,1 @@\n-  Node* access_flags = make_load(NULL, access_flags_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* access_flags = make_load(nullptr, access_flags_addr, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -2259,1 +2259,1 @@\n-                                   NULL, TypePtr::BOTTOM,\n+                                   nullptr, TypePtr::BOTTOM,\n@@ -2349,1 +2349,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -2418,1 +2418,1 @@\n-  SafePointNode *sfpnt = new SafePointNode(parms, NULL);\n+  SafePointNode *sfpnt = new SafePointNode(parms, nullptr);\n@@ -2460,1 +2460,1 @@\n-    assert(C->root() != NULL, \"Expect parse is still valid\");\n+    assert(C->root() != nullptr, \"Expect parse is still valid\");\n@@ -2468,2 +2468,2 @@\n-  InlineTree* ilt = NULL;\n-  if (C->ilt() != NULL) {\n+  InlineTree* ilt = nullptr;\n+  if (C->ilt() != nullptr) {\n@@ -2534,1 +2534,1 @@\n-  if( method() != NULL ) {\n+  if( method() != nullptr ) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":86,"deletions":86,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-    if (C->log() != NULL)   C->log()->elem(\"observe that='!need_range_check'\");\n+    if (C->log() != nullptr)   C->log()->elem(\"observe that='!need_range_check'\");\n@@ -412,1 +412,1 @@\n-                      NULL, \"range_check\");\n+                      nullptr, \"range_check\");\n@@ -572,1 +572,1 @@\n-                    NULL,\n+                    nullptr,\n@@ -594,1 +594,1 @@\n-                    NULL,\n+                    nullptr,\n@@ -613,1 +613,1 @@\n-                  NULL,\n+                  nullptr,\n@@ -762,1 +762,1 @@\n-  ciMultiBranchData* profile = NULL;\n+  ciMultiBranchData* profile = nullptr;\n@@ -765,1 +765,1 @@\n-    if (data != NULL && data->is_MultiBranchData()) {\n+    if (data != nullptr && data->is_MultiBranchData()) {\n@@ -778,1 +778,1 @@\n-    if (profile != NULL) {\n+    if (profile != nullptr) {\n@@ -788,1 +788,1 @@\n-    if (profile != NULL) {\n+    if (profile != nullptr) {\n@@ -799,1 +799,1 @@\n-    if (profile != NULL) {\n+    if (profile != nullptr) {\n@@ -836,1 +836,1 @@\n-  ciMultiBranchData* profile = NULL;\n+  ciMultiBranchData* profile = nullptr;\n@@ -839,1 +839,1 @@\n-    if (data != NULL && data->is_MultiBranchData()) {\n+    if (data != nullptr && data->is_MultiBranchData()) {\n@@ -852,1 +852,1 @@\n-      table[3*j+2] = (profile == NULL) ? 1 : (jint)MIN2<uint>((uint)max_jint, profile->count_at(j));\n+      table[3*j+2] = (profile == nullptr) ? 1 : (jint)MIN2<uint>((uint)max_jint, profile->count_at(j));\n@@ -858,1 +858,1 @@\n-  if (profile != NULL) {\n+  if (profile != nullptr) {\n@@ -943,1 +943,1 @@\n-    : _lo(lo), _hi(hi), _mid(NULL),\n+    : _lo(lo), _hi(hi), _mid(nullptr),\n@@ -948,1 +948,1 @@\n-    : _lo(NULL), _hi(NULL), _mid(NULL),\n+    : _lo(nullptr), _hi(nullptr), _mid(nullptr),\n@@ -962,1 +962,1 @@\n-      if (r._mid == NULL) {\n+      if (r._mid == nullptr) {\n@@ -971,1 +971,1 @@\n-        SwitchRange* mid = NULL;\n+        SwitchRange* mid = nullptr;\n@@ -1020,1 +1020,1 @@\n-  SwitchRange* ranges = NULL;\n+  SwitchRange* ranges = nullptr;\n@@ -1216,1 +1216,1 @@\n-  ciMultiBranchData* profile = NULL;\n+  ciMultiBranchData* profile = nullptr;\n@@ -1219,1 +1219,1 @@\n-    if (data != NULL && data->is_MultiBranchData()) {\n+    if (data != nullptr && data->is_MultiBranchData()) {\n@@ -1224,1 +1224,1 @@\n-  Node* jtn = _gvn.transform(new JumpNode(control(), key_val, num_cases, probs, profile == NULL ? COUNT_UNKNOWN : total));\n+  Node* jtn = _gvn.transform(new JumpNode(control(), key_val, num_cases, probs, profile == nullptr ? COUNT_UNKNOWN : total));\n@@ -1278,1 +1278,1 @@\n-    if (ti != NULL) {\n+    if (ti != nullptr) {\n@@ -1315,1 +1315,1 @@\n-    SwitchRange* mid = NULL;\n+    SwitchRange* mid = nullptr;\n@@ -1439,1 +1439,1 @@\n-                              \"frem\", NULL, \/\/no memory effects\n+                              \"frem\", nullptr, \/\/no memory effects\n@@ -1451,1 +1451,1 @@\n-                              \"drem\", NULL, \/\/no memory effects\n+                              \"drem\", nullptr, \/\/no memory effects\n@@ -1468,1 +1468,1 @@\n-                              \"l2f\", NULL, \/\/no memory effects\n+                              \"l2f\", nullptr, \/\/no memory effects\n@@ -1550,1 +1550,1 @@\n-    if (data == NULL) {\n+    if (data == nullptr) {\n@@ -1570,1 +1570,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -1600,2 +1600,2 @@\n-  if (C->log() != NULL) {\n-    const char* prob_str = NULL;\n+  if (C->log() != nullptr) {\n+    const char* prob_str = nullptr;\n@@ -1605,1 +1605,1 @@\n-    if (prob_str == NULL) {\n+    if (prob_str == nullptr) {\n@@ -1644,1 +1644,1 @@\n-        if (data == NULL ||\n+        if (data == nullptr ||\n@@ -1694,2 +1694,2 @@\n-  assert(argument(0) != NULL, \"must exist\");\n-  assert(bc_depth == 1 || argument(1) != NULL, \"two must exist\");\n+  assert(argument(0) != nullptr, \"must exist\");\n+  assert(bc_depth == 1 || argument(1) != nullptr, \"two must exist\");\n@@ -1717,1 +1717,1 @@\n-                  NULL, \"cold\");\n+                  nullptr, \"cold\");\n@@ -1788,1 +1788,1 @@\n-                  NULL, \"cold\");\n+                  nullptr, \"cold\");\n@@ -1818,1 +1818,1 @@\n-    \/\/ This wins when (Bool ne (Conv2B p) 0) => (Bool ne (CmpP p NULL)).\n+    \/\/ This wins when (Bool ne (Conv2B p) 0) => (Bool ne (CmpP p null)).\n@@ -2323,1 +2323,1 @@\n-                  NULL,\n+                  nullptr,\n@@ -2365,1 +2365,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2370,1 +2370,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2374,1 +2374,1 @@\n-  assert(ldk != NULL && ldk->is_Load(), \"should have found a LoadKlass or LoadNKlass node\");\n+  assert(ldk != nullptr && ldk->is_Load(), \"should have found a LoadKlass or LoadNKlass node\");\n@@ -2379,2 +2379,2 @@\n-  if (obj == NULL || off != oopDesc::klass_offset_in_bytes()) \/\/ loading oopDesc::_klass?\n-    return NULL;\n+  if (obj == nullptr || off != oopDesc::klass_offset_in_bytes()) \/\/ loading oopDesc::_klass?\n+    return nullptr;\n@@ -2382,2 +2382,2 @@\n-  if (tp == NULL || !(tp->isa_instptr() || tp->isa_aryptr())) \/\/ is obj a Java object ptr?\n-    return NULL;\n+  if (tp == nullptr || !(tp->isa_instptr() || tp->isa_aryptr())) \/\/ is obj a Java object ptr?\n+    return nullptr;\n@@ -2396,1 +2396,1 @@\n-    if (obj != NULL && (con_type->isa_instptr() || con_type->isa_aryptr())) {\n+    if (obj != nullptr && (con_type->isa_instptr() || con_type->isa_aryptr())) {\n@@ -2402,1 +2402,1 @@\n-       if (tboth != NULL && tboth->klass_is_exact() && tboth != obj_type &&\n+       if (tboth != nullptr && tboth->klass_is_exact() && tboth != obj_type &&\n@@ -2435,2 +2435,2 @@\n-  ConstraintCastNode* ccast = NULL;\n-  Node* cast = NULL;\n+  ConstraintCastNode* ccast = nullptr;\n+  Node* cast = nullptr;\n@@ -2473,1 +2473,1 @@\n-  if (ccast != NULL) {\n+  if (ccast != nullptr) {\n@@ -2484,1 +2484,1 @@\n-  if (cast != NULL) {                   \/\/ Here's the payoff.\n+  if (cast != nullptr) {                   \/\/ Here's the payoff.\n@@ -2504,2 +2504,2 @@\n-    Node* load_klass = NULL;\n-    Node* decode = NULL;\n+    Node* load_klass = nullptr;\n+    Node* decode = nullptr;\n@@ -2516,1 +2516,1 @@\n-      if (obj_type->speculative_type_not_null() != NULL) {\n+      if (obj_type->speculative_type_not_null() != nullptr) {\n@@ -2530,1 +2530,1 @@\n-        if (decode != NULL) {\n+        if (decode != nullptr) {\n@@ -2617,1 +2617,1 @@\n-      if (con_type != NULL) {\n+      if (con_type != nullptr) {\n@@ -2625,1 +2625,1 @@\n-                      NULL, \"constant in error state\", true \/* must_throw *\/);\n+                      nullptr, \"constant in error state\", true \/* must_throw *\/);\n@@ -2632,1 +2632,1 @@\n-                      NULL, \"unresolved constant\", false \/* must_throw *\/);\n+                      nullptr, \"unresolved constant\", false \/* must_throw *\/);\n@@ -3273,1 +3273,1 @@\n-    a = Compile::narrow_value(T_BYTE, a, NULL, &_gvn, true);\n+    a = Compile::narrow_value(T_BYTE, a, nullptr, &_gvn, true);\n@@ -3278,1 +3278,1 @@\n-    a = Compile::narrow_value(T_SHORT, a, NULL, &_gvn, true);\n+    a = Compile::narrow_value(T_SHORT, a, nullptr, &_gvn, true);\n@@ -3283,1 +3283,1 @@\n-    a = Compile::narrow_value(T_CHAR, a, NULL, &_gvn, true);\n+    a = Compile::narrow_value(T_CHAR, a, nullptr, &_gvn, true);\n@@ -3307,1 +3307,1 @@\n-    return_current(NULL);\n+    return_current(nullptr);\n@@ -3323,1 +3323,1 @@\n-    \/\/ null exception oop throws NULL pointer exception\n+    \/\/ null exception oop throws null pointer exception\n@@ -3357,1 +3357,1 @@\n-    assert(data != NULL && data->is_JumpData(), \"need JumpData for taken branch\");\n+    assert(data != nullptr && data->is_JumpData(), \"need JumpData for taken branch\");\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-                  NULL, \"put to call site target field\");\n+                  nullptr, \"put to call site target field\");\n@@ -138,1 +138,1 @@\n-    if (con != NULL) {\n+    if (con != nullptr) {\n@@ -148,1 +148,1 @@\n-  Node* ld = NULL;\n+  Node* ld = nullptr;\n@@ -172,1 +172,1 @@\n-        assert(type != NULL, \"field singleton type must be consistent\");\n+        assert(type != nullptr, \"field singleton type must be consistent\");\n@@ -218,1 +218,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -283,1 +283,1 @@\n-      if (AllocateNode::Ideal_allocation(obj, &_gvn) != NULL) {\n+      if (AllocateNode::Ideal_allocation(obj, &_gvn) != nullptr) {\n@@ -317,1 +317,1 @@\n-  } else if (array_klass->element_klass() != NULL &&\n+  } else if (array_klass->element_klass() != nullptr &&\n@@ -322,1 +322,1 @@\n-                  NULL);\n+                  nullptr);\n@@ -349,1 +349,1 @@\n-  assert(length != NULL, \"\");\n+  assert(length != nullptr, \"\");\n@@ -382,1 +382,1 @@\n-  length[ndimensions] = NULL;  \/\/ terminating null for make_runtime_call\n+  length[ndimensions] = nullptr;  \/\/ terminating null for make_runtime_call\n@@ -389,1 +389,1 @@\n-  if (elem_klass != NULL && elem_klass->is_inlinetype() && !elem_klass->as_inline_klass()->is_initialized()) {\n+  if (elem_klass != nullptr && elem_klass->is_inlinetype() && !elem_klass->as_inline_klass()->is_initialized()) {\n@@ -393,1 +393,1 @@\n-                  NULL);\n+                  nullptr);\n@@ -418,1 +418,1 @@\n-    Node* obj = NULL;\n+    Node* obj = nullptr;\n@@ -433,1 +433,1 @@\n-  address fun = NULL;\n+  address fun = nullptr;\n@@ -441,1 +441,1 @@\n-  Node* c = NULL;\n+  Node* c = nullptr;\n@@ -443,1 +443,1 @@\n-  if (fun != NULL) {\n+  if (fun != nullptr) {\n@@ -446,1 +446,1 @@\n-                          fun, NULL, TypeRawPtr::BOTTOM,\n+                          fun, nullptr, TypeRawPtr::BOTTOM,\n@@ -449,2 +449,2 @@\n-                          (ndimensions > 2) ? length[3] : NULL,\n-                          (ndimensions > 3) ? length[4] : NULL);\n+                          (ndimensions > 2) ? length[3] : nullptr,\n+                          (ndimensions > 3) ? length[4] : nullptr);\n@@ -453,1 +453,1 @@\n-    Node* dims = NULL;\n+    Node* dims = nullptr;\n@@ -468,1 +468,1 @@\n-                          OptoRuntime::multianewarrayN_Java(), NULL, TypeRawPtr::BOTTOM,\n+                          OptoRuntime::multianewarrayN_Java(), nullptr, TypeRawPtr::BOTTOM,\n@@ -483,1 +483,1 @@\n-  if (ltype != NULL)\n+  if (ltype != nullptr)\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-  \/\/ _from_ is not loaded, and value is not null.  If the value _is_ NULL,\n+  \/\/ _from_ is not loaded, and value is not null.  If the value _is_ null,\n@@ -81,1 +81,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -98,1 +98,1 @@\n-  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)), NULL, null_free);\n+  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)), nullptr, null_free);\n@@ -121,1 +121,1 @@\n-    if (C->log() != NULL) {\n+    if (C->log() != nullptr) {\n@@ -175,1 +175,1 @@\n-    const TypeKlassPtr* extak = NULL;\n+    const TypeKlassPtr* extak = nullptr;\n@@ -181,1 +181,1 @@\n-    if (ary_spec != NULL && !too_many_traps(Deoptimization::Reason_speculate_class_check)) {\n+    if (ary_spec != nullptr && !too_many_traps(Deoptimization::Reason_speculate_class_check)) {\n@@ -188,2 +188,2 @@\n-        ciKlass* array_type = NULL;\n-        ciKlass* element_type = NULL;\n+        ciKlass* array_type = nullptr;\n+        ciKlass* element_type = nullptr;\n@@ -194,1 +194,1 @@\n-        if (array_type != NULL) {\n+        if (array_type != nullptr) {\n@@ -220,1 +220,1 @@\n-    if (extak != NULL && extak->exact_klass(true) != NULL) {\n+    if (extak != nullptr && extak->exact_klass(true) != nullptr) {\n@@ -245,1 +245,1 @@\n-        if (log != NULL) {\n+        if (log != nullptr) {\n@@ -262,1 +262,1 @@\n-  Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, always_see_exact_class ? control() : NULL,\n+  Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, always_see_exact_class ? control() : nullptr,\n@@ -275,1 +275,1 @@\n-  return gen_checkcast(obj, a_e_klass, NULL, null_free);\n+  return gen_checkcast(obj, a_e_klass, nullptr, null_free);\n@@ -384,2 +384,2 @@\n-  MergeMemNode *mem = map() == NULL ? NULL : (map()->memory()->is_MergeMem() ?\n-                                      map()->memory()->as_MergeMem() : NULL);\n+  MergeMemNode *mem = map() == nullptr ? nullptr : (map()->memory()->is_MergeMem() ?\n+                                      map()->memory()->as_MergeMem() : nullptr);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  _sentinel = new ProjNode(NULL, TypeFunc::Control);\n+  _sentinel = new ProjNode(nullptr, TypeFunc::Control);\n@@ -76,1 +76,1 @@\n-  _sentinel = new ProjNode(NULL, TypeFunc::Control);\n+  _sentinel = new ProjNode(nullptr, TypeFunc::Control);\n@@ -102,1 +102,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -110,1 +110,1 @@\n-    return NULL;                \/\/ Miss!\n+    return nullptr;             \/\/ Miss!\n@@ -132,1 +132,1 @@\n-      return NULL;              \/\/ Miss!\n+      return nullptr;           \/\/ Miss!\n@@ -136,1 +136,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -147,1 +147,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -159,1 +159,1 @@\n-    return NULL;                \/\/ Miss!\n+    return nullptr;             \/\/ Miss!\n@@ -188,1 +188,1 @@\n-      return NULL;              \/\/ Miss!\n+      return nullptr;           \/\/ Miss!\n@@ -196,1 +196,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -238,1 +238,1 @@\n-  for( ; \/* (k != NULL) && (k != _sentinel) *\/; ) {\n+  for( ; \/* (k != nullptr) && (k != _sentinel) *\/; ) {\n@@ -297,1 +297,1 @@\n-\/\/ Clear all entries in _table to NULL but keep storage\n+\/\/ Clear all entries in _table to null but keep storage\n@@ -322,1 +322,1 @@\n-    if(n != NULL && n != sentinel_node && !useful.test(n->_idx)) {\n+    if(n != nullptr && n != sentinel_node && !useful.test(n->_idx)) {\n@@ -338,1 +338,1 @@\n-    if (n != NULL &&\n+    if (n != nullptr &&\n@@ -382,1 +382,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -570,1 +570,1 @@\n-  if (type != NULL && type->isa_oopptr() && type->is_oopptr()->is_known_instance()) {\n+  if (type != nullptr && type->isa_oopptr() && type->is_oopptr()->is_known_instance()) {\n@@ -598,1 +598,1 @@\n-  _types.map(C->unique(), NULL);\n+  _types.map(C->unique(), nullptr);\n@@ -614,1 +614,1 @@\n-  _types.map(C->unique(), NULL);\n+  _types.map(C->unique(), nullptr);\n@@ -641,1 +641,1 @@\n-  if (n == NULL)  return NULL;\n+  if (n == nullptr)  return nullptr;\n@@ -646,1 +646,1 @@\n-  if (t == NULL)  return NULL;\n+  if (t == nullptr)  return nullptr;\n@@ -653,1 +653,1 @@\n-  if (n == NULL)  return NULL;\n+  if (n == nullptr)  return nullptr;\n@@ -656,1 +656,1 @@\n-  if (t == NULL)  return NULL;\n+  if (t == nullptr)  return nullptr;\n@@ -698,1 +698,1 @@\n-  if (type_or_null(n) != NULL) {\n+  if (type_or_null(n) != nullptr) {\n@@ -761,1 +761,1 @@\n-  if (k == NULL) {\n+  if (k == nullptr) {\n@@ -764,1 +764,1 @@\n-    if (nna != NULL) {\n+    if (nna != nullptr) {\n@@ -781,1 +781,1 @@\n-    if (icon != NULL && icon->in(TypeFunc::Control) != NULL)\n+    if (icon != nullptr && icon->in(TypeFunc::Control) != nullptr)\n@@ -797,1 +797,1 @@\n-    if (lcon != NULL && lcon->in(TypeFunc::Control) != NULL)\n+    if (lcon != nullptr && lcon->in(TypeFunc::Control) != nullptr)\n@@ -820,1 +820,1 @@\n-  if (zcon != NULL && zcon->in(TypeFunc::Control) != NULL)\n+  if (zcon != nullptr && zcon->in(TypeFunc::Control) != nullptr)\n@@ -832,1 +832,1 @@\n-  if (i == NULL) {\n+  if (i == nullptr) {\n@@ -855,1 +855,1 @@\n-  while (i != NULL) {\n+  while (i != nullptr) {\n@@ -876,1 +876,1 @@\n-  assert(t != NULL, \"value sanity\");\n+  assert(t != nullptr, \"value sanity\");\n@@ -880,1 +880,1 @@\n-    if (type_or_null(k) == NULL) {\n+    if (type_or_null(k) == nullptr) {\n@@ -926,1 +926,1 @@\n-    if (n == NULL || i >= 100) {\n+    if (n == nullptr || i >= 100) {\n@@ -939,1 +939,1 @@\n-  if (n != NULL && !n->is_dead_loop_safe() && !n->is_CFG()) {\n+  if (n != nullptr && !n->is_dead_loop_safe() && !n->is_CFG()) {\n@@ -947,1 +947,1 @@\n-      } else if (in != NULL && !in->is_dead_loop_safe()) {\n+      } else if (in != nullptr && !in->is_dead_loop_safe()) {\n@@ -1002,1 +1002,1 @@\n-    if(n != NULL && n != _table.sentinel() && n->outcnt() == 0) {\n+    if(n != nullptr && n != _table.sentinel() && n->outcnt() == 0) {\n@@ -1049,1 +1049,1 @@\n-      if (n == NULL) {\n+      if (n == nullptr) {\n@@ -1073,1 +1073,1 @@\n-      if (oldtype != newtype && oldtype != NULL) {\n+      if (oldtype != newtype && oldtype != nullptr) {\n@@ -1082,1 +1082,1 @@\n-      if (oldtype == NULL) {\n+      if (oldtype == nullptr) {\n@@ -1089,1 +1089,1 @@\n-      if (newtype == NULL) {\n+      if (newtype == nullptr) {\n@@ -1107,1 +1107,1 @@\n-      verify_step((Node*) NULL);\n+      verify_step((Node*) nullptr);\n@@ -1116,1 +1116,1 @@\n-    _verify_window[i] = NULL;\n+    _verify_window[i] = nullptr;\n@@ -1121,1 +1121,1 @@\n-  while (modified_list != NULL && modified_list->size()) {\n+  while (modified_list != nullptr && modified_list->size()) {\n@@ -1135,1 +1135,1 @@\n-  while (modified_list != NULL && modified_list->size()) {\n+  while (modified_list != nullptr && modified_list->size()) {\n@@ -1156,1 +1156,1 @@\n-  if (modified_list != NULL) {\n+  if (modified_list != nullptr) {\n@@ -1263,1 +1263,1 @@\n-  \/\/ If we assert inside type(n), because the type is still a nullptr, then maybe\n+  \/\/ If we assert inside type(n), because the type is still a null, then maybe\n@@ -1327,1 +1327,1 @@\n-  if (orig != NULL)  C->copy_node_notes_to(n, orig);\n+  if (orig != nullptr)  C->copy_node_notes_to(n, orig);\n@@ -1336,1 +1336,1 @@\n-  if (type_or_null(n) == NULL) {\n+  if (type_or_null(n) == nullptr) {\n@@ -1376,1 +1376,1 @@\n-  while (i != NULL) {\n+  while (i != nullptr) {\n@@ -1408,1 +1408,1 @@\n-  assert(t != NULL, \"value sanity\");\n+  assert(t != nullptr, \"value sanity\");\n@@ -1493,2 +1493,2 @@\n-          if (in != NULL && in != C->top()) {  \/\/ Points to something?\n-            int nrep = dead->replace_edge(in, NULL, this);  \/\/ Kill edges\n+          if (in != nullptr && in != C->top()) {  \/\/ Points to something?\n+            int nrep = dead->replace_edge(in, nullptr, this);  \/\/ Kill edges\n@@ -1519,1 +1519,1 @@\n-                in->is_Proj() && in->in(0) != NULL && in->in(0)->is_Initialize()) {\n+                in->is_Proj() && in->in(0) != nullptr && in->in(0)->is_Initialize()) {\n@@ -1530,1 +1530,1 @@\n-          } \/\/ if (in != NULL && in != C->top())\n+          } \/\/ if (in != nullptr && in != C->top())\n@@ -1586,1 +1586,1 @@\n-  if (old->is_Phi() && old->as_Phi()->type()->has_memory() && old->in(0) != NULL) {\n+  if (old->is_Phi() && old->as_Phi()->type()->has_memory() && old->in(0) != nullptr) {\n@@ -1590,1 +1590,1 @@\n-      if (phi != NULL && phi->inst_mem_id() == (int)old->_idx) {\n+      if (phi != nullptr && phi->inst_mem_id() == (int)old->_idx) {\n@@ -1601,1 +1601,1 @@\n-  if (nn != NULL && nn->outcnt() == 0) {\n+  if (nn != nullptr && nn->outcnt() == 0) {\n@@ -1646,1 +1646,1 @@\n-          if (phi != NULL) {\n+          if (phi != nullptr) {\n@@ -1653,1 +1653,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1668,1 +1668,1 @@\n-    \/\/ the Catch following the call.  It's looking for a non-NULL\n+    \/\/ the Catch following the call.  It's looking for a non-null\n@@ -1673,1 +1673,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -1701,1 +1701,1 @@\n-        if (phi != NULL) {\n+        if (phi != nullptr) {\n@@ -1848,1 +1848,1 @@\n-      if (init != NULL) {\n+      if (init != nullptr) {\n@@ -1850,1 +1850,1 @@\n-        if (imem != NULL)  add_users_to_worklist0(imem);\n+        if (imem != nullptr)  add_users_to_worklist0(imem);\n@@ -1858,1 +1858,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -1865,1 +1865,1 @@\n-      if (imem != NULL)  add_users_to_worklist0(imem);\n+      if (imem != nullptr)  add_users_to_worklist0(imem);\n@@ -1927,1 +1927,1 @@\n-    if (t != NULL) {\n+    if (t != nullptr) {\n@@ -2118,1 +2118,1 @@\n-\/\/ non-NULL receiver to know when to enable the regular fall-through path in addition to the NullPtrException path.\n+\/\/ non-null receiver to know when to enable the regular fall-through path in addition to the NullPtrException path.\n@@ -2126,1 +2126,1 @@\n-        if (catch_node != NULL) {\n+        if (catch_node != nullptr) {\n@@ -2156,1 +2156,1 @@\n-    if (phi != NULL) {\n+    if (phi != nullptr) {\n@@ -2257,1 +2257,1 @@\n-  if( new_node != NULL )\n+  if( new_node != nullptr )\n@@ -2278,1 +2278,1 @@\n-    assert(new_node == NULL, \"\");\n+    assert(new_node == nullptr, \"\");\n@@ -2290,1 +2290,1 @@\n-      if( input != NULL ) {                    \/\/ Ignore NULLs\n+      if( input != nullptr ) {                 \/\/ Ignore nulls\n@@ -2292,1 +2292,1 @@\n-        if( new_input == NULL ) {\n+        if( new_input == nullptr ) {\n@@ -2334,1 +2334,1 @@\n-      if( C->cached_top_node() == NULL || C->cached_top_node()->in(0) == NULL ) {\n+      if( C->cached_top_node() == nullptr || C->cached_top_node()->in(0) == nullptr ) {\n@@ -2346,1 +2346,1 @@\n-        n->set_req(0, NULL);        \/\/ Cut selfreference\n+        n->set_req(0, nullptr);     \/\/ Cut selfreference\n@@ -2379,1 +2379,1 @@\n-  \/\/ TEMPORARY fix to ensure that 2nd GVN pass eliminates NULL checks\n+  \/\/ TEMPORARY fix to ensure that 2nd GVN pass eliminates null checks\n@@ -2440,1 +2440,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2542,1 +2542,1 @@\n-  if (igvn == NULL) {\n+  if (igvn == nullptr) {\n@@ -2575,1 +2575,1 @@\n-    _types[0] = NULL;\n+    _types[0] = nullptr;\n@@ -2588,1 +2588,1 @@\n-    if( _types[i] != NULL ) {\n+    if( _types[i] != nullptr ) {\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":81,"deletions":81,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-\/\/ Expandable closed hash-table of nodes, initialized to NULL.\n+\/\/ Expandable closed hash-table of nodes, initialized to null.\n@@ -86,1 +86,1 @@\n-  void   clear();               \/\/ Set all entries to NULL, keep storage.\n+  void   clear();               \/\/ Set all entries to null, keep storage.\n@@ -120,1 +120,1 @@\n-\/\/ Abstractly provides an infinite array of Type*'s, initialized to NULL.\n+\/\/ Abstractly provides an infinite array of Type*'s, initialized to null.\n@@ -129,2 +129,2 @@\n-  const Type *operator[] ( uint i ) const \/\/ Lookup, or NULL for not mapped\n-  { return (i<_max) ? _types[i] : (Type*)NULL; }\n+  const Type *operator[] ( uint i ) const \/\/ Lookup, or null for not mapped\n+  { return (i<_max) ? _types[i] : (Type*)nullptr; }\n@@ -223,1 +223,1 @@\n-  \/\/ you must use type_or_null, and test the result for NULL.\n+  \/\/ you must use type_or_null, and test the result for null.\n@@ -226,1 +226,1 @@\n-    assert(n != NULL, \"must not be null\");\n+    assert(n != nullptr, \"must not be null\");\n@@ -228,1 +228,1 @@\n-    assert(t != NULL, \"must set before get\");\n+    assert(t != nullptr, \"must set before get\");\n@@ -232,1 +232,1 @@\n-  \/\/ or else return NULL if there is none.\n+  \/\/ or else return null if there is none.\n@@ -239,1 +239,1 @@\n-    assert(t != NULL, \"type must not be null\");\n+    assert(t != nullptr, \"type must not be null\");\n@@ -244,1 +244,1 @@\n-      _types.map(n->_idx, NULL);\n+      _types.map(n->_idx, nullptr);\n@@ -252,1 +252,1 @@\n-    assert(_types[n->_idx] == NULL, \"must set the initial type just once\");\n+    assert(_types[n->_idx] == nullptr, \"must set the initial type just once\");\n@@ -259,1 +259,1 @@\n-      _types.map(n->_idx, NULL);   \/\/ Grow the types array as needed.\n+      _types.map(n->_idx, nullptr);   \/\/ Grow the types array as needed.\n@@ -267,1 +267,1 @@\n-    return (t != NULL && t->is_con()) ? t->get_con() : value_if_unknown;\n+    return (t != nullptr && t->is_con()) ? t->get_con() : value_if_unknown;\n@@ -271,1 +271,1 @@\n-    return (t != NULL && t->is_con()) ? t->get_con() : value_if_unknown;\n+    return (t != nullptr && t->is_con()) ? t->get_con() : value_if_unknown;\n@@ -278,1 +278,1 @@\n-  { ShouldNotCallThis(); return NULL; }\n+  { ShouldNotCallThis(); return nullptr; }\n@@ -342,1 +342,1 @@\n-  { ShouldNotCallThis(); return NULL; }\n+  { ShouldNotCallThis(); return nullptr; }\n@@ -383,1 +383,1 @@\n-  PhaseIterGVN* is_IterGVN() { return (_iterGVN) ? (PhaseIterGVN*)this : NULL; }\n+  PhaseIterGVN* is_IterGVN() { return (_iterGVN) ? (PhaseIterGVN*)this : nullptr; }\n@@ -509,1 +509,1 @@\n-  Node* register_new_node_with_optimizer(Node* n, Node* orig = NULL);\n+  Node* register_new_node_with_optimizer(Node* n, Node* orig = nullptr);\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-    _token = strtok_r(NULL, \",\", &_saved_ptr);\n+    _token = strtok_r(nullptr, \",\", &_saved_ptr);\n@@ -164,1 +164,1 @@\n-    for (PhaseNameIter iter(option); *iter != NULL && _valid; ++iter) {\n+    for (PhaseNameIter iter(option); *iter != nullptr && _valid; ++iter) {\n@@ -170,1 +170,1 @@\n-        \/\/ strncpy always writes len characters. If the source string is shorter, the function fills the remaining bytes with NULLs.\n+        \/\/ strncpy always writes len characters. If the source string is shorter, the function fills the remaining bytes with nulls.\n@@ -183,1 +183,1 @@\n-    if (_bad != NULL) {\n+    if (_bad != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-  if (_replaced_nodes == NULL) {\n+  if (_replaced_nodes == nullptr) {\n@@ -38,1 +38,1 @@\n-  return _replaced_nodes == NULL || _replaced_nodes->length() == 0;\n+  return _replaced_nodes == nullptr || _replaced_nodes->length() == 0;\n@@ -81,1 +81,1 @@\n-  if (_replaced_nodes != NULL) {\n+  if (_replaced_nodes != nullptr) {\n@@ -89,1 +89,1 @@\n-  if (_replaced_nodes != NULL) {\n+  if (_replaced_nodes != nullptr) {\n@@ -133,1 +133,1 @@\n-    assert (ctl != NULL && !ctl->is_top(), \"replaced node should have actual control\");\n+    assert (ctl != nullptr && !ctl->is_top(), \"replaced node should have actual control\");\n@@ -154,1 +154,1 @@\n-        if (n->is_CFG() || (n->in(0) != NULL && !n->in(0)->is_top())) {\n+        if (n->is_CFG() || (n->in(0) != nullptr && !n->in(0)->is_top())) {\n@@ -168,1 +168,1 @@\n-            if (depth >= 100 || n == NULL) {\n+            if (depth >= 100 || n == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/replacednodes.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,17 +98,17 @@\n-address OptoRuntime::_new_instance_Java                           = NULL;\n-address OptoRuntime::_new_array_Java                              = NULL;\n-address OptoRuntime::_new_array_nozero_Java                       = NULL;\n-address OptoRuntime::_multianewarray2_Java                        = NULL;\n-address OptoRuntime::_multianewarray3_Java                        = NULL;\n-address OptoRuntime::_multianewarray4_Java                        = NULL;\n-address OptoRuntime::_multianewarray5_Java                        = NULL;\n-address OptoRuntime::_multianewarrayN_Java                        = NULL;\n-address OptoRuntime::_vtable_must_compile_Java                    = NULL;\n-address OptoRuntime::_complete_monitor_locking_Java               = NULL;\n-address OptoRuntime::_monitor_notify_Java                         = NULL;\n-address OptoRuntime::_monitor_notifyAll_Java                      = NULL;\n-address OptoRuntime::_rethrow_Java                                = NULL;\n-\n-address OptoRuntime::_slow_arraycopy_Java                         = NULL;\n-address OptoRuntime::_register_finalizer_Java                     = NULL;\n-address OptoRuntime::_load_unknown_inline                         = NULL;\n+address OptoRuntime::_new_instance_Java                           = nullptr;\n+address OptoRuntime::_new_array_Java                              = nullptr;\n+address OptoRuntime::_new_array_nozero_Java                       = nullptr;\n+address OptoRuntime::_multianewarray2_Java                        = nullptr;\n+address OptoRuntime::_multianewarray3_Java                        = nullptr;\n+address OptoRuntime::_multianewarray4_Java                        = nullptr;\n+address OptoRuntime::_multianewarray5_Java                        = nullptr;\n+address OptoRuntime::_multianewarrayN_Java                        = nullptr;\n+address OptoRuntime::_vtable_must_compile_Java                    = nullptr;\n+address OptoRuntime::_complete_monitor_locking_Java               = nullptr;\n+address OptoRuntime::_monitor_notify_Java                         = nullptr;\n+address OptoRuntime::_monitor_notifyAll_Java                      = nullptr;\n+address OptoRuntime::_rethrow_Java                                = nullptr;\n+\n+address OptoRuntime::_slow_arraycopy_Java                         = nullptr;\n+address OptoRuntime::_register_finalizer_Java                     = nullptr;\n+address OptoRuntime::_load_unknown_inline                         = nullptr;\n@@ -136,1 +136,1 @@\n-  if (var == NULL) { return false; }\n+  if (var == nullptr) { return false; }\n@@ -187,1 +187,1 @@\n-  assert(rs != NULL && rs->is_runtime_stub(), \"not a runtime stub\");\n+  assert(rs != nullptr && rs->is_runtime_stub(), \"not a runtime stub\");\n@@ -312,1 +312,1 @@\n-  if ((len > 0) && (result != NULL) &&\n+  if ((len > 0) && (result != nullptr) &&\n@@ -619,1 +619,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -624,1 +624,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -791,1 +791,1 @@\n-    fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+    fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -833,1 +833,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -854,1 +854,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -1034,1 +1034,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -1080,1 +1080,1 @@\n-  fields[TypeFunc::Parms+0] = NULL;\n+  fields[TypeFunc::Parms+0] = nullptr;\n@@ -1100,1 +1100,1 @@\n-  fields[TypeFunc::Parms+0] = NULL;\n+  fields[TypeFunc::Parms+0] = nullptr;\n@@ -1188,1 +1188,1 @@\n-  fields[TypeFunc::Parms + 0] = NULL;\n+  fields[TypeFunc::Parms + 0] = nullptr;\n@@ -1228,1 +1228,1 @@\n-    fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+    fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -1269,1 +1269,1 @@\n-  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms + 0] = nullptr; \/\/ void\n@@ -1311,1 +1311,1 @@\n-  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms + 0] = nullptr; \/\/ void\n@@ -1326,1 +1326,1 @@\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n@@ -1365,2 +1365,2 @@\n-  assert(current->exception_oop() != NULL, \"exception oop is found\");\n-  address handler_address = NULL;\n+  assert(current->exception_oop() != nullptr, \"exception oop is found\");\n+  address handler_address = nullptr;\n@@ -1399,1 +1399,1 @@\n-  assert(nm != NULL, \"No NMethod found\");\n+  assert(nm != nullptr, \"No NMethod found\");\n@@ -1440,1 +1440,1 @@\n-        force_unwind ? NULL : nm->handler_for_exception_and_pc(exception, pc);\n+        force_unwind ? nullptr : nm->handler_for_exception_and_pc(exception, pc);\n@@ -1442,1 +1442,1 @@\n-      if (handler_address == NULL) {\n+      if (handler_address == nullptr) {\n@@ -1445,1 +1445,1 @@\n-        assert (handler_address != NULL, \"must have compiled handler\");\n+        assert (handler_address != nullptr, \"must have compiled handler\");\n@@ -1491,2 +1491,2 @@\n-  nmethod* nm = NULL;\n-  address handler_address = NULL;\n+  nmethod* nm = nullptr;\n+  address handler_address = nullptr;\n@@ -1505,1 +1505,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -1557,1 +1557,1 @@\n-  assert (exception != NULL, \"should have thrown a NULLPointerException\");\n+  assert (exception != nullptr, \"should have thrown a NullPointerException\");\n@@ -1696,1 +1696,1 @@\n-NamedCounter * volatile OptoRuntime::_named_counters = NULL;\n+NamedCounter * volatile OptoRuntime::_named_counters = nullptr;\n@@ -1752,1 +1752,1 @@\n-    ciMethod* m = jvms->has_method() ? jvms->method() : NULL;\n+    ciMethod* m = jvms->has_method() ? jvms->method() : nullptr;\n@@ -1760,1 +1760,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -1779,1 +1779,1 @@\n-    c->set_next(NULL);\n+    c->set_next(nullptr);\n@@ -1892,1 +1892,1 @@\n-  assert(buffer != NULL, \"can't store null into flat array\");\n+  assert(buffer != nullptr, \"can't store null into flat array\");\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-    _name(n == NULL ? NULL : os::strdup(n)),\n+    _name(n == nullptr ? nullptr : os::strdup(n)),\n@@ -79,1 +79,1 @@\n-    _next(NULL) {}\n+    _next(nullptr) {}\n@@ -82,1 +82,1 @@\n-    if (_name != NULL) {\n+    if (_name != nullptr) {\n@@ -95,1 +95,1 @@\n-    assert(_next == NULL || next == NULL, \"already set\");\n+    assert(_next == nullptr || next == nullptr, \"already set\");\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-        Node* bol = clone_skeleton_predicate_bool(m, NULL, NULL, m->in(0));\n+        Node* bol = clone_skeleton_predicate_bool(m, nullptr, nullptr, m->in(0));\n@@ -168,1 +168,1 @@\n-  const Type* rtype = NULL;\n+  const Type* rtype = nullptr;\n@@ -178,1 +178,1 @@\n-    if (rtype != NULL) x->as_Type()->set_type(rtype);\n+    if (rtype != nullptr) x->as_Type()->set_type(rtype);\n@@ -554,1 +554,1 @@\n-  if (use_blk == NULL) {        \/\/ He's dead, Jim\n+  if (use_blk == nullptr) {        \/\/ He's dead, Jim\n@@ -632,1 +632,1 @@\n-        if (_nodes[m->_idx] == NULL) {\n+        if (_nodes[m->_idx] == nullptr) {\n@@ -655,3 +655,3 @@\n-  Node *old_false = NULL, *old_true = NULL;\n-  RegionNode* new_false = NULL;\n-  RegionNode* new_true = NULL;\n+  Node *old_false = nullptr, *old_true = nullptr;\n+  RegionNode* new_false = nullptr;\n+  RegionNode* new_true = nullptr;\n@@ -693,1 +693,1 @@\n-  region->set_req(0, NULL);        \/\/ Break the self-cycle. Required for lazy_update to work on region\n+  region->set_req(0, nullptr);        \/\/ Break the self-cycle. Required for lazy_update to work on region\n@@ -738,1 +738,1 @@\n-  if (new_false_region != NULL) {\n+  if (new_false_region != nullptr) {\n@@ -741,1 +741,1 @@\n-  if (new_true_region != NULL) {\n+  if (new_true_region != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    _begin(NULL),\n+    _begin(nullptr),\n@@ -118,1 +118,1 @@\n-      if (m != NULL &&\n+      if (m != nullptr &&\n@@ -130,1 +130,1 @@\n-    \/\/ (Proj == NULL) ? \"null\":\"CastPP(Proj)#NotNULL\n+    \/\/ (Proj == nullptr) ? \"null\":\"CastPP(Proj)#Notnull\n@@ -190,1 +190,1 @@\n-    if (log != NULL) {\n+    if (log != nullptr) {\n@@ -193,1 +193,1 @@\n-      while (p != NULL) {\n+      while (p != nullptr) {\n@@ -208,1 +208,1 @@\n-      const TypePtr* no_memory_effects = NULL;\n+      const TypePtr* no_memory_effects = nullptr;\n@@ -319,1 +319,1 @@\n-  if (projs->fallthrough_catchproj != NULL) {\n+  if (projs->fallthrough_catchproj != nullptr) {\n@@ -322,1 +322,1 @@\n-  if (projs->fallthrough_memproj != NULL) {\n+  if (projs->fallthrough_memproj != nullptr) {\n@@ -325,1 +325,1 @@\n-  if (projs->catchall_memproj != NULL) {\n+  if (projs->catchall_memproj != nullptr) {\n@@ -328,1 +328,1 @@\n-  if (projs->fallthrough_ioproj != NULL) {\n+  if (projs->fallthrough_ioproj != nullptr) {\n@@ -331,1 +331,1 @@\n-  if (projs->catchall_ioproj != NULL) {\n+  if (projs->catchall_ioproj != nullptr) {\n@@ -334,1 +334,1 @@\n-  if (projs->catchall_catchproj != NULL) {\n+  if (projs->catchall_catchproj != nullptr) {\n@@ -346,1 +346,1 @@\n-  if (projs->resproj[0] != NULL) {\n+  if (projs->resproj[0] != nullptr) {\n@@ -360,1 +360,1 @@\n-  if (ctrl_proj != NULL) {\n+  if (ctrl_proj != nullptr) {\n@@ -364,1 +364,1 @@\n-  if (mem_proj != NULL) {\n+  if (mem_proj != nullptr) {\n@@ -381,1 +381,1 @@\n-    if (n != NULL && !_visited.test_set(n->_idx)) {\n+    if (n != nullptr && !_visited.test_set(n->_idx)) {\n@@ -394,1 +394,1 @@\n-    if (ctrl->in(0) != NULL && !_visited.test_set(ctrl->in(0)->_idx)) {\n+    if (ctrl->in(0) != nullptr && !_visited.test_set(ctrl->in(0)->_idx)) {\n@@ -399,1 +399,1 @@\n-        if (ctrl->in(i) != NULL && !_visited.test_set(ctrl->in(i)->_idx)) {\n+        if (ctrl->in(i) != nullptr && !_visited.test_set(ctrl->in(i)->_idx)) {\n@@ -447,1 +447,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -457,1 +457,1 @@\n-  AllocateNode* alloc = NULL;\n+  AllocateNode* alloc = nullptr;\n@@ -467,1 +467,1 @@\n-    if (cnode == NULL) {\n+    if (cnode == nullptr) {\n@@ -469,1 +469,1 @@\n-      if (alloc == NULL) {\n+      if (alloc == nullptr) {\n@@ -474,1 +474,1 @@\n-      if (result == NULL || !result->is_CheckCastPP() || alloc->in(TypeFunc::Memory)->is_top()) {\n+      if (result == nullptr || !result->is_CheckCastPP() || alloc->in(TypeFunc::Memory)->is_top()) {\n@@ -484,1 +484,1 @@\n-      Node* constructor = NULL;\n+      Node* constructor = nullptr;\n@@ -487,2 +487,2 @@\n-        if (use != NULL &&\n-            use->method() != NULL &&\n+        if (use != nullptr &&\n+            use->method() != nullptr &&\n@@ -499,1 +499,1 @@\n-              assert(use->in(TypeFunc::Parms + 1) != NULL, \"what?\");\n+              assert(use->in(TypeFunc::Parms + 1) != nullptr, \"what?\");\n@@ -510,1 +510,1 @@\n-                return NULL;\n+                return nullptr;\n@@ -517,1 +517,1 @@\n-              assert(parm != NULL, \"must exist\");\n+              assert(parm != nullptr, \"must exist\");\n@@ -530,1 +530,1 @@\n-                return NULL;\n+                return nullptr;\n@@ -549,1 +549,1 @@\n-      if (constructor == NULL) {\n+      if (constructor == nullptr) {\n@@ -570,1 +570,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -572,1 +572,1 @@\n-    } else if (cnode->method() == NULL) {\n+    } else if (cnode->method() == nullptr) {\n@@ -582,1 +582,1 @@\n-      if (arg == NULL || arg->is_top()) {\n+      if (arg == nullptr || arg->is_top()) {\n@@ -598,1 +598,1 @@\n-          if (csj->method() != NULL &&\n+          if (csj->method() != nullptr &&\n@@ -630,1 +630,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -653,1 +653,1 @@\n-    if (sc != NULL) {\n+    if (sc != nullptr) {\n@@ -781,1 +781,1 @@\n-        assert(mem != NULL, \"calls should have memory edge\");\n+        assert(mem != nullptr, \"calls should have memory edge\");\n@@ -838,2 +838,2 @@\n-        IfNode* iff = NULL;\n-        RegionNode* copy = NULL;\n+        IfNode* iff = nullptr;\n+        RegionNode* copy = nullptr;\n@@ -849,2 +849,2 @@\n-                     ctrl->in(1) != NULL && ctrl->in(1)->is_Proj() &&\n-                     ctrl->in(2) != NULL && ctrl->in(2)->is_Proj() &&\n+                     ctrl->in(1) != nullptr && ctrl->in(1)->is_Proj() &&\n+                     ctrl->in(2) != nullptr && ctrl->in(2)->is_Proj() &&\n@@ -852,1 +852,1 @@\n-                     ctrl->in(1)->in(0) != NULL && ctrl->in(1)->in(0)->is_If(),\n+                     ctrl->in(1)->in(0) != nullptr && ctrl->in(1)->in(0)->is_If(),\n@@ -936,1 +936,1 @@\n-      if (catchproj != NULL) {\n+      if (catchproj != nullptr) {\n@@ -957,1 +957,1 @@\n-      if (b == NULL) {\n+      if (b == nullptr) {\n@@ -978,1 +978,1 @@\n-        \/\/ NULL check of the return value of the append\n+        \/\/ null check of the return value of the append\n@@ -982,1 +982,1 @@\n-          if (call != NULL && call->_name != NULL && strcmp(call->_name, \"uncommon_trap\") == 0) {\n+          if (call != nullptr && call->_name != nullptr && strcmp(call->_name, \"uncommon_trap\") == 0) {\n@@ -996,1 +996,1 @@\n-        if (call != NULL && call->_name != NULL && strcmp(call->_name, \"uncommon_trap\") == 0) {\n+        if (call != nullptr && call->_name != nullptr && strcmp(call->_name, \"uncommon_trap\") == 0) {\n@@ -1037,1 +1037,1 @@\n-      if (copy != NULL) {\n+      if (copy != nullptr) {\n@@ -1042,2 +1042,2 @@\n-          ptr->in(1) != NULL && ptr->in(1)->is_Proj() &&\n-          ptr->in(2) != NULL && ptr->in(2)->is_Proj() &&\n+          ptr->in(1) != nullptr && ptr->in(1)->is_Proj() &&\n+          ptr->in(2) != nullptr && ptr->in(2)->is_Proj() &&\n@@ -1045,1 +1045,1 @@\n-          ptr->in(1)->in(0) != NULL && ptr->in(1)->in(0)->is_If()) {\n+          ptr->in(1)->in(0) != nullptr && ptr->in(1)->in(0)->is_If()) {\n@@ -1098,1 +1098,1 @@\n-    if (cnode != NULL) {\n+    if (cnode != nullptr) {\n@@ -1101,2 +1101,2 @@\n-    Node* result = cnode != NULL ? cnode->proj_out_or_null(TypeFunc::Parms) : NULL;\n-    if (result != NULL && result != final_result) {\n+    Node* result = cnode != nullptr ? cnode->proj_out_or_null(TypeFunc::Parms) : nullptr;\n+    if (result != nullptr && result != final_result) {\n@@ -1107,1 +1107,1 @@\n-  Node* last_result = NULL;\n+  Node* last_result = nullptr;\n@@ -1453,1 +1453,1 @@\n-  Node* extra = NULL;\n+  Node* extra = nullptr;\n@@ -1630,1 +1630,1 @@\n-  bool dcon = (dst_coder != NULL) && dst_coder->is_Con();\n+  bool dcon = (dst_coder != nullptr) && dst_coder->is_Con();\n@@ -1666,1 +1666,1 @@\n-  if (ideal != NULL) {\n+  if (ideal != nullptr) {\n@@ -1670,1 +1670,1 @@\n-  Node* byte_array = NULL;\n+  Node* byte_array = nullptr;\n@@ -1687,1 +1687,1 @@\n-  if (ideal != NULL) {\n+  if (ideal != nullptr) {\n@@ -1837,2 +1837,2 @@\n-        Node* count = NULL;\n-        Node* arg_coder = NULL;\n+        Node* count = nullptr;\n+        Node* arg_coder = nullptr;\n@@ -1896,1 +1896,1 @@\n-        string_sizes->init_req(argi, NULL);\n+        string_sizes->init_req(argi, nullptr);\n@@ -1959,1 +1959,1 @@\n-    Node* dst_array = NULL;\n+    Node* dst_array = nullptr;\n@@ -1968,1 +1968,1 @@\n-      dst_array = allocate_byte_array(kit, NULL, __ LShiftI(length, coder));\n+      dst_array = allocate_byte_array(kit, nullptr, __ LShiftI(length, coder));\n@@ -2012,1 +2012,1 @@\n-    assert(AllocateNode::Ideal_allocation(result, _gvn) != NULL, \"should be newly allocated\");\n+    assert(AllocateNode::Ideal_allocation(result, _gvn) != nullptr, \"should be newly allocated\");\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":67,"deletions":67,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-#include \"utilities\/moveBits.hpp\"\n+#include \"utilities\/reverse_bits.hpp\"\n@@ -98,1 +98,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -103,1 +103,1 @@\n-  if (t != NULL) {\n+  if (t != nullptr) {\n@@ -121,1 +121,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -174,1 +174,1 @@\n-  if( t2 == Type::TOP ) return NULL;\n+  if( t2 == Type::TOP ) return nullptr;\n@@ -215,1 +215,1 @@\n-  if( t1 == Type::TOP ) return NULL;\n+  if( t1 == Type::TOP ) return nullptr;\n@@ -275,3 +275,3 @@\n-    Node* sub_in1 = NULL;\n-    Node* sub_in2 = NULL;\n-    Node* mul_in = NULL;\n+    Node* sub_in1 = nullptr;\n+    Node* sub_in2 = nullptr;\n+    Node* mul_in = nullptr;\n@@ -301,1 +301,1 @@\n-    if (mul_in != NULL) {\n+    if (mul_in != nullptr) {\n@@ -319,1 +319,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -359,1 +359,1 @@\n-  if( phase->type( in2 ) == Type::TOP ) return NULL;\n+  if( phase->type( in2 ) == Type::TOP ) return nullptr;\n@@ -399,1 +399,1 @@\n-  if( t1 == Type::TOP ) return NULL;\n+  if( t1 == Type::TOP ) return nullptr;\n@@ -452,3 +452,3 @@\n-    Node* sub_in1 = NULL;\n-    Node* sub_in2 = NULL;\n-    Node* mul_in = NULL;\n+    Node* sub_in1 = nullptr;\n+    Node* sub_in2 = nullptr;\n+    Node* mul_in = nullptr;\n@@ -478,1 +478,1 @@\n-    if (mul_in != NULL) {\n+    if (mul_in != nullptr) {\n@@ -496,1 +496,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -560,1 +560,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -595,1 +595,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -640,1 +640,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -680,1 +680,1 @@\n-  if (in1 != NULL && in2 != NULL) {\n+  if (in1 != nullptr && in2 != nullptr) {\n@@ -682,1 +682,1 @@\n-    Node* cmp = NULL;\n+    Node* cmp = nullptr;\n@@ -689,1 +689,1 @@\n-      assert(cmp == NULL, \"A cmp with 2 OpaqueZeroTripGuard inputs\");\n+      assert(cmp == nullptr, \"A cmp with 2 OpaqueZeroTripGuard inputs\");\n@@ -693,1 +693,1 @@\n-    if (cmp != NULL) {\n+    if (cmp != nullptr) {\n@@ -772,1 +772,1 @@\n-  if (t != NULL) {\n+  if (t != nullptr) {\n@@ -875,1 +875,1 @@\n-  return NULL;                  \/\/ No change\n+  return nullptr;                  \/\/ No change\n@@ -893,1 +893,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1024,3 +1024,3 @@\n-      AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, NULL);\n-      AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, NULL);\n-      if (MemNode::detect_ptr_independence(in1, alloc1, in2, alloc2, NULL)) {\n+      AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, nullptr);\n+      AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, nullptr);\n+      if (MemNode::detect_ptr_independence(in1, alloc1, in2, alloc2, nullptr)) {\n@@ -1091,1 +1091,1 @@\n-  \/\/   or NULL if not matching.\n+  \/\/   or null if not matching.\n@@ -1095,1 +1095,1 @@\n-  if (n->Opcode() != Op_LoadP) return NULL;\n+  if (n->Opcode() != Op_LoadP) return nullptr;\n@@ -1098,1 +1098,1 @@\n-  if (!tp || tp->instance_klass() != phase->C->env()->Class_klass()) return NULL;\n+  if (!tp || tp->instance_klass() != phase->C->env()->Class_klass()) return nullptr;\n@@ -1102,1 +1102,1 @@\n-  if (adr->Opcode() != Op_LoadP || !phase->type(adr)->isa_rawptr()) return NULL;\n+  if (adr->Opcode() != Op_LoadP || !phase->type(adr)->isa_rawptr()) return nullptr;\n@@ -1107,1 +1107,1 @@\n-  if (k == NULL)  return NULL;\n+  if (k == nullptr)  return nullptr;\n@@ -1109,1 +1109,1 @@\n-  if (!tkp || off != in_bytes(Klass::java_mirror_offset())) return NULL;\n+  if (!tkp || off != in_bytes(Klass::java_mirror_offset())) return nullptr;\n@@ -1117,2 +1117,2 @@\n-  \/\/ otherwise return NULL\n-  if (!n->is_Con()) return NULL;\n+  \/\/ otherwise return null\n+  if (!n->is_Con()) return nullptr;\n@@ -1121,1 +1121,1 @@\n-  if (!tp) return NULL;\n+  if (!tp) return nullptr;\n@@ -1124,1 +1124,1 @@\n-  \/\/ TypeInstPtr::java_mirror_type() returns non-NULL for compile-\n+  \/\/ TypeInstPtr::java_mirror_type() returns non-null for compile-\n@@ -1126,1 +1126,1 @@\n-  if (!mirror_type) return NULL;\n+  if (!mirror_type) return nullptr;\n@@ -1129,1 +1129,1 @@\n-  \/\/ Return a ConP(NULL) node for this case.\n+  \/\/ Return a ConP(null) node for this case.\n@@ -1173,1 +1173,1 @@\n-      Node* rhs = (k2 != NULL) ? k2 : conk2;\n+      Node* rhs = (k2 != nullptr) ? k2 : conk2;\n@@ -1182,2 +1182,2 @@\n-  if (t2 == NULL || !t2->klass_is_exact())\n-    return NULL;\n+  if (t2 == nullptr || !t2->klass_is_exact())\n+    return nullptr;\n@@ -1192,1 +1192,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1194,1 +1194,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1199,2 +1199,2 @@\n-  if (ldk2 == NULL)\n-    return NULL;\n+  if (ldk2 == nullptr)\n+    return nullptr;\n@@ -1217,1 +1217,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1219,1 +1219,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1223,1 +1223,1 @@\n-    return NULL;                \/\/ Might be element-klass loading from array klass\n+    return nullptr;                \/\/ Might be element-klass loading from array klass\n@@ -1249,1 +1249,1 @@\n-    if (ik->has_subklass() || ik->is_interface())  return NULL;\n+    if (ik->has_subklass() || ik->is_interface())  return nullptr;\n@@ -1273,1 +1273,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1373,1 +1373,1 @@\n-  return NULL;                  \/\/ No change\n+  return nullptr;                  \/\/ No change\n@@ -1501,1 +1501,1 @@\n-  Node* cmov = CMoveNode::make(NULL, this,\n+  Node* cmov = CMoveNode::make(nullptr, this,\n@@ -1523,2 +1523,2 @@\n-    if ((r0 != NULL) && (r0 != TypeInt::INT) &&\n-        (r1 != NULL) && (r1 != TypeInt::INT) &&\n+    if ((r0 != nullptr) && (r0 != TypeInt::INT) &&\n+        (r1 != nullptr) && (r1 != TypeInt::INT) &&\n@@ -1558,1 +1558,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1563,1 +1563,1 @@\n-  return n != NULL &&\n+  return n != nullptr &&\n@@ -1565,1 +1565,1 @@\n-         n->in(0) != NULL &&\n+         n->in(0) != nullptr &&\n@@ -1575,1 +1575,1 @@\n-  if( !cmp->is_Sub() ) return NULL;\n+  if( !cmp->is_Sub() ) return nullptr;\n@@ -1579,1 +1579,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1583,1 +1583,1 @@\n-  if( !cmp1 ) return NULL;\n+  if( !cmp1 ) return nullptr;\n@@ -1586,1 +1586,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1691,1 +1691,1 @@\n-  if (cmp2_type == NULL)  return NULL;\n+  if (cmp2_type == nullptr)  return nullptr;\n@@ -1708,1 +1708,1 @@\n-    Node* bound = NULL;\n+    Node* bound = nullptr;\n@@ -1804,1 +1804,1 @@\n-      cmp1->in(2) != NULL &&\n+      cmp1->in(2) != nullptr &&\n@@ -1877,1 +1877,1 @@\n-  \/\/      return NULL;\n+  \/\/      return nullptr;\n@@ -1882,1 +1882,1 @@\n-  \/\/    if( !phase->allow_progress() ) return NULL;\n+  \/\/    if( !phase->allow_progress() ) return nullptr;\n@@ -1888,1 +1888,1 @@\n-  \/\/    if( cmp->Opcode() == Op_CmpU ) return NULL;\n+  \/\/    if( cmp->Opcode() == Op_CmpU ) return nullptr;\n@@ -1991,1 +1991,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":73,"deletions":73,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,1 +255,1 @@\n-  virtual const Type *sub( const Type *, const Type * ) const { ShouldNotReachHere(); return NULL; }\n+  virtual const Type *sub( const Type *, const Type * ) const { ShouldNotReachHere(); return nullptr; }\n@@ -283,1 +283,1 @@\n-  virtual const Type *sub( const Type *, const Type * ) const { ShouldNotReachHere(); return NULL; }\n+  virtual const Type *sub( const Type *, const Type * ) const { ShouldNotReachHere(); return nullptr; }\n@@ -361,1 +361,1 @@\n-  BoolNode(Node *cc, BoolTest::mask t): Node(NULL,cc), _test(t) {\n+  BoolNode(Node *cc, BoolTest::mask t): Node(nullptr,cc), _test(t) {\n@@ -537,1 +537,1 @@\n-    if (c != NULL) {\n+    if (c != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  if (subk != NULL) {\n+  if (subk != nullptr) {\n@@ -91,3 +91,3 @@\n-  if (obj_or_subklass == NULL ||\n-      superklass == NULL) {\n-    return NULL;\n+  if (obj_or_subklass == nullptr ||\n+      superklass == nullptr) {\n+    return nullptr;\n@@ -101,1 +101,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -104,1 +104,1 @@\n-  Node* addr = NULL;\n+  Node* addr = nullptr;\n@@ -106,1 +106,1 @@\n-    if (obj_or_subklass->in(1) != NULL &&\n+    if (obj_or_subklass->in(1) != nullptr &&\n@@ -114,1 +114,1 @@\n-  if (addr != NULL) {\n+  if (addr != nullptr) {\n@@ -117,1 +117,1 @@\n-    if (con == oopDesc::klass_offset_in_bytes() && obj != NULL) {\n+    if (con == oopDesc::klass_offset_in_bytes() && obj != nullptr) {\n@@ -126,1 +126,1 @@\n-  if (allocated_klass != NULL) {\n+  if (allocated_klass != nullptr) {\n@@ -136,1 +136,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -190,1 +190,1 @@\n-  if (super_t->singleton() && subk != NULL) {\n+  if (super_t->singleton() && subk != nullptr) {\n@@ -198,1 +198,1 @@\n-        Node* chk_off = phase->transform(new LoadINode(NULL, C->immutable_memory(), p1, phase->type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered));\n+        Node* chk_off = phase->transform(new LoadINode(nullptr, C->immutable_memory(), p1, phase->type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered));\n@@ -210,1 +210,1 @@\n-          Node* nkls = phase->transform(LoadKlassNode::make(*phase, NULL, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n+          Node* nkls = phase->transform(LoadKlassNode::make(*phase, nullptr, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -230,1 +230,1 @@\n-  Node* subklass = NULL;\n+  Node* subklass = nullptr;\n@@ -233,1 +233,1 @@\n-    subklass  = phase->transform(LoadKlassNode::make(*phase, NULL, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+    subklass  = phase->transform(LoadKlassNode::make(*phase, nullptr, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-Dict* Type::_shared_type_dict = NULL;\n+Dict* Type::_shared_type_dict = nullptr;\n@@ -172,2 +172,2 @@\n-const TypePtr::InterfaceSet* TypeAryPtr::_array_interfaces = NULL;\n-const TypePtr::InterfaceSet* TypeAryKlassPtr::_array_interfaces = NULL;\n+const TypePtr::InterfaceSet* TypeAryPtr::_array_interfaces = nullptr;\n+const TypePtr::InterfaceSet* TypeAryKlassPtr::_array_interfaces = nullptr;\n@@ -189,2 +189,2 @@\n-  if (type == NULL) {\n-    return NULL;\n+  if (type == nullptr) {\n+    return nullptr;\n@@ -214,1 +214,1 @@\n-\/\/ Otherwise or if the arrays have different dimensions, return NULL.\n+\/\/ Otherwise or if the arrays have different dimensions, return null.\n@@ -218,4 +218,4 @@\n-  if (e1) *e1 = NULL;\n-  if (e2) *e2 = NULL;\n-  const TypeAryPtr* a1tap = (a1 == NULL) ? NULL : a1->isa_aryptr();\n-  const TypeAryPtr* a2tap = (a2 == NULL) ? NULL : a2->isa_aryptr();\n+  if (e1) *e1 = nullptr;\n+  if (e2) *e2 = nullptr;\n+  const TypeAryPtr* a1tap = (a1 == nullptr) ? nullptr : a1->isa_aryptr();\n+  const TypeAryPtr* a2tap = (a2 == nullptr) ? nullptr : a2->isa_aryptr();\n@@ -223,1 +223,1 @@\n-  if (a1tap != NULL && a2tap != NULL) {\n+  if (a1tap != nullptr && a2tap != nullptr) {\n@@ -308,1 +308,1 @@\n-        const Type* con_type = NULL;\n+        const Type* con_type = nullptr;\n@@ -332,1 +332,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -335,1 +335,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -376,1 +376,1 @@\n-    return NULL; \/\/ wrong offset\n+    return nullptr; \/\/ wrong offset\n@@ -388,1 +388,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -394,1 +394,1 @@\n-  if (type != NULL && type->is_instance_klass() && off >= InstanceMirrorKlass::offset_of_static_fields()) {\n+  if (type != nullptr && type->is_instance_klass() && off >= InstanceMirrorKlass::offset_of_static_fields()) {\n@@ -401,2 +401,2 @@\n-  if (field == NULL) {\n-    return NULL; \/\/ Wrong offset\n+  if (field == nullptr) {\n+    return nullptr; \/\/ Wrong offset\n@@ -410,1 +410,1 @@\n-    return NULL; \/\/ Non-constant field\n+    return nullptr; \/\/ Non-constant field\n@@ -416,1 +416,1 @@\n-  } else if (holder != NULL) {\n+  } else if (holder != nullptr) {\n@@ -424,1 +424,1 @@\n-    return NULL; \/\/ Not a constant\n+    return nullptr; \/\/ Not a constant\n@@ -439,1 +439,1 @@\n-  if (con_type != NULL && field->is_call_site_target()) {\n+  if (con_type != nullptr && field->is_call_site_target()) {\n@@ -611,1 +611,1 @@\n-  TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, Offset::bottom);\n+  TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, nullptr, Offset::bottom);\n@@ -634,1 +634,1 @@\n-  TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL \/* current->env()->Object_klass() *\/, false, Offset(arrayOopDesc::length_offset_in_bytes()));\n+  TypeAryPtr::RANGE   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), nullptr \/* current->env()->Object_klass() *\/, false, Offset(arrayOopDesc::length_offset_in_bytes()));\n@@ -636,1 +636,1 @@\n-  TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n+  TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n@@ -646,1 +646,1 @@\n-    TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n+    TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), nullptr \/*ciArrayKlass::make(o)*\/,  false,  Offset::bottom);\n@@ -655,1 +655,1 @@\n-  TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true), NULL, false, Offset::bottom);\n+  TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true), nullptr, false, Offset::bottom);\n@@ -657,2 +657,2 @@\n-  \/\/ Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.\n-  TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;\n+  \/\/ Nobody should ask _array_body_type[T_NARROWOOP]. Use null as assert.\n+  TypeAryPtr::_array_body_type[T_NARROWOOP] = nullptr;\n@@ -733,1 +733,1 @@\n-  _zero_type[T_CONFLICT]= NULL;\n+  _zero_type[T_CONFLICT]= nullptr;\n@@ -768,1 +768,1 @@\n-  current->set_type_dict(NULL);\n+  current->set_type_dict(nullptr);\n@@ -773,1 +773,1 @@\n-  assert(current->type_arena() != NULL, \"must have created type arena\");\n+  assert(current->type_arena() != nullptr, \"must have created type arena\");\n@@ -775,1 +775,1 @@\n-  if (_shared_type_dict == NULL) {\n+  if (_shared_type_dict == nullptr) {\n@@ -866,1 +866,1 @@\n-            _in1(NULL), _in2(NULL), _res(NULL) {\n+            _in1(nullptr), _in2(nullptr), _res(nullptr) {\n@@ -886,1 +886,1 @@\n-          assert(v1._res == v2._res || v1._res == NULL || v2._res == NULL, \"same inputs should lead to same result\");\n+          assert(v1._res == v2._res || v1._res == nullptr || v2._res == nullptr, \"same inputs should lead to same result\");\n@@ -936,1 +936,1 @@\n-    const VerifyMeetResultEntry meet(t1, t2, NULL);\n+    const VerifyMeetResultEntry meet(t1, t2, nullptr);\n@@ -938,1 +938,1 @@\n-    const Type* res = NULL;\n+    const Type* res = nullptr;\n@@ -965,1 +965,1 @@\n-  assert(Compile::current()->_type_verify == NULL || Compile::current()->_type_verify->empty_cache(), \"cache should have been discarded\");\n+  assert(Compile::current()->_type_verify == nullptr || Compile::current()->_type_verify->empty_cache(), \"cache should have been discarded\");\n@@ -973,1 +973,1 @@\n-    if (C->_type_verify == NULL) {\n+    if (C->_type_verify == nullptr) {\n@@ -1778,1 +1778,1 @@\n-  if (old == NULL)  return this;\n+  if (old == nullptr)  return this;\n@@ -1780,1 +1780,1 @@\n-  if (ot == NULL)  return this;\n+  if (ot == nullptr)  return this;\n@@ -1809,1 +1809,1 @@\n-  if (ft == NULL || ft->empty())\n+  if (ft == nullptr || ft->empty())\n@@ -2044,1 +2044,1 @@\n-  if (old == NULL)  return this;\n+  if (old == nullptr)  return this;\n@@ -2046,1 +2046,1 @@\n-  if (ot == NULL)  return this;\n+  if (ot == nullptr)  return this;\n@@ -2075,1 +2075,1 @@\n-  if (ft == NULL || ft->empty())\n+  if (ft == nullptr || ft->empty())\n@@ -2109,1 +2109,1 @@\n-    if (n >= x + 10000)  return NULL;\n+    if (n >= x + 10000)  return nullptr;\n@@ -2112,1 +2112,1 @@\n-    if (n <= x - 10000)  return NULL;\n+    if (n <= x - 10000)  return nullptr;\n@@ -2130,1 +2130,1 @@\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, buf_size, n)) != NULL)\n+  else if ((str = longnamenear(max_juint, \"maxuint\", buf, buf_size, n)) != nullptr)\n@@ -2132,1 +2132,1 @@\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, buf_size, n)) != NULL)\n+  else if ((str = longnamenear(max_jint, \"maxint\", buf, buf_size, n)) != nullptr)\n@@ -2134,1 +2134,1 @@\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, buf_size, n)) != NULL)\n+  else if ((str = longnamenear(min_jint, \"minint\", buf, buf_size, n)) != nullptr)\n@@ -2257,1 +2257,1 @@\n-    assert(method->get_sig_cc() != NULL, \"Should have scalarized signature\");\n+    assert(method->get_sig_cc() != nullptr, \"Should have scalarized signature\");\n@@ -2580,1 +2580,1 @@\n-  const TypeOopPtr*  toop = NULL;\n+  const TypeOopPtr*  toop = nullptr;\n@@ -2615,7 +2615,7 @@\n-const TypeVect *TypeVect::VECTA = NULL; \/\/ vector length agnostic\n-const TypeVect *TypeVect::VECTS = NULL; \/\/  32-bit vectors\n-const TypeVect *TypeVect::VECTD = NULL; \/\/  64-bit vectors\n-const TypeVect *TypeVect::VECTX = NULL; \/\/ 128-bit vectors\n-const TypeVect *TypeVect::VECTY = NULL; \/\/ 256-bit vectors\n-const TypeVect *TypeVect::VECTZ = NULL; \/\/ 512-bit vectors\n-const TypeVect *TypeVect::VECTMASK = NULL; \/\/ predicate\/mask vector\n+const TypeVect *TypeVect::VECTA = nullptr; \/\/ vector length agnostic\n+const TypeVect *TypeVect::VECTS = nullptr; \/\/  32-bit vectors\n+const TypeVect *TypeVect::VECTD = nullptr; \/\/  64-bit vectors\n+const TypeVect *TypeVect::VECTX = nullptr; \/\/ 128-bit vectors\n+const TypeVect *TypeVect::VECTY = nullptr; \/\/ 256-bit vectors\n+const TypeVect *TypeVect::VECTZ = nullptr; \/\/ 512-bit vectors\n+const TypeVect *TypeVect::VECTMASK = nullptr; \/\/ predicate\/mask vector\n@@ -2649,1 +2649,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2819,1 +2819,1 @@\n-  if (res->isa_ptr() == NULL) {\n+  if (res->isa_ptr() == nullptr) {\n@@ -2824,2 +2824,2 @@\n-  if (res_ptr->speculative() != NULL) {\n-    \/\/ type->speculative() == NULL means that speculation is no better\n+  if (res_ptr->speculative() != nullptr) {\n+    \/\/ type->speculative() is null means that speculation is no better\n@@ -2830,1 +2830,1 @@\n-    \/\/ type and set speculative to NULL if it is the case.\n+    \/\/ type and set speculative to null if it is the case.\n@@ -2933,1 +2933,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -2937,1 +2937,1 @@\n-  return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);\n+  return make(AnyPtr, _ptr, _offset, nullptr, _inline_depth);\n@@ -2945,1 +2945,1 @@\n-  if (speculative() == NULL) {\n+  if (speculative() == nullptr) {\n@@ -2962,1 +2962,1 @@\n-      (spec_oopptr == NULL || !spec_oopptr->klass_is_exact())) {\n+      (spec_oopptr == nullptr || !spec_oopptr->klass_is_exact())) {\n@@ -2972,2 +2972,2 @@\n-  if (_speculative == NULL) {\n-    return NULL;\n+  if (_speculative == nullptr) {\n+    return nullptr;\n@@ -2984,2 +2984,2 @@\n-  bool this_has_spec = (_speculative != NULL);\n-  bool other_has_spec = (other->speculative() != NULL);\n+  bool this_has_spec = (_speculative != nullptr);\n+  bool other_has_spec = (other->speculative() != nullptr);\n@@ -2988,1 +2988,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3033,1 +3033,1 @@\n-  if (_speculative == NULL || other->speculative() == NULL) {\n+  if (_speculative == nullptr || other->speculative() == nullptr) {\n@@ -3048,1 +3048,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -3061,2 +3061,2 @@\n-  if (_speculative == NULL) {\n-    return NULL;\n+  if (_speculative == nullptr) {\n+    return nullptr;\n@@ -3068,2 +3068,2 @@\n-  if (_speculative == NULL) {\n-    return NULL;\n+  if (_speculative == nullptr) {\n+    return nullptr;\n@@ -3078,1 +3078,1 @@\n-  if (_speculative != NULL && _speculative->isa_oopptr()) {\n+  if (_speculative != nullptr && _speculative->isa_oopptr()) {\n@@ -3084,1 +3084,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3091,1 +3091,1 @@\n-  if (_speculative != NULL) {\n+  if (_speculative != nullptr) {\n@@ -3099,1 +3099,1 @@\n-  if (_speculative != NULL) {\n+  if (_speculative != nullptr) {\n@@ -3112,1 +3112,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3127,1 +3127,1 @@\n-  if (exact_kls == NULL) {\n+  if (exact_kls == nullptr) {\n@@ -3134,1 +3134,1 @@\n-  if (speculative_type() == NULL) {\n+  if (speculative_type() == nullptr) {\n@@ -3177,1 +3177,1 @@\n-  if (ptr_kind == ProfileAlwaysNull && speculative() != NULL && speculative()->isa_oopptr()) {\n+  if (ptr_kind == ProfileAlwaysNull && speculative() != nullptr && speculative()->isa_oopptr()) {\n@@ -3185,1 +3185,1 @@\n-  \"TopPTR\",\"AnyNull\",\"Constant\",\"NULL\",\"NotNull\",\"BotPTR\"\n+  \"TopPTR\",\"AnyNull\",\"Constant\",\"null\",\"NotNull\",\"BotPTR\"\n@@ -3190,1 +3190,1 @@\n-  if( _ptr == Null ) st->print(\"NULL\");\n+  if( _ptr == Null ) st->print(\"null\");\n@@ -3201,1 +3201,1 @@\n-  if (_speculative != NULL) {\n+  if (_speculative != nullptr) {\n@@ -3242,1 +3242,1 @@\n-  assert( ptr != Null, \"Use TypePtr for NULL\" );\n+  assert( ptr != Null, \"Use TypePtr for null\" );\n@@ -3247,1 +3247,1 @@\n-  assert( bits, \"Use TypePtr for NULL\" );\n+  assert( bits, \"Use TypePtr for null\" );\n@@ -3254,1 +3254,1 @@\n-  assert( ptr != Null, \"Use TypePtr for NULL\" );\n+  assert( ptr != Null, \"Use TypePtr for null\" );\n@@ -3344,1 +3344,1 @@\n-  return NULL;                  \/\/ Lint noise\n+  return nullptr;                  \/\/ Lint noise\n@@ -3375,1 +3375,1 @@\n-        : _list(Compile::current()->type_arena(), 0, 0, NULL),\n+        : _list(Compile::current()->type_arena(), 0, 0, nullptr),\n@@ -3380,1 +3380,1 @@\n-        : _list(Compile::current()->type_arena(), interfaces->length(), 0, NULL),\n+        : _list(Compile::current()->type_arena(), interfaces->length(), 0, nullptr),\n@@ -3567,1 +3567,1 @@\n-    _exact_klass = NULL;\n+    _exact_klass = nullptr;\n@@ -3570,1 +3570,1 @@\n-  ciKlass* res = NULL;\n+  ciKlass* res = nullptr;\n@@ -3574,1 +3574,1 @@\n-      assert(res == NULL, \"\");\n+      assert(res == nullptr, \"\");\n@@ -3622,1 +3622,1 @@\n-    } else if (klass() == NULL) {\n+    } else if (klass() == nullptr) {\n@@ -3634,1 +3634,1 @@\n-        assert(field != NULL, \"missing field\");\n+        assert(field != nullptr, \"missing field\");\n@@ -3655,2 +3655,2 @@\n-          ciField* field = NULL;\n-          if (const_oop() != NULL) {\n+          ciField* field = nullptr;\n+          if (const_oop() != nullptr) {\n@@ -3664,1 +3664,1 @@\n-              if (field != NULL) {\n+              if (field != nullptr) {\n@@ -3677,1 +3677,1 @@\n-          if (field != NULL) {\n+          if (field != nullptr) {\n@@ -3701,1 +3701,1 @@\n-  ciObject* o = NULL;\n+  ciObject* o = nullptr;\n@@ -3732,1 +3732,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -3813,1 +3813,1 @@\n-  assert(const_oop() == NULL,             \"no constants here\");\n+  assert(const_oop() == nullptr,             \"no constants here\");\n@@ -3823,1 +3823,1 @@\n-    assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n+    assert((deps != nullptr) == (C->method() != nullptr && C->method()->code_size() > 0), \"sanity\");\n@@ -3831,1 +3831,1 @@\n-          && deps != NULL && UseUniqueSubclasses) {\n+          && deps != nullptr && UseUniqueSubclasses) {\n@@ -3833,1 +3833,1 @@\n-        if (sub != NULL) {\n+        if (sub != nullptr) {\n@@ -3839,1 +3839,1 @@\n-      if (!klass_is_exact && try_for_exact && deps != NULL &&\n+      if (!klass_is_exact && try_for_exact && deps != nullptr &&\n@@ -3847,1 +3847,1 @@\n-    return TypeInstPtr::make(TypePtr::BotPTR, klass, interfaces, klass_is_exact, NULL, Offset(0));\n+    return TypeInstPtr::make(TypePtr::BotPTR, klass, interfaces, klass_is_exact, nullptr, Offset(0));\n@@ -3870,1 +3870,1 @@\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, NULL, xk, Offset(0));\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, nullptr, xk, Offset(0));\n@@ -3889,1 +3889,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -3906,1 +3906,1 @@\n-      return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, Offset(0));\n+      return TypeInstPtr::make(TypePtr::NotNull, klass, true, nullptr, Offset(0));\n@@ -3920,1 +3920,1 @@\n-    \/\/ slam NULLs down in the subarrays.\n+    \/\/ slam nulls down in the subarrays.\n@@ -3953,1 +3953,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4000,1 +4000,1 @@\n-  if (one == NULL || two == NULL) {\n+  if (one == nullptr || two == nullptr) {\n@@ -4054,1 +4054,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -4058,1 +4058,1 @@\n-  return make(_ptr, _offset, _instance_id, NULL, _inline_depth);\n+  return make(_ptr, _offset, _instance_id, nullptr, _inline_depth);\n@@ -4156,1 +4156,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -4166,3 +4166,3 @@\n-  assert(k == NULL || !k->is_loaded() || !k->is_interface(), \"no interface here\");\n-  assert(k != NULL &&\n-         (k->is_loaded() || o == NULL),\n+  assert(k == nullptr || !k->is_loaded() || !k->is_interface(), \"no interface here\");\n+  assert(k != nullptr &&\n+         (k->is_loaded() || o == nullptr),\n@@ -4186,1 +4186,1 @@\n-  \/\/ Either const_oop() is NULL or else ptr is Constant\n+  \/\/ Either const_oop() is null or else ptr is Constant\n@@ -4190,1 +4190,1 @@\n-  assert( ptr != Null, \"NULL pointers are not typed\" );\n+  assert( ptr != Null, \"null pointers are not typed\" );\n@@ -4251,1 +4251,1 @@\n-  assert((const_oop() != NULL), \"should be called only for constant object\");\n+  assert((const_oop() != nullptr), \"should be called only for constant object\");\n@@ -4266,1 +4266,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4274,1 +4274,1 @@\n-  return make(ptr, klass(), _interfaces, klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _flatten_array, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, klass(), _interfaces, klass_is_exact(), ptr == Constant ? const_oop() : nullptr, _offset, _flatten_array, _instance_id, _speculative, _inline_depth);\n@@ -4323,1 +4323,1 @@\n-    else if (loaded->ptr() == TypePtr::AnyNull)  { return make(ptr, unloaded->klass(), interfaces, false, NULL, off, false, instance_id, speculative, depth); }\n+    else if (loaded->ptr() == TypePtr::AnyNull)  { return make(ptr, unloaded->klass(), interfaces, false, nullptr, off, false, instance_id, speculative, depth); }\n@@ -4393,1 +4393,1 @@\n-                  (ptr == Constant ? const_oop() : NULL), offset, flatten_array(), instance_id, speculative, depth);\n+                  (ptr == Constant ? const_oop() : nullptr), offset, flatten_array(), instance_id, speculative, depth);\n@@ -4421,1 +4421,1 @@\n-                  (ptr == Constant ? const_oop() : NULL), offset, flatten_array(), instance_id, speculative, depth);\n+                  (ptr == Constant ? const_oop() : nullptr), offset, flatten_array(), instance_id, speculative, depth);\n@@ -4459,1 +4459,1 @@\n-    ciKlass* res_klass = NULL;\n+    ciKlass* res_klass = nullptr;\n@@ -4488,1 +4488,1 @@\n-      ciObject* o = NULL;             \/\/ Assume not constant when done\n+      ciObject* o = nullptr;             \/\/ Assume not constant when done\n@@ -4492,1 +4492,1 @@\n-        if (this_oop != NULL && tinst_oop != NULL &&\n+        if (this_oop != nullptr && tinst_oop != nullptr &&\n@@ -4570,1 +4570,1 @@\n-  const T* subtype = NULL;\n+  const T* subtype = nullptr;\n@@ -4610,1 +4610,1 @@\n-    \/\/ NotNull if they do (neither constant is NULL; that is a special case\n+    \/\/ NotNull if they do (neither constant is null; that is a special case\n@@ -4639,1 +4639,1 @@\n-  if( const_oop() == NULL )  return NULL;\n+  if( const_oop() == nullptr )  return nullptr;\n@@ -4642,1 +4642,1 @@\n-  if( klass() != ciEnv::current()->Class_klass() )  return NULL;\n+  if( klass() != ciEnv::current()->Class_klass() )  return nullptr;\n@@ -4753,1 +4753,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -4758,1 +4758,1 @@\n-              _instance_id, NULL, _inline_depth);\n+              _instance_id, nullptr, _inline_depth);\n@@ -4833,1 +4833,1 @@\n-  if (other_elem != NULL && this_elem != NULL) {\n+  if (other_elem != nullptr && this_elem != nullptr) {\n@@ -4836,1 +4836,1 @@\n-  if (other_elem == NULL && this_elem == NULL) {\n+  if (other_elem == nullptr && this_elem == nullptr) {\n@@ -4872,1 +4872,1 @@\n-  assert(!(k == NULL && ary->_elem->isa_int()),\n+  assert(!(k == nullptr && ary->_elem->isa_int()),\n@@ -4876,1 +4876,1 @@\n-  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n+  if (k != nullptr && k->is_loaded() && k->is_obj_array_klass() &&\n@@ -4878,1 +4878,1 @@\n-    k = NULL;\n+    k = nullptr;\n@@ -4880,2 +4880,2 @@\n-  if (k != NULL && k->is_flat_array_klass() && !ary->_flat) {\n-    k = NULL;\n+  if (k != nullptr && k->is_flat_array_klass() && !ary->_flat) {\n+    k = nullptr;\n@@ -4883,1 +4883,1 @@\n-  return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, field_offset, instance_id, false, speculative, inline_depth))->hashcons();\n+  return (TypeAryPtr*)(new TypeAryPtr(ptr, nullptr, ary, k, xk, offset, field_offset, instance_id, false, speculative, inline_depth))->hashcons();\n@@ -4890,1 +4890,1 @@\n-  assert(!(k == NULL && ary->_elem->isa_int()),\n+  assert(!(k == nullptr && ary->_elem->isa_int()),\n@@ -4893,1 +4893,1 @@\n-  if (!xk)  xk = (o != NULL) || ary->ary_must_be_exact();\n+  if (!xk)  xk = (o != nullptr) || ary->ary_must_be_exact();\n@@ -4895,1 +4895,1 @@\n-  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n+  if (k != nullptr && k->is_loaded() && k->is_obj_array_klass() &&\n@@ -4897,1 +4897,1 @@\n-    k = NULL;\n+    k = nullptr;\n@@ -4899,2 +4899,2 @@\n-  if (k != NULL && k->is_flat_array_klass() && !ary->_flat) {\n-    k = NULL;\n+  if (k != nullptr && k->is_flat_array_klass() && !ary->_flat) {\n+    k = nullptr;\n@@ -4908,1 +4908,1 @@\n-  return make(ptr, ptr == Constant ? const_oop() : NULL, _ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+  return make(ptr, ptr == Constant ? const_oop() : nullptr, _ary, klass(), klass_is_exact(), _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n@@ -4943,1 +4943,1 @@\n-\/\/ Return NULL if the resulting int type becomes empty.\n+\/\/ Return null if the resulting int type becomes empty.\n@@ -4975,1 +4975,1 @@\n-  assert(new_size != NULL, \"\");\n+  assert(new_size != nullptr, \"\");\n@@ -5013,1 +5013,1 @@\n-    return NULL; \/\/ Inconsistent properties\n+    return nullptr; \/\/ Inconsistent properties\n@@ -5042,1 +5042,1 @@\n-  if (stable_dimension > 1 && elem_ptr != NULL && elem_ptr->isa_aryptr()) {\n+  if (stable_dimension > 1 && elem_ptr != nullptr && elem_ptr->isa_aryptr()) {\n@@ -5057,1 +5057,1 @@\n-  if (elem_ptr != NULL && elem_ptr->isa_aryptr())\n+  if (elem_ptr != nullptr && elem_ptr->isa_aryptr())\n@@ -5066,1 +5066,1 @@\n-  if (etype == NULL)  return this;\n+  if (etype == nullptr)  return this;\n@@ -5138,1 +5138,1 @@\n-      return make(ptr, (ptr == Constant ? const_oop() : NULL),\n+      return make(ptr, (ptr == Constant ? const_oop() : nullptr),\n@@ -5168,1 +5168,1 @@\n-      return make(ptr, (ptr == Constant ? const_oop() : NULL),\n+      return make(ptr, (ptr == Constant ? const_oop() : nullptr),\n@@ -5191,1 +5191,1 @@\n-    ciKlass* res_klass = NULL;\n+    ciKlass* res_klass = nullptr;\n@@ -5215,1 +5215,1 @@\n-    ciObject* o = NULL;             \/\/ Assume not constant when done\n+    ciObject* o = nullptr;             \/\/ Assume not constant when done\n@@ -5219,1 +5219,1 @@\n-      if (this_oop != NULL && tap_oop != NULL &&\n+      if (this_oop != nullptr && tap_oop != nullptr &&\n@@ -5258,1 +5258,1 @@\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL, offset, false, instance_id, speculative, depth);\n+        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, nullptr, offset, false, instance_id, speculative, depth);\n@@ -5272,1 +5272,1 @@\n-          return make(ptr, (ptr == Constant ? const_oop() : NULL),\n+          return make(ptr, (ptr == Constant ? const_oop() : nullptr),\n@@ -5285,1 +5285,1 @@\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL, offset, false, instance_id, speculative, depth);\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, nullptr, offset, false, instance_id, speculative, depth);\n@@ -5311,1 +5311,1 @@\n-  res_klass = NULL;\n+  res_klass = nullptr;\n@@ -5511,1 +5511,1 @@\n-  if (_speculative == NULL) {\n+  if (_speculative == nullptr) {\n@@ -5515,1 +5515,1 @@\n-  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, NULL, _inline_depth, _is_autobox_cache);\n+  return make(_ptr, _const_oop, _ary->remove_speculative()->is_ary(), _klass, _klass_is_exact, _offset, _field_offset, _instance_id, nullptr, _inline_depth, _is_autobox_cache);\n@@ -5519,1 +5519,1 @@\n-  if (speculative() == NULL) {\n+  if (speculative() == nullptr) {\n@@ -5524,1 +5524,1 @@\n-  if (spec_aryptr != NULL && !above_centerline(spec_aryptr->ptr()) &&\n+  if (spec_aryptr != nullptr && !above_centerline(spec_aryptr->ptr()) &&\n@@ -5563,1 +5563,1 @@\n-      if (field != NULL) {\n+      if (field != nullptr) {\n@@ -5609,1 +5609,1 @@\n-  if (tc != NULL) {\n+  if (tc != nullptr) {\n@@ -5741,1 +5741,1 @@\n-  if (one == NULL || two == NULL) {\n+  if (one == nullptr || two == nullptr) {\n@@ -5774,1 +5774,1 @@\n-  if (ft == NULL || ft->empty())\n+  if (ft == nullptr || ft->empty())\n@@ -5877,1 +5877,1 @@\n-    return make(ptr, NULL, offset);\n+    return make(ptr, nullptr, offset);\n@@ -5924,1 +5924,1 @@\n-  assert(m == NULL || !m->is_klass(), \"wrong type\");\n+  assert(m == nullptr || !m->is_klass(), \"wrong type\");\n@@ -5932,1 +5932,1 @@\n-  if (elem->make_oopptr() != NULL) {\n+  if (elem->make_oopptr() != nullptr) {\n@@ -5960,1 +5960,1 @@\n-  assert(klass == NULL || !klass->is_loaded() || (klass->is_instance_klass() && !klass->is_interface()) ||\n+  assert(klass == nullptr || !klass->is_loaded() || (klass->is_instance_klass() && !klass->is_interface()) ||\n@@ -5975,1 +5975,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -6157,1 +6157,1 @@\n-  assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n+  assert((deps != nullptr) == (C->method() != nullptr && C->method()->code_size() > 0), \"sanity\");\n@@ -6166,1 +6166,1 @@\n-        && deps != NULL && UseUniqueSubclasses) {\n+        && deps != nullptr && UseUniqueSubclasses) {\n@@ -6168,1 +6168,1 @@\n-      if (sub != NULL) {\n+      if (sub != nullptr) {\n@@ -6180,1 +6180,1 @@\n-  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, NULL, Offset(0), flatten_array() && !klass()->is_inlinetype());\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, nullptr, Offset(0), flatten_array() && !klass()->is_inlinetype());\n@@ -6258,1 +6258,1 @@\n-    ciKlass* res_klass = NULL;\n+    ciKlass* res_klass = nullptr;\n@@ -6410,1 +6410,1 @@\n-  assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n+  assert((deps != nullptr) == (C->method() != nullptr && C->method()->code_size() > 0), \"sanity\");\n@@ -6416,1 +6416,1 @@\n-        deps != NULL) {\n+        deps != nullptr) {\n@@ -6418,1 +6418,1 @@\n-      if (sub != NULL) {\n+      if (sub != nullptr) {\n@@ -6463,1 +6463,1 @@\n-    return TypeAryKlassPtr::make(ptr, etype, NULL, offset, not_flat, not_null_free, null_free);\n+    return TypeAryKlassPtr::make(ptr, etype, nullptr, offset, not_flat, not_null_free, null_free);\n@@ -6474,1 +6474,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -6482,1 +6482,1 @@\n-  bool not_flat = !UseFlatArray || not_null_free || (k->as_array_klass()->element_klass() != NULL &&\n+  bool not_flat = !UseFlatArray || not_null_free || (k->as_array_klass()->element_klass() != nullptr &&\n@@ -6516,1 +6516,1 @@\n-  ciKlass* k_ary = NULL;\n+  ciKlass* k_ary = nullptr;\n@@ -6527,1 +6527,1 @@\n-    if (el->inline_klass() != NULL) {\n+    if (el->inline_klass() != nullptr) {\n@@ -6530,4 +6530,4 @@\n-  } else if ((tinst = el->isa_instptr()) != NULL) {\n-    \/\/ Leave k_ary at NULL.\n-  } else if ((tary = el->isa_aryptr()) != NULL) {\n-    \/\/ Leave k_ary at NULL.\n+  } else if ((tinst = el->isa_instptr()) != nullptr) {\n+    \/\/ Leave k_ary at nullptr.\n+  } else if ((tary = el->isa_aryptr()) != nullptr) {\n+    \/\/ Leave k_ary at nullptr.\n@@ -6538,1 +6538,1 @@\n-    \/\/ Leave k_ary at NULL.\n+    \/\/ Leave k_ary at null.\n@@ -6599,2 +6599,2 @@\n-    if (k == NULL) {\n-      return NULL;\n+    if (k == nullptr) {\n+      return nullptr;\n@@ -6685,1 +6685,1 @@\n-  const Type* el = NULL;\n+  const Type* el = nullptr;\n@@ -6688,1 +6688,1 @@\n-    k = NULL;\n+    k = nullptr;\n@@ -6773,1 +6773,1 @@\n-    ciKlass* res_klass = NULL;\n+    ciKlass* res_klass = nullptr;\n@@ -6874,1 +6874,1 @@\n-  if (this_elem != NULL && other_elem != NULL) {\n+  if (this_elem != nullptr && other_elem != nullptr) {\n@@ -6880,1 +6880,1 @@\n-  if (this_elem == NULL && other_elem == NULL) {\n+  if (this_elem == nullptr && other_elem == nullptr) {\n@@ -6909,1 +6909,1 @@\n-  if (other_elem != NULL && this_elem != NULL) {\n+  if (other_elem != nullptr && this_elem != nullptr) {\n@@ -6912,2 +6912,2 @@\n-  if (other_elem == NULL && this_elem == NULL) {\n-    assert(this_one->_klass != NULL && other->_klass != NULL, \"\");\n+  if (other_elem == nullptr && this_elem == nullptr) {\n+    assert(this_one->_klass != nullptr && other->_klass != nullptr, \"\");\n@@ -6949,1 +6949,1 @@\n-  if (other_elem != NULL && this_elem != NULL) {\n+  if (other_elem != nullptr && this_elem != nullptr) {\n@@ -6952,1 +6952,1 @@\n-  if (other_elem == NULL && this_elem == NULL) {\n+  if (other_elem == nullptr && this_elem == nullptr) {\n@@ -6972,2 +6972,2 @@\n-    if (k == NULL) {\n-      return NULL;\n+    if (k == nullptr) {\n+      return nullptr;\n@@ -6983,1 +6983,1 @@\n-  if (_klass != NULL) {\n+  if (_klass != nullptr) {\n@@ -6986,1 +6986,1 @@\n-  ciKlass* k = NULL;\n+  ciKlass* k = nullptr;\n@@ -6988,1 +6988,1 @@\n-    \/\/ leave NULL\n+    \/\/ leave null\n@@ -7068,1 +7068,1 @@\n-  const TypeFunc* tf = NULL;\n+  const TypeFunc* tf = nullptr;\n@@ -7071,1 +7071,1 @@\n-    if (tf != NULL)  return tf;  \/\/ The hit rate here is almost 50%.\n+    if (tf != nullptr)  return tf;  \/\/ The hit rate here is almost 50%.\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":223,"deletions":223,"binary":false,"changes":446,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,1 +206,1 @@\n-  Type( TYPES t ) : _dual(NULL),  _base(t) {} \/\/ Simple types\n+  Type( TYPES t ) : _dual(nullptr),  _base(t) {} \/\/ Simple types\n@@ -308,1 +308,1 @@\n-  const TypeInt    *isa_int() const;             \/\/ Returns NULL if not an Int\n+  const TypeInt    *isa_int() const;             \/\/ Returns null if not an Int\n@@ -312,2 +312,2 @@\n-  const TypeLong   *isa_long() const;            \/\/ Returns NULL if not a Long\n-  const TypeD      *isa_double() const;          \/\/ Returns NULL if not a Double{Top,Con,Bot}\n+  const TypeLong   *isa_long() const;            \/\/ Returns null if not a Long\n+  const TypeD      *isa_double() const;          \/\/ Returns null if not a Double{Top,Con,Bot}\n@@ -315,2 +315,2 @@\n-  const TypeD      *isa_double_constant() const; \/\/ Returns NULL if not a DoubleCon\n-  const TypeF      *isa_float() const;           \/\/ Returns NULL if not a Float{Top,Con,Bot}\n+  const TypeD      *isa_double_constant() const; \/\/ Returns null if not a DoubleCon\n+  const TypeF      *isa_float() const;           \/\/ Returns null if not a Float{Top,Con,Bot}\n@@ -318,1 +318,1 @@\n-  const TypeF      *isa_float_constant() const;  \/\/ Returns NULL if not a FloatCon\n+  const TypeF      *isa_float_constant() const;  \/\/ Returns null if not a FloatCon\n@@ -321,1 +321,1 @@\n-  const TypeAry    *isa_ary() const;             \/\/ Returns NULL of not ary\n+  const TypeAry    *isa_ary() const;             \/\/ Returns null of not ary\n@@ -323,1 +323,1 @@\n-  const TypeVect   *isa_vect() const;            \/\/ Returns NULL if not a Vector\n+  const TypeVect   *isa_vect() const;            \/\/ Returns null if not a Vector\n@@ -325,1 +325,1 @@\n-  const TypeVectMask *isa_vectmask() const;      \/\/ Returns NULL if not a Vector Predicate\/Mask\n+  const TypeVectMask *isa_vectmask() const;      \/\/ Returns null if not a Vector Predicate\/Mask\n@@ -327,1 +327,1 @@\n-  const TypePtr    *isa_ptr() const;             \/\/ Returns NULL if not ptr type\n+  const TypePtr    *isa_ptr() const;             \/\/ Returns null if not ptr type\n@@ -331,1 +331,1 @@\n-  const TypeNarrowOop  *isa_narrowoop() const;   \/\/ Returns NULL if not oop ptr type\n+  const TypeNarrowOop  *isa_narrowoop() const;   \/\/ Returns null if not oop ptr type\n@@ -333,2 +333,2 @@\n-  const TypeNarrowKlass *isa_narrowklass() const;\/\/ Returns NULL if not oop ptr type\n-  const TypeOopPtr   *isa_oopptr() const;        \/\/ Returns NULL if not oop ptr type\n+  const TypeNarrowKlass *isa_narrowklass() const;\/\/ Returns null if not oop ptr type\n+  const TypeOopPtr   *isa_oopptr() const;        \/\/ Returns null if not oop ptr type\n@@ -336,1 +336,1 @@\n-  const TypeInstPtr  *isa_instptr() const;       \/\/ Returns NULL if not InstPtr\n+  const TypeInstPtr  *isa_instptr() const;       \/\/ Returns null if not InstPtr\n@@ -338,1 +338,1 @@\n-  const TypeAryPtr   *isa_aryptr() const;        \/\/ Returns NULL if not AryPtr\n+  const TypeAryPtr   *isa_aryptr() const;        \/\/ Returns null if not AryPtr\n@@ -341,1 +341,1 @@\n-  const TypeMetadataPtr   *isa_metadataptr() const;   \/\/ Returns NULL if not oop ptr type\n+  const TypeMetadataPtr   *isa_metadataptr() const;   \/\/ Returns null if not oop ptr type\n@@ -343,1 +343,1 @@\n-  const TypeKlassPtr      *isa_klassptr() const;      \/\/ Returns NULL if not KlassPtr\n+  const TypeKlassPtr      *isa_klassptr() const;      \/\/ Returns null if not KlassPtr\n@@ -345,1 +345,1 @@\n-  const TypeInstKlassPtr  *isa_instklassptr() const;  \/\/ Returns NULL if not IntKlassPtr\n+  const TypeInstKlassPtr  *isa_instklassptr() const;  \/\/ Returns null if not IntKlassPtr\n@@ -347,1 +347,1 @@\n-  const TypeAryKlassPtr   *isa_aryklassptr() const;   \/\/ Returns NULL if not AryKlassPtr\n+  const TypeAryKlassPtr   *isa_aryklassptr() const;   \/\/ Returns null if not AryKlassPtr\n@@ -418,1 +418,1 @@\n-    assert((uint)type <= T_CONFLICT && _const_basic_type[type] != NULL, \"bad type\");\n+    assert((uint)type <= T_CONFLICT && _const_basic_type[type] != nullptr, \"bad type\");\n@@ -423,1 +423,1 @@\n-  \/\/ Otherwise or if the arrays have different dimensions, return NULL.\n+  \/\/ Otherwise or if the arrays have different dimensions, return null.\n@@ -439,1 +439,1 @@\n-    assert((uint)type <= T_CONFLICT && _zero_type[type] != NULL, \"bad type\");\n+    assert((uint)type <= T_CONFLICT && _zero_type[type] != nullptr, \"bad type\");\n@@ -497,3 +497,3 @@\n-  virtual const TypePtr* speculative() const                                  { return NULL; }\n-  virtual ciKlass* speculative_type() const                                   { return NULL; }\n-  virtual ciKlass* speculative_type_not_null() const                          { return NULL; }\n+  virtual const TypePtr* speculative() const                                  { return nullptr; }\n+  virtual ciKlass* speculative_type() const                                   { return nullptr; }\n+  virtual ciKlass* speculative_type_not_null() const                          { return nullptr; }\n@@ -504,1 +504,1 @@\n-  virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }\n+  virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != nullptr; }\n@@ -968,1 +968,1 @@\n-          const TypePtr* speculative = NULL,\n+          const TypePtr* speculative = nullptr,\n@@ -1044,1 +1044,1 @@\n-                             const TypePtr* speculative = NULL,\n+                             const TypePtr* speculative = nullptr,\n@@ -1133,1 +1133,1 @@\n-  virtual const TypeRawPtr* with_offset(intptr_t offset) const { ShouldNotReachHere(); return NULL;}\n+  virtual const TypeRawPtr* with_offset(intptr_t offset) const { ShouldNotReachHere(); return nullptr;}\n@@ -1165,1 +1165,1 @@\n-  \/\/ Oop is NULL, unless this is a constant oop.\n+  \/\/ Oop is null, unless this is a constant oop.\n@@ -1167,1 +1167,1 @@\n-  \/\/ If _klass is NULL, then so is _sig.  This is an unloaded klass.\n+  \/\/ If _klass is null, then so is _sig.  This is an unloaded klass.\n@@ -1193,1 +1193,1 @@\n-  virtual ciKlass* exact_klass_helper() const { return NULL; }\n+  virtual ciKlass* exact_klass_helper() const { return nullptr; }\n@@ -1236,1 +1236,1 @@\n-  \/\/ If require_constant, produce a NULL if a singleton is not possible.\n+  \/\/ If require_constant, produce a null if a singleton is not possible.\n@@ -1242,1 +1242,1 @@\n-                                const TypePtr* speculative = NULL,\n+                                const TypePtr* speculative = nullptr,\n@@ -1247,1 +1247,1 @@\n-  ciKlass* exact_klass(bool maybe_null = false) const { assert(klass_is_exact(), \"\"); ciKlass* k = exact_klass_helper(); assert(k != NULL || maybe_null, \"\"); return k;  }\n+  ciKlass* exact_klass(bool maybe_null = false) const { assert(klass_is_exact(), \"\"); ciKlass* k = exact_klass_helper(); assert(k != nullptr || maybe_null, \"\"); return k;  }\n@@ -1262,1 +1262,1 @@\n-  virtual bool can_be_inline_type() const { return (_klass == NULL || _klass->can_be_inline_klass(_klass_is_exact)); }\n+  virtual bool can_be_inline_type() const { return (_klass == nullptr || _klass->can_be_inline_klass(_klass_is_exact)); }\n@@ -1363,1 +1363,1 @@\n-    return make(ptr, klass, interfaces, false, NULL, Offset(0));\n+    return make(ptr, klass, interfaces, false, nullptr, Offset(0));\n@@ -1369,1 +1369,1 @@\n-    return make(ptr, klass, interfaces, true, NULL, Offset(0));\n+    return make(ptr, klass, interfaces, true, nullptr, Offset(0));\n@@ -1375,1 +1375,1 @@\n-    return make(ptr, klass, interfaces, false, NULL, offset);\n+    return make(ptr, klass, interfaces, false, nullptr, offset);\n@@ -1382,1 +1382,1 @@\n-                                 const TypePtr* speculative = NULL,\n+                                 const TypePtr* speculative = nullptr,\n@@ -1393,1 +1393,1 @@\n-  \/\/ If this is a java.lang.Class constant, return the type for it or NULL.\n+  \/\/ If this is a java.lang.Class constant, return the type for it or null.\n@@ -1396,1 +1396,1 @@\n-  ciType* java_mirror_type(bool* is_val_mirror = NULL) const;\n+  ciType* java_mirror_type(bool* is_val_mirror = nullptr) const;\n@@ -1462,1 +1462,1 @@\n-    if (UseCompressedOops && (elem()->make_oopptr() != NULL && !top_or_bottom) &&\n+    if (UseCompressedOops && (elem()->make_oopptr() != nullptr && !top_or_bottom) &&\n@@ -1509,1 +1509,1 @@\n-  bool is_null_free()     const { return is_flat() || (_ary->_elem->make_ptr() != NULL && _ary->_elem->make_ptr()->is_inlinetypeptr() && (_ary->_elem->make_ptr()->ptr() == NotNull || _ary->_elem->make_ptr()->ptr() == AnyNull)); }\n+  bool is_null_free()     const { return is_flat() || (_ary->_elem->make_ptr() != nullptr && _ary->_elem->make_ptr()->is_inlinetypeptr() && (_ary->_elem->make_ptr()->ptr() == NotNull || _ary->_elem->make_ptr()->ptr() == AnyNull)); }\n@@ -1517,1 +1517,1 @@\n-                                const TypePtr* speculative = NULL,\n+                                const TypePtr* speculative = nullptr,\n@@ -1523,1 +1523,1 @@\n-                                const TypePtr* speculative = NULL,\n+                                const TypePtr* speculative = nullptr,\n@@ -1591,1 +1591,1 @@\n-    assert((uint)elem <= T_CONFLICT && _array_body_type[elem] != NULL, \"bad elem type\");\n+    assert((uint)elem <= T_CONFLICT && _array_body_type[elem] != nullptr, \"bad elem type\");\n@@ -1685,1 +1685,1 @@\n-  ciKlass* exact_klass(bool maybe_null = false) const { assert(klass_is_exact(), \"\"); ciKlass* k = exact_klass_helper(); assert(k != NULL || maybe_null, \"\"); return k;  }\n+  ciKlass* exact_klass(bool maybe_null = false) const { assert(klass_is_exact(), \"\"); ciKlass* k = exact_klass_helper(); assert(k != nullptr || maybe_null, \"\"); return k;  }\n@@ -1693,1 +1693,1 @@\n-  virtual const TypeKlassPtr* cast_to_ptr_type(PTR ptr) const { ShouldNotReachHere(); return NULL; }\n+  virtual const TypeKlassPtr* cast_to_ptr_type(PTR ptr) const { ShouldNotReachHere(); return nullptr; }\n@@ -1695,1 +1695,1 @@\n-  virtual const TypeKlassPtr *cast_to_exactness(bool klass_is_exact) const { ShouldNotReachHere(); return NULL; }\n+  virtual const TypeKlassPtr *cast_to_exactness(bool klass_is_exact) const { ShouldNotReachHere(); return nullptr; }\n@@ -1698,1 +1698,1 @@\n-  virtual const TypeOopPtr* as_instance_type(bool klass_change = true) const { ShouldNotReachHere(); return NULL; }\n+  virtual const TypeOopPtr* as_instance_type(bool klass_change = true) const { ShouldNotReachHere(); return nullptr; }\n@@ -1700,3 +1700,3 @@\n-  virtual const TypePtr *add_offset( intptr_t offset ) const { ShouldNotReachHere(); return NULL; }\n-  virtual const Type    *xmeet( const Type *t ) const { ShouldNotReachHere(); return NULL; }\n-  virtual const Type    *xdual() const { ShouldNotReachHere(); return NULL; }\n+  virtual const TypePtr *add_offset( intptr_t offset ) const { ShouldNotReachHere(); return nullptr; }\n+  virtual const Type    *xmeet( const Type *t ) const { ShouldNotReachHere(); return nullptr; }\n+  virtual const Type    *xdual() const { ShouldNotReachHere(); return nullptr; }\n@@ -1706,1 +1706,1 @@\n-  virtual const TypeKlassPtr* with_offset(intptr_t offset) const { ShouldNotReachHere(); return NULL; }\n+  virtual const TypeKlassPtr* with_offset(intptr_t offset) const { ShouldNotReachHere(); return nullptr; }\n@@ -1763,1 +1763,1 @@\n-  virtual bool can_be_inline_type() const { return (_klass == NULL || _klass->can_be_inline_klass(klass_is_exact())); }\n+  virtual bool can_be_inline_type() const { return (_klass == nullptr || _klass->can_be_inline_klass(klass_is_exact())); }\n@@ -1818,1 +1818,1 @@\n-    assert(klass == NULL || klass->is_type_array_klass() || klass->is_flat_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"\");\n+    assert(klass == nullptr || klass->is_type_array_klass() || klass->is_flat_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"\");\n@@ -1874,1 +1874,1 @@\n-  bool is_flat()          const { return klass() != NULL && klass()->is_flat_array_klass(); }\n+  bool is_flat()          const { return klass() != nullptr && klass()->is_flat_array_klass(); }\n@@ -2074,1 +2074,1 @@\n-  return (isa_oopptr() != NULL && is_oopptr()->is_ptr_to_narrowoop_nv());\n+  return (isa_oopptr() != nullptr && is_oopptr()->is_ptr_to_narrowoop_nv());\n@@ -2082,1 +2082,1 @@\n-  return (isa_oopptr() != NULL && is_oopptr()->is_ptr_to_narrowklass_nv());\n+  return (isa_oopptr() != nullptr && is_oopptr()->is_ptr_to_narrowklass_nv());\n@@ -2104,1 +2104,1 @@\n-  return (((bt == T_INT && _base == Int) || (bt == T_LONG && _base == Long)) ? (TypeInteger*)this : NULL);\n+  return (((bt == T_INT && _base == Int) || (bt == T_LONG && _base == Long)) ? (TypeInteger*)this : nullptr);\n@@ -2113,1 +2113,1 @@\n-  return ( _base == Int ? (TypeInt*)this : NULL);\n+  return ( _base == Int ? (TypeInt*)this : nullptr);\n@@ -2122,1 +2122,1 @@\n-  return ( _base == Long ? (TypeLong*)this : NULL);\n+  return ( _base == Long ? (TypeLong*)this : nullptr);\n@@ -2128,1 +2128,1 @@\n-           _base == FloatBot) ? (TypeF*)this : NULL);\n+           _base == FloatBot) ? (TypeF*)this : nullptr);\n@@ -2137,1 +2137,1 @@\n-  return ( _base == FloatCon ? (TypeF*)this : NULL);\n+  return ( _base == FloatCon ? (TypeF*)this : nullptr);\n@@ -2143,1 +2143,1 @@\n-           _base == DoubleBot) ? (TypeD*)this : NULL);\n+           _base == DoubleBot) ? (TypeD*)this : nullptr);\n@@ -2152,1 +2152,1 @@\n-  return ( _base == DoubleCon ? (TypeD*)this : NULL);\n+  return ( _base == DoubleCon ? (TypeD*)this : nullptr);\n@@ -2166,1 +2166,1 @@\n-  return ((_base == Array) ? (TypeAry*)this : NULL);\n+  return ((_base == Array) ? (TypeAry*)this : nullptr);\n@@ -2175,1 +2175,1 @@\n-  return (_base == VectorMask) ? (TypeVectMask*)this : NULL;\n+  return (_base == VectorMask) ? (TypeVectMask*)this : nullptr;\n@@ -2184,1 +2184,1 @@\n-  return (_base >= VectorMask && _base <= VectorZ) ? (TypeVect*)this : NULL;\n+  return (_base >= VectorMask && _base <= VectorZ) ? (TypeVect*)this : nullptr;\n@@ -2195,1 +2195,1 @@\n-  return (_base >= AnyPtr && _base <= AryKlassPtr) ? (TypePtr*)this : NULL;\n+  return (_base >= AnyPtr && _base <= AryKlassPtr) ? (TypePtr*)this : nullptr;\n@@ -2206,1 +2206,1 @@\n-  return (_base >= OopPtr && _base <= AryPtr) ? (TypeOopPtr*)this : NULL;\n+  return (_base >= OopPtr && _base <= AryPtr) ? (TypeOopPtr*)this : nullptr;\n@@ -2210,1 +2210,1 @@\n-  return (_base == RawPtr) ? (TypeRawPtr*)this : NULL;\n+  return (_base == RawPtr) ? (TypeRawPtr*)this : nullptr;\n@@ -2219,1 +2219,1 @@\n-  return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;\n+  return (_base == InstPtr) ? (TypeInstPtr*)this : nullptr;\n@@ -2228,1 +2228,1 @@\n-  return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;\n+  return (_base == AryPtr) ? (TypeAryPtr*)this : nullptr;\n@@ -2244,1 +2244,1 @@\n-  return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;\n+  return (_base == NarrowOop) ? (TypeNarrowOop*)this : nullptr;\n@@ -2253,1 +2253,1 @@\n-  return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;\n+  return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : nullptr;\n@@ -2263,1 +2263,1 @@\n-  return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : NULL;\n+  return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : nullptr;\n@@ -2267,1 +2267,1 @@\n-  return (_base >= KlassPtr && _base <= AryKlassPtr ) ? (TypeKlassPtr*)this : NULL;\n+  return (_base >= KlassPtr && _base <= AryKlassPtr ) ? (TypeKlassPtr*)this : nullptr;\n@@ -2276,1 +2276,1 @@\n-  return (_base == InstKlassPtr) ? (TypeInstKlassPtr*)this : NULL;\n+  return (_base == InstKlassPtr) ? (TypeInstKlassPtr*)this : nullptr;\n@@ -2285,1 +2285,1 @@\n-  return (_base == AryKlassPtr) ? (TypeAryKlassPtr*)this : NULL;\n+  return (_base == AryKlassPtr) ? (TypeAryKlassPtr*)this : nullptr;\n@@ -2305,1 +2305,1 @@\n-                                (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);\n+                                (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : nullptr);\n@@ -2310,1 +2310,1 @@\n-                                  (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);\n+                                  (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : nullptr);\n@@ -2321,1 +2321,1 @@\n-  return isa_instptr() != NULL && is_instptr()->instance_klass()->is_inlinetype();\n+  return isa_instptr() != nullptr && is_instptr()->instance_klass()->is_inlinetype();\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":86,"deletions":86,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,1 +215,1 @@\n-      Node* new_vbox = NULL;\n+      Node* new_vbox = nullptr;\n@@ -297,1 +297,1 @@\n-      if (debug != NULL && debug->uncast(\/*keep_deps*\/false) == vec_box) {\n+      if (debug != nullptr && debug->uncast(\/*keep_deps*\/false) == vec_box) {\n@@ -407,1 +407,1 @@\n-  assert(field != NULL, \"\");\n+  assert(field != nullptr, \"\");\n@@ -448,1 +448,1 @@\n-    assert(field != NULL, \"\");\n+    assert(field != nullptr, \"\");\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -346,0 +346,4 @@\n+  if (InstanceKlass::cast(k) == vmClasses::Continuation_klass()) {\n+    \/\/ Don't redefine Continuation class. See 8302779.\n+    return false;\n+  }\n@@ -4135,1 +4139,1 @@\n-  bool deopt_needed;\n+  DeoptimizationScope deopt_scope;\n@@ -4139,0 +4143,1 @@\n+    CodeCache::mark_all_nmethods_for_evol_deoptimization(&deopt_scope);\n@@ -4140,5 +4145,2 @@\n-    CodeCache::mark_all_nmethods_for_evol_deoptimization();\n-    deopt_needed = true;\n-    int deopt = CodeCache::mark_dependents_for_evol_deoptimization();\n-    log_debug(redefine, class, nmethod)(\"Marked %d dependent nmethods for deopt\", deopt);\n-    deopt_needed = (deopt != 0);\n+    CodeCache::mark_dependents_for_evol_deoptimization(&deopt_scope);\n+    log_debug(redefine, class, nmethod)(\"Marked dependent nmethods for deopt\");\n@@ -4148,3 +4150,1 @@\n-  if (deopt_needed) {\n-    CodeCache::flush_evol_dependents();\n-  }\n+  deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -957,1 +957,1 @@\n-void MethodHandles::flush_dependent_nmethods(Handle call_site, Handle target) {\n+void MethodHandles::mark_dependent_nmethods(DeoptimizationScope* deopt_scope, Handle call_site, Handle target) {\n@@ -960,1 +960,0 @@\n-  int marked = 0;\n@@ -964,1 +963,1 @@\n-    MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -968,5 +967,1 @@\n-    marked = deps.mark_dependent_nmethods(changes);\n-  }\n-  if (marked > 0) {\n-    \/\/ At least one nmethod has been marked for deoptimization.\n-    Deoptimization::deoptimize_all_marked();\n+    deps.mark_dependent_nmethods(deopt_scope, changes);\n@@ -1226,0 +1221,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1229,1 +1225,1 @@\n-    MethodHandles::flush_dependent_nmethods(call_site, target);\n+    MethodHandles::mark_dependent_nmethods(&deopt_scope, call_site, target);\n@@ -1231,0 +1227,3 @@\n+    \/\/ This is assumed to be an 'atomic' operation by verification.\n+    \/\/ So keep it under lock for now.\n+    deopt_scope.deoptimize_marked();\n@@ -1238,0 +1237,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1241,1 +1241,1 @@\n-    MethodHandles::flush_dependent_nmethods(call_site, target);\n+    MethodHandles::mark_dependent_nmethods(&deopt_scope, call_site, target);\n@@ -1243,0 +1243,3 @@\n+    \/\/ This is assumed to be an 'atomic' operation by verification.\n+    \/\/ So keep it under lock for now.\n+    deopt_scope.deoptimize_marked();\n@@ -1332,0 +1335,1 @@\n+  DeoptimizationScope deopt_scope;\n@@ -1333,14 +1337,7 @@\n-    \/\/ Walk all nmethods depending on this call site.\n-    MutexLocker mu1(thread, Compile_lock);\n-\n-    int marked = 0;\n-    {\n-      NoSafepointVerifier nsv;\n-      MutexLocker mu2(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-      DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());\n-      marked = deps.remove_and_mark_for_deoptimization_all_dependents();\n-    }\n-    if (marked > 0) {\n-      \/\/ At least one nmethod has been marked for deoptimization\n-      Deoptimization::deoptimize_all_marked();\n-    }\n+    NoSafepointVerifier nsv;\n+    MutexLocker ml(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());\n+    deps.remove_and_mark_for_deoptimization_all_dependents(&deopt_scope);\n+    \/\/ This is assumed to be an 'atomic' operation by verification.\n+    \/\/ So keep it under lock for now.\n+    deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -124,2 +124,0 @@\n-#define SIZE_T_MAX_VALUE ((size_t) -1)\n-\n@@ -353,1 +351,1 @@\n-    jlong size_t_max_value = (jlong) SIZE_T_MAX_VALUE;\n+    jlong size_t_max_value = (jlong)SIZE_MAX;\n@@ -784,2 +782,3 @@\n-  CodeCache::mark_all_nmethods_for_deoptimization();\n-  Deoptimization::deoptimize_all_marked();\n+  DeoptimizationScope deopt_scope;\n+  CodeCache::mark_all_nmethods_for_deoptimization(&deopt_scope);\n+  deopt_scope.deoptimize_marked();\n@@ -792,11 +791,15 @@\n-  MutexLocker mu(Compile_lock);\n-  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n-  if (is_osr) {\n-    result += mh->mark_osr_nmethods();\n-  } else if (mh->code() != nullptr) {\n-    mh->code()->mark_for_deoptimization();\n-    ++result;\n-  }\n-  result += CodeCache::mark_for_deoptimization(mh());\n-  if (result > 0) {\n-    Deoptimization::deoptimize_all_marked();\n+\n+  DeoptimizationScope deopt_scope;\n+  {\n+    MutexLocker mu(Compile_lock);\n+    methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+    if (is_osr) {\n+      result += mh->method_holder()->mark_osr_nmethods(&deopt_scope, mh());\n+    } else {\n+      MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+      if (mh->code() != nullptr) {\n+        deopt_scope.mark(mh->code());\n+        ++result;\n+      }\n+    }\n+    CodeCache::mark_for_deoptimization(&deopt_scope, mh());\n@@ -804,0 +807,3 @@\n+\n+  deopt_scope.deoptimize_marked();\n+\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -74,1 +74,3 @@\n-#define DEFAULT_JAVA_LAUNCHER  \"generic\"\n+static const char _default_java_launcher[] = \"generic\";\n+\n+#define DEFAULT_JAVA_LAUNCHER _default_java_launcher\n@@ -100,0 +102,1 @@\n+char*  Arguments::_default_shared_archive_path  = nullptr;\n@@ -326,1 +329,1 @@\n-void Arguments::add_init_library(const char* name, char* options) {\n+void Arguments::add_init_library(const char* name, const char* options) {\n@@ -330,1 +333,1 @@\n-void Arguments::add_init_agent(const char* name, char* options, bool absolute_path) {\n+void Arguments::add_init_agent(const char* name, const char* options, bool absolute_path) {\n@@ -334,1 +337,1 @@\n-void Arguments::add_instrument_agent(const char* name, char* options, bool absolute_path) {\n+void Arguments::add_instrument_agent(const char* name, const char* options, bool absolute_path) {\n@@ -1911,0 +1914,3 @@\n+  if (_sun_java_launcher != _default_java_launcher) {\n+    os::free(const_cast<char*>(_sun_java_launcher));\n+  }\n@@ -2439,0 +2445,2 @@\n+        FREE_C_HEAP_ARRAY(char, name);\n+        FREE_C_HEAP_ARRAY(char, options);\n@@ -2509,0 +2517,2 @@\n+        os::free(name);\n+        os::free(options);\n@@ -2522,0 +2532,1 @@\n+        FREE_C_HEAP_ARRAY(char, options);\n@@ -3504,13 +3515,14 @@\n-  char *default_archive_path;\n-  char jvm_path[JVM_MAXPATHLEN];\n-  os::jvm_path(jvm_path, sizeof(jvm_path));\n-  char *end = strrchr(jvm_path, *os::file_separator());\n-  if (end != nullptr) *end = '\\0';\n-  size_t jvm_path_len = strlen(jvm_path);\n-  size_t file_sep_len = strlen(os::file_separator());\n-  const size_t len = jvm_path_len + file_sep_len + 20;\n-  default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);\n-  jio_snprintf(default_archive_path, len,\n-               LP64_ONLY(!UseCompressedOops ? \"%s%sclasses_nocoops.jsa\":) \"%s%sclasses.jsa\",\n-               jvm_path, os::file_separator());\n-  return default_archive_path;\n+  if (_default_shared_archive_path == nullptr) {\n+    char jvm_path[JVM_MAXPATHLEN];\n+    os::jvm_path(jvm_path, sizeof(jvm_path));\n+    char *end = strrchr(jvm_path, *os::file_separator());\n+    if (end != nullptr) *end = '\\0';\n+    size_t jvm_path_len = strlen(jvm_path);\n+    size_t file_sep_len = strlen(os::file_separator());\n+    const size_t len = jvm_path_len + file_sep_len + 20;\n+    _default_shared_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);\n+    jio_snprintf(_default_shared_archive_path, len,\n+                LP64_ONLY(!UseCompressedOops ? \"%s%sclasses_nocoops.jsa\":) \"%s%sclasses.jsa\",\n+                jvm_path, os::file_separator());\n+  }\n+  return _default_shared_archive_path;\n@@ -3568,2 +3580,1 @@\n-    char* shared_archive_path = get_default_shared_archive_path();\n-    if (os::same_files(shared_archive_path, ArchiveClassesAtExit)) {\n+    if (os::same_files(get_default_shared_archive_path(), ArchiveClassesAtExit)) {\n@@ -3571,1 +3582,1 @@\n-        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", shared_archive_path);\n+        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", get_default_shared_archive_path());\n@@ -3573,1 +3584,0 @@\n-    FREE_C_HEAP_ARRAY(char, shared_archive_path);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":31,"deletions":21,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-  static void add_init_library(const char* name, char* options);\n+  static void add_init_library(const char* name, const char* options);\n@@ -341,2 +341,2 @@\n-  static void add_init_agent(const char* name, char* options, bool absolute_path);\n-  static void add_instrument_agent(const char* name, char* options, bool absolute_path);\n+  static void add_init_agent(const char* name, const char* options, bool absolute_path);\n+  static void add_instrument_agent(const char* name, const char* options, bool absolute_path);\n@@ -474,0 +474,1 @@\n+  static char*  _default_shared_archive_path;\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -104,0 +104,115 @@\n+uint64_t DeoptimizationScope::_committed_deopt_gen = 0;\n+uint64_t DeoptimizationScope::_active_deopt_gen    = 1;\n+bool     DeoptimizationScope::_committing_in_progress = false;\n+\n+DeoptimizationScope::DeoptimizationScope() : _required_gen(0) {\n+  DEBUG_ONLY(_deopted = false;)\n+\n+  MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n+  \/\/ If there is nothing to deopt _required_gen is the same as comitted.\n+  _required_gen = DeoptimizationScope::_committed_deopt_gen;\n+}\n+\n+DeoptimizationScope::~DeoptimizationScope() {\n+  assert(_deopted, \"Deopt not executed\");\n+}\n+\n+void DeoptimizationScope::mark(CompiledMethod* cm, bool inc_recompile_counts) {\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                 Mutex::_no_safepoint_check_flag);\n+\n+  \/\/ If it's already marked but we still need it to be deopted.\n+  if (cm->is_marked_for_deoptimization()) {\n+    dependent(cm);\n+    return;\n+  }\n+\n+  CompiledMethod::DeoptimizationStatus status =\n+    inc_recompile_counts ? CompiledMethod::deoptimize : CompiledMethod::deoptimize_noupdate;\n+  Atomic::store(&cm->_deoptimization_status, status);\n+\n+  \/\/ Make sure active is not committed\n+  assert(DeoptimizationScope::_committed_deopt_gen < DeoptimizationScope::_active_deopt_gen, \"Must be\");\n+  assert(cm->_deoptimization_generation == 0, \"Is already marked\");\n+\n+  cm->_deoptimization_generation = DeoptimizationScope::_active_deopt_gen;\n+  _required_gen                  = DeoptimizationScope::_active_deopt_gen;\n+}\n+\n+void DeoptimizationScope::dependent(CompiledMethod* cm) {\n+  MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                 Mutex::_no_safepoint_check_flag);\n+  \/\/ A method marked by someone else may have a _required_gen lower than what we marked with.\n+  \/\/ Therefore only store it if it's higher than _required_gen.\n+  if (_required_gen < cm->_deoptimization_generation) {\n+    _required_gen = cm->_deoptimization_generation;\n+  }\n+}\n+\n+void DeoptimizationScope::deoptimize_marked() {\n+  assert(!_deopted, \"Already deopted\");\n+\n+  \/\/ We are not alive yet.\n+  if (!Universe::is_fully_initialized()) {\n+    DEBUG_ONLY(_deopted = true;)\n+    return;\n+  }\n+\n+  \/\/ Safepoints are a special case, handled here.\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    DeoptimizationScope::_committed_deopt_gen = DeoptimizationScope::_active_deopt_gen;\n+    DeoptimizationScope::_active_deopt_gen++;\n+    Deoptimization::deoptimize_all_marked();\n+    DEBUG_ONLY(_deopted = true;)\n+    return;\n+  }\n+\n+  uint64_t comitting = 0;\n+  bool wait = false;\n+  while (true) {\n+    {\n+      MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                 Mutex::_no_safepoint_check_flag);\n+      \/\/ First we check if we or someone else already deopted the gen we want.\n+      if (DeoptimizationScope::_committed_deopt_gen >= _required_gen) {\n+        DEBUG_ONLY(_deopted = true;)\n+        return;\n+      }\n+      if (!_committing_in_progress) {\n+        \/\/ The version we are about to commit.\n+        comitting = DeoptimizationScope::_active_deopt_gen;\n+        \/\/ Make sure new marks use a higher gen.\n+        DeoptimizationScope::_active_deopt_gen++;\n+        _committing_in_progress = true;\n+        wait = false;\n+      } else {\n+        \/\/ Another thread is handshaking and committing a gen.\n+        wait = true;\n+      }\n+    }\n+    if (wait) {\n+      \/\/ Wait and let the concurrent handshake be performed.\n+      ThreadBlockInVM tbivm(JavaThread::current());\n+      os::naked_yield();\n+    } else {\n+      \/\/ Performs the handshake.\n+      Deoptimization::deoptimize_all_marked(); \/\/ May safepoint and an additional deopt may have occurred.\n+      DEBUG_ONLY(_deopted = true;)\n+      {\n+        MutexLocker ml(CompiledMethod_lock->owned_by_self() ? nullptr : CompiledMethod_lock,\n+                       Mutex::_no_safepoint_check_flag);\n+        \/\/ Make sure that committed doesn't go backwards.\n+        \/\/ Should only happen if we did a deopt during a safepoint above.\n+        if (DeoptimizationScope::_committed_deopt_gen < comitting) {\n+          DeoptimizationScope::_committed_deopt_gen = comitting;\n+        }\n+        _committing_in_progress = false;\n+\n+        assert(DeoptimizationScope::_committed_deopt_gen >= _required_gen, \"Must be\");\n+\n+        return;\n+      }\n+    }\n+  }\n+}\n+\n@@ -949,1 +1064,1 @@\n-void Deoptimization::deoptimize_all_marked(nmethod* nmethod_only) {\n+void Deoptimization::deoptimize_all_marked() {\n@@ -953,7 +1068,1 @@\n-  if (nmethod_only != nullptr) {\n-    nmethod_only->mark_for_deoptimization();\n-    nmethod_only->make_not_entrant();\n-    CodeCache::make_nmethod_deoptimized(nmethod_only);\n-  } else {\n-    CodeCache::make_marked_nmethods_deoptimized();\n-  }\n+  CodeCache::make_marked_nmethods_deoptimized();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":117,"deletions":8,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -43,0 +43,26 @@\n+class DeoptimizationScope {\n+ private:\n+  \/\/ What gen we have done the deopt handshake for.\n+  static uint64_t _committed_deopt_gen;\n+  \/\/ What gen to mark a method with, hence larger than _committed_deopt_gen.\n+  static uint64_t _active_deopt_gen;\n+  \/\/ Indicate an in-progress deopt handshake.\n+  static bool     _committing_in_progress;\n+\n+  \/\/ The required gen we need to execute\/wait for\n+  uint64_t _required_gen;\n+  DEBUG_ONLY(bool _deopted;)\n+\n+ public:\n+  DeoptimizationScope();\n+  ~DeoptimizationScope();\n+  \/\/ Mark a method, if already marked as dependent.\n+  void mark(CompiledMethod* cm, bool inc_recompile_counts = true);\n+  \/\/ Record this as a dependent method.\n+  void dependent(CompiledMethod* cm);\n+\n+  \/\/ Execute the deoptimization.\n+  \/\/ Make the nmethods not entrant, stackwalks and patch return pcs and sets post call nops.\n+  void deoptimize_marked();\n+};\n+\n@@ -152,2 +178,1 @@\n-  \/\/ activations using those nmethods.  If an nmethod is passed as an argument then it is\n-  \/\/ marked_for_deoptimization and made not_entrant.  Otherwise a scan of the code cache is done to\n+  \/\/ activations using those nmethods. Scan of the code cache is done to\n@@ -155,1 +180,1 @@\n-  static void deoptimize_all_marked(nmethod* nmethod_only = nullptr);\n+  static void deoptimize_all_marked();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1215,1 +1215,1 @@\n-          \"Inline intrinsics that can be statically resolved\")              \\\n+          \"Use intrinsics in Interpreter that can be statically resolved\")  \\\n@@ -1906,1 +1906,1 @@\n-  product(size_t, ArrayAllocatorMallocLimit, (size_t)-1, EXPERIMENTAL,      \\\n+  product(size_t, ArrayAllocatorMallocLimit, SIZE_MAX, EXPERIMENTAL,        \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-                            THREAD);\n+                            CHECK);\n@@ -250,1 +250,1 @@\n-                            THREAD);\n+                            CHECK);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -451,91 +451,0 @@\n-\/\/ Reference implementation at src\/java.base\/share\/classes\/java\/lang\/Float.java:floatToFloat16\n-JRT_LEAF(jshort, SharedRuntime::f2hf(jfloat  x))\n-  union {jfloat f; jint i;} bits;\n-  bits.f = x;\n-  jint doppel = bits.i;\n-  jshort sign_bit = (jshort) ((doppel & 0x80000000) >> 16);\n-  if (g_isnan(x))\n-    return (jshort)(sign_bit | 0x7c00 | (doppel & 0x007fe000) >> 13 | (doppel & 0x00001ff0) >> 4 | (doppel & 0x0000000f));\n-\n-  jfloat abs_f = (x >= 0.0f) ? x : (x * -1.0f);\n-\n-  \/\/ Overflow threshold is halffloat max value + 1\/2 ulp\n-  if (abs_f >= (65504.0f + 16.0f)) {\n-    return (jshort)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n-  }\n-\n-  \/\/ Smallest magnitude of Halffloat is 0x1.0p-24, half-way or smaller rounds to zero\n-  if (abs_f <= (pow(2, -24) * 0.5f)) { \/\/ Covers float zeros and subnormals.\n-    return sign_bit; \/\/ Positive or negative zero\n-  }\n-\n-  jint exp = ((0x7f800000 & doppel) >> (24 - 1)) - 127;\n-\n-  \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n-  \/\/ the difference exp_delta = E_min - exp.  This is the excess\n-  \/\/ shift value, in addition to 13, to be used in the\n-  \/\/ computations below. Further the (hidden) msb with value 1\n-  \/\/ in f must be involved as well\n-  jint exp_delta = 0;\n-  jint msb = 0x00000000;\n-  if (exp < -14) {\n-    exp_delta = -14 - exp;\n-    exp = -15;\n-    msb = 0x00800000;\n-  }\n-  jint f_signif_bits = ((doppel & 0x007fffff) | msb);\n-\n-  \/\/ Significand bits as if using rounding to zero\n-  jshort signif_bits = (jshort)(f_signif_bits >> (13 + exp_delta));\n-\n-  jint lsb = f_signif_bits & (1 << (13 + exp_delta));\n-  jint round  = f_signif_bits & (1 << (12 + exp_delta));\n-  jint sticky = f_signif_bits & ((1 << (12 + exp_delta)) - 1);\n-\n-  if (round != 0 && ((lsb | sticky) != 0 )) {\n-    signif_bits++;\n-  }\n-\n-  return (jshort)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n-JRT_END\n-\n-\/\/ Reference implementation at src\/java.base\/share\/classes\/java\/lang\/Float.java:float16ToFloat\n-JRT_LEAF(jfloat, SharedRuntime::hf2f(jshort x))\n-  \/\/ Halffloat format has 1 signbit, 5 exponent bits and\n-  \/\/ 10 significand bits\n-  union {jfloat f; jint i;} bits;\n-  jint hf_arg = (jint)x;\n-  jint hf_sign_bit = 0x8000 & hf_arg;\n-  jint hf_exp_bits = 0x7c00 & hf_arg;\n-  jint hf_significand_bits = 0x03ff & hf_arg;\n-\n-  jint significand_shift = 13; \/\/difference between float and halffloat precision\n-\n-  jfloat sign = (hf_sign_bit != 0) ? -1.0f : 1.0f;\n-\n-  \/\/ Extract halffloat exponent, remove its bias\n-  jint hf_exp = (hf_exp_bits >> 10) - 15;\n-\n-  if (hf_exp == -15) {\n-    \/\/ For subnormal values, return 2^-24 * significand bits\n-    return (sign * (pow(2,-24)) * hf_significand_bits);\n-  } else if (hf_exp == 16) {\n-    if (hf_significand_bits == 0) {\n-      bits.i = 0x7f800000;\n-      return sign * bits.f;\n-    } else {\n-      bits.i = (hf_sign_bit << 16) | 0x7f800000 |\n-               (hf_significand_bits << significand_shift);\n-      return bits.f;\n-    }\n-  }\n-\n-  \/\/ Add the bias of float exponent and shift\n-  jint float_exp_bits = (hf_exp + 127) << (24 - 1);\n-\n-  \/\/ Combine sign, exponent and significand bits\n-  bits.i = (hf_sign_bit << 16) | float_exp_bits |\n-           (hf_significand_bits << significand_shift);\n-\n-  return bits.f;\n-JRT_END\n@@ -3140,1 +3049,3 @@\n-                  CodeCache::flush_dependents_on_method(mh);\n+                  DeoptimizationScope deopt_scope;\n+                  CodeCache::mark_for_deoptimization(&deopt_scope, mh());\n+                  deopt_scope.deoptimize_marked();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":3,"deletions":92,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -132,2 +132,0 @@\n-  static jfloat  hf2f(jshort  x);\n-  static jshort  f2hf(jfloat  x);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -174,0 +174,3 @@\n+address StubRoutines::_f2hf = nullptr;\n+address StubRoutines::_hf2f = nullptr;\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -252,0 +252,3 @@\n+  static address _f2hf;\n+  static address _hf2f;\n+\n@@ -430,0 +433,18 @@\n+  \/\/ These are versions of the java.lang.Float::floatToFloat16() and float16ToFloat()\n+  \/\/ methods which perform the same operations as the intrinsic version.\n+  \/\/ They are used for constant folding in JIT compiler to ensure equivalence.\n+  \/\/\n+  static address f2hf_adr()            { return _f2hf; }\n+  static address hf2f_adr()            { return _hf2f; }\n+\n+  static jshort f2hf(jfloat x) {\n+    assert(_f2hf != nullptr, \"stub is not implemented on this platform\");\n+    typedef jshort (*f2hf_stub_t)(jfloat x);\n+    return ((f2hf_stub_t)_f2hf)(x);\n+  }\n+  static jfloat hf2f(jshort x) {\n+    assert(_hf2f != nullptr, \"stub is not implemented on this platform\");\n+    typedef jfloat (*hf2f_stub_t)(jshort x);\n+    return ((hf2f_stub_t)_hf2f)(x);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1253,0 +1253,1 @@\n+\n@@ -1254,0 +1255,14 @@\n+\/\/\n+\/\/ C++14 5.8\/3: In the description of \"E1 >> E2\" it says \"If E1 has a signed type\n+\/\/ and a negative value, the resulting value is implementation-defined.\"\n+\/\/\n+\/\/ However, C++20 7.6.7\/3 further defines integral arithmetic, as part of\n+\/\/ requiring two's-complement behavior.\n+\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0907r3.html\n+\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p1236r1.html\n+\/\/ The corresponding C++20 text is \"Right-shift on signed integral types is an\n+\/\/ arithmetic right shift, which performs sign-extension.\"\n+\/\/\n+\/\/ As discussed in the two's complement proposal, all known modern C++ compilers\n+\/\/ already behave that way. And it is unlikely any would go off and do something\n+\/\/ different now, with C++20 tightening things up.\n@@ -1284,0 +1299,32 @@\n+\/\/ Taken from rom section 8-2 of Henry S. Warren, Jr., Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n+inline uint64_t multiply_high_unsigned(const uint64_t x, const uint64_t y) {\n+  const uint64_t x1 = x >> 32u;\n+  const uint64_t x2 = x & 0xFFFFFFFF;\n+  const uint64_t y1 = y >> 32u;\n+  const uint64_t y2 = y & 0xFFFFFFFF;\n+  const uint64_t z2 = x2 * y2;\n+  const uint64_t t = x1 * y2 + (z2 >> 32u);\n+  uint64_t z1 = t & 0xFFFFFFFF;\n+  const uint64_t z0 = t >> 32u;\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + (z1 >> 32u);\n+}\n+\n+\/\/ Taken from java.lang.Math::multiplyHigh which uses the technique from section 8-2 of Henry S. Warren, Jr.,\n+\/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174 but adapted for signed longs.\n+inline int64_t multiply_high_signed(const int64_t x, const int64_t y) {\n+  const jlong x1 = java_shift_right((jlong)x, 32);\n+  const jlong x2 = x & 0xFFFFFFFF;\n+  const jlong y1 = java_shift_right((jlong)y, 32);\n+  const jlong y2 = y & 0xFFFFFFFF;\n+\n+  const uint64_t z2 = x2 * y2;\n+  const int64_t t = x1 * y2 + (z2 >> 32u); \/\/ Unsigned shift\n+  int64_t z1 = t & 0xFFFFFFFF;\n+  const int64_t z0 = java_shift_right((jlong)t, 32);\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + java_shift_right((jlong)z1, 32);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -813,1 +813,1 @@\n-     * witness value was not the same as the {@code expectedValue}.\n+     * <em>witness value<\/em> was not the same as the {@code expectedValue}.\n@@ -846,1 +846,1 @@\n-     * @return the signature-polymorphic result that is the witness value, which\n+     * @return the signature-polymorphic result that is the <em>witness value<\/em>, which\n@@ -881,1 +881,1 @@\n-     * @return the signature-polymorphic result that is the witness value, which\n+     * @return the signature-polymorphic result that is the <em>witness value<\/em>, which\n@@ -916,1 +916,1 @@\n-     * @return the signature-polymorphic result that is the witness value, which\n+     * @return the signature-polymorphic result that is the <em>witness value<\/em>, which\n@@ -943,1 +943,1 @@\n-     * contention) even if the witness value does match the expected value.\n+     * contention) even if the <em>witness value<\/em> does match the expected value.\n@@ -956,1 +956,1 @@\n-     * witness value was not the same as the {@code expectedValue} or if this\n+     * <em>witness value<\/em> was not the same as the {@code expectedValue} or if this\n@@ -980,1 +980,1 @@\n-     * contention) even if the witness value does match the expected value.\n+     * contention) even if the <em>witness value<\/em> does match the expected value.\n@@ -993,1 +993,1 @@\n-     * witness value was not the same as the {@code expectedValue} or if this\n+     * <em>witness value<\/em> was not the same as the {@code expectedValue} or if this\n@@ -1017,1 +1017,1 @@\n-     * contention) even if the witness value does match the expected value.\n+     * contention) even if the <em>witness value<\/em> does match the expected value.\n@@ -1031,1 +1031,1 @@\n-     * witness value was not the same as the {@code expectedValue} or if this\n+     * <em>witness value<\/em> was not the same as the {@code expectedValue} or if this\n@@ -1055,1 +1055,1 @@\n-     * contention) even if the witness value does match the expected value.\n+     * contention) even if the <em>witness value<\/em> does match the expected value.\n@@ -1069,1 +1069,1 @@\n-     * witness value was not the same as the {@code expectedValue} or if this\n+     * <em>witness value<\/em> was not the same as the {@code expectedValue} or if this\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+        jdk.jartool, \/\/ participates in preview features\n@@ -192,1 +193,1 @@\n-    exports jdk.internal.org.objectweb.asm to\n+    exports jdk.internal.classfile to\n@@ -194,1 +195,0 @@\n-        jdk.jfr,\n@@ -197,0 +197,9 @@\n+    exports jdk.internal.classfile.attribute to\n+        jdk.jartool;\n+    exports jdk.internal.classfile.constantpool to\n+        jdk.jartool;\n+    exports jdk.internal.classfile.instruction to\n+        jdk.jshell;\n+    exports jdk.internal.org.objectweb.asm to\n+        jdk.jfr,\n+        jdk.jlink;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -879,2 +879,2 @@\n-                        types.rank(that.type) == types.rank(this.type) &&\n-                        that.getQualifiedName().compareTo(this.getQualifiedName()) < 0;\n+                        (types.rank(that.type) == types.rank(this.type) &&\n+                         that.getQualifiedName().compareTo(this.getQualifiedName()) < 0);\n@@ -1356,1 +1356,1 @@\n-                new ClassType(Type.noType, null, null, TypeMetadata.EMPTY, Flavor.X_Typeof_X),\n+                new ClassType(Type.noType, null, null, List.nil(), Flavor.X_Typeof_X),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.Optional;\n@@ -39,1 +40,2 @@\n-import com.sun.tools.javac.code.TypeMetadata.Entry;\n+import com.sun.tools.javac.code.TypeMetadata.Annotations;\n+import com.sun.tools.javac.code.TypeMetadata.ConstantValue;\n@@ -90,9 +92,1 @@\n-    protected final TypeMetadata metadata;\n-\n-    public TypeMetadata getMetadata() {\n-        return metadata;\n-    }\n-\n-    public Entry getMetadataOfKind(final Entry.Kind kind) {\n-        return metadata != null ? metadata.get(kind) : null;\n-    }\n+    protected final List<TypeMetadata> metadata;\n@@ -192,1 +186,2 @@\n-        return null;\n+        return getMetadata(TypeMetadata.ConstantValue.class)\n+                .map(ConstantValue::value).orElse(null);\n@@ -234,1 +229,1 @@\n-    public Type(TypeSymbol tsym, TypeMetadata metadata) {\n+    public Type(TypeSymbol tsym, List<TypeMetadata> metadata) {\n@@ -418,1 +413,1 @@\n-        return metadata == TypeMetadata.EMPTY ? this : baseType();\n+        return metadata.isEmpty() ? this : baseType();\n@@ -423,0 +418,1 @@\n+     * Only to be used internally!\n@@ -424,1 +420,40 @@\n-    public abstract Type cloneWithMetadata(TypeMetadata metadata);\n+    protected Type cloneWithMetadata(List<TypeMetadata> metadata) {\n+        throw new AssertionError(\"Cannot add metadata to this type: \" + getTag());\n+    }\n+\n+    \/**\n+     * Get all the type metadata associated with this type.\n+     *\/\n+    public List<TypeMetadata> getMetadata() {\n+        return metadata;\n+    }\n+\n+    \/**\n+     * Get the type metadata of the given kind associated with this type (if any).\n+     *\/\n+    public <M extends TypeMetadata> Optional<M> getMetadata(Class<M> metadataClass) {\n+        return metadata.stream()\n+                .filter(m -> metadataClass.isAssignableFrom(m.getClass()))\n+                .map(metadataClass::cast)\n+                .findFirst();\n+    }\n+\n+    \/**\n+     * Create a new copy of this type but with the specified type metadata.\n+     * If this type is already associated with a type metadata of the same class,\n+     * an exception is thrown.\n+     *\/\n+    public Type addMetadata(TypeMetadata md) {\n+        Assert.check(getMetadata(md.getClass()).isEmpty());\n+        return cloneWithMetadata(metadata.append(md));\n+    }\n+\n+    \/**\n+     * Create a new copy of this type but without the specified type metadata.\n+     *\/\n+    public Type dropMetadata(Class<? extends TypeMetadata> metadataClass) {\n+        List<TypeMetadata> newMetadata = metadata.stream()\n+                .filter(m -> !metadataClass.isAssignableFrom(m.getClass()))\n+                .collect(List.collector());\n+        return cloneWithMetadata(newMetadata);\n+    }\n@@ -471,0 +506,4 @@\n+    public Type preannotatedType() {\n+        return addMetadata(new Annotations());\n+    }\n+\n@@ -472,2 +511,1 @@\n-        final Entry annoMetadata = new TypeMetadata.Annotations(annos);\n-        return cloneWithMetadata(metadata.combine(annoMetadata));\n+        return addMetadata(new Annotations(annos));\n@@ -477,4 +515,1 @@\n-        final TypeMetadata.Annotations metadata =\n-            (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);\n-\n-        return null != metadata && !metadata.getAnnotations().isEmpty();\n+        return getMetadata(TypeMetadata.Annotations.class).isPresent();\n@@ -485,4 +520,2 @@\n-        final TypeMetadata.Annotations metadata =\n-            (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);\n-\n-        return metadata == null ? List.nil() : metadata.getAnnotations();\n+        return getMetadata(TypeMetadata.Annotations.class)\n+                .map(Annotations::annotations).orElse(List.nil());\n@@ -761,1 +794,1 @@\n-            this(tag, tsym, TypeMetadata.EMPTY);\n+            this(tag, tsym, List.nil());\n@@ -764,1 +797,1 @@\n-        private JCPrimitiveType(TypeTag tag, TypeSymbol tsym, TypeMetadata metadata) {\n+        private JCPrimitiveType(TypeTag tag, TypeSymbol tsym, List<TypeMetadata> metadata) {\n@@ -771,1 +804,1 @@\n-        public JCPrimitiveType cloneWithMetadata(TypeMetadata md) {\n+        protected JCPrimitiveType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -817,11 +850,1 @@\n-            final Object value = constValue;\n-            return new JCPrimitiveType(tag, tsym, metadata) {\n-                    @Override\n-                    public Object constValue() {\n-                        return value;\n-                    }\n-                    @Override\n-                    public Type baseType() {\n-                        return tsym.type;\n-                    }\n-                };\n+            return addMetadata(new ConstantValue(constValue));\n@@ -902,1 +925,1 @@\n-            this(type, kind, tsym, null, TypeMetadata.EMPTY);\n+            this(type, kind, tsym, null, List.nil());\n@@ -906,1 +929,1 @@\n-                            TypeMetadata metadata) {\n+                            List<TypeMetadata> metadata) {\n@@ -912,1 +935,1 @@\n-            this(type, kind, tsym, bound, TypeMetadata.EMPTY);\n+            this(type, kind, tsym, bound, List.nil());\n@@ -916,1 +939,1 @@\n-                            TypeVar bound, TypeMetadata metadata) {\n+                            TypeVar bound, List<TypeMetadata> metadata) {\n@@ -924,1 +947,1 @@\n-        public WildcardType cloneWithMetadata(TypeMetadata md) {\n+        protected WildcardType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -1176,1 +1199,5 @@\n-            this(outer, typarams, tsym, TypeMetadata.EMPTY, Flavor.L_TypeOf_L);\n+            this(outer, typarams, tsym, List.nil(), Flavor.L_TypeOf_L);\n+        }\n+\n+        public ClassType(Type outer, List<Type> typarams, TypeSymbol tsym, Flavor flavor) {\n+            this(outer, typarams, tsym, List.nil(), flavor);\n@@ -1180,1 +1207,1 @@\n-                         TypeMetadata metadata, Flavor flavor) {\n+                         List<TypeMetadata> metadata, Flavor flavor) {\n@@ -1195,1 +1222,1 @@\n-        public ClassType cloneWithMetadata(TypeMetadata md) {\n+        public ClassType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -1213,11 +1240,1 @@\n-            final Object value = constValue;\n-            return new ClassType(getEnclosingType(), typarams_field, tsym, metadata, flavor) {\n-                    @Override\n-                    public Object constValue() {\n-                        return value;\n-                    }\n-                    @Override\n-                    public Type baseType() {\n-                        return tsym.type;\n-                    }\n-                };\n+            return addMetadata(new ConstantValue(constValue));\n@@ -1481,1 +1498,1 @@\n-                               TypeMetadata metadata) {\n+                               List<TypeMetadata> metadata) {\n@@ -1506,5 +1523,0 @@\n-        @Override\n-        public UnionClassType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a union type\");\n-        }\n-\n@@ -1562,5 +1574,0 @@\n-        @Override\n-        public IntersectionClassType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to an intersection type\");\n-        }\n-\n@@ -1609,1 +1616,1 @@\n-            this(elemtype, arrayClass, TypeMetadata.EMPTY);\n+            this(elemtype, arrayClass, List.nil());\n@@ -1613,1 +1620,1 @@\n-                         TypeMetadata metadata) {\n+                         List<TypeMetadata> metadata) {\n@@ -1629,1 +1636,1 @@\n-        public ArrayType cloneWithMetadata(TypeMetadata md) {\n+        protected ArrayType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -1754,1 +1761,1 @@\n-            super(methodClass, TypeMetadata.EMPTY);\n+            super(methodClass, List.nil());\n@@ -1760,5 +1767,0 @@\n-        @Override\n-        public MethodType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a method type\");\n-        }\n-\n@@ -1851,6 +1853,1 @@\n-            super(tsym, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public PackageType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a package type\");\n+            super(tsym, List.nil());\n@@ -1889,6 +1886,1 @@\n-            super(tsym, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public ModuleType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a module type\");\n+            super(tsym, List.nil());\n@@ -1950,1 +1942,1 @@\n-            super(null, TypeMetadata.EMPTY);\n+            super(null, List.nil());\n@@ -1958,1 +1950,1 @@\n-            this(tsym, bound, lower, TypeMetadata.EMPTY);\n+            this(tsym, bound, lower, List.nil());\n@@ -1962,1 +1954,1 @@\n-                       TypeMetadata metadata) {\n+                       List<TypeMetadata> metadata) {\n@@ -1970,1 +1962,1 @@\n-        public TypeVar cloneWithMetadata(TypeMetadata md) {\n+        protected TypeVar cloneWithMetadata(List<TypeMetadata> md) {\n@@ -2053,1 +2045,1 @@\n-                            TypeMetadata metadata) {\n+                            List<TypeMetadata> metadata) {\n@@ -2059,1 +2051,1 @@\n-        public CapturedType cloneWithMetadata(TypeMetadata md) {\n+        protected CapturedType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -2098,1 +2090,1 @@\n-            this(tag, qtype, TypeMetadata.EMPTY);\n+            this(tag, qtype, List.nil());\n@@ -2102,1 +2094,1 @@\n-                             TypeMetadata metadata) {\n+                             List<TypeMetadata> metadata) {\n@@ -2135,5 +2127,0 @@\n-        @Override\n-        public ForAll cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a forall type\");\n-        }\n-\n@@ -2368,5 +2355,0 @@\n-        @Override\n-        public UndetVar cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to an UndetVar type\");\n-        }\n-\n@@ -2515,6 +2497,1 @@\n-            super(null, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public JCNoType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a JCNoType\");\n+            super(null, List.nil());\n@@ -2548,6 +2525,1 @@\n-            super(null, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public JCVoidType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a void type\");\n+            super(null, List.nil());\n@@ -2583,6 +2555,1 @@\n-            super(null, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public BottomType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a bottom type\");\n+            super(null, List.nil());\n@@ -2639,1 +2606,1 @@\n-            super(noType, List.nil(), tsym, TypeMetadata.EMPTY, Flavor.E_Typeof_X);\n+            super(noType, List.nil(), tsym, List.nil(), Flavor.E_Typeof_X);\n@@ -2644,1 +2611,1 @@\n-                          TypeMetadata metadata, Flavor flavor) {\n+                          List<TypeMetadata> metadata, Flavor flavor) {\n@@ -2651,1 +2618,1 @@\n-        public ErrorType cloneWithMetadata(TypeMetadata md) {\n+        public ErrorType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -2722,6 +2689,1 @@\n-            super(null, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public UnknownType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to an unknown type\");\n+            super(null, List.nil());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":97,"deletions":135,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;\n+import com.sun.tools.javac.code.TypeMetadata.Annotations;\n@@ -2521,1 +2521,1 @@\n-                if (t.getMetadata() != TypeMetadata.EMPTY) {\n+                if (t.getMetadata().nonEmpty()) {\n@@ -2532,1 +2532,1 @@\n-                        default: return s.cloneWithMetadata(s.getMetadata().without(Kind.ANNOTATIONS));\n+                        default: return s.dropMetadata(Annotations.class);\n@@ -2570,1 +2570,1 @@\n-                                t.getMetadata().without(Kind.ANNOTATIONS));\n+                                                     t.dropMetadata(Annotations.class).getMetadata());\n@@ -2996,1 +2996,1 @@\n-     * The resulting preferred method has a thrown clause that is the intersection of the merged\n+     * The resulting preferred method has a throws clause that is the intersection of the merged\n@@ -3825,1 +3825,1 @@\n-     * (that is, subclasses come first, arbitrary but fixed\n+     * (that is, subclasses come first, arbitrarily but fixed\n@@ -4016,1 +4016,1 @@\n-                                 class1.tsym, TypeMetadata.EMPTY, class1.getFlavor());\n+                                 class1.tsym, List.nil(), class1.getFlavor());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import com.sun.tools.javac.code.TypeMetadata.Annotations;\n@@ -5311,1 +5310,1 @@\n-        Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);\n+        Type annotatedType = underlyingType.preannotatedType();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1221,1 +1221,1 @@\n-                \/\/ add intersection of all thrown clauses of initial constructors\n+                \/\/ add intersection of all throws clauses of initial constructors\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -506,1 +506,1 @@\n-         *  @site          The type of the qualifier\n+         *  @param site    The type of the qualifier\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,1 +251,1 @@\n-     * @Target\n+     * {@code @Target}\n@@ -257,1 +257,1 @@\n-     * @Repeatable\n+     * {@code @Repeatable}\n@@ -594,1 +594,1 @@\n-                    return new ClassType(outer, List.nil(), t, TypeMetadata.EMPTY, flavor);\n+                    return new ClassType(outer, List.nil(), t, List.nil(), flavor);\n@@ -606,1 +606,1 @@\n-                outer = new ClassType(outer, sigToTypes('>'), t, TypeMetadata.EMPTY, flavor) {\n+                outer = new ClassType(outer, sigToTypes('>'), t, List.nil(), flavor) {\n@@ -671,1 +671,1 @@\n-                    outer = new ClassType(outer, List.nil(), t, TypeMetadata.EMPTY, flavor);\n+                    outer = new ClassType(outer, List.nil(), t, List.nil(), flavor);\n@@ -3010,1 +3010,1 @@\n-            super(syms.noSymbol, TypeMetadata.EMPTY);\n+            super(syms.noSymbol, List.nil());\n@@ -3019,5 +3019,0 @@\n-        @Override\n-        public Type cloneWithMetadata(TypeMetadata metadata) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1673,1 +1673,3 @@\n-        if (preview.isEnabled() && preview.usesPreview(c.sourcefile)) {\n+        if (preview.isEnabled() && preview.usesPreview(c.sourcefile)\n+                \/\/ do not write PREVIEW_MINOR_VERSION for classes participating in preview\n+                && !preview.participatesInPreview(syms, c, syms.java_base.unnamedPackage)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-            return (DeclaredType) new Type.ClassType(outer, targs.toList(), sym, TypeMetadata.EMPTY, sym.type.getFlavor());\n+            return (DeclaredType) new Type.ClassType(outer, targs.toList(), sym, sym.type.getFlavor());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1340,1 +1340,1 @@\n-                            cs.type = new ClassType(cs.type.getEnclosingType(), null, cs, TypeMetadata.EMPTY, Flavor.X_Typeof_X);\n+                            cs.type = new ClassType(cs.type.getEnclosingType(), null, cs, List.nil(), Flavor.X_Typeof_X);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+compiler\/vectorapi\/VectorLogicalOpIdentityTest.java 8302459 linux-x64,windows-x64\n+\n@@ -127,0 +129,1 @@\n+serviceability\/sa\/UniqueVtableTest.java 8303921 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -169,0 +169,5 @@\n+    public static final String ADD_VF = PREFIX + \"ADD_VF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VF, \"AddVF\");\n+    }\n+\n@@ -184,0 +189,10 @@\n+    public static final String ADD_REDUCTION_VI = PREFIX + \"ADD_REDUCTION_VI\" + POSTFIX;\n+    static {\n+        superWordNodes(ADD_REDUCTION_VI, \"AddReductionVI\");\n+    }\n+\n+    public static final String ADD_REDUCTION_VL = PREFIX + \"ADD_REDUCTION_VL\" + POSTFIX;\n+    static {\n+        superWordNodes(ADD_REDUCTION_VL, \"AddReductionVL\");\n+    }\n+\n@@ -233,0 +248,5 @@\n+    public static final String AND_REDUCTION_V = PREFIX + \"AND_REDUCTION_V\" + POSTFIX;\n+    static {\n+        superWordNodes(AND_REDUCTION_V, \"AndReductionV\");\n+    }\n+\n@@ -702,0 +722,5 @@\n+    public static final String MUL_VI = PREFIX + \"MUL_VI\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VI, \"MulVI\");\n+    }\n+\n@@ -712,0 +737,10 @@\n+    public static final String MUL_REDUCTION_VI = PREFIX + \"MUL_REDUCTION_VI\" + POSTFIX;\n+    static {\n+        superWordNodes(MUL_REDUCTION_VI, \"MulReductionVI\");\n+    }\n+\n+    public static final String MUL_REDUCTION_VL = PREFIX + \"MUL_REDUCTION_VL\" + POSTFIX;\n+    static {\n+        superWordNodes(MUL_REDUCTION_VL, \"MulReductionVL\");\n+    }\n+\n@@ -737,0 +772,5 @@\n+    public static final String OR_REDUCTION_V = PREFIX + \"OR_REDUCTION_V\" + POSTFIX;\n+    static {\n+        superWordNodes(OR_REDUCTION_V, \"OrReductionV\");\n+    }\n+\n@@ -1356,0 +1396,5 @@\n+    public static final String XOR_REDUCTION_V = PREFIX + \"XOR_REDUCTION_V\" + POSTFIX;\n+    static {\n+        superWordNodes(XOR_REDUCTION_V, \"XorReductionV\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -540,0 +540,2 @@\n+java\/net\/SocketOption\/OptionsTest.java                          8304286 windows-all\n+\n@@ -611,1 +613,0 @@\n-sun\/security\/provider\/certpath\/OCSP\/OCSPNoContentLength.java    8300939 generic-all\n@@ -667,0 +668,3 @@\n+javax\/swing\/JColorChooser\/Test6827032.java 8224968 windows-x64\n+java\/awt\/dnd\/MissingDragExitEventTest\/MissingDragExitEventTest.java 8288839 windows-x64\n+\n@@ -757,0 +761,5 @@\n+jdk\/classfile\/SwapTest.java                                     8308778 generic-all\n+jdk\/classfile\/LowAdaptTest.java                                 8308778 generic-all\n+jdk\/classfile\/BuilderBlockTest.java                             8308778 generic-all\n+jdk\/classfile\/BuilderTryCatchTest.java                          8308778 generic-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-#  Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+    jdk\/classfile \\\n@@ -228,1 +229,0 @@\n-    com\/sun\/jarsigner \\\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,7 @@\n+jdk\/jshell\/UserExecutionControlTest.java                                        8308779    generic-all\n+jdk\/jshell\/ToolLocalSimpleTest.java                                             8308779    generic-all\n+jdk\/jshell\/SimpleRegressionTest.java                                            8308779    generic-all\n+jdk\/jshell\/ExecutionControlSpecTest.java                                        8308779    generic-all\n+jdk\/jshell\/ExceptionMessageTest.java                                            8308779    generic-all\n+jdk\/jshell\/ClassMembersTest.java                                                8308779    generic-all\n+\n","filename":"test\/langtools\/ProblemList.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}