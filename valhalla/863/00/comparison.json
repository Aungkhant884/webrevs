{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -510,1 +510,1 @@\n-            format_helper(regalloc, st, init_node, \":\", -1, NULL);\n+            format_helper(regalloc, st, init_node, \":\", -2, NULL);\n@@ -512,0 +512,5 @@\n+\n+          Node* larval_node = mcall->in(first_ind++);\n+          assert(larval_node != NULL && larval_node->is_Con(), \"is_larval node not found\");\n+          st->print(\" [is_larval\");\n+          format_helper(regalloc, st, larval_node, \":\", -1, NULL);\n@@ -513,1 +518,1 @@\n-        Node* fld_node = mcall->in(first_ind);\n+\n@@ -515,10 +520,3 @@\n-        if (iklass != NULL) {\n-          st->print(\" [\");\n-          cifield = iklass->nonstatic_field_at(0);\n-          cifield->print_name_on(st);\n-          format_helper(regalloc, st, fld_node, \":\", 0, &scobjs);\n-        } else {\n-          format_helper(regalloc, st, fld_node, \"[\", 0, &scobjs);\n-        }\n-        for (uint j = 1; j < nf; j++) {\n-          fld_node = mcall->in(first_ind+j);\n+        uint sec_fields_count = 0;\n+        for (uint j = 0; j < nf; j++) {\n+          Node* fld_node = mcall->in(first_ind + j);\n@@ -526,2 +524,2 @@\n-            st->print(\", [\");\n-            cifield = iklass->nonstatic_field_at(j);\n+            st->print(\" [\");\n+            cifield = iklass->nonstatic_field_at(j - sec_fields_count);\n@@ -530,0 +528,15 @@\n+            sec_fields_count = 0;\n+            if (cifield->is_multifield_base() && !fld_node->bottom_type()->isa_vect()) {\n+              sec_fields_count = cifield->secondary_fields_count() - 1;\n+              for (uint f = 0; f < sec_fields_count; f++) {\n+                st->print(\" [\");\n+                fld_node = mcall->in(first_ind + j + f + 1);\n+                ciField* sec_field = static_cast<ciMultiField*>(cifield)->secondary_field_at(f);\n+                sec_field->print_name_on(st);\n+                format_helper(regalloc, st, fld_node, \":\", j + f + 1, &scobjs);\n+                if (f < sec_fields_count - 1) {\n+                  st->print(\",\");\n+                }\n+              }\n+              j += sec_fields_count;\n+            }\n@@ -531,1 +544,5 @@\n-            format_helper(regalloc, st, fld_node, \", [\", j, &scobjs);\n+            format_helper(regalloc, st, fld_node, \" [\", j, &scobjs);\n+          }\n+\n+          if (j < nf - 1) {\n+            st->print(\",\");\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":33,"deletions":16,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -302,0 +302,27 @@\n+  uint sec_nfields = 0;\n+  Node_List fields;\n+\n+  \/\/ Iterate over the inline type fields in the order of increasing\n+  \/\/ offset and add them to the \"fields\" list.\n+  for (uint j = 0; j < nfields; j++) {\n+    ciField* field = vk->nonstatic_field_at(j);\n+    Node* value = field_value_by_offset(field->offset(), true \/* include flattened inline type fields *\/);\n+    fields.push(value);\n+\n+    if (value->is_InlineType()) {\n+      \/\/ Add inline type field to the worklist to process later.\n+      worklist.push(value);\n+    } else if (field->is_multifield_base() && !value->bottom_type()->isa_vect()) {\n+      \/\/ Add un-vectorized multi-fields to the \"fields\" list. These\n+      \/\/ multi-fields should be passed to safepoint as well.\n+      sec_nfields += field->secondary_fields_count() - 1;\n+      for (int i = 0; i < field->secondary_fields_count() - 1; i++) {\n+        ciField* sec_field = static_cast<ciMultiField*>(field)->secondary_field_at(i);\n+        assert(sec_field != nullptr, \"\");\n+        value = field_value_by_offset(sec_field->offset(), true);\n+        assert(!value->is_InlineType(), \"\");\n+        fields.push(value);\n+      }\n+    }\n+  }\n+\n@@ -310,1 +337,1 @@\n-                                                                  first_ind, nfields);\n+                                                                  first_ind, nfields + sec_nfields);\n@@ -323,10 +350,3 @@\n-  \/\/ Iterate over the inline type fields in order of increasing\n-  \/\/ offset and add the field values to the safepoint.\n-  for (uint j = 0; j < nfields; ++j) {\n-    int offset = vk->nonstatic_field_at(j)->offset();\n-    Node* value = field_value_by_offset(offset, true \/* include flattened inline type fields *\/);\n-    if (value->is_InlineType()) {\n-      \/\/ Add inline type field to the worklist to process later\n-      worklist.push(value);\n-    }\n-    sfpt->add_req(value);\n+  \/\/ Add the field values to the safepoint.\n+  for (uint i = 0; i < fields.size(); ++i) {\n+    sfpt->add_req(fields.at(i));\n@@ -334,0 +354,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -302,0 +302,3 @@\n+  assert(ov->field_size() == 1, \"%s not a vector\", ik->name()->as_C_string());\n+  assert(ik->is_inline_klass(), \"\");\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,0 @@\n-  static void init_payload_element(typeArrayOop arr, BasicType elem_bt, int index, address addr);\n-\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1144,1 +1144,9 @@\n-        if (EnableVectorSupport && VectorSupport::is_vector(ik)) {\n+        bool is_vector = false;\n+        if (sv->field_size() > 0) {\n+          ScopeValue* field = sv->field_at(0);\n+          if (field->is_location() &&\n+              field->as_LocationValue()->location().type() == Location::vector) {\n+            is_vector = true;\n+          }\n+        }\n+        if (is_vector && VectorSupport::is_vector(ik)) {\n@@ -1146,1 +1154,1 @@\n-        } else if (EnableVectorSupport && VectorSupport::is_vector_payload_mf(ik)) {\n+        } else if (is_vector && VectorSupport::is_vector_payload_mf(ik)) {\n@@ -1548,2 +1556,1 @@\n-    if (EnableVectorSupport && (VectorSupport::is_vector(k) || VectorSupport::is_vector_payload_mf(k))) {\n-      assert(sv->field_size() == 1, \"%s not a vector\", k->name()->as_C_string());\n+    if (VectorSupport::is_vector(k) || VectorSupport::is_vector_payload_mf(k)) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"}]}