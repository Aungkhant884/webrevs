{"files":[{"patch":"@@ -0,0 +1,758 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8292817\n+ * @summary add binary compatibility tests for value objects\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ValueObjectsBinaryCompatibilityTests\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavaTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+\n+public class ValueObjectsBinaryCompatibilityTests extends TestRunner {\n+    ToolBox tb;\n+\n+    ValueObjectsBinaryCompatibilityTests() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ValueObjectsBinaryCompatibilityTests().runTests();\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    \/* 1- compiles the first version of the source code, code1, along with the client source code\n+     * 2- executes the client class just to make sure that it works, sanity check\n+     * 3- compiles the second version, code2\n+     * 4- executes the client class and makes sure that the VM throws the expected error or not\n+     *    depending on the shouldFail argument\n+     *\/\n+    private void testCompatibilityAfterChange(\n+            Path base,\n+            String code1,\n+            String code2,\n+            String clientCode,\n+            boolean shouldFail,\n+            Class<?> expectedError) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path pkg = src.resolve(\"pkg\");\n+        Path src1 = pkg.resolve(\"Test\");\n+        Path client = pkg.resolve(\"Client\");\n+\n+        tb.writeJavaFiles(src1, code1);\n+        tb.writeJavaFiles(client, clientCode);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(findJavaFiles(pkg))\n+                .run();\n+\n+        \/\/ let's execute to check that it's working\n+        String output = new JavaTask(tb)\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Client\")\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDOUT);\n+\n+        \/\/ let's first check that it runs wo issues\n+        if (!output.contains(\"Hello World!\")) {\n+            throw new AssertionError(\"execution of Client didn't finish\");\n+        }\n+\n+        \/\/ now lets change the first class\n+        tb.writeJavaFiles(src1, code2);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(findJavaFiles(src1))\n+                .run();\n+\n+        if (shouldFail) {\n+            \/\/ let's now check that we get the expected error\n+            output = new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"pkg.Client\")\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.STDERR);\n+            if (!output.contains(expectedError.getName())) {\n+                throw new AssertionError(expectedError.getName() + \" expected\");\n+            }\n+        } else {\n+            new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"pkg.Client\")\n+                    .run(Task.Expect.SUCCESS);\n+        }\n+    }\n+\n+    @Test\n+    public void testAbstractClassCompatibility(Path base) throws Exception {\n+        \/* If one of the identity or value modifiers is added to an abstract class, a pre-existing binary that attempts\n+         * to extend the class may fail to load. Specifically, if the subclass has an incompatible identity or value\n+         * modifier, or implements an interface with an incompatible identity or value modifier, class loading will fail\n+         * with an IncompatibleClassChangeError.\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract identity class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                IncompatibleClassChangeError.class\n+        );\n+\n+        \/\/ another variation of the assertion above\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract value class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                IncompatibleClassChangeError.class\n+        );\n+\n+        \/\/ Removing one of the identity or value modifiers from an abstract class does not break compatibility with pre-existing binaries.\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract identity class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                false,\n+                null\n+        );\n+\n+        \/\/ another variation of the assertion above\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract value class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                false,\n+                null\n+        );\n+\n+        \/* Changing an identity class that is declared abstract to no longer be declared abstract does not break\n+         * compatibility with pre-existing binaries.\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract identity class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                false,\n+                null\n+        );\n+\n+        \/\/ another variation of the assertion above\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract identity class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                false,\n+                null\n+        );\n+\n+        \/* Modifying a non-abstract identity class to be a value class is a binary compatible change, as long as the class\n+         * is already final and all its constructors are private. If the class is not final, declaring it a value class\n+         * has the effect of declaring the class final (13.4.2.3). If the class has a non-private constructor,\n+         * pre-existing binaries that attempt to invoke that constructor will behave as if the constructor had been\n+         * removed (13.4.12).\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public final identity class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class Client {\n+                    public static void main(String... args) {\n+                        A a = new A();\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                InstantiationError.class\n+        );\n+\n+        \/\/ another variation of the assertion above\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public identity class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                IncompatibleClassChangeError.class\n+        );\n+\n+        \/* Modifying a non-abstract value class to be an identity class is a binary compatible change, as long as all\n+         * of the class's constructors are private. If the class has a non-private constructor, pre-existing binaries\n+         * that attempt to invoke that constructor will behave as if the constructor had been removed\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public value class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class Client {\n+                    public static void main(String... args) {\n+                        A a = new A();\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                NoSuchMethodError.class\n+        );\n+    }\n+\n+    @Test\n+    public void testFieldCompatibility(Path base) throws Exception {\n+        \/* Adding an instance field to an abstract class that is not an identity class also has the side-effect of\n+         * making the class an identity class\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    int i;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                IncompatibleClassChangeError.class\n+        );\n+\n+        \/\/ another variation of the assertion above\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    static int i; \/\/ OK no instance field\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                false,\n+                null\n+        );\n+\n+        \/* Removing a static modifier from a field of an abstract class that is not an identity class also has the\n+         * side-effect of making the class an identity class\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    static int i;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    int i;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                IncompatibleClassChangeError.class\n+        );\n+    }\n+\n+    @Test\n+    public void testSynchronizedCompatibility(Path base) throws Exception {\n+        \/* Adding a synchronized modifier to a method of an identity class does not break compatibility with\n+         * pre-existing binaries\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public identity class A {\n+                    void m() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class A {\n+                    synchronized void m() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                false,\n+                null\n+        );\n+\n+        \/* Adding a synchronized modifier to a method of an abstract class that is not an identity class has the\n+         * side-effect of making the class an identity class\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    void m() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    synchronized void m() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                IncompatibleClassChangeError.class\n+        );\n+\n+        \/* Deleting a synchronized modifier of a method does not break compatibility with pre-existing binaries\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    synchronized void m() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    void m() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                false,\n+                null\n+        );\n+    }\n+\n+    @Test\n+    public void testConstructorCompatibility(Path base) throws Exception {\n+        \/* Adding a throws clause to the constructor of an abstract class that is not an identity class has the\n+         * side-effect of making the class an identity class\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    public A() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    public A() throws Exception {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                IncompatibleClassChangeError.class\n+        );\n+\n+        \/* changes to the body of the constructor of an abstract class that is not an identity class, other than adding\n+         * or removing the super(); call, have the side-effect of making the class an identity class\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    public A() { super(); }\n+                    void m() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    public A() { super(); m(); }\n+                    void m() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                IncompatibleClassChangeError.class\n+        );\n+\n+        \/* Adding type parameters to the constructor of an abstract class that is not an identity class has the\n+         * side-effect of making the class an identity class\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    public A() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    public <T> A() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                IncompatibleClassChangeError.class\n+        );\n+\n+        \/* Changing the declared access of the constructor of an abstract class that is not an identity class to permit\n+         * less access may also have the side-effect of making the class an identity class\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    public A() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public abstract class A {\n+                    \/\/ this constructor has less access than the class so it will be considered an identity class\n+                    protected A() {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class Client extends A {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                IncompatibleClassChangeError.class  \/\/currently failing with this error, but the spec mentions NoSuchMethodError\n+        );\n+    }\n+\n+    @Test\n+    public void testInterfaceCompatibility(Path base) throws Exception {\n+        \/* If one of the identity or value modifiers is added to an interface, a pre-existing binary that attempts to\n+         * extend or implement the interface may fail to load. Specifically, if the subclass or subinterface has an\n+         * incompatible identity or value modifier, or extends a class or interface with an incompatible identity or\n+         * value modifier, class loading will fail with an IncompatibleClassChangeError\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public interface I {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity interface I {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class Client implements I {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                IncompatibleClassChangeError.class\n+        );\n+\n+        \/\/ another variation of the assertion above\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public interface I {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value interface I {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class Client implements I {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                true,\n+                IncompatibleClassChangeError.class\n+        );\n+\n+        \/* Removing one of the identity or value modifiers from an interface does not break compatibility with\n+         * pre-existing binaries\n+         *\/\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public identity interface I {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public interface I {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public identity class Client implements I {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                false,\n+                null\n+        );\n+\n+        \/\/ another variation of the assertion above\n+        testCompatibilityAfterChange(\n+                base,\n+                \"\"\"\n+                package pkg;\n+                public value interface I {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public interface I {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public value class Client implements I {\n+                    public static void main(String... args) {\n+                        System.out.println(\"Hello World!\");\n+                    }\n+                }\n+                \"\"\",\n+                false,\n+                null\n+        );\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectsBinaryCompatibilityTests.java","additions":758,"deletions":0,"binary":false,"changes":758,"status":"added"}]}