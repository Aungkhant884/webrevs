{"files":[{"patch":"@@ -492,16 +492,0 @@\n-\n-void LIRGenerator::nio_range_check(LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info) {\n-  CodeStub* stub = new RangeCheckStub(info, index);\n-  if (index->is_constant()) {\n-    cmp_mem_int(lir_cond_belowEqual, buffer, java_nio_Buffer::limit_offset(), index->as_jint(), info);\n-    __ branch(lir_cond_belowEqual, stub); \/\/ forward branch\n-  } else {\n-    cmp_reg_mem(lir_cond_aboveEqual, index, buffer,\n-                java_nio_Buffer::limit_offset(), T_INT, info);\n-    __ branch(lir_cond_aboveEqual, stub); \/\/ forward branch\n-  }\n-  __ move(index, result);\n-}\n-\n-\n-\n@@ -2173,0 +2157,6 @@\n+\/\/ int\/long jdk.internal.util.Preconditions.checkIndex\n+void LIRGenerator::do_PreconditionsCheckIndex(Intrinsic* x, BasicType type) {\n+  assert(x->number_of_arguments() == 3, \"wrong type\");\n+  LIRItem index(x->argument_at(0), this);\n+  LIRItem length(x->argument_at(1), this);\n+  LIRItem oobef(x->argument_at(2), this);\n@@ -2174,11 +2164,2 @@\n-\/\/------------------------java.nio.Buffer.checkIndex------------------------\n-\n-\/\/ int java.nio.Buffer.checkIndex(int)\n-void LIRGenerator::do_NIOCheckIndex(Intrinsic* x) {\n-  \/\/ NOTE: by the time we are in checkIndex() we are guaranteed that\n-  \/\/ the buffer is non-null (because checkIndex is package-private and\n-  \/\/ only called from within other methods in the buffer).\n-  assert(x->number_of_arguments() == 2, \"wrong type\");\n-  LIRItem buf  (x->argument_at(0), this);\n-  LIRItem index(x->argument_at(1), this);\n-  buf.load_item();\n+  length.load_item();\n+  oobef.load_item();\n@@ -2188,10 +2169,15 @@\n-  if (GenerateRangeChecks) {\n-    CodeEmitInfo* info = state_for(x);\n-    CodeStub* stub = new RangeCheckStub(info, index.result());\n-    if (index.result()->is_constant()) {\n-      cmp_mem_int(lir_cond_belowEqual, buf.result(), java_nio_Buffer::limit_offset(), index.result()->as_jint(), info);\n-      __ branch(lir_cond_belowEqual, stub);\n-    } else {\n-      cmp_reg_mem(lir_cond_aboveEqual, index.result(), buf.result(),\n-                  java_nio_Buffer::limit_offset(), T_INT, info);\n-      __ branch(lir_cond_aboveEqual, stub);\n+  \/\/ x->state() is created from copy_state_for_exception, it does not contains arguments\n+  \/\/ we should prepare them before entering into interpreter mode due to deoptimization.\n+  ValueStack* state = x->state();\n+  for (int i = 0; i < x->number_of_arguments(); i++) {\n+    Value arg = x->argument_at(i);\n+    state->push(arg->type(), arg);\n+  }\n+  CodeEmitInfo* info = state_for(x, state);\n+\n+  LIR_Opr len = length.result();\n+  LIR_Opr zero = NULL;\n+  if (type == T_INT) {\n+    zero = LIR_OprFact::intConst(0);\n+    if (length.result()->is_constant()){\n+      len = LIR_OprFact::intConst(length.result()->as_jint());\n@@ -2199,4 +2185,34 @@\n-    __ move(index.result(), result);\n-    \/\/ Just load the index into the result register\n-    __ move(index.result(), result);\n-  }\n+    assert(type == T_LONG, \"sanity check\");\n+    zero = LIR_OprFact::longConst(0);\n+    if (length.result()->is_constant()){\n+      len = LIR_OprFact::longConst(length.result()->as_jlong());\n+    }\n+  }\n+  \/\/ C1 can not handle the case that comparing index with constant value while condition\n+  \/\/ is neither lir_cond_equal nor lir_cond_notEqual, see LIR_Assembler::comp_op.\n+  LIR_Opr zero_reg = new_register(type);\n+  __ move(zero, zero_reg);\n+#if defined(X86) && !defined(_LP64)\n+  \/\/ BEWARE! On 32-bit x86 cmp clobbers its left argument so we need a temp copy.\n+  LIR_Opr index_copy = new_register(index.type());\n+  \/\/ index >= 0\n+  __ move(index.result(), index_copy);\n+  __ cmp(lir_cond_less, index_copy, zero_reg);\n+  __ branch(lir_cond_less, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                    Deoptimization::Action_make_not_entrant));\n+  \/\/ index < length\n+  __ move(index.result(), index_copy);\n+  __ cmp(lir_cond_greaterEqual, index_copy, len);\n+  __ branch(lir_cond_greaterEqual, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                            Deoptimization::Action_make_not_entrant));\n+#else\n+  \/\/ index >= 0\n+  __ cmp(lir_cond_less, index.result(), zero_reg);\n+  __ branch(lir_cond_less, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                    Deoptimization::Action_make_not_entrant));\n+  \/\/ index < length\n+  __ cmp(lir_cond_greaterEqual, index.result(), len);\n+  __ branch(lir_cond_greaterEqual, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                            Deoptimization::Action_make_not_entrant));\n+#endif\n+  __ move(index.result(), result);\n@@ -2206,1 +2222,0 @@\n-\n@@ -3627,2 +3642,6 @@\n-  \/\/ java.nio.Buffer.checkIndex\n-  case vmIntrinsics::_checkIndex:     do_NIOCheckIndex(x); break;\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+    do_PreconditionsCheckIndex(x, T_INT);\n+    break;\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n+    do_PreconditionsCheckIndex(x, T_LONG);\n+    break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":63,"deletions":44,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-  void do_NIOCheckIndex(Intrinsic* x);\n+  void do_PreconditionsCheckIndex(Intrinsic* x, BasicType type);\n@@ -368,2 +368,0 @@\n-  \/\/ For java.nio.Buffer.checkIndex\n-  void nio_range_check            (LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -646,1 +646,2 @@\n-          set_live_gen_kill(value, op, live_gen, live_kill)\n+          set_live_gen_kill(value, op, live_gen, live_kill);\n+          local_has_fpu_registers = local_has_fpu_registers || value->type()->is_float_kind();\n@@ -1662,1 +1663,1 @@\n-  \/\/ allocate cpu registers\n+  \/\/ collect cpu intervals\n@@ -1666,1 +1667,1 @@\n-  \/\/ allocate fpu registers\n+  \/\/ collect fpu intervals\n@@ -1669,2 +1670,1 @@\n-\n-  \/\/ the fpu interval allocation cannot be moved down below with the fpu section as\n+  \/\/ this fpu interval collection cannot be moved down below with the allocation section as\n@@ -1673,0 +1673,11 @@\n+  if (!has_fpu_registers()) {\n+#ifdef ASSERT\n+    assert(not_precolored_fpu_intervals == Interval::end(), \"missed an uncolored fpu interval\");\n+#else\n+    if (not_precolored_fpu_intervals != Interval::end()) {\n+      BAILOUT(\"missed an uncolored fpu interval\");\n+    }\n+#endif\n+  }\n+\n+  \/\/ allocate cpu registers\n@@ -1678,0 +1689,1 @@\n+    \/\/ allocate fpu registers\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -156,3 +156,0 @@\n-  product(bool, InlineNIOCheckIndex, true, DIAGNOSTIC,                      \\\n-          \"Intrinsify java.nio.Buffer.checkIndex\")                          \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  if (_file) {\n+  if (_file != NULL) {\n@@ -92,0 +92,2 @@\n+  delete _indy_items;\n+  delete _interfaces;\n@@ -664,2 +666,1 @@\n-    Handle s = java_lang_String::create_from_symbol(class_name_symbol, CHECK_NULL);\n-    Handle ext_class_name = java_lang_String::externalize_classname(s, CHECK_NULL);\n+    Handle ext_class_name = java_lang_String::externalize_classname(class_name_symbol, CHECK_NULL);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-    if (!ik->can_be_verified_at_dumptime()) {\n+    if (ik->can_be_verified_at_dumptime()) {\n@@ -579,1 +579,1 @@\n-  return DumpSharedSpaces ? !ik->can_be_verified_at_dumptime() : !ik->is_shared_unregistered_class();\n+  return DumpSharedSpaces ? ik->can_be_verified_at_dumptime() : !ik->is_shared_unregistered_class();\n@@ -755,1 +755,1 @@\n-  if (ik->is_loaded() && !ik->is_linked() && !ik->can_be_verified_at_dumptime() &&\n+  if (ik->is_loaded() && !ik->is_linked() && ik->can_be_verified_at_dumptime() &&\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -474,64 +474,3 @@\n-Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {\n-  oop          obj    = java_string();\n-  \/\/ Typical usage is to convert all '\/' to '.' in string.\n-  typeArrayOop value  = java_lang_String::value(obj);\n-  int          length = java_lang_String::length(obj, value);\n-  bool      is_latin1 = java_lang_String::is_latin1(obj);\n-\n-  \/\/ First check if any from_char exist\n-  int index; \/\/ Declared outside, used later\n-  for (index = 0; index < length; index++) {\n-    jchar c = !is_latin1 ? value->char_at(index) :\n-                  ((jchar) value->byte_at(index)) & 0xff;\n-    if (c == from_char) {\n-      break;\n-    }\n-  }\n-  if (index == length) {\n-    \/\/ No from_char, so do not copy.\n-    return java_string;\n-  }\n-\n-  \/\/ Check if result string will be latin1\n-  bool to_is_latin1 = false;\n-\n-  \/\/ Replacement char must be latin1\n-  if (CompactStrings && UNICODE::is_latin1(to_char)) {\n-    if (is_latin1) {\n-      \/\/ Source string is latin1 as well\n-      to_is_latin1 = true;\n-    } else if (!UNICODE::is_latin1(from_char)) {\n-      \/\/ We are replacing an UTF16 char. Scan string to\n-      \/\/ check if result can be latin1 encoded.\n-      to_is_latin1 = true;\n-      for (index = 0; index < length; index++) {\n-        jchar c = value->char_at(index);\n-        if (c != from_char && !UNICODE::is_latin1(c)) {\n-          to_is_latin1 = false;\n-          break;\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Create new UNICODE (or byte) buffer. Must handlize value because GC\n-  \/\/ may happen during String and char array creation.\n-  typeArrayHandle h_value(THREAD, value);\n-  Handle string = basic_create(length, to_is_latin1, CHECK_NH);\n-  typeArrayOop from_buffer = h_value();\n-  typeArrayOop to_buffer = java_lang_String::value(string());\n-\n-  \/\/ Copy contents\n-  for (index = 0; index < length; index++) {\n-    jchar c = (!is_latin1) ? from_buffer->char_at(index) :\n-                    ((jchar) from_buffer->byte_at(index)) & 0xff;\n-    if (c == from_char) {\n-      c = to_char;\n-    }\n-    if (!to_is_latin1) {\n-      to_buffer->char_at_put(index, c);\n-    } else {\n-      to_buffer->byte_at_put(index, (jbyte) c);\n-    }\n-  }\n-  return string;\n+Handle java_lang_String::externalize_classname(Symbol* java_name, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  return create_from_str(java_name->as_klass_external_name(), THREAD);\n@@ -4672,20 +4611,0 @@\n-\n-\/\/ Support for intrinsification of java.nio.Buffer.checkIndex\n-\n-int java_nio_Buffer::_limit_offset;\n-\n-#define BUFFER_FIELDS_DO(macro) \\\n-  macro(_limit_offset, k, \"limit\", int_signature, false)\n-\n-void java_nio_Buffer::compute_offsets() {\n-  InstanceKlass* k = vmClasses::nio_Buffer_klass();\n-  assert(k != NULL, \"must be loaded in 1.4+\");\n-  BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {\n-  BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":84,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  f(java_nio_Buffer) \\\n@@ -149,1 +148,0 @@\n-  static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);\n@@ -232,4 +230,2 @@\n-  \/\/ Conversion between '.' and '\/' formats\n-  static Handle externalize_classname(Handle java_string, TRAPS) {\n-    return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);\n-  }\n+  \/\/ Conversion between '.' and '\/' formats, and allocate a String from the result.\n+  static Handle externalize_classname(Symbol* java_name, TRAPS);\n@@ -1586,10 +1582,0 @@\n-class java_nio_Buffer: AllStatic {\n- private:\n-  static int _limit_offset;\n-\n- public:\n-  static int  limit_offset() { CHECK_INIT(_limit_offset); }\n-  static void compute_offsets();\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-};\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1388,2 +1388,1 @@\n-    Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);\n-    Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);\n+    Handle string = java_lang_String::externalize_classname(class_name, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-  case vmIntrinsics::_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n@@ -474,5 +475,0 @@\n-#ifdef COMPILER1\n-  case vmIntrinsics::_checkIndex:\n-    if (!InlineNIOCheckIndex) return true;\n-    break;\n-#endif \/\/ COMPILER1\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -344,4 +344,0 @@\n-  do_class(java_nio_Buffer,               \"java\/nio\/Buffer\")                                                            \\\n-  do_intrinsic(_checkIndex,               java_nio_Buffer,        checkIndex_name, int_int_signature,            F_R)   \\\n-   do_name(     checkIndex_name,                                 \"checkIndex\")                                          \\\n-                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+  template(java_nio_Buffer,                           \"java\/nio\/Buffer\")                          \\\n@@ -490,0 +491,1 @@\n+  template(checkIndex_name,                           \"checkIndex\")                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -864,0 +864,2 @@\n+\n+#undef XTOP\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"opto\/runtime.hpp\"\n@@ -256,0 +257,2 @@\n+#define XTOP LP64_ONLY(COMMA phase->top())\n+\n@@ -258,0 +261,1 @@\n+\n@@ -259,2 +263,39 @@\n-    \/\/ Clone primitive array\n-    BarrierSetC2::clone_at_expansion(phase, ac);\n+    const TypeAryPtr* ary_ptr = src->get_ptr_type()->isa_aryptr();\n+    BasicType bt;\n+    if (ary_ptr == NULL) {\n+      \/\/ ary_ptr can be null iff we are running with StressReflectiveCode\n+      \/\/ This code will be unreachable\n+      assert(StressReflectiveCode, \"Guard against surprises\");\n+      bt = T_LONG;\n+    } else {\n+      bt = ary_ptr->elem()->array_element_basic_type();\n+      if (is_reference_type(bt)) {\n+        \/\/ Clone object array\n+        bt = T_OBJECT;\n+      } else {\n+        \/\/ Clone primitive array\n+        bt = T_LONG;\n+      }\n+    }\n+\n+    Node* ctrl = ac->in(TypeFunc::Control);\n+    Node* mem = ac->in(TypeFunc::Memory);\n+    Node* src = ac->in(ArrayCopyNode::Src);\n+    Node* src_offset = ac->in(ArrayCopyNode::SrcPos);\n+    Node* dest = ac->in(ArrayCopyNode::Dest);\n+    Node* dest_offset = ac->in(ArrayCopyNode::DestPos);\n+    Node* length = ac->in(ArrayCopyNode::Length);\n+\n+    Node* payload_src = phase->basic_plus_adr(src, src_offset);\n+    Node* payload_dst = phase->basic_plus_adr(dest, dest_offset);\n+\n+    const char* copyfunc_name = \"arraycopy\";\n+    address     copyfunc_addr = phase->basictype2arraycopy(bt, NULL, NULL, true, copyfunc_name, true);\n+\n+    const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;\n+    const TypeFunc* call_type = OptoRuntime::fast_arraycopy_Type();\n+\n+    Node* call = phase->make_leaf_call(ctrl, mem, call_type, copyfunc_addr, copyfunc_name, raw_adr_type, payload_src, payload_dst, length XTOP);\n+    phase->transform_later(call);\n+\n+    phase->igvn().replace_node(ac, call);\n@@ -292,0 +333,2 @@\n+#undef XTOP\n+\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -574,1 +574,1 @@\n-    assert(klass->can_be_verified_at_dumptime(), \"only shared old classes aren't rewritten\");\n+    assert(!klass->can_be_verified_at_dumptime(), \"only shared old classes aren't rewritten\");\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-  if (!_pool_holder->is_linked() && _pool_holder->is_shared_old_klass()) {\n+  if (!_pool_holder->is_linked() && !_pool_holder->verified_at_dump_time()) {\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2554,2 +2554,2 @@\n-    \/\/ Set the old class bit.\n-    set_is_shared_old_klass();\n+    \/\/ Remember this so we can avoid walking the hierarchy at runtime.\n+    set_verified_at_dump_time();\n@@ -2712,1 +2712,1 @@\n-    return true;\n+    return false;\n@@ -2714,2 +2714,2 @@\n-  if (java_super() != NULL && java_super()->can_be_verified_at_dumptime()) {\n-    return true;\n+  if (java_super() != NULL && !java_super()->can_be_verified_at_dumptime()) {\n+    return false;\n@@ -2720,2 +2720,2 @@\n-    if (interfaces->at(i)->can_be_verified_at_dumptime()) {\n-      return true;\n+    if (!interfaces->at(i)->can_be_verified_at_dumptime()) {\n+      return false;\n@@ -2724,1 +2724,1 @@\n-  return false;\n+  return true;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-    _is_shared_old_klass = 8\n+    _verified_at_dump_time = 8\n@@ -338,2 +338,2 @@\n-  void set_is_shared_old_klass() {\n-    CDS_ONLY(_shared_class_flags |= _is_shared_old_klass;)\n+  void set_verified_at_dump_time() {\n+    CDS_ONLY(_shared_class_flags |= _verified_at_dump_time;)\n@@ -341,2 +341,2 @@\n-  bool is_shared_old_klass() const {\n-    CDS_ONLY(return (_shared_class_flags & _is_shared_old_klass) != 0;)\n+  bool verified_at_dump_time() const {\n+    CDS_ONLY(return (_shared_class_flags & _verified_at_dump_time) != 0;)\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  return _klass->is_shared() && !MetaspaceShared::remapped_readwrite() && !_klass->is_shared_old_klass();\n+  return _klass->is_shared() && !MetaspaceShared::remapped_readwrite() && _klass->verified_at_dump_time();\n@@ -1097,2 +1097,2 @@\n-     !m->method_holder()->can_be_verified_at_dumptime() &&\n-     !klass->can_be_verified_at_dumptime()) {\n+     m->method_holder()->verified_at_dump_time() &&\n+     klass->verified_at_dump_time()) {\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-  if (is_shared() && !MetaspaceShared::remapped_readwrite() && !method_holder()->is_shared_old_klass()) {\n+  if (is_shared() && !MetaspaceShared::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n@@ -433,1 +433,1 @@\n-  if (is_shared() && !MetaspaceShared::remapped_readwrite() && !method_holder()->is_shared_old_klass()) {\n+  if (is_shared() && !MetaspaceShared::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+const char* C2Compiler::retry_no_locks_coarsening() {\n+  return \"retry without locks coarsening\";\n+}\n@@ -100,0 +103,1 @@\n+  bool do_locks_coarsening = EliminateLocks;\n@@ -103,1 +107,1 @@\n-    Compile C(env, target, entry_bci, subsume_loads, do_escape_analysis, eliminate_boxing, install_code, directive);\n+    Compile C(env, target, entry_bci, subsume_loads, do_escape_analysis, eliminate_boxing, do_locks_coarsening, install_code, directive);\n@@ -123,0 +127,6 @@\n+      if (C.failure_reason_is(retry_no_locks_coarsening())) {\n+        assert(do_locks_coarsening, \"must make progress\");\n+        do_locks_coarsening = false;\n+        env->report_failure(C.failure_reason());\n+        continue;  \/\/ retry\n+      }\n@@ -144,0 +154,4 @@\n+      if (do_locks_coarsening) {\n+        do_locks_coarsening = false;\n+        continue;  \/\/ retry\n+      }\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2269,0 +2269,6 @@\n+const char* AbstractLockNode::_kind_names[] = {\"Regular\", \"NonEscObj\", \"Coarsened\", \"Nested\"};\n+\n+const char * AbstractLockNode::kind_as_string() const {\n+  return _kind_names[_kind];\n+}\n+\n@@ -2286,2 +2292,0 @@\n-const char* AbstractLockNode::_kind_names[] = {\"Regular\", \"NonEscObj\", \"Coarsened\", \"Nested\"};\n-\n@@ -2341,0 +2345,3 @@\n+    if (!phase->C->do_locks_coarsening()) {\n+      return result; \/\/ Compiling without locks coarsening\n+    }\n@@ -2378,0 +2385,3 @@\n+          if (Verbose) {\n+            tty->print_cr(\"=== Locks coarsening ===\");\n+          }\n@@ -2385,1 +2395,2 @@\n-              lock->dump(1);\n+              tty->print(\" %d: \", i);\n+              lock->dump();\n@@ -2388,1 +2399,1 @@\n-          tty->print_cr(\"***Eliminated %d unlocks and %d locks\", unlocks, locks);\n+          tty->print_cr(\"=== Coarsened %d unlocks and %d locks\", unlocks, locks);\n@@ -2403,0 +2414,2 @@\n+        \/\/ Record this coarsened group.\n+        phase->C->add_coarsened_locks(lock_ops);\n@@ -2436,1 +2449,2 @@\n-  if (!box->is_simple_lock_region(&unique_lock, obj)) {\n+  Node* bad_lock = NULL;\n+  if (!box->is_simple_lock_region(&unique_lock, obj, &bad_lock)) {\n@@ -2438,1 +2452,1 @@\n-    this->log_lock_optimization(c, \"eliminate_lock_INLR_2a\");\n+    this->log_lock_optimization(c, \"eliminate_lock_INLR_2a\", bad_lock);\n@@ -2444,1 +2458,19 @@\n-    this->log_lock_optimization(c, \"eliminate_lock_INLR_2b\");\n+    this->log_lock_optimization(c, \"eliminate_lock_INLR_2b\", (unique_lock != NULL ? unique_lock : bad_lock));\n+    if (PrintEliminateLocks && Verbose) {\n+      tty->print_cr(\"=============== unique_lock != this ============\");\n+      tty->print(\" this: \");\n+      this->dump();\n+      tty->print(\" box: \");\n+      box->dump();\n+      tty->print(\" obj: \");\n+      obj->dump();\n+      if (unique_lock != NULL) {\n+        tty->print(\" unique_lock: \");\n+        unique_lock->dump();\n+      }\n+      if (bad_lock != NULL) {\n+        tty->print(\" bad_lock: \");\n+        bad_lock->dump();\n+      }\n+      tty->print_cr(\"===============\");\n+    }\n@@ -2513,8 +2545,1 @@\n-const char * AbstractLockNode::kind_as_string() const {\n-  return is_coarsened()   ? \"coarsened\" :\n-         is_nested()      ? \"nested\" :\n-         is_non_esc_obj() ? \"non_escaping\" :\n-         \"?\";\n-}\n-\n-void AbstractLockNode::log_lock_optimization(Compile *C, const char * tag)  const {\n+void AbstractLockNode::log_lock_optimization(Compile *C, const char * tag, Node* bad_lock)  const {\n@@ -2526,2 +2551,7 @@\n-    log->begin_head(\"%s lock='%d' compile_id='%d' class_id='%s' kind='%s'\",\n-          tag, is_Lock(), C->compile_id(),\n+    Node* box = box_node();\n+    Node* obj = obj_node();\n+    int box_id = box != NULL ? box->_idx : -1;\n+    int obj_id = obj != NULL ? obj->_idx : -1;\n+\n+    log->begin_head(\"%s compile_id='%d' lock_id='%d' class='%s' kind='%s' box_id='%d' obj_id='%d' bad_id='%d'\",\n+          tag, C->compile_id(), this->_idx,\n@@ -2529,1 +2559,1 @@\n-          kind_as_string());\n+          kind_as_string(), box_id, obj_id, (bad_lock != NULL ? bad_lock->_idx : -1));\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":48,"deletions":18,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1101,0 +1101,3 @@\n+\n+  static const char* _kind_names[Nested+1];\n+\n@@ -1103,1 +1106,0 @@\n-  static const char* _kind_names[Nested+1];\n@@ -1146,1 +1148,1 @@\n-  void log_lock_optimization(Compile* c, const char * tag) const;\n+  void log_lock_optimization(Compile* c, const char * tag, Node* bad_lock = NULL) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -445,0 +445,1 @@\n+  remove_useless_coarsened_locks(useful);            \/\/ remove useless coarsened locks nodes\n@@ -514,0 +515,6 @@\n+  if ((_do_locks_coarsening != EliminateLocks) && PrintOpto) {\n+    \/\/ Recompiling without locks coarsening\n+    tty->print_cr(\"*********************************************************\");\n+    tty->print_cr(\"** Bailout: Recompile without locks coarsening         **\");\n+    tty->print_cr(\"*********************************************************\");\n+  }\n@@ -541,1 +548,2 @@\n-                  bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, bool install_code, DirectiveSet* directive)\n+                  bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing,\n+                  bool do_locks_coarsening, bool install_code, DirectiveSet* directive)\n@@ -548,0 +556,1 @@\n+                  _do_locks_coarsening(do_locks_coarsening),\n@@ -580,0 +589,1 @@\n+                  _coarsened_locks   (comp_arena(), 8, 0, NULL),\n@@ -848,0 +858,1 @@\n+    _do_locks_coarsening(false),\n@@ -4951,0 +4962,95 @@\n+\/**\n+ * Track coarsened Lock and Unlock nodes.\n+ *\/\n+\n+class Lock_List : public Node_List {\n+  uint _origin_cnt;\n+public:\n+  Lock_List(Arena *a, uint cnt) : Node_List(a), _origin_cnt(cnt) {}\n+  uint origin_cnt() const { return _origin_cnt; }\n+};\n+\n+void Compile::add_coarsened_locks(GrowableArray<AbstractLockNode*>& locks) {\n+  int length = locks.length();\n+  if (length > 0) {\n+    \/\/ Have to keep this list until locks elimination during Macro nodes elimination.\n+    Lock_List* locks_list = new (comp_arena()) Lock_List(comp_arena(), length);\n+    for (int i = 0; i < length; i++) {\n+      AbstractLockNode* lock = locks.at(i);\n+      assert(lock->is_coarsened(), \"expecting only coarsened AbstractLock nodes, but got '%s'[%d] node\", lock->Name(), lock->_idx);\n+      locks_list->push(lock);\n+    }\n+    _coarsened_locks.append(locks_list);\n+  }\n+}\n+\n+void Compile::remove_useless_coarsened_locks(Unique_Node_List& useful) {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    Node_List* locks_list = _coarsened_locks.at(i);\n+    for (uint j = 0; j < locks_list->size(); j++) {\n+      Node* lock = locks_list->at(j);\n+      assert(lock->is_AbstractLock(), \"sanity\");\n+      if (!useful.member(lock)) {\n+        locks_list->yank(lock);\n+      }\n+    }\n+  }\n+}\n+\n+void Compile::remove_coarsened_lock(Node* n) {\n+  if (n->is_AbstractLock()) {\n+    int count = coarsened_count();\n+    for (int i = 0; i < count; i++) {\n+      Node_List* locks_list = _coarsened_locks.at(i);\n+      locks_list->yank(n);\n+    }\n+  }\n+}\n+\n+bool Compile::coarsened_locks_consistent() {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    bool unbalanced = false;\n+    bool modified = false; \/\/ track locks kind modifications\n+    Lock_List* locks_list = (Lock_List*)_coarsened_locks.at(i);\n+    uint size = locks_list->size();\n+    if (size != locks_list->origin_cnt()) {\n+      unbalanced = true; \/\/ Some locks were removed from list\n+    } else {\n+      for (uint j = 0; j < size; j++) {\n+        Node* lock = locks_list->at(j);\n+        \/\/ All nodes in group should have the same state (modified or not)\n+        if (!lock->as_AbstractLock()->is_coarsened()) {\n+          if (j == 0) {\n+            \/\/ first on list was modified, the rest should be too for consistency\n+            modified = true;\n+          } else if (!modified) {\n+            \/\/ this lock was modified but previous locks on the list were not\n+            unbalanced = true;\n+            break;\n+          }\n+        } else if (modified) {\n+          \/\/ previous locks on list were modified but not this lock\n+          unbalanced = true;\n+          break;\n+        }\n+      }\n+    }\n+    if (unbalanced) {\n+      \/\/ unbalanced monitor enter\/exit - only some [un]lock nodes were removed or modified\n+#ifdef ASSERT\n+      if (PrintEliminateLocks) {\n+        tty->print_cr(\"=== unbalanced coarsened locks ===\");\n+        for (uint l = 0; l < size; l++) {\n+          locks_list->at(l)->dump();\n+        }\n+      }\n+#endif\n+      record_failure(C2Compiler::retry_no_locks_coarsening());\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":107,"deletions":1,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+class AbstractLockNode;\n@@ -67,0 +68,1 @@\n+class Node_List;\n@@ -253,0 +255,1 @@\n+  const bool            _do_locks_coarsening;   \/\/ Do locks coarsening\n@@ -326,0 +329,1 @@\n+  GrowableArray<Node_List*> _coarsened_locks;   \/\/ List of coarsened Lock and Unlock nodes\n@@ -517,0 +521,2 @@\n+  \/** Do locks coarsening. *\/\n+  bool              do_locks_coarsening() const { return _do_locks_coarsening; }\n@@ -674,0 +680,1 @@\n+  int           coarsened_count()         const { return _coarsened_locks.length(); }\n@@ -695,0 +702,4 @@\n+    \/\/ Remove from coarsened locks list if present\n+    if (coarsened_count() > 0) {\n+      remove_coarsened_lock(n);\n+    }\n@@ -714,0 +725,4 @@\n+  void add_coarsened_locks(GrowableArray<AbstractLockNode*>& locks);\n+  void remove_coarsened_lock(Node* n);\n+  bool coarsened_locks_consistent();\n+\n@@ -977,0 +992,2 @@\n+  void remove_useless_coarsened_locks(Unique_Node_List& useful);\n+\n@@ -1043,1 +1060,2 @@\n-          bool eliminate_boxing, bool install_code, DirectiveSet* directive);\n+          bool eliminate_boxing, bool do_locks_coarsening,\n+          bool install_code, DirectiveSet* directive);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4409,0 +4409,2 @@\n+#undef XTOP\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-bool BoxLockNode::is_simple_lock_region(LockNode** unique_lock, Node* obj) {\n+bool BoxLockNode::is_simple_lock_region(LockNode** unique_lock, Node* obj, Node** bad_lock) {\n@@ -105,0 +105,3 @@\n+              if (bad_lock != NULL) {\n+                *bad_lock = alock;\n+              }\n@@ -108,0 +111,3 @@\n+          if (bad_lock != NULL) {\n+            *bad_lock = alock;\n+          }\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2048,1 +2048,1 @@\n-  if (oldbox->as_BoxLock()->is_eliminated())\n+  if (oldbox->as_BoxLock()->is_eliminated()) {\n@@ -2050,1 +2050,1 @@\n-\n+  }\n@@ -2056,1 +2056,1 @@\n-      oldbox->as_BoxLock()->is_simple_lock_region(NULL, obj)) {\n+      oldbox->as_BoxLock()->is_simple_lock_region(NULL, obj, NULL)) {\n@@ -2271,5 +2271,1 @@\n-    if (alock->is_Lock()) {\n-      tty->print_cr(\"++++ Eliminated: %d Lock\", alock->_idx);\n-    } else {\n-      tty->print_cr(\"++++ Eliminated: %d Unlock\", alock->_idx);\n-    }\n+    tty->print_cr(\"++++ Eliminated: %d %s '%s'\", alock->_idx, (alock->is_Lock() ? \"Lock\" : \"Unlock\"), alock->kind_as_string());\n@@ -2986,1 +2982,2 @@\n-  \/\/ First, attempt to eliminate locks\n+  \/\/ Before elimination may re-mark (change to Nested or NonEscObj)\n+  \/\/ all associated (same box and obj) lock and unlock nodes.\n@@ -2991,2 +2988,0 @@\n-      \/\/ Before elimination mark all associated (same box and obj)\n-      \/\/ lock and unlock nodes.\n@@ -2996,0 +2991,6 @@\n+  \/\/ Re-marking may break consistency of Coarsened locks.\n+  if (!C->coarsened_locks_consistent()) {\n+    return; \/\/ recompile without Coarsened locks if broken\n+  }\n+\n+  \/\/ First, attempt to eliminate locks\n@@ -3064,0 +3065,1 @@\n+  if (C->failing())  return true;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1353,0 +1353,2 @@\n+#undef XTOP\n+\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -528,2 +528,7 @@\n-  { \"SuspendRetryCount\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n-  { \"SuspendRetryDelay\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+\n+  \/\/ --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:\n+  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CreateMinidumpOnCrash\",        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"TLABStats\",                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },\n+\n+  \/\/ -------------- Obsolete Flags - sorted by expired_in --------------\n@@ -540,10 +545,1 @@\n-\n-  \/\/ --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:\n-  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"CreateMinidumpOnCrash\",        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"TLABStats\",                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },\n-\n-  \/\/ -------------- Obsolete Flags - sorted by expired_in --------------\n-  { \"AssertOnSuspendWaitFailure\",   JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n-  { \"TraceSuspendWaitFailures\",     JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n-  { \"DummyObsoleteTestFlag\",        JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::undefined() },\n+  { \"DummyObsoleteTestFlag\",        JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::undefined() },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -516,1 +516,1 @@\n-            sb.append(tsym.name);\n+            sb.append(tsym.name.toString());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2438,0 +2438,4 @@\n+                    if (inits.isReset()) {\n+                        inits.assign(initsWhenTrue);\n+                        uninits.assign(uninitsWhenTrue);\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2756,0 +2756,3 @@\n+                    case BANG: case TILDE:\n+                        isYieldStatement = S.token(1).kind != SEMI;\n+                        break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2161,1 +2161,1 @@\n-                    StringBuilder sb = new StringBuilder(e.getSimpleName());\n+                    StringBuilder sb = new StringBuilder(e.getSimpleName().toString());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,0 +142,2 @@\n+compiler\/intrinsics\/VectorizedMismatchTest.java 8268482 windows-x64\n+\n@@ -186,0 +188,1 @@\n+serviceability\/jvmti\/CompiledMethodLoad\/Zombie.java 8245877 linux-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+  compiler\/locks\/ \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}