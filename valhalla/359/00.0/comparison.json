{"files":[{"patch":"@@ -2073,1 +2073,1 @@\n-    apush(append_split(new Deoptimize(state_before)));\n+    apush(append_split(new Deoptimize(holder, state_before)));\n@@ -2514,1 +2514,1 @@\n-    apush(append_split(new Deoptimize(copy_state_before())));\n+    apush(append_split(new Deoptimize(klass, copy_state_before())));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6021,1 +6021,1 @@\n-        Klass* klass = SystemDictionary::find(klass_name,\n+        InstanceKlass* klass = SystemDictionary::find_instance_klass(klass_name,\n@@ -6023,1 +6023,1 @@\n-            Handle(THREAD, ik->protection_domain()), CHECK);\n+            Handle(THREAD, ik->protection_domain()));\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1372,3 +1372,3 @@\n-Klass* InstanceKlass::implementor() const {\n-  Klass* volatile* k = adr_implementor();\n-  if (k == NULL) {\n+InstanceKlass* InstanceKlass::implementor() const {\n+  InstanceKlass* volatile* ik = adr_implementor();\n+  if (ik == NULL) {\n@@ -1378,2 +1378,2 @@\n-    Klass* kls = Atomic::load_acquire(k);\n-    if (kls != NULL && !kls->is_loader_alive()) {\n+    InstanceKlass* ikls = Atomic::load_acquire(ik);\n+    if (ikls != NULL && !ikls->is_loader_alive()) {\n@@ -1382,1 +1382,1 @@\n-      return kls;\n+      return ikls;\n@@ -1388,1 +1388,1 @@\n-void InstanceKlass::set_implementor(Klass* k) {\n+void InstanceKlass::set_implementor(InstanceKlass* ik) {\n@@ -1391,1 +1391,1 @@\n-  Klass* volatile* addr = adr_implementor();\n+  InstanceKlass* volatile* addr = adr_implementor();\n@@ -1394,1 +1394,1 @@\n-    Atomic::release_store(addr, k);\n+    Atomic::release_store(addr, ik);\n@@ -1399,2 +1399,2 @@\n-  Klass* k = implementor();\n-  if (k == NULL) {\n+  InstanceKlass* ik = implementor();\n+  if (ik == NULL) {\n@@ -1402,1 +1402,1 @@\n-  } else if (k != this) {\n+  } else if (ik != this) {\n@@ -1418,1 +1418,1 @@\n-void InstanceKlass::add_implementor(Klass* k) {\n+void InstanceKlass::add_implementor(InstanceKlass* ik) {\n@@ -1425,1 +1425,1 @@\n-  if (InstanceKlass::cast(k)->is_interface()) return;\n+  if (ik->is_interface()) return;\n@@ -1430,2 +1430,2 @@\n-  Klass* sk = k->super();\n-  if (sk != NULL && InstanceKlass::cast(sk)->implements_interface(this))\n+  InstanceKlass* super_ik = ik->java_super();\n+  if (super_ik != NULL && super_ik->implements_interface(this))\n@@ -1437,4 +1437,4 @@\n-  Klass* ik = implementor();\n-  if (ik == NULL) {\n-    set_implementor(k);\n-  } else if (ik != this && ik != k) {\n+  InstanceKlass* iklass = implementor();\n+  if (iklass == NULL) {\n+    set_implementor(ik);\n+  } else if (iklass != this && iklass != ik) {\n@@ -1448,1 +1448,1 @@\n-    InstanceKlass::cast(local_interfaces()->at(index))->add_implementor(k);\n+    local_interfaces()->at(index)->add_implementor(ik);\n@@ -1463,1 +1463,1 @@\n-    InstanceKlass* interf = InstanceKlass::cast(local_interfaces()->at(i));\n+    InstanceKlass* interf = local_interfaces()->at(i);\n@@ -2510,1 +2510,1 @@\n-      Klass* impl = Atomic::load_acquire(adr_implementor());\n+      InstanceKlass* impl = Atomic::load_acquire(adr_implementor());\n@@ -2512,3 +2512,3 @@\n-        \/\/ NULL this field, might be an unloaded klass or NULL\n-        Klass* volatile* klass = adr_implementor();\n-        if (Atomic::cmpxchg(klass, impl, (Klass*)NULL) == impl) {\n+        \/\/ NULL this field, might be an unloaded instance klass or NULL\n+        InstanceKlass* volatile* iklass = adr_implementor();\n+        if (Atomic::cmpxchg(iklass, impl, (InstanceKlass*)NULL) == impl) {\n@@ -4492,0 +4492,21 @@\n+\n+\/\/ Make a step iterating over the class hierarchy under the root class.\n+\/\/ Skips subclasses if requested.\n+void ClassHierarchyIterator::next() {\n+  assert(_current != NULL, \"required\");\n+  if (_visit_subclasses && _current->subklass() != NULL) {\n+    _current = _current->subklass();\n+    return; \/\/ visit next subclass\n+  }\n+  _visit_subclasses = true; \/\/ reset\n+  while (_current->next_sibling() == NULL && _current != _root) {\n+    _current = _current->superklass(); \/\/ backtrack; no more sibling subclasses left\n+  }\n+  if (_current == _root) {\n+    \/\/ Iteration is over (back at root after backtracking). Invalidate the iterator.\n+    _current = NULL;\n+    return;\n+  }\n+  _current = _current->next_sibling();\n+  return; \/\/ visit next sibling subclass\n+}\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":47,"deletions":26,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-  \/\/   iterface. The possible values of the implementor fall into following\n+  \/\/   interface. The possible values of the implementor fall into following\n@@ -1153,2 +1153,2 @@\n-  Klass* implementor() const;\n-  void set_implementor(Klass* k);\n+  InstanceKlass* implementor() const;\n+  void set_implementor(InstanceKlass* ik);\n@@ -1156,1 +1156,1 @@\n-  void add_implementor(Klass* k);  \/\/ k is a new class that implements this interface\n+  void add_implementor(InstanceKlass* ik);  \/\/ ik is a new class that implements this interface\n@@ -1232,1 +1232,1 @@\n-  inline Klass* volatile* adr_implementor() const;\n+  inline InstanceKlass* volatile* adr_implementor() const;\n@@ -1585,0 +1585,37 @@\n+\/\/ Iterator over class hierarchy under a particular class. Implements depth-first pre-order traversal.\n+\/\/ Usage:\n+\/\/  for (ClassHierarchyIterator iter(root_klass); !iter.done(); iter.next()) {\n+\/\/    Klass* k = iter.klass();\n+\/\/    ...\n+\/\/  }\n+class ClassHierarchyIterator : public StackObj {\n+ private:\n+  InstanceKlass* _root;\n+  Klass*         _current;\n+  bool           _visit_subclasses;\n+\n+ public:\n+  ClassHierarchyIterator(InstanceKlass* root) : _root(root), _current(root), _visit_subclasses(true) {\n+    assert(!root->is_interface(), \"no subclasses\");\n+    assert(_root == _current, \"required\"); \/\/ initial state\n+  }\n+\n+  bool done() {\n+    return (_current == NULL);\n+  }\n+\n+  \/\/ Make a step iterating over the class hierarchy under the root class.\n+  \/\/ Skips subclasses if requested.\n+  void next();\n+\n+  Klass* klass() {\n+    assert(!done(), \"sanity\");\n+    return _current;\n+  }\n+\n+  \/\/ Skip subclasses of the current class.\n+  void skip_subclasses() {\n+    _visit_subclasses = false;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-inline Klass* volatile* InstanceKlass::adr_implementor() const {\n+inline InstanceKlass* volatile* InstanceKlass::adr_implementor() const {\n@@ -80,1 +80,1 @@\n-    return (Klass* volatile*)end_of_nonstatic_oop_maps();\n+    return (InstanceKlass* volatile*)end_of_nonstatic_oop_maps();\n@@ -106,1 +106,1 @@\n-    Klass* volatile* adr_impl = adr_implementor();\n+    InstanceKlass* volatile* adr_impl = adr_implementor();\n@@ -129,1 +129,1 @@\n-    Klass* volatile* adr_impl = adr_implementor();\n+    InstanceKlass* volatile* adr_impl = adr_implementor();\n@@ -328,1 +328,1 @@\n-    Klass* volatile* adr_impl = adr_implementor();\n+    InstanceKlass* volatile* adr_impl = adr_implementor();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -963,1 +963,1 @@\n-    return SystemDictionary::find(klass_name, loader, prot, thread) != NULL;\n+    return SystemDictionary::find_instance_klass(klass_name, loader, prot) != NULL;\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}