{"files":[{"patch":"@@ -1855,0 +1855,6 @@\n+      if (field->has_restricted_type()) {\n+        CheckCast* c = new CheckCast(field->type()->as_klass(), val, copy_state_before(), field->type()->as_inline_klass() != NULL);\n+        append_split(c);\n+        c->set_incompatible_class_change_check();\n+        c->set_direct_compare(field->type()->as_instance_klass()->is_final());\n+      }\n@@ -2019,0 +2025,6 @@\n+      if (field->has_restricted_type()) {\n+        CheckCast* c = new CheckCast(field->type()->as_klass(), val, copy_state_before(), field->type()->as_inline_klass() != NULL);\n+        append_split(c);\n+        c->set_incompatible_class_change_check();\n+        c->set_direct_compare(field->type()->as_instance_klass()->is_final());\n+      }\n@@ -2065,0 +2077,7 @@\n+  if (field_modify->has_restricted_type()) {\n+    CheckCast* c = new CheckCast(field_modify->type()->as_klass(), val, copy_state_before(), field_modify->type()->as_inline_klass() != NULL);\n+    append_split(c);\n+    c->set_incompatible_class_change_check();\n+    c->set_direct_compare(field_modify->type()->as_instance_klass()->is_final());\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1383,0 +1383,2 @@\n+                                             u2* restricted_field_info,\n+                                             bool* has_restricted_type,\n@@ -1515,0 +1517,16 @@\n+      } else if (_major_version >= JAVA_17_VERSION) {\n+        if (attribute_name == vmSymbols::tag_restricted_field()) {\n+          check_property(\n+            attribute_length == 2,\n+            \"Invalid RestrictedField field attribute length %u in class file %s\",\n+            attribute_length, CHECK);\n+            const u2 type_index = cfs->get_u2_fast();\n+            check_property(valid_symbol_at(type_index),\n+                          \"Invalid constant pool index %u for field restricted type signature in class file %s\",\n+                            type_index, CHECK);\n+            *restricted_field_info = type_index;\n+            *has_restricted_type = true;\n+            set_has_restricted_fields();\n+        } else {\n+          cfs->skip_u1(attribute_length, CHECK);  \/\/ Skip unknown attributes\n+        }\n@@ -1669,0 +1687,2 @@\n+  _descriptor_signature_info = new GrowableArray<u2>(total_fields);\n+\n@@ -1699,0 +1719,1 @@\n+\n@@ -1731,0 +1752,2 @@\n+    bool has_restricted_type = false;\n+    u2 restricted_type_index;\n@@ -1740,0 +1763,2 @@\n+                             &restricted_type_index,\n+                             &has_restricted_type,\n@@ -1774,0 +1799,26 @@\n+    \/\/ RestrictedField:\n+    \/\/ The current model for restricted field is that such a field has a descriptor signature used\n+    \/\/ as the normal signature for this field (for instance in field access bytecodes) but it also\n+    \/\/ has a restricted type that will be used internally by the VM as the real type of the field.\n+    \/\/ Current constraints are that the restricted type must be an inline type and the descriptor\n+    \/\/ type must be a super type of the restricted type.\n+    \/\/ The code below verifies that the restricted type is an inline type. The property that the\n+    \/\/ descriptor type is a super type of the restricted type is verified just after the pre-loading\n+    \/\/ of the restricted type (inline type field preloading)\n+    if (has_restricted_type && cp->basic_type_for_signature_at(restricted_type_index) != T_INLINE_TYPE) {\n+      \/\/ Probably not the right error to throw\n+      THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                err_msg(\"Field %s.%s has a RestricteField attribute but its restricted type is not an inline type\",\n+                _class_name->as_C_string(),\n+                _cp->symbol_at(restricted_type_index)->as_C_string()));\n+    }\n+\n+    u2 sharp_type_index, erased_type_index;\n+    if (has_restricted_type) {\n+      sharp_type_index = restricted_type_index;\n+      erased_type_index = signature_index;\n+    } else {\n+      sharp_type_index = signature_index;\n+      erased_type_index = signature_index;\n+    }\n+\n@@ -1777,1 +1828,1 @@\n-                      signature_index,\n+                      sharp_type_index,\n@@ -1779,0 +1830,3 @@\n+    _descriptor_signature_info->append(erased_type_index);\n+    field->set_has_rectricted_type(has_restricted_type);\n+\n@@ -1828,0 +1882,1 @@\n+      _descriptor_signature_info->append(0);\n@@ -1831,0 +1886,1 @@\n+  \/\/ Add internal static field to inline type to store the pre-allocated default value\n@@ -1838,0 +1894,1 @@\n+    \/\/ Remember how many oops we encountered\n@@ -1840,0 +1897,1 @@\n+    _descriptor_signature_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)));\n@@ -1842,0 +1900,3 @@\n+  \/\/ True zero size inline types are causing issues when inlined, so the current\n+  \/\/ implementation inserts a byte field to work around the issue\n+  \/\/ Could be optimized later after revisiting use of field offsets as field identifiers\n@@ -1850,0 +1911,1 @@\n+    \/\/ Remember how many oops we encountered\n@@ -1852,0 +1914,1 @@\n+    _descriptor_signature_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)));\n@@ -2630,0 +2693,4 @@\n+  bool has_restricted_method_attribute = false;\n+  const u1* restricted_param_types_start = NULL;\n+  u2 restricted_return_type_index = 0;\n+  u1 restricted_num_params = 0;\n@@ -2966,0 +3033,23 @@\n+      } else if (method_attribute_name == vmSymbols::tag_restricted_method()) {\n+        const u1* const current_start = cfs->current();\n+\n+        \/\/ RestrictedMethod_attribute {\n+        \/\/   u2 name_index;\n+        \/\/   u4 length;\n+        \/\/   u1 num_params;\n+        \/\/   u2 restricted_param_type[num_params];\n+        \/\/   u2 restricted_return_type;\n+        \/\/ }\n+\n+        has_restricted_method_attribute = true;\n+        cfs->guarantee_more(1, CHECK_NULL);  \/\/ num_params\n+        restricted_num_params = cfs->get_u1_fast();\n+        guarantee_property((int)method_attribute_length == restricted_num_params * 2 + 3,\n+                          \"Invalid RestrictedMethod attribute length %u in class file %s\",\n+                          method_attribute_length,\n+                          CHECK_NULL);\n+\n+        restricted_param_types_start = cfs->current();\n+        cfs->skip_u2_fast(restricted_num_params);\n+        cfs->guarantee_more(2, CHECK_NULL);  \/\/ restricted_return_type\n+        restricted_return_type_index = cfs->get_u2_fast();\n@@ -3005,0 +3095,4 @@\n+      \/\/ RestrictedMethod atribute requires a more complex protocol because num_params can be zeo\n+      \/\/ but the attribute still be there because of a restricted return value\n+      \/\/ So -1 is passed if the attribute is absent, otherwise num_params is passed\n+      has_restricted_method_attribute ? restricted_num_params : -1 ,\n@@ -3108,0 +3202,12 @@\n+  \/\/ Copy RestrictedMethod attribute if present\n+  if (has_restricted_method_attribute) {\n+    m->set_restricted_method(true);\n+    *(m->constMethod()->restricted_num_params_addr()) = restricted_num_params;\n+    *(m->constMethod()->restricted_return_type_index_addr()) = restricted_return_type_index;\n+    u2* cursor = m->constMethod()->restricted_param_type_start();\n+    for (int i = 0; i < restricted_num_params; i++) {\n+      cursor[i] = Bytes::get_Java_u2((address)restricted_param_types_start);\n+      restricted_param_types_start +=2;\n+    }\n+  }\n+\n@@ -5898,0 +6004,8 @@\n+  if(has_restricted_fields()) {\n+    ik->set_has_restricted_fields();\n+    u2* rfi = ik->fields_descriptor_type();\n+    for (int i = 0; i < ik->java_fields_count(); i++) {\n+      rfi[i] = _descriptor_signature_info->at(i);\n+    }\n+  }\n+\n@@ -6102,0 +6216,1 @@\n+  _descriptor_signature_info(NULL),\n@@ -6143,0 +6258,1 @@\n+  _has_restricted_fields(false),\n@@ -6728,0 +6844,1 @@\n+  \/\/ Pre-loading classes of inlined types non static fields\n@@ -6730,1 +6847,0 @@\n-      \/\/ Pre-load inline class\n@@ -6743,0 +6859,13 @@\n+      if (fs.has_restricted_type()) {\n+        \/\/ descriptor type supposed to be a super type of the restricted type, so after the pre-loading\n+        \/\/ of the restricted type above, the descriptor type should be loaded at this point\n+        Symbol* descriptor_name = _cp->symbol_at(_descriptor_signature_info->at(fs.index()));\n+        ResolvingSignatureStream rss(descriptor_name, Handle(THREAD, _loader_data->class_loader()), _protection_domain, false);\n+        Klass* desc_klass = rss.as_klass(SignatureStream::ReturnNull, CHECK);\n+        if (desc_klass == NULL || !klass->is_subtype_of(desc_klass)) {\n+          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                    err_msg(\"Restricted type %s should be a subtype of the descriptor type %s, but it is not\",\n+                    fs.signature()->as_C_string(),\n+                    descriptor_name->as_C_string()));\n+        }\n+      }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":131,"deletions":2,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -476,1 +476,2 @@\n-                                       parser.is_inline_type());\n+                                       parser.is_inline_type(),\n+                                       parser.has_restricted_fields());\n@@ -511,0 +512,4 @@\n+  if (parser.has_restricted_fields()) {\n+    ik->set_has_restricted_fields(); \/\/ required to get the size right when calling size()\n+  }\n+\n@@ -1031,0 +1036,4 @@\n+      \/\/ Loadding classes of restricted parameters\n+      if (m->constMethod()->has_restricted_method()) {\n+        m->resolve_restricted_types(CHECK_false);\n+      }\n@@ -1256,0 +1265,1 @@\n+\n@@ -1660,4 +1670,14 @@\n-    Symbol* f_sig  = fs.signature();\n-    if (f_name == name && f_sig == sig) {\n-      fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n-      return true;\n+    if (f_name == name) {\n+      Symbol* f_sig = NULL;\n+      f_sig  = fs.signature();\n+      if (f_sig == sig) {\n+        fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+        return true;\n+      }\n+      if (fs.has_restricted_type()) {\n+        f_sig = fs.descriptor_signature();\n+        if (f_sig == sig) {\n+          fd->reinitialize(const_cast<InstanceKlass*>(this), fs.index());\n+          return true;\n+        }\n+      }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\/\/    [EMBEDDED restricted_fields_info] only if has_restricted_fields() == true\n@@ -296,1 +297,2 @@\n-    _misc_has_injected_primitiveObject        = 1 << 23  \/\/ PrimitiveObject has been injected by the JVM\n+    _misc_has_injected_primitiveObject        = 1 << 23, \/\/ PrimitiveObject has been injected by the JVM\n+    _misc_has_restricted_fields               = 1 << 24  \/\/ class has fields with type restrictions\n@@ -480,1 +482,1 @@\n-    return (_misc_flags & _misc_has_injected_identityObject);\n+    return (_misc_flags & _misc_has_injected_identityObject) != 0;\n@@ -495,0 +497,8 @@\n+  bool has_restricted_fields() const {\n+    return (_misc_flags & _misc_has_restricted_fields) != 0;\n+  }\n+\n+  void set_has_restricted_fields() {\n+    _misc_flags |= _misc_has_restricted_fields;\n+  }\n+\n@@ -559,0 +569,1 @@\n+  bool    field_has_restricted_type(int index) const { return field(index)->has_restricted_type(); }\n@@ -1189,1 +1200,1 @@\n-                  int java_fields, bool is_inline_type) {\n+                  int java_fields, bool is_inline_type, bool has_restricted_fields) {\n@@ -1198,1 +1209,2 @@\n-           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0));\n+           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0) +\n+           (has_restricted_fields ? (align_up(java_fields * (int)sizeof(u2), wordSize)\/wordSize) : 0));\n@@ -1207,1 +1219,2 @@\n-                                               is_inline_klass());\n+                                               is_inline_klass(),\n+                                               has_restricted_fields());\n@@ -1223,0 +1236,2 @@\n+  inline u2* fields_descriptor_type() const;\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -306,0 +307,29 @@\n+inline u2* InstanceKlass::fields_descriptor_type() const {\n+    assert(has_restricted_fields(), \"Should not be called otherwise\");\n+    if (is_inline_klass()) {\n+      return (u2*)((address)(InlineKlass::cast((Klass*)this)->inlineklass_static_block()) + sizeof(InlineKlassFixedBlock));\n+    }\n+\n+    address adr_jf = adr_inline_type_field_klasses();\n+    if (adr_jf != NULL) {\n+      return (u2*)(adr_jf + this->java_fields_count() * sizeof(Klass*));\n+    }\n+\n+    address adr_fing = adr_fingerprint();\n+    if (adr_fing != NULL) {\n+      return (u2*)(adr_fingerprint() + sizeof(u8));\n+    }\n+\n+    InstanceKlass** adr_host = adr_unsafe_anonymous_host();\n+    if (adr_host != NULL) {\n+      return (u2*)(adr_host + 1);\n+    }\n+\n+    InstanceKlass* volatile* adr_impl = adr_implementor();\n+    if (adr_impl != NULL) {\n+      return (u2*)(adr_impl + 1);\n+    }\n+\n+    return (u2*)end_of_nonstatic_oop_maps();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  int size = Method::size(access_flags.is_native());\n+  int size = Method::size(access_flags.is_native(), sizes);\n@@ -179,0 +179,33 @@\n+\n+void  Method::resolve_restricted_types(TRAPS) {\n+  int idx = constMethod()->restricted_return_value_index();\n+  Handle loader_h(THREAD, constants()->pool_holder()->class_loader());\n+  Handle protdom_h(THREAD, constants()->pool_holder()->protection_domain());\n+  if (idx != 0) {\n+    Symbol* ret = constants()->symbol_at(idx);\n+    Klass* k = SystemDictionary::resolve_or_fail(ret, loader_h, protdom_h, true, CHECK);\n+    *restricted_return_value_addr() = k;\n+  } else {\n+    *restricted_return_value_addr() = NULL;\n+  }\n+  Klass** param_array = restricted_param_type_start();\n+  for (int i = 0; i < restricted_num_param(); i++) {\n+    int idx = constMethod()->restricted_param_type_index_at(i);\n+    if (idx != 0) {\n+      Symbol* ret = constants()->symbol_at(idx);\n+      Klass* k = SystemDictionary::resolve_or_fail(ret, loader_h, protdom_h, true, CHECK);\n+      param_array[i] = k;\n+    } else {\n+      param_array[i] = NULL;\n+    }\n+  }\n+}\n+\n+Klass* Method::restricted_return_value() const {\n+  return *restricted_return_value_addr();\n+}\n+\n+Klass* Method::restricted_param_type_at(int index) const {\n+  return restricted_param_type_start()[index];\n+}\n+\n@@ -344,1 +377,1 @@\n-int Method::size(bool is_native) {\n+int Method::size(bool is_native, InlineTableSizes* sizes) {\n@@ -347,0 +380,3 @@\n+  if (sizes->restricted_method_length() != -1) {\n+    extra_bytes += (sizes->restricted_method_length() + 1) * sizeof(Klass*); \/\/ +1 is for the return value type\n+  }\n@@ -1618,0 +1654,1 @@\n+  int restricted_method_len = 0;\n@@ -1630,0 +1667,1 @@\n+      restricted_method_len,\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"}]}