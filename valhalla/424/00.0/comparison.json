{"files":[{"patch":"@@ -3014,28 +3014,5 @@\n-      Label is_null_free_inline_type, uninitialized;\n-      \/\/ Issue below if the static field has not been initialized yet\n-      __ test_field_is_null_free_inline_type(flags2, rscratch1, is_null_free_inline_type);\n-        \/\/ field is not a null free inline type\n-        __ push(atos);\n-        __ jmp(Done);\n-      \/\/ field is a null free inline type, must not return null even if uninitialized\n-      __ bind(is_null_free_inline_type);\n-        __ testptr(rax, rax);\n-        __ jcc(Assembler::zero, uninitialized);\n-          __ push(atos);\n-          __ jmp(Done);\n-        __ bind(uninitialized);\n-          __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n-#ifdef _LP64\n-          Label slow_case, finish;\n-          __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n-          __ jcc(Assembler::notEqual, slow_case);\n-        __ get_default_value_oop(rcx, off, rax);\n-        __ jmp(finish);\n-        __ bind(slow_case);\n-#endif \/\/ LP64\n-          __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field),\n-                 obj, flags2);\n-#ifdef _LP64\n-          __ bind(finish);\n-#endif \/\/ _LP64\n-          __ verify_oop(rax);\n+      if (EnableValhalla) {\n+        Label is_null_free_inline_type, uninitialized;\n+        \/\/ Issue below if the static field has not been initialized yet\n+        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_null_free_inline_type);\n+          \/\/ field is not a null free inline type\n@@ -3044,0 +3021,25 @@\n+        \/\/ field is a null free inline type, must not return null even if uninitialized\n+        __ bind(is_null_free_inline_type);\n+           __ testptr(rax, rax);\n+          __ jcc(Assembler::zero, uninitialized);\n+            __ push(atos);\n+            __ jmp(Done);\n+          __ bind(uninitialized);\n+            __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n+  #ifdef _LP64\n+            Label slow_case, finish;\n+            __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n+            __ jcc(Assembler::notEqual, slow_case);\n+          __ get_default_value_oop(rcx, off, rax);\n+          __ jmp(finish);\n+          __ bind(slow_case);\n+  #endif \/\/ LP64\n+            __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field),\n+                  obj, flags2);\n+  #ifdef _LP64\n+            __ bind(finish);\n+  #endif \/\/ _LP64\n+      }\n+        __ verify_oop(rax);\n+        __ push(atos);\n+        __ jmp(Done);\n@@ -3046,5 +3048,37 @@\n-      __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n-        \/\/ field is not an inline type\n-        pop_and_check_object(obj);\n-        __ load_heap_oop(rax, field);\n-        __ push(atos);\n+      if (EnableValhalla) {\n+        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+      }\n+      \/\/ field is not a null free inline type\n+      pop_and_check_object(obj);\n+      __ load_heap_oop(rax, field);\n+      __ push(atos);\n+      if (rc == may_rewrite) {\n+        patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);\n+      }\n+      __ jmp(Done);\n+      if (EnableValhalla) {\n+        __ bind(is_inline_type);\n+          __ test_field_is_inlined(flags2, rscratch1, is_inlined);\n+            \/\/ field is not inlined\n+            __ movptr(rax, rcx);  \/\/ small dance required to preserve the klass_holder somewhere\n+            pop_and_check_object(obj);\n+            __ push(rax);\n+            __ load_heap_oop(rax, field);\n+            __ pop(rcx);\n+            __ testptr(rax, rax);\n+            __ jcc(Assembler::notZero, nonnull);\n+              __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n+              __ get_inline_type_field_klass(rcx, flags2, rbx);\n+              __ get_default_value_oop(rbx, rcx, rax);\n+            __ bind(nonnull);\n+            __ verify_oop(rax);\n+            __ push(atos);\n+            __ jmp(rewrite_inline);\n+          __ bind(is_inlined);\n+          \/\/ field is inlined\n+            __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n+            pop_and_check_object(rax);\n+            __ read_inlined_field(rcx, flags2, rbx, rax);\n+            __ verify_oop(rax);\n+            __ push(atos);\n+        __ bind(rewrite_inline);\n@@ -3052,1 +3086,1 @@\n-          patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);\n+          patch_bytecode(Bytecodes::_fast_qgetfield, bc, rbx);\n@@ -3055,28 +3089,0 @@\n-      __ bind(is_inline_type);\n-        __ test_field_is_inlined(flags2, rscratch1, is_inlined);\n-          \/\/ field is not inlined\n-          __ movptr(rax, rcx);  \/\/ small dance required to preserve the klass_holder somewhere\n-          pop_and_check_object(obj);\n-          __ push(rax);\n-          __ load_heap_oop(rax, field);\n-          __ pop(rcx);\n-          __ testptr(rax, rax);\n-          __ jcc(Assembler::notZero, nonnull);\n-            __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n-            __ get_inline_type_field_klass(rcx, flags2, rbx);\n-            __ get_default_value_oop(rbx, rcx, rax);\n-          __ bind(nonnull);\n-          __ verify_oop(rax);\n-          __ push(atos);\n-          __ jmp(rewrite_inline);\n-        __ bind(is_inlined);\n-        \/\/ field is inlined\n-          __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n-          pop_and_check_object(rax);\n-          __ read_inlined_field(rcx, flags2, rbx, rax);\n-          __ verify_oop(rax);\n-          __ push(atos);\n-      __ bind(rewrite_inline);\n-      if (rc == may_rewrite) {\n-        patch_bytecode(Bytecodes::_fast_qgetfield, bc, rbx);\n-      __ jmp(Done);\n@@ -3395,3 +3401,5 @@\n-        __ test_field_is_not_null_free_inline_type(flags2, rscratch1, is_inline_type);\n-        __ null_check(rax);\n-        __ bind(is_inline_type);\n+        if (EnableValhalla) {\n+          __ test_field_is_not_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+          __ null_check(rax);\n+          __ bind(is_inline_type);\n+        }\n@@ -3402,1 +3410,3 @@\n-        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+        if (EnableValhalla) {\n+          __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+        }\n@@ -3412,20 +3422,23 @@\n-        \/\/ Implementation of the inline type semantic\n-        __ bind(is_inline_type);\n-        __ null_check(rax);\n-        __ test_field_is_inlined(flags2, rscratch1, is_inlined);\n-        \/\/ field is not inlined\n-        pop_and_check_object(obj);\n-        \/\/ Store into the field\n-        do_oop_store(_masm, field, rax);\n-        __ jmp(rewrite_inline);\n-        __ bind(is_inlined);\n-        \/\/ field is inlined\n-        pop_and_check_object(obj);\n-        assert_different_registers(rax, rdx, obj, off);\n-        __ load_klass(rdx, rax, rscratch1);\n-        __ data_for_oop(rax, rax, rdx);\n-        __ addptr(obj, off);\n-        __ access_value_copy(IN_HEAP, rax, obj, rdx);\n-        __ bind(rewrite_inline);\n-        if (rc == may_rewrite) {\n-          patch_bytecode(Bytecodes::_fast_qputfield, bc, rbx, true, byte_no);\n+        if (EnableValhalla) {\n+          \/\/ Implementation of the inline type semantic\n+          __ bind(is_inline_type);\n+          __ null_check(rax);\n+          __ test_field_is_inlined(flags2, rscratch1, is_inlined);\n+          \/\/ field is not inlined\n+          pop_and_check_object(obj);\n+          \/\/ Store into the field\n+          do_oop_store(_masm, field, rax);\n+          __ jmp(rewrite_inline);\n+          __ bind(is_inlined);\n+          \/\/ field is inlined\n+          pop_and_check_object(obj);\n+          assert_different_registers(rax, rdx, obj, off);\n+          __ load_klass(rdx, rax, rscratch1);\n+          __ data_for_oop(rax, rax, rdx);\n+          __ addptr(obj, off);\n+          __ access_value_copy(IN_HEAP, rax, obj, rdx);\n+          __ bind(rewrite_inline);\n+          if (rc == may_rewrite) {\n+            patch_bytecode(Bytecodes::_fast_qputfield, bc, rbx, true, byte_no);\n+          }\n+          __ jmp(Done);\n@@ -3433,1 +3446,0 @@\n-        __ jmp(Done);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":99,"deletions":87,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -6627,1 +6627,1 @@\n-  if (!is_inline_type() && invalid_inline_super() && (_super_klass == NULL || !_super_klass->invalid_inline_super())\n+  if (EnableValhalla && !is_inline_type() && invalid_inline_super() && (_super_klass == NULL || !_super_klass->invalid_inline_super())\n@@ -6694,14 +6694,16 @@\n-  for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n-    if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE && !fs.access_flags().is_static()) {\n-      \/\/ Pre-load inline class\n-      Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&fs,\n-          Handle(THREAD, _loader_data->class_loader()),\n-          _protection_domain, true, CHECK);\n-      assert(klass != NULL, \"Sanity check\");\n-      if (!klass->access_flags().is_inline_type()) {\n-        assert(klass->is_instance_klass(), \"Sanity check\");\n-        ResourceMark rm(THREAD);\n-          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                    err_msg(\"Class %s expects class %s to be an inline type, but it is not\",\n-                    _class_name->as_C_string(),\n-                    InstanceKlass::cast(klass)->external_name()));\n+  if (EnableValhalla) {\n+    for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n+      if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE && !fs.access_flags().is_static()) {\n+        \/\/ Pre-load inline class\n+        Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&fs,\n+            Handle(THREAD, _loader_data->class_loader()),\n+            _protection_domain, true, CHECK);\n+        assert(klass != NULL, \"Sanity check\");\n+        if (!klass->access_flags().is_inline_type()) {\n+          assert(klass->is_instance_klass(), \"Sanity check\");\n+          ResourceMark rm(THREAD);\n+            THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                      err_msg(\"Class %s expects class %s to be an inline type, but it is not\",\n+                      _class_name->as_C_string(),\n+                      InstanceKlass::cast(klass)->external_name()));\n+        }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -999,1 +999,1 @@\n-  {\n+  if (EnableValhalla) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata(), t.isReferenceProjection()) {\n+                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata(), t.getFlavor()) {\n@@ -1028,1 +1028,1 @@\n-        return t != null && !t.isReferenceProjection() && t.tsym != null && (t.tsym.flags_field & Flags.PRIMITIVE_CLASS) != 0;\n+        return t != null && t.isPrimitiveClass();\n@@ -2581,1 +2581,1 @@\n-                if (t.isReferenceProjection()) {\n+                if (erased.hasTag(CLASS) && t.flavor != erased.getFlavor()) {\n@@ -2584,1 +2584,1 @@\n-                            erased.getMetadata(), true);\n+                            erased.getMetadata(), t.flavor);\n@@ -2648,2 +2648,0 @@\n-        if (isPrimitiveClass(bounds.head))\n-            flags |= PRIMITIVE_CLASS;\n@@ -2921,1 +2919,1 @@\n-                                         t.getMetadata(), t.isReferenceProjection());\n+                                         t.getMetadata(), t.getFlavor());\n@@ -4048,1 +4046,1 @@\n-                                 class1.tsym);\n+                                 class1.tsym, TypeMetadata.EMPTY, class1.getFlavor());\n@@ -4607,1 +4605,1 @@\n-                                 cls.getMetadata(), cls.isReferenceProjection());\n+                                 cls.getMetadata(), cls.getFlavor());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"}]}