{"files":[{"patch":"@@ -2375,1 +2375,1 @@\n-    if (ProfileInterpreter) {\n+    if (ProfileInterpreter && !TieredCompilation) {\n@@ -2485,0 +2485,2 @@\n+  __ profile_acmp(rbx, rdx, rax, rcx);\n+\n@@ -2491,3 +2493,1 @@\n-    __ movptr(rbx, rdx);\n-    __ andptr(rbx, rax);\n-    __ testptr(rbx, rbx);\n+    __ testptr(rdx, rax);\n@@ -2498,0 +2498,1 @@\n+    __ andptr(rbx, Address(rax, oopDesc::mark_offset_in_bytes()));\n@@ -2499,4 +2500,1 @@\n-    __ movptr(rcx, Address(rax, oopDesc::mark_offset_in_bytes()));\n-    __ andptr(rbx, is_inline_type_mask);\n-    __ andptr(rbx, rcx);\n-    __ cmpl(rbx, is_inline_type_mask);\n+    __ cmpptr(rbx, is_inline_type_mask);\n@@ -2525,1 +2523,1 @@\n-  __ profile_not_taken_branch(rax);\n+  __ profile_not_taken_branch(rax, true);\n@@ -2783,1 +2781,1 @@\n-    __ testb(Address(r15_thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());\n+    __ testb(Address(r15_thread, Thread::polling_word_offset()), SafepointMechanism::poll_bit());\n@@ -2787,1 +2785,1 @@\n-    __ testb(Address(thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());\n+    __ testb(Address(thread, Thread::polling_word_offset()), SafepointMechanism::poll_bit());\n@@ -2792,1 +2790,1 @@\n-                                    InterpreterRuntime::at_safepoint));\n+                                       InterpreterRuntime::at_safepoint));\n@@ -3973,5 +3971,0 @@\n-void TemplateTable::count_calls(Register method, Register temp) {\n-  \/\/ implemented elsewhere\n-  ShouldNotReachHere();\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -220,1 +220,2 @@\n-            tag, CHECK);\n+            tag, THREAD);\n+          return;\n@@ -242,1 +243,2 @@\n-              tag, CHECK);\n+              tag, THREAD);\n+          return;\n@@ -257,1 +259,2 @@\n-              tag, CHECK);\n+              tag, THREAD);\n+          return;\n@@ -376,2 +379,2 @@\n-                              CHECK);\n-        break;\n+                              THREAD);\n+        return;\n@@ -577,1 +580,2 @@\n-              index, CHECK);\n+              index, THREAD);\n+            return;\n@@ -755,1 +759,2 @@\n-              name_ref_index, CHECK);\n+              name_ref_index, THREAD);\n+            return;\n@@ -777,1 +782,2 @@\n-                    name_ref_index, CHECK);\n+                    name_ref_index, THREAD);\n+                return;\n@@ -794,1 +800,2 @@\n-                  name_ref_index, CHECK);\n+                  name_ref_index, THREAD);\n+                return;\n@@ -1059,1 +1066,1 @@\n-                             name->as_C_string(), CHECK);\n+                             name->as_C_string(), THREAD);\n@@ -1115,1 +1122,1 @@\n-                             CHECK);\n+                             THREAD);\n@@ -1404,1 +1411,2 @@\n-        classfile_parse_error(\"Duplicate ConstantValue attribute in class file %s\", CHECK);\n+        classfile_parse_error(\"Duplicate ConstantValue attribute in class file %s\", THREAD);\n+        return;\n@@ -1419,1 +1427,2 @@\n-          attribute_length, CHECK);\n+          attribute_length, THREAD);\n+        return;\n@@ -1426,1 +1435,2 @@\n-          attribute_length, CHECK);\n+          attribute_length, THREAD);\n+        return;\n@@ -1432,1 +1442,2 @@\n-            \"Multiple Signature attributes for field in class file %s\", CHECK);\n+            \"Multiple Signature attributes for field in class file %s\", THREAD);\n+          return;\n@@ -1437,1 +1448,2 @@\n-            attribute_length, CHECK);\n+            attribute_length, THREAD);\n+          return;\n@@ -1443,1 +1455,2 @@\n-            \"Multiple RuntimeVisibleAnnotations attributes for field in class file %s\", CHECK);\n+            \"Multiple RuntimeVisibleAnnotations attributes for field in class file %s\", THREAD);\n+          return;\n@@ -1472,1 +1485,2 @@\n-            \"Multiple RuntimeInvisibleAnnotations attributes for field in class file %s\", CHECK);\n+            \"Multiple RuntimeInvisibleAnnotations attributes for field in class file %s\", THREAD);\n+          return;\n@@ -1484,1 +1498,2 @@\n-            \"Multiple RuntimeVisibleTypeAnnotations attributes for field in class file %s\", CHECK);\n+            \"Multiple RuntimeVisibleTypeAnnotations attributes for field in class file %s\", THREAD);\n+          return;\n@@ -1493,1 +1508,2 @@\n-            \"Multiple RuntimeInvisibleTypeAnnotations attributes for field in class file %s\", CHECK);\n+            \"Multiple RuntimeInvisibleTypeAnnotations attributes for field in class file %s\", THREAD);\n+          return;\n@@ -1826,3 +1842,3 @@\n-      field->initialize(JVM_ACC_FIELD_INTERNAL,\n-                        injected[n].name_index,\n-                        injected[n].signature_index,\n+      field->initialize((u2)JVM_ACC_FIELD_INTERNAL,\n+                        (u2)(injected[n].name_index),\n+                        (u2)(injected[n].signature_index),\n@@ -1844,2 +1860,2 @@\n-                      vmSymbols::default_value_name_enum,\n-                      vmSymbols::object_signature_enum,\n+                      (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(default_value_name)),\n+                      (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)),\n@@ -1851,1 +1867,1 @@\n-    _restricted_field_info->append(vmSymbols::object_signature_enum);\n+    _restricted_field_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)));\n@@ -1861,2 +1877,2 @@\n-        vmSymbols::empty_marker_name_enum,\n-        vmSymbols::byte_signature_enum,\n+        (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(empty_marker_name)),\n+        (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)),\n@@ -1868,1 +1884,1 @@\n-    _restricted_field_info->append(vmSymbols::byte_signature_enum);\n+    _restricted_field_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)));\n@@ -1920,1 +1936,1 @@\n-                             name->as_C_string(), sig->as_klass_external_name(), CHECK);\n+                             name->as_C_string(), sig->as_klass_external_name(), THREAD);\n@@ -2088,1 +2104,2 @@\n-          start_pc, tbl_name, CHECK_NULL);\n+          start_pc, tbl_name, THREAD);\n+        return NULL;\n@@ -2093,1 +2110,2 @@\n-          length, tbl_name, CHECK_NULL);\n+          length, tbl_name, THREAD);\n+        return NULL;\n@@ -2206,1 +2224,1 @@\n-  const vmSymbols::SID sid = vmSymbols::find_sid(name);\n+  const vmSymbolID sid = vmSymbols::find_sid(name);\n@@ -2212,1 +2230,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {\n+    case VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {\n@@ -2217,1 +2235,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {\n@@ -2222,1 +2240,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {\n@@ -2227,1 +2245,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {\n+    case VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {\n@@ -2232,1 +2250,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_LambdaForm_Compiled_signature): {\n+    case VM_SYMBOL_ENUM_NAME(java_lang_invoke_LambdaForm_Compiled_signature): {\n@@ -2237,1 +2255,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Hidden_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Hidden_signature): {\n@@ -2242,1 +2260,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_IntrinsicCandidate_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_IntrinsicCandidate_signature): {\n@@ -2247,1 +2265,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Stable_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Stable_signature): {\n@@ -2252,1 +2270,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Contended_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Contended_signature): {\n@@ -2261,1 +2279,1 @@\n-    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ReservedStackAccess_signature): {\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ReservedStackAccess_signature): {\n@@ -2358,1 +2376,2 @@\n-                               CHECK);\n+                               THREAD);\n+        return;\n@@ -2377,1 +2396,2 @@\n-                                 CHECK);\n+                                 THREAD);\n+          return;\n@@ -2383,1 +2403,2 @@\n-                               CHECK);\n+                               THREAD);\n+        return;\n@@ -2502,1 +2523,2 @@\n-      classfile_parse_error(\"Method <clinit> is not static in class file %s\", CHECK_NULL);\n+      classfile_parse_error(\"Method <clinit> is not static in class file %s\", THREAD);\n+      return NULL;\n@@ -2510,1 +2532,2 @@\n-      classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", CHECK_NULL);\n+      classfile_parse_error(\"Interface cannot have a method named <init>, class file %s\", THREAD);\n+      return NULL;\n@@ -2562,1 +2585,2 @@\n-      classfile_parse_error(\"Too many arguments in method signature in class file %s\", CHECK_NULL);\n+      classfile_parse_error(\"Too many arguments in method signature in class file %s\", THREAD);\n+      return NULL;\n@@ -2641,1 +2665,2 @@\n-                              CHECK_NULL);\n+                              THREAD);\n+        return NULL;\n@@ -2773,1 +2798,2 @@\n-            classfile_parse_error(\"Multiple StackMapTable attributes in class file %s\", CHECK_NULL);\n+            classfile_parse_error(\"Multiple StackMapTable attributes in class file %s\", THREAD);\n+            return NULL;\n@@ -2793,1 +2819,2 @@\n-                              CHECK_NULL);\n+                              THREAD);\n+        return NULL;\n@@ -2805,1 +2832,2 @@\n-                              CHECK_NULL);\n+                              THREAD);\n+        return NULL;\n@@ -2813,1 +2841,2 @@\n-          method_attribute_length, CHECK_NULL);\n+          method_attribute_length, THREAD);\n+        return NULL;\n@@ -2825,1 +2854,2 @@\n-          method_attribute_length, CHECK_NULL);\n+          method_attribute_length, THREAD);\n+        return NULL;\n@@ -2833,1 +2863,2 @@\n-          method_attribute_length, CHECK_NULL);\n+          method_attribute_length, THREAD);\n+        return NULL;\n@@ -2840,1 +2871,2 @@\n-            CHECK_NULL);\n+            THREAD);\n+          return NULL;\n@@ -2845,1 +2877,2 @@\n-            method_attribute_length, CHECK_NULL);\n+            method_attribute_length, THREAD);\n+          return NULL;\n@@ -2852,1 +2885,2 @@\n-            CHECK_NULL);\n+            THREAD);\n+          return NULL;\n@@ -2870,1 +2904,2 @@\n-            CHECK_NULL);\n+            THREAD);\n+          return NULL;\n@@ -2883,1 +2918,2 @@\n-            CHECK_NULL);\n+            THREAD);\n+          return NULL;\n@@ -2893,1 +2929,2 @@\n-            CHECK_NULL);\n+            THREAD);\n+          return NULL;\n@@ -2907,1 +2944,2 @@\n-            CHECK_NULL);\n+            THREAD);\n+          return NULL;\n@@ -2917,1 +2955,2 @@\n-            CHECK_NULL);\n+            THREAD);\n+          return NULL;\n@@ -2928,1 +2967,2 @@\n-            CHECK_NULL);\n+            THREAD);\n+          return NULL;\n@@ -3171,1 +3211,1 @@\n-                               name->as_C_string(), sig->as_klass_external_name(), CHECK);\n+                               name->as_C_string(), sig->as_klass_external_name(), THREAD);\n@@ -3420,1 +3460,2 @@\n-    classfile_parse_error(\"PermittedSubclasses attribute is empty in class file %s\", CHECK_0);\n+    classfile_parse_error(\"PermittedSubclasses attribute is empty in class file %s\", THREAD);\n+    return 0;\n@@ -3522,1 +3563,2 @@\n-            CHECK_0);\n+            THREAD);\n+          return 0;\n@@ -3527,1 +3569,2 @@\n-            attribute_length, CHECK_0);\n+            attribute_length, THREAD);\n+          return 0;\n@@ -3534,1 +3577,2 @@\n-            \"Multiple RuntimeVisibleAnnotations attributes for Record component in class file %s\", CHECK_0);\n+            \"Multiple RuntimeVisibleAnnotations attributes for Record component in class file %s\", THREAD);\n+          return 0;\n@@ -3546,1 +3590,2 @@\n-            \"Multiple RuntimeInvisibleAnnotations attributes for Record component in class file %s\", CHECK_0);\n+            \"Multiple RuntimeInvisibleAnnotations attributes for Record component in class file %s\", THREAD);\n+          return 0;\n@@ -3559,1 +3604,2 @@\n-            \"Multiple RuntimeVisibleTypeAnnotations attributes for Record component in class file %s\", CHECK_0);\n+            \"Multiple RuntimeVisibleTypeAnnotations attributes for Record component in class file %s\", THREAD);\n+          return 0;\n@@ -3571,1 +3617,2 @@\n-            \"Multiple RuntimeInvisibleTypeAnnotations attributes for Record component in class file %s\", CHECK_0);\n+            \"Multiple RuntimeInvisibleTypeAnnotations attributes for Record component in class file %s\", THREAD);\n+          return 0;\n@@ -3781,1 +3828,2 @@\n-        classfile_parse_error(\"Multiple SourceFile attributes in class file %s\", CHECK);\n+        classfile_parse_error(\"Multiple SourceFile attributes in class file %s\", THREAD);\n+        return;\n@@ -3789,2 +3837,3 @@\n-          classfile_parse_error(\n-            \"Multiple SourceDebugExtension attributes in class file %s\", CHECK);\n+        classfile_parse_error(\n+          \"Multiple SourceDebugExtension attributes in class file %s\", THREAD);\n+        return;\n@@ -3797,1 +3846,2 @@\n-        classfile_parse_error(\"Multiple InnerClasses attributes in class file %s\", CHECK);\n+        classfile_parse_error(\"Multiple InnerClasses attributes in class file %s\", THREAD);\n+        return;\n@@ -3810,1 +3860,2 @@\n-          attribute_length, CHECK);\n+          attribute_length, THREAD);\n+        return;\n@@ -3818,1 +3869,2 @@\n-          attribute_length, CHECK);\n+          attribute_length, THREAD);\n+        return;\n@@ -3824,1 +3876,2 @@\n-            \"Multiple Signature attributes in class file %s\", CHECK);\n+            \"Multiple Signature attributes in class file %s\", THREAD);\n+          return;\n@@ -3829,1 +3882,2 @@\n-            attribute_length, CHECK);\n+            attribute_length, THREAD);\n+          return;\n@@ -3835,1 +3889,2 @@\n-            \"Multiple RuntimeVisibleAnnotations attributes in class file %s\", CHECK);\n+            \"Multiple RuntimeVisibleAnnotations attributes in class file %s\", THREAD);\n+          return;\n@@ -3852,1 +3907,2 @@\n-            \"Multiple RuntimeInvisibleAnnotations attributes in class file %s\", CHECK);\n+            \"Multiple RuntimeInvisibleAnnotations attributes in class file %s\", THREAD);\n+          return;\n@@ -3863,1 +3919,2 @@\n-          classfile_parse_error(\"Multiple EnclosingMethod attributes in class file %s\", CHECK);\n+          classfile_parse_error(\"Multiple EnclosingMethod attributes in class file %s\", THREAD);\n+          return;\n@@ -3874,1 +3931,2 @@\n-          classfile_parse_error(\"Invalid class index in EnclosingMethod attribute in class file %s\", CHECK);\n+          classfile_parse_error(\"Invalid class index in EnclosingMethod attribute in class file %s\", THREAD);\n+          return;\n@@ -3882,1 +3940,2 @@\n-          classfile_parse_error(\"Invalid or out-of-bounds method index in EnclosingMethod attribute in class file %s\", CHECK);\n+          classfile_parse_error(\"Invalid or out-of-bounds method index in EnclosingMethod attribute in class file %s\", THREAD);\n+          return;\n@@ -3887,1 +3946,2 @@\n-          classfile_parse_error(\"Multiple BootstrapMethods attributes in class file %s\", CHECK);\n+          classfile_parse_error(\"Multiple BootstrapMethods attributes in class file %s\", THREAD);\n+          return;\n@@ -3894,1 +3954,2 @@\n-            \"Multiple RuntimeVisibleTypeAnnotations attributes in class file %s\", CHECK);\n+            \"Multiple RuntimeVisibleTypeAnnotations attributes in class file %s\", THREAD);\n+          return;\n@@ -3904,1 +3965,2 @@\n-            \"Multiple RuntimeInvisibleTypeAnnotations attributes in class file %s\", CHECK);\n+            \"Multiple RuntimeInvisibleTypeAnnotations attributes in class file %s\", THREAD);\n+          return;\n@@ -3918,1 +3980,2 @@\n-            classfile_parse_error(\"Multiple NestMembers attributes in class file %s\", CHECK);\n+            classfile_parse_error(\"Multiple NestMembers attributes in class file %s\", THREAD);\n+            return;\n@@ -3923,1 +3986,2 @@\n-            classfile_parse_error(\"Conflicting NestHost and NestMembers attributes in class file %s\", CHECK);\n+            classfile_parse_error(\"Conflicting NestHost and NestMembers attributes in class file %s\", THREAD);\n+            return;\n@@ -3930,1 +3994,2 @@\n-            classfile_parse_error(\"Multiple NestHost attributes in class file %s\", CHECK);\n+            classfile_parse_error(\"Multiple NestHost attributes in class file %s\", THREAD);\n+            return;\n@@ -3935,1 +4000,2 @@\n-            classfile_parse_error(\"Conflicting NestMembers and NestHost attributes in class file %s\", CHECK);\n+            classfile_parse_error(\"Conflicting NestMembers and NestHost attributes in class file %s\", THREAD);\n+            return;\n@@ -3954,1 +4020,2 @@\n-                classfile_parse_error(\"Multiple Record attributes in class file %s\", CHECK);\n+                classfile_parse_error(\"Multiple Record attributes in class file %s\", THREAD);\n+                return;\n@@ -3958,1 +4025,2 @@\n-                classfile_parse_error(\"Record attribute in non-final or abstract class file %s\", CHECK);\n+                classfile_parse_error(\"Record attribute in non-final or abstract class file %s\", THREAD);\n+                return;\n@@ -3985,1 +4053,2 @@\n-                  classfile_parse_error(\"Multiple PermittedSubclasses attributes in class file %s\", CHECK);\n+                  classfile_parse_error(\"Multiple PermittedSubclasses attributes in class file %s\", THREAD);\n+                  return;\n@@ -3989,1 +4058,2 @@\n-                  classfile_parse_error(\"PermittedSubclasses attribute in final class file %s\", CHECK);\n+                  classfile_parse_error(\"PermittedSubclasses attribute in final class file %s\", THREAD);\n+                  return;\n@@ -4524,1 +4594,1 @@\n-static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {\n+void ClassFileParser::check_super_class_access(const InstanceKlass* this_klass, TRAPS) {\n@@ -4543,7 +4613,1 @@\n-      ResourceMark rm(THREAD);\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_IncompatibleClassChangeError(),\n-        \"class %s cannot inherit from sealed class %s\",\n-        this_klass->external_name(),\n-        super_ik->external_name());\n+      classfile_icce_error(\"class %s cannot inherit from sealed class %s\", super_ik, THREAD);\n@@ -4605,1 +4669,1 @@\n-static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {\n+void ClassFileParser::check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {\n@@ -4614,8 +4678,4 @@\n-      ResourceMark rm(THREAD);\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_IncompatibleClassChangeError(),\n-        \"class %s cannot %s sealed interface %s\",\n-        this_klass->external_name(),\n-        this_klass->is_interface() ? \"extend\" : \"implement\",\n-        k->external_name());\n+      classfile_icce_error(this_klass->is_interface() ?\n+                             \"class %s cannot extend sealed interface %s\" :\n+                             \"class %s cannot implement sealed interface %s\",\n+                           k, THREAD);\n@@ -4814,1 +4874,1 @@\n-static void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){\n+void ClassFileParser::verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){\n@@ -4818,5 +4878,2 @@\n-    Exceptions::fthrow(\n-      THREAD_AND_LOCATION,\n-      vmSymbols::java_lang_UnsupportedClassVersionError(),\n-      \"%s (class file version %u.%u) was compiled with an invalid major version\",\n-      class_name->as_C_string(), major, minor);\n+    classfile_ucve_error(\"%s (class file version %u.%u) was compiled with an invalid major version\",\n+                         class_name, major, minor, THREAD);\n@@ -4852,5 +4909,2 @@\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_UnsupportedClassVersionError(),\n-        \"Preview features are not enabled for %s (class file version %u.%u). Try running with '--enable-preview'\",\n-        class_name->as_C_string(), major, minor);\n+      classfile_ucve_error(\"Preview features are not enabled for %s (class file version %u.%u). Try running with '--enable-preview'\",\n+                           class_name, major, minor, THREAD);\n@@ -4861,5 +4915,2 @@\n-    Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_UnsupportedClassVersionError(),\n-        \"%s (class file version %u.%u) was compiled with an invalid non-zero minor version\",\n-        class_name->as_C_string(), major, minor);\n+    classfile_ucve_error(\"%s (class file version %u.%u) was compiled with an invalid non-zero minor version\",\n+                         class_name, major, minor, THREAD);\n@@ -5017,1 +5068,1 @@\n-    classfile_parse_error(\"Illegal UTF8 string in constant pool in class file %s\", CHECK);\n+    classfile_parse_error(\"Illegal UTF8 string in constant pool in class file %s\", THREAD);\n@@ -5195,1 +5246,1 @@\n-                                  CHECK_NULL);\n+                                  THREAD);\n@@ -5207,1 +5258,2 @@\n-        classfile_parse_error(\"Array type descriptor has more than 255 dimensions in class file %s\", CHECK_NULL);\n+        classfile_parse_error(\"Array type descriptor has more than 255 dimensions in class file %s\", THREAD);\n+        return NULL;\n@@ -5453,1 +5505,1 @@\n-  const vmSymbols::SID klass_id = Method::klass_id_for_intrinsics(ik);\n+  const vmSymbolID klass_id = Method::klass_id_for_intrinsics(ik);\n@@ -5455,1 +5507,1 @@\n-  if (klass_id != vmSymbols::NO_SID) {\n+  if (klass_id != vmSymbolID::NO_SID) {\n@@ -5650,3 +5702,0 @@\n-  if (_is_empty_inline_type) {\n-    ik->set_is_empty_inline_type();\n-  }\n@@ -5835,0 +5884,1 @@\n+  bool all_fields_empty = true;\n@@ -5838,8 +5888,9 @@\n-    if (ik->field_is_inline_type(i) && ((ik->field_access_flags(i) & JVM_ACC_STATIC) == 0)) {\n-      Symbol* klass_name = ik->field_signature(i)->fundamental_name(CHECK);\n-      \/\/ Inline classes for instance fields must have been pre-loaded\n-      \/\/ Inline classes for static fields might not have been loaded yet\n-      Klass* klass = SystemDictionary::find(klass_name,\n-          Handle(THREAD, ik->class_loader()),\n-          Handle(THREAD, ik->protection_domain()), CHECK);\n-      if (klass != NULL) {\n+    if (((ik->field_access_flags(i) & JVM_ACC_STATIC) == 0)) {\n+      if (ik->field_is_inline_type(i)) {\n+        Symbol* klass_name = ik->field_signature(i)->fundamental_name(CHECK);\n+        \/\/ Inline classes for instance fields must have been pre-loaded\n+        \/\/ Inline classes for static fields might not have been loaded yet\n+        Klass* klass = SystemDictionary::find(klass_name,\n+            Handle(THREAD, ik->class_loader()),\n+            Handle(THREAD, ik->protection_domain()), CHECK);\n+        assert(klass != NULL, \"Just checking\");\n@@ -5848,0 +5899,4 @@\n+        klass_name->decrement_refcount();\n+        if (!InlineKlass::cast(klass)->is_empty_inline_type()) { all_fields_empty = false; }\n+      } else {\n+        all_fields_empty = false;\n@@ -5849,4 +5904,1 @@\n-      klass_name->decrement_refcount();\n-    } else\n-      if (is_inline_type() && ((ik->field_access_flags(i) & JVM_ACC_FIELD_INTERNAL) != 0)\n-        && ((ik->field_access_flags(i) & JVM_ACC_STATIC) != 0)) {\n+    } else if (is_inline_type() && ((ik->field_access_flags(i) & JVM_ACC_FIELD_INTERNAL) != 0)) {\n@@ -5857,0 +5909,4 @@\n+  if (_is_empty_inline_type || (is_inline_type() && all_fields_empty)) {\n+    ik->set_is_empty_inline_type();\n+  }\n+\n@@ -6301,1 +6357,2 @@\n-    classfile_parse_error(\"Unknown constant tag %u in class file %s\", bad_constant, CHECK);\n+    classfile_parse_error(\"Unknown constant tag %u in class file %s\", bad_constant, THREAD);\n+    return;\n@@ -6473,1 +6530,12 @@\n-  jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));\n+  if (DumpSharedSpaces) {\n+    \/\/ We want stable names for the archived hidden classes (only for static\n+    \/\/ archive for now). Spaces under default_SharedBaseAddress() will be\n+    \/\/ occupied by the archive at run time, so we know that no dynamically\n+    \/\/ loaded InstanceKlass will be placed under there.\n+    static volatile size_t counter = 0;\n+    Atomic::cmpxchg(&counter, (size_t)0, Arguments::default_SharedBaseAddress()); \/\/ initialize it\n+    size_t new_id = Atomic::add(&counter, (size_t)1);\n+    jio_snprintf(addr_buf, 20, SIZE_FORMAT_HEX, new_id);\n+  } else {\n+    jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));\n+  }\n@@ -6537,8 +6605,1 @@\n-      ResourceMark rm(THREAD);\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_IncompatibleClassChangeError(),\n-        \"class %s has interface %s as super class\",\n-        _class_name->as_klass_external_name(),\n-        _super_klass->external_name()\n-      );\n+      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":221,"deletions":160,"binary":false,"changes":381,"status":"modified"},{"patch":"@@ -403,0 +403,10 @@\n+  void classfile_icce_error(const char* msg,\n+                            const Klass* k,\n+                            TRAPS) const;\n+\n+  void classfile_ucve_error(const char* msg,\n+                            const Symbol* class_name,\n+                            u2 major,\n+                            u2 minor,\n+                            TRAPS) const;\n+\n@@ -404,1 +414,1 @@\n-    if (!b) { classfile_parse_error(msg, CHECK); }\n+    if (!b) { classfile_parse_error(msg, THREAD); return; }\n@@ -449,1 +459,1 @@\n-    if (!b) { classfile_parse_error(msg, index, CHECK); }\n+    if (!b) { classfile_parse_error(msg, index, THREAD); return; }\n@@ -456,1 +466,1 @@\n-    if (!b) { classfile_parse_error(msg, name, CHECK); }\n+    if (!b) { classfile_parse_error(msg, name, THREAD); return; }\n@@ -464,1 +474,1 @@\n-    if (!b) { classfile_parse_error(msg, index, name, CHECK); }\n+    if (!b) { classfile_parse_error(msg, index, name, THREAD); return; }\n@@ -494,0 +504,2 @@\n+  void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS);\n+\n@@ -505,0 +517,6 @@\n+  void check_super_class_access(const InstanceKlass* this_klass,\n+                                TRAPS);\n+\n+  void check_super_interface_access(const InstanceKlass* this_klass,\n+                                    TRAPS);\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -79,1 +79,2 @@\n-  _primitive_fields(NULL),\n+  _small_primitive_fields(NULL),\n+  _big_primitive_fields(NULL),\n@@ -81,1 +82,0 @@\n-  _inlined_fields(NULL),\n@@ -88,2 +88,4 @@\n-  if (_primitive_fields == NULL) {\n-    _primitive_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+  if (size >= oopSize) {\n+    add_to_big_primitive_list(block);\n+  } else {\n+    add_to_small_primitive_list(block);\n@@ -91,1 +93,0 @@\n-  _primitive_fields->append(block);\n@@ -105,1 +106,0 @@\n-  \/\/ _inlined_fields list might be merged with the _primitive_fields list in the future\n@@ -108,2 +108,4 @@\n-  if (_inlined_fields == NULL) {\n-    _inlined_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+  if (block->size() >= oopSize) {\n+    add_to_big_primitive_list(block);\n+  } else {\n+    add_to_small_primitive_list(block);\n@@ -111,1 +113,0 @@\n-  _inlined_fields->append(block);\n@@ -115,2 +116,11 @@\n-  if (_primitive_fields != NULL) {\n-    _primitive_fields->sort(LayoutRawBlock::compare_size_inverted);\n+  if (_small_primitive_fields != NULL) {\n+    _small_primitive_fields->sort(LayoutRawBlock::compare_size_inverted);\n+  }\n+  if (_big_primitive_fields != NULL) {\n+    _big_primitive_fields->sort(LayoutRawBlock::compare_size_inverted);\n+  }\n+}\n+\n+void FieldGroup::add_to_small_primitive_list(LayoutRawBlock* block) {\n+  if (_small_primitive_fields == NULL) {\n+    _small_primitive_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n@@ -118,2 +128,6 @@\n-  if (_inlined_fields != NULL) {\n-    _inlined_fields->sort(LayoutRawBlock::compare_size_inverted);\n+  _small_primitive_fields->append(block);\n+}\n+\n+void FieldGroup::add_to_big_primitive_list(LayoutRawBlock* block) {\n+  if (_big_primitive_fields == NULL) {\n+    _big_primitive_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n@@ -121,0 +135,1 @@\n+  _big_primitive_fields->append(block);\n@@ -786,7 +801,4 @@\n- *   - inlined fields are allocated first (because they have potentially the\n- *     least regular shapes, and are more likely to create empty slots between them,\n- *     which can then be used to allocation primitive or oop fields). Allocation is\n- *     performed from the biggest to the smallest field.\n- *   - then primitive fields (from the biggest to the smallest)\n- *   - then oop fields are allocated contiguously (to reduce the number of oopmaps\n- *     and reduce the work of the GC).\n+ *   - primitive fields (both primitive types and flattened inline types) are allocated\n+ *     first, from the biggest to the smallest\n+ *   - then oop fields are allocated (to increase chances to have contiguous oops and\n+ *     a simpler oopmap).\n@@ -805,2 +817,2 @@\n-  _layout->add(_root_group->inlined_fields());\n-  _layout->add(_root_group->primitive_fields());\n+  _layout->add(_root_group->big_primitive_fields());\n+  _layout->add(_root_group->small_primitive_fields());\n@@ -814,2 +826,2 @@\n-      _layout->add(_root_group->inlined_fields());\n-      _layout->add(cg->primitive_fields(), start);\n+      _layout->add(cg->big_primitive_fields());\n+      _layout->add(cg->small_primitive_fields(), start);\n@@ -824,1 +836,1 @@\n-  _static_layout->add(_static_fields->inlined_fields());\n+  \/\/ Warning: IntanceMirrorKlass expects static oops to be allocated first\n@@ -826,1 +838,2 @@\n-  _static_layout->add(_static_fields->primitive_fields());\n+  _static_layout->add(_static_fields->big_primitive_fields());\n+  _static_layout->add(_static_fields->small_primitive_fields());\n@@ -838,7 +851,4 @@\n- *   - inlined fields are allocated first (because they have potentially the\n- *     least regular shapes, and are more likely to create empty slots between them,\n- *     which can then be used to allocation primitive or oop fields). Allocation is\n- *     performed from the biggest to the smallest field.\n- *   - then oop fields are allocated contiguously (to reduce the number of oopmaps\n- *     and reduce the work of the GC)\n- *   - then primitive fields (from the biggest to the smallest)\n+ *   - big primitive fields (primitive types and flattened inline type smaller\n+ *     than an oop) are allocated first (from the biggest to the smallest)\n+ *   - then oop fields\n+ *   - then small primitive fields (from the biggest to the smallest)\n@@ -861,1 +871,1 @@\n-  _layout->add(_root_group->inlined_fields());\n+  _layout->add(_root_group->big_primitive_fields());\n@@ -863,1 +873,1 @@\n-  _layout->add(_root_group->primitive_fields());\n+  _layout->add(_root_group->small_primitive_fields());\n@@ -876,1 +886,1 @@\n-  _static_layout->add(_static_fields->inlined_fields());\n+  \/\/ Warning:: InstanceMirrorKlass expects static oops to be allocated first\n@@ -878,2 +888,2 @@\n-  _static_layout->add(_static_fields->primitive_fields());\n-\n+  _static_layout->add(_static_fields->big_primitive_fields());\n+  _static_layout->add(_static_fields->small_primitive_fields());\n@@ -895,0 +905,26 @@\n+void FieldLayoutBuilder::register_embedded_oops_from_list(OopMapBlocksBuilder* nonstatic_oop_maps, GrowableArray<LayoutRawBlock*>* list) {\n+  if (list != NULL) {\n+    for (int i = 0; i < list->length(); i++) {\n+      LayoutRawBlock* f = list->at(i);\n+      if (f->kind() == LayoutRawBlock::INLINED) {\n+        InlineKlass* vk = f->inline_klass();\n+        assert(vk != NULL, \"Should have been initialized\");\n+        if (vk->contains_oops()) {\n+          add_inlined_field_oopmap(nonstatic_oop_maps, vk, f->offset());\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void FieldLayoutBuilder::register_embedded_oops(OopMapBlocksBuilder* nonstatic_oop_maps, FieldGroup* group) {\n+  if (group->oop_fields() != NULL) {\n+    for (int i = 0; i < group->oop_fields()->length(); i++) {\n+      LayoutRawBlock* b = group->oop_fields()->at(i);\n+      nonstatic_oop_maps->add(b->offset(), 1);\n+    }\n+  }\n+  register_embedded_oops_from_list(nonstatic_oop_maps, group->big_primitive_fields());\n+  register_embedded_oops_from_list(nonstatic_oop_maps, group->small_primitive_fields());\n+}\n+\n@@ -899,1 +935,0 @@\n-\n@@ -906,20 +941,1 @@\n-\n-  if (_root_group->oop_fields() != NULL) {\n-    for (int i = 0; i < _root_group->oop_fields()->length(); i++) {\n-      LayoutRawBlock* b = _root_group->oop_fields()->at(i);\n-      nonstatic_oop_maps->add(b->offset(), 1);\n-    }\n-  }\n-\n-  GrowableArray<LayoutRawBlock*>* ff = _root_group->inlined_fields();\n-  if (ff != NULL) {\n-    for (int i = 0; i < ff->length(); i++) {\n-      LayoutRawBlock* f = ff->at(i);\n-      InlineKlass* vk = f->inline_klass();\n-      assert(vk != NULL, \"Should have been initialized\");\n-      if (vk->contains_oops()) {\n-        add_inlined_field_oopmap(nonstatic_oop_maps, vk, f->offset());\n-      }\n-    }\n-  }\n-\n+  register_embedded_oops(nonstatic_oop_maps, _root_group);\n@@ -931,1 +947,1 @@\n-        nonstatic_oop_maps->add(cg->oop_fields()->at(0)->offset(), cg->oop_count());\n+        register_embedded_oops(nonstatic_oop_maps, cg);\n@@ -935,1 +951,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":76,"deletions":61,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"jfr\/support\/jfrIntrinsics.hpp\"\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -33,2 +33,1 @@\n-#include \"vmIntrinsics.hpp\"\n-\n+#include \"utilities\/enumIterator.hpp\"\n@@ -46,1 +45,2 @@\n-#define VM_SYMBOL_ENUM_NAME(name)    name##_enum\n+#define VM_SYMBOL_ENUM_NAME_(name)    name##_enum\n+#define VM_SYMBOL_ENUM_NAME(name)    vmSymbolID::VM_SYMBOL_ENUM_NAME_(name)\n@@ -86,0 +86,10 @@\n+                                                                                                  \\\n+  template(jdk_internal_vm_vector_VectorSupport,      \"jdk\/internal\/vm\/vector\/VectorSupport\")               \\\n+  template(jdk_internal_vm_vector_VectorPayload,      \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload\") \\\n+  template(jdk_internal_vm_vector_Vector,             \"jdk\/internal\/vm\/vector\/VectorSupport$Vector\")        \\\n+  template(jdk_internal_vm_vector_VectorMask,         \"jdk\/internal\/vm\/vector\/VectorSupport$VectorMask\")    \\\n+  template(jdk_internal_vm_vector_VectorShuffle,      \"jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle\") \\\n+  template(payload_name,                              \"payload\")                                            \\\n+  template(ETYPE_name,                                \"ETYPE\")                                              \\\n+  template(VLENGTH_name,                              \"VLENGTH\")                                            \\\n+                                                                                                  \\\n@@ -288,0 +298,4 @@\n+  \/* used by CDS *\/                                                                               \\\n+  template(jdk_internal_misc_CDS, \"jdk\/internal\/misc\/CDS\")                                        \\\n+  template(generateLambdaFormHolderClasses, \"generateLambdaFormHolderClasses\")                    \\\n+  template(generateLambdaFormHolderClasses_signature, \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\") \\\n@@ -295,1 +309,0 @@\n-                                                                                                  \\\n@@ -689,0 +702,6 @@\n+\/\/ enum for figuring positions and size of Symbol::_vm_symbols[]\n+enum class vmSymbolID : int {\n+  \/\/ [FIRST_SID ... LAST_SID] is the iteration range for the *valid* symbols.\n+  \/\/ NO_SID is used to indicate an invalid symbol. Some implementation code\n+  \/\/ *may* read _vm_symbols[NO_SID], so it must be a valid array index.\n+  NO_SID = 0,                \/\/ exclusive lower limit\n@@ -690,0 +709,3 @@\n+  #define VM_SYMBOL_ENUM(name, string) VM_SYMBOL_ENUM_NAME_(name),\n+  VM_SYMBOLS_DO(VM_SYMBOL_ENUM, VM_ALIAS_IGNORE)\n+  #undef VM_SYMBOL_ENUM\n@@ -691,1 +713,13 @@\n-\/\/ Class vmSymbols\n+  SID_LIMIT,                 \/\/ exclusive upper limit\n+\n+  #define VM_ALIAS_ENUM(name, def) VM_SYMBOL_ENUM_NAME_(name) = VM_SYMBOL_ENUM_NAME_(def),\n+  VM_SYMBOLS_DO(VM_SYMBOL_IGNORE, VM_ALIAS_ENUM)\n+  #undef VM_ALIAS_ENUM\n+\n+  FIRST_SID = NO_SID + 1,    \/\/ inclusive lower limit\n+  LAST_SID = SID_LIMIT - 1,  \/\/ inclusive upper limit\n+};\n+\n+ENUMERATOR_RANGE(vmSymbolID, vmSymbolID::FIRST_SID, vmSymbolID::LAST_SID)\n+constexpr EnumRange<vmSymbolID> vmSymbolsRange; \/\/ the default range of all valid vmSymbolIDs\n+using vmSymbolsIterator = EnumIterator<vmSymbolID>; \/\/ convenience\n@@ -697,0 +731,6 @@\n+\n+  static const int NO_SID    = static_cast<int>(vmSymbolID::NO_SID);    \/\/ exclusive lower limit\n+  static const int FIRST_SID = static_cast<int>(vmSymbolID::FIRST_SID); \/\/ inclusive lower limit\n+  static const int LAST_SID  = static_cast<int>(vmSymbolID::FIRST_SID); \/\/ inclusive upper limit\n+  static const int SID_LIMIT = static_cast<int>(vmSymbolID::SID_LIMIT); \/\/ exclusive upper limit\n+\n@@ -698,3 +738,6 @@\n-  \/\/ enum for figuring positions and size of array holding Symbol*s\n-  enum SID {\n-    NO_SID = 0,\n+  static constexpr bool is_valid_id(int id) {\n+    return (id >= FIRST_SID && id < SID_LIMIT);\n+  }\n+  static constexpr bool is_valid_id(vmSymbolID sid) {\n+    return is_valid_id(static_cast<int>(sid));\n+  }\n@@ -702,3 +745,4 @@\n-    #define VM_SYMBOL_ENUM(name, string) VM_SYMBOL_ENUM_NAME(name),\n-    VM_SYMBOLS_DO(VM_SYMBOL_ENUM, VM_ALIAS_IGNORE)\n-    #undef VM_SYMBOL_ENUM\n+  static constexpr vmSymbolID as_SID(int id) {\n+    assert(is_valid_id(id), \"must be\");\n+    return static_cast<vmSymbolID>(id);\n+  }\n@@ -706,1 +750,4 @@\n-    SID_LIMIT,\n+  static constexpr int as_int(vmSymbolID sid) {\n+    assert(is_valid_id(sid), \"must be\");\n+    return static_cast<int>(sid);\n+  }\n@@ -708,3 +755,5 @@\n-    #define VM_ALIAS_ENUM(name, def) VM_SYMBOL_ENUM_NAME(name) = VM_SYMBOL_ENUM_NAME(def),\n-    VM_SYMBOLS_DO(VM_SYMBOL_IGNORE, VM_ALIAS_ENUM)\n-    #undef VM_ALIAS_ENUM\n+  static constexpr int number_of_symbols() {\n+    static_assert(NO_SID == 0, \"must be a valid array index\");\n+    static_assert(FIRST_SID == 1, \"must not be the same as NO_SID\");\n+    return SID_LIMIT;\n+  }\n@@ -712,2 +761,0 @@\n-    FIRST_SID = NO_SID + 1\n-  };\n@@ -719,2 +766,0 @@\n-  \/\/ The symbol array\n-  static Symbol* _symbols[];\n@@ -731,1 +776,1 @@\n-      return _symbols[VM_SYMBOL_ENUM_NAME(name)];         \\\n+      return Symbol::_vm_symbols[static_cast<int>(VM_SYMBOL_ENUM_NAME(name))]; \\\n@@ -747,4 +792,2 @@\n-  static Symbol* symbol_at(SID id) {\n-    assert(id >= FIRST_SID && id < SID_LIMIT, \"oob\");\n-    assert(_symbols[id] != NULL, \"init\");\n-    return _symbols[id];\n+  static Symbol* symbol_at(vmSymbolID id) {\n+    return Symbol::vm_symbol_at(id);\n@@ -753,3 +796,3 @@\n-  \/\/ Returns symbol's SID if one is assigned, else NO_SID.\n-  static SID find_sid(const Symbol* symbol);\n-  static SID find_sid(const char* symbol_name);\n+  \/\/ Returns symbol's vmSymbolID if one is assigned, else vmSymbolID::NO_SID.\n+  static vmSymbolID find_sid(const Symbol* symbol);\n+  static vmSymbolID find_sid(const char* symbol_name);\n@@ -759,1 +802,1 @@\n-  static const char* name_for(SID sid);\n+  static const char* name_for(vmSymbolID sid);\n@@ -763,129 +806,0 @@\n-\/\/ VM Intrinsic ID's uniquely identify some very special methods\n-class vmIntrinsics: AllStatic {\n-  friend class vmSymbols;\n-  friend class ciObjectFactory;\n-\n- public:\n-  \/\/ Accessing\n-  enum ID {\n-    _none = 0,                      \/\/ not an intrinsic (default answer)\n-\n-    #define VM_INTRINSIC_ENUM(id, klass, name, sig, flags)  id,\n-    VM_INTRINSICS_DO(VM_INTRINSIC_ENUM,\n-                     VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)\n-    #undef VM_INTRINSIC_ENUM\n-\n-    ID_LIMIT,\n-    LAST_COMPILER_INLINE = _getAndSetReference,\n-    FIRST_MH_SIG_POLY    = _invokeGeneric,\n-    FIRST_MH_STATIC      = _linkToVirtual,\n-    LAST_MH_SIG_POLY     = _linkToInterface,\n-\n-    FIRST_ID = _none + 1\n-  };\n-\n-  enum Flags {\n-    \/\/ AccessFlags syndromes relevant to intrinsics.\n-    F_none = 0,\n-    F_R,                        \/\/ !static ?native !synchronized (R=\"regular\")\n-    F_S,                        \/\/  static ?native !synchronized\n-    F_Y,                        \/\/ !static ?native  synchronized\n-    F_RN,                       \/\/ !static  native !synchronized\n-    F_SN,                       \/\/  static  native !synchronized\n-    F_RNY,                      \/\/ !static  native  synchronized\n-\n-    FLAG_LIMIT\n-  };\n-  enum {\n-    log2_FLAG_LIMIT = 4         \/\/ checked by an assert at start-up\n-  };\n-\n-public:\n-  static ID ID_from(int raw_id) {\n-    assert(raw_id >= (int)_none && raw_id < (int)ID_LIMIT,\n-           \"must be a valid intrinsic ID\");\n-    return (ID)raw_id;\n-  }\n-\n-  static const char* name_at(ID id);\n-\n-private:\n-  static ID find_id_impl(vmSymbols::SID holder,\n-                         vmSymbols::SID name,\n-                         vmSymbols::SID sig,\n-                         jshort flags);\n-\n-  \/\/ check if the intrinsic is disabled by course-grained flags.\n-  static bool disabled_by_jvm_flags(vmIntrinsics::ID id);\n-public:\n-  static ID find_id(const char* name);\n-  \/\/ Given a method's class, name, signature, and access flags, report its ID.\n-  static ID find_id(vmSymbols::SID holder,\n-                    vmSymbols::SID name,\n-                    vmSymbols::SID sig,\n-                    jshort flags) {\n-    ID id = find_id_impl(holder, name, sig, flags);\n-#ifdef ASSERT\n-    \/\/ ID _none does not hold the following asserts.\n-    if (id == _none)  return id;\n-#endif\n-    assert(    class_for(id) == holder, \"correct id\");\n-    assert(     name_for(id) == name,   \"correct id\");\n-    assert(signature_for(id) == sig,    \"correct id\");\n-    return id;\n-  }\n-\n-  static void verify_method(ID actual_id, Method* m) PRODUCT_RETURN;\n-\n-  \/\/ Find out the symbols behind an intrinsic:\n-  static vmSymbols::SID     class_for(ID id);\n-  static vmSymbols::SID      name_for(ID id);\n-  static vmSymbols::SID signature_for(ID id);\n-  static Flags              flags_for(ID id);\n-\n-  static const char* short_name_as_C_string(ID id, char* buf, int size);\n-\n-  \/\/ Wrapper object methods:\n-  static ID for_boxing(BasicType type);\n-  static ID for_unboxing(BasicType type);\n-\n-  \/\/ Raw conversion:\n-  static ID for_raw_conversion(BasicType src, BasicType dest);\n-\n-  \/\/ The methods below provide information related to compiling intrinsics.\n-\n-  \/\/ (1) Information needed by the C1 compiler.\n-\n-  static bool preserves_state(vmIntrinsics::ID id);\n-  static bool can_trap(vmIntrinsics::ID id);\n-  static bool should_be_pinned(vmIntrinsics::ID id);\n-\n-  \/\/ (2) Information needed by the C2 compiler.\n-\n-  \/\/ Returns true if the intrinsic for method 'method' will perform a virtual dispatch.\n-  static bool does_virtual_dispatch(vmIntrinsics::ID id);\n-  \/\/ A return value larger than 0 indicates that the intrinsic for method\n-  \/\/ 'method' requires predicated logic.\n-  static int predicates_needed(vmIntrinsics::ID id);\n-\n-  \/\/ There are 2 kinds of JVM options to control intrinsics.\n-  \/\/ 1. Disable\/Control Intrinsic accepts a list of intrinsic IDs.\n-  \/\/    ControlIntrinsic is recommended. DisableIntrinic will be deprecated.\n-  \/\/    Currently, the DisableIntrinsic list prevails if an intrinsic appears on\n-  \/\/    both lists.\n-  \/\/\n-  \/\/ 2. Explicit UseXXXIntrinsics options. eg. UseAESIntrinsics, UseCRC32Intrinsics etc.\n-  \/\/    Each option can control a group of intrinsics. The user can specify them but\n-  \/\/    their final values are subject to hardware inspection (VM_Version::initialize).\n-  \/\/    Stub generators are controlled by them.\n-  \/\/\n-  \/\/ An intrinsic is enabled if and only if neither the fine-grained control(1) nor\n-  \/\/ the corresponding coarse-grained control(2) disables it.\n-  static bool is_disabled_by_flags(vmIntrinsics::ID id);\n-\n-  static bool is_disabled_by_flags(const methodHandle& method);\n-  static bool is_intrinsic_available(vmIntrinsics::ID id) {\n-    return !is_disabled_by_flags(id);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":72,"deletions":158,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"prims\/methodHandles.hpp\"\n@@ -70,0 +71,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -705,0 +707,4 @@\n+  \/\/ We get here after we have unwound from a callee throwing an exception\n+  \/\/ into the interpreter. Any deferred stack processing is notified of\n+  \/\/ the event via the StackWatermarkSet.\n+  StackWatermarkSet::after_unwind(thread);\n@@ -806,1 +812,1 @@\n-  if (handler_bci < 0 || !thread->reguard_stack((address) &continuation)) {\n+  if (handler_bci < 0 || !thread->stack_overflow_state()->reguard_stack((address) &continuation)) {\n@@ -1426,0 +1432,5 @@\n+    \/\/ This function is called by the interpreter when single stepping. Such single\n+    \/\/ stepping could unwind a frame. Then, it is important that we process any frames\n+    \/\/ that we might return into.\n+    StackWatermarkSet::before_unwind(thread);\n+\n@@ -1434,0 +1445,14 @@\n+JRT_ENTRY(void, InterpreterRuntime::at_unwind(JavaThread* thread))\n+  \/\/ JRT_END does an implicit safepoint check, hence we are guaranteed to block\n+  \/\/ if this is called during a safepoint\n+\n+  \/\/ This function is called by the interpreter when the return poll found a reason\n+  \/\/ to call the VM. The reason could be that we are returning into a not yet safe\n+  \/\/ to access frame. We handle that below.\n+  \/\/ Note that this path does not check for single stepping, because we do not want\n+  \/\/ to single step when unwinding frames for an exception being thrown. Instead,\n+  \/\/ such single stepping code will use the safepoint table, which will use the\n+  \/\/ InterpreterRuntime::at_safepoint callback.\n+  StackWatermarkSet::before_unwind(thread);\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+  static void    at_unwind(JavaThread* thread);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"oops\/symbol.hpp\"\n@@ -30,1 +31,1 @@\n-#include \"classfile\/vmSymbols.hpp\"\n+#include \"utilities\/vmEnums.hpp\"\n@@ -200,1 +201,1 @@\n-    return vmSymbols::symbol_at((vmSymbols::SID)symbol_index);\n+    return Symbol::vm_symbol_at(static_cast<vmSymbolID>(symbol_index));\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -128,1 +129,1 @@\n-      return vmSymbols::symbol_at((vmSymbols::SID)sig_index);\n+      return vmSymbols::symbol_at(vmSymbols::as_SID(sig_index));\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-    _misc_is_empty_inline_type                = 1 << 17, \/\/ empty inline type\n+    _misc_is_empty_inline_type                = 1 << 17, \/\/ empty inline type (*)\n@@ -300,0 +300,6 @@\n+\n+  \/\/ (*) An inline type is considered empty if it contains no non-static fields or\n+  \/\/ if it contains only empty inline fields. Note that JITs have a slightly different\n+  \/\/ definition: empty inline fields must be flattened otherwise the container won't\n+  \/\/ be considered empty\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -299,0 +299,1 @@\n+  AOT_ONLY(nonstatic_field(MethodCounters,     _method,                                       Method*))                              \\\n@@ -469,1 +470,1 @@\n-     static_field(vmSymbols,                   _symbols[0],                                   Symbol*)                               \\\n+     static_field(Symbol,                      _vm_symbols[0],                                Symbol*)                               \\\n@@ -742,1 +743,1 @@\n-  nonstatic_field(NamedThread,                 _processed_thread,                             JavaThread*)                           \\\n+  nonstatic_field(NamedThread,                 _processed_thread,                             Thread*)                               \\\n@@ -1504,0 +1505,2 @@\n+  declare_c2_type(MaxLNode, MaxNode)                                      \\\n+  declare_c2_type(MinLNode, MaxNode)                                      \\\n@@ -1579,1 +1582,0 @@\n-  declare_c2_type(CastI2NNode, TypeNode)                                  \\\n@@ -1583,1 +1585,0 @@\n-  declare_c2_type(CastN2INode, Node)                                      \\\n@@ -1741,0 +1742,2 @@\n+  declare_c2_type(NegINode, NegNode)                                      \\\n+  declare_c2_type(NegLNode, NegNode)                                      \\\n@@ -1750,4 +1753,6 @@\n-  declare_c2_type(AbsVBNode, VectorNode)                                   \\\n-  declare_c2_type(AbsVSNode, VectorNode)                                   \\\n-  declare_c2_type(AbsVINode, VectorNode)                                   \\\n-  declare_c2_type(AbsVLNode, VectorNode)                                   \\\n+  declare_c2_type(AbsVFNode, VectorNode)                                  \\\n+  declare_c2_type(AbsVDNode, VectorNode)                                  \\\n+  declare_c2_type(AbsVBNode, VectorNode)                                  \\\n+  declare_c2_type(AbsVSNode, VectorNode)                                  \\\n+  declare_c2_type(AbsVINode, VectorNode)                                  \\\n+  declare_c2_type(AbsVLNode, VectorNode)                                  \\\n@@ -1779,0 +1784,1 @@\n+  declare_c2_type(NegVINode, VectorNode)                                  \\\n@@ -1801,0 +1807,2 @@\n+  declare_c2_type(MinReductionVNode, ReductionNode)                       \\\n+  declare_c2_type(MaxReductionVNode, ReductionNode)                       \\\n@@ -1809,2 +1817,0 @@\n-  declare_c2_type(MaxReductionVNode, ReductionNode)                       \\\n-  declare_c2_type(MinReductionVNode, ReductionNode)                       \\\n@@ -1852,0 +1858,21 @@\n+  declare_c2_type(LoadVectorGatherNode, LoadVectorNode)                   \\\n+  declare_c2_type(StoreVectorScatterNode, StoreVectorNode)                \\\n+  declare_c2_type(VectorLoadMaskNode, VectorNode)                         \\\n+  declare_c2_type(VectorLoadShuffleNode, VectorNode)                      \\\n+  declare_c2_type(VectorStoreMaskNode, VectorNode)                        \\\n+  declare_c2_type(VectorBlendNode, VectorNode)                            \\\n+  declare_c2_type(VectorRearrangeNode, VectorNode)                        \\\n+  declare_c2_type(VectorMaskWrapperNode, VectorNode)                      \\\n+  declare_c2_type(VectorMaskCmpNode, VectorNode)                          \\\n+  declare_c2_type(VectorCastB2XNode, VectorNode)                          \\\n+  declare_c2_type(VectorCastS2XNode, VectorNode)                          \\\n+  declare_c2_type(VectorCastI2XNode, VectorNode)                          \\\n+  declare_c2_type(VectorCastL2XNode, VectorNode)                          \\\n+  declare_c2_type(VectorCastF2XNode, VectorNode)                          \\\n+  declare_c2_type(VectorCastD2XNode, VectorNode)                          \\\n+  declare_c2_type(VectorInsertNode, VectorNode)                           \\\n+  declare_c2_type(VectorUnboxNode, VectorNode)                            \\\n+  declare_c2_type(VectorReinterpretNode, VectorNode)                      \\\n+  declare_c2_type(VectorBoxNode, Node)                                    \\\n+  declare_c2_type(VectorBoxAllocateNode, CallStaticJavaNode)              \\\n+  declare_c2_type(VectorTestNode, Node)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -317,0 +317,5 @@\n+    \/\/ has_stored_fingerprint() @ instanceKlass.cpp can return true only if INCLUDE_AOT is\n+    \/\/ set during compilation.\n+    if (!VM.getVM().hasAOT()) {\n+      return false;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}