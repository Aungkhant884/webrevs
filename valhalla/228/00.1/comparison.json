{"files":[{"patch":"@@ -3361,0 +3361,14 @@\n+\n+  Label notRestricted;\n+  __ movl(rdx, flags);\n+  __ shrl(rdx, ConstantPoolCacheEntry::has_restricted_type_shift);\n+  __ andl(rdx, 0x1);\n+  __ testl(rdx, rdx);\n+  __ jcc(Assembler::zero, notRestricted);\n+\n+  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::check_restricted_type));\n+  __ get_cache_and_index_at_bcp(cache, index, 1);\n+  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+\n+  __ bind(notRestricted);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n@@ -1373,0 +1373,2 @@\n+                                             u2* restricted_field_info,\n+                                             bool* has_restricted_type,\n@@ -1468,0 +1470,12 @@\n+      } else if (attribute_name == vmSymbols::tag_restricted_field()) {\n+        check_property(\n+          attribute_length == 2,\n+          \"Invalid RestrictedField field attribute length %u in class file %s\",\n+          attribute_length, CHECK);\n+          const u2 type_index = cfs->get_u2_fast();\n+          check_property(valid_symbol_at(type_index),\n+                         \"Invalid constant pool index %u for field restricted type signature in class file %s\",\n+                          type_index, CHECK);\n+          *restricted_field_info = type_index;\n+          *has_restricted_type = true;\n+          set_has_restricted_fields();\n@@ -1660,0 +1674,2 @@\n+  _restricted_field_info = new GrowableArray<u2>(total_fields);\n+\n@@ -1690,0 +1706,1 @@\n+\n@@ -1722,0 +1739,2 @@\n+    bool has_restricted_type = false;\n+    u2 restricted_type_index;\n@@ -1731,0 +1750,2 @@\n+                             &restricted_type_index,\n+                             &has_restricted_type,\n@@ -1765,0 +1786,9 @@\n+    u2 sharp_type_index, erased_type_index;\n+    if (has_restricted_type) {\n+      sharp_type_index = restricted_type_index;\n+      erased_type_index = signature_index;\n+    } else {\n+      sharp_type_index = signature_index;\n+      erased_type_index = signature_index;\n+    }\n+\n@@ -1768,1 +1798,1 @@\n-                      signature_index,\n+                      sharp_type_index,\n@@ -1770,0 +1800,3 @@\n+    _restricted_field_info->append(erased_type_index);\n+    field->set_has_rectricted_type(has_restricted_type);\n+\n@@ -1772,3 +1805,2 @@\n-    \/\/ Remember how many oops we encountered and compute allocation type\n-    const FieldAllocationType atype = fac->update(is_static, type, type == T_INLINE_TYPE);\n-    field->set_allocation_type(atype);\n+    \/\/ \/\/ Remember how many oops we encountered\n+    fac->update(is_static, type, type == T_INLINE_TYPE);\n@@ -1817,3 +1849,2 @@\n-      \/\/ Remember how many oops we encountered and compute allocation type\n-      const FieldAllocationType atype = fac->update(false, type, false);\n-      field->set_allocation_type(atype);\n+      \/\/ Remember how many oops we encountered\n+      fac->update(false, type, false);\n@@ -1821,0 +1852,1 @@\n+      _restricted_field_info->append(0);\n@@ -1824,0 +1856,1 @@\n+  \/\/ Add internal static field to inline type to store the pre-allocated default value\n@@ -1831,2 +1864,2 @@\n-    const FieldAllocationType atype = fac->update(true, type, false);\n-    field->set_allocation_type(atype);\n+    \/\/ Remember how many oops we encountered\n+    fac->update(true, type, false);\n@@ -1834,0 +1867,1 @@\n+    _restricted_field_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)));\n@@ -1836,0 +1870,3 @@\n+  \/\/ True zero size inline types are causing issues when inlined, so the current\n+  \/\/ implementation inserts a byte field to work around the issue\n+  \/\/ Could be optimized later after revisiting use of field offsets as field identifiers\n@@ -1844,2 +1881,2 @@\n-    const FieldAllocationType atype = fac->update(false, type, false);\n-    field->set_allocation_type(atype);\n+    \/\/ Remember how many oops we encountered\n+    fac->update(false, type, false);\n@@ -1847,0 +1884,1 @@\n+    _restricted_field_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)));\n@@ -5838,0 +5876,8 @@\n+  if(has_restricted_fields()) {\n+    ik->set_has_restricted_fields();\n+    u2* rfi = ik->fields_erased_type();\n+    for (int i = 0; i < ik->java_fields_count(); i++) {\n+      rfi[i] = _restricted_field_info->at(i);\n+    }\n+  }\n+\n@@ -6036,0 +6082,1 @@\n+  _restricted_field_info(NULL),\n@@ -6075,0 +6122,1 @@\n+  _has_restricted_fields(false),\n@@ -6653,0 +6701,1 @@\n+  \/\/ Pre-loading classes of inlined types non static fields\n@@ -6655,1 +6704,0 @@\n-      \/\/ Pre-load inline class\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":61,"deletions":13,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  GrowableArray<u2>* _restricted_field_info;\n@@ -216,0 +217,1 @@\n+  bool _has_restricted_fields;\n@@ -285,0 +287,2 @@\n+                              u2* restricted_field_info,\n+                              bool* has_restricted_type,\n@@ -626,0 +630,2 @@\n+  void set_has_restricted_fields() { _has_restricted_fields = true; }\n+  bool has_restricted_fields() const { return _has_restricted_fields; }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -536,1 +536,1 @@\n-                                       Array<u2>* fields, bool is_contended, bool is_inline_type, ClassLoaderData* class_loader_data,\n+                                       Array<u2>* fields,  bool is_contended, bool is_inline_type, ClassLoaderData* class_loader_data,\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -191,0 +191,1 @@\n+  template(tag_restricted_field,                      \"RestrictedField\")                          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -525,0 +525,23 @@\n+JRT_ENTRY(void, InterpreterRuntime::check_restricted_type(JavaThread* thread))\n+  LastFrameAccessor last_frame(thread);\n+  ConstantPoolCacheEntry* cp_entry = last_frame.cache_entry();\n+  int offset = cp_entry->f2_as_offset();\n+  InstanceKlass* holder = InstanceKlass::cast(cp_entry->f1_as_klass());\n+  fieldDescriptor fd;\n+  bool is_static = last_frame.bytecode().code() == Bytecodes::_putstatic;\n+  holder->find_field_from_offset(offset, is_static, &fd);\n+  Klass* field_klass = holder->get_inline_type_field_klass_or_null(fd.index());\n+  if (field_klass == NULL) {\n+    field_klass = SystemDictionary::resolve_or_fail(holder->field_signature(fd.index())->fundamental_name(THREAD),\n+        Handle(THREAD, holder->class_loader()),\n+        Handle(THREAD, holder->protection_domain()),\n+        true, CHECK);\n+    holder->set_inline_type_field_klass(fd.index(), field_klass);\n+  }\n+  assert(field_klass != NULL, \"Must have been set\");\n+  oop value = cast_to_oop(*last_frame.get_frame().interpreter_frame_tos_at(0));\n+  assert(value != NULL, \"Inline types cannot be NULL\");\n+  Klass* value_klass = value->klass();\n+  assert(value_klass->is_subtype_of(field_klass), \"Just checking\");\n+JRT_END\n+\n@@ -955,0 +978,1 @@\n+    info.has_restricted_type(),\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  static void check_restricted_type(JavaThread* thread);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,8 +49,5 @@\n-#define FIELDINFO_TAG_SIZE             3\n-#define FIELDINFO_TAG_BLANK            0\n-#define FIELDINFO_TAG_OFFSET           1\n-#define FIELDINFO_TAG_TYPE_PLAIN       2\n-#define FIELDINFO_TAG_TYPE_CONTENDED   3\n-#define FIELDINFO_TAG_TYPE_MASK        3\n-#define FIELDINFO_TAG_MASK             7\n-#define FIELDINFO_TAG_INLINED          4\n+#define FIELDINFO_TAG_SIZE             4\n+#define FIELDINFO_TAG_OFFSET           1 << 0\n+#define FIELDINFO_TAG_CONTENDED        1 << 1\n+#define FIELDINFO_TAG_INLINED          1 << 2\n+#define FIELDINFO_TAG_RESTRICTED       1 << 3\n@@ -61,6 +58,10 @@\n-  \/\/    ..........................................00  - blank\n-  \/\/    [------------------offset---------------]I01  - real field offset\n-  \/\/    ......................[-------type------]I10  - plain field with type\n-  \/\/    [--contention_group--][-------type------]I11  - contended field with type and contention group\n-  \/\/\n-  \/\/ Bit I indicates if the field has been inlined  (I=1) or nor (I=0)\n+  \/\/    ........................................RICO\n+  \/\/    ........................................RI00  - non-contended field\n+  \/\/    [--contention_group--]..................RI10  - contended field with type and contention group\n+  \/\/    [------------------offset--------------]RI01  - real field offset\n+\n+  \/\/ Bit O indicates if the packed field contains an offset (O=1) or not (O=1)\n+  \/\/ Bit C indicates if the field is contended (C=1) or not (C=1)\n+  \/\/       (if it is contended, the high packed field contains the contention group)\n+  \/\/ Bit I indicates if the field has been inlined  (I=1) or not (I=0)\n+  \/\/ Bit R indicates if the field has a type restriction (R=1) ot not (R=0)\n@@ -111,15 +112,2 @@\n-    u2 lo = _shorts[low_packed_offset];\n-    switch(lo & FIELDINFO_TAG_TYPE_MASK) {\n-      case FIELDINFO_TAG_OFFSET:\n-        return build_int_from_shorts(_shorts[low_packed_offset], _shorts[high_packed_offset]) >> FIELDINFO_TAG_SIZE;\n-#ifndef PRODUCT\n-      case FIELDINFO_TAG_TYPE_PLAIN:\n-        fatal(\"Asking offset for the plain type field\");\n-      case FIELDINFO_TAG_TYPE_CONTENDED:\n-        fatal(\"Asking offset for the contended type field\");\n-      case FIELDINFO_TAG_BLANK:\n-        fatal(\"Asking offset for the blank field\");\n-#endif\n-    }\n-    ShouldNotReachHere();\n-    return 0;\n+    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET) != 0, \"Offset must have been set\");\n+    return build_int_from_shorts(_shorts[low_packed_offset], _shorts[high_packed_offset]) >> FIELDINFO_TAG_SIZE;\n@@ -129,15 +117,1 @@\n-    u2 lo = _shorts[low_packed_offset];\n-    switch(lo & FIELDINFO_TAG_TYPE_MASK) {\n-      case FIELDINFO_TAG_TYPE_PLAIN:\n-        return false;\n-      case FIELDINFO_TAG_TYPE_CONTENDED:\n-        return true;\n-#ifndef PRODUCT\n-      case FIELDINFO_TAG_OFFSET:\n-        fatal(\"Asking contended flag for the field with offset\");\n-      case FIELDINFO_TAG_BLANK:\n-        fatal(\"Asking contended flag for the blank field\");\n-#endif\n-    }\n-    ShouldNotReachHere();\n-    return false;\n+    return (_shorts[low_packed_offset] & FIELDINFO_TAG_CONTENDED) != 0;\n@@ -147,15 +121,3 @@\n-    u2 lo = _shorts[low_packed_offset];\n-    switch(lo & FIELDINFO_TAG_TYPE_MASK) {\n-      case FIELDINFO_TAG_TYPE_PLAIN:\n-        return 0;\n-      case FIELDINFO_TAG_TYPE_CONTENDED:\n-        return _shorts[high_packed_offset];\n-#ifndef PRODUCT\n-      case FIELDINFO_TAG_OFFSET:\n-        fatal(\"Asking the contended group for the field with offset\");\n-      case FIELDINFO_TAG_BLANK:\n-        fatal(\"Asking the contended group for the blank field\");\n-#endif\n-    }\n-    ShouldNotReachHere();\n-    return 0;\n+    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET) == 0, \"Offset must not have been set\");\n+    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_CONTENDED) != 0, \"Field must be contended\");\n+    return _shorts[high_packed_offset];\n@@ -164,18 +126,1 @@\n-  u2 allocation_type() const {\n-    u2 lo = _shorts[low_packed_offset];\n-    switch(lo & FIELDINFO_TAG_TYPE_MASK) {\n-      case FIELDINFO_TAG_TYPE_PLAIN:\n-      case FIELDINFO_TAG_TYPE_CONTENDED:\n-        return (lo >> FIELDINFO_TAG_SIZE);\n-#ifndef PRODUCT\n-      case FIELDINFO_TAG_OFFSET:\n-        fatal(\"Asking the field type for field with offset\");\n-      case FIELDINFO_TAG_BLANK:\n-        fatal(\"Asking the field type for the blank field\");\n-#endif\n-    }\n-    ShouldNotReachHere();\n-    return 0;\n-  }\n-\n-    return (_shorts[low_packed_offset] & FIELDINFO_TAG_TYPE_MASK) == FIELDINFO_TAG_OFFSET;\n+    return (_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET)!= 0;\n@@ -202,0 +147,1 @@\n+\n@@ -204,3 +150,3 @@\n-    bool inlined = is_inlined();\n-    _shorts[low_packed_offset] = extract_low_short_from_int(val) | FIELDINFO_TAG_OFFSET;\n-    if (inlined) set_inlined(true);\n+    int inline_tag = is_inlined() ? FIELDINFO_TAG_INLINED : 0;\n+    int restricted_tag = has_restricted_type() ? FIELDINFO_TAG_RESTRICTED : 0;\n+    _shorts[low_packed_offset] = extract_low_short_from_int(val) | restricted_tag | inline_tag | FIELDINFO_TAG_OFFSET;\n@@ -208,21 +154,0 @@\n-    assert(is_inlined() || !inlined, \"just checking\");\n-  }\n-\n-  void set_allocation_type(int type) {\n-    bool b = is_inlined();\n-    u2 lo = _shorts[low_packed_offset];\n-    switch(lo & FIELDINFO_TAG_TYPE_MASK) {\n-      case FIELDINFO_TAG_BLANK:\n-        _shorts[low_packed_offset] |= ((type << FIELDINFO_TAG_SIZE)) & 0xFFFF;\n-        _shorts[low_packed_offset] &= ~FIELDINFO_TAG_TYPE_MASK;\n-        _shorts[low_packed_offset] |= FIELDINFO_TAG_TYPE_PLAIN;\n-        assert(is_inlined() || !b, \"Just checking\");\n-        return;\n-#ifndef PRODUCT\n-      case FIELDINFO_TAG_TYPE_PLAIN:\n-      case FIELDINFO_TAG_TYPE_CONTENDED:\n-      case FIELDINFO_TAG_OFFSET:\n-        fatal(\"Setting the field type with overwriting\");\n-#endif\n-    }\n-    ShouldNotReachHere();\n@@ -239,1 +164,1 @@\n-  bool is_inlined() {\n+  bool is_inlined() const {\n@@ -243,15 +168,5 @@\n-  void set_contended_group(u2 val) {\n-    u2 lo = _shorts[low_packed_offset];\n-    switch(lo & FIELDINFO_TAG_TYPE_MASK) {\n-      case FIELDINFO_TAG_TYPE_PLAIN:\n-        _shorts[low_packed_offset] |= FIELDINFO_TAG_TYPE_CONTENDED;\n-        _shorts[high_packed_offset] = val;\n-        return;\n-#ifndef PRODUCT\n-      case FIELDINFO_TAG_TYPE_CONTENDED:\n-        fatal(\"Overwriting contended group\");\n-      case FIELDINFO_TAG_BLANK:\n-        fatal(\"Setting contended group for the blank field\");\n-      case FIELDINFO_TAG_OFFSET:\n-        fatal(\"Setting contended group for field with offset\");\n-#endif\n+  void set_has_rectricted_type(bool b) {\n+    if (b) {\n+      _shorts[low_packed_offset] |= FIELDINFO_TAG_RESTRICTED;\n+    } else {\n+      _shorts[low_packed_offset] &= ~FIELDINFO_TAG_RESTRICTED;\n@@ -259,1 +174,11 @@\n-    ShouldNotReachHere();\n+  }\n+\n+  bool has_restricted_type() const {\n+    return (_shorts[low_packed_offset] & FIELDINFO_TAG_RESTRICTED) != 0;\n+  }\n+\n+  void set_contended_group(u2 val) {\n+    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET) == 0, \"Offset must not have been set\");\n+    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_CONTENDED) == 0, \"Overwritting contended group\");\n+    _shorts[low_packed_offset] |= FIELDINFO_TAG_CONTENDED;\n+    _shorts[high_packed_offset] = val;\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":43,"deletions":118,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -124,0 +125,10 @@\n+  Symbol* secondary_signature() const {\n+    assert(field()->has_restricted_type(), \"Must have\");\n+    int sig_index = field_holder()->fields_erased_type()[index()];\n+    if (access_flags().is_internal()) {\n+      return vmSymbols::symbol_at(vmSymbols::as_SID(sig_index));\n+    } else {\n+      return _constants->symbol_at(sig_index);\n+    }\n+  }\n+\n@@ -138,4 +149,0 @@\n-  int allocation_type() const {\n-    return field()->allocation_type();\n-  }\n-\n@@ -166,0 +173,8 @@\n+  bool has_restricted_type() const {\n+    return field()->has_restricted_type();\n+  }\n+\n+  void set_has_restricted_type(bool b) {\n+    field()->set_has_rectricted_type(b);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+\/\/    [EMBEDDED restricted_fields_info] only if has_restricted_fields() == true\n@@ -296,1 +297,2 @@\n-    _misc_has_injected_identityObject         = 1 << 22  \/\/ IdentityObject has been injected by the JVM\n+    _misc_has_injected_identityObject         = 1 << 22, \/\/ IdentityObject has been injected by the JVM\n+    _misc_has_restricted_fields               = 1 << 23  \/\/ class has fields with type restrictions\n@@ -487,0 +489,8 @@\n+  bool has_restricted_fields() const {\n+    return (_misc_flags & _misc_has_restricted_fields);\n+  }\n+\n+  void set_has_restricted_fields() {\n+    _misc_flags |= _misc_has_restricted_fields;\n+  }\n+\n@@ -1201,1 +1211,1 @@\n-                  int java_fields, bool is_inline_type) {\n+                  int java_fields, bool is_inline_type, bool has_restricted_fields) {\n@@ -1210,1 +1220,2 @@\n-           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0));\n+           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0) +\n+           (has_restricted_fields ? java_fields * (int)sizeof(u2)\/wordSize : 0));\n@@ -1219,1 +1230,2 @@\n-                                               is_inline_klass());\n+                                               is_inline_klass(),\n+                                               has_restricted_fields());\n@@ -1279,0 +1291,2 @@\n+  u2* fields_erased_type();\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2262,1 +2262,3 @@\n-  declare_preprocessor_constant(\"FIELDINFO_TAG_MASK\", FIELDINFO_TAG_MASK) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_CONTENDED\", FIELDINFO_TAG_CONTENDED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_INLINED\", FIELDINFO_TAG_INLINED) \\\n+  declare_preprocessor_constant(\"FIELDINFO_TAG_RESTRICTED\", FIELDINFO_TAG_RESTRICTED) \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-  private static short FIELDINFO_TAG_MASK;\n@@ -120,1 +119,0 @@\n-    FIELDINFO_TAG_MASK             = db.lookupIntConstant(\"FIELDINFO_TAG_MASK\").shortValue();\n@@ -400,1 +398,1 @@\n-    if ((lo & FIELDINFO_TAG_MASK) == FIELDINFO_TAG_OFFSET) {\n+    if ((lo & FIELDINFO_TAG_OFFSET) == FIELDINFO_TAG_OFFSET) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}