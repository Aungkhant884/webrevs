{"files":[{"patch":"@@ -10,0 +10,1 @@\n+      - pr\/*\n@@ -31,0 +32,1 @@\n+      platform_macos_aarch64: ${{ steps.check_platforms.outputs.platform_macos_aarch64 }}\n@@ -47,0 +49,1 @@\n+          echo \"::set-output name=platform_macos_aarch64::${{ contains(github.event.inputs.platforms, 'macos aarch64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'macos aarch64'))) }}\"\n@@ -1368,0 +1371,104 @@\n+  macos_aarch64_build:\n+    name: macOS aarch64\n+    runs-on: \"macos-10.15\"\n+    needs: prerequisites\n+    if: needs.prerequisites.outputs.should_run != 'false' && needs.prerequisites.outputs.platform_macos_aarch64 != 'false'\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        flavor:\n+          - build release\n+          - build debug\n+        include:\n+          - flavor: build release\n+          - flavor: build debug\n+            flags: --enable-debug\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v2\n+        with:\n+          path: jdk\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v2\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p ${HOME}\/bootjdk\/${BOOT_JDK_VERSION} || true\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256}  ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | shasum -a 256 -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v2\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v2\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Checkout gtest sources\n+        uses: actions\/checkout@v2\n+        with:\n+          repository: \"google\/googletest\"\n+          ref: \"release-${{ fromJson(needs.prerequisites.outputs.dependencies).GTEST_VERSION }}\"\n+          path: gtest\n+\n+      - name: Install dependencies\n+        run: brew install make\n+\n+      - name: Select Xcode version\n+        run: sudo xcode-select --switch \/Applications\/Xcode_12.4.app\/Contents\/Developer\n+\n+      - name: Configure\n+        run: >\n+          bash configure\n+          --with-conf-name=macos-aarch64\n+          --openjdk-target=aarch64-apple-darwin\n+          ${{ matrix.flags }}\n+          --with-version-opt=${GITHUB_ACTOR}-${GITHUB_SHA}\n+          --with-version-build=0\n+          --with-boot-jdk=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/Contents\/Home\n+          --with-jtreg=${HOME}\/jtreg\n+          --with-gtest=${GITHUB_WORKSPACE}\/gtest\n+          --with-default-make-target=\"product-bundles test-bundles\"\n+          --with-zlib=system\n+          --enable-jtreg-failure-handler\n+        working-directory: jdk\n+\n+      - name: Build\n+        run: make CONF_NAME=macos-aarch64\n+        working-directory: jdk\n+\n+      - name: Persist test bundles\n+        uses: actions\/upload-artifact@v2\n+        with:\n+          name: transient_jdk-macos-aarch64${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: |\n+            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_osx-aarch64_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_osx-aarch64_bin-tests${{ matrix.artifact }}.tar.gz\n+\n+\n@@ -1566,0 +1673,1 @@\n+      - macos_aarch64_build\n","filename":".github\/workflows\/submit.yml","additions":108,"deletions":0,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -102,1 +102,2 @@\n-JAVADOC_DISABLED_DOCLINT := missing\n+JAVADOC_DISABLED_DOCLINT_WARNINGS := missing\n+JAVADOC_DISABLED_DOCLINT_PACKAGES := org.w3c.* javax.smartcardio\n@@ -157,1 +158,2 @@\n-JAVADOC_BOTTOM := \\\n+# $1 - Optional \"Other Versions\" link\n+JAVADOC_BOTTOM = \\\n@@ -163,1 +165,1 @@\n-    of terms, workarounds, and working code examples.<br> \\\n+    of terms, workarounds, and working code examples. $1<br> \\\n@@ -298,9 +300,4 @@\n-      $$(JAVADOC_DISABLED_DOCLINT)))\n-  # Ignore the doclint warnings in the W3C DOM package\n-  $1_OPTIONS += -Xdoclint\/package:-org.w3c.*\n-\n-  ifneq ($$($1_OTHER_VERSIONS), )\n-    $1_LINKED_SHORT_NAME = <a href=\"$$($1_OTHER_VERSIONS)\">$$($1_SHORT_NAME)<\/a>\n-  else\n-    $1_LINKED_SHORT_NAME = $$($1_SHORT_NAME)\n-  endif\n+      $$(JAVADOC_DISABLED_DOCLINT_WARNINGS)))\n+  # Ignore the doclint warnings in certain packages\n+  $1_OPTIONS += -Xdoclint\/package:$$(call CommaList, $$(addprefix -, \\\n+      $$(JAVADOC_DISABLED_DOCLINT_PACKAGES)))\n@@ -311,1 +308,1 @@\n-  $1_HEADER_TITLE := <div $$(HEADER_STYLE)><strong>$$($1_LINKED_SHORT_NAME)<\/strong> \\\n+  $1_HEADER_TITLE := <div $$(HEADER_STYLE)><strong>$$($1_SHORT_NAME)<\/strong> \\\n@@ -313,0 +310,5 @@\n+  ifneq ($$($1_OTHER_VERSIONS), )\n+      $1_JAVADOC_BOTTOM := $$(call JAVADOC_BOTTOM, <a href=\"$$($1_OTHER_VERSIONS)\">Other versions.<\/a>)\n+  else\n+      $1_JAVADOC_BOTTOM := $$(call JAVADOC_BOTTOM, )\n+  endif\n@@ -317,1 +319,1 @@\n-  $1_OPTIONS += -bottom '$$(JAVADOC_BOTTOM)'\n+  $1_OPTIONS += -bottom '$$($1_JAVADOC_BOTTOM)'\n","filename":"make\/Docs.gmk","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-        \"linux-x64\", \"linux-x86\", \"macosx-x64\",\n+        \"linux-x64\", \"linux-x86\", \"macosx-x64\", \"macosx-aarch64\",\n@@ -399,1 +399,1 @@\n-    common.boot_jdk_version = \"15\";\n+    common.boot_jdk_version = \"16\";\n@@ -422,2 +422,4 @@\n-            dependencies: [\"devkit\", \"gtest\", \"graphviz\", \"pandoc\"],\n-            configure_args: concat(common.configure_args_64bit,\n+            dependencies: [\"devkit\", \"gtest\", \"build_devkit\", \"graphviz\", \"pandoc\"],\n+            configure_args: concat(\n+                (input.build_cpu == \"x64\" ? common.configure_args_64bit\n+                 : \"--openjdk-target=x86_64-linux-gnu\"),\n@@ -444,0 +446,1 @@\n+                \"--enable-compatible-cds-alignment\",\n@@ -449,0 +452,8 @@\n+        \"macosx-aarch64\": {\n+            target_os: \"macosx\",\n+            target_cpu: \"aarch64\",\n+            dependencies: [\"devkit\", \"gtest\"],\n+            configure_args: concat(common.configure_args_64bit, \"--with-zlib=system\",\n+                \"--with-macosx-version-max=11.00.00\"),\n+        },\n+\n@@ -480,0 +491,1 @@\n+\t\t\"--enable-compatible-cds-alignment\",\n@@ -558,1 +570,1 @@\n-    [ \"linux-aarch64\", \"linux-x64\", \"macosx-x64\" ].forEach(function (name) {\n+    [ \"linux-aarch64\", \"linux-x64\", \"macosx-x64\", \"macosx-aarch64\" ].forEach(function (name) {\n@@ -647,1 +659,1 @@\n-    [ \"linux-aarch64\", \"linux-x64\", \"macosx-x64\", \"windows-x64\" ]\n+    [ \"linux-aarch64\", \"linux-x64\", \"macosx-x64\", \"macosx-aarch64\", \"windows-x64\" ]\n@@ -676,0 +688,4 @@\n+        \"macosx-aarch64\": {\n+            platform: \"osx-aarch64\",\n+            jdk_subdir: \"jdk-\" + data.version + \".jdk\/Contents\/Home\",\n+        },\n@@ -843,1 +859,1 @@\n-    [ \"linux-aarch64\", \"linux-x64\", \"macosx-x64\", \"windows-x64\" ]\n+    [ \"linux-aarch64\", \"linux-x64\", \"macosx-x64\", \"macosx-aarch64\", \"windows-x64\" ]\n@@ -863,1 +879,1 @@\n-    [ \"linux-aarch64\", \"linux-x64\", \"macosx-x64\" ].forEach(function (name) {\n+    [ \"linux-aarch64\", \"linux-x64\", \"macosx-x64\", \"macosx-aarch64\" ].forEach(function (name) {\n@@ -975,2 +991,5 @@\n-            environment_path: input.get(\"devkit\", \"install_path\")\n-                + \"\/Xcode.app\/Contents\/Developer\/usr\/bin\"\n+            dependencies: [ \"lldb\" ],\n+            environment_path: [\n+                input.get(\"gnumake\", \"install_path\") + \"\/bin\",\n+                input.get(\"lldb\", \"install_path\") + \"\/Xcode.app\/Contents\/Developer\/usr\/bin\",\n+            ],\n@@ -1030,4 +1049,4 @@\n-        linux_x64: \"gcc10.2.0-OL6.4+1.0\",\n-        macosx_x64: \"Xcode11.3.1-MacOSX10.15+1.1\",\n-        windows_x64: \"VS2019-16.7.2+1.1\",\n-        linux_aarch64: \"gcc10.2.0-OL7.6+1.0\",\n+        linux_x64: \"gcc10.3.0-OL6.4+1.0\",\n+        macosx: \"Xcode12.4+1.0\",\n+        windows_x64: \"VS2019-16.9.3+1.0\",\n+        linux_aarch64: \"gcc10.3.0-OL7.6+1.0\",\n@@ -1044,0 +1063,2 @@\n+    } else if (input.target_os == \"macosx\") {\n+        devkit_platform = \"macosx\";\n@@ -1062,7 +1083,12 @@\n-\n-    var makeBinDir = (input.build_os == \"windows\"\n-        ? input.get(\"gnumake\", \"install_path\") + \"\/cygwin\/bin\"\n-        : input.get(\"gnumake\", \"install_path\") + \"\/bin\");\n-\n-    var dependencies = {\n-        boot_jdk: {\n+    var boot_jdk;\n+    if (boot_jdk_platform == 'osx-aarch64') {\n+        boot_jdk = {\n+            organization: common.organization,\n+            ext: \"tar.gz\",\n+            module: \"jdk-macosx_aarch64\",\n+            revision: \"16+1.0-beta1\",\n+            configure_args: \"--with-boot-jdk=\" + common.boot_jdk_home,\n+            environment_path: common.boot_jdk_home + \"\/bin\"\n+        }\n+    } else {\n+        boot_jdk = {\n@@ -1077,1 +1103,9 @@\n-        },\n+        }\n+    }\n+\n+    var makeBinDir = (input.build_os == \"windows\"\n+        ? input.get(\"gnumake\", \"install_path\") + \"\/cygwin\/bin\"\n+        : input.get(\"gnumake\", \"install_path\") + \"\/bin\");\n+\n+    var dependencies = {\n+        boot_jdk: boot_jdk,\n@@ -1093,1 +1127,11 @@\n-            revision: devkit_platform_revisions[input.build_platform]\n+            revision: devkit_platform_revisions[input.build_platform],\n+            \/\/ Only set --with-build-devkit when cross compiling.\n+            configure_args: (input.build_cpu == input.target_cpu ? false\n+                : \"--with-build-devkit=\" + input.get(\"build_devkit\", \"home_path\"))\n+        },\n+\n+        lldb: {\n+            organization: common.organization,\n+            ext: \"tar.gz\",\n+            module: \"devkit-macosx\" + (input.build_cpu == \"x64\" ? \"_x64\" : \"\"),\n+            revision: (input.build_cpu == \"x64\" ? \"Xcode11.3.1-MacOSX10.15+1.1\" : devkit_platform_revisions[devkit_platform])\n@@ -1121,2 +1165,1 @@\n-            \/\/ Until an official build of JCov is available, use custom\n-            \/\/ build to support classfile version 60.\n+            \/\/ Use custom build of JCov\n@@ -1130,1 +1173,1 @@\n-            revision: \"3.0-60-support+1.0\",\n+            revision: \"3.0-7-jdk-asm+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":69,"deletions":26,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"15 16 17\"\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"16 17\"\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -470,16 +470,16 @@\n-  reg_def P0 (SOC, SOC, Op_RegVMask, 0, p0->as_VMReg());\n-  reg_def P1 (SOC, SOC, Op_RegVMask, 1, p1->as_VMReg());\n-  reg_def P2 (SOC, SOC, Op_RegVMask, 2, p2->as_VMReg());\n-  reg_def P3 (SOC, SOC, Op_RegVMask, 3, p3->as_VMReg());\n-  reg_def P4 (SOC, SOC, Op_RegVMask, 4, p4->as_VMReg());\n-  reg_def P5 (SOC, SOC, Op_RegVMask, 5, p5->as_VMReg());\n-  reg_def P6 (SOC, SOC, Op_RegVMask, 6, p6->as_VMReg());\n-  reg_def P7 (SOC, SOC, Op_RegVMask, 7, p7->as_VMReg());\n-  reg_def P8 (SOC, SOC, Op_RegVMask, 8, p8->as_VMReg());\n-  reg_def P9 (SOC, SOC, Op_RegVMask, 9, p9->as_VMReg());\n-  reg_def P10 (SOC, SOC, Op_RegVMask, 10, p10->as_VMReg());\n-  reg_def P11 (SOC, SOC, Op_RegVMask, 11, p11->as_VMReg());\n-  reg_def P12 (SOC, SOC, Op_RegVMask, 12, p12->as_VMReg());\n-  reg_def P13 (SOC, SOC, Op_RegVMask, 13, p13->as_VMReg());\n-  reg_def P14 (SOC, SOC, Op_RegVMask, 14, p14->as_VMReg());\n-  reg_def P15 (SOC, SOC, Op_RegVMask, 15, p15->as_VMReg());\n+  reg_def P0 (SOC, SOC, Op_RegVectMask, 0, p0->as_VMReg());\n+  reg_def P1 (SOC, SOC, Op_RegVectMask, 1, p1->as_VMReg());\n+  reg_def P2 (SOC, SOC, Op_RegVectMask, 2, p2->as_VMReg());\n+  reg_def P3 (SOC, SOC, Op_RegVectMask, 3, p3->as_VMReg());\n+  reg_def P4 (SOC, SOC, Op_RegVectMask, 4, p4->as_VMReg());\n+  reg_def P5 (SOC, SOC, Op_RegVectMask, 5, p5->as_VMReg());\n+  reg_def P6 (SOC, SOC, Op_RegVectMask, 6, p6->as_VMReg());\n+  reg_def P7 (SOC, SOC, Op_RegVectMask, 7, p7->as_VMReg());\n+  reg_def P8 (SOC, SOC, Op_RegVectMask, 8, p8->as_VMReg());\n+  reg_def P9 (SOC, SOC, Op_RegVectMask, 9, p9->as_VMReg());\n+  reg_def P10 (SOC, SOC, Op_RegVectMask, 10, p10->as_VMReg());\n+  reg_def P11 (SOC, SOC, Op_RegVectMask, 11, p11->as_VMReg());\n+  reg_def P12 (SOC, SOC, Op_RegVectMask, 12, p12->as_VMReg());\n+  reg_def P13 (SOC, SOC, Op_RegVectMask, 13, p13->as_VMReg());\n+  reg_def P14 (SOC, SOC, Op_RegVectMask, 14, p14->as_VMReg());\n+  reg_def P15 (SOC, SOC, Op_RegVectMask, 15, p15->as_VMReg());\n@@ -1785,14 +1785,0 @@\n-\/\/ Indicate if the safepoint node needs the polling page as an input\n-\n-\/\/ the shared code plants the oop data at the start of the generated\n-\/\/ code for the safepoint node and that needs ot be at the load\n-\/\/ instruction itself. so we cannot plant a mov of the safepoint poll\n-\/\/ address followed by a load. setting this to true means the mov is\n-\/\/ scheduled as a prior instruction. that's better for scheduling\n-\/\/ anyway.\n-\n-bool SafePointNode::needs_polling_address_input()\n-{\n-  return true;\n-}\n-\n@@ -2454,0 +2440,8 @@\n+const RegMask* Matcher::predicate_reg_mask(void) {\n+  return &_PR_REG_mask;\n+}\n+\n+const TypeVect* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n+  return new TypeVectMask(elemTy, length);\n+}\n+\n@@ -5621,1 +5615,1 @@\n-  match(RegVMask);\n+  match(RegVectMask);\n@@ -6280,0 +6274,1 @@\n+opclass vmem2(indirect, indIndex, indOffI2, indOffL2);\n@@ -9260,1 +9255,0 @@\n-\n@@ -9274,0 +9268,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9275,0 +9271,1 @@\n+\n@@ -9290,0 +9287,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9291,0 +9290,1 @@\n+\n@@ -9306,0 +9306,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9307,0 +9309,1 @@\n+\n@@ -9321,0 +9324,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9322,0 +9327,1 @@\n+\n@@ -9336,0 +9342,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9337,0 +9345,1 @@\n+\n@@ -9351,0 +9360,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9367,0 +9378,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9384,0 +9397,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9401,1 +9416,2 @@\n-\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9418,0 +9434,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9434,1 +9452,2 @@\n-\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9451,0 +9470,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9467,0 +9488,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9468,0 +9491,1 @@\n+\n@@ -9484,0 +9508,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9485,0 +9511,1 @@\n+\n@@ -9501,0 +9528,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9502,0 +9531,1 @@\n+\n@@ -9518,0 +9548,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9519,0 +9551,1 @@\n+\n@@ -9535,0 +9568,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9536,0 +9571,1 @@\n+\n@@ -9552,0 +9588,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9570,0 +9608,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9588,0 +9628,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9606,0 +9648,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9624,0 +9668,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9642,0 +9688,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9660,0 +9708,2 @@\n+\/\/ This pattern is generated automatically from cas.m4.\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -9661,1 +9711,1 @@\n-  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n+  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":85,"deletions":35,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2251,7 +2251,0 @@\n-\n-\/* vtable-dispatch is not enabled for aarch64 platform*\/\n-void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {\n-  ShouldNotReachHere();\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-        __ move(tmp, LIR_OprFact::intptrConst(large_disp));\n+        __ move(LIR_OprFact::intptrConst(large_disp), tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -4,0 +4,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -60,1 +61,6 @@\n-int InterpreterRuntime::SignatureHandlerGenerator::next_stack_offset() {\n+\/\/ On macos\/aarch64 native stack is packed, int\/float are using only 4 bytes\n+\/\/ on stack. Natural alignment for types are still in place,\n+\/\/ for example double\/long should be 8 bytes aligned.\n+\n+int InterpreterRuntime::SignatureHandlerGenerator::next_stack_offset(unsigned elem_size) {\n+  MACOS_ONLY(_stack_offset = align_up(_stack_offset, elem_size));\n@@ -62,1 +68,1 @@\n-  _stack_offset += wordSize;\n+  _stack_offset += NOT_MACOS(wordSize) MACOS_ONLY(elem_size);\n@@ -74,0 +80,24 @@\n+void InterpreterRuntime::SignatureHandlerGenerator::pass_byte() {\n+  const Address src(from(), Interpreter::local_offset_in_bytes(offset()));\n+\n+  Register reg = next_gpr();\n+  if (reg != noreg) {\n+    __ ldr(reg, src);\n+  } else {\n+    __ ldrb(r0, src);\n+    __ strb(r0, Address(to(), next_stack_offset(sizeof(jbyte))));\n+  }\n+}\n+\n+void InterpreterRuntime::SignatureHandlerGenerator::pass_short() {\n+  const Address src(from(), Interpreter::local_offset_in_bytes(offset()));\n+\n+  Register reg = next_gpr();\n+  if (reg != noreg) {\n+    __ ldr(reg, src);\n+  } else {\n+    __ ldrh(r0, src);\n+    __ strh(r0, Address(to(), next_stack_offset(sizeof(jshort))));\n+  }\n+}\n+\n@@ -82,1 +112,1 @@\n-    __ strw(r0, Address(to(), next_stack_offset()));\n+    __ strw(r0, Address(to(), next_stack_offset(sizeof(jint))));\n@@ -94,1 +124,1 @@\n-    __ str(r0, Address(to(), next_stack_offset()));\n+    __ str(r0, Address(to(), next_stack_offset(sizeof(jlong))));\n@@ -106,1 +136,1 @@\n-    __ strw(r0, Address(to(), next_stack_offset()));\n+    __ strw(r0, Address(to(), next_stack_offset(sizeof(jfloat))));\n@@ -118,1 +148,1 @@\n-    __ str(r0, Address(to(), next_stack_offset()));\n+    __ str(r0, Address(to(), next_stack_offset(sizeof(jdouble))));\n@@ -142,1 +172,2 @@\n-    __ str(r0, Address(to(), next_stack_offset()));\n+    static_assert(sizeof(jobject) == wordSize, \"\");\n+    __ str(r0, Address(to(), next_stack_offset(sizeof(jobject))));\n@@ -171,1 +202,1 @@\n-  intptr_t* _to;\n+  char*     _to;\n@@ -206,2 +237,19 @@\n-  void pass_stack(intptr_t value) {\n-    *_to++ = value;\n+  template<typename T>\n+  void pass_stack(T value) {\n+    MACOS_ONLY(_to = align_up(_to, sizeof(value)));\n+    *(T *)_to = value;\n+    _to += NOT_MACOS(wordSize) MACOS_ONLY(sizeof(value));\n+  }\n+\n+  virtual void pass_byte() {\n+    jbyte value = *(jbyte*)single_slot_addr();\n+    if (pass_gpr(value) < 0) {\n+      pass_stack<>(value);\n+    }\n+  }\n+\n+  virtual void pass_short() {\n+    jshort value = *(jshort*)single_slot_addr();\n+    if (pass_gpr(value) < 0) {\n+      pass_stack<>(value);\n+    }\n@@ -213,1 +261,1 @@\n-      pass_stack(value);\n+      pass_stack<>(value);\n@@ -225,1 +273,1 @@\n-      pass_stack(value);\n+      pass_stack<>(value);\n@@ -233,1 +281,1 @@\n-      pass_stack(value);\n+      pass_stack<>(value);\n@@ -240,1 +288,1 @@\n-      pass_stack(value);\n+      pass_stack<>(value);\n@@ -250,1 +298,1 @@\n-      pass_stack(value);\n+      pass_stack<>(value);\n@@ -259,1 +307,1 @@\n-    _to   = to;\n+    _to   = (char *)to;\n@@ -273,1 +321,1 @@\n-          InterpreterRuntime::slow_signature_handler(JavaThread* thread,\n+          InterpreterRuntime::slow_signature_handler(JavaThread* current,\n@@ -277,1 +325,1 @@\n-  methodHandle m(thread, (Method*)method);\n+  methodHandle m(current, (Method*)method);\n","filename":"src\/hotspot\/cpu\/aarch64\/interpreterRT_aarch64.cpp","additions":67,"deletions":19,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -4,0 +4,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -41,0 +42,2 @@\n+  void pass_byte();\n+  void pass_short();\n@@ -50,1 +53,1 @@\n-  int next_stack_offset();\n+  int next_stack_offset(unsigned elem_size);\n","filename":"src\/hotspot\/cpu\/aarch64\/interpreterRT_aarch64.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -56,0 +57,42 @@\n+\/\/ On macos\/aarch64 we need to ensure WXExec mode when running generated\n+\/\/ FastGetXXXField, as these functions can be called from WXWrite context\n+\/\/ (8262896).  So each FastGetXXXField is wrapped into a C++ statically\n+\/\/ compiled template function that optionally switches to WXExec if necessary.\n+\n+#ifdef __APPLE__\n+\n+static address generated_fast_get_field[T_LONG + 1 - T_BOOLEAN];\n+\n+template<int BType> struct BasicTypeToJni {};\n+template<> struct BasicTypeToJni<T_BOOLEAN> { static const jboolean jni_type; };\n+template<> struct BasicTypeToJni<T_BYTE>    { static const jbyte    jni_type; };\n+template<> struct BasicTypeToJni<T_CHAR>    { static const jchar    jni_type; };\n+template<> struct BasicTypeToJni<T_SHORT>   { static const jshort   jni_type; };\n+template<> struct BasicTypeToJni<T_INT>     { static const jint     jni_type; };\n+template<> struct BasicTypeToJni<T_LONG>    { static const jlong    jni_type; };\n+template<> struct BasicTypeToJni<T_FLOAT>   { static const jfloat   jni_type; };\n+template<> struct BasicTypeToJni<T_DOUBLE>  { static const jdouble  jni_type; };\n+\n+template<int BType, typename JniType = decltype(BasicTypeToJni<BType>::jni_type)>\n+JniType static_fast_get_field_wrapper(JNIEnv *env, jobject obj, jfieldID fieldID) {\n+  JavaThread* thread = JavaThread::thread_from_jni_environment(env);\n+  ThreadWXEnable wx(WXExec, thread);\n+  address get_field_addr = generated_fast_get_field[BType - T_BOOLEAN];\n+  return ((JniType(*)(JNIEnv *env, jobject obj, jfieldID fieldID))get_field_addr)(env, obj, fieldID);\n+}\n+\n+template<int BType>\n+address JNI_FastGetField::generate_fast_get_int_field1() {\n+  generated_fast_get_field[BType - T_BOOLEAN] = generate_fast_get_int_field0((BasicType)BType);\n+  return (address)static_fast_get_field_wrapper<BType>;\n+}\n+\n+#else \/\/ __APPLE__\n+\n+template<int BType>\n+address JNI_FastGetField::generate_fast_get_int_field1() {\n+  return generate_fast_get_int_field0((BasicType)BType);\n+}\n+\n+#endif \/\/ __APPLE__\n+\n@@ -172,1 +215,1 @@\n-  return generate_fast_get_int_field0(T_BOOLEAN);\n+  return generate_fast_get_int_field1<T_BOOLEAN>();\n@@ -176,1 +219,1 @@\n-  return generate_fast_get_int_field0(T_BYTE);\n+  return generate_fast_get_int_field1<T_BYTE>();\n@@ -180,1 +223,1 @@\n-  return generate_fast_get_int_field0(T_CHAR);\n+  return generate_fast_get_int_field1<T_CHAR>();\n@@ -184,1 +227,1 @@\n-  return generate_fast_get_int_field0(T_SHORT);\n+  return generate_fast_get_int_field1<T_SHORT>();\n@@ -188,1 +231,1 @@\n-  return generate_fast_get_int_field0(T_INT);\n+  return generate_fast_get_int_field1<T_INT>();\n@@ -192,1 +235,1 @@\n-  return generate_fast_get_int_field0(T_LONG);\n+  return generate_fast_get_int_field1<T_LONG>();\n@@ -196,1 +239,1 @@\n-  return generate_fast_get_int_field0(T_FLOAT);\n+  return generate_fast_get_int_field1<T_FLOAT>();\n@@ -200,1 +243,1 @@\n-  return generate_fast_get_int_field0(T_DOUBLE);\n+  return generate_fast_get_int_field1<T_DOUBLE>();\n","filename":"src\/hotspot\/cpu\/aarch64\/jniFastGetField_aarch64.cpp","additions":51,"deletions":8,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"interpreter\/bytecodeHistogram.hpp\"\n@@ -184,1 +185,1 @@\n-    uint32_t n = CompressedOops::narrow_oop_value((oop)o);\n+    uint32_t n = CompressedOops::narrow_oop_value(cast_to_oop(o));\n@@ -5499,1 +5500,1 @@\n-  fmovd(vtmp1, zr);\n+  fmovd(vtmp1, 0.0);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -535,26 +536,0 @@\n-  \/\/ AdvSIMD shift by immediate.\n-  \/\/ These are \"user friendly\" variants which allow a shift count of 0.\n-#define WRAP(INSN)                                                                \\\n-  void INSN(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int shift) {  \\\n-    if (shift == 0) {                                                             \\\n-      SIMD_Arrangement arrange = (T & 1) == 0 ? T8B : T16B;                       \\\n-      Assembler::orr(Vd, arrange, Vn, Vn);                                        \\\n-    } else {                                                                      \\\n-      Assembler::INSN(Vd, T, Vn, shift);                                          \\\n-    }                                                                             \\\n-  }                                                                               \\\n-\n-  WRAP(shl) WRAP(sshr) WRAP(ushr)\n-#undef WRAP\n-\n-#define WRAP(INSN)                                                                \\\n-  void INSN(FloatRegister Vd, SIMD_Arrangement T, FloatRegister Vn, int shift) {  \\\n-    if (shift == 0) {                                                             \\\n-      Assembler::addv(Vd, T, Vd, Vn);                                             \\\n-    } else {                                                                      \\\n-      Assembler::INSN(Vd, T, Vn, shift);                                          \\\n-    }                                                                             \\\n-  }                                                                               \\\n-\n-  WRAP(usra) WRAP(ssra)\n-#undef WRAP\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -34,0 +35,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -1037,1 +1039,1 @@\n-int SharedRuntime::c_calling_convention(const BasicType *sig_bt,\n+static int c_calling_convention_priv(const BasicType *sig_bt,\n@@ -1068,0 +1070,5 @@\n+#ifdef __APPLE__\n+          \/\/ Less-than word types are stored one after another.\n+          \/\/ The code is unable to handle this so bailout.\n+          return -1;\n+#endif\n@@ -1091,0 +1098,5 @@\n+#ifdef __APPLE__\n+          \/\/ Less-than word types are stored one after another.\n+          \/\/ The code is unable to handle this so bailout.\n+          return -1;\n+#endif\n@@ -1117,0 +1129,10 @@\n+int SharedRuntime::c_calling_convention(const BasicType *sig_bt,\n+                                         VMRegPair *regs,\n+                                         VMRegPair *regs2,\n+                                         int total_args_passed)\n+{\n+  int result = c_calling_convention_priv(sig_bt, regs, regs2, total_args_passed);\n+  guarantee(result >= 0, \"Unsupported arguments configuration\");\n+  return result;\n+}\n+\n@@ -1622,1 +1644,5 @@\n-  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);\n+  out_arg_slots = c_calling_convention_priv(out_sig_bt, out_regs, NULL, total_c_args);\n+\n+  if (out_arg_slots < 0) {\n+    return NULL;\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -5599,0 +5600,300 @@\n+  void generate_base64_decode_simdround(Register src, Register dst,\n+        FloatRegister codecL, FloatRegister codecH, int size, Label& Exit) {\n+\n+    FloatRegister in0  = v16, in1  = v17,  in2 = v18,  in3 = v19;\n+    FloatRegister out0 = v20, out1 = v21, out2 = v22;\n+\n+    FloatRegister decL0 = v23, decL1 = v24, decL2 = v25, decL3 = v26;\n+    FloatRegister decH0 = v28, decH1 = v29, decH2 = v30, decH3 = v31;\n+\n+    Label NoIllegalData, ErrorInLowerHalf, StoreLegalData;\n+\n+    Assembler::SIMD_Arrangement arrangement = size == 16 ? __ T16B : __ T8B;\n+\n+    __ ld4(in0, in1, in2, in3, arrangement, __ post(src, 4 * size));\n+\n+    \/\/ we need unsigned saturating substract, to make sure all input values\n+    \/\/ in range [0, 63] will have 0U value in the higher half lookup\n+    __ uqsubv(decH0, __ T16B, in0, v27);\n+    __ uqsubv(decH1, __ T16B, in1, v27);\n+    __ uqsubv(decH2, __ T16B, in2, v27);\n+    __ uqsubv(decH3, __ T16B, in3, v27);\n+\n+    \/\/ lower half lookup\n+    __ tbl(decL0, arrangement, codecL, 4, in0);\n+    __ tbl(decL1, arrangement, codecL, 4, in1);\n+    __ tbl(decL2, arrangement, codecL, 4, in2);\n+    __ tbl(decL3, arrangement, codecL, 4, in3);\n+\n+    \/\/ higher half lookup\n+    __ tbx(decH0, arrangement, codecH, 4, decH0);\n+    __ tbx(decH1, arrangement, codecH, 4, decH1);\n+    __ tbx(decH2, arrangement, codecH, 4, decH2);\n+    __ tbx(decH3, arrangement, codecH, 4, decH3);\n+\n+    \/\/ combine lower and higher\n+    __ orr(decL0, arrangement, decL0, decH0);\n+    __ orr(decL1, arrangement, decL1, decH1);\n+    __ orr(decL2, arrangement, decL2, decH2);\n+    __ orr(decL3, arrangement, decL3, decH3);\n+\n+    \/\/ check illegal inputs, value larger than 63 (maximum of 6 bits)\n+    __ cmhi(decH0, arrangement, decL0, v27);\n+    __ cmhi(decH1, arrangement, decL1, v27);\n+    __ cmhi(decH2, arrangement, decL2, v27);\n+    __ cmhi(decH3, arrangement, decL3, v27);\n+    __ orr(in0, arrangement, decH0, decH1);\n+    __ orr(in1, arrangement, decH2, decH3);\n+    __ orr(in2, arrangement, in0,   in1);\n+    __ umaxv(in3, arrangement, in2);\n+    __ umov(rscratch2, in3, __ B, 0);\n+\n+    \/\/ get the data to output\n+    __ shl(out0,  arrangement, decL0, 2);\n+    __ ushr(out1, arrangement, decL1, 4);\n+    __ orr(out0,  arrangement, out0,  out1);\n+    __ shl(out1,  arrangement, decL1, 4);\n+    __ ushr(out2, arrangement, decL2, 2);\n+    __ orr(out1,  arrangement, out1,  out2);\n+    __ shl(out2,  arrangement, decL2, 6);\n+    __ orr(out2,  arrangement, out2,  decL3);\n+\n+    __ cbz(rscratch2, NoIllegalData);\n+\n+    \/\/ handle illegal input\n+    __ umov(r10, in2, __ D, 0);\n+    if (size == 16) {\n+      __ cbnz(r10, ErrorInLowerHalf);\n+\n+      \/\/ illegal input is in higher half, store the lower half now.\n+      __ st3(out0, out1, out2, __ T8B, __ post(dst, 24));\n+\n+      __ umov(r10, in2,  __ D, 1);\n+      __ umov(r11, out0, __ D, 1);\n+      __ umov(r12, out1, __ D, 1);\n+      __ umov(r13, out2, __ D, 1);\n+      __ b(StoreLegalData);\n+\n+      __ BIND(ErrorInLowerHalf);\n+    }\n+    __ umov(r11, out0, __ D, 0);\n+    __ umov(r12, out1, __ D, 0);\n+    __ umov(r13, out2, __ D, 0);\n+\n+    __ BIND(StoreLegalData);\n+    __ tbnz(r10, 5, Exit); \/\/ 0xff indicates illegal input\n+    __ strb(r11, __ post(dst, 1));\n+    __ strb(r12, __ post(dst, 1));\n+    __ strb(r13, __ post(dst, 1));\n+    __ lsr(r10, r10, 8);\n+    __ lsr(r11, r11, 8);\n+    __ lsr(r12, r12, 8);\n+    __ lsr(r13, r13, 8);\n+    __ b(StoreLegalData);\n+\n+    __ BIND(NoIllegalData);\n+    __ st3(out0, out1, out2, arrangement, __ post(dst, 3 * size));\n+  }\n+\n+\n+   \/**\n+   *  Arguments:\n+   *\n+   *  Input:\n+   *  c_rarg0   - src_start\n+   *  c_rarg1   - src_offset\n+   *  c_rarg2   - src_length\n+   *  c_rarg3   - dest_start\n+   *  c_rarg4   - dest_offset\n+   *  c_rarg5   - isURL\n+   *\n+   *\/\n+  address generate_base64_decodeBlock() {\n+\n+    \/\/ The SIMD part of this Base64 decode intrinsic is based on the algorithm outlined\n+    \/\/ on http:\/\/0x80.pl\/articles\/base64-simd-neon.html#encoding-quadwords, in section\n+    \/\/ titled \"Base64 decoding\".\n+\n+    \/\/ Non-SIMD lookup tables are mostly dumped from fromBase64 array used in java.util.Base64,\n+    \/\/ except the trailing character '=' is also treated illegal value in this instrinsic. That\n+    \/\/ is java.util.Base64.fromBase64['='] = -2, while fromBase(URL)64ForNoSIMD['='] = 255 here.\n+    static const uint8_t fromBase64ForNoSIMD[256] = {\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n+       52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+       15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u, 255u,\n+      255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+       41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    static const uint8_t fromBase64URLForNoSIMD[256] = {\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n+       52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+       15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,  63u,\n+      255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+       41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    \/\/ A legal value of base64 code is in range [0, 127].  We need two lookups\n+    \/\/ with tbl\/tbx and combine them to get the decode data. The 1st table vector\n+    \/\/ lookup use tbl, out of range indices are set to 0 in destination. The 2nd\n+    \/\/ table vector lookup use tbx, out of range indices are unchanged in\n+    \/\/ destination. Input [64..126] is mapped to index [65, 127] in second lookup.\n+    \/\/ The value of index 64 is set to 0, so that we know that we already get the\n+    \/\/ decoded data with the 1st lookup.\n+    static const uint8_t fromBase64ForSIMD[128] = {\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n+       52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        0u, 255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,\n+       14u,  15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,\n+      255u, 255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,\n+       40u,  41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    static const uint8_t fromBase64URLForSIMD[128] = {\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n+       52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        0u, 255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,\n+       14u,  15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,\n+       63u, 255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,\n+       40u,  41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"decodeBlock\");\n+    address start = __ pc();\n+\n+    Register src   = c_rarg0;  \/\/ source array\n+    Register soff  = c_rarg1;  \/\/ source start offset\n+    Register send  = c_rarg2;  \/\/ source end offset\n+    Register dst   = c_rarg3;  \/\/ dest array\n+    Register doff  = c_rarg4;  \/\/ position for writing to dest array\n+    Register isURL = c_rarg5;  \/\/ Base64 or URL character set\n+\n+    Register length = send;    \/\/ reuse send as length of source data to process\n+\n+    Register simd_codec   = c_rarg6;\n+    Register nosimd_codec = c_rarg7;\n+\n+    Label ProcessData, Process64B, Process32B, Process4B, SIMDEnter, SIMDExit, Exit;\n+\n+    __ enter();\n+\n+    __ add(src, src, soff);\n+    __ add(dst, dst, doff);\n+\n+    __ mov(doff, dst);\n+\n+    __ sub(length, send, soff);\n+    __ bfm(length, zr, 0, 1);\n+\n+    __ lea(nosimd_codec, ExternalAddress((address) fromBase64ForNoSIMD));\n+    __ cbz(isURL, ProcessData);\n+    __ lea(nosimd_codec, ExternalAddress((address) fromBase64URLForNoSIMD));\n+\n+    __ BIND(ProcessData);\n+    __ mov(rscratch1, length);\n+    __ cmp(length, (u1)144); \/\/ 144 = 80 + 64\n+    __ br(Assembler::LT, Process4B);\n+\n+    \/\/ In the MIME case, the line length cannot be more than 76\n+    \/\/ bytes (see RFC 2045). This is too short a block for SIMD\n+    \/\/ to be worthwhile, so we use non-SIMD here.\n+    __ movw(rscratch1, 79);\n+\n+    __ BIND(Process4B);\n+    __ ldrw(r14, __ post(src, 4));\n+    __ ubfxw(r10, r14, 0,  8);\n+    __ ubfxw(r11, r14, 8,  8);\n+    __ ubfxw(r12, r14, 16, 8);\n+    __ ubfxw(r13, r14, 24, 8);\n+    \/\/ get the de-code\n+    __ ldrb(r10, Address(nosimd_codec, r10, Address::uxtw(0)));\n+    __ ldrb(r11, Address(nosimd_codec, r11, Address::uxtw(0)));\n+    __ ldrb(r12, Address(nosimd_codec, r12, Address::uxtw(0)));\n+    __ ldrb(r13, Address(nosimd_codec, r13, Address::uxtw(0)));\n+    \/\/ error detection, 255u indicates an illegal input\n+    __ orrw(r14, r10, r11);\n+    __ orrw(r15, r12, r13);\n+    __ orrw(r14, r14, r15);\n+    __ tbnz(r14, 7, Exit);\n+    \/\/ recover the data\n+    __ lslw(r14, r10, 10);\n+    __ bfiw(r14, r11, 4, 6);\n+    __ bfmw(r14, r12, 2, 5);\n+    __ rev16w(r14, r14);\n+    __ bfiw(r13, r12, 6, 2);\n+    __ strh(r14, __ post(dst, 2));\n+    __ strb(r13, __ post(dst, 1));\n+    \/\/ non-simd loop\n+    __ subsw(rscratch1, rscratch1, 4);\n+    __ br(Assembler::GT, Process4B);\n+\n+    \/\/ if exiting from PreProcess80B, rscratch1 == -1;\n+    \/\/ otherwise, rscratch1 == 0.\n+    __ cbzw(rscratch1, Exit);\n+    __ sub(length, length, 80);\n+\n+    __ lea(simd_codec, ExternalAddress((address) fromBase64ForSIMD));\n+    __ cbz(isURL, SIMDEnter);\n+    __ lea(simd_codec, ExternalAddress((address) fromBase64URLForSIMD));\n+\n+    __ BIND(SIMDEnter);\n+    __ ld1(v0, v1, v2, v3, __ T16B, __ post(simd_codec, 64));\n+    __ ld1(v4, v5, v6, v7, __ T16B, Address(simd_codec));\n+    __ mov(rscratch1, 63);\n+    __ dup(v27, __ T16B, rscratch1);\n+\n+    __ BIND(Process64B);\n+    __ cmp(length, (u1)64);\n+    __ br(Assembler::LT, Process32B);\n+    generate_base64_decode_simdround(src, dst, v0, v4, 16, Exit);\n+    __ sub(length, length, 64);\n+    __ b(Process64B);\n+\n+    __ BIND(Process32B);\n+    __ cmp(length, (u1)32);\n+    __ br(Assembler::LT, SIMDExit);\n+    generate_base64_decode_simdround(src, dst, v0, v4, 8, Exit);\n+    __ sub(length, length, 32);\n+    __ b(Process32B);\n+\n+    __ BIND(SIMDExit);\n+    __ cbz(length, Exit);\n+    __ movw(rscratch1, length);\n+    __ b(Process4B);\n+\n+    __ BIND(Exit);\n+    __ sub(c_rarg0, dst, doff);\n+\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -7025,0 +7326,1 @@\n+        StubRoutines::_base64_decodeBlock = generate_base64_decodeBlock();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":302,"deletions":0,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-    __ fmovs(v0, zr);\n+    __ fmovs(v0, 0.0);\n@@ -284,1 +284,1 @@\n-    __ fmovd(v0, zr);\n+    __ fmovd(v0, 0.0);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1944,6 +1944,0 @@\n-\n-\/* vtable-dispatch is not enabled for arm platforms *\/\n-void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {\n-  ShouldNotReachHere();\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -709,7 +709,0 @@\n-\n-\/* vtable_call is not enabled for ppc platform *\/\n-void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {\n-  ShouldNotReachHere(); \/\/ ic_call is used instead.\n-}\n-\n-\n@@ -1330,2 +1323,2 @@\n-  const Register return_pc        = R31;  \/\/ Must survive C-call to enable_stack_reserved_zone().\n-  const Register polling_page     = R12;\n+  const Register return_pc = R31;  \/\/ Must survive C-call to enable_stack_reserved_zone().\n+  const Register temp      = R12;\n@@ -1341,2 +1334,0 @@\n-  __ ld(polling_page, in_bytes(Thread::polling_page_offset()), R16_thread);\n-\n@@ -1354,2 +1345,5 @@\n-  __ relocate(relocInfo::poll_return_type);\n-  __ load_from_polling_page(polling_page);\n+  if (!UseSIGTRAP) {\n+    code_stub->set_safepoint_offset(__ offset());\n+    __ relocate(relocInfo::poll_return_type);\n+  }\n+  __ safepoint_poll(*code_stub->entry(), temp, true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -830,0 +830,1 @@\n+\/\/ Apply stack watermark barrier.\n@@ -845,0 +846,17 @@\n+\n+  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n+  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n+  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n+  Label slow_path;\n+  Label fast_path;\n+  safepoint_poll(slow_path, R11_scratch1, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  b(fast_path);\n+  bind(slow_path);\n+  push(state);\n+  set_last_Java_frame(R1_SP, noreg);\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), R16_thread);\n+  reset_last_Java_frame();\n+  pop(state);\n+  align(32);\n+  bind(fast_path);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -499,1 +499,0 @@\n-    case lir_virtual_call:   \/\/ currently, sparc-specific for niagara\n@@ -536,5 +535,0 @@\n-\/\/ not supported\n-void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {\n-  ShouldNotReachHere();\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -3058,1 +3059,0 @@\n-  case lir_virtual_call:  \/\/ currently, sparc-specific for niagara\n@@ -3081,6 +3081,0 @@\n-\/* Currently, vtable-dispatch is only enabled for sparc platforms *\/\n-void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {\n-  ShouldNotReachHere();\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-void C2_MacroAssembler::setvectmask(Register dst, Register src) {\n+void C2_MacroAssembler::setvectmask(Register dst, Register src, KRegister mask) {\n@@ -57,1 +57,1 @@\n-  Assembler::kmovdl(k1, dst);\n+  Assembler::kmovdl(mask, dst);\n@@ -61,1 +61,1 @@\n-void C2_MacroAssembler::restorevectmask() {\n+void C2_MacroAssembler::restorevectmask(KRegister mask) {\n@@ -63,1 +63,1 @@\n-  Assembler::knotwl(k1, k0);\n+  Assembler::knotwl(mask, k0);\n@@ -1901,1 +1901,1 @@\n-void C2_MacroAssembler::genmask(Register dst, Register len, Register temp) {\n+void C2_MacroAssembler::genmask(KRegister dst, Register len, Register temp) {\n@@ -1903,2 +1903,3 @@\n-  mov64(dst, -1L);\n-  bzhiq(dst, dst, len);\n+  mov64(temp, -1L);\n+  bzhiq(temp, temp, len);\n+  kmovql(dst, temp);\n@@ -2162,1 +2163,2 @@\n-void C2_MacroAssembler::vectortest(int bt, int vlen, XMMRegister src1, XMMRegister src2, XMMRegister vtmp1, XMMRegister vtmp2) {\n+void C2_MacroAssembler::vectortest(int bt, int vlen, XMMRegister src1, XMMRegister src2,\n+                                   XMMRegister vtmp1, XMMRegister vtmp2, KRegister mask) {\n@@ -2200,2 +2202,1 @@\n-        KRegister ktemp = k2; \/\/ Use a hardcoded temp due to no k register allocation.\n-        evpcmpeqb(ktemp, src1, src2, Assembler::AVX_512bit);\n+        evpcmpeqb(mask, src1, src2, Assembler::AVX_512bit);\n@@ -2204,1 +2205,1 @@\n-          ktestql(ktemp, ktemp);\n+          ktestql(mask, mask);\n@@ -2207,1 +2208,1 @@\n-          kortestql(ktemp, ktemp);\n+          kortestql(mask, mask);\n@@ -2924,1 +2925,1 @@\n-                                       XMMRegister vec1, int ae) {\n+                                       XMMRegister vec1, int ae, KRegister mask) {\n@@ -3077,1 +3078,1 @@\n-        evpcmpeqb(k7, vec1, Address(str2, result, scale), Assembler::AVX_512bit); \/\/ k7 == 11..11, if operands equal, otherwise k7 has some 0\n+        evpcmpeqb(mask, vec1, Address(str2, result, scale), Assembler::AVX_512bit); \/\/ k7 == 11..11, if operands equal, otherwise k7 has some 0\n@@ -3080,1 +3081,1 @@\n-        evpcmpeqb(k7, vec1, Address(str2, result, scale2), Assembler::AVX_512bit); \/\/ k7 == 11..11, if operands equal, otherwise k7 has some 0\n+        evpcmpeqb(mask, vec1, Address(str2, result, scale2), Assembler::AVX_512bit); \/\/ k7 == 11..11, if operands equal, otherwise k7 has some 0\n@@ -3082,1 +3083,1 @@\n-      kortestql(k7, k7);\n+      kortestql(mask, mask);\n@@ -3266,1 +3267,1 @@\n-    kmovql(cnt1, k7);\n+    kmovql(cnt1, mask);\n@@ -3315,1 +3316,1 @@\n-  XMMRegister vec1, XMMRegister vec2) {\n+  XMMRegister vec1, XMMRegister vec2, KRegister mask1, KRegister mask2) {\n@@ -3347,2 +3348,2 @@\n-    evpcmpgtb(k2, vec2, Address(ary1, len, Address::times_1), Assembler::AVX_512bit);\n-    kortestql(k2, k2);\n+    evpcmpgtb(mask1, vec2, Address(ary1, len, Address::times_1), Assembler::AVX_512bit);\n+    kortestql(mask1, mask1);\n@@ -3365,1 +3366,1 @@\n-    kmovql(k3, tmp3_aliased);\n+    kmovql(mask2, tmp3_aliased);\n@@ -3390,1 +3391,1 @@\n-    evpcmpgtb(k3, vec1, Address(len, 0), Assembler::AVX_512bit);\n+    evpcmpgtb(mask2, vec1, Address(len, 0), Assembler::AVX_512bit);\n@@ -3393,2 +3394,2 @@\n-    evpcmpgtb(k2, k3, vec2, Address(ary1, 0), Assembler::AVX_512bit);\n-    ktestq(k2, k3);\n+    evpcmpgtb(mask1, mask2, vec2, Address(ary1, 0), Assembler::AVX_512bit);\n+    ktestq(mask1, mask2);\n@@ -3521,1 +3522,1 @@\n-                                      XMMRegister vec1, XMMRegister vec2, bool is_char) {\n+                                      XMMRegister vec1, XMMRegister vec2, bool is_char, KRegister mask) {\n@@ -3584,2 +3585,2 @@\n-      evpcmpeqb(k7, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);\n-      kortestql(k7, k7);\n+      evpcmpeqb(mask, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);\n+      kortestql(mask, mask);\n@@ -3602,2 +3603,2 @@\n-      evpcmpeqb(k7, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);\n-      kortestql(k7, k7);\n+      evpcmpeqb(mask, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);\n+      kortestql(mask, mask);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":31,"deletions":30,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -345,1 +345,5 @@\n-  __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED);\n+  int flags = ShenandoahHeap::HAS_FORWARDED;\n+  if (!is_strong) {\n+    flags |= ShenandoahHeap::WEAK_ROOTS;\n+  }\n+  __ testb(gc_state, flags);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,0 @@\n-  \/\/ Restore registers\n@@ -399,0 +398,1 @@\n+  GrowableArray<KRegister>       _opmask_registers;\n@@ -455,0 +455,5 @@\n+  void opmask_register_save(KRegister reg) {\n+    _spill_offset -= 8;\n+    __ kmovql(Address(rsp, _spill_offset), reg);\n+  }\n+\n@@ -460,0 +465,5 @@\n+  void opmask_register_restore(KRegister reg) {\n+    __ kmovql(reg, Address(rsp, _spill_offset));\n+    _spill_offset += 8;\n+  }\n+\n@@ -482,0 +492,1 @@\n+    int opmask_spill_size = 0;\n@@ -495,0 +506,7 @@\n+      } else if (vm_reg->is_KRegister()) {\n+        \/\/ All opmask registers are caller saved, thus spill the ones\n+        \/\/ which are live.\n+        if (_opmask_registers.find(vm_reg->as_KRegister()) == -1) {\n+          _opmask_registers.append(vm_reg->as_KRegister());\n+          opmask_spill_size += 8;\n+        }\n@@ -525,1 +543,1 @@\n-    _spill_offset = _spill_size = align_up(xmm_spill_size + gp_spill_size + arg_spill_size, 16);\n+    _spill_offset = _spill_size = align_up(xmm_spill_size + gp_spill_size + opmask_spill_size + arg_spill_size, 16);\n@@ -532,0 +550,1 @@\n+      _opmask_registers(),\n@@ -581,0 +600,5 @@\n+\n+    \/\/ Save opmask registers\n+    for (int i = 0; i < _opmask_registers.length(); i++) {\n+      opmask_register_save(_opmask_registers.at(i));\n+    }\n@@ -584,0 +608,5 @@\n+    \/\/ Restore opmask registers\n+    for (int i = _opmask_registers.length() - 1; i >= 0; i--) {\n+      opmask_register_restore(_opmask_registers.at(i));\n+    }\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":32,"deletions":3,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,2 +160,2 @@\n-JRT_ENTRY(address, InterpreterRuntime::slow_signature_handler(JavaThread* thread, Method* method, intptr_t* from, intptr_t* to))\n-  methodHandle m(thread, (Method*)method);\n+JRT_ENTRY(address, InterpreterRuntime::slow_signature_handler(JavaThread* current, Method* method, intptr_t* from, intptr_t* to))\n+  methodHandle m(current, (Method*)method);\n","filename":"src\/hotspot\/cpu\/x86\/interpreterRT_x86_32.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"interpreter\/bytecodeHistogram.hpp\"\n@@ -2538,0 +2539,53 @@\n+void MacroAssembler::kmov(KRegister dst, Address src) {\n+  if (VM_Version::supports_avx512bw()) {\n+    kmovql(dst, src);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    kmovwl(dst, src);\n+  }\n+}\n+\n+void MacroAssembler::kmov(Address dst, KRegister src) {\n+  if (VM_Version::supports_avx512bw()) {\n+    kmovql(dst, src);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    kmovwl(dst, src);\n+  }\n+}\n+\n+void MacroAssembler::kmov(KRegister dst, KRegister src) {\n+  if (VM_Version::supports_avx512bw()) {\n+    kmovql(dst, src);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    kmovwl(dst, src);\n+  }\n+}\n+\n+void MacroAssembler::kmov(Register dst, KRegister src) {\n+  if (VM_Version::supports_avx512bw()) {\n+    kmovql(dst, src);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    kmovwl(dst, src);\n+  }\n+}\n+\n+void MacroAssembler::kmov(KRegister dst, Register src) {\n+  if (VM_Version::supports_avx512bw()) {\n+    kmovql(dst, src);\n+  } else {\n+    assert(VM_Version::supports_evex(), \"\");\n+    kmovwl(dst, src);\n+  }\n+}\n+\n+void MacroAssembler::kmovql(KRegister dst, AddressLiteral src, Register scratch_reg) {\n+  if (reachable(src)) {\n+    kmovql(dst, as_Address(src));\n+  } else {\n+    lea(scratch_reg, src);\n+    kmovql(dst, Address(scratch_reg, 0));\n+  }\n+}\n@@ -5335,1 +5389,1 @@\n-void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp) {\n+void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, KRegister mask) {\n@@ -5371,1 +5425,1 @@\n-    fill64_masked_avx(3, base, 0, xtmp, k2, cnt, val, true);\n+    fill64_masked_avx(3, base, 0, xtmp, mask, cnt, val, true);\n@@ -5390,1 +5444,1 @@\n-    fill32_masked_avx(3, base, 0, xtmp, k2, cnt, val);\n+    fill32_masked_avx(3, base, 0, xtmp, mask, cnt, val);\n@@ -5701,1 +5755,1 @@\n-void MacroAssembler::clear_mem(Register base, int cnt, Register rtmp, XMMRegister xtmp) {\n+void MacroAssembler::clear_mem(Register base, int cnt, Register rtmp, XMMRegister xtmp, KRegister mask) {\n@@ -5726,2 +5780,2 @@\n-        kmovwl(k2, rtmp);\n-        evmovdqu(T_LONG, k2, Address(base, disp), xtmp, Assembler::AVX_256bit);\n+        kmovwl(mask, rtmp);\n+        evmovdqu(T_LONG, mask, Address(base, disp), xtmp, Assembler::AVX_256bit);\n@@ -5735,2 +5789,2 @@\n-          kmovwl(k2, rtmp);\n-          evmovdqu(T_LONG, k2, Address(base, disp), xtmp, Assembler::AVX_512bit);\n+          kmovwl(mask, rtmp);\n+          evmovdqu(T_LONG, mask, Address(base, disp), xtmp, Assembler::AVX_512bit);\n@@ -5745,2 +5799,2 @@\n-          kmovwl(k2, rtmp);\n-          evmovdqu(T_LONG, k2, Address(base, disp), xtmp, Assembler::AVX_512bit);\n+          kmovwl(mask, rtmp);\n+          evmovdqu(T_LONG, mask, Address(base, disp), xtmp, Assembler::AVX_512bit);\n@@ -5755,2 +5809,2 @@\n-          kmovwl(k2, rtmp);\n-          evmovdqu(T_LONG, k2, Address(base, disp), xtmp, Assembler::AVX_512bit);\n+          kmovwl(mask, rtmp);\n+          evmovdqu(T_LONG, mask, Address(base, disp), xtmp, Assembler::AVX_512bit);\n@@ -5760,2 +5814,2 @@\n-          kmovwl(k2, rtmp);\n-          evmovdqu(T_LONG, k2, Address(base, disp + 32), xtmp, Assembler::AVX_256bit);\n+          kmovwl(mask, rtmp);\n+          evmovdqu(T_LONG, mask, Address(base, disp + 32), xtmp, Assembler::AVX_256bit);\n@@ -5771,1 +5825,2 @@\n-void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only) {\n+void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp,\n+                               bool is_large, bool word_copy_only, KRegister mask) {\n@@ -5808,1 +5863,1 @@\n-    xmm_clear_mem(base, cnt, val, xtmp);\n+    xmm_clear_mem(base, cnt, val, xtmp, mask);\n@@ -8440,1 +8495,1 @@\n-  Register tmp5, Register result) {\n+  Register tmp5, Register result, KRegister mask1, KRegister mask2) {\n@@ -8492,1 +8547,1 @@\n-    kmovdl(k3, result);\n+    kmovdl(mask2, result);\n@@ -8494,3 +8549,3 @@\n-    evmovdquw(tmp1Reg, k3, Address(src, 0), \/*merge*\/ false, Assembler::AVX_512bit);\n-    evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n-    ktestd(k2, k3);\n+    evmovdquw(tmp1Reg, mask2, Address(src, 0), \/*merge*\/ false, Assembler::AVX_512bit);\n+    evpcmpuw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    ktestd(mask1, mask2);\n@@ -8499,1 +8554,1 @@\n-    evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);\n+    evpmovwb(Address(dst, 0), mask2, tmp1Reg, Assembler::AVX_512bit);\n@@ -8520,2 +8575,2 @@\n-    evpcmpuw(k2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n-    kortestdl(k2, k2);\n+    evpcmpuw(mask1, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    kortestdl(mask1, mask1);\n@@ -8542,1 +8597,1 @@\n-    kmovdl(k3, result);\n+    kmovdl(mask2, result);\n@@ -8544,3 +8599,3 @@\n-    evmovdquw(tmp1Reg, k3, Address(src, 0), \/*merge*\/ false, Assembler::AVX_512bit);\n-    evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n-    ktestd(k2, k3);\n+    evmovdquw(tmp1Reg, mask2, Address(src, 0), \/*merge*\/ false, Assembler::AVX_512bit);\n+    evpcmpuw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    ktestd(mask1, mask2);\n@@ -8549,1 +8604,1 @@\n-    evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);\n+    evpmovwb(Address(dst, 0), mask2, tmp1Reg, Assembler::AVX_512bit);\n@@ -8649,1 +8704,1 @@\n-  XMMRegister tmp1, Register tmp2) {\n+  XMMRegister tmp1, Register tmp2, KRegister mask) {\n@@ -8702,3 +8757,3 @@\n-    kmovdl(k2, tmp3_aliased);\n-    evpmovzxbw(tmp1, k2, Address(src, 0), Assembler::AVX_512bit);\n-    evmovdquw(Address(dst, 0), k2, tmp1, \/*merge*\/ true, Assembler::AVX_512bit);\n+    kmovdl(mask, tmp3_aliased);\n+    evpmovzxbw(tmp1, mask, Address(src, 0), Assembler::AVX_512bit);\n+    evmovdquw(Address(dst, 0), mask, tmp1, \/*merge*\/ true, Assembler::AVX_512bit);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":88,"deletions":33,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -1151,0 +1151,17 @@\n+  void kmovwl(Address dst,  KRegister src) { Assembler::kmovwl(dst, src); }\n+  void kmovwl(KRegister dst, KRegister src) { Assembler::kmovwl(dst, src); }\n+\n+  void kmovql(KRegister dst, KRegister src) { Assembler::kmovql(dst, src); }\n+  void kmovql(KRegister dst, Register src) { Assembler::kmovql(dst, src); }\n+  void kmovql(Register dst, KRegister src) { Assembler::kmovql(dst, src); }\n+  void kmovql(KRegister dst, Address src) { Assembler::kmovql(dst, src); }\n+  void kmovql(Address  dst, KRegister src) { Assembler::kmovql(dst, src); }\n+  void kmovql(KRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);\n+\n+  \/\/ Safe move operation, lowers down to 16bit moves for targets supporting\n+  \/\/ AVX512F feature and 64bit moves for targets supporting AVX512BW feature.\n+  void kmov(Address  dst, KRegister src);\n+  void kmov(KRegister dst, Address src);\n+  void kmov(KRegister dst, KRegister src);\n+  void kmov(Register dst, KRegister src);\n+  void kmov(KRegister dst, Register src);\n@@ -1458,1 +1475,1 @@\n-      Assembler::vinserti32x4(dst, dst, src, imm8);\n+      Assembler::vinserti32x4(dst, nds, src, imm8);\n@@ -1469,1 +1486,1 @@\n-      Assembler::vinserti32x4(dst, dst, src, imm8);\n+      Assembler::vinserti32x4(dst, nds, src, imm8);\n@@ -1758,1 +1775,1 @@\n-  void clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only);\n+  void clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only, KRegister mask=knoreg);\n@@ -1761,1 +1778,1 @@\n-  void clear_mem(Register base, int cnt, Register rtmp, XMMRegister xtmp);\n+  void clear_mem(Register base, int cnt, Register rtmp, XMMRegister xtmp, KRegister mask=knoreg);\n@@ -1764,1 +1781,1 @@\n-  void xmm_clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp);\n+  void xmm_clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp, KRegister mask=knoreg);\n@@ -1877,1 +1894,2 @@\n-                           XMMRegister tmp4, Register tmp5, Register result);\n+                           XMMRegister tmp4, Register tmp5, Register result,\n+                           KRegister mask1 = knoreg, KRegister mask2 = knoreg);\n@@ -1881,1 +1899,1 @@\n-                          XMMRegister tmp1, Register tmp2);\n+                          XMMRegister tmp1, Register tmp2, KRegister mask = knoreg);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-                              oop mh,\n+                              oopDesc* mh,\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -134,0 +135,1 @@\n+  int opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n@@ -142,0 +144,1 @@\n+      additional_frame_words += opmask_state_bytes \/ wordSize;\n@@ -220,0 +223,1 @@\n+#ifdef COMPILER2\n@@ -232,0 +236,5 @@\n+      __ subptr(rsp, opmask_state_bytes);\n+      \/\/ Save opmask registers\n+      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+        __ kmov(Address(rsp, n*8), as_KRegister(n));\n+      }\n@@ -234,0 +243,4 @@\n+#else\n+  assert(!save_vectors, \"vectors are generated only by C2\");\n+#endif\n+\n@@ -254,0 +267,1 @@\n+\n@@ -278,0 +292,2 @@\n+  int opmask_state_bytes = 0;\n+  int additional_frame_bytes = 0;\n@@ -282,1 +298,0 @@\n-  int additional_frame_bytes = 0;\n@@ -292,0 +307,2 @@\n+      opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n+      additional_frame_bytes += opmask_state_bytes;\n@@ -325,1 +342,0 @@\n-\n@@ -328,0 +344,1 @@\n+      off = opmask_state_bytes;\n@@ -329,1 +346,4 @@\n-        __ vinsertf64x4_high(as_XMMRegister(n), Address(rsp, n*32));\n+        __ vinsertf64x4_high(as_XMMRegister(n), Address(rsp, n*32+off));\n+      }\n+      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+        __ kmov(as_KRegister(n), Address(rsp, n*8));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -94,0 +95,1 @@\n+#define XSAVE_AREA_OPMASK_BEGIN 1088\n@@ -99,0 +101,1 @@\n+#define DEF_OPMASK_OFFS(regnum)    opmask ## regnum ## _off = opmask_off + (regnum)*8\/BytesPerInt,     opmask ## regnum ## H_off\n@@ -110,0 +113,4 @@\n+    opmask_off         = xmm_off + (XSAVE_AREA_OPMASK_BEGIN - XSAVE_AREA_BEGIN)\/BytesPerInt,\n+    DEF_OPMASK_OFFS(0),\n+    DEF_OPMASK_OFFS(1),\n+    \/\/ 2..7 are implied in range usage\n@@ -217,0 +224,7 @@\n+#if COMPILER2_OR_JVMCI\n+      base_addr = XSAVE_AREA_OPMASK_BEGIN;\n+      off = 0;\n+      for(int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+        __ kmov(Address(rsp, base_addr+(off++*8)), as_KRegister(n));\n+      }\n+#endif\n@@ -226,0 +240,7 @@\n+#if COMPILER2_OR_JVMCI\n+      base_addr = XSAVE_AREA_OPMASK_BEGIN;\n+      off = 0;\n+      for(int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+        __ kmov(Address(rsp, base_addr+(off++*8)), as_KRegister(n));\n+      }\n+#endif\n@@ -385,0 +406,7 @@\n+#if COMPILER2_OR_JVMCI\n+      base_addr = XSAVE_AREA_OPMASK_BEGIN;\n+      off = 0;\n+      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+        __ kmov(as_KRegister(n), Address(rsp, base_addr+(off++*8)));\n+      }\n+#endif\n@@ -394,0 +422,7 @@\n+#if COMPILER2_OR_JVMCI\n+      base_addr = XSAVE_AREA_OPMASK_BEGIN;\n+      off = 0;\n+      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+        __ kmov(as_KRegister(n), Address(rsp, base_addr+(off++*8)));\n+      }\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-#include \"runtime\/arguments.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -631,0 +631,23 @@\n+\/\/ AVX3 Mask Registers.\n+reg_def K1   (SOC, SOC, Op_RegI,  1, k1->as_VMReg());\n+reg_def K1_H (SOC, SOC, Op_RegI,  1, k1->as_VMReg()->next());\n+\n+reg_def K2   (SOC, SOC, Op_RegI,  2, k2->as_VMReg());\n+reg_def K2_H (SOC, SOC, Op_RegI,  2, k2->as_VMReg()->next());\n+\n+reg_def K3   (SOC, SOC, Op_RegI,  3, k3->as_VMReg());\n+reg_def K3_H (SOC, SOC, Op_RegI,  3, k3->as_VMReg()->next());\n+\n+reg_def K4   (SOC, SOC, Op_RegI,  4, k4->as_VMReg());\n+reg_def K4_H (SOC, SOC, Op_RegI,  4, k4->as_VMReg()->next());\n+\n+reg_def K5   (SOC, SOC, Op_RegI,  5, k5->as_VMReg());\n+reg_def K5_H (SOC, SOC, Op_RegI,  5, k5->as_VMReg()->next());\n+\n+reg_def K6   (SOC, SOC, Op_RegI,  6, k6->as_VMReg());\n+reg_def K6_H (SOC, SOC, Op_RegI,  6, k6->as_VMReg()->next());\n+\n+reg_def K7   (SOC, SOC, Op_RegI,  7, k7->as_VMReg());\n+reg_def K7_H (SOC, SOC, Op_RegI,  7, k7->as_VMReg()->next());\n+\n+\n@@ -667,0 +690,24 @@\n+alloc_class chunk2(K7, K7_H,\n+                   K6, K6_H,\n+                   K5, K5_H,\n+                   K4, K4_H,\n+                   K3, K3_H,\n+                   K2, K2_H,\n+                   K1, K1_H);\n+\n+reg_class  vectmask_reg(K1, K1_H,\n+                        K2, K2_H,\n+                        K3, K3_H,\n+                        K4, K4_H,\n+                        K5, K5_H,\n+                        K6, K6_H,\n+                        K7, K7_H);\n+\n+reg_class vectmask_reg_K1(K1, K1_H);\n+reg_class vectmask_reg_K2(K2, K2_H);\n+reg_class vectmask_reg_K3(K3, K3_H);\n+reg_class vectmask_reg_K4(K4, K4_H);\n+reg_class vectmask_reg_K5(K5, K5_H);\n+reg_class vectmask_reg_K6(K6, K6_H);\n+reg_class vectmask_reg_K7(K7, K7_H);\n+\n@@ -668,1 +715,2 @@\n-alloc_class chunk2(RFLAGS);\n+alloc_class chunk3(RFLAGS);\n+\n@@ -1371,0 +1419,1 @@\n+  const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);\n@@ -1527,0 +1576,1 @@\n+\n@@ -1530,1 +1580,1 @@\n-      if (UseAVX < 3 || !VM_Version::supports_bmi2()) {\n+      if (!is_LP64  || UseAVX < 3 || !VM_Version::supports_bmi2()) {\n@@ -1561,0 +1611,1 @@\n+  const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);\n@@ -1611,1 +1662,1 @@\n-      if (!VM_Version::supports_avx512bw()) {\n+      if (!is_LP64 || !VM_Version::supports_avx512bw()) {\n@@ -1834,0 +1885,8 @@\n+const RegMask* Matcher::predicate_reg_mask(void) {\n+  return &_VECTMASK_REG_mask;\n+}\n+\n+const TypeVect* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n+  return new TypeVectMask(TypeInt::BOOL, length);\n+}\n+\n@@ -2567,3 +2626,7 @@\n-\n-instruct setMask(rRegI dst, rRegI src) %{\n-  predicate(Matcher::has_predicated_vectors());\n+\/\/ Existing partial implementation for post-loop multi-versioning computes\n+\/\/ the mask corresponding to tail loop in K1 opmask register. This may then be\n+\/\/ used for predicating instructions in loop body during last post-loop iteration.\n+\/\/ TODO: Remove hard-coded K1 usage while fixing existing post-loop\n+\/\/ multiversioning support.\n+instruct setMask(rRegI dst, rRegI src, kReg_K1 mask) %{\n+  predicate(PostLoopMultiversioning && Matcher::has_predicated_vectors());\n@@ -2574,1 +2637,1 @@\n-    __ setvectmask($dst$$Register, $src$$Register);\n+    __ setvectmask($dst$$Register, $src$$Register, $mask$$KRegister);\n@@ -3247,25 +3310,3 @@\n-instruct sqrtF_reg(regF dst, regF src) %{\n-  predicate(UseSSE>=1);\n-  match(Set dst (SqrtF src));\n-\n-  format %{ \"sqrtss  $dst, $src\" %}\n-  ins_cost(150);\n-  ins_encode %{\n-    __ sqrtss($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct sqrtF_mem(regF dst, memory src) %{\n-  predicate(UseSSE>=1);\n-  match(Set dst (SqrtF (LoadF src)));\n-\n-  format %{ \"sqrtss  $dst, $src\" %}\n-  ins_cost(150);\n-  ins_encode %{\n-    __ sqrtss($dst$$XMMRegister, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct sqrtF_imm(regF dst, immF con) %{\n+\/\/ sqrtss instruction needs destination register to be pre initialized for best performance\n+\/\/ Therefore only the instruct rule where the input is pre-loaded into dst register is defined below\n+instruct sqrtF_reg(regF dst) %{\n@@ -3273,28 +3314,2 @@\n-  match(Set dst (SqrtF con));\n-\n-  format %{ \"sqrtss  $dst, [$constantaddress]\\t# load from constant table: float=$con\" %}\n-  ins_cost(150);\n-  ins_encode %{\n-    __ sqrtss($dst$$XMMRegister, $constantaddress($con));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct sqrtD_reg(regD dst, regD src) %{\n-  predicate(UseSSE>=2);\n-  match(Set dst (SqrtD src));\n-\n-  format %{ \"sqrtsd  $dst, $src\" %}\n-  ins_cost(150);\n-  ins_encode %{\n-    __ sqrtsd($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct sqrtD_mem(regD dst, memory src) %{\n-  predicate(UseSSE>=2);\n-  match(Set dst (SqrtD (LoadD src)));\n-\n-  format %{ \"sqrtsd  $dst, $src\" %}\n-  ins_cost(150);\n+  match(Set dst (SqrtF dst));\n+  format %{ \"sqrtss  $dst, $dst\" %}\n@@ -3302,1 +3317,1 @@\n-    __ sqrtsd($dst$$XMMRegister, $src$$Address);\n+    __ sqrtss($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -3307,1 +3322,3 @@\n-instruct sqrtD_imm(regD dst, immD con) %{\n+\/\/ sqrtsd instruction needs destination register to be pre initialized for best performance\n+\/\/ Therefore only the instruct rule where the input is pre-loaded into dst register is defined below\n+instruct sqrtD_reg(regD dst) %{\n@@ -3309,3 +3326,2 @@\n-  match(Set dst (SqrtD con));\n-  format %{ \"sqrtsd  $dst, [$constantaddress]\\t# load from constant table: double=$con\" %}\n-  ins_cost(150);\n+  match(Set dst (SqrtD dst));\n+  format %{ \"sqrtsd  $dst, $dst\" %}\n@@ -3313,1 +3329,1 @@\n-    __ sqrtsd($dst$$XMMRegister, $constantaddress($con));\n+    __ sqrtsd($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -3614,1 +3630,1 @@\n-instruct evgather(vec dst, memory mem, vec idx, rRegP tmp) %{\n+instruct evgather(vec dst, memory mem, vec idx, rRegP tmp, kReg ktmp) %{\n@@ -3617,1 +3633,1 @@\n-  effect(TEMP dst, TEMP tmp);\n+  effect(TEMP dst, TEMP tmp, TEMP ktmp);\n@@ -3627,2 +3643,1 @@\n-    KRegister ktmp = k2;\n-    __ kmovwl(k2, ExternalAddress(vector_all_bits_set()), $tmp$$Register);\n+    __ kmovwl($ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), $tmp$$Register);\n@@ -3630,1 +3645,1 @@\n-    __ evgather(elem_bt, $dst$$XMMRegister, ktmp, $tmp$$Register, $idx$$XMMRegister, vlen_enc);\n+    __ evgather(elem_bt, $dst$$XMMRegister, $ktmp$$KRegister, $tmp$$Register, $idx$$XMMRegister, vlen_enc);\n@@ -3639,1 +3654,2 @@\n-instruct scatter(memory mem, vec src, vec idx, rRegP tmp) %{\n+instruct scatter(memory mem, vec src, vec idx, rRegP tmp, kReg ktmp) %{\n+  predicate(UseAVX > 2);\n@@ -3641,1 +3657,1 @@\n-  effect(TEMP tmp);\n+  effect(TEMP tmp, TEMP ktmp);\n@@ -3644,2 +3660,0 @@\n-    assert(UseAVX > 2, \"sanity\");\n-\n@@ -3652,2 +3666,1 @@\n-    KRegister ktmp = k2;\n-    __ kmovwl(k2, ExternalAddress(vector_all_bits_set()), $tmp$$Register);\n+    __ kmovwl($ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), $tmp$$Register);\n@@ -3655,1 +3668,1 @@\n-    __ evscatter(elem_bt, $tmp$$Register, $idx$$XMMRegister, ktmp, $src$$XMMRegister, vlen_enc);\n+    __ evscatter(elem_bt, $tmp$$Register, $idx$$XMMRegister, $ktmp$$KRegister, $src$$XMMRegister, vlen_enc);\n@@ -5756,1 +5769,1 @@\n-instruct evminmaxFP_reg_eavx(vec dst, vec a, vec b, vec atmp, vec btmp) %{\n+instruct evminmaxFP_reg_eavx(vec dst, vec a, vec b, vec atmp, vec btmp, kReg ktmp) %{\n@@ -5761,1 +5774,1 @@\n-  effect(TEMP dst, USE a, USE b, TEMP atmp, TEMP btmp);\n+  effect(TEMP dst, USE a, USE b, TEMP atmp, TEMP btmp, TEMP ktmp);\n@@ -5770,1 +5783,0 @@\n-    KRegister ktmp = k1;\n@@ -5773,1 +5785,1 @@\n-                   ktmp, $atmp$$XMMRegister , $btmp$$XMMRegister, vlen_enc);\n+                   $ktmp$$KRegister, $atmp$$XMMRegister , $btmp$$XMMRegister, vlen_enc);\n@@ -6838,1 +6850,1 @@\n-instruct evcmpFD(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch) %{\n+instruct evcmpFD(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n@@ -6842,1 +6854,1 @@\n-  effect(TEMP scratch);\n+  effect(TEMP scratch, TEMP ktmp);\n@@ -6847,1 +6859,0 @@\n-    KRegister ktmp = k2; \/\/ Use a hardcoded temp due to no k register allocation.\n@@ -6850,2 +6861,2 @@\n-      __ evcmpps(ktmp, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n-      __ evmovdqul($dst$$XMMRegister, ktmp, ExternalAddress(vector_all_bits_set()), false, vlen_enc, $scratch$$Register);\n+      __ evcmpps($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+      __ evmovdqul($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), false, vlen_enc, $scratch$$Register);\n@@ -6853,2 +6864,2 @@\n-      __ evcmppd(ktmp, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n-      __ evmovdquq($dst$$XMMRegister, ktmp, ExternalAddress(vector_all_bits_set()), false, vlen_enc, $scratch$$Register);\n+      __ evcmppd($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+      __ evmovdquq($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), false, vlen_enc, $scratch$$Register);\n@@ -6876,1 +6887,1 @@\n-instruct evcmp(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch) %{\n+instruct evcmp(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n@@ -6880,1 +6891,1 @@\n-  effect(TEMP scratch);\n+  effect(TEMP scratch, TEMP ktmp);\n@@ -6887,1 +6898,0 @@\n-    KRegister ktmp = k2; \/\/ Use a hardcoded temp due to no k register allocation.\n@@ -6894,2 +6904,2 @@\n-        __ evpcmpb(ktmp, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n-        __ evmovdqub($dst$$XMMRegister, ktmp, ExternalAddress(vector_all_bits_set()), merge, vlen_enc, $scratch$$Register);\n+        __ evpcmpb($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evmovdqub($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), merge, vlen_enc, $scratch$$Register);\n@@ -6899,2 +6909,2 @@\n-        __ evpcmpw(ktmp, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n-        __ evmovdquw($dst$$XMMRegister, ktmp, ExternalAddress(vector_all_bits_set()), merge, vlen_enc, $scratch$$Register);\n+        __ evpcmpw($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evmovdquw($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), merge, vlen_enc, $scratch$$Register);\n@@ -6904,2 +6914,2 @@\n-        __ evpcmpd(ktmp, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n-        __ evmovdqul($dst$$XMMRegister, ktmp, ExternalAddress(vector_all_bits_set()), merge, vlen_enc, $scratch$$Register);\n+        __ evpcmpd($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evmovdqul($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), merge, vlen_enc, $scratch$$Register);\n@@ -6909,2 +6919,2 @@\n-        __ evpcmpq(ktmp, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n-        __ evmovdquq($dst$$XMMRegister, ktmp, ExternalAddress(vector_all_bits_set()), merge, vlen_enc, $scratch$$Register);\n+        __ evpcmpq($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evmovdquq($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), merge, vlen_enc, $scratch$$Register);\n@@ -7088,1 +7098,1 @@\n-instruct evblendvp64(vec dst, vec src1, vec src2, vec mask, rRegP scratch) %{\n+instruct evblendvp64(vec dst, vec src1, vec src2, vec mask, rRegP scratch, kReg ktmp) %{\n@@ -7092,1 +7102,1 @@\n-  effect(TEMP scratch);\n+  effect(TEMP scratch, TEMP ktmp);\n@@ -7096,3 +7106,2 @@\n-     KRegister ktmp = k2;\n-    __ evpcmp(elem_bt, ktmp, k0, $mask$$XMMRegister, ExternalAddress(vector_all_bits_set()), Assembler::eq, vlen_enc, $scratch$$Register);\n-    __ evpblend(elem_bt, $dst$$XMMRegister, ktmp, $src1$$XMMRegister, $src2$$XMMRegister, true, vlen_enc);\n+    __ evpcmp(elem_bt, $ktmp$$KRegister, k0, $mask$$XMMRegister, ExternalAddress(vector_all_bits_set()), Assembler::eq, vlen_enc, $scratch$$Register);\n+    __ evpblend(elem_bt, $dst$$XMMRegister, $ktmp$$KRegister, $src1$$XMMRegister, $src2$$XMMRegister, true, vlen_enc);\n@@ -7241,0 +7250,1 @@\n+            vector_length_in_bytes(n->in(1)) <  64 &&\n@@ -7247,1 +7257,16 @@\n-    __ vectortest(BoolTest::overflow, vlen, $src1$$XMMRegister, $src2$$XMMRegister); \n+    __ vectortest(BoolTest::overflow, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n+    __ setb(Assembler::carrySet, $dst$$Register);\n+    __ movzbl($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vptest_alltrue_evex(rRegI dst, legVec src1, legVec src2, kReg ktmp, rFlagsReg cr) %{\n+  predicate(vector_length_in_bytes(n->in(1)) == 64 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);\n+  match(Set dst (VectorTest src1 src2 ));\n+  effect(KILL cr, TEMP ktmp);\n+  format %{ \"vector_test $dst,$src1, $src2\\t! using $cr as TEMP\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    __ vectortest(BoolTest::overflow, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, $ktmp$$KRegister);\n@@ -7272,0 +7297,1 @@\n+            vector_length_in_bytes(n->in(1)) < 64  &&\n@@ -7278,1 +7304,16 @@\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister);\n+    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n+    __ setb(Assembler::notZero, $dst$$Register);\n+    __ movzbl($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vptest_anytrue_evex(rRegI dst, legVec src1, legVec src2, kReg ktmp, rFlagsReg cr) %{\n+  predicate(vector_length_in_bytes(n->in(1)) == 64 &&\n+            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);\n+  match(Set dst (VectorTest src1 src2 ));\n+  effect(KILL cr, TEMP ktmp);\n+  format %{ \"vector_test_any_true $dst,$src1,$src2\\t! using $cr as TEMP\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, $ktmp$$KRegister);\n@@ -7301,0 +7342,1 @@\n+            vector_length_in_bytes(n->in(1)->in(1)) <  64 &&\n@@ -7306,1 +7348,14 @@\n-    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister);\n+    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct cmpvptest_anytrue_evex(rFlagsReg cr, legVec src1, legVec src2, immI_0 zero, kReg ktmp) %{\n+  predicate(vector_length_in_bytes(n->in(1)->in(1)) == 64 &&\n+            static_cast<const VectorTestNode*>(n->in(1))->get_predicate() == BoolTest::ne);\n+  match(Set cr (CmpI (VectorTest src1 src2) zero));\n+  effect(TEMP ktmp);\n+  format %{ \"cmp_vector_test_any_true $src1,$src2\\t!\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    __ vectortest(BoolTest::ne, vlen, $src1$$XMMRegister, $src2$$XMMRegister, xnoreg, xnoreg, $ktmp$$KRegister);\n@@ -7959,2 +8014,1 @@\n-\n-instruct vmasked_load64(vec dst, memory mem, rRegL mask) %{\n+instruct vmasked_load64(vec dst, memory mem, kReg mask) %{\n@@ -7966,2 +8020,1 @@\n-    __ kmovql(k2, $mask$$Register);\n-    __ evmovdqu(elmType, k2, $dst$$XMMRegister, $mem$$Address, vector_len);\n+    __ evmovdqu(elmType, $mask$$KRegister, $dst$$XMMRegister, $mem$$Address, vector_len);\n@@ -7972,1 +8025,1 @@\n-instruct vmask_gen(rRegL dst, rRegL len, rRegL tempLen) %{\n+instruct vmask_gen(kReg dst, rRegL len, rRegL temp) %{\n@@ -7974,2 +8027,2 @@\n-  effect(TEMP_DEF dst, TEMP tempLen);\n-  format %{ \"vector_mask_gen $len \\t! vector mask generator\" %}\n+  effect(TEMP temp);\n+  format %{ \"vector_mask_gen32 $dst, $len \\t! vector mask generator\" %}\n@@ -7977,1 +8030,1 @@\n-    __ genmask($dst$$Register, $len$$Register, $tempLen$$Register);\n+    __ genmask($dst$$KRegister, $len$$Register, $temp$$Register);\n@@ -7982,1 +8035,1 @@\n-instruct vmask_gen_imm(rRegL dst, immL len) %{\n+instruct vmask_gen_imm(kReg dst, immL len, rRegL temp) %{\n@@ -7985,0 +8038,1 @@\n+  effect(TEMP temp);\n@@ -7986,1 +8040,2 @@\n-    __ mov64($dst$$Register, (0xFFFFFFFFFFFFFFFFUL >> (64 -$len$$constant)));\n+    __ mov64($temp$$Register, (0xFFFFFFFFFFFFFFFFUL >> (64 -$len$$constant)));\n+    __ kmovql($dst$$KRegister, $temp$$Register);\n@@ -7991,1 +8046,1 @@\n-instruct vmasked_store64(memory mem, vec src, rRegL mask) %{\n+instruct vmasked_store64(memory mem, vec src, kReg mask) %{\n@@ -7998,2 +8053,1 @@\n-    __ kmovql(k2, $mask$$Register);\n-    __ evmovdqu(elmType, k2, $mem$$Address, $src$$XMMRegister, vector_len);\n+    __ evmovdqu(elmType, $mask$$KRegister, $mem$$Address, $src$$XMMRegister, vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":175,"deletions":121,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -263,0 +263,12 @@\n+void reg_mask_init() {\n+  if (Matcher::has_predicated_vectors()) {\n+    \/\/ Post-loop multi-versioning expects mask to be present in K1 register, till the time\n+    \/\/ its fixed, RA should not be allocting K1 register, this shall prevent any accidental\n+    \/\/ curruption of value held in K1 register.\n+    if (PostLoopMultiversioning) {\n+      const_cast<RegMask*>(&_VECTMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k1->as_VMReg()));\n+      const_cast<RegMask*>(&_VECTMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k1->as_VMReg()->next()));\n+    }\n+  }\n+}\n+\n@@ -731,1 +743,1 @@\n-enum RC { rc_bad, rc_int, rc_float, rc_xmm, rc_stack };\n+enum RC { rc_bad, rc_int, rc_kreg, rc_float, rc_xmm, rc_stack };\n@@ -1050,1 +1062,1 @@\n-  if (bottom_type()->isa_vect() != NULL) {\n+  if (bottom_type()->isa_vect() != NULL && bottom_type()->isa_vectmask() == NULL) {\n@@ -1103,1 +1115,1 @@\n-  if( dst_first_rc == rc_int && src_first_rc == rc_stack )\n+  if( src_first_rc == rc_stack && dst_first_rc == rc_int )\n@@ -1192,1 +1204,1 @@\n-    return impl_x_helper(cbuf,do_size,false,ra_->reg2offset(dst_first),src_first, src_second, size, st);\n+    return impl_x_helper(cbuf,do_size,false,ra_->reg2offset(dst_first), src_first, src_second, size, st);\n@@ -1196,1 +1208,1 @@\n-  if( dst_first_rc == rc_xmm && src_first_rc == rc_stack ) {\n+  if( src_first_rc == rc_stack && dst_first_rc == rc_xmm ) {\n@@ -1201,1 +1213,1 @@\n-  if( dst_first_rc == rc_xmm && src_first_rc == rc_float ) {\n+  if( src_first_rc == rc_float && dst_first_rc == rc_xmm ) {\n@@ -1257,0 +1269,36 @@\n+  \/\/ AVX-512 opmask specific spilling.\n+  if (src_first_rc == rc_stack && dst_first_rc == rc_kreg) {\n+    assert((src_first & 1) == 0 && src_first + 1 == src_second, \"invalid register pair\");\n+    assert((dst_first & 1) == 0 && dst_first + 1 == dst_second, \"invalid register pair\");\n+    MacroAssembler _masm(cbuf);\n+    int offset = ra_->reg2offset(src_first);\n+    __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n+    return 0;\n+  }\n+\n+  if (src_first_rc == rc_kreg && dst_first_rc == rc_stack) {\n+    assert((src_first & 1) == 0 && src_first + 1 == src_second, \"invalid register pair\");\n+    assert((dst_first & 1) == 0 && dst_first + 1 == dst_second, \"invalid register pair\");\n+    MacroAssembler _masm(cbuf);\n+    int offset = ra_->reg2offset(dst_first);\n+    __ kmov(Address(rsp, offset), as_KRegister(Matcher::_regEncode[src_first]));\n+    return 0;\n+  }\n+\n+  if (src_first_rc == rc_kreg && dst_first_rc == rc_int) {\n+    Unimplemented();\n+    return 0;\n+  }\n+\n+  if (src_first_rc == rc_int && dst_first_rc == rc_kreg) {\n+    Unimplemented();\n+    return 0;\n+  }\n+\n+  if (src_first_rc == rc_kreg && dst_first_rc == rc_kreg) {\n+    assert((src_first & 1) == 0 && src_first + 1 == src_second, \"invalid register pair\");\n+    assert((dst_first & 1) == 0 && dst_first + 1 == dst_second, \"invalid register pair\");\n+    MacroAssembler _masm(cbuf);\n+    __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), as_KRegister(Matcher::_regEncode[src_first]));\n+    return 0;\n+  }\n@@ -3574,0 +3622,66 @@\n+operand kReg()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+operand kReg_K1()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K1));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+operand kReg_K2()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K2));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Special Registers\n+operand kReg_K3()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K3));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+operand kReg_K4()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K4));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+operand kReg_K5()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K5));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+operand kReg_K6()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K6));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Special Registers\n+operand kReg_K7()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K7));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n@@ -11410,0 +11524,1 @@\n+\/\/ Small ClearArray non-AVX512.\n@@ -11411,1 +11526,2 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() && !n->in(2)->bottom_type()->is_int()->is_con());\n+  predicate(!((ClearArrayNode*)n)->is_large() &&\n+              (UseAVX <= 2 || !VM_Version::supports_avx512vlbw()));\n@@ -11464,1 +11580,1 @@\n-                 $tmp$$XMMRegister, false);\n+                 $tmp$$XMMRegister, false, knoreg);\n@@ -11469,0 +11585,63 @@\n+\/\/ Small ClearArray AVX512 non-constant length.\n+instruct rep_stos_evex(eCXRegI cnt, eDIRegP base, regD tmp, kReg ktmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{\n+  predicate(!((ClearArrayNode*)n)->is_large() &&\n+               UseAVX > 2 && VM_Version::supports_avx512vlbw() &&\n+               !n->in(2)->bottom_type()->is_int()->is_con());\n+  match(Set dummy (ClearArray cnt base));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, KILL zero, KILL cr);\n+\n+  format %{ $$template\n+    $$emit$$\"XOR    EAX,EAX\\t# ClearArray:\\n\\t\"\n+    $$emit$$\"CMP    InitArrayShortSize,rcx\\n\\t\"\n+    $$emit$$\"JG     LARGE\\n\\t\"\n+    $$emit$$\"SHL    ECX, 1\\n\\t\"\n+    $$emit$$\"DEC    ECX\\n\\t\"\n+    $$emit$$\"JS     DONE\\t# Zero length\\n\\t\"\n+    $$emit$$\"MOV    EAX,(EDI,ECX,4)\\t# LOOP\\n\\t\"\n+    $$emit$$\"DEC    ECX\\n\\t\"\n+    $$emit$$\"JGE    LOOP\\n\\t\"\n+    $$emit$$\"JMP    DONE\\n\\t\"\n+    $$emit$$\"# LARGE:\\n\\t\"\n+    if (UseFastStosb) {\n+       $$emit$$\"SHL    ECX,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"REP STOSB\\t# store EAX into [EDI++] while ECX--\\n\\t\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"MOV     RDI,RAX\\n\\t\"\n+       $$emit$$\"VPXOR    YMM0,YMM0,YMM0\\n\\t\"\n+       $$emit$$\"JMPQ    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"VMOVDQU YMM0,(RAX)\\n\\t\"\n+       $$emit$$\"VMOVDQU YMM0,0x20(RAX)\\n\\t\"\n+       $$emit$$\"ADD     0x40,RAX\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"SUB     0x8,RCX\\n\\t\"\n+       $$emit$$\"JGE     L_loop\\n\\t\"\n+       $$emit$$\"ADD     0x4,RCX\\n\\t\"\n+       $$emit$$\"JL      L_tail\\n\\t\"\n+       $$emit$$\"VMOVDQU YMM0,(RAX)\\n\\t\"\n+       $$emit$$\"ADD     0x20,RAX\\n\\t\"\n+       $$emit$$\"SUB     0x4,RCX\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"ADD     0x4,RCX\\n\\t\"\n+       $$emit$$\"JLE     L_end\\n\\t\"\n+       $$emit$$\"DEC     RCX\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"VMOVQ   XMM0,(RAX)\\n\\t\"\n+       $$emit$$\"ADD     0x8,RAX\\n\\t\"\n+       $$emit$$\"DEC     RCX\\n\\t\"\n+       $$emit$$\"JGE     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"SHL    ECX,1\\t# Convert doublewords to words\\n\\t\"\n+       $$emit$$\"REP STOS\\t# store EAX into [EDI++] while ECX--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n+                 $tmp$$XMMRegister, false, $ktmp$$KRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ Large ClearArray non-AVX512.\n@@ -11470,1 +11649,1 @@\n-  predicate(((ClearArrayNode*)n)->is_large());\n+  predicate(UseAVX <= 2 && ((ClearArrayNode*)n)->is_large());\n@@ -11513,1 +11692,51 @@\n-                 $tmp$$XMMRegister, true);\n+                 $tmp$$XMMRegister, true, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ Large ClearArray AVX512.\n+instruct rep_stos_large_evex(eCXRegI cnt, eDIRegP base, regD tmp, kReg ktmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{\n+  predicate(UseAVX > 2 && ((ClearArrayNode*)n)->is_large());\n+  match(Set dummy (ClearArray cnt base));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, KILL zero, KILL cr);\n+  format %{ $$template\n+    if (UseFastStosb) {\n+       $$emit$$\"XOR    EAX,EAX\\t# ClearArray:\\n\\t\"\n+       $$emit$$\"SHL    ECX,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"REP STOSB\\t# store EAX into [EDI++] while ECX--\\n\\t\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"MOV     RDI,RAX\\t# ClearArray:\\n\\t\"\n+       $$emit$$\"VPXOR   YMM0,YMM0,YMM0\\n\\t\"\n+       $$emit$$\"JMPQ    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"VMOVDQU YMM0,(RAX)\\n\\t\"\n+       $$emit$$\"VMOVDQU YMM0,0x20(RAX)\\n\\t\"\n+       $$emit$$\"ADD     0x40,RAX\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"SUB     0x8,RCX\\n\\t\"\n+       $$emit$$\"JGE     L_loop\\n\\t\"\n+       $$emit$$\"ADD     0x4,RCX\\n\\t\"\n+       $$emit$$\"JL      L_tail\\n\\t\"\n+       $$emit$$\"VMOVDQU YMM0,(RAX)\\n\\t\"\n+       $$emit$$\"ADD     0x20,RAX\\n\\t\"\n+       $$emit$$\"SUB     0x4,RCX\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"ADD     0x4,RCX\\n\\t\"\n+       $$emit$$\"JLE     L_end\\n\\t\"\n+       $$emit$$\"DEC     RCX\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"VMOVQ   XMM0,(RAX)\\n\\t\"\n+       $$emit$$\"ADD     0x8,RAX\\n\\t\"\n+       $$emit$$\"DEC     RCX\\n\\t\"\n+       $$emit$$\"JGE     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"XOR    EAX,EAX\\t# ClearArray:\\n\\t\"\n+       $$emit$$\"SHL    ECX,1\\t# Convert doublewords to words\\n\\t\"\n+       $$emit$$\"REP STOS\\t# store EAX into [EDI++] while ECX--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n+                 $tmp$$XMMRegister, true, $ktmp$$KRegister);\n@@ -11518,1 +11747,2 @@\n-instruct rep_stos_im(immI cnt, eRegP base, regD tmp, rRegI zero, Universe dummy, eFlagsReg cr)\n+\/\/ Small ClearArray AVX512 constant length.\n+instruct rep_stos_im(immI cnt, kReg ktmp, eRegP base, regD tmp, rRegI zero, Universe dummy, eFlagsReg cr)\n@@ -11520,1 +11750,3 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() && n->in(2)->bottom_type()->is_int()->is_con());\n+  predicate(!((ClearArrayNode*)n)->is_large() &&\n+               (UseAVX > 2 && VM_Version::supports_avx512vlbw() &&\n+                 n->in(2)->bottom_type()->is_int()->is_con()));\n@@ -11522,1 +11754,1 @@\n-  effect(TEMP tmp, TEMP zero, KILL cr);\n+  effect(TEMP tmp, TEMP zero, TEMP ktmp, KILL cr);\n@@ -11525,1 +11757,1 @@\n-   __ clear_mem($base$$Register, $cnt$$constant, $zero$$Register, $tmp$$XMMRegister);\n+   __ clear_mem($base$$Register, $cnt$$constant, $zero$$Register, $tmp$$XMMRegister, $ktmp$$KRegister);\n@@ -11532,1 +11764,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -11540,1 +11772,16 @@\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::LL);\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::LL, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareL_evex(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,\n+                              eAXRegI result, regD tmp1, kReg ktmp, eFlagsReg cr) %{\n+  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::LL, $ktmp$$KRegister);\n@@ -11547,1 +11794,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -11555,1 +11802,16 @@\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::UU);\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::UU, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareU_evex(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,\n+                              eAXRegI result, regD tmp1, kReg ktmp, eFlagsReg cr) %{\n+  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare char[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::UU, $ktmp$$KRegister);\n@@ -11562,1 +11824,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n@@ -11570,1 +11832,16 @@\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::LU);\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::LU, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareLU_evex(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,\n+                               eAXRegI result, regD tmp1, kReg ktmp, eFlagsReg cr) %{\n+  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::LU, $ktmp$$KRegister);\n@@ -11577,1 +11854,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n@@ -11585,1 +11862,16 @@\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::UL);\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::UL, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareUL_evex(eSIRegP str1, eDXRegI cnt1, eDIRegP str2, eCXRegI cnt2,\n+                               eAXRegI result, regD tmp1, kReg ktmp, eFlagsReg cr) %{\n+  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str2$$Register, $str1$$Register,\n+                      $cnt2$$Register, $cnt1$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::UL, $ktmp$$KRegister);\n@@ -11593,0 +11885,1 @@\n+  predicate(UseAVX <= 2);\n@@ -11600,1 +11893,1 @@\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/);\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, knoreg);\n@@ -11606,0 +11899,17 @@\n+instruct string_equals_evex(eDIRegP str1, eSIRegP str2, eCXRegI cnt, eAXRegI result,\n+                            regD tmp1, regD tmp2, kReg ktmp, eBXRegI tmp3, eFlagsReg cr) %{\n+  predicate(UseAVX > 2);\n+  match(Set result (StrEquals (Binary str1 str2) cnt));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);\n+\n+  format %{ \"String Equals $str1,$str2,$cnt -> $result    \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  ins_encode %{\n+    __ arrays_equals(false, $str1$$Register, $str2$$Register,\n+                     $cnt$$Register, $result$$Register, $tmp3$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, $ktmp$$KRegister);\n+  %}\n+\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n@@ -11769,1 +12079,1 @@\n-  predicate(((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate(UseAVX <= 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -11778,1 +12088,18 @@\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/);\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct array_equalsB_evex(eDIRegP ary1, eSIRegP ary2, eAXRegI result,\n+                       regD tmp1, regD tmp2, kReg ktmp, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)\n+%{\n+  predicate(UseAVX > 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  match(Set result (AryEq ary1 ary2));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);\n+  \/\/ins_cost(300);\n+\n+  format %{ \"Array Equals byte[] $ary1,$ary2 -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3, $tmp4\" %}\n+  ins_encode %{\n+    __ arrays_equals(true, $ary1$$Register, $ary2$$Register,\n+                     $tmp3$$Register, $result$$Register, $tmp4$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, $ktmp$$KRegister);\n@@ -11786,1 +12113,1 @@\n-  predicate(((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(UseAVX <= 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -11795,1 +12122,18 @@\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, true \/* char *\/);\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, true \/* char *\/, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct array_equalsC_evex(eDIRegP ary1, eSIRegP ary2, eAXRegI result,\n+                            regD tmp1, regD tmp2, kReg ktmp, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)\n+%{\n+  predicate(UseAVX > 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  match(Set result (AryEq ary1 ary2));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);\n+  \/\/ins_cost(300);\n+\n+  format %{ \"Array Equals char[] $ary1,$ary2 -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3, $tmp4\" %}\n+  ins_encode %{\n+    __ arrays_equals(true, $ary1$$Register, $ary2$$Register,\n+                     $tmp3$$Register, $result$$Register, $tmp4$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, true \/* char *\/, $ktmp$$KRegister);\n@@ -11803,0 +12147,1 @@\n+  predicate(UseAVX <= 2);\n@@ -11810,1 +12155,17 @@\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister);\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct has_negatives_evex(eSIRegP ary1, eCXRegI len, eAXRegI result,\n+                           regD tmp1, regD tmp2, kReg ktmp1, kReg ktmp2, eBXRegI tmp3, eFlagsReg cr)\n+%{\n+  predicate(UseAVX > 2);\n+  match(Set result (HasNegatives ary1 len));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp1, TEMP ktmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);\n+\n+  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  ins_encode %{\n+    __ has_negatives($ary1$$Register, $len$$Register,\n+                     $result$$Register, $tmp3$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n@@ -11815,0 +12176,1 @@\n+\n@@ -11816,2 +12178,3 @@\n-instruct string_compress(eSIRegP src, eDIRegP dst, eDXRegI len, regD tmp1, regD tmp2, regD tmp3, regD tmp4,\n-                         eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{\n+instruct string_compress(eSIRegP src, eDIRegP dst, eDXRegI len, regD tmp1, regD tmp2,\n+                         regD tmp3, regD tmp4, eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{\n+  predicate(UseAVX <= 2);\n@@ -11825,1 +12188,18 @@\n-                           $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);\n+                           $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register,\n+                           knoreg, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compress_evex(eSIRegP src, eDIRegP dst, eDXRegI len, regD tmp1, regD tmp2,\n+                              regD tmp3, regD tmp4, kReg ktmp1, kReg ktmp2, eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{\n+  predicate(UseAVX > 2);\n+  match(Set result (StrCompressedCopy src (Binary dst len)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ktmp1, TEMP ktmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);\n+\n+  format %{ \"String Compress $src,$dst -> $result    \/\/ KILL RAX, RCX, RDX\" %}\n+  ins_encode %{\n+    __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,\n+                           $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,\n+                           $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register,\n+                           $ktmp1$$KRegister, $ktmp2$$KRegister);\n@@ -11833,0 +12213,1 @@\n+  predicate(UseAVX <= 2);\n@@ -11839,1 +12220,15 @@\n-                          $tmp1$$XMMRegister, $tmp2$$Register);\n+                          $tmp1$$XMMRegister, $tmp2$$Register, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_inflate_evex(Universe dummy, eSIRegP src, eDIRegP dst, eDXRegI len,\n+                             regD tmp1, kReg ktmp, eCXRegI tmp2, eFlagsReg cr) %{\n+  predicate(UseAVX > 2);\n+  match(Set dummy (StrInflatedCopy src (Binary dst len)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);\n+\n+  format %{ \"String Inflate $src,$dst    \/\/ KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,\n+                          $tmp1$$XMMRegister, $tmp2$$Register, $ktmp$$KRegister);\n@@ -12267,2 +12662,4 @@\n-instruct jmpLoopEnd_and_restoreMask(cmpOp cop, eFlagsReg cr, label labl) %{\n-  predicate(n->has_vector_mask_set());\n+\/\/ Bounded mask operand used in following patten is needed for\n+\/\/ post-loop multiversioning.\n+instruct jmpLoopEnd_and_restoreMask(cmpOp cop, kReg_K1 ktmp, eFlagsReg cr, label labl) %{\n+  predicate(PostLoopMultiversioning && n->has_vector_mask_set());\n@@ -12270,1 +12667,1 @@\n-  effect(USE labl);\n+  effect(USE labl, TEMP ktmp);\n@@ -12279,1 +12676,1 @@\n-    __ restorevectmask();\n+    __ restorevectmask($ktmp$$KRegister);\n@@ -12285,2 +12682,4 @@\n-instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, eFlagsRegU cmp, label labl) %{\n-  predicate(n->has_vector_mask_set());\n+\/\/ Bounded mask operand used in following patten is needed for\n+\/\/ post-loop multiversioning.\n+instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, kReg_K1 ktmp, eFlagsRegU cmp, label labl) %{\n+  predicate(PostLoopMultiversioning && n->has_vector_mask_set());\n@@ -12288,1 +12687,1 @@\n-  effect(USE labl);\n+  effect(USE labl, TEMP ktmp);\n@@ -12297,1 +12696,1 @@\n-    __ restorevectmask();\n+    __ restorevectmask($ktmp$$KRegister);\n@@ -12302,2 +12701,4 @@\n-instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{\n-  predicate(n->has_vector_mask_set());\n+\/\/ Bounded mask operand used in following patten is needed for\n+\/\/ post-loop multiversioning.\n+instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, kReg_K1 ktmp, eFlagsRegUCF cmp, label labl) %{\n+  predicate(PostLoopMultiversioning && n->has_vector_mask_set());\n@@ -12305,1 +12706,1 @@\n-  effect(USE labl);\n+  effect(USE labl, TEMP ktmp);\n@@ -12314,1 +12715,1 @@\n-    __ restorevectmask();\n+    __ restorevectmask($ktmp$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":446,"deletions":45,"binary":false,"changes":491,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -427,0 +427,10 @@\n+\n+  if (Matcher::has_predicated_vectors()) {\n+    \/\/ Post-loop multi-versioning expects mask to be present in K1 register, till the time\n+    \/\/ its fixed, RA should not be allocting K1 register, this shall prevent any accidental\n+    \/\/ curruption of value held in K1 register.\n+    if (PostLoopMultiversioning) {\n+      const_cast<RegMask*>(&_VECTMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k1->as_VMReg()));\n+      const_cast<RegMask*>(&_VECTMASK_REG_mask)->Remove(OptoReg::as_OptoReg(k1->as_VMReg()->next()));\n+    }\n+  }\n@@ -993,0 +1003,1 @@\n+  rc_kreg,\n@@ -1007,0 +1018,2 @@\n+  if (r->is_KRegister()) return rc_kreg;\n+\n@@ -1120,1 +1133,1 @@\n-  if (bottom_type()->isa_vect() != NULL) {\n+  if (bottom_type()->isa_vect() != NULL && bottom_type()->isa_vectmask() == NULL) {\n@@ -1250,0 +1263,18 @@\n+#endif\n+        }\n+      }\n+      return 0;\n+    } else if (dst_first_rc == rc_kreg) {\n+      \/\/ mem -> kreg\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        int offset = ra_->reg2offset(src_first);\n+        if (cbuf) {\n+          MacroAssembler _masm(cbuf);\n+          __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"kmovq   %s, [rsp + #%d]\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     offset);\n@@ -1355,0 +1386,17 @@\n+    } else if (dst_first_rc == rc_kreg) {\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        if (cbuf) {\n+          MacroAssembler _masm(cbuf);\n+          __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));\n+  #ifndef PRODUCT\n+        } else {\n+           st->print(\"kmovq   %s, %s\\t# spill\",\n+                       Matcher::regName[dst_first],\n+                       Matcher::regName[src_first]);\n+  #endif\n+        }\n+      }\n+      Unimplemented();\n+      return 0;\n@@ -1455,0 +1503,59 @@\n+    } else if (dst_first_rc == rc_kreg) {\n+      assert(false, \"Illegal spilling\");\n+      return 0;\n+    }\n+  } else if (src_first_rc == rc_kreg) {\n+    if (dst_first_rc == rc_stack) {\n+      \/\/ mem -> kreg\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        int offset = ra_->reg2offset(dst_first);\n+        if (cbuf) {\n+          MacroAssembler _masm(cbuf);\n+          __ kmov(Address(rsp, offset), as_KRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+          st->print(\"kmovq   [rsp + #%d] , %s\\t# spill\",\n+                     offset,\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n+      }\n+      return 0;\n+    } else if (dst_first_rc == rc_int) {\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        if (cbuf) {\n+          MacroAssembler _masm(cbuf);\n+          __ kmov(as_Register(Matcher::_regEncode[dst_first]), as_KRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+         st->print(\"kmovq   %s, %s\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n+      }\n+      Unimplemented();\n+      return 0;\n+    } else if (dst_first_rc == rc_kreg) {\n+      if ((src_first & 1) == 0 && src_first + 1 == src_second &&\n+          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {\n+        \/\/ 64-bit\n+        if (cbuf) {\n+          MacroAssembler _masm(cbuf);\n+          __ kmov(as_KRegister(Matcher::_regEncode[dst_first]), as_KRegister(Matcher::_regEncode[src_first]));\n+#ifndef PRODUCT\n+        } else {\n+         st->print(\"kmovq   %s, %s\\t# spill\",\n+                     Matcher::regName[dst_first],\n+                     Matcher::regName[src_first]);\n+#endif\n+        }\n+      }\n+      return 0;\n+    } else if (dst_first_rc == rc_float) {\n+      assert(false, \"Illegal spill\");\n+      return 0;\n@@ -1650,1 +1757,1 @@\n-  return true;\n+  return false;\n@@ -3178,0 +3285,12 @@\n+\/\/ Int Immediate: 2^n-1, postive\n+operand immI_Pow2M1()\n+%{\n+  predicate((n->get_int() > 0)\n+            && is_power_of_2(n->get_int() + 1));\n+  match(ConI);\n+\n+  op_cost(20);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -3281,0 +3400,66 @@\n+operand kReg()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+operand kReg_K1()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K1));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+operand kReg_K2()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K2));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Special Registers\n+operand kReg_K3()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K3));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+operand kReg_K4()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K4));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+operand kReg_K5()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K5));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+operand kReg_K6()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K6));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n+\/\/ Special Registers\n+operand kReg_K7()\n+%{\n+  constraint(ALLOC_IN_RC(vectmask_reg_K7));\n+  match(RegVectMask);\n+  format %{%}\n+  interface(REG_INTER);\n+%}\n+\n@@ -4707,1 +4892,0 @@\n-\n@@ -9184,0 +9368,15 @@\n+\/\/ Can skip int2long conversions after AND with small bitmask\n+instruct convI2LAndI_reg_immIbitmask(rRegL dst, rRegI src,  immI_Pow2M1 mask, rRegI tmp, rFlagsReg cr)\n+%{\n+  predicate(VM_Version::supports_bmi2());\n+  ins_cost(125);\n+  effect(TEMP tmp, KILL cr);\n+  match(Set dst (ConvI2L (AndI src mask)));\n+  format %{ \"bzhiq $dst, $src, $mask \\t# using $tmp as TEMP, int &  immI_Pow2M1 -> long\" %}\n+  ins_encode %{\n+    __ movl($tmp$$Register, exact_log2($mask$$constant + 1));\n+    __ bzhiq($dst$$Register, $src$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -10773,2 +10972,2 @@\n-\/\/ =======================================================================\n-\/\/ fast clearing of an array\n+\/\/ Fast clearing of an array\n+\/\/ Small ClearArray non-AVX512.\n@@ -10778,1 +10977,1 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && !n->in(2)->in(1)->bottom_type()->is_long()->is_con());\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2 || !VM_Version::supports_avx512vlbw()));\n@@ -10780,1 +10979,1 @@\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL val, KILL cr);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n@@ -10839,1 +11038,1 @@\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL val, KILL cr);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n@@ -10885,1 +11084,1 @@\n-                 $tmp$$XMMRegister, false, true);\n+                 $tmp$$XMMRegister, false, true, knoreg);\n@@ -10890,0 +11089,63 @@\n+\/\/ Small ClearArray AVX512 non-constant length.\n+instruct rep_stos_evex(rcx_RegL cnt, rdi_RegP base, regD tmp, kReg ktmp, rax_RegL val,\n+                       Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() &&\n+               UseAVX > 2 && VM_Version::supports_avx512vlbw() &&\n+               !n->in(2)->bottom_type()->is_long()->is_con());\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n+    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n+    $$emit$$\"jg      LARGE\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n+    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"jge     LOOP\\n\\t\"\n+    $$emit$$\"jmp     DONE\\n\\t\"\n+    $$emit$$\"# LARGE:\\n\\t\"\n+    if (UseFastStosb) {\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"mov     rdi,rax\\n\\t\"\n+       $$emit$$\"vpxor   ymm0,ymm0,ymm0\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, $ktmp$$KRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Large ClearArray non-AVX512.\n@@ -10893,1 +11155,1 @@\n-  predicate(((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only());\n+  predicate(UseAVX <=2 && ((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only());\n@@ -10895,1 +11157,1 @@\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL val, KILL cr);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n@@ -10934,1 +11196,52 @@\n-                 $tmp$$XMMRegister, true, false);\n+                 $tmp$$XMMRegister, true, false, knoreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Large ClearArray AVX512.\n+instruct rep_stos_large_evex(rcx_RegL cnt, rdi_RegP base, regD tmp, kReg ktmp, rax_RegL val,\n+                             Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(UseAVX > 2 && ((ClearArrayNode*)n)->is_large());\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    if (UseFastStosb) {\n+       $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"mov     rdi,rax\\t# ClearArray:\\n\\t\"\n+       $$emit$$\"vpxor   ymm0,ymm0,ymm0\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu ymm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"xorq    rax, rax\\t# ClearArray:\\n\\t\"\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n+    }\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, $ktmp$$KRegister);\n@@ -10944,1 +11257,1 @@\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL val, KILL cr);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n@@ -10985,1 +11298,2 @@\n-instruct rep_stos_im(immL cnt, rRegP base, regD tmp, rax_RegL val, Universe dummy, rFlagsReg cr)\n+\/\/ Small ClearArray AVX512 constant length.\n+instruct rep_stos_im(immL cnt, rRegP base, regD tmp, rax_RegL val, kReg ktmp, Universe dummy, rFlagsReg cr)\n@@ -10987,1 +11301,4 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && n->in(2)->in(1)->bottom_type()->is_long()->is_con());\n+  predicate(!((ClearArrayNode*)n)->is_large() &&\n+            !((ClearArrayNode*)n)->word_copy_only() &&\n+              (UseAVX > 2 && VM_Version::supports_avx512vlbw() &&\n+               n->in(2)->bottom_type()->is_long()->is_con()));\n@@ -10989,1 +11306,1 @@\n-  effect(TEMP tmp, USE_KILL val, KILL cr);\n+  effect(TEMP tmp, USE_KILL val, TEMP ktmp, KILL cr);\n@@ -10992,1 +11309,1 @@\n-   __ clear_mem($base$$Register, $cnt$$constant, $val$$Register, $tmp$$XMMRegister);\n+    __ clear_mem($base$$Register, $cnt$$constant, $val$$Register, $tmp$$XMMRegister, $ktmp$$KRegister);\n@@ -11000,1 +11317,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -11008,1 +11325,17 @@\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::LL);\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::LL, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareL_evex(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n+                              rax_RegI result, legRegD tmp1, kReg ktmp, rFlagsReg cr)\n+%{\n+  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::LL, $ktmp$$KRegister);\n@@ -11016,1 +11349,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -11024,1 +11357,17 @@\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::UU);\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::UU, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareU_evex(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n+                              rax_RegI result, legRegD tmp1, kReg ktmp, rFlagsReg cr)\n+%{\n+  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare char[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::UU, $ktmp$$KRegister);\n@@ -11032,1 +11381,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n@@ -11040,1 +11389,17 @@\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::LU);\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::LU, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareLU_evex(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,\n+                               rax_RegI result, legRegD tmp1, kReg ktmp, rFlagsReg cr)\n+%{\n+  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::LU, $ktmp$$KRegister);\n@@ -11048,1 +11413,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  predicate(UseAVX <= 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n@@ -11056,1 +11421,17 @@\n-                      $tmp1$$XMMRegister, StrIntrinsicNode::UL);\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::UL, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_compareUL_evex(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,\n+                               rax_RegI result, legRegD tmp1, kReg ktmp, rFlagsReg cr)\n+%{\n+  predicate(UseAVX > 2 && ((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare byte[] $str1,$cnt1,$str2,$cnt2 -> $result   \/\/ KILL $tmp1\" %}\n+  ins_encode %{\n+    __ string_compare($str2$$Register, $str1$$Register,\n+                      $cnt2$$Register, $cnt1$$Register, $result$$Register,\n+                      $tmp1$$XMMRegister, StrIntrinsicNode::UL, $ktmp$$KRegister);\n@@ -11231,0 +11612,1 @@\n+  predicate(UseAVX <= 2);\n@@ -11238,1 +11620,17 @@\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/);\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_equals_evex(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,\n+                           legRegD tmp1, legRegD tmp2, kReg ktmp, rbx_RegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseAVX > 2);\n+  match(Set result (StrEquals (Binary str1 str2) cnt));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);\n+\n+  format %{ \"String Equals $str1,$str2,$cnt -> $result    \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  ins_encode %{\n+    __ arrays_equals(false, $str1$$Register, $str2$$Register,\n+                     $cnt$$Register, $result$$Register, $tmp3$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, $ktmp$$KRegister);\n@@ -11247,1 +11645,1 @@\n-  predicate(((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate(UseAVX <= 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -11255,1 +11653,17 @@\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/);\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct array_equalsB_evex(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,\n+                            legRegD tmp1, legRegD tmp2, kReg ktmp, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)\n+%{\n+  predicate(UseAVX > 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  match(Set result (AryEq ary1 ary2));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);\n+\n+  format %{ \"Array Equals byte[] $ary1,$ary2 -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3, $tmp4\" %}\n+  ins_encode %{\n+    __ arrays_equals(true, $ary1$$Register, $ary2$$Register,\n+                     $tmp3$$Register, $result$$Register, $tmp4$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, false \/* char *\/, $ktmp$$KRegister);\n@@ -11263,1 +11677,1 @@\n-  predicate(((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate(UseAVX <= 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -11271,1 +11685,17 @@\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, true \/* char *\/);\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, true \/* char *\/, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct array_equalsC_evex(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,\n+                            legRegD tmp1, legRegD tmp2, kReg ktmp, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)\n+%{\n+  predicate(UseAVX > 2 && ((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  match(Set result (AryEq ary1 ary2));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);\n+\n+  format %{ \"Array Equals char[] $ary1,$ary2 -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3, $tmp4\" %}\n+  ins_encode %{\n+    __ arrays_equals(true, $ary1$$Register, $ary2$$Register,\n+                     $tmp3$$Register, $result$$Register, $tmp4$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, true \/* char *\/, $ktmp$$KRegister);\n@@ -11277,1 +11707,1 @@\n-                       legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)\n+                       legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr,)\n@@ -11279,0 +11709,1 @@\n+  predicate(UseAVX <= 2);\n@@ -11286,1 +11717,17 @@\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister);\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct has_negatives_evex(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n+                            legRegD tmp1, legRegD tmp2, kReg ktmp1, kReg ktmp2, rbx_RegI tmp3, rFlagsReg cr,)\n+%{\n+  predicate(UseAVX > 2);\n+  match(Set result (HasNegatives ary1 len));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp1, TEMP ktmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);\n+\n+  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  ins_encode %{\n+    __ has_negatives($ary1$$Register, $len$$Register,\n+                     $result$$Register, $tmp3$$Register,\n+                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n@@ -11292,2 +11739,3 @@\n-instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,\n-                         rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{\n+instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3,\n+                         legRegD tmp4, rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{\n+  predicate(UseAVX <= 2);\n@@ -11295,1 +11743,2 @@\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst,\n+         USE_KILL len, KILL tmp5, KILL cr);\n@@ -11301,1 +11750,2 @@\n-                           $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);\n+                           $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register,\n+                           knoreg, knoreg);\n@@ -11306,0 +11756,16 @@\n+instruct string_compress_evex(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3,\n+                              legRegD tmp4, kReg ktmp1, kReg ktmp2, rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{\n+  predicate(UseAVX > 2);\n+  match(Set result (StrCompressedCopy src (Binary dst len)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ktmp1, TEMP ktmp2, USE_KILL src, USE_KILL dst,\n+         USE_KILL len, KILL tmp5, KILL cr);\n+\n+  format %{ \"String Compress $src,$dst -> $result    \/\/ KILL RAX, RCX, RDX\" %}\n+  ins_encode %{\n+    __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,\n+                           $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,\n+                           $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register,\n+                           $ktmp1$$KRegister, $ktmp2$$KRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -11309,0 +11775,1 @@\n+  predicate(UseAVX <= 2);\n@@ -11315,1 +11782,15 @@\n-                          $tmp1$$XMMRegister, $tmp2$$Register);\n+                          $tmp1$$XMMRegister, $tmp2$$Register, knoreg);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_inflate_evex(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,\n+                             legRegD tmp1, kReg ktmp, rcx_RegI tmp2, rFlagsReg cr) %{\n+  predicate(UseAVX > 2);\n+  match(Set dummy (StrInflatedCopy src (Binary dst len)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP ktmp, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);\n+\n+  format %{ \"String Inflate $src,$dst    \/\/ KILL $tmp1, $tmp2\" %}\n+  ins_encode %{\n+    __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,\n+                          $tmp1$$XMMRegister, $tmp2$$Register, $ktmp$$KRegister);\n@@ -12107,1 +12588,3 @@\n-instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)\n+\/\/ Bounded mask operand used in following patten is needed for\n+\/\/ post-loop multiversioning.\n+instruct jmpLoopEnd_and_restoreMask(cmpOp cop, kReg_K1 ktmp, rFlagsReg cr, label labl)\n@@ -12109,1 +12592,1 @@\n-  predicate(n->has_vector_mask_set());\n+  predicate(PostLoopMultiversioning && n->has_vector_mask_set());\n@@ -12111,1 +12594,1 @@\n-  effect(USE labl);\n+  effect(USE labl, TEMP ktmp);\n@@ -12120,1 +12603,1 @@\n-    __ restorevectmask();\n+    __ restorevectmask($ktmp$$KRegister);\n@@ -12126,2 +12609,4 @@\n-instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{\n-  predicate(n->has_vector_mask_set());\n+\/\/ Bounded mask operand used in following patten is needed for\n+\/\/ post-loop multiversioning.\n+instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, kReg_K1 ktmp, rFlagsRegU cmp, label labl) %{\n+  predicate(PostLoopMultiversioning && n->has_vector_mask_set());\n@@ -12129,1 +12614,1 @@\n-  effect(USE labl);\n+  effect(USE labl, TEMP ktmp);\n@@ -12138,1 +12623,1 @@\n-    __ restorevectmask();\n+    __ restorevectmask($ktmp$$KRegister);\n@@ -12143,2 +12628,4 @@\n-instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{\n-  predicate(n->has_vector_mask_set());\n+\/\/ Bounded mask operand used in following patten is needed for\n+\/\/ post-loop multiversioning.\n+instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, kReg_K1 ktmp, rFlagsRegUCF cmp, label labl) %{\n+  predicate(PostLoopMultiversioning && n->has_vector_mask_set());\n@@ -12146,1 +12633,1 @@\n-  effect(USE labl);\n+  effect(USE labl, TEMP ktmp);\n@@ -12155,1 +12642,1 @@\n-    __ restorevectmask();\n+    __ restorevectmask($ktmp$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":537,"deletions":50,"binary":false,"changes":587,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -784,0 +784,1 @@\n+       !strcmp(_matrule->_rChild->_opType,\"StrInflatedCopy\") ||\n@@ -3826,1 +3827,0 @@\n-    \"MinV\",\"MaxV\",\n@@ -3968,1 +3968,1 @@\n-         strcmp(opType,\"RegVMask\")==0 ||\n+         strcmp(opType,\"RegVectMask\")==0 ||\n@@ -4177,1 +4177,0 @@\n-    \"MinV\",\"MaxV\",\n@@ -4205,1 +4204,2 @@\n-    \"ExtractB\",\"ExtractUB\",\"ExtractC\",\"ExtractS\",\"ExtractI\",\"ExtractL\",\"ExtractF\",\"ExtractD\"\n+    \"ExtractB\",\"ExtractUB\",\"ExtractC\",\"ExtractS\",\"ExtractI\",\"ExtractL\",\"ExtractF\",\"ExtractD\",\n+    \"VectorMaskCast\"\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,0 +255,1 @@\n+  AD.addInclude(AD._CPP_FORMAT_file, \"compiler\/oopMap.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,0 +245,1 @@\n+    NewMultiArray* nma;\n@@ -249,0 +250,4 @@\n+    } else if ((nma = x->array()->as_NewMultiArray()) != NULL &&\n+               (length = nma->dims()->at(0)->as_Constant()) != NULL) {\n+      assert(length->type()->as_IntConstant() != NULL, \"array length must be integer\");\n+      set_constant(length->type()->as_IntConstant()->value());\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1021,0 +1021,1 @@\n+      (array->as_Constant() != NULL) ||\n@@ -1022,1 +1023,2 @@\n-      (array->as_NewArray() && array->as_NewArray()->length() && array->as_NewArray()->length()->type()->is_constant())) {\n+      (array->as_NewArray() && array->as_NewArray()->length() && array->as_NewArray()->length()->type()->is_constant()) ||\n+      (array->as_NewMultiArray() && array->as_NewMultiArray()->dims()->at(0)->type()->is_constant())) {\n@@ -1106,0 +1108,1 @@\n+      (array->as_Constant() != NULL) ||\n@@ -1107,1 +1110,2 @@\n-      (array->as_NewArray() && array->as_NewArray()->length() && array->as_NewArray()->length()->type()->is_constant())) {\n+      (array->as_NewArray() && array->as_NewArray()->length() && array->as_NewArray()->length()->type()->is_constant()) ||\n+      (array->as_NewMultiArray() && array->as_NewMultiArray()->dims()->at(0)->type()->is_constant())) {\n@@ -2436,1 +2440,0 @@\n-  int vtable_index = Method::invalid_vtable_index;\n@@ -2476,1 +2479,1 @@\n-  Invoke* result = new Invoke(code, result_type, recv, args, vtable_index, target, state_before,\n+  Invoke* result = new Invoke(code, result_type, recv, args, target, state_before,\n@@ -3853,1 +3856,0 @@\n-  if (!callee->can_be_compiled())      return \"not compilable (disabled)\";\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -453,1 +453,1 @@\n-               int vtable_index, ciMethod* target, ValueStack* state_before, bool null_free)\n+               ciMethod* target, ValueStack* state_before, bool null_free)\n@@ -458,1 +458,0 @@\n-  , _vtable_index(vtable_index)\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1314,1 +1314,0 @@\n-  int             _vtable_index;\n@@ -1320,1 +1319,1 @@\n-         int vtable_index, ciMethod* target, ValueStack* state_before, bool null_free);\n+         ciMethod* target, ValueStack* state_before, bool null_free);\n@@ -1328,1 +1327,0 @@\n-  int vtable_index() const                       { return _vtable_index; }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -745,1 +745,0 @@\n-    case lir_virtual_call:\n@@ -1879,1 +1878,0 @@\n-     case lir_virtual_call:          s = \"virtual\";       break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -973,1 +973,0 @@\n-      , lir_virtual_call\n@@ -1231,5 +1230,0 @@\n-  intptr_t vtable_offset() const {\n-    assert(_code == lir_virtual_call, \"only have vtable for real vcall\");\n-    return (intptr_t) addr();\n-  }\n-\n@@ -2197,4 +2191,0 @@\n-  void call_virtual(ciMethod* method, LIR_Opr receiver, LIR_Opr result,\n-                    intptr_t vtable_offset, LIR_OprList* arguments, CodeEmitInfo* info) {\n-    append(new LIR_OpJavaCall(lir_virtual_call, method, receiver, result, vtable_offset, arguments, info));\n-  }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -474,3 +475,0 @@\n-  case lir_virtual_call:\n-    vtable_call(op);\n-    break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -3412,1 +3411,1 @@\n-      } else if (x->vtable_index() < 0) {\n+      } else {\n@@ -3416,4 +3415,0 @@\n-      } else {\n-        int entry_offset = in_bytes(Klass::vtable_start_offset()) + x->vtable_index() * vtableEntry::size_in_bytes();\n-        int vtable_offset = entry_offset + vtableEntry::method_offset_in_bytes();\n-        __ call_virtual(target, receiver, result_register, vtable_offset, arg_list, info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -6663,2 +6663,1 @@\n-        case lir_optvirtual_call:\n-        case lir_virtual_call:    inc_counter(counter_call); break;\n+        case lir_optvirtual_call: inc_counter(counter_call); break;\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -121,1 +122,0 @@\n-int Runtime1::_generic_arraycopy_cnt = 0;\n@@ -146,1 +146,0 @@\n-int Runtime1::_throw_array_store_exception_count = 0;\n@@ -179,4 +178,3 @@\n-static bool caller_is_deopted() {\n-  JavaThread* thread = JavaThread::current();\n-  RegisterMap reg_map(thread, false);\n-  frame runtime_frame = thread->last_frame();\n+static bool caller_is_deopted(JavaThread* current) {\n+  RegisterMap reg_map(current, false);\n+  frame runtime_frame = current->last_frame();\n@@ -189,5 +187,4 @@\n-static void deopt_caller() {\n-  if ( !caller_is_deopted()) {\n-    JavaThread* thread = JavaThread::current();\n-    RegisterMap reg_map(thread, false);\n-    frame runtime_frame = thread->last_frame();\n+static void deopt_caller(JavaThread* current) {\n+  if (!caller_is_deopted(current)) {\n+    RegisterMap reg_map(current, false);\n+    frame runtime_frame = current->last_frame();\n@@ -195,2 +192,2 @@\n-    Deoptimization::deoptimize_frame(thread, caller_frame.id());\n-    assert(caller_is_deopted(), \"Must be deoptimized\");\n+    Deoptimization::deoptimize_frame(current, caller_frame.id());\n+    assert(caller_is_deopted(current), \"Must be deoptimized\");\n@@ -367,1 +364,1 @@\n-static void allocate_instance(JavaThread* thread, Klass* klass, TRAPS) {\n+static void allocate_instance(JavaThread* current, Klass* klass, TRAPS) {\n@@ -369,1 +366,1 @@\n-  Handle holder(THREAD, klass->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, klass->klass_holder()); \/\/ keep the klass alive\n@@ -376,2 +373,2 @@\n-  thread->set_vm_result(obj);\n-}\n+  current->set_vm_result(obj);\n+JRT_END\n@@ -379,1 +376,1 @@\n-JRT_ENTRY(void, Runtime1::new_instance(JavaThread* thread, Klass* klass))\n+JRT_ENTRY(void, Runtime1::new_instance(JavaThread* current, Klass* klass))\n@@ -381,1 +378,1 @@\n-  allocate_instance(thread, klass, CHECK);\n+  allocate_instance(current, klass, CHECK);\n@@ -385,1 +382,1 @@\n-JRT_ENTRY(void, Runtime1::new_instance_no_inline(JavaThread* thread, Klass* klass))\n+JRT_ENTRY(void, Runtime1::new_instance_no_inline(JavaThread* current, Klass* klass))\n@@ -388,1 +385,1 @@\n-    SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_InstantiationError());\n+    SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_InstantiationError());\n@@ -390,1 +387,1 @@\n-    allocate_instance(thread, klass, CHECK);\n+    allocate_instance(current, klass, CHECK);\n@@ -394,1 +391,1 @@\n-JRT_ENTRY(void, Runtime1::new_type_array(JavaThread* thread, Klass* klass, jint length))\n+JRT_ENTRY(void, Runtime1::new_type_array(JavaThread* current, Klass* klass, jint length))\n@@ -402,1 +399,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -406,1 +403,1 @@\n-    deopt_caller();\n+    deopt_caller(current);\n@@ -412,1 +409,1 @@\n-JRT_ENTRY(void, Runtime1::new_object_array(JavaThread* thread, Klass* array_klass, jint length))\n+JRT_ENTRY(void, Runtime1::new_object_array(JavaThread* current, Klass* array_klass, jint length))\n@@ -419,1 +416,1 @@\n-  Handle holder(THREAD, array_klass->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, array_klass->klass_holder()); \/\/ keep the klass alive\n@@ -422,1 +419,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -426,1 +423,1 @@\n-    deopt_caller();\n+    deopt_caller(current);\n@@ -431,1 +428,1 @@\n-JRT_ENTRY(void, Runtime1::new_flat_array(JavaThread* thread, Klass* array_klass, jint length))\n+JRT_ENTRY(void, Runtime1::new_flat_array(JavaThread* current, Klass* array_klass, jint length))\n@@ -444,1 +441,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -448,1 +445,1 @@\n-    deopt_caller();\n+    deopt_caller(current);\n@@ -453,1 +450,1 @@\n-JRT_ENTRY(void, Runtime1::new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims))\n+JRT_ENTRY(void, Runtime1::new_multi_array(JavaThread* current, Klass* klass, int rank, jint* dims))\n@@ -458,1 +455,1 @@\n-  Handle holder(THREAD, klass->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, klass->klass_holder()); \/\/ keep the klass alive\n@@ -460,1 +457,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -464,3 +461,3 @@\n-static void profile_flat_array(JavaThread* thread) {\n-  ResourceMark rm(thread);\n-  vframeStream vfst(thread, true);\n+static void profile_flat_array(JavaThread* current) {\n+  ResourceMark rm(current);\n+  vframeStream vfst(current, true);\n@@ -483,1 +480,1 @@\n-JRT_ENTRY(void, Runtime1::load_flattened_array(JavaThread* thread, flatArrayOopDesc* array, int index))\n+JRT_ENTRY(void, Runtime1::load_flattened_array(JavaThread* current, flatArrayOopDesc* array, int index))\n@@ -485,1 +482,1 @@\n-  profile_flat_array(thread);\n+  profile_flat_array(current);\n@@ -489,1 +486,1 @@\n-  flatArrayHandle vah(thread, array);\n+  flatArrayHandle vah(current, array);\n@@ -491,1 +488,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -495,1 +492,1 @@\n-JRT_ENTRY(void, Runtime1::store_flattened_array(JavaThread* thread, flatArrayOopDesc* array, int index, oopDesc* value))\n+JRT_ENTRY(void, Runtime1::store_flattened_array(JavaThread* current, flatArrayOopDesc* array, int index, oopDesc* value))\n@@ -497,1 +494,1 @@\n-    profile_flat_array(thread);\n+    profile_flat_array(current);\n@@ -503,1 +500,1 @@\n-    SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());\n+    SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException());\n@@ -511,1 +508,1 @@\n-JRT_ENTRY(int, Runtime1::substitutability_check(JavaThread* thread, oopDesc* left, oopDesc* right))\n+JRT_ENTRY(int, Runtime1::substitutability_check(JavaThread* current, oopDesc* left, oopDesc* right))\n@@ -528,5 +525,5 @@\n-void Runtime1::buffer_inline_args_impl(JavaThread* thread, Method* m, bool allocate_receiver) {\n-  Thread* THREAD = thread;\n-  methodHandle method(thread, m); \/\/ We are inside the verified_entry or verified_inline_ro_entry of this method.\n-  oop obj = SharedRuntime::allocate_inline_types_impl(thread, method, allocate_receiver, CHECK);\n-  thread->set_vm_result(obj);\n+void Runtime1::buffer_inline_args_impl(JavaThread* current, Method* m, bool allocate_receiver) {\n+  Thread* THREAD = current;\n+  methodHandle method(current, m); \/\/ We are inside the verified_entry or verified_inline_ro_entry of this method.\n+  oop obj = SharedRuntime::allocate_inline_types_impl(current, method, allocate_receiver, CHECK);\n+  current->set_vm_result(obj);\n@@ -535,1 +532,1 @@\n-JRT_ENTRY(void, Runtime1::buffer_inline_args(JavaThread* thread, Method* method))\n+JRT_ENTRY(void, Runtime1::buffer_inline_args(JavaThread* current, Method* method))\n@@ -537,1 +534,1 @@\n-  buffer_inline_args_impl(thread, method, true);\n+  buffer_inline_args_impl(current, method, true);\n@@ -540,1 +537,1 @@\n-JRT_ENTRY(void, Runtime1::buffer_inline_args_no_receiver(JavaThread* thread, Method* method))\n+JRT_ENTRY(void, Runtime1::buffer_inline_args_no_receiver(JavaThread* current, Method* method))\n@@ -542,1 +539,1 @@\n-  buffer_inline_args_impl(thread, method, false);\n+  buffer_inline_args_impl(current, method, false);\n@@ -545,1 +542,1 @@\n-JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* thread, StubID id))\n+JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* current, StubID id))\n@@ -550,2 +547,2 @@\n-JRT_ENTRY(void, Runtime1::throw_array_store_exception(JavaThread* thread, oopDesc* obj))\n-  ResourceMark rm(thread);\n+JRT_ENTRY(void, Runtime1::throw_array_store_exception(JavaThread* current, oopDesc* obj))\n+  ResourceMark rm(current);\n@@ -553,1 +550,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArrayStoreException(), klass_name);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_ArrayStoreException(), klass_name);\n@@ -561,1 +558,1 @@\n-static nmethod* counter_overflow_helper(JavaThread* THREAD, int branch_bci, Method* m) {\n+static nmethod* counter_overflow_helper(JavaThread* current, int branch_bci, Method* m) {\n@@ -563,1 +560,1 @@\n-  methodHandle method(THREAD, m);\n+  methodHandle method(current, m);\n@@ -565,2 +562,2 @@\n-  RegisterMap map(THREAD, false);\n-  frame fr =  THREAD->last_frame().sender(&map);\n+  RegisterMap map(current, false);\n+  frame fr =  current->last_frame().sender(&map);\n@@ -569,1 +566,1 @@\n-  methodHandle enclosing_method(THREAD, nm->method());\n+  methodHandle enclosing_method(current, nm->method());\n@@ -595,1 +592,1 @@\n-  osr_nm = CompilationPolicy::event(enclosing_method, method, branch_bci, bci, level, nm, THREAD);\n+  osr_nm = CompilationPolicy::event(enclosing_method, method, branch_bci, bci, level, nm, current);\n@@ -599,1 +596,1 @@\n-JRT_BLOCK_ENTRY(address, Runtime1::counter_overflow(JavaThread* thread, int bci, Method* method))\n+JRT_BLOCK_ENTRY(address, Runtime1::counter_overflow(JavaThread* current, int bci, Method* method))\n@@ -602,1 +599,1 @@\n-    osr_nm = counter_overflow_helper(thread, bci, method);\n+    osr_nm = counter_overflow_helper(current, bci, method);\n@@ -604,3 +601,3 @@\n-      RegisterMap map(thread, false);\n-      frame fr =  thread->last_frame().sender(&map);\n-      Deoptimization::deoptimize_frame(thread, fr.id());\n+      RegisterMap map(current, false);\n+      frame fr =  current->last_frame().sender(&map);\n+      Deoptimization::deoptimize_frame(current, fr.id());\n@@ -630,1 +627,1 @@\n-JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* thread, oopDesc* ex, address pc, nmethod*& nm))\n+JRT_ENTRY_NO_ASYNC(static address, exception_handler_for_pc_helper(JavaThread* current, oopDesc* ex, address pc, nmethod*& nm))\n@@ -632,1 +629,1 @@\n-  thread->set_is_method_handle_return(false);\n+  current->set_is_method_handle_return(false);\n@@ -634,1 +631,1 @@\n-  Handle exception(thread, ex);\n+  Handle exception(current, ex);\n@@ -639,1 +636,1 @@\n-  if (thread->last_frame().cb() == Runtime1::blob_for(Runtime1::handle_exception_from_callee_id)) {\n+  if (current->last_frame().cb() == Runtime1::blob_for(Runtime1::handle_exception_from_callee_id)) {\n@@ -643,1 +640,1 @@\n-    StackWatermarkSet::after_unwind(thread);\n+    StackWatermarkSet::after_unwind(current);\n@@ -650,2 +647,2 @@\n-    RegisterMap map(thread, false);\n-    frame exception_frame = thread->last_frame().sender(&map);\n+    RegisterMap map(current, false);\n+    frame exception_frame = current->last_frame().sender(&map);\n@@ -669,1 +666,1 @@\n-                 nm->method()->print_value_string(), p2i(pc), p2i(thread));\n+                 nm->method()->print_value_string(), p2i(pc), p2i(current));\n@@ -678,1 +675,1 @@\n-  bool guard_pages_enabled = thread->stack_overflow_state()->reguard_stack_if_needed();\n+  bool guard_pages_enabled = current->stack_overflow_state()->reguard_stack_if_needed();\n@@ -689,2 +686,2 @@\n-    RegisterMap reg_map(thread);\n-    frame stub_frame = thread->last_frame();\n+    RegisterMap reg_map(current);\n+    frame stub_frame = current->last_frame();\n@@ -696,2 +693,2 @@\n-    Deoptimization::deoptimize_frame(thread, caller_frame.id());\n-    assert(caller_is_deopted(), \"Must be deoptimized\");\n+    Deoptimization::deoptimize_frame(current, caller_frame.id());\n+    assert(caller_is_deopted(current), \"Must be deoptimized\");\n@@ -707,1 +704,1 @@\n-      thread->set_is_method_handle_return(nm->is_method_handle_return(pc));\n+      current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -725,1 +722,1 @@\n-    thread->clear_exception_oop_and_pc();\n+    current->clear_exception_oop_and_pc();\n@@ -730,2 +727,2 @@\n-    thread->set_exception_oop(exception());\n-    thread->set_exception_pc(pc);\n+    current->set_exception_oop(exception());\n+    current->set_exception_pc(pc);\n@@ -743,1 +740,1 @@\n-  thread->set_vm_result(exception());\n+  current->set_vm_result(exception());\n@@ -745,1 +742,1 @@\n-  thread->set_is_method_handle_return(nm->is_method_handle_return(pc));\n+  current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -751,1 +748,1 @@\n-                         p2i(thread), p2i(continuation), p2i(pc));\n+                         p2i(current), p2i(continuation), p2i(pc));\n@@ -762,3 +759,3 @@\n-address Runtime1::exception_handler_for_pc(JavaThread* thread) {\n-  oop exception = thread->exception_oop();\n-  address pc = thread->exception_pc();\n+address Runtime1::exception_handler_for_pc(JavaThread* current) {\n+  oop exception = current->exception_oop();\n+  address pc = current->exception_pc();\n@@ -772,1 +769,1 @@\n-    continuation = exception_handler_for_pc_helper(thread, exception, pc, nm);\n+    continuation = exception_handler_for_pc_helper(current, exception, pc, nm);\n@@ -778,1 +775,1 @@\n-  if (nm != NULL && caller_is_deopted()) {\n+  if (nm != NULL && caller_is_deopted(current)) {\n@@ -787,1 +784,1 @@\n-JRT_ENTRY(void, Runtime1::throw_range_check_exception(JavaThread* thread, int index, arrayOopDesc* a))\n+JRT_ENTRY(void, Runtime1::throw_range_check_exception(JavaThread* current, int index, arrayOopDesc* a))\n@@ -793,1 +790,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), message);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), message);\n@@ -797,1 +794,1 @@\n-JRT_ENTRY(void, Runtime1::throw_index_exception(JavaThread* thread, int index))\n+JRT_ENTRY(void, Runtime1::throw_index_exception(JavaThread* current, int index))\n@@ -801,1 +798,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IndexOutOfBoundsException(), message);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_IndexOutOfBoundsException(), message);\n@@ -805,1 +802,1 @@\n-JRT_ENTRY(void, Runtime1::throw_div0_exception(JavaThread* thread))\n+JRT_ENTRY(void, Runtime1::throw_div0_exception(JavaThread* current))\n@@ -807,1 +804,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArithmeticException(), \"\/ by zero\");\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_ArithmeticException(), \"\/ by zero\");\n@@ -811,1 +808,1 @@\n-JRT_ENTRY(void, Runtime1::throw_null_pointer_exception(JavaThread* thread))\n+JRT_ENTRY(void, Runtime1::throw_null_pointer_exception(JavaThread* current))\n@@ -813,1 +810,1 @@\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException());\n@@ -817,1 +814,1 @@\n-JRT_ENTRY(void, Runtime1::throw_class_cast_exception(JavaThread* thread, oopDesc* object))\n+JRT_ENTRY(void, Runtime1::throw_class_cast_exception(JavaThread* current, oopDesc* object))\n@@ -819,5 +816,3 @@\n-  ResourceMark rm(thread);\n-  char* message = SharedRuntime::generate_class_cast_message(\n-    thread, object->klass());\n-  SharedRuntime::throw_and_post_jvmti_exception(\n-    thread, vmSymbols::java_lang_ClassCastException(), message);\n+  ResourceMark rm(current);\n+  char* message = SharedRuntime::generate_class_cast_message(current, object->klass());\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_ClassCastException(), message);\n@@ -827,1 +822,1 @@\n-JRT_ENTRY(void, Runtime1::throw_incompatible_class_change_error(JavaThread* thread))\n+JRT_ENTRY(void, Runtime1::throw_incompatible_class_change_error(JavaThread* current))\n@@ -829,2 +824,2 @@\n-  ResourceMark rm(thread);\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IncompatibleClassChangeError());\n+  ResourceMark rm(current);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_IncompatibleClassChangeError());\n@@ -834,1 +829,1 @@\n-JRT_ENTRY(void, Runtime1::throw_illegal_monitor_state_exception(JavaThread* thread))\n+JRT_ENTRY(void, Runtime1::throw_illegal_monitor_state_exception(JavaThread* current))\n@@ -836,2 +831,2 @@\n-  ResourceMark rm(thread);\n-  SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IllegalMonitorStateException());\n+  ResourceMark rm(current);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_IllegalMonitorStateException());\n@@ -840,2 +835,1 @@\n-\n-JRT_BLOCK_ENTRY(void, Runtime1::monitorenter(JavaThread* thread, oopDesc* obj, BasicObjectLock* lock))\n+JRT_BLOCK_ENTRY(void, Runtime1::monitorenter(JavaThread* current, oopDesc* obj, BasicObjectLock* lock))\n@@ -847,1 +841,1 @@\n-  SharedRuntime::monitor_enter_helper(obj, lock->lock(), thread);\n+  SharedRuntime::monitor_enter_helper(obj, lock->lock(), current);\n@@ -851,1 +845,1 @@\n-JRT_LEAF(void, Runtime1::monitorexit(JavaThread* thread, BasicObjectLock* lock))\n+JRT_LEAF(void, Runtime1::monitorexit(JavaThread* current, BasicObjectLock* lock))\n@@ -853,1 +847,1 @@\n-  assert(thread->last_Java_sp(), \"last_Java_sp must be set\");\n+  assert(current->last_Java_sp(), \"last_Java_sp must be set\");\n@@ -856,1 +850,1 @@\n-  SharedRuntime::monitor_exit_helper(obj, lock->lock(), thread);\n+  SharedRuntime::monitor_exit_helper(obj, lock->lock(), current);\n@@ -860,1 +854,1 @@\n-JRT_ENTRY(void, Runtime1::deoptimize(JavaThread* thread, jint trap_request))\n+JRT_ENTRY(void, Runtime1::deoptimize(JavaThread* current, jint trap_request))\n@@ -862,2 +856,2 @@\n-  RegisterMap reg_map(thread, false);\n-  frame stub_frame = thread->last_frame();\n+  RegisterMap reg_map(current, false);\n+  frame stub_frame = current->last_frame();\n@@ -868,1 +862,1 @@\n-  methodHandle method(thread, nm->method());\n+  methodHandle method(current, nm->method());\n@@ -876,1 +870,1 @@\n-        MethodData* trap_mdo = Deoptimization::get_method_data(thread, method, true \/*create_if_missing*\/);\n+        MethodData* trap_mdo = Deoptimization::get_method_data(current, method, true \/*create_if_missing*\/);\n@@ -885,1 +879,1 @@\n-  Deoptimization::deoptimize_frame(thread, caller_frame.id());\n+  Deoptimization::deoptimize_frame(current, caller_frame.id());\n@@ -1003,1 +997,1 @@\n-JRT_ENTRY(void, Runtime1::patch_code(JavaThread* thread, Runtime1::StubID stub_id ))\n+JRT_ENTRY(void, Runtime1::patch_code(JavaThread* current, Runtime1::StubID stub_id ))\n@@ -1006,3 +1000,3 @@\n-  ResourceMark rm(thread);\n-  RegisterMap reg_map(thread, false);\n-  frame runtime_frame = thread->last_frame();\n+  ResourceMark rm(current);\n+  RegisterMap reg_map(current, false);\n+  frame runtime_frame = current->last_frame();\n@@ -1012,1 +1006,1 @@\n-  vframeStream vfst(thread, true);\n+  vframeStream vfst(current, true);\n@@ -1015,1 +1009,1 @@\n-  methodHandle caller_method(THREAD, vfst.method());\n+  methodHandle caller_method(current, vfst.method());\n@@ -1030,2 +1024,2 @@\n-  Handle mirror(THREAD, NULL);                    \/\/ oop needed by load_mirror_patching code\n-  Handle appendix(THREAD, NULL);                  \/\/ oop needed by appendix_patching code\n+  Handle mirror(current, NULL);                    \/\/ oop needed by load_mirror_patching code\n+  Handle appendix(current, NULL);                  \/\/ oop needed by appendix_patching code\n@@ -1040,1 +1034,1 @@\n-    constantPoolHandle constants(THREAD, caller_method->constants());\n+    constantPoolHandle constants(current, caller_method->constants());\n@@ -1078,1 +1072,1 @@\n-          mirror = Handle(THREAD, klass->java_mirror());\n+          mirror = Handle(current, klass->java_mirror());\n@@ -1121,1 +1115,1 @@\n-          mirror = Handle(THREAD, m);\n+          mirror = Handle(current, m);\n@@ -1132,1 +1126,1 @@\n-    constantPoolHandle pool(thread, caller_method->constants());\n+    constantPoolHandle pool(current, caller_method->constants());\n@@ -1141,1 +1135,1 @@\n-        appendix = Handle(THREAD, cpce->appendix_if_resolved(pool)); \/\/ just in case somebody already resolved the entry\n+        appendix = Handle(current, cpce->appendix_if_resolved(pool)); \/\/ just in case somebody already resolved the entry\n@@ -1147,1 +1141,1 @@\n-        appendix = Handle(THREAD, cpce->appendix_if_resolved(pool)); \/\/ just in case somebody already resolved the entry\n+        appendix = Handle(current, cpce->appendix_if_resolved(pool)); \/\/ just in case somebody already resolved the entry\n@@ -1176,1 +1170,1 @@\n-    Deoptimization::deoptimize_frame(thread, caller_frame.id());\n+    Deoptimization::deoptimize_frame(current, caller_frame.id());\n@@ -1184,1 +1178,1 @@\n-    MutexLocker ml_patch (THREAD, Patching_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml_patch (current, Patching_lock, Mutex::_no_safepoint_check_flag);\n@@ -1189,1 +1183,1 @@\n-    if (!caller_is_deopted()) {\n+    if (!caller_is_deopted(current)) {\n@@ -1396,1 +1390,1 @@\n-    MutexLocker ml_code (THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml_code (current, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -1408,1 +1402,1 @@\n-void Runtime1::patch_code(JavaThread* thread, Runtime1::StubID stub_id) {\n+void Runtime1::patch_code(JavaThread* current, Runtime1::StubID stub_id) {\n@@ -1411,0 +1405,4 @@\n+  \/\/ Enable WXWrite: the function is called by c1 stub as a runtime function\n+  \/\/ (see another implementation above).\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n+\n@@ -1415,1 +1413,1 @@\n-  RegisterMap reg_map(thread, false);\n+  RegisterMap reg_map(current, false);\n@@ -1417,1 +1415,1 @@\n-  frame runtime_frame = thread->last_frame();\n+  frame runtime_frame = current->last_frame();\n@@ -1427,1 +1425,1 @@\n-  Deoptimization::deoptimize_frame(thread, caller_frame.id());\n+  Deoptimization::deoptimize_frame(current, caller_frame.id());\n@@ -1429,1 +1427,1 @@\n-  postcond(caller_is_deopted());\n+  postcond(caller_is_deopted(current));\n@@ -1442,1 +1440,1 @@\n-int Runtime1::move_klass_patching(JavaThread* thread) {\n+int Runtime1::move_klass_patching(JavaThread* current) {\n@@ -1446,1 +1444,0 @@\n-  Thread* THREAD = thread;\n@@ -1451,1 +1448,1 @@\n-    patch_code(thread, load_klass_patching_id);\n+    patch_code(current, load_klass_patching_id);\n@@ -1457,1 +1454,1 @@\n-  return caller_is_deopted();\n+  return caller_is_deopted(current);\n@@ -1460,1 +1457,1 @@\n-int Runtime1::move_mirror_patching(JavaThread* thread) {\n+int Runtime1::move_mirror_patching(JavaThread* current) {\n@@ -1464,1 +1461,0 @@\n-  Thread* THREAD = thread;\n@@ -1469,1 +1465,1 @@\n-    patch_code(thread, load_mirror_patching_id);\n+    patch_code(current, load_mirror_patching_id);\n@@ -1475,1 +1471,1 @@\n-  return caller_is_deopted();\n+  return caller_is_deopted(current);\n@@ -1478,1 +1474,1 @@\n-int Runtime1::move_appendix_patching(JavaThread* thread) {\n+int Runtime1::move_appendix_patching(JavaThread* current) {\n@@ -1482,1 +1478,0 @@\n-  Thread* THREAD = thread;\n@@ -1487,1 +1482,1 @@\n-    patch_code(thread, load_appendix_patching_id);\n+    patch_code(current, load_appendix_patching_id);\n@@ -1493,1 +1488,1 @@\n-  return caller_is_deopted();\n+  return caller_is_deopted(current);\n@@ -1504,1 +1499,1 @@\n-int Runtime1::access_field_patching(JavaThread* thread) {\n+int Runtime1::access_field_patching(JavaThread* current) {\n@@ -1514,1 +1509,1 @@\n-    patch_code(thread, access_field_patching_id);\n+    patch_code(current, access_field_patching_id);\n@@ -1520,1 +1515,1 @@\n-  return caller_is_deopted();\n+  return caller_is_deopted(current);\n@@ -1542,1 +1537,1 @@\n-JRT_ENTRY(void, Runtime1::predicate_failed_trap(JavaThread* thread))\n+JRT_ENTRY(void, Runtime1::predicate_failed_trap(JavaThread* current))\n@@ -1545,2 +1540,2 @@\n-  RegisterMap reg_map(thread, false);\n-  frame runtime_frame = thread->last_frame();\n+  RegisterMap reg_map(current, false);\n+  frame runtime_frame = current->last_frame();\n@@ -1553,1 +1548,1 @@\n-  methodHandle m(thread, nm->method());\n+  methodHandle m(current, nm->method());\n@@ -1574,1 +1569,1 @@\n-    vframeStream vfst(thread);\n+    vframeStream vfst(current);\n@@ -1582,1 +1577,1 @@\n-  Deoptimization::deoptimize_frame(thread, caller_frame.id());\n+  Deoptimization::deoptimize_frame(current, caller_frame.id());\n@@ -1594,1 +1589,0 @@\n-  tty->print_cr(\" _generic_arraycopy_cnt:          %d\", _generic_arraycopy_cnt);\n@@ -1627,1 +1621,0 @@\n-  tty->print_cr(\" _throw_array_store_exception_count:            %d:\", _throw_array_store_exception_count);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":166,"deletions":173,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -105,4 +105,0 @@\n-  static int _resolve_invoke_cnt;\n-  static int _handle_wrong_method_cnt;\n-  static int _ic_miss_cnt;\n-  static int _generic_arraycopy_cnt;\n@@ -133,1 +129,0 @@\n-  static int _throw_array_store_exception_count;\n@@ -140,1 +135,1 @@\n-  static void buffer_inline_args_impl(JavaThread* thread, Method* m, bool allocate_receiver);\n+  static void buffer_inline_args_impl(JavaThread* current, Method* m, bool allocate_receiver);\n@@ -157,11 +152,11 @@\n-  static void new_instance    (JavaThread* thread, Klass* klass);\n-  static void new_instance_no_inline(JavaThread* thread, Klass* klass);\n-  static void new_type_array  (JavaThread* thread, Klass* klass, jint length);\n-  static void new_object_array(JavaThread* thread, Klass* klass, jint length);\n-  static void new_flat_array (JavaThread* thread, Klass* klass, jint length);\n-  static void new_multi_array (JavaThread* thread, Klass* klass, int rank, jint* dims);\n-  static void load_flattened_array(JavaThread* thread, flatArrayOopDesc* array, int index);\n-  static void store_flattened_array(JavaThread* thread, flatArrayOopDesc* array, int index, oopDesc* value);\n-  static int  substitutability_check(JavaThread* thread, oopDesc* left, oopDesc* right);\n-  static void buffer_inline_args(JavaThread* thread, Method* method);\n-  static void buffer_inline_args_no_receiver(JavaThread* thread, Method* method);\n+  static void new_instance    (JavaThread* current, Klass* klass);\n+  static void new_instance_no_inline(JavaThread* current, Klass* klass);\n+  static void new_type_array  (JavaThread* current, Klass* klass, jint length);\n+  static void new_object_array(JavaThread* current, Klass* klass, jint length);\n+  static void new_flat_array (JavaThread* current, Klass* klass, jint length);\n+  static void new_multi_array (JavaThread* current, Klass* klass, int rank, jint* dims);\n+  static void load_flattened_array(JavaThread* current, flatArrayOopDesc* array, int index);\n+  static void store_flattened_array(JavaThread* current, flatArrayOopDesc* array, int index, oopDesc* value);\n+  static int  substitutability_check(JavaThread* current, oopDesc* left, oopDesc* right);\n+  static void buffer_inline_args(JavaThread* current, Method* method);\n+  static void buffer_inline_args_no_receiver(JavaThread* current, Method* method);\n@@ -169,1 +164,1 @@\n-  static address counter_overflow(JavaThread* thread, int bci, Method* method);\n+  static address counter_overflow(JavaThread* current, int bci, Method* method);\n@@ -171,1 +166,1 @@\n-  static void unimplemented_entry   (JavaThread* thread, StubID id);\n+  static void unimplemented_entry(JavaThread* current, StubID id);\n@@ -173,1 +168,1 @@\n-  static address exception_handler_for_pc(JavaThread* thread);\n+  static address exception_handler_for_pc(JavaThread* current);\n@@ -175,8 +170,8 @@\n-  static void throw_range_check_exception(JavaThread* thread, int index, arrayOopDesc* a);\n-  static void throw_index_exception(JavaThread* thread, int index);\n-  static void throw_div0_exception(JavaThread* thread);\n-  static void throw_null_pointer_exception(JavaThread* thread);\n-  static void throw_class_cast_exception(JavaThread* thread, oopDesc* object);\n-  static void throw_incompatible_class_change_error(JavaThread* thread);\n-  static void throw_illegal_monitor_state_exception(JavaThread* thread);\n-  static void throw_array_store_exception(JavaThread* thread, oopDesc* object);\n+  static void throw_range_check_exception(JavaThread* current, int index, arrayOopDesc* a);\n+  static void throw_index_exception(JavaThread* current, int index);\n+  static void throw_div0_exception(JavaThread* current);\n+  static void throw_null_pointer_exception(JavaThread* current);\n+  static void throw_class_cast_exception(JavaThread* current, oopDesc* object);\n+  static void throw_incompatible_class_change_error(JavaThread* current);\n+  static void throw_illegal_monitor_state_exception(JavaThread* current);\n+  static void throw_array_store_exception(JavaThread* current, oopDesc* object);\n@@ -184,2 +179,2 @@\n-  static void monitorenter(JavaThread* thread, oopDesc* obj, BasicObjectLock* lock);\n-  static void monitorexit (JavaThread* thread, BasicObjectLock* lock);\n+  static void monitorenter(JavaThread* current, oopDesc* obj, BasicObjectLock* lock);\n+  static void monitorexit (JavaThread* current, BasicObjectLock* lock);\n@@ -187,1 +182,1 @@\n-  static void deoptimize(JavaThread* thread, jint trap_request);\n+  static void deoptimize(JavaThread* current, jint trap_request);\n@@ -189,4 +184,4 @@\n-  static int access_field_patching(JavaThread* thread);\n-  static int move_klass_patching(JavaThread* thread);\n-  static int move_mirror_patching(JavaThread* thread);\n-  static int move_appendix_patching(JavaThread* thread);\n+  static int access_field_patching(JavaThread* current);\n+  static int move_klass_patching(JavaThread* current);\n+  static int move_mirror_patching(JavaThread* current);\n+  static int move_appendix_patching(JavaThread* current);\n@@ -194,1 +189,1 @@\n-  static void patch_code(JavaThread* thread, StubID stub_id);\n+  static void patch_code(JavaThread* current, StubID stub_id);\n@@ -221,1 +216,1 @@\n-  static void predicate_failed_trap(JavaThread* thread);\n+  static void predicate_failed_trap(JavaThread* current);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":32,"deletions":37,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-  : _gvn(gvn), _short_loop_optimizer(slo) {\n+  : _gvn(gvn), _short_loop_optimizer(slo), _insertion_point(NULL), _state(NULL), _insert_is_pred(false) {\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,1 +279,1 @@\n-  \/\/ other calls are skipped if there are no unescaped arguments passed to them\n+  \/\/ other calls are skipped if there are no non-escaped arguments passed to them\n@@ -305,2 +305,1 @@\n-      && (klass->is_initialized() || (klass->is_interface() && target->holder()->is_initialized()))\n-      && target->is_loaded()) {\n+      && (klass->is_initialized() || (klass->is_interface() && target->holder()->is_initialized()))) {\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -409,1 +409,1 @@\n-  EXCEPTION_CONTEXT;\n+  Thread* current = Thread::current();\n@@ -429,2 +429,2 @@\n-  Handle loader(THREAD, (oop)NULL);\n-  Handle domain(THREAD, (oop)NULL);\n+  Handle loader;\n+  Handle domain;\n@@ -432,2 +432,2 @@\n-    loader = Handle(THREAD, accessing_klass->loader());\n-    domain = Handle(THREAD, accessing_klass->protection_domain());\n+    loader = Handle(current, accessing_klass->loader());\n+    domain = Handle(current, accessing_klass->protection_domain());\n@@ -446,1 +446,1 @@\n-    MutexLocker ml(Compile_lock);\n+    MutexLocker ml(current, Compile_lock);\n@@ -449,1 +449,1 @@\n-      kls = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, THREAD);\n+      kls = SystemDictionary::find_constrained_instance_or_array_klass(current, sym, loader);\n@@ -513,1 +513,1 @@\n-    char *new_name = CURRENT_THREAD_ENV->name_buffer(sym->utf8_length()+1);\n+    char* new_name = name_buffer(sym->utf8_length()+1);\n@@ -687,0 +687,2 @@\n+  } else if (tag.is_unresolved_klass_in_error()) {\n+    return ciConstant();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"compiler\/oopMap.hpp\"\n@@ -40,0 +39,1 @@\n+class OopMapSet;\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -289,0 +289,25 @@\n+static bool is_klass_initialized(Symbol* klass_name) {\n+  VM_ENTRY_MARK;\n+  InstanceKlass* ik = SystemDictionary::find_instance_klass(klass_name, Handle(), Handle());\n+  return ik != nullptr && ik->is_initialized();\n+}\n+\n+bool ciInstanceKlass::is_box_cache_valid() const {\n+  BasicType box_type = box_klass_type();\n+\n+  if (box_type != T_OBJECT) {\n+    switch(box_type) {\n+      case T_INT:     return is_klass_initialized(java_lang_Integer_IntegerCache::symbol());\n+      case T_CHAR:    return is_klass_initialized(java_lang_Character_CharacterCache::symbol());\n+      case T_SHORT:   return is_klass_initialized(java_lang_Short_ShortCache::symbol());\n+      case T_BYTE:    return is_klass_initialized(java_lang_Byte_ByteCache::symbol());\n+      case T_LONG:    return is_klass_initialized(java_lang_Long_LongCache::symbol());\n+      case T_BOOLEAN:\n+      case T_FLOAT:\n+      case T_DOUBLE:  return true;\n+      default:;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -821,1 +846,1 @@\n-        obj = (oop) (cast_from_oop<address>(mirror) + field_offset);\n+        obj = cast_to_oop(cast_from_oop<address>(mirror) + field_offset);\n@@ -823,1 +848,1 @@\n-        obj =  mirror->obj_field_acquire(fd->offset());\n+        obj = mirror->obj_field_acquire(fd->offset());\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -280,0 +280,1 @@\n+  bool is_box_cache_valid() const;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"prims\/nativeLookup.hpp\"\n@@ -303,1 +302,1 @@\n-    EXCEPTION_MARK;\n+    ExceptionMark em(THREAD);\n@@ -747,3 +746,2 @@\n-    Klass* context = actual_recv->get_Klass();\n-    target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context,\n-                                                       root_m->get_Method()));\n+    InstanceKlass* context = actual_recv->get_instanceKlass();\n+    target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context, root_m->get_Method()));\n@@ -1016,2 +1014,1 @@\n-    _method_data->load_data();\n-    return true;\n+    return _method_data->load_data();\n@@ -1193,1 +1190,1 @@\n-    EXCEPTION_MARK;\n+    ExceptionMark em(THREAD);\n@@ -1220,1 +1217,1 @@\n-    EXCEPTION_MARK;\n+    ExceptionMark em(THREAD);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-void ciMethodData::load_data() {\n+bool ciMethodData::load_data() {\n@@ -176,1 +176,1 @@\n-    return;\n+    return false;\n@@ -266,0 +266,3 @@\n+    if (is_empty()) {\n+      return false;\n+    }\n@@ -268,0 +271,1 @@\n+  return true;\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -544,1 +544,1 @@\n-  void load_data();\n+  bool load_data();\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -853,1 +853,1 @@\n-          oop obj = (oop)(cast_from_oop<address>(_vt) + field_offset);\n+          oop obj = cast_to_oop(cast_from_oop<address>(_vt) + field_offset);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -237,0 +237,5 @@\n+  bool is_unresolved_klass_in_error() const {\n+    constantTag tag = get_constant_pool_tag(get_klass_index());\n+    return tag.is_unresolved_klass_in_error();\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -741,11 +741,10 @@\n-  BasicType basic_type = con.basic_type();\n-  if (basic_type == T_ILLEGAL) {\n-    \/\/ OutOfMemoryError in the CI while loading constant\n-    push_null();\n-    outer()->record_failure(\"ldc did not link\");\n-    return;\n-  }\n-  if (is_reference_type(basic_type)) {\n-    ciObject* obj = con.as_object();\n-    if (obj->is_null_object()) {\n-      push_null();\n+  if (con.is_valid()) {\n+    BasicType basic_type = con.basic_type();\n+    if (is_reference_type(basic_type)) {\n+      ciObject* obj = con.as_object();\n+      if (obj->is_null_object()) {\n+        push_null();\n+      } else {\n+        assert(obj->is_instance() || obj->is_array(), \"must be java_mirror of klass\");\n+        push_object(obj->klass());\n+      }\n@@ -753,2 +752,1 @@\n-      assert(obj->is_instance() || obj->is_array(), \"must be java_mirror of klass\");\n-      push_object(obj->klass());\n+      push_translate(ciType::make(basic_type));\n@@ -757,1 +755,8 @@\n-    push_translate(ciType::make(basic_type));\n+    if (str->is_unresolved_klass_in_error()) {\n+      trap(str, NULL, Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n+                                                        Deoptimization::Action_none));\n+    } else {\n+      \/\/ OutOfMemoryError in the CI while loading constant\n+      push_null();\n+      outer()->record_failure(\"ldc did not link\");\n+    }\n@@ -2229,0 +2234,2 @@\n+      return str.is_unresolved_klass_in_error();\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"classfile\/dictionary.hpp\"\n@@ -1297,2 +1296,1 @@\n-                              const bool can_access_vm_annotations,\n-                              TRAPS) {\n+                              const bool can_access_vm_annotations) {\n@@ -1475,2 +1473,1 @@\n-                          _can_access_vm_annotations,\n-                          CHECK);\n+                          _can_access_vm_annotations);\n@@ -2885,2 +2882,1 @@\n-                          _can_access_vm_annotations,\n-                          CHECK_NULL);\n+                          _can_access_vm_annotations);\n@@ -3722,1 +3718,1 @@\n-void ClassFileParser::parse_classfile_synthetic_attribute(TRAPS) {\n+void ClassFileParser::parse_classfile_synthetic_attribute() {\n@@ -3921,1 +3917,1 @@\n-      parse_classfile_synthetic_attribute(CHECK);\n+      parse_classfile_synthetic_attribute();\n@@ -3923,1 +3919,1 @@\n-      \/\/ Check for Deprecatd tag - 4276120\n+      \/\/ Check for Deprecated tag - 4276120\n@@ -3959,2 +3955,1 @@\n-                          _can_access_vm_annotations,\n-                          CHECK);\n+                          _can_access_vm_annotations);\n@@ -4230,2 +4225,1 @@\n-                                            int java_fields_count,\n-                                            TRAPS) {\n+                                            int java_fields_count) {\n@@ -5530,1 +5524,1 @@\n-      method->init_intrinsic_id();\n+      method->init_intrinsic_id(klass_id);\n@@ -5738,1 +5732,1 @@\n-  apply_parsed_class_metadata(ik, _java_fields_count, CHECK);\n+  apply_parsed_class_metadata(ik, _java_fields_count);\n@@ -5742,1 +5736,1 @@\n-    ik->set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);\n+    ik->set_nest_host(cl_inst_info.dynamic_nest_host());\n@@ -6007,2 +6001,2 @@\n-void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {\n-  ResourceMark rm(THREAD);\n+void ClassFileParser::prepend_host_package_name(Thread* current, const InstanceKlass* unsafe_anonymous_host) {\n+  ResourceMark rm(current);\n@@ -6044,1 +6038,1 @@\n-    prepend_host_package_name(_unsafe_anonymous_host, CHECK);\n+    prepend_host_package_name(THREAD, _unsafe_anonymous_host);\n@@ -6717,2 +6711,1 @@\n-                                                    _local_interfaces,\n-                                                    CHECK);\n+                                                    _local_interfaces);\n@@ -6729,1 +6722,1 @@\n-    if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE  && !fs.access_flags().is_static()) {\n+    if (Signature::basic_type(fs.signature()) == T_INLINE_TYPE && !fs.access_flags().is_static()) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":16,"deletions":23,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,1 +233,1 @@\n-  void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);\n+  void prepend_host_package_name(Thread* current, const InstanceKlass* unsafe_anonymous_host);\n@@ -250,1 +250,1 @@\n-  void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);\n+  void apply_parsed_class_metadata(InstanceKlass* k, int fields_count);\n@@ -375,1 +375,1 @@\n-  void parse_classfile_synthetic_attribute(TRAPS);\n+  void parse_classfile_synthetic_attribute();\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -95,0 +95,55 @@\n+int ClassListParser::parse(TRAPS) {\n+  int class_count = 0;\n+\n+  while (parse_one_line()) {\n+    if (lambda_form_line()) {\n+      \/\/ The current line is \"@lambda-form-invoker ...\". It has been recorded in LambdaFormInvokers,\n+      \/\/ and will be processed later.\n+      continue;\n+    }\n+\n+    TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);\n+    if (_indy_items->length() > 0) {\n+      \/\/ The current line is \"@lambda-proxy class_name\". Load the proxy class.\n+      resolve_indy(THREAD, class_name_symbol);\n+      class_count++;\n+      continue;\n+    }\n+\n+    Klass* klass = load_current_class(class_name_symbol, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      if (PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())) {\n+        \/\/ If we have run out of memory, don't try to load the rest of the classes in\n+        \/\/ the classlist. Throw an exception, which will terminate the dumping process.\n+        return 0; \/\/ THROW\n+      }\n+\n+      \/\/ We might have an invalid class name or an bad class. Warn about it\n+      \/\/ and keep going to the next line.\n+      CLEAR_PENDING_EXCEPTION;\n+      log_warning(cds)(\"Preload Warning: Cannot find %s\", _class_name);\n+      continue;\n+    }\n+\n+    assert(klass != NULL, \"sanity\");\n+    if (log_is_enabled(Trace, cds)) {\n+      ResourceMark rm(THREAD);\n+      log_trace(cds)(\"Shared spaces preloaded: %s\", klass->external_name());\n+    }\n+\n+    if (klass->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(klass);\n+\n+      \/\/ Link the class to cause the bytecodes to be rewritten and the\n+      \/\/ cpcache to be created. The linking is done as soon as classes\n+      \/\/ are loaded in order that the related data structures (klass and\n+      \/\/ cpCache) are located together.\n+      MetaspaceShared::try_link_class(THREAD, ik);\n+    }\n+\n+    class_count++;\n+  }\n+\n+  return class_count;\n+}\n+\n@@ -401,1 +456,1 @@\n-    return NULL;\n+    THROW_NULL(vmSymbols::java_lang_ClassNotFoundException());\n@@ -405,0 +460,6 @@\n+  if (k->local_interfaces()->length() != _interfaces->length()) {\n+    print_specified_interfaces();\n+    print_actual_interfaces(k);\n+    error(\"The number of interfaces (%d) specified in class list does not match the class file (%d)\",\n+          _interfaces->length(), k->local_interfaces()->length());\n+  }\n@@ -450,1 +511,1 @@\n-    bool added = SystemDictionaryShared::add_unregistered_class(k, CHECK_NULL);\n+    bool added = SystemDictionaryShared::add_unregistered_class(THREAD, k);\n@@ -461,0 +522,4 @@\n+  \/\/ This tells JVM_FindLoadedClass to not find this class.\n+  k->set_shared_classpath_index(UNREGISTERED_INDEX);\n+  k->clear_shared_class_loader_type();\n+\n@@ -481,4 +546,2 @@\n-        Klass* callee = pool->klass_at(callee_index, THREAD);\n-        if (callee != NULL) {\n-          cii->add_item(callee->name()->as_C_string());\n-        }\n+        Klass* callee = pool->klass_at(callee_index, CHECK);\n+        cii->add_item(callee->name()->as_C_string());\n@@ -497,1 +560,1 @@\n-  populate_cds_indy_info(pool, cp_index, &cii, THREAD);\n+  populate_cds_indy_info(pool, cp_index, &cii, CHECK_0);\n@@ -510,1 +573,4 @@\n-void ClassListParser::resolve_indy(Symbol* class_name_symbol, TRAPS) {\n+\n+void ClassListParser::resolve_indy(Thread* current, Symbol* class_name_symbol) {\n+  ExceptionMark em(current);\n+  Thread* THREAD = current; \/\/ For exception macros.\n@@ -513,1 +579,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -530,2 +596,2 @@\n-  Klass* klass = SystemDictionary::resolve_or_fail(class_name_symbol, class_loader, protection_domain, true, CHECK); \/\/ FIXME should really be just a lookup\n-  if (klass != NULL && klass->is_instance_klass()) {\n+  Klass* klass = SystemDictionary::resolve_or_fail(class_name_symbol, class_loader, protection_domain, true, CHECK);\n+  if (klass->is_instance_klass()) {\n@@ -533,2 +599,3 @@\n-    if (SystemDictionaryShared::has_class_failed_verification(ik)) {\n-      \/\/ don't attempt to resolve indy on classes that has previously failed verification\n+    MetaspaceShared::try_link_class(THREAD, ik);\n+    if (!ik->is_linked()) {\n+      \/\/ Verification of ik has failed\n@@ -537,1 +604,0 @@\n-    MetaspaceShared::try_link_class(ik, CHECK);\n@@ -577,9 +643,2 @@\n-Klass* ClassListParser::load_current_class(TRAPS) {\n-  TempNewSymbol class_name_symbol = SymbolTable::new_symbol(_class_name);\n-\n-  if (_indy_items->length() > 0) {\n-    resolve_indy(class_name_symbol, CHECK_NULL);\n-    return NULL;\n-  }\n-\n-  Klass* klass = NULL;\n+Klass* ClassListParser::load_current_class(Symbol* class_name_symbol, TRAPS) {\n+  Klass* klass;\n@@ -595,25 +654,1 @@\n-    bool non_array = !Signature::is_array(class_name_symbol);\n-\n-    JavaValue result(T_OBJECT);\n-    if (non_array) {\n-      \/\/ At this point, we are executing in the context of the boot loader. We\n-      \/\/ cannot call Class.forName because that is context dependent and\n-      \/\/ would load only classes for the boot loader.\n-      \/\/\n-      \/\/ Instead, let's call java_system_loader().loadClass() directly, which will\n-      \/\/ delegate to the correct loader (boot, platform or app) depending on\n-      \/\/ the class name.\n-\n-      Handle s = java_lang_String::create_from_symbol(class_name_symbol, CHECK_NULL);\n-      \/\/ ClassLoader.loadClass() wants external class name format, i.e., convert '\/' chars to '.'\n-      Handle ext_class_name = java_lang_String::externalize_classname(s, CHECK_NULL);\n-      Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());\n-\n-      JavaCalls::call_virtual(&result,\n-                              loader, \/\/SystemDictionary::java_system_loader(),\n-                              vmClasses::ClassLoader_klass(),\n-                              vmSymbols::loadClass_name(),\n-                              vmSymbols::string_class_signature(),\n-                              ext_class_name,\n-                              THREAD); \/\/ <-- failure is handled below\n-    } else {\n+    if (Signature::is_array(class_name_symbol)) {\n@@ -623,22 +658,22 @@\n-    assert(result.get_type() == T_OBJECT, \"just checking\");\n-    oop obj = (oop) result.get_jobject();\n-    if (!HAS_PENDING_EXCEPTION && (obj != NULL)) {\n-      klass = java_lang_Class::as_Klass(obj);\n-    } else { \/\/ load classes in bootclasspath\/a\n-      if (HAS_PENDING_EXCEPTION) {\n-        ArchiveUtils::check_for_oom(PENDING_EXCEPTION); \/\/ exit on OOM\n-        CLEAR_PENDING_EXCEPTION;\n-      }\n-      if (non_array) {\n-        Klass* k = SystemDictionary::resolve_or_null(class_name_symbol, CHECK_NULL);\n-        if (k != NULL) {\n-          klass = k;\n-        } else {\n-          if (!HAS_PENDING_EXCEPTION) {\n-            THROW_NULL(vmSymbols::java_lang_ClassNotFoundException());\n-          } else {\n-            ArchiveUtils::check_for_oom(PENDING_EXCEPTION); \/\/ exit on OOM\n-          }\n-        }\n-      }\n-    }\n+    JavaValue result(T_OBJECT);\n+    \/\/ Call java_system_loader().loadClass() directly, which will\n+    \/\/ delegate to the correct loader (boot, platform or app) depending on\n+    \/\/ the package name.\n+\n+    Handle s = java_lang_String::create_from_symbol(class_name_symbol, CHECK_NULL);\n+    \/\/ ClassLoader.loadClass() wants external class name format, i.e., convert '\/' chars to '.'\n+    Handle ext_class_name = java_lang_String::externalize_classname(s, CHECK_NULL);\n+    Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());\n+\n+    JavaCalls::call_virtual(&result,\n+                            loader, \/\/SystemDictionary::java_system_loader(),\n+                            vmClasses::ClassLoader_klass(),\n+                            vmSymbols::loadClass_name(),\n+                            vmSymbols::string_class_signature(),\n+                            ext_class_name,\n+                            CHECK_NULL);\n+\n+    assert(result.get_type() == T_OBJECT, \"just checking\");\n+    oop obj = result.get_oop();\n+    assert(obj != NULL, \"jdk.internal.loader.BuiltinClassLoader::loadClass never returns null\");\n+    klass = java_lang_Class::as_Klass(obj);\n@@ -650,3 +685,0 @@\n-    if (HAS_PENDING_EXCEPTION) {\n-      ArchiveUtils::check_for_oom(PENDING_EXCEPTION); \/\/ exit on OOM\n-    }\n@@ -655,1 +687,4 @@\n-  if (klass != NULL && klass->is_instance_klass() && is_id_specified()) {\n+  assert(klass != NULL, \"exception should have been thrown\");\n+  assert(klass->is_instance_klass(), \"array classes should have been filtered out\");\n+\n+  if (is_id_specified()) {\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":109,"deletions":74,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-ClassFileStream* ClassPathDirEntry::open_stream(const char* name, TRAPS) {\n+ClassFileStream* ClassPathDirEntry::open_stream(Thread* current, const char* name) {\n@@ -244,1 +244,1 @@\n-  char* path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, path_len);\n+  char* path = NEW_RESOURCE_ARRAY_IN_THREAD(current, char, path_len);\n@@ -288,4 +288,3 @@\n-u1* ClassPathZipEntry::open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS) {\n-    \/\/ enable call to C land\n-  JavaThread* thread = THREAD->as_Java_thread();\n-  ThreadToNativeFromVM ttn(thread);\n+u1* ClassPathZipEntry::open_entry(Thread* current, const char* name, jint* filesize, bool nul_terminate) {\n+  \/\/ enable call to C land\n+  ThreadToNativeFromVM ttn(current->as_Java_thread());\n@@ -317,1 +316,1 @@\n-ClassFileStream* ClassPathZipEntry::open_stream(const char* name, TRAPS) {\n+ClassFileStream* ClassPathZipEntry::open_stream(Thread* current, const char* name) {\n@@ -319,1 +318,1 @@\n-  u1* buffer = open_entry(name, &filesize, false, CHECK_NULL);\n+  u1* buffer = open_entry(current, name, &filesize, false);\n@@ -377,2 +376,2 @@\n-ClassFileStream* ClassPathImageEntry::open_stream(const char* name, TRAPS) {\n-  return open_stream_for_loader(name, ClassLoaderData::the_null_class_loader_data(), THREAD);\n+ClassFileStream* ClassPathImageEntry::open_stream(Thread* current, const char* name) {\n+  return open_stream_for_loader(current, name, ClassLoaderData::the_null_class_loader_data());\n@@ -388,1 +387,1 @@\n-ClassFileStream* ClassPathImageEntry::open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS) {\n+ClassFileStream* ClassPathImageEntry::open_stream_for_loader(Thread* current, const char* name, ClassLoaderData* loader_data) {\n@@ -402,1 +401,1 @@\n-          ResourceMark rm(THREAD);\n+          ResourceMark rm(current);\n@@ -504,1 +503,1 @@\n-void ClassLoader::setup_bootstrap_search_path(TRAPS) {\n+void ClassLoader::setup_bootstrap_search_path(Thread* current) {\n@@ -513,1 +512,1 @@\n-  setup_bootstrap_search_path_impl(sys_class_path, CHECK);\n+  setup_bootstrap_search_path_impl(current, sys_class_path);\n@@ -517,1 +516,1 @@\n-void ClassLoader::setup_app_search_path(const char *class_path, TRAPS) {\n+void ClassLoader::setup_app_search_path(Thread* current, const char *class_path) {\n@@ -520,1 +519,1 @@\n-  ResourceMark rm;\n+  ResourceMark rm(current);\n@@ -525,1 +524,1 @@\n-    update_class_path_entry_list(path, false, false, false, CHECK);\n+    update_class_path_entry_list(current, path, false, false, false);\n@@ -545,1 +544,1 @@\n-void ClassLoader::setup_module_search_path(const char* path, TRAPS) {\n+void ClassLoader::setup_module_search_path(Thread* current, const char* path) {\n@@ -555,4 +554,4 @@\n-  new_entry = create_class_path_entry(path, &st, true \/* throw_exception *\/,\n-                                      false \/*is_boot_append *\/, false \/* from_class_path_attr *\/, CHECK);\n-  if (new_entry == NULL) {\n-    return;\n+  new_entry = create_class_path_entry(current, path, &st,\n+                                      false \/*is_boot_append *\/, false \/* from_class_path_attr *\/);\n+  if (new_entry != NULL) {\n+    add_to_module_path_entries(path, new_entry);\n@@ -560,3 +559,0 @@\n-\n-  add_to_module_path_entries(path, new_entry);\n-  return;\n@@ -599,1 +595,1 @@\n-        ClassPathEntry* new_entry = create_class_path_entry(path, &st, false, false, false, CHECK);\n+        ClassPathEntry* new_entry = create_class_path_entry(THREAD, path, &st, false, false);\n@@ -631,2 +627,2 @@\n-void ClassLoader::setup_bootstrap_search_path_impl(const char *class_path, TRAPS) {\n-  ResourceMark rm(THREAD);\n+void ClassLoader::setup_bootstrap_search_path_impl(Thread* current, const char *class_path) {\n+  ResourceMark rm(current);\n@@ -656,1 +652,1 @@\n-        ClassPathEntry* new_entry = create_class_path_entry(path, &st, false, false, false, CHECK);\n+        ClassPathEntry* new_entry = create_class_path_entry(current, path, &st, false, false);\n@@ -673,1 +669,1 @@\n-      update_class_path_entry_list(path, false, true, false, CHECK);\n+      update_class_path_entry_list(current, path, false, true, false);\n@@ -680,1 +676,1 @@\n-void ClassLoader::add_to_exploded_build_list(Symbol* module_sym, TRAPS) {\n+void ClassLoader::add_to_exploded_build_list(Thread* current, Symbol* module_sym) {\n@@ -685,1 +681,1 @@\n-  ResourceMark rm(THREAD);\n+  ResourceMark rm(current);\n@@ -697,1 +693,1 @@\n-    ClassPathEntry* new_entry = create_class_path_entry(path, &st, false, false, false, CHECK);\n+    ClassPathEntry* new_entry = create_class_path_entry(current, path, &st, false, false);\n@@ -707,1 +703,1 @@\n-        MutexLocker ml(THREAD, Module_lock);\n+        MutexLocker ml(current, Module_lock);\n@@ -723,2 +719,2 @@\n-ClassPathEntry* ClassLoader::create_class_path_entry(const char *path, const struct stat* st,\n-                                                     bool throw_exception,\n+ClassPathEntry* ClassLoader::create_class_path_entry(Thread* current,\n+                                                     const char *path, const struct stat* st,\n@@ -726,3 +722,2 @@\n-                                                     bool from_class_path_attr,\n-                                                     TRAPS) {\n-  JavaThread* thread = THREAD->as_Java_thread();\n+                                                     bool from_class_path_attr) {\n+  JavaThread* thread = current->as_Java_thread();\n@@ -736,6 +731,1 @@\n-      \/\/ This matches the classic VM\n-      if (throw_exception) {\n-        THROW_MSG_(vmSymbols::java_io_IOException(), \"Bad pathname\", NULL);\n-      } else {\n-        return NULL;\n-      }\n+      return NULL;\n@@ -753,15 +743,1 @@\n-        char *msg;\n-        if (error_msg == NULL) {\n-          msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(path) + 128); ;\n-          jio_snprintf(msg, strlen(path) + 127, \"error in opening JAR file %s\", path);\n-        } else {\n-          int len = (int)(strlen(path) + strlen(error_msg) + 128);\n-          msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, len); ;\n-          jio_snprintf(msg, len - 1, \"error in opening JAR file <%s> %s\", error_msg, path);\n-        }\n-        \/\/ Don't complain about bad jar files added via -Xbootclasspath\/a:.\n-        if (throw_exception && is_init_completed()) {\n-          THROW_MSG_(vmSymbols::java_lang_ClassNotFoundException(), msg, NULL);\n-        } else {\n-          return NULL;\n-        }\n+        return NULL;\n@@ -804,13 +780,0 @@\n-\/\/ returns true if entry already on class path\n-bool ClassLoader::contains_append_entry(const char* name) {\n-  ClassPathEntry* e = first_append_entry();\n-  while (e != NULL) {\n-    \/\/ assume zip entries have been canonicalized\n-    if (strcmp(name, e->name()) == 0) {\n-      return true;\n-    }\n-    e = e->next();\n-  }\n-  return false;\n-}\n-\n@@ -838,1 +801,2 @@\n-void ClassLoader::add_to_app_classpath_entries(const char* path,\n+void ClassLoader::add_to_app_classpath_entries(Thread* current,\n+                                               const char* path,\n@@ -840,2 +804,1 @@\n-                                               bool check_for_duplicates,\n-                                               TRAPS) {\n+                                               bool check_for_duplicates) {\n@@ -865,1 +828,1 @@\n-    ClassLoaderExt::process_jar_manifest(entry, check_for_duplicates, CHECK);\n+    ClassLoaderExt::process_jar_manifest(current, entry, check_for_duplicates);\n@@ -871,1 +834,2 @@\n-bool ClassLoader::update_class_path_entry_list(const char *path,\n+bool ClassLoader::update_class_path_entry_list(Thread* current,\n+                                               const char *path,\n@@ -874,2 +838,1 @@\n-                                               bool from_class_path_attr,\n-                                               TRAPS) {\n+                                               bool from_class_path_attr) {\n@@ -880,1 +843,1 @@\n-    new_entry = create_class_path_entry(path, &st, \/*throw_exception=*\/true, is_boot_append, from_class_path_attr, CHECK_false);\n+    new_entry = create_class_path_entry(current, path, &st, is_boot_append, from_class_path_attr);\n@@ -890,1 +853,1 @@\n-      add_to_app_classpath_entries(path, new_entry, check_for_duplicates, CHECK_false);\n+      add_to_app_classpath_entries(current, path, new_entry, check_for_duplicates);\n@@ -1120,1 +1083,2 @@\n-ClassFileStream* ClassLoader::search_module_entries(const GrowableArray<ModuleClassPathList*>* const module_list,\n+ClassFileStream* ClassLoader::search_module_entries(Thread* current,\n+                                                    const GrowableArray<ModuleClassPathList*>* const module_list,\n@@ -1122,2 +1086,1 @@\n-                                                    const char* const file_name,\n-                                                    TRAPS) {\n+                                                    const char* const file_name) {\n@@ -1150,1 +1113,1 @@\n-      MutexLocker ml(THREAD, Module_lock);\n+      MutexLocker ml(current, Module_lock);\n@@ -1159,1 +1122,1 @@\n-    stream = e->open_stream(file_name, CHECK_NULL);\n+    stream = e->open_stream(current, file_name);\n@@ -1222,1 +1185,1 @@\n-      stream = search_module_entries(_patch_mod_entries, class_name, file_name, CHECK_NULL);\n+      stream = search_module_entries(THREAD, _patch_mod_entries, class_name, file_name);\n@@ -1230,1 +1193,1 @@\n-      stream = _jrt_entry->open_stream(file_name, CHECK_NULL);\n+      stream = _jrt_entry->open_stream(THREAD, file_name);\n@@ -1234,1 +1197,1 @@\n-      stream = search_module_entries(_exploded_entries, class_name, file_name, CHECK_NULL);\n+      stream = search_module_entries(THREAD, _exploded_entries, class_name, file_name);\n@@ -1248,1 +1211,1 @@\n-      stream = e->open_stream(file_name, CHECK_NULL);\n+      stream = e->open_stream(THREAD, file_name);\n@@ -1271,8 +1234,1 @@\n-                                                           THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    if (DumpSharedSpaces) {\n-      log_error(cds)(\"Preload Error: Failed to load %s\", class_name);\n-    }\n-    return NULL;\n-  }\n-\n+                                                           CHECK_NULL);\n@@ -1305,1 +1261,1 @@\n-void ClassLoader::record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS) {\n+void ClassLoader::record_result(Thread* current, InstanceKlass* ik, const ClassFileStream* stream) {\n@@ -1327,1 +1283,1 @@\n-  ResourceMark rm(THREAD);\n+  ResourceMark rm(current);\n@@ -1411,1 +1367,1 @@\n-  ClassLoaderExt::record_result(classpath_index, ik, CHECK);\n+  ClassLoaderExt::record_result(classpath_index, ik);\n@@ -1452,1 +1408,1 @@\n-  setup_bootstrap_search_path(CHECK);\n+  setup_bootstrap_search_path(THREAD);\n@@ -1489,1 +1445,1 @@\n-void ClassLoader::initialize_shared_path(TRAPS) {\n+void ClassLoader::initialize_shared_path(Thread* current) {\n@@ -1491,1 +1447,1 @@\n-    ClassLoaderExt::setup_search_paths(CHECK);\n+    ClassLoaderExt::setup_search_paths(current);\n@@ -1497,1 +1453,1 @@\n-    ClassLoaderExt::setup_module_paths(CHECK);\n+    ClassLoaderExt::setup_module_paths(THREAD);\n@@ -1562,1 +1518,1 @@\n-void ClassLoader::classLoader_init2(TRAPS) {\n+void ClassLoader::classLoader_init2(Thread* current) {\n@@ -1587,1 +1543,1 @@\n-    add_to_exploded_build_list(vmSymbols::java_base(), CHECK);\n+    add_to_exploded_build_list(current, vmSymbols::java_base());\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":64,"deletions":108,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -950,7 +950,10 @@\n-void ClassLoaderData::print_on(outputStream* out) const {\n-  out->print(\"ClassLoaderData CLD: \" PTR_FORMAT \", loader: \" PTR_FORMAT \", loader_klass: %s {\",\n-              p2i(this), p2i(_class_loader.ptr_raw()), loader_name_and_id());\n-  if (has_class_mirror_holder()) out->print(\" has a class holder\");\n-  if (claimed()) out->print(\" claimed\");\n-  if (is_unloading()) out->print(\" unloading\");\n-  out->print(\" metaspace: \" INTPTR_FORMAT, p2i(metaspace_or_null()));\n+class PrintKlassClosure: public KlassClosure {\n+  outputStream* _out;\n+public:\n+  PrintKlassClosure(outputStream* out): _out(out) { }\n+\n+  void do_klass(Klass* k) {\n+    ResourceMark rm;\n+    _out->print(\"%s,\", k->external_name());\n+  }\n+};\n@@ -958,0 +961,33 @@\n+void ClassLoaderData::print_on(outputStream* out) const {\n+  ResourceMark rm;\n+  out->print_cr(\"ClassLoaderData(\" INTPTR_FORMAT \")\", p2i(this));\n+  out->print_cr(\" - name                %s\", loader_name_and_id());\n+  if (!_holder.is_null()) {\n+    out->print   (\" - holder              \");\n+    _holder.print_on(out);\n+    out->print_cr(\"\");\n+  }\n+  out->print_cr(\" - class loader        \" INTPTR_FORMAT, p2i(_class_loader.ptr_raw()));\n+  out->print_cr(\" - metaspace           \" INTPTR_FORMAT, p2i(_metaspace));\n+  out->print_cr(\" - unloading           %s\", _unloading ? \"true\" : \"false\");\n+  out->print_cr(\" - class mirror holder %s\", _has_class_mirror_holder ? \"true\" : \"false\");\n+  out->print_cr(\" - modified oops       %s\", _modified_oops ? \"true\" : \"false\");\n+  out->print_cr(\" - keep alive          %d\", _keep_alive);\n+  out->print   (\" - claim               \");\n+  switch(_claim) {\n+    case _claim_none:       out->print_cr(\"none\"); break;\n+    case _claim_finalizable:out->print_cr(\"finalizable\"); break;\n+    case _claim_strong:     out->print_cr(\"strong\"); break;\n+    case _claim_other:      out->print_cr(\"other\"); break;\n+    default:                ShouldNotReachHere();\n+  }\n+  out->print_cr(\" - handles             %d\", _handles.count());\n+  out->print_cr(\" - dependency count    %d\", _dependency_count);\n+  out->print   (\" - klasses             {\");\n+  PrintKlassClosure closure(out);\n+  ((ClassLoaderData*)this)->classes_do(&closure);\n+  out->print_cr(\" }\");\n+  out->print_cr(\" - packages            \" INTPTR_FORMAT, p2i(_packages));\n+  out->print_cr(\" - module              \" INTPTR_FORMAT, p2i(_modules));\n+  out->print_cr(\" - unnamed module      \" INTPTR_FORMAT, p2i(_unnamed_module));\n+  out->print_cr(\" - dictionary          \" INTPTR_FORMAT, p2i(_dictionary));\n@@ -959,1 +995,3 @@\n-    Method::print_jmethod_ids(this, out);\n+    out->print   (\" - jmethod count       \");\n+    Method::print_jmethod_ids_count(this, out);\n+    out->print_cr(\"\");\n@@ -961,3 +999,2 @@\n-  out->print(\" handles count %d\", _handles.count());\n-  out->print(\" dependencies %d\", _dependency_count);\n-  out->print_cr(\"}\");\n+  out->print_cr(\" - deallocate list     \" INTPTR_FORMAT, p2i(_deallocate_list));\n+  out->print_cr(\" - next CLD            \" INTPTR_FORMAT, p2i(_next));\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -830,0 +830,66 @@\n+#ifdef ASSERT\n+inline static void assert_valid_static_string_field(fieldDescriptor* fd) {\n+  assert(fd->has_initial_value(), \"caller should have checked this\");\n+  assert(fd->field_type() == T_OBJECT, \"caller should have checked this\");\n+  \/\/ Can't use vmSymbols::string_signature() as fd->signature() may have been relocated\n+  \/\/ during DumpSharedSpaces\n+  assert(fd->signature()->equals(\"Ljava\/lang\/String;\"), \"just checking\");\n+}\n+#endif\n+\n+static void initialize_static_string_field(fieldDescriptor* fd, Handle mirror, TRAPS) {\n+  DEBUG_ONLY(assert_valid_static_string_field(fd);)\n+  oop string = fd->string_initial_value(CHECK);\n+  mirror()->obj_field_put(fd->offset(), string);\n+}\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+static void initialize_static_string_field_for_dump(fieldDescriptor* fd, Handle mirror) {\n+  DEBUG_ONLY(assert_valid_static_string_field(fd);)\n+  assert(DumpSharedSpaces, \"must be\");\n+  if (HeapShared::is_archived_object(mirror())) {\n+    \/\/ Archive the String field and update the pointer.\n+    oop s = mirror()->obj_field(fd->offset());\n+    oop archived_s = StringTable::create_archived_string(s);\n+    mirror()->obj_field_put(fd->offset(), archived_s);\n+  } else {\n+    guarantee(false, \"Unexpected\");\n+  }\n+}\n+#endif\n+\n+static void initialize_static_primitive_field(fieldDescriptor* fd, Handle mirror) {\n+  assert(fd->has_initial_value(), \"caller should have checked this\");\n+  BasicType t = fd->field_type();\n+  switch (t) {\n+  case T_BYTE:\n+    mirror()->byte_field_put(fd->offset(), fd->int_initial_value());\n+    break;\n+  case T_BOOLEAN:\n+    mirror()->bool_field_put(fd->offset(), fd->int_initial_value());\n+    break;\n+  case T_CHAR:\n+    mirror()->char_field_put(fd->offset(), fd->int_initial_value());\n+    break;\n+  case T_SHORT:\n+    mirror()->short_field_put(fd->offset(), fd->int_initial_value());\n+    break;\n+  case T_INT:\n+    mirror()->int_field_put(fd->offset(), fd->int_initial_value());\n+    break;\n+  case T_FLOAT:\n+    mirror()->float_field_put(fd->offset(), fd->float_initial_value());\n+    break;\n+  case T_DOUBLE:\n+    mirror()->double_field_put(fd->offset(), fd->double_initial_value());\n+    break;\n+  case T_LONG:\n+    mirror()->long_field_put(fd->offset(), fd->long_initial_value());\n+    break;\n+  default:\n+    \/\/ Illegal ConstantValue attribute in class file should have been\n+    \/\/ caught during classfile parsing.\n+    ShouldNotReachHere();\n+  }\n+}\n+\n@@ -833,46 +899,4 @@\n-    BasicType t = fd->field_type();\n-    switch (t) {\n-      case T_BYTE:\n-        mirror()->byte_field_put(fd->offset(), fd->int_initial_value());\n-              break;\n-      case T_BOOLEAN:\n-        mirror()->bool_field_put(fd->offset(), fd->int_initial_value());\n-              break;\n-      case T_CHAR:\n-        mirror()->char_field_put(fd->offset(), fd->int_initial_value());\n-              break;\n-      case T_SHORT:\n-        mirror()->short_field_put(fd->offset(), fd->int_initial_value());\n-              break;\n-      case T_INT:\n-        mirror()->int_field_put(fd->offset(), fd->int_initial_value());\n-        break;\n-      case T_FLOAT:\n-        mirror()->float_field_put(fd->offset(), fd->float_initial_value());\n-        break;\n-      case T_DOUBLE:\n-        mirror()->double_field_put(fd->offset(), fd->double_initial_value());\n-        break;\n-      case T_LONG:\n-        mirror()->long_field_put(fd->offset(), fd->long_initial_value());\n-        break;\n-      case T_OBJECT:\n-        {\n-          \/\/ Can't use vmSymbols::string_signature() as fd->signature() may have been relocated\n-          \/\/ during DumpSharedSpaces\n-          assert(fd->signature()->equals(\"Ljava\/lang\/String;\"),\n-                 \"just checking\");\n-          if (DumpSharedSpaces && HeapShared::is_archived_object(mirror())) {\n-            \/\/ Archive the String field and update the pointer.\n-            oop s = mirror()->obj_field(fd->offset());\n-            oop archived_s = StringTable::create_archived_string(s);\n-            mirror()->obj_field_put(fd->offset(), archived_s);\n-          } else {\n-            oop string = fd->string_initial_value(CHECK);\n-            mirror()->obj_field_put(fd->offset(), string);\n-          }\n-        }\n-        break;\n-      default:\n-        THROW_MSG(vmSymbols::java_lang_ClassFormatError(),\n-                  \"Illegal ConstantValue attribute in class file\");\n+    if (fd->field_type() != T_OBJECT) {\n+      initialize_static_primitive_field(fd, mirror);\n+    } else {\n+      initialize_static_string_field(fd, mirror, CHECK);\n@@ -883,0 +907,12 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+static void initialize_static_field_for_dump(fieldDescriptor* fd, Handle mirror) {\n+  assert(mirror.not_null() && fd->is_static(), \"just checking\");\n+  if (fd->has_initial_value()) {\n+    if (fd->field_type() != T_OBJECT) {\n+      initialize_static_primitive_field(fd, mirror);\n+    } else {\n+      initialize_static_string_field_for_dump(fd, mirror);\n+    }\n+  }\n+}\n+#endif\n@@ -937,1 +973,1 @@\n-void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {\n+void java_lang_Class::set_mirror_module_field(JavaThread* current, Klass* k, Handle mirror, Handle module) {\n@@ -946,1 +982,1 @@\n-      MutexLocker m1(THREAD, Module_lock);\n+      MutexLocker m1(current, Module_lock);\n@@ -963,1 +999,1 @@\n-      Handle javabase_handle(THREAD, javabase_entry->module());\n+      Handle javabase_handle(current, javabase_entry->module());\n@@ -996,1 +1032,1 @@\n-  int computed_modifiers = k->compute_modifier_flags(CHECK);\n+  int computed_modifiers = k->compute_modifier_flags();\n@@ -1061,1 +1097,1 @@\n-    set_mirror_module_field(k, mirror, module, THREAD);\n+    set_mirror_module_field(THREAD->as_Java_thread(), k, mirror, module);\n@@ -1090,1 +1126,1 @@\n-      initialize_static_field(fd, _m, Thread::current());\n+      initialize_static_field_for_dump(fd, _m);\n@@ -1375,1 +1411,1 @@\n-  set_mirror_module_field(k, mirror, module, THREAD);\n+  set_mirror_module_field(THREAD->as_Java_thread(), k, mirror, module);\n@@ -1454,1 +1490,1 @@\n-  java_class->obj_field_put(_signers_offset, (oop)signers);\n+  java_class->obj_field_put(_signers_offset, signers);\n@@ -1983,0 +2019,1 @@\n+int java_lang_Throwable::_cause_offset;\n@@ -1990,0 +2027,1 @@\n+  macro(_cause_offset,         k, \"cause\",         throwable_signature,               false); \\\n@@ -2030,0 +2068,3 @@\n+oop java_lang_Throwable::cause(oop throwable) {\n+  return throwable->obj_field(_cause_offset);\n+}\n@@ -2402,1 +2443,1 @@\n-      EXCEPTION_MARK;\n+      ExceptionMark em(THREAD);\n@@ -2415,1 +2456,1 @@\n-        throwable = Handle(THREAD, (oop) cause.get_jobject());\n+        throwable = Handle(THREAD, cause.get_oop());\n@@ -2865,1 +2906,1 @@\n-  MethodHandles::init_method_MemberName(mname, info, THREAD);\n+  MethodHandles::init_method_MemberName(mname, info);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":98,"deletions":57,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-  static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);\n+  static void set_mirror_module_field(JavaThread* current, Klass* K, Handle mirror, Handle module);\n@@ -502,0 +502,1 @@\n+  static int _cause_offset;\n@@ -519,0 +520,1 @@\n+  static oop cause(oop throwable);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-  Hashtable<Symbol*, mtClass>::free_entry(entry);\n+  BasicHashtable<mtClass>::free_entry(entry);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-    const methodHandle& m, VerificationType thisKlass, TRAPS) {\n+    const methodHandle& m, VerificationType thisKlass) {\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-  _java_system_loader = OopHandle(Universe::vm_global(), (oop)result.get_jobject());\n+  _java_system_loader = OopHandle(Universe::vm_global(), result.get_oop());\n@@ -141,1 +141,1 @@\n-  _java_platform_loader = OopHandle(Universe::vm_global(), (oop)result.get_jobject());\n+  _java_platform_loader = OopHandle(Universe::vm_global(), result.get_oop());\n@@ -332,1 +332,12 @@\n-\/\/ Must be called for any super-class or super-interface resolution\n+static inline void log_circularity_error(Thread* thread, PlaceholderEntry* probe) {\n+  LogTarget(Debug, class, load, placeholders) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm(thread);\n+    LogStream ls(lt);\n+    ls.print(\"ClassCircularityError detected for placeholder \");\n+    probe->print_entry(&ls);\n+    ls.cr();\n+  }\n+}\n+\n+\/\/ Must be called for any superclass or superinterface resolution\n@@ -334,4 +345,4 @@\n-\/\/ super-interface callers:\n-\/\/    parse_interfaces - for defineClass\n-\/\/ super-class callers:\n-\/\/   ClassFileParser - for defineClass\n+\/\/ superinterface callers:\n+\/\/    parse_interfaces - from defineClass\n+\/\/ superclass callers:\n+\/\/   ClassFileParser - from defineClass\n@@ -343,25 +354,9 @@\n-\/\/      if another thread is trying to resolve the class, it must do\n-\/\/      super-class checks on its own thread to catch class circularity\n-\/\/ This last call is critical in class circularity checking for cases\n-\/\/ where classloading is delegated to different threads and the\n-\/\/ classloader lock is released.\n-\/\/ Take the case: Base->Super->Base\n-\/\/   1. If thread T1 tries to do a defineClass of class Base\n-\/\/    resolve_super_or_fail creates placeholder: T1, Base (super Super)\n-\/\/   2. resolve_instance_class_or_null does not find SD or placeholder for Super\n-\/\/    so it tries to load Super\n-\/\/   3. If we load the class internally, or user classloader uses same thread\n-\/\/      loadClassFromxxx or defineClass via parseClassFile Super ...\n-\/\/      3.1 resolve_super_or_fail creates placeholder: T1, Super (super Base)\n-\/\/      3.3 resolve_instance_class_or_null Base, finds placeholder for Base\n-\/\/      3.4 calls resolve_super_or_fail Base\n-\/\/      3.5 finds T1,Base -> throws class circularity\n-\/\/OR 4. If T2 tries to resolve Super via defineClass Super ...\n-\/\/      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)\n-\/\/      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)\n-\/\/      4.3 calls resolve_super_or_fail Super in parallel on own thread T2\n-\/\/      4.4 finds T2, Super -> throws class circularity\n-\/\/ Be careful when modifying this code: once you have run\n-\/\/ placeholders()->find_and_add(PlaceholderTable::LOAD_SUPER),\n-\/\/ you need to find_and_remove it before returning.\n-\/\/ So be careful to not exit with a CHECK_ macro between these calls.\n+\/\/      If another thread is trying to resolve the class, it must do\n+\/\/      superclass checks on its own thread to catch class circularity and\n+\/\/      to avoid deadlock.\n+\/\/\n+\/\/ resolve_super_or_fail adds a LOAD_SUPER placeholder to the placeholder table before calling\n+\/\/ resolve_instance_class_or_null. ClassCircularityError is detected when a LOAD_SUPER or LOAD_INSTANCE\n+\/\/ placeholder for the same thread, class, classloader is found.\n+\/\/ This can be seen with logging option: -Xlog:class+load+placeholders=debug.\n+\/\/\n@@ -374,1 +369,3 @@\n-  assert(!Signature::is_array(super_name), \"invalid super class name\");\n+\n+  assert(super_name != NULL, \"null superclass for resolving\");\n+  assert(!Signature::is_array(super_name), \"invalid superclass name\");\n@@ -386,14 +383,4 @@\n-  \/\/ Double-check, if klass is already loaded, just return super-class,interface\n-  \/\/ Don't add a placedholder if already loaded, i.e. already in appropriate class loader\n-  \/\/ dictionary.\n-  \/\/ Make sure there's a placeholder for the *klass* before resolving.\n-  \/\/ Used as a claim that this thread is currently loading superclass\/classloader\n-  \/\/ Used here for ClassCircularity checks and also for heap verification\n-  \/\/ (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).\n-  \/\/ Must check ClassCircularity before checking if super class is already loaded.\n-  \/\/\n-  \/\/ We might not already have a placeholder if this class_name was\n-  \/\/ first seen via resolve_from_stream (jni_DefineClass or JVM_DefineClass);\n-  \/\/ the name of the class might not be known until the stream is actually\n-  \/\/ parsed.\n-  \/\/ Bugs 4643874, 4715493\n+  \/\/ If klass is already loaded, just return the superclass or superinterface.\n+  \/\/ Make sure there's a placeholder for the class_name before resolving.\n+  \/\/ This is used as a claim that this thread is currently loading superclass\/classloader\n+  \/\/ and for ClassCircularity checks.\n@@ -405,0 +392,1 @@\n+\n@@ -420,0 +408,1 @@\n+      \/\/ Must check ClassCircularity before checking if superclass is already loaded.\n@@ -422,0 +411,1 @@\n+          log_circularity_error(THREAD, probe);\n@@ -425,0 +415,1 @@\n+\n@@ -427,1 +418,5 @@\n-      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, class_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);\n+      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash,\n+                                                                class_name,\n+                                                                loader_data,\n+                                                                PlaceholderTable::LOAD_SUPER,\n+                                                                super_name, THREAD);\n@@ -430,0 +425,1 @@\n+\n@@ -435,3 +431,1 @@\n-  \/\/ java.lang.Object should have been found above\n-  assert(super_name != NULL, \"null super class for resolving\");\n-  \/\/ Resolve the super class or interface, check results on return\n+  \/\/ Resolve the superclass or superinterface, check results on return\n@@ -444,6 +438,1 @@\n-  \/\/ Clean up of placeholders moved so that each classloadAction registrar self-cleans up\n-  \/\/ It is no longer necessary to keep the placeholder table alive until update_dictionary\n-  \/\/ or error. GC used to walk the placeholder table as strong roots.\n-  \/\/ The instanceKlass is kept alive because the class loader is on the stack,\n-  \/\/ which keeps the loader_data alive, as well as all instanceKlasses in\n-  \/\/ the loader_data. parseClassFile adds the instanceKlass to loader_data.\n+  \/\/ Clean up placeholder entry.\n@@ -508,67 +497,0 @@\n-void SystemDictionary::validate_protection_domain(InstanceKlass* klass,\n-                                                  Handle class_loader,\n-                                                  Handle protection_domain,\n-                                                  TRAPS) {\n-  \/\/ Now we have to call back to java to check if the initating class has access\n-  assert(class_loader() != NULL, \"Should not call this\");\n-  assert(protection_domain() != NULL, \"Should not call this\");\n-\n-  \/\/ We only have to call checkPackageAccess if there's a security manager installed.\n-  if (java_lang_System::has_security_manager()) {\n-\n-    \/\/ This handle and the class_loader handle passed in keeps this class from\n-    \/\/ being unloaded through several GC points.\n-    \/\/ The class_loader handle passed in is the initiating loader.\n-    Handle mirror(THREAD, klass->java_mirror());\n-\n-    InstanceKlass* system_loader = vmClasses::ClassLoader_klass();\n-    JavaValue result(T_VOID);\n-    JavaCalls::call_special(&result,\n-                           class_loader,\n-                           system_loader,\n-                           vmSymbols::checkPackageAccess_name(),\n-                           vmSymbols::class_protectiondomain_signature(),\n-                           mirror,\n-                           protection_domain,\n-                           THREAD);\n-\n-    LogTarget(Debug, protectiondomain) lt;\n-    if (lt.is_enabled()) {\n-      ResourceMark rm(THREAD);\n-      \/\/ Print out trace information\n-      LogStream ls(lt);\n-      ls.print_cr(\"Checking package access\");\n-      ls.print(\"class loader: \");\n-      class_loader()->print_value_on(&ls);\n-      ls.print(\" protection domain: \");\n-      protection_domain()->print_value_on(&ls);\n-      ls.print(\" loading: \"); klass->print_value_on(&ls);\n-      if (HAS_PENDING_EXCEPTION) {\n-        ls.print_cr(\" DENIED !!!!!!!!!!!!!!!!!!!!!\");\n-      } else {\n-        ls.print_cr(\" granted\");\n-      }\n-    }\n-\n-    if (HAS_PENDING_EXCEPTION) return;\n-  }\n-\n-  \/\/ If no exception has been thrown, we have validated the protection domain\n-  \/\/ Insert the protection domain of the initiating class into the set.\n-  \/\/ We still have to add the protection_domain to the dictionary in case a new\n-  \/\/ security manager is installed later. Calls to load the same class with class loader\n-  \/\/ and protection domain are expected to succeed.\n-  {\n-    ClassLoaderData* loader_data = class_loader_data(class_loader);\n-    Dictionary* dictionary = loader_data->dictionary();\n-\n-    Symbol*  kn = klass->name();\n-    unsigned int name_hash = dictionary->compute_hash(kn);\n-\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-    int d_index = dictionary->hash_to_index(name_hash);\n-    dictionary->add_protection_domain(d_index, name_hash, klass,\n-                                      protection_domain, THREAD);\n-  }\n-}\n-\n@@ -599,1 +521,1 @@\n-void SystemDictionary::double_lock_wait(Thread* thread, Handle lockObject) {\n+static void double_lock_wait(JavaThread* thread, Handle lockObject) {\n@@ -604,1 +526,1 @@\n-      = ObjectSynchronizer::current_thread_holds_lock(thread->as_Java_thread(), lockObject);\n+      = ObjectSynchronizer::current_thread_holds_lock(thread, lockObject);\n@@ -616,1 +538,1 @@\n-\/\/ If the class in is in the placeholder table, class loading is in progress\n+\/\/ If the class in is in the placeholder table, class loading is in progress.\n@@ -619,14 +541,7 @@\n-\/\/ the superclass on the same thread internally, so we do parallel\n-\/\/ super class loading here.\n-\/\/ This also is critical in cases where the original thread gets stalled\n-\/\/ even in non-circularity situations.\n-\/\/ Returns non-null Klass* if other thread has completed load\n-\/\/ and we are done.  If this returns a null Klass* and no pending exception,\n-\/\/ the caller must load the class.\n-InstanceKlass* SystemDictionary::handle_parallel_super_load(\n-    Symbol* name, Symbol* superclassname, Handle class_loader,\n-    Handle protection_domain, Handle lockObject, TRAPS) {\n-\n-  ClassLoaderData* loader_data = class_loader_data(class_loader);\n-  Dictionary* dictionary = loader_data->dictionary();\n-  unsigned int name_hash = dictionary->compute_hash(name);\n+\/\/ the superclass on the new thread internally, so we do parallel\n+\/\/ superclass loading here.  This avoids deadlock for ClassCircularity\n+\/\/ detection for parallelCapable class loaders that lock on a per-class lock.\n+static void handle_parallel_super_load(Symbol* name,\n+                                       Symbol* superclassname,\n+                                       Handle class_loader,\n+                                       Handle protection_domain, TRAPS) {\n@@ -640,20 +555,25 @@\n-                                                          CHECK_NULL);\n-\n-  \/\/ parallelCapable class loaders do NOT wait for parallel superclass loads to complete\n-  \/\/ Serial class loaders and bootstrap classloader do wait for superclass loads\n- if (!class_loader.is_null() && is_parallelCapable(class_loader)) {\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-    return dictionary->find_class(name_hash, name);\n-  }\n-\n-  \/\/ must loop to both handle other placeholder updates\n-  \/\/ and spurious notifications\n-  bool super_load_in_progress = true;\n-  PlaceholderEntry* placeholder;\n-  while (super_load_in_progress) {\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-    \/\/ Check if classloading completed while we were loading superclass or waiting\n-    InstanceKlass* check = dictionary->find_class(name_hash, name);\n-    if (check != NULL) {\n-      \/\/ Klass is already loaded, so just return it\n-      return check;\n+                                                          CHECK);\n+}\n+\n+\/\/ parallelCapable class loaders do NOT wait for parallel superclass loads to complete\n+\/\/ Serial class loaders and bootstrap classloader do wait for superclass loads\n+static bool should_wait_for_loading(Handle class_loader) {\n+  return class_loader.is_null() || !is_parallelCapable(class_loader);\n+}\n+\n+\/\/ For bootstrap and non-parallelCapable class loaders, check and wait for\n+\/\/ another thread to complete loading this class.\n+InstanceKlass* SystemDictionary::handle_parallel_loading(JavaThread* current,\n+                                                         unsigned int name_hash,\n+                                                         Symbol* name,\n+                                                         ClassLoaderData* loader_data,\n+                                                         Handle lockObject,\n+                                                         bool* throw_circularity_error) {\n+  PlaceholderEntry* oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n+  if (oldprobe != NULL) {\n+    \/\/ only need check_seen_thread once, not on each loop\n+    \/\/ 6341374 java\/lang\/Instrument with -Xcomp\n+    if (oldprobe->check_seen_thread(current, PlaceholderTable::LOAD_INSTANCE)) {\n+      log_circularity_error(current, oldprobe);\n+      *throw_circularity_error = true;\n+      return NULL;\n@@ -661,2 +581,5 @@\n-      placeholder = placeholders()->get_entry(name_hash, name, loader_data);\n-      if (placeholder != NULL && placeholder->super_load_in_progress()) {\n+      \/\/ Wait until the first thread has finished loading this class. Also wait until all the\n+      \/\/ threads trying to load its superclass have removed their placeholders.\n+      while (oldprobe != NULL &&\n+             (oldprobe->instance_load_in_progress() || oldprobe->super_load_in_progress())) {\n+\n@@ -675,2 +598,3 @@\n-        \/\/ We also get here for parallel bootstrap classloader\n-        if (class_loader.is_null()) {\n+        oldprobe = NULL;  \/\/ Other thread could delete this placeholder entry\n+\n+        if (lockObject.is_null()) {\n@@ -679,1 +603,1 @@\n-          double_lock_wait(THREAD, lockObject);\n+          double_lock_wait(current, lockObject);\n@@ -681,4 +605,9 @@\n-      } else {\n-        \/\/ If not in SD and not in PH, the other thread is done loading the super class\n-        \/\/ but not done loading this class. We'll give up the lock and wait for that below.\n-        super_load_in_progress = false;\n+\n+        \/\/ Check if classloading completed while we were waiting\n+        InstanceKlass* check = loader_data->dictionary()->find_class(name_hash, name);\n+        if (check != NULL) {\n+          \/\/ Klass is already loaded, so just return it\n+          return check;\n+        }\n+        \/\/ check if other thread failed to load and cleaned up\n+        oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n@@ -701,7 +630,5 @@\n-\n-\/\/ Be careful when modifying this code: once you have run\n-\/\/ placeholders()->find_and_add(PlaceholderTable::LOAD_INSTANCE),\n-\/\/ you need to find_and_remove it before returning.\n-\/\/ So be careful to not exit with a CHECK_ macro betweeen these calls.\n-\/\/\n-\/\/ name must be in the form of \"java\/lang\/Object\" -- cannot be \"Ljava\/lang\/Object;\"\n+\/\/ SystemDictionary::resolve_instance_class_or_null is the main function for class name resolution.\n+\/\/ After checking if the InstanceKlass already exists, it checks for ClassCircularityError and\n+\/\/ whether the thread must wait for loading in parallel.  It eventually calls load_instance_class,\n+\/\/ which will load the class via the bootstrap loader or call ClassLoader.loadClass().\n+\/\/ This can return NULL, an exception or an InstanceKlass.\n@@ -712,0 +639,1 @@\n+  \/\/ name must be in the form of \"java\/lang\/Object\" -- cannot be \"Ljava\/lang\/Object;\"\n@@ -725,2 +653,2 @@\n-  \/\/ Do lookup to see if class already exist and the protection domain\n-  \/\/ has the right access\n+  \/\/ Do lookup to see if class already exists and the protection domain\n+  \/\/ has the right access.\n@@ -728,7 +656,4 @@\n-  \/\/ All subsequent calls use find_class, and set has_loaded_class so that\n-  \/\/ before we return a result we call out to java to check for valid protection domain\n-  \/\/ to allow returning the Klass* and add it to the pd_set if it is valid\n-  {\n-    InstanceKlass* probe = dictionary->find(name_hash, name, protection_domain);\n-    if (probe != NULL) return probe;\n-  }\n+  \/\/ All subsequent calls use find_class, and set loaded_class so that\n+  \/\/ before we return a result, we call out to java to check for valid protection domain.\n+  InstanceKlass* probe = dictionary->find(name_hash, name, protection_domain);\n+  if (probe != NULL) return probe;\n@@ -743,1 +668,1 @@\n-  \/\/ ParallelCapable Classloaders and the bootstrap classloader\n+  \/\/ ParallelCapable class loaders and the bootstrap classloader\n@@ -746,1 +671,1 @@\n-  ObjectLocker ol(lockObject, THREAD);\n+  ObjectLocker ol(lockObject, THREAD->as_Java_thread());\n@@ -748,2 +673,0 @@\n-  \/\/ Check again (after locking) if the class already exists in SystemDictionary\n-  bool class_has_been_loaded   = false;\n@@ -761,0 +684,1 @@\n+  \/\/ Check again (after locking) if the class already exists in SystemDictionary\n@@ -765,2 +689,1 @@\n-      \/\/ InstanceKlass is already loaded, so just return it\n-      class_has_been_loaded = true;\n+      \/\/ InstanceKlass is already loaded, but we still need to check protection domain below.\n@@ -778,1 +701,2 @@\n-  \/\/ If the class is in the placeholder table, class loading is in progress\n+  \/\/ If the class is in the placeholder table with super_class set,\n+  \/\/ handle superclass loading in progress.\n@@ -780,8 +704,4 @@\n-    loaded_class = handle_parallel_super_load(name,\n-                                              superclassname,\n-                                              class_loader,\n-                                              protection_domain,\n-                                              lockObject, CHECK_NULL);\n-    if (loaded_class != NULL) {\n-      class_has_been_loaded = true;\n-    }\n+    handle_parallel_super_load(name, superclassname,\n+                               class_loader,\n+                               protection_domain,\n+                               CHECK_NULL);\n@@ -791,2 +711,2 @@\n-  if (!class_has_been_loaded) {\n-    bool load_instance_added = false;\n+  if (loaded_class == NULL) {\n+    bool load_placeholder_added = false;\n@@ -795,1 +715,1 @@\n-    \/\/ Three cases:\n+    \/\/ Four cases:\n@@ -811,1 +731,1 @@\n-    if (class_loader.is_null() || !is_parallelCapable(class_loader)) {\n+    {\n@@ -813,30 +733,7 @@\n-      PlaceholderEntry* oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n-      if (oldprobe != NULL) {\n-        \/\/ only need check_seen_thread once, not on each loop\n-        \/\/ 6341374 java\/lang\/Instrument with -Xcomp\n-        if (oldprobe->check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {\n-          throw_circularity_error = true;\n-        } else {\n-          \/\/ case 3: traditional: should never see load_in_progress.\n-          while (!class_has_been_loaded && oldprobe != NULL && oldprobe->instance_load_in_progress()) {\n-\n-            \/\/ case 1: bootstrap classloader: prevent futile classloading,\n-            \/\/ wait on first requestor\n-            if (class_loader.is_null()) {\n-              SystemDictionary_lock->wait();\n-            } else {\n-              \/\/ case 4: traditional with broken classloader lock. wait on first\n-              \/\/ requestor.\n-              double_lock_wait(THREAD, lockObject);\n-            }\n-            \/\/ Check if classloading completed while we were waiting\n-            InstanceKlass* check = dictionary->find_class(name_hash, name);\n-            if (check != NULL) {\n-              \/\/ Klass is already loaded, so just return it\n-              loaded_class = check;\n-              class_has_been_loaded = true;\n-            }\n-            \/\/ check if other thread failed to load and cleaned up\n-            oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n-          }\n-        }\n+      if (should_wait_for_loading(class_loader)) {\n+        loaded_class = handle_parallel_loading(THREAD->as_Java_thread(),\n+                                               name_hash,\n+                                               name,\n+                                               loader_data,\n+                                               lockObject,\n+                                               &throw_circularity_error);\n@@ -845,5 +742,3 @@\n-      \/\/ Add LOAD_INSTANCE while holding the SystemDictionary_lock\n-      if (!throw_circularity_error && !class_has_been_loaded) {\n-        \/\/ For the bootclass loader, if the thread did not catch another thread holding\n-        \/\/ the LOAD_INSTANCE token, we need to check whether it completed loading\n-        \/\/ while holding the SD_lock.\n+      \/\/ Recheck if the class has been loaded for all class loader cases and\n+      \/\/ add a LOAD_INSTANCE placeholder while holding the SystemDictionary_lock.\n+      if (!throw_circularity_error && loaded_class == NULL) {\n@@ -852,4 +747,2 @@\n-          \/\/ Klass is already loaded, so return it after checking\/adding protection domain\n-          class_has_been_loaded = true;\n-        } else {\n-          \/\/ Now we've got the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread.\n+        } else if (should_wait_for_loading(class_loader)) {\n+          \/\/ Add the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread.\n@@ -861,1 +754,1 @@\n-          load_instance_added = true;\n+          load_placeholder_added = true;\n@@ -866,1 +759,1 @@\n-    \/\/ must throw error outside of owning lock\n+    \/\/ Must throw error outside of owning lock\n@@ -868,1 +761,1 @@\n-      assert(!HAS_PENDING_EXCEPTION && !load_instance_added, \"circularity error cleanup\");\n+      assert(!HAS_PENDING_EXCEPTION && !load_placeholder_added, \"circularity error cleanup\");\n@@ -873,1 +766,4 @@\n-    if (!class_has_been_loaded) {\n+    \/\/ Be careful when modifying this code: once you have run\n+    \/\/ placeholders()->find_and_add(PlaceholderTable::LOAD_INSTANCE),\n+    \/\/ you need to find_and_remove it before returning.\n+    \/\/ So be careful to not exit with a CHECK_ macro between these calls.\n@@ -875,0 +771,1 @@\n+    if (loaded_class == NULL) {\n@@ -876,31 +773,2 @@\n-      loaded_class = load_instance_class(name, class_loader, THREAD);\n-\n-      \/\/ If everything was OK (no exceptions, no null return value), and\n-      \/\/ class_loader is NOT the defining loader, do a little more bookkeeping.\n-      if (!HAS_PENDING_EXCEPTION && loaded_class != NULL &&\n-        loaded_class->class_loader() != class_loader()) {\n-\n-        check_constraints(name_hash, loaded_class, class_loader, false, THREAD);\n-\n-        \/\/ Need to check for a PENDING_EXCEPTION again; check_constraints\n-        \/\/ can throw but we may have to remove entry from the placeholder table below.\n-        if (!HAS_PENDING_EXCEPTION) {\n-          \/\/ Record dependency for non-parent delegation.\n-          \/\/ This recording keeps the defining class loader of the klass (loaded_class) found\n-          \/\/ from being unloaded while the initiating class loader is loaded\n-          \/\/ even if the reference to the defining class loader is dropped\n-          \/\/ before references to the initiating class loader.\n-          loader_data->record_dependency(loaded_class);\n-\n-          { \/\/ Grabbing the Compile_lock prevents systemDictionary updates\n-            \/\/ during compilations.\n-            MutexLocker mu(THREAD, Compile_lock);\n-            update_dictionary(name_hash, loaded_class, class_loader);\n-          }\n-\n-          if (JvmtiExport::should_post_class_load()) {\n-            JvmtiExport::post_class_load(THREAD->as_Java_thread(), loaded_class);\n-          }\n-        }\n-      }\n-    } \/\/ load_instance_class\n+      loaded_class = load_instance_class(name_hash, name, class_loader, THREAD);\n+    }\n@@ -908,1 +776,1 @@\n-    if (load_instance_added) {\n+    if (load_placeholder_added) {\n@@ -921,0 +789,1 @@\n+\n@@ -929,4 +798,1 @@\n-  if (protection_domain() != NULL &&\n-     java_lang_System::allow_security_manager() &&\n-     !dictionary->is_valid_protection_domain(name_hash, name,\n-                                             protection_domain)) {\n+  if (protection_domain() != NULL) {\n@@ -934,1 +800,1 @@\n-    validate_protection_domain(loaded_class, class_loader, protection_domain, CHECK_NULL);\n+    dictionary->validate_protection_domain(name_hash, loaded_class, class_loader, protection_domain, CHECK_NULL);\n@@ -1002,9 +868,9 @@\n-\/\/ Note: this method is much like resolve_from_stream, but\n-\/\/ does not publish the classes via the SystemDictionary.\n-\/\/ Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass\n-\/\/ and redefineclasses. RedefinedClasses do not add to the class hierarchy.\n-InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,\n-                                              Handle class_loader,\n-                                              ClassFileStream* st,\n-                                              const ClassLoadInfo& cl_info,\n-                                              TRAPS) {\n+\/\/ Note: this method is much like resolve_class_from_stream, but\n+\/\/ does not publish the classes in the SystemDictionary.\n+\/\/ Handles Lookup.defineClass hidden and unsafe_DefineAnonymousClass.\n+InstanceKlass* SystemDictionary::resolve_hidden_class_from_stream(\n+                                                     ClassFileStream* st,\n+                                                     Symbol* class_name,\n+                                                     Handle class_loader,\n+                                                     const ClassLoadInfo& cl_info,\n+                                                     TRAPS) {\n@@ -1021,2 +887,2 @@\n-  if (is_unsafe_anon_class || cl_info.is_hidden()) {\n-    guarantee(!is_unsafe_anon_class || cl_info.unsafe_anonymous_host()->class_loader() == class_loader(),\n+  assert (is_unsafe_anon_class || cl_info.is_hidden(), \"only used for hidden classes\");\n+  guarantee(!is_unsafe_anon_class || cl_info.unsafe_anonymous_host()->class_loader() == class_loader(),\n@@ -1024,5 +890,2 @@\n-    bool create_mirror_cld = is_unsafe_anon_class || !cl_info.is_strong_hidden();\n-    loader_data = register_loader(class_loader, create_mirror_cld);\n-  } else {\n-    loader_data = ClassLoaderData::class_loader_data(class_loader());\n-  }\n+  bool create_mirror_cld = is_unsafe_anon_class || !cl_info.is_strong_hidden();\n+  loader_data = register_loader(class_loader, create_mirror_cld);\n@@ -1034,4 +897,0 @@\n-  \/\/ Note that we do this even though this klass might\n-  \/\/ already be present in the SystemDictionary, otherwise we would not\n-  \/\/ throw potential ClassFormatErrors.\n-\n@@ -1045,7 +904,6 @@\n-  if (cl_info.is_hidden() || is_unsafe_anon_class) {\n-    \/\/ Hidden classes that are not strong and unsafe anonymous classes must update\n-    \/\/ ClassLoaderData holder so that they can be unloaded when the mirror is no\n-    \/\/ longer referenced.\n-    if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {\n-      k->class_loader_data()->initialize_holder(Handle(THREAD, k->java_mirror()));\n-    }\n+  \/\/ Hidden classes that are not strong and unsafe anonymous classes must update\n+  \/\/ ClassLoaderData holder so that they can be unloaded when the mirror is no\n+  \/\/ longer referenced.\n+  if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {\n+    k->class_loader_data()->initialize_holder(Handle(THREAD, k->java_mirror()));\n+  }\n@@ -1053,6 +911,6 @@\n-    {\n-      MutexLocker mu_r(THREAD, Compile_lock);\n-      \/\/ Add to class hierarchy, and do possible deoptimizations.\n-      add_to_hierarchy(k);\n-      \/\/ But, do not add to dictionary.\n-    }\n+  {\n+    MutexLocker mu_r(THREAD, Compile_lock);\n+    \/\/ Add to class hierarchy, and do possible deoptimizations.\n+    add_to_hierarchy(k);\n+    \/\/ But, do not add to dictionary.\n+  }\n@@ -1060,5 +918,5 @@\n-    \/\/ Rewrite and patch constant pool here.\n-    k->link_class(CHECK_NULL);\n-    if (cl_info.cp_patches() != NULL) {\n-      k->constants()->patch_resolved_references(cl_info.cp_patches());\n-    }\n+  \/\/ Rewrite and patch constant pool here.\n+  k->link_class(CHECK_NULL);\n+  if (cl_info.cp_patches() != NULL) {\n+    k->constants()->patch_resolved_references(cl_info.cp_patches());\n+  }\n@@ -1066,4 +924,4 @@\n-    \/\/ If it's anonymous, initialize it now, since nobody else will.\n-    if (is_unsafe_anon_class) {\n-      k->eager_initialize(CHECK_NULL);\n-    }\n+  \/\/ If it's anonymous, initialize it now, since nobody else will.\n+  if (is_unsafe_anon_class) {\n+    k->eager_initialize(CHECK_NULL);\n+  }\n@@ -1071,7 +929,3 @@\n-    \/\/ notify jvmti\n-    if (JvmtiExport::should_post_class_load()) {\n-      JvmtiExport::post_class_load(THREAD->as_Java_thread(), k);\n-    }\n-    if (class_load_start_event.should_commit()) {\n-      post_class_load_event(&class_load_start_event, k, loader_data);\n-    }\n+  \/\/ notify jvmti\n+  if (JvmtiExport::should_post_class_load()) {\n+    JvmtiExport::post_class_load(THREAD->as_Java_thread(), k);\n@@ -1079,0 +933,4 @@\n+  if (class_load_start_event.should_commit()) {\n+    post_class_load_event(&class_load_start_event, k, loader_data);\n+  }\n+\n@@ -1091,3 +949,1 @@\n-InstanceKlass* SystemDictionary::resolve_from_stream(Symbol* class_name,\n-                                                     Handle class_loader,\n-                                                     Handle protection_domain,\n+InstanceKlass* SystemDictionary::resolve_class_from_stream(\n@@ -1095,0 +951,3 @@\n+                                                     Symbol* class_name,\n+                                                     Handle class_loader,\n+                                                     const ClassLoadInfo& cl_info,\n@@ -1104,1 +963,1 @@\n-  ObjectLocker ol(lockObject, THREAD);\n+  ObjectLocker ol(lockObject, THREAD->as_Java_thread());\n@@ -1116,1 +975,1 @@\n-                                                   protection_domain,\n+                                                   cl_info.protection_domain(),\n@@ -1123,1 +982,0 @@\n-    ClassLoadInfo cl_info(protection_domain);\n@@ -1154,0 +1012,14 @@\n+InstanceKlass* SystemDictionary::resolve_from_stream(ClassFileStream* st,\n+                                                     Symbol* class_name,\n+                                                     Handle class_loader,\n+                                                     const ClassLoadInfo& cl_info,\n+                                                     TRAPS) {\n+  bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;\n+  if (cl_info.is_hidden() || is_unsafe_anon_class) {\n+    return resolve_hidden_class_from_stream(st, class_name, class_loader, cl_info, CHECK_NULL);\n+  } else {\n+    return resolve_class_from_stream(st, class_name, class_loader, cl_info, CHECK_NULL);\n+  }\n+}\n+\n+\n@@ -1156,1 +1028,1 @@\n-\/\/ forces the super class and all interfaces to be loaded.\n+\/\/ forces the superclass and all interfaces to be loaded.\n@@ -1172,1 +1044,1 @@\n-                                               Handle class_loader, TRAPS) {\n+                                               Handle class_loader) {\n@@ -1204,1 +1076,1 @@\n-    assert(SystemDictionary::is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD),\n+    assert(SystemDictionary::is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader),\n@@ -1208,1 +1080,1 @@\n-  return is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD);\n+  return is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader);\n@@ -1214,1 +1086,1 @@\n-                                                    Handle class_loader, TRAPS) {\n+                                                    Handle class_loader) {\n@@ -1266,1 +1138,1 @@\n-    \/\/ Check if the super class is loaded by the current class_loader\n+    \/\/ Check if the superclass is loaded by the current class_loader\n@@ -1332,1 +1204,1 @@\n-  ik->set_nest_host(shared_nest_host, THREAD);\n+  ik->set_nest_host(shared_nest_host);\n@@ -1354,3 +1226,1 @@\n-  bool visible = is_shared_class_visible(\n-                          class_name, ik, pkg_entry, class_loader, CHECK_NULL);\n-  if (!visible) {\n+  if (!is_shared_class_visible(class_name, ik, pkg_entry, class_loader)) {\n@@ -1410,1 +1280,1 @@\n-    ObjectLocker ol(lockObject, THREAD);\n+    ObjectLocker ol(lockObject, THREAD->as_Java_thread());\n@@ -1416,1 +1286,1 @@\n-  load_shared_class_misc(ik, loader_data, CHECK_NULL);\n+  load_shared_class_misc(ik, loader_data);\n@@ -1427,1 +1297,1 @@\n-void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {\n+void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data) {\n@@ -1449,1 +1319,1 @@\n-        ResourceMark rm(THREAD);\n+        ResourceMark rm;\n@@ -1458,1 +1328,1 @@\n-InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {\n+InstanceKlass* SystemDictionary::load_instance_class_impl(Symbol* class_name, Handle class_loader, TRAPS) {\n@@ -1579,1 +1449,1 @@\n-    oop obj = (oop) result.get_jobject();\n+    oop obj = result.get_oop();\n@@ -1597,0 +1467,35 @@\n+InstanceKlass* SystemDictionary::load_instance_class(unsigned int name_hash,\n+                                                     Symbol* name,\n+                                                     Handle class_loader,\n+                                                     TRAPS) {\n+\n+  InstanceKlass* loaded_class = load_instance_class_impl(name, class_loader, CHECK_NULL);\n+\n+  \/\/ If everything was OK (no exceptions, no null return value), and\n+  \/\/ class_loader is NOT the defining loader, do a little more bookkeeping.\n+  if (loaded_class != NULL &&\n+    loaded_class->class_loader() != class_loader()) {\n+\n+    check_constraints(name_hash, loaded_class, class_loader, false, CHECK_NULL);\n+\n+    \/\/ Record dependency for non-parent delegation.\n+    \/\/ This recording keeps the defining class loader of the klass (loaded_class) found\n+    \/\/ from being unloaded while the initiating class loader is loaded\n+    \/\/ even if the reference to the defining class loader is dropped\n+    \/\/ before references to the initiating class loader.\n+    ClassLoaderData* loader_data = class_loader_data(class_loader);\n+    loader_data->record_dependency(loaded_class);\n+\n+    { \/\/ Grabbing the Compile_lock prevents systemDictionary updates\n+      \/\/ during compilations.\n+      MutexLocker mu(THREAD, Compile_lock);\n+      update_dictionary(name_hash, loaded_class, class_loader);\n+    }\n+\n+    if (JvmtiExport::should_post_class_load()) {\n+      JvmtiExport::post_class_load(THREAD->as_Java_thread(), loaded_class);\n+    }\n+  }\n+  return loaded_class;\n+}\n+\n@@ -1724,0 +1629,1 @@\n+      InstanceKlass* ik = probe->instance_klass();\n@@ -1730,1 +1636,1 @@\n-      return probe->instance_klass();\n+      return ik;\n@@ -1965,1 +1871,1 @@\n-                    Symbol* class_name, Handle class_loader, Thread* THREAD) {\n+                    Thread* current, Symbol* class_name, Handle class_loader) {\n@@ -1987,1 +1893,1 @@\n-      MutexLocker mu(THREAD, SystemDictionary_lock);\n+      MutexLocker mu(current, SystemDictionary_lock);\n@@ -1995,1 +1901,1 @@\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n+    MutexLocker mu(current, SystemDictionary_lock);\n@@ -2006,2 +1912,1 @@\n-                                             Handle class_loader2,\n-                                             Thread* THREAD) {\n+                                             Handle class_loader2) {\n@@ -2037,1 +1942,1 @@\n-    MutexLocker mu_s(THREAD, SystemDictionary_lock);\n+    MutexLocker mu_s(SystemDictionary_lock);\n@@ -2047,1 +1952,1 @@\n-                                     class_loader1, class_loader2, THREAD);\n+                                     class_loader1, class_loader2);\n@@ -2060,1 +1965,2 @@\n-                                            Symbol* error, Symbol* message) {\n+                                            Symbol* error, Symbol* message,\n+                                            Symbol* cause, Symbol* cause_msg) {\n@@ -2065,1 +1971,4 @@\n-    resolution_errors()->add_entry(index, hash, pool, which, error, message);\n+    ResolutionErrorEntry* entry = resolution_errors()->find_entry(index, hash, pool, which);\n+    if (entry == NULL) {\n+      resolution_errors()->add_entry(index, hash, pool, which, error, message, cause, cause_msg);\n+    }\n@@ -2076,1 +1985,1 @@\n-                                                Symbol** message) {\n+                                                Symbol** message, Symbol** cause, Symbol** cause_msg) {\n@@ -2084,0 +1993,2 @@\n+      *cause = entry->cause();\n+      *cause_msg = entry->cause_msg();\n@@ -2179,3 +2090,3 @@\n-                                               Klass* klass_being_linked,\n-                                               Handle loader1, Handle loader2,\n-                                               bool is_method, TRAPS)  {\n+                                                  Klass* klass_being_linked,\n+                                                  Handle loader1, Handle loader2,\n+                                                  bool is_method)  {\n@@ -2193,1 +2104,1 @@\n-      if (!add_loader_constraint(sig, klass_being_linked, loader1, loader2, THREAD)) {\n+      if (!add_loader_constraint(sig, klass_being_linked, loader1, loader2)) {\n@@ -2315,1 +2226,1 @@\n-  Handle mname(THREAD, (oop) result.get_jobject());\n+  Handle mname(THREAD, result.get_oop());\n@@ -2449,1 +2360,1 @@\n-  Handle method_type(THREAD, (oop) result.get_jobject());\n+  Handle method_type(THREAD, result.get_oop());\n@@ -2535,1 +2446,1 @@\n-  return Handle(THREAD, (oop) result.get_jobject());\n+  return Handle(THREAD, result.get_oop());\n@@ -2577,1 +2488,1 @@\n-  Handle value(THREAD, (oop) result.get_jobject());\n+  Handle value(THREAD, result.get_oop());\n@@ -2596,5 +2507,0 @@\n-\/\/ Protection domain cache table handling\n-\n-ProtectionDomainCacheEntry* SystemDictionary::cache_get(Handle protection_domain) {\n-  return _pd_cache_table->get(protection_domain);\n-}\n@@ -2694,11 +2600,0 @@\n-\n-int SystemDictionaryDCmd::num_arguments() {\n-  ResourceMark rm;\n-  SystemDictionaryDCmd* dcmd = new SystemDictionaryDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":286,"deletions":391,"binary":false,"changes":677,"status":"modified"},{"patch":"@@ -49,3 +49,1 @@\n-\/\/ a side data structure, and is used to detect ClassCircularityErrors\n-\/\/ and to perform verification during GC.  A GC can occur in the midst\n-\/\/ of class loading, as we call out to Java, have to take locks, etc.\n+\/\/ a side data structure, and is used to detect ClassCircularityErrors.\n@@ -61,3 +59,2 @@\n-\/\/    - entries are only deleted at safepoints\n-\/\/    - readers cannot come to a safepoint while actively examining\n-\/\/         an entry  (an entry cannot be deleted from under a reader)\n+\/\/    - entries are only deleted when the class loader is not alive, when the\n+\/\/      entire dictionary is deleted.\n@@ -125,0 +122,16 @@\n+ private:\n+  \/\/ Parse the stream to create an unsafe anonymous or hidden class.\n+  \/\/ Used by Unsafe_DefineAnonymousClass and jvm_lookup_define_class.\n+  static InstanceKlass* resolve_hidden_class_from_stream(ClassFileStream* st,\n+                                                         Symbol* class_name,\n+                                                         Handle class_loader,\n+                                                         const ClassLoadInfo& cl_info,\n+                                                         TRAPS);\n+\n+  \/\/ Resolve a class from stream (called by jni_DefineClass and JVM_DefineClass)\n+  \/\/ This class is added to the SystemDictionary.\n+  static InstanceKlass* resolve_class_from_stream(ClassFileStream* st,\n+                                                  Symbol* class_name,\n+                                                  Handle class_loader,\n+                                                  const ClassLoadInfo& cl_info,\n+                                                  TRAPS);\n@@ -126,0 +139,1 @@\n+ public:\n@@ -132,11 +146,3 @@\n-  \/\/ Parse new stream. This won't update the dictionary or class\n-  \/\/ hierarchy, simply parse the stream. Used by JVMTI RedefineClasses\n-  \/\/ and by Unsafe_DefineAnonymousClass and jvm_lookup_define_class.\n-  static InstanceKlass* parse_stream(Symbol* class_name,\n-                                     Handle class_loader,\n-                                     ClassFileStream* st,\n-                                     const ClassLoadInfo& cl_info,\n-                                     TRAPS);\n-\n-  \/\/ Resolve from stream (called by jni_DefineClass and JVM_DefineClass)\n-  static InstanceKlass* resolve_from_stream(Symbol* class_name,\n+  \/\/ Resolve either a hidden or normal class from a stream of bytes, based on ClassLoadInfo\n+  static InstanceKlass* resolve_from_stream(ClassFileStream* st,\n+                                            Symbol* class_name,\n@@ -144,2 +150,1 @@\n-                                            Handle protection_domain,\n-                                            ClassFileStream* st,\n+                                            const ClassLoadInfo& cl_info,\n@@ -179,3 +184,3 @@\n-  static Klass* find_constrained_instance_or_array_klass(Symbol* class_name,\n-                                                           Handle class_loader,\n-                                                           Thread* THREAD);\n+  static Klass* find_constrained_instance_or_array_klass(Thread* current,\n+                                                         Symbol* class_name,\n+                                                         Handle class_loader);\n@@ -228,1 +233,1 @@\n-                                         Handle loader1, Handle loader2, bool is_method, TRAPS);\n+                                         Handle loader1, Handle loader2, bool is_method);\n@@ -287,1 +292,1 @@\n-                                   Symbol* message);\n+                                   Symbol* message, Symbol* cause = NULL, Symbol* cause_msg = NULL);\n@@ -290,1 +295,1 @@\n-                                       Symbol** message);\n+                                       Symbol** message, Symbol** cause, Symbol** cause_msg);\n@@ -298,2 +303,0 @@\n-  static ProtectionDomainCacheEntry* cache_get(Handle protection_domain);\n-\n@@ -325,4 +328,0 @@\n-  static void validate_protection_domain(InstanceKlass* klass,\n-                                         Handle class_loader,\n-                                         Handle protection_domain, TRAPS);\n-\n@@ -346,10 +345,7 @@\n-  static InstanceKlass* handle_parallel_super_load(Symbol* class_name,\n-                                                   Symbol* supername,\n-                                                   Handle class_loader,\n-                                                   Handle protection_domain,\n-                                                   Handle lockObject, TRAPS);\n-  \/\/ Wait on SystemDictionary_lock; unlocks lockObject before\n-  \/\/ waiting; relocks lockObject with correct recursion count\n-  \/\/ after waiting, but before reentering SystemDictionary_lock\n-  \/\/ to preserve lock order semantics.\n-  static void double_lock_wait(Thread* thread, Handle lockObject);\n+  static InstanceKlass* handle_parallel_loading(JavaThread* current,\n+                                                unsigned int name_hash,\n+                                                Symbol* name,\n+                                                ClassLoaderData* loader_data,\n+                                                Handle lockObject,\n+                                                bool* throw_circularity_error);\n+\n@@ -360,1 +356,4 @@\n-  static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);\n+  static InstanceKlass* load_instance_class_impl(Symbol* class_name, Handle class_loader, TRAPS);\n+  static InstanceKlass* load_instance_class(unsigned int name_hash,\n+                                            Symbol* class_name,\n+                                            Handle class_loader, TRAPS);\n@@ -364,1 +363,1 @@\n-                                      Handle class_loader, TRAPS);\n+                                      Handle class_loader);\n@@ -368,1 +367,1 @@\n-                                           Handle class_loader, TRAPS);\n+                                           Handle class_loader);\n@@ -375,1 +374,1 @@\n-  static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;\n+  static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data) NOT_CDS_RETURN;\n@@ -380,1 +379,1 @@\n-                                    Handle loader2, TRAPS);\n+                                    Handle loader2);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":45,"deletions":46,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -128,2 +128,2 @@\n-    VerificationType comp_this = get_component(context, CHECK_false);\n-    VerificationType comp_from = from.get_component(context, CHECK_false);\n+    VerificationType comp_this = get_component(context);\n+    VerificationType comp_from = from.get_component(context);\n@@ -206,1 +206,1 @@\n-VerificationType VerificationType::get_component(ClassVerifier *context, TRAPS) const {\n+VerificationType VerificationType::get_component(ClassVerifier *context) const {\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-  VerificationType get_component(ClassVerifier* context, TRAPS) const;\n+  VerificationType get_component(ClassVerifier* context) const;\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,2 +138,2 @@\n-void Verifier::log_end_verification(outputStream* st, const char* klassName, Symbol* exception_name, TRAPS) {\n-  if (HAS_PENDING_EXCEPTION) {\n+void Verifier::log_end_verification(outputStream* st, const char* klassName, Symbol* exception_name, oop pending_exception) {\n+  if (pending_exception != NULL) {\n@@ -141,1 +141,1 @@\n-    oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n+    oop message = java_lang_Throwable::message(pending_exception);\n@@ -145,1 +145,1 @@\n-                 PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n+                   pending_exception->klass()->external_name(), ex_msg);\n@@ -148,1 +148,1 @@\n-                 PENDING_EXCEPTION->klass()->external_name());\n+                   pending_exception->klass()->external_name());\n@@ -197,1 +197,2 @@\n-    ClassVerifier split_verifier(klass, THREAD);\n+    ClassVerifier split_verifier(jt, klass);\n+    \/\/ We don't use CHECK here, or on inference_verify below, so that we can log any exception.\n@@ -232,1 +233,1 @@\n-    log_end_verification(&ls, klass->external_name(), exception_name, THREAD);\n+    log_end_verification(&ls, klass->external_name(), exception_name, PENDING_EXCEPTION);\n@@ -237,1 +238,1 @@\n-    log_end_verification(&ls, klass->external_name(), exception_name, THREAD);\n+    log_end_verification(&ls, klass->external_name(), exception_name, PENDING_EXCEPTION);\n@@ -608,3 +609,2 @@\n-ClassVerifier::ClassVerifier(\n-    InstanceKlass* klass, TRAPS)\n-    : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),\n+ClassVerifier::ClassVerifier(JavaThread* current, InstanceKlass* klass)\n+    : _thread(current), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),\n@@ -635,0 +635,1 @@\n+\n@@ -672,2 +673,1 @@\n-                                        sig_as_verification_types* sig_verif_types,\n-                                        TRAPS) {\n+                                        sig_as_verification_types* sig_verif_types) {\n@@ -707,1 +707,1 @@\n-                                            int sig_index, TRAPS) {\n+                                            int sig_index) {\n@@ -711,1 +711,1 @@\n-  translate_signature(method_sig, sig_verif_types, CHECK_VERIFY(this));\n+  translate_signature(method_sig, sig_verif_types);\n@@ -737,2 +737,1 @@\n-  VerificationType return_type = current_frame.set_locals_from_arg(\n-    m, current_type(), CHECK_VERIFY(this));\n+  VerificationType return_type = current_frame.set_locals_from_arg( m, current_type());\n@@ -1068,2 +1067,1 @@\n-            VerificationType component =\n-              atype.get_component(this, CHECK_VERIFY(this));\n+            VerificationType component = atype.get_component(this);\n@@ -2897,1 +2895,1 @@\n-    create_method_sig_entry(mth_sig_verif_types, sig_index, CHECK_VERIFY(this));\n+    create_method_sig_entry(mth_sig_verif_types, sig_index);\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-  static void log_end_verification(outputStream* st, const char* klassName, Symbol* exception_name, TRAPS);\n+  static void log_end_verification(outputStream* st, const char* klassName, Symbol* exception_name,\n+                                    oop pending_exception);\n@@ -405,1 +406,1 @@\n-  ClassVerifier(InstanceKlass* klass, TRAPS);\n+  ClassVerifier(JavaThread* current, InstanceKlass* klass);\n@@ -422,1 +423,1 @@\n-  void translate_signature(Symbol* const method_sig, sig_as_verification_types* sig_verif_types, TRAPS);\n+  void translate_signature(Symbol* const method_sig, sig_as_verification_types* sig_verif_types);\n@@ -425,1 +426,1 @@\n-  void create_method_sig_entry(sig_as_verification_types* sig_verif_types, int sig_index, TRAPS);\n+  void create_method_sig_entry(sig_as_verification_types* sig_verif_types, int sig_index);\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -685,0 +685,40 @@\n+class vmIntrinsicsLookup {\n+  bool _class_map[vmSymbols::number_of_symbols()];\n+\n+  constexpr int as_index(vmSymbolID id) const {\n+    int index = vmSymbols::as_int(id);\n+    assert(0 <= index && index < int(sizeof(_class_map)), \"must be\");\n+    return index;\n+  }\n+\n+  constexpr void set_class_map(vmSymbolID id) {\n+    _class_map[as_index(id)] = true;\n+  }\n+\n+public:\n+  constexpr vmIntrinsicsLookup() : _class_map() {\n+\n+#define VM_INTRINSIC_CLASS_MAP(id, klass, name, sig, fcode) \\\n+    set_class_map(SID_ENUM(klass));\n+\n+    VM_INTRINSICS_DO(VM_INTRINSIC_CLASS_MAP,\n+                     VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);\n+#undef VM_INTRINSIC_CLASS_MAP\n+\n+\n+    \/\/ A few slightly irregular cases. See Method::init_intrinsic_id\n+    set_class_map(SID_ENUM(java_lang_StrictMath));\n+    set_class_map(SID_ENUM(java_lang_invoke_MethodHandle));\n+    set_class_map(SID_ENUM(java_lang_invoke_VarHandle));\n+  }\n+\n+  bool class_has_intrinsics(vmSymbolID holder) const {\n+    return _class_map[as_index(holder)];\n+  }\n+};\n+\n+constexpr vmIntrinsicsLookup _intrinsics_lookup;\n+\n+bool vmIntrinsics::class_has_intrinsics(vmSymbolID holder) {\n+  return _intrinsics_lookup.class_has_intrinsics(holder);\n+}\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1154,0 +1154,2 @@\n+  static bool class_has_intrinsics(vmSymbolID holder);\n+\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -303,2 +303,2 @@\n-  template(jdk_internal_misc_CDS, \"jdk\/internal\/misc\/CDS\")                                        \\\n-  template(generateLambdaFormHolderClasses, \"generateLambdaFormHolderClasses\")                    \\\n+  template(jdk_internal_misc_CDS,                     \"jdk\/internal\/misc\/CDS\")                    \\\n+  template(generateLambdaFormHolderClasses,           \"generateLambdaFormHolderClasses\")          \\\n@@ -306,0 +306,2 @@\n+  template(dumpSharedArchive,                         \"dumpSharedArchive\")                        \\\n+  template(dumpSharedArchive_signature,               \"(ZLjava\/lang\/String;)V\")                   \\\n@@ -543,0 +545,1 @@\n+  template(throwable_signature,                       \"Ljava\/lang\/Throwable;\")                    \\\n@@ -545,1 +548,0 @@\n-  template(throwable_throwable_signature,             \"(Ljava\/lang\/Throwable;)Ljava\/lang\/Throwable;\")             \\\n@@ -550,0 +552,1 @@\n+  template(throwable_throwable_signature,             \"(Ljava\/lang\/Throwable;)Ljava\/lang\/Throwable;\")             \\\n@@ -782,1 +785,1 @@\n-  static void initialize(TRAPS);\n+  static void initialize();\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"compiler\/oopMap.hpp\"\n@@ -36,0 +35,4 @@\n+class ImmutableOopMap;\n+class ImmutableOopMapSet;\n+class OopMapSet;\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  if (cache == NULL)  cache = (void*)Universe::non_oop_word();\n+  if (cache == NULL)  cache = Universe::non_oop_word();\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-#include \"compiler\/oopMap.hpp\"\n@@ -38,0 +37,3 @@\n+class OopMap;\n+class OopMapSet;\n+\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -951,0 +952,2 @@\n+  run_nmethod_entry_barrier(); \/\/ ensure all embedded OOPs are valid before printing\n+\n@@ -1051,1 +1054,1 @@\n-    (*dest) = (oop) handle;\n+    *(void**)dest = handle;\n@@ -1053,1 +1056,1 @@\n-    (*dest) = JNIHandles::resolve_non_null(handle);\n+    *dest = JNIHandles::resolve_non_null(handle);\n@@ -1194,1 +1197,1 @@\n-#ifdef DEBUG\n+#ifdef ASSERT\n@@ -2641,1 +2644,1 @@\n-      if (*p == Universe::non_oop_word()) {\n+      if (Universe::contains_non_oop_word(p)) {\n@@ -2737,0 +2740,30 @@\n+void nmethod::print_recorded_oop(int log_n, int i) {\n+  void* value;\n+\n+  if (i == 0) {\n+    value = NULL;\n+  } else {\n+    \/\/ Be careful around non-oop words. Don't create an oop\n+    \/\/ with that value, or it will assert in verification code.\n+    if (Universe::contains_non_oop_word(oop_addr_at(i))) {\n+      value = Universe::non_oop_word();\n+    } else {\n+      value = oop_at(i);\n+    }\n+  }\n+\n+  tty->print(\"#%*d: \" INTPTR_FORMAT \" \", log_n, i, p2i(value));\n+\n+  if (value == Universe::non_oop_word()) {\n+    tty->print(\"non-oop word\");\n+  } else {\n+    if (value == 0) {\n+      tty->print(\"NULL-oop\");\n+    } else {\n+      oop_at(i)->print_value_on(tty);\n+    }\n+  }\n+\n+  tty->cr();\n+}\n+\n@@ -2744,10 +2777,1 @@\n-      oop o = oop_at(i);\n-      tty->print(\"#%*d: \" INTPTR_FORMAT \" \", log_n, i, p2i(o));\n-      if (o == (oop)Universe::non_oop_word()) {\n-        tty->print(\"non-oop word\");\n-      } else if (o == NULL) {\n-        tty->print(\"NULL-oop\");\n-      } else {\n-        o->print_value_on(tty);\n-      }\n-      tty->cr();\n+      print_recorded_oop(log_n, i);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":38,"deletions":14,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-  \/\/ some collectors need to to different things depending on whether the nmethods\n+  \/\/ some collectors need to do different things depending on whether the nmethods\n@@ -681,0 +681,1 @@\n+  void print_recorded_oop(int log_n, int index);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -60,0 +59,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -1435,2 +1435,1 @@\n-    bool in_base_library;\n-    address adr = NativeLookup::lookup(method, in_base_library, THREAD);\n+    address adr = NativeLookup::lookup(method, THREAD);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,0 +54,18 @@\n+static_assert(sizeof(oop) == sizeof(intptr_t), \"Derived pointer sanity check\");\n+\n+static inline intptr_t derived_pointer_value(derived_pointer p) {\n+  return static_cast<intptr_t>(p);\n+}\n+\n+static inline derived_pointer to_derived_pointer(oop obj) {\n+  return static_cast<derived_pointer>(cast_from_oop<intptr_t>(obj));\n+}\n+\n+static inline intptr_t operator-(derived_pointer p, derived_pointer p1) {\n+  return derived_pointer_value(p) - derived_pointer_value(p1);\n+}\n+\n+static inline derived_pointer operator+(derived_pointer p, intptr_t offset) {\n+  return static_cast<derived_pointer>(derived_pointer_value(p) + offset);\n+}\n+\n@@ -197,1 +215,1 @@\n-static void add_derived_oop(oop* base, oop* derived, OopClosure* oop_fn) {\n+static void add_derived_oop(oop* base, derived_pointer* derived, OopClosure* oop_fn) {\n@@ -203,1 +221,1 @@\n-static void ignore_derived_oop(oop* base, oop* derived, OopClosure* oop_fn) {\n+static void ignore_derived_oop(oop* base, derived_pointer* derived, OopClosure* oop_fn) {\n@@ -206,1 +224,1 @@\n-static void process_derived_oop(oop* base, oop* derived, OopClosure* oop_fn) {\n+static void process_derived_oop(oop* base, derived_pointer* derived, OopClosure* oop_fn) {\n@@ -210,4 +228,5 @@\n-  uintptr_t offset = cast_from_oop<uintptr_t>(*derived) - cast_from_oop<uintptr_t>(*base);\n-  *derived = *base;\n-  oop_fn->do_oop(derived);\n-  *derived = cast_to_oop(cast_from_oop<uintptr_t>(*derived) + offset);\n+  derived_pointer derived_base = to_derived_pointer(*base);\n+  intptr_t offset = *derived - derived_base;\n+  *derived = derived_base;\n+  oop_fn->do_oop((oop*)derived);\n+  *derived = *derived + offset;\n@@ -248,1 +267,1 @@\n-    all_do(fr, reg_map, f, process_derived_oop, &do_nothing_cl);\n+    all_do(fr, reg_map, f, process_derived_oop);\n@@ -251,1 +270,1 @@\n-    all_do(fr, reg_map, f, add_derived_oop, &do_nothing_cl);\n+    all_do(fr, reg_map, f, add_derived_oop);\n@@ -254,1 +273,1 @@\n-    all_do(fr, reg_map, f, ignore_derived_oop, &do_nothing_cl);\n+    all_do(fr, reg_map, f, ignore_derived_oop);\n@@ -261,2 +280,1 @@\n-                       OopClosure* oop_fn, void derived_oop_fn(oop*, oop*, OopClosure*),\n-                       OopClosure* value_fn) {\n+                       OopClosure* oop_fn, void derived_oop_fn(oop*, derived_pointer*, OopClosure*)) {\n@@ -288,4 +306,3 @@\n-      oop* loc = fr->oopmapreg_to_location(omv.reg(),reg_map);\n-      guarantee(loc != NULL, \"missing saved register\");\n-      oop *derived_loc = loc;\n-      oop *base_loc    = fr->oopmapreg_to_location(omv.content_reg(), reg_map);\n+      derived_pointer* derived_loc = (derived_pointer*)fr->oopmapreg_to_location(omv.reg(),reg_map);\n+      guarantee(derived_loc != NULL, \"missing saved register\");\n+      oop* base_loc = fr->oopmapreg_to_oop_location(omv.content_reg(), reg_map);\n@@ -307,1 +324,1 @@\n-      oop* loc = fr->oopmapreg_to_location(omv.reg(),reg_map);\n+      oop* loc = fr->oopmapreg_to_oop_location(omv.reg(),reg_map);\n@@ -370,1 +387,1 @@\n-      oop* loc = fr->oopmapreg_to_location(omv.reg(), reg_map);\n+      oop* loc = fr->oopmapreg_to_oop_location(omv.reg(), reg_map);\n@@ -661,3 +678,3 @@\n-  oop* _location;   \/\/ Location of derived pointer, also pointing to base\n-  intptr_t _offset; \/\/ Offset from base pointer\n-  Entry* volatile _next;\n+  derived_pointer* _location; \/\/ Location of derived pointer, also pointing to base\n+  intptr_t         _offset;   \/\/ Offset from base pointer\n+  Entry* volatile  _next;\n@@ -668,1 +685,1 @@\n-  Entry(oop* location, intptr_t offset) :\n+  Entry(derived_pointer* location, intptr_t offset) :\n@@ -671,1 +688,1 @@\n-  oop* location() const { return _location; }\n+  derived_pointer* location() const { return _location; }\n@@ -699,6 +716,1 @@\n-\/\/ Returns value of location as an int\n-inline intptr_t value_of_loc(oop *pointer) {\n-  return cast_from_oop<intptr_t>((*pointer));\n-}\n-\n-void DerivedPointerTable::add(oop *derived_loc, oop *base_loc) {\n+void DerivedPointerTable::add(derived_pointer* derived_loc, oop *base_loc) {\n@@ -706,2 +718,4 @@\n-  assert(derived_loc != base_loc, \"Base and derived in same location\");\n-  assert(*derived_loc != (void*)base_loc, \"location already added\");\n+  assert(derived_loc != (void*)base_loc, \"Base and derived in same location\");\n+  derived_pointer base_loc_as_derived_pointer =\n+    static_cast<derived_pointer>(reinterpret_cast<intptr_t>(base_loc));\n+  assert(*derived_loc != base_loc_as_derived_pointer, \"location already added\");\n@@ -710,1 +724,1 @@\n-  intptr_t offset = value_of_loc(derived_loc) - value_of_loc(base_loc);\n+  intptr_t offset = *derived_loc - to_derived_pointer(*base_loc);\n@@ -720,1 +734,1 @@\n-      p2i(derived_loc), p2i(*derived_loc), p2i(*base_loc), p2i(base_loc), offset\n+      p2i(derived_loc), derived_pointer_value(*derived_loc), p2i(*base_loc), p2i(base_loc), offset\n@@ -724,1 +738,1 @@\n-  *derived_loc = (oop)base_loc;\n+  *derived_loc = base_loc_as_derived_pointer;\n@@ -735,1 +749,1 @@\n-    oop* derived_loc = entry->location();\n+    derived_pointer* derived_loc = entry->location();\n@@ -738,1 +752,1 @@\n-    oop base = **(oop**)derived_loc;\n+    oop base = **reinterpret_cast<oop**>(derived_loc);\n@@ -741,2 +755,3 @@\n-    *derived_loc = (oop)(cast_from_oop<address>(base) + offset);\n-    assert(value_of_loc(derived_loc) - value_of_loc(&base) == offset, \"sanity check\");\n+    derived_pointer derived_base = to_derived_pointer(base);\n+    *derived_loc = derived_base + offset;\n+    assert(*derived_loc - derived_base == offset, \"sanity check\");\n@@ -747,1 +762,1 @@\n-          p2i(derived_loc), p2i(*derived_loc), p2i(base), offset);\n+                    p2i(derived_loc), derived_pointer_value(*derived_loc), p2i(base), offset);\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":54,"deletions":39,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -760,1 +760,1 @@\n-            if (c != NULL) {\n+            if (c != NULL && c->Opcode() != Op_Parm) {\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-    obj = (oop) m.decode_pointer();\n+    obj = cast_to_oop(m.decode_pointer());\n@@ -476,1 +476,1 @@\n-  const oop obj = oop(obj_ptr);\n+  const oop obj = cast_to_oop(obj_ptr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -538,0 +539,1 @@\n+  \/\/ end_region is inclusive\n@@ -553,1 +555,0 @@\n-  Klass* klass = ((oop)addr)->klass();\n@@ -569,2 +570,2 @@\n-  assert(region_offset(beg) == 0, \"not RegionSize aligned\");\n-  assert(region_offset(end) == 0, \"not RegionSize aligned\");\n+  assert(is_region_aligned(beg), \"not RegionSize aligned\");\n+  assert(is_region_aligned(end), \"not RegionSize aligned\");\n@@ -766,1 +767,1 @@\n-      } else if (region_offset(dest_addr) == 0) {\n+      } else if (is_region_aligned(dest_addr)) {\n@@ -821,1 +822,1 @@\n-  const size_t live = bitmap->live_words_in_range(cm, search_start, oop(addr));\n+  const size_t live = bitmap->live_words_in_range(cm, search_start, cast_to_oop(addr));\n@@ -2059,1 +2060,1 @@\n-      _subtasks(),\n+      _subtasks(ParallelRootType::sentinel),\n@@ -2062,2 +2063,0 @@\n-    _subtasks.set_n_threads(active_workers);\n-    _subtasks.set_n_tasks(ParallelRootType::sentinel);\n@@ -2070,1 +2069,0 @@\n-    _subtasks.all_tasks_completed();\n@@ -2678,1 +2676,1 @@\n-  compaction_manager()->update_contents(oop(addr));\n+  compaction_manager()->update_contents(cast_to_oop(addr));\n@@ -2781,2 +2779,2 @@\n-      cm->update_contents(oop(addr));\n-      assert(oopDesc::is_oop_or_null(oop(addr)), \"Expected an oop or NULL at \" PTR_FORMAT, p2i(oop(addr)));\n+      cm->update_contents(cast_to_oop(addr));\n+      assert(oopDesc::is_oop_or_null(cast_to_oop(addr)), \"Expected an oop or NULL at \" PTR_FORMAT, p2i(cast_to_oop(addr)));\n@@ -3302,1 +3300,1 @@\n-  oop moved_oop = (oop) copy_destination();\n+  oop moved_oop = cast_to_oop(copy_destination());\n@@ -3360,1 +3358,1 @@\n-    addr += oop(addr)->size();\n+    addr += cast_to_oop(addr)->size();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-    oop new_obj = oop(obj->mark().decode_pointer());\n+    oop new_obj = cast_to_oop(obj->mark().decode_pointer());\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,4 +61,1 @@\n-  \/\/ No store check needed if we're storing a NULL or an old object\n-  \/\/ (latter case is probably a string constant). The concurrent\n-  \/\/ mark sweep garbage collector, however, needs to have all nonNull\n-  \/\/ oop updates flagged via card-marks.\n+  \/\/ No store check needed if we're storing a NULL.\n@@ -66,3 +63,1 @@\n-    \/\/ must be either an oop or NULL\n-    if (t == TypePtr::NULL_PTR || t == Type::TOP)\n-      \/\/ stores of null never (?) need barriers\n+    if (t == TypePtr::NULL_PTR || t == Type::TOP) {\n@@ -71,0 +66,1 @@\n+    }\n@@ -76,1 +72,1 @@\n-    \/\/ Keep this code in sync with new_deferred_store_barrier() in runtime.cpp.\n+    \/\/ Keep this code in sync with CardTableBarrierSet::on_slowpath_allocation_exit.\n@@ -86,0 +82,2 @@\n+  } else {\n+    \/\/ Else it's an array (or unknown), and we want more precise card marks.\n@@ -87,1 +85,1 @@\n-  \/\/ (Else it's an array (or unknown), and we want more precise card marks.)\n+\n@@ -96,1 +94,1 @@\n-  Node* card_offset = __ URShiftX( cast, __ ConI(CardTable::card_shift) );\n+  Node* card_offset = __ URShiftX(cast, __ ConI(CardTable::card_shift));\n@@ -99,1 +97,1 @@\n-  Node* card_adr = __ AddP(__ top(), byte_map_base_node(kit), card_offset );\n+  Node* card_adr = __ AddP(__ top(), byte_map_base_node(kit), card_offset);\n@@ -103,1 +101,3 @@\n-  Node*   zero = __ ConI(0); \/\/ Dirty card value\n+\n+  \/\/ Dirty card value to store\n+  Node* dirty = __ ConI(CardTable::dirty_card_val());\n@@ -114,1 +114,1 @@\n-    __ if_then(card_val, BoolTest::ne, zero);\n+    __ if_then(card_val, BoolTest::ne, dirty);\n@@ -117,2 +117,2 @@\n-  \/\/ Smash zero into card\n-  __ store(__ ctrl(), card_adr, zero, T_BYTE, adr_type, MemNode::unordered);\n+  \/\/ Smash dirty value into card\n+  __ store(__ ctrl(), card_adr, dirty, T_BYTE, adr_type, MemNode::unordered);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+  assert(_thread->is_Java_thread(), \"non Java threads shouldn't allocate on the Heap\");\n@@ -391,1 +392,1 @@\n-  return oop(mem);\n+  return cast_to_oop(mem);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1068,1 +1068,1 @@\n-        int nb = u->replace_edge(ctrl, region);\n+        int nb = u->replace_edge(ctrl, region, &phase->igvn());\n@@ -1248,1 +1248,1 @@\n-            int nb = u_clone->replace_edge(n, n_clone);\n+            int nb = u_clone->replace_edge(n, n_clone, &phase->igvn());\n@@ -1270,1 +1270,1 @@\n-                int nb = u->replace_edge(n, n_clone);\n+                int nb = u->replace_edge(n, n_clone, &phase->igvn());\n@@ -1288,1 +1288,2 @@\n-                  int nb = cmp_clone->replace_edge(nn, create_phis_on_call_return(ctrl, c, nn, nn_clone, projs, phase));\n+                  int nb = cmp_clone->replace_edge(nn, create_phis_on_call_return(ctrl, c, nn, nn_clone, projs, phase),\n+                                                   &phase->igvn());\n@@ -1298,1 +1299,1 @@\n-                  int nb = u->replace_edge(n, create_phis_on_call_return(ctrl, c, n, n_clone, projs, phase));\n+                  int nb = u->replace_edge(n, create_phis_on_call_return(ctrl, c, n, n_clone, projs, phase), &phase->igvn());\n@@ -1361,1 +1362,5 @@\n-    test_gc_state(ctrl, raw_mem, heap_stable_ctrl, phase, ShenandoahHeap::HAS_FORWARDED);\n+    int flags = ShenandoahHeap::HAS_FORWARDED;\n+    if (!ShenandoahBarrierSet::is_strong_access(lrb->decorators())) {\n+      flags |= ShenandoahHeap::WEAK_ROOTS;\n+    }\n+    test_gc_state(ctrl, raw_mem, heap_stable_ctrl, phase, flags);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,0 @@\n-  Handle       appendix(TRAPS);                  \/\/ if CPCE::has_appendix (from constant pool)\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -90,3 +90,3 @@\n-  LastFrameAccessor(JavaThread* thread) {\n-    assert(thread == Thread::current(), \"sanity\");\n-    _last_frame = thread->last_frame();\n+  LastFrameAccessor(JavaThread* current) {\n+    assert(current == Thread::current(), \"sanity\");\n+    _last_frame = current->last_frame();\n@@ -136,2 +136,2 @@\n-void InterpreterRuntime::set_bcp_and_mdp(address bcp, JavaThread *thread) {\n-  LastFrameAccessor last_frame(thread);\n+void InterpreterRuntime::set_bcp_and_mdp(address bcp, JavaThread* current) {\n+  LastFrameAccessor last_frame(current);\n@@ -154,1 +154,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::ldc(JavaThread* thread, bool wide))\n+JRT_ENTRY(void, InterpreterRuntime::ldc(JavaThread* current, bool wide))\n@@ -156,1 +156,1 @@\n-  LastFrameAccessor last_frame(thread);\n+  LastFrameAccessor last_frame(current);\n@@ -163,2 +163,2 @@\n-    oop java_class = klass->java_mirror();\n-    thread->set_vm_result(java_class);\n+  oop java_class = klass->java_mirror();\n+  current->set_vm_result(java_class);\n@@ -167,1 +167,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::resolve_ldc(JavaThread* thread, Bytecodes::Code bytecode)) {\n+JRT_ENTRY(void, InterpreterRuntime::resolve_ldc(JavaThread* current, Bytecodes::Code bytecode)) {\n@@ -173,1 +173,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -176,2 +176,2 @@\n-  LastFrameAccessor last_frame(thread);\n-  methodHandle m (thread, last_frame.method());\n+  LastFrameAccessor last_frame(current);\n+  methodHandle m (current, last_frame.method());\n@@ -207,1 +207,1 @@\n-  thread->set_vm_result(result);\n+  current->set_vm_result(result);\n@@ -214,1 +214,1 @@\n-    thread->set_vm_result_2((Metadata*)flags);\n+    current->set_vm_result_2((Metadata*)flags);\n@@ -223,1 +223,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))\n+JRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* current, ConstantPool* pool, int index))\n@@ -252,1 +252,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -291,1 +291,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::defaultvalue(JavaThread* thread, ConstantPool* pool, int index))\n+JRT_ENTRY(void, InterpreterRuntime::defaultvalue(JavaThread* current, ConstantPool* pool, int index))\n@@ -304,1 +304,1 @@\n-  thread->set_vm_result(res);\n+  current->set_vm_result(res);\n@@ -307,2 +307,2 @@\n-JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* thread, ConstantPoolCache* cp_cache))\n-  LastFrameAccessor last_frame(thread);\n+JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* current, ConstantPoolCache* cp_cache))\n+  LastFrameAccessor last_frame(current);\n@@ -365,1 +365,1 @@\n-  thread->set_vm_result(new_value_h());\n+  current->set_vm_result(new_value_h());\n@@ -369,1 +369,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_inline_type_field(JavaThread* thread, oopDesc* mirror, int index))\n+JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_inline_type_field(JavaThread* current, oopDesc* mirror, int index))\n@@ -400,1 +400,1 @@\n-    thread->set_vm_result(defaultvalue);\n+    current->set_vm_result(defaultvalue);\n@@ -418,1 +418,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::read_inlined_field(JavaThread* thread, oopDesc* obj, int index, Klass* field_holder))\n+JRT_ENTRY(void, InterpreterRuntime::read_inlined_field(JavaThread* current, oopDesc* obj, int index, Klass* field_holder))\n@@ -432,1 +432,1 @@\n-  thread->set_vm_result(res);\n+  current->set_vm_result(res);\n@@ -435,1 +435,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread* thread, BasicType type, jint size))\n+JRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread* current, BasicType type, jint size))\n@@ -437,1 +437,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -441,1 +441,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::anewarray(JavaThread* thread, ConstantPool* pool, int index, jint size))\n+JRT_ENTRY(void, InterpreterRuntime::anewarray(JavaThread* current, ConstantPool* pool, int index, jint size))\n@@ -451,1 +451,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -454,2 +454,2 @@\n-JRT_ENTRY(void, InterpreterRuntime::value_array_load(JavaThread* thread, arrayOopDesc* array, int index))\n-  flatArrayHandle vah(thread, (flatArrayOop)array);\n+JRT_ENTRY(void, InterpreterRuntime::value_array_load(JavaThread* current, arrayOopDesc* array, int index))\n+  flatArrayHandle vah(current, (flatArrayOop)array);\n@@ -457,1 +457,1 @@\n-  thread->set_vm_result(value_holder);\n+  current->set_vm_result(value_holder);\n@@ -460,1 +460,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::value_array_store(JavaThread* thread, void* val, arrayOopDesc* array, int index))\n+JRT_ENTRY(void, InterpreterRuntime::value_array_store(JavaThread* current, void* val, arrayOopDesc* array, int index))\n@@ -462,1 +462,1 @@\n-  ((flatArrayOop)array)->value_copy_to_index((oop)val, index);\n+  ((flatArrayOop)array)->value_copy_to_index(cast_to_oop(val), index);\n@@ -465,1 +465,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::multianewarray(JavaThread* thread, jint* first_size_address))\n+JRT_ENTRY(void, InterpreterRuntime::multianewarray(JavaThread* current, jint* first_size_address))\n@@ -467,1 +467,1 @@\n-  LastFrameAccessor last_frame(thread);\n+  LastFrameAccessor last_frame(current);\n@@ -481,1 +481,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -494,1 +494,1 @@\n-  thread->set_vm_result(obj);\n+  current->set_vm_result(obj);\n@@ -498,1 +498,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::register_finalizer(JavaThread* thread, oopDesc* obj))\n+JRT_ENTRY(void, InterpreterRuntime::register_finalizer(JavaThread* current, oopDesc* obj))\n@@ -504,1 +504,1 @@\n-JRT_ENTRY(jboolean, InterpreterRuntime::is_substitutable(JavaThread* thread, oopDesc* aobj, oopDesc* bobj))\n+JRT_ENTRY(jboolean, InterpreterRuntime::is_substitutable(JavaThread* current, oopDesc* aobj, oopDesc* bobj))\n@@ -513,1 +513,1 @@\n-  methodHandle method(thread, Universe::is_substitutable_method());\n+  methodHandle method(current, Universe::is_substitutable_method());\n@@ -529,1 +529,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::quicken_io_cc(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::quicken_io_cc(JavaThread* current))\n@@ -531,1 +531,1 @@\n-  LastFrameAccessor last_frame(thread);\n+  LastFrameAccessor last_frame(current);\n@@ -539,1 +539,1 @@\n-  thread->set_vm_result_2(klass);\n+  current->set_vm_result_2(klass);\n@@ -546,2 +546,2 @@\n-void InterpreterRuntime::note_trap_inner(JavaThread* thread, int reason,\n-                                         const methodHandle& trap_method, int trap_bci, TRAPS) {\n+void InterpreterRuntime::note_trap_inner(JavaThread* current, int reason,\n+                                         const methodHandle& trap_method, int trap_bci) {\n@@ -551,0 +551,2 @@\n+      ExceptionMark em(current);\n+      JavaThread* THREAD = current; \/\/ for exception macros\n@@ -571,1 +573,1 @@\n-void InterpreterRuntime::note_trap(JavaThread* thread, int reason, TRAPS) {\n+void InterpreterRuntime::note_trap(JavaThread* current, int reason) {\n@@ -573,2 +575,2 @@\n-  LastFrameAccessor last_frame(thread);\n-  methodHandle trap_method(thread, last_frame.method());\n+  LastFrameAccessor last_frame(current);\n+  methodHandle trap_method(current, last_frame.method());\n@@ -576,1 +578,1 @@\n-  note_trap_inner(thread, reason, trap_method, trap_bci, THREAD);\n+  note_trap_inner(current, reason, trap_method, trap_bci);\n@@ -599,1 +601,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_StackOverflowError(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_StackOverflowError(JavaThread* current))\n@@ -608,1 +610,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_delayed_StackOverflowError(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_delayed_StackOverflowError(JavaThread* current))\n@@ -619,1 +621,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::create_exception(JavaThread* thread, char* name, char* message))\n+JRT_ENTRY(void, InterpreterRuntime::create_exception(JavaThread* current, char* name, char* message))\n@@ -624,1 +626,1 @@\n-      note_trap(thread, Deoptimization::Reason_div0_check, CHECK);\n+      note_trap(current, Deoptimization::Reason_div0_check);\n@@ -626,1 +628,1 @@\n-      note_trap(thread, Deoptimization::Reason_null_check, CHECK);\n+      note_trap(current, Deoptimization::Reason_null_check);\n@@ -630,2 +632,2 @@\n-  Handle exception = Exceptions::new_exception(thread, s, message);\n-  thread->set_vm_result(exception());\n+  Handle exception = Exceptions::new_exception(current, s, message);\n+  current->set_vm_result(exception());\n@@ -635,1 +637,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::create_klass_exception(JavaThread* thread, char* name, oopDesc* obj))\n+JRT_ENTRY(void, InterpreterRuntime::create_klass_exception(JavaThread* current, char* name, oopDesc* obj))\n@@ -637,1 +639,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -642,1 +644,1 @@\n-    note_trap(thread, Deoptimization::Reason_class_check, CHECK);\n+    note_trap(current, Deoptimization::Reason_class_check);\n@@ -645,2 +647,2 @@\n-  Handle exception = Exceptions::new_exception(thread, s, klass_name);\n-  thread->set_vm_result(exception());\n+  Handle exception = Exceptions::new_exception(current, s, klass_name);\n+  current->set_vm_result(exception());\n@@ -649,1 +651,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_ArrayIndexOutOfBoundsException(JavaThread* thread, arrayOopDesc* a, jint index))\n+JRT_ENTRY(void, InterpreterRuntime::throw_ArrayIndexOutOfBoundsException(JavaThread* current, arrayOopDesc* a, jint index))\n@@ -651,1 +653,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -656,1 +658,1 @@\n-    note_trap(thread, Deoptimization::Reason_range_check, CHECK);\n+    note_trap(current, Deoptimization::Reason_range_check);\n@@ -663,1 +665,1 @@\n-  JavaThread* thread, oopDesc* obj))\n+  JavaThread* current, oopDesc* obj))\n@@ -666,1 +668,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -668,1 +670,1 @@\n-    thread, obj->klass());\n+    current, obj->klass());\n@@ -671,1 +673,1 @@\n-    note_trap(thread, Deoptimization::Reason_class_check, CHECK);\n+    note_trap(current, Deoptimization::Reason_class_check);\n@@ -686,1 +688,1 @@\n-JRT_ENTRY(address, InterpreterRuntime::exception_handler_for_exception(JavaThread* thread, oopDesc* exception))\n+JRT_ENTRY(address, InterpreterRuntime::exception_handler_for_exception(JavaThread* current, oopDesc* exception))\n@@ -690,1 +692,1 @@\n-  StackWatermarkSet::after_unwind(thread);\n+  StackWatermarkSet::after_unwind(current);\n@@ -692,4 +694,4 @@\n-  LastFrameAccessor last_frame(thread);\n-  Handle             h_exception(thread, exception);\n-  methodHandle       h_method   (thread, last_frame.method());\n-  constantPoolHandle h_constants(thread, h_method->constants());\n+  LastFrameAccessor last_frame(current);\n+  Handle             h_exception(current, exception);\n+  methodHandle       h_method   (current, last_frame.method());\n+  constantPoolHandle h_constants(current, h_method->constants());\n@@ -700,1 +702,1 @@\n-  if (thread->frames_to_pop_failed_realloc() > 0) {\n+  if (current->frames_to_pop_failed_realloc() > 0) {\n@@ -703,2 +705,2 @@\n-    thread->dec_frames_to_pop_failed_realloc();\n-    thread->set_vm_result(h_exception());\n+    current->dec_frames_to_pop_failed_realloc();\n+    current->set_vm_result(h_exception());\n@@ -708,1 +710,1 @@\n-    thread->set_do_not_unlock_if_synchronized(true);\n+    current->set_do_not_unlock_if_synchronized(true);\n@@ -716,1 +718,1 @@\n-  if (thread->do_not_unlock_if_synchronized()) {\n+  if (current->do_not_unlock_if_synchronized()) {\n@@ -719,1 +721,1 @@\n-    thread->set_vm_result(exception);\n+    current->set_vm_result(exception);\n@@ -734,1 +736,1 @@\n-      ResourceMark rm(thread);\n+      ResourceMark rm(current);\n@@ -738,1 +740,1 @@\n-                   h_method->print_value_string(), current_bci, p2i(thread), thread->name());\n+                   h_method->print_value_string(), current_bci, p2i(current), current->name());\n@@ -771,1 +773,1 @@\n-    ResourceMark rm(thread);\n+    ResourceMark rm(current);\n@@ -783,1 +785,1 @@\n-    JvmtiExport::post_exception_throw(thread, h_method(), last_frame.bcp(), h_exception());\n+    JvmtiExport::post_exception_throw(current, h_method(), last_frame.bcp(), h_exception());\n@@ -788,1 +790,1 @@\n-  if (handler_bci < 0 || !thread->stack_overflow_state()->reguard_stack((address) &continuation)) {\n+  if (handler_bci < 0 || !current->stack_overflow_state()->reguard_stack((address) &continuation)) {\n@@ -801,1 +803,1 @@\n-    set_bcp_and_mdp(handler_pc, thread);\n+    set_bcp_and_mdp(handler_pc, current);\n@@ -811,1 +813,1 @@\n-    JvmtiExport::notice_unwind_due_to_exception(thread, h_method(), handler_pc, h_exception(), (handler_pc != NULL));\n+    JvmtiExport::notice_unwind_due_to_exception(current, h_method(), handler_pc, h_exception(), (handler_pc != NULL));\n@@ -814,1 +816,1 @@\n-  thread->set_vm_result(h_exception());\n+  current->set_vm_result(h_exception());\n@@ -819,2 +821,2 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_pending_exception(JavaThread* thread))\n-  assert(thread->has_pending_exception(), \"must only ne called if there's an exception pending\");\n+JRT_ENTRY(void, InterpreterRuntime::throw_pending_exception(JavaThread* current))\n+  assert(current->has_pending_exception(), \"must only be called if there's an exception pending\");\n@@ -825,1 +827,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodError(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodError(JavaThread* current))\n@@ -835,1 +837,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorWithMethod(JavaThread* thread,\n+JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorWithMethod(JavaThread* current,\n@@ -837,1 +839,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -839,1 +841,1 @@\n-  methodHandle m(thread, missingMethod);\n+  methodHandle m(current, missingMethod);\n@@ -843,1 +845,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorVerbose(JavaThread* thread,\n+JRT_ENTRY(void, InterpreterRuntime::throw_AbstractMethodErrorVerbose(JavaThread* current,\n@@ -846,2 +848,2 @@\n-  ResourceMark rm(thread);\n-  methodHandle mh = methodHandle(thread, missingMethod);\n+  ResourceMark rm(current);\n+  methodHandle mh = methodHandle(current, missingMethod);\n@@ -851,1 +853,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_InstantiationError(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_InstantiationError(JavaThread* current))\n@@ -856,1 +858,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeError(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeError(JavaThread* current))\n@@ -860,1 +862,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose(JavaThread* thread,\n+JRT_ENTRY(void, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose(JavaThread* current,\n@@ -863,1 +865,1 @@\n-  ResourceMark rm(thread);\n+  ResourceMark rm(current);\n@@ -873,1 +875,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_NullPointerException(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_NullPointerException(JavaThread* current))\n@@ -881,2 +883,1 @@\n-void InterpreterRuntime::resolve_get_put(JavaThread* thread, Bytecodes::Code bytecode) {\n-  Thread* THREAD = thread;\n+void InterpreterRuntime::resolve_get_put(JavaThread* current, Bytecodes::Code bytecode) {\n@@ -885,3 +886,3 @@\n-  LastFrameAccessor last_frame(thread);\n-  constantPoolHandle pool(thread, last_frame.method()->constants());\n-  methodHandle m(thread, last_frame.method());\n+  LastFrameAccessor last_frame(current);\n+  constantPoolHandle pool(current, last_frame.method()->constants());\n+  methodHandle m(current, last_frame.method());\n@@ -894,1 +895,2 @@\n-    JvmtiHideSingleStepping jhss(thread);\n+    JvmtiHideSingleStepping jhss(current);\n+    Thread* THREAD = current;  \/\/ for exception macros\n@@ -957,2 +959,1 @@\n-    info.is_inline_type(),\n-    pool->pool_holder()\n+    info.is_inline_type()\n@@ -971,1 +972,1 @@\n-JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))\n+JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* current, BasicObjectLock* elem))\n@@ -973,1 +974,1 @@\n-  thread->last_frame().interpreter_frame_verify_monitor(elem);\n+  current->last_frame().interpreter_frame_verify_monitor(elem);\n@@ -978,1 +979,1 @@\n-  Handle h_obj(thread, elem->obj());\n+  Handle h_obj(current, elem->obj());\n@@ -981,1 +982,1 @@\n-  ObjectSynchronizer::enter(h_obj, elem->lock(), CHECK);\n+  ObjectSynchronizer::enter(h_obj, elem->lock(), current);\n@@ -985,1 +986,1 @@\n-  thread->last_frame().interpreter_frame_verify_monitor(elem);\n+  current->last_frame().interpreter_frame_verify_monitor(elem);\n@@ -1001,1 +1002,1 @@\n-  ObjectSynchronizer::exit(obj, elem->lock(), Thread::current());\n+  ObjectSynchronizer::exit(obj, elem->lock(), JavaThread::current());\n@@ -1008,1 +1009,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::throw_illegal_monitor_state_exception(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::throw_illegal_monitor_state_exception(JavaThread* current))\n@@ -1013,1 +1014,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::new_illegal_monitor_state_exception(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::new_illegal_monitor_state_exception(JavaThread* current))\n@@ -1020,1 +1021,1 @@\n-  Handle exception(thread, thread->vm_result());\n+  Handle exception(current, current->vm_result());\n@@ -1022,1 +1023,1 @@\n-  thread->set_vm_result(NULL); \/\/ clear vm result before continuing (may cause memory leaks and assert failures)\n+  current->set_vm_result(NULL); \/\/ clear vm result before continuing (may cause memory leaks and assert failures)\n@@ -1028,1 +1029,1 @@\n-  thread->set_vm_result(exception());\n+  current->set_vm_result(exception());\n@@ -1035,1 +1036,1 @@\n-JRT_ENTRY(Bytecodes::Code, InterpreterRuntime::get_original_bytecode_at(JavaThread* thread, Method* method, address bcp))\n+JRT_ENTRY(Bytecodes::Code, InterpreterRuntime::get_original_bytecode_at(JavaThread* current, Method* method, address bcp))\n@@ -1039,1 +1040,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::set_original_bytecode_at(JavaThread* thread, Method* method, address bcp, Bytecodes::Code new_code))\n+JRT_ENTRY(void, InterpreterRuntime::set_original_bytecode_at(JavaThread* current, Method* method, address bcp, Bytecodes::Code new_code))\n@@ -1043,2 +1044,2 @@\n-JRT_ENTRY(void, InterpreterRuntime::_breakpoint(JavaThread* thread, Method* method, address bcp))\n-  JvmtiExport::post_raw_breakpoint(thread, method, bcp);\n+JRT_ENTRY(void, InterpreterRuntime::_breakpoint(JavaThread* current, Method* method, address bcp))\n+  JvmtiExport::post_raw_breakpoint(current, method, bcp);\n@@ -1047,3 +1048,2 @@\n-void InterpreterRuntime::resolve_invoke(JavaThread* thread, Bytecodes::Code bytecode) {\n-  Thread* THREAD = thread;\n-  LastFrameAccessor last_frame(thread);\n+void InterpreterRuntime::resolve_invoke(JavaThread* current, Bytecodes::Code bytecode) {\n+  LastFrameAccessor last_frame(current);\n@@ -1051,1 +1051,1 @@\n-  Handle receiver(thread, NULL);\n+  Handle receiver(current, NULL);\n@@ -1054,2 +1054,2 @@\n-    ResourceMark rm(thread);\n-    methodHandle m (thread, last_frame.method());\n+    ResourceMark rm(current);\n+    methodHandle m (current, last_frame.method());\n@@ -1058,1 +1058,1 @@\n-    receiver = Handle(thread, last_frame.callee_receiver(signature));\n+    receiver = Handle(current, last_frame.callee_receiver(signature));\n@@ -1069,1 +1069,1 @@\n-  constantPoolHandle pool(thread, last_frame.method()->constants());\n+  constantPoolHandle pool(current, last_frame.method()->constants());\n@@ -1074,1 +1074,2 @@\n-    JvmtiHideSingleStepping jhss(thread);\n+    JvmtiHideSingleStepping jhss(current);\n+    Thread* THREAD = current;  \/\/ for exception macros\n@@ -1079,1 +1080,1 @@\n-      resolved_method = methodHandle(THREAD, info.resolved_method()->get_new_method());\n+      resolved_method = methodHandle(current, info.resolved_method()->get_new_method());\n@@ -1081,1 +1082,1 @@\n-      resolved_method = methodHandle(THREAD, info.resolved_method());\n+      resolved_method = methodHandle(current, info.resolved_method());\n@@ -1146,2 +1147,1 @@\n-void InterpreterRuntime::resolve_invokehandle(JavaThread* thread) {\n-  Thread* THREAD = thread;\n+void InterpreterRuntime::resolve_invokehandle(JavaThread* current) {\n@@ -1149,1 +1149,1 @@\n-  LastFrameAccessor last_frame(thread);\n+  LastFrameAccessor last_frame(current);\n@@ -1153,1 +1153,1 @@\n-  constantPoolHandle pool(thread, last_frame.method()->constants());\n+  constantPoolHandle pool(current, last_frame.method()->constants());\n@@ -1155,1 +1155,2 @@\n-    JvmtiHideSingleStepping jhss(thread);\n+    JvmtiHideSingleStepping jhss(current);\n+    Thread* THREAD = current;  \/\/ for exception macros\n@@ -1166,3 +1167,2 @@\n-void InterpreterRuntime::resolve_invokedynamic(JavaThread* thread) {\n-  Thread* THREAD = thread;\n-  LastFrameAccessor last_frame(thread);\n+void InterpreterRuntime::resolve_invokedynamic(JavaThread* current) {\n+  LastFrameAccessor last_frame(current);\n@@ -1173,1 +1173,1 @@\n-  constantPoolHandle pool(thread, last_frame.method()->constants());\n+  constantPoolHandle pool(current, last_frame.method()->constants());\n@@ -1176,1 +1176,2 @@\n-    JvmtiHideSingleStepping jhss(thread);\n+    JvmtiHideSingleStepping jhss(current);\n+    Thread* THREAD = current;  \/\/ for exception macros\n@@ -1188,1 +1189,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::resolve_from_cache(JavaThread* thread, Bytecodes::Code bytecode)) {\n+JRT_ENTRY(void, InterpreterRuntime::resolve_from_cache(JavaThread* current, Bytecodes::Code bytecode)) {\n@@ -1195,1 +1196,1 @@\n-    resolve_get_put(thread, bytecode);\n+    resolve_get_put(current, bytecode);\n@@ -1201,1 +1202,1 @@\n-    resolve_invoke(thread, bytecode);\n+    resolve_invoke(current, bytecode);\n@@ -1204,1 +1205,1 @@\n-    resolve_invokehandle(thread);\n+    resolve_invokehandle(current);\n@@ -1207,1 +1208,1 @@\n-    resolve_invokedynamic(thread);\n+    resolve_invokedynamic(current);\n@@ -1220,1 +1221,4 @@\n-nmethod* InterpreterRuntime::frequency_counter_overflow(JavaThread* thread, address branch_bcp) {\n+nmethod* InterpreterRuntime::frequency_counter_overflow(JavaThread* current, address branch_bcp) {\n+  \/\/ Enable WXWrite: the function is called directly by interpreter.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n+\n@@ -1222,1 +1226,1 @@\n-  nmethod* nm = frequency_counter_overflow_inner(thread, branch_bcp);\n+  nmethod* nm = frequency_counter_overflow_inner(current, branch_bcp);\n@@ -1230,1 +1234,1 @@\n-    LastFrameAccessor last_frame(thread);\n+    LastFrameAccessor last_frame(current);\n@@ -1242,1 +1246,1 @@\n-  if (nm != NULL && thread->is_interp_only_mode()) {\n+  if (nm != NULL && current->is_interp_only_mode()) {\n@@ -1262,1 +1266,1 @@\n-          InterpreterRuntime::frequency_counter_overflow_inner(JavaThread* thread, address branch_bcp))\n+          InterpreterRuntime::frequency_counter_overflow_inner(JavaThread* current, address branch_bcp))\n@@ -1265,1 +1269,1 @@\n-  UnlockFlagSaver fs(thread);\n+  UnlockFlagSaver fs(current);\n@@ -1267,1 +1271,1 @@\n-  LastFrameAccessor last_frame(thread);\n+  LastFrameAccessor last_frame(current);\n@@ -1269,1 +1273,1 @@\n-  methodHandle method(thread, last_frame.method());\n+  methodHandle method(current, last_frame.method());\n@@ -1273,1 +1277,1 @@\n-  nmethod* osr_nm = CompilationPolicy::event(method, method, branch_bci, bci, CompLevel_none, NULL, THREAD);\n+  nmethod* osr_nm = CompilationPolicy::event(method, method, branch_bci, bci, CompLevel_none, NULL, CHECK_NULL);\n@@ -1296,1 +1300,1 @@\n-          objects_to_revoke->append(Handle(THREAD, kptr->obj()));\n+          objects_to_revoke->append(Handle(current, kptr->obj()));\n@@ -1299,1 +1303,1 @@\n-      BiasedLocking::revoke(objects_to_revoke, thread);\n+      BiasedLocking::revoke(objects_to_revoke, current);\n@@ -1342,1 +1346,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::update_mdp_for_ret(JavaThread* thread, int return_bci))\n+JRT_ENTRY(void, InterpreterRuntime::update_mdp_for_ret(JavaThread* current, int return_bci))\n@@ -1344,2 +1348,2 @@\n-  ResourceMark rm(thread);\n-  LastFrameAccessor last_frame(thread);\n+  ResourceMark rm(current);\n+  LastFrameAccessor last_frame(current);\n@@ -1362,8 +1366,2 @@\n-JRT_ENTRY(MethodCounters*, InterpreterRuntime::build_method_counters(JavaThread* thread, Method* m))\n-  MethodCounters* mcs = Method::build_method_counters(m, thread);\n-  if (HAS_PENDING_EXCEPTION) {\n-    \/\/ Only metaspace OOM is expected. No Java code executed.\n-    assert((PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n-    CLEAR_PENDING_EXCEPTION;\n-  }\n-  return mcs;\n+JRT_ENTRY(MethodCounters*, InterpreterRuntime::build_method_counters(JavaThread* current, Method* m))\n+  return Method::build_method_counters(current, m);\n@@ -1373,1 +1371,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::at_safepoint(JavaThread* thread))\n+JRT_ENTRY(void, InterpreterRuntime::at_safepoint(JavaThread* current))\n@@ -1385,1 +1383,1 @@\n-    StackWatermarkSet::before_unwind(thread);\n+    StackWatermarkSet::before_unwind(current);\n@@ -1390,2 +1388,2 @@\n-    LastFrameAccessor last_frame(thread);\n-    JvmtiExport::at_single_stepping_point(thread, last_frame.method(), last_frame.bcp());\n+    LastFrameAccessor last_frame(current);\n+    JvmtiExport::at_single_stepping_point(current, last_frame.method(), last_frame.bcp());\n@@ -1395,1 +1393,1 @@\n-JRT_LEAF(void, InterpreterRuntime::at_unwind(JavaThread* thread))\n+JRT_LEAF(void, InterpreterRuntime::at_unwind(JavaThread* current))\n@@ -1403,1 +1401,1 @@\n-  StackWatermarkSet::before_unwind(thread);\n+  StackWatermarkSet::before_unwind(current);\n@@ -1406,2 +1404,2 @@\n-JRT_ENTRY(void, InterpreterRuntime::post_field_access(JavaThread *thread, oopDesc* obj,\n-ConstantPoolCacheEntry *cp_entry))\n+JRT_ENTRY(void, InterpreterRuntime::post_field_access(JavaThread* current, oopDesc* obj,\n+                                                      ConstantPoolCacheEntry *cp_entry))\n@@ -1417,1 +1415,1 @@\n-  HandleMark hm(thread);\n+  HandleMark hm(current);\n@@ -1422,1 +1420,1 @@\n-    h_obj = Handle(thread, obj);\n+    h_obj = Handle(current, obj);\n@@ -1426,2 +1424,2 @@\n-  LastFrameAccessor last_frame(thread);\n-  JvmtiExport::post_field_access(thread, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);\n+  LastFrameAccessor last_frame(current);\n+  JvmtiExport::post_field_access(current, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);\n@@ -1430,2 +1428,2 @@\n-JRT_ENTRY(void, InterpreterRuntime::post_field_modification(JavaThread *thread,\n-  oopDesc* obj, ConstantPoolCacheEntry *cp_entry, jvalue *value))\n+JRT_ENTRY(void, InterpreterRuntime::post_field_modification(JavaThread* current, oopDesc* obj,\n+                                                            ConstantPoolCacheEntry *cp_entry, jvalue *value))\n@@ -1464,1 +1462,1 @@\n-  HandleMark hm(thread);\n+  HandleMark hm(current);\n@@ -1486,1 +1484,1 @@\n-    h_obj = Handle(thread, obj);\n+    h_obj = Handle(current, obj);\n@@ -1489,2 +1487,2 @@\n-  LastFrameAccessor last_frame(thread);\n-  JvmtiExport::post_raw_field_modification(thread, last_frame.method(), last_frame.bcp(), ik, h_obj,\n+  LastFrameAccessor last_frame(current);\n+  JvmtiExport::post_raw_field_modification(current, last_frame.method(), last_frame.bcp(), ik, h_obj,\n@@ -1494,3 +1492,3 @@\n-JRT_ENTRY(void, InterpreterRuntime::post_method_entry(JavaThread *thread))\n-  LastFrameAccessor last_frame(thread);\n-  JvmtiExport::post_method_entry(thread, last_frame.method(), last_frame.get_frame());\n+JRT_ENTRY(void, InterpreterRuntime::post_method_entry(JavaThread* current))\n+  LastFrameAccessor last_frame(current);\n+  JvmtiExport::post_method_entry(current, last_frame.method(), last_frame.get_frame());\n@@ -1503,3 +1501,3 @@\n-JRT_BLOCK_ENTRY(void, InterpreterRuntime::post_method_exit(JavaThread *thread))\n-  LastFrameAccessor last_frame(thread);\n-  JvmtiExport::post_method_exit(thread, last_frame.method(), last_frame.get_frame());\n+JRT_BLOCK_ENTRY(void, InterpreterRuntime::post_method_exit(JavaThread* current))\n+  LastFrameAccessor last_frame(current);\n+  JvmtiExport::post_method_exit(current, last_frame.method(), last_frame.get_frame());\n@@ -1705,2 +1703,2 @@\n-JRT_ENTRY(void, InterpreterRuntime::prepare_native_call(JavaThread* thread, Method* method))\n-  methodHandle m(thread, method);\n+JRT_ENTRY(void, InterpreterRuntime::prepare_native_call(JavaThread* current, Method* method))\n+  methodHandle m(current, method);\n@@ -1709,2 +1707,1 @@\n-  bool in_base_library;\n-    NativeLookup::lookup(m, in_base_library, CHECK);\n+    NativeLookup::lookup(m, CHECK);\n@@ -1722,1 +1719,1 @@\n-JRT_LEAF(void, InterpreterRuntime::popframe_move_outgoing_args(JavaThread* thread, void* src_address, void* dest_address))\n+JRT_LEAF(void, InterpreterRuntime::popframe_move_outgoing_args(JavaThread* current, void* src_address, void* dest_address))\n@@ -1727,1 +1724,1 @@\n-  LastFrameAccessor last_frame(thread);\n+  LastFrameAccessor last_frame(current);\n@@ -1730,1 +1727,1 @@\n-  methodHandle mh(thread, last_frame.method());\n+  methodHandle mh(current, last_frame.method());\n@@ -1746,1 +1743,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::member_name_arg_or_null(JavaThread* thread, address member_name,\n+JRT_ENTRY(void, InterpreterRuntime::member_name_arg_or_null(JavaThread* current, address member_name,\n@@ -1758,1 +1755,1 @@\n-    oop member_name_oop = (oop) member_name;\n+    oop member_name_oop = cast_to_oop(member_name);\n@@ -1763,1 +1760,1 @@\n-    thread->set_vm_result(member_name_oop);\n+    current->set_vm_result(member_name_oop);\n@@ -1765,1 +1762,1 @@\n-    thread->set_vm_result(NULL);\n+    current->set_vm_result(NULL);\n@@ -1775,2 +1772,2 @@\n-JRT_LEAF(intptr_t, InterpreterRuntime::trace_bytecode(JavaThread* thread, intptr_t preserve_this_value, intptr_t tos, intptr_t tos2))\n-  LastFrameAccessor last_frame(thread);\n+JRT_LEAF(intptr_t, InterpreterRuntime::trace_bytecode(JavaThread* current, intptr_t preserve_this_value, intptr_t tos, intptr_t tos2))\n+  LastFrameAccessor last_frame(current);\n@@ -1778,1 +1775,1 @@\n-  methodHandle mh(thread, last_frame.method());\n+  methodHandle mh(current, last_frame.method());\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":210,"deletions":213,"binary":false,"changes":423,"status":"modified"},{"patch":"@@ -48,4 +48,4 @@\n-  static void      set_bcp_and_mdp(address bcp, JavaThread*thread);\n-  static void      note_trap_inner(JavaThread* thread, int reason,\n-                                   const methodHandle& trap_method, int trap_bci, TRAPS);\n-  static void      note_trap(JavaThread *thread, int reason, TRAPS);\n+  static void      set_bcp_and_mdp(address bcp, JavaThread* current);\n+  static void      note_trap_inner(JavaThread* current, int reason,\n+                                   const methodHandle& trap_method, int trap_bci);\n+  static void      note_trap(JavaThread* current, int reason);\n@@ -54,1 +54,1 @@\n-  static nmethod* frequency_counter_overflow_inner(JavaThread* thread, address branch_bcp);\n+  static nmethod* frequency_counter_overflow_inner(JavaThread* current, address branch_bcp);\n@@ -58,2 +58,2 @@\n-  static void    ldc           (JavaThread* thread, bool wide);\n-  static void    resolve_ldc   (JavaThread* thread, Bytecodes::Code bytecode);\n+  static void    ldc           (JavaThread* current, bool wide);\n+  static void    resolve_ldc   (JavaThread* current, Bytecodes::Code bytecode);\n@@ -62,15 +62,15 @@\n-  static void    _new          (JavaThread* thread, ConstantPool* pool, int index);\n-  static void    newarray      (JavaThread* thread, BasicType type, jint size);\n-  static void    anewarray     (JavaThread* thread, ConstantPool* pool, int index, jint size);\n-  static void    multianewarray(JavaThread* thread, jint* first_size_address);\n-  static void    register_finalizer(JavaThread* thread, oopDesc* obj);\n-  static void    defaultvalue  (JavaThread* thread, ConstantPool* pool, int index);\n-  static int     withfield     (JavaThread* thread, ConstantPoolCache* cp_cache);\n-  static void    uninitialized_static_inline_type_field(JavaThread* thread, oopDesc* mirror, int offset);\n-  static void    write_heap_copy (JavaThread* thread, oopDesc* value, int offset, oopDesc* rcv);\n-  static void    read_inlined_field(JavaThread* thread, oopDesc* value, int index, Klass* field_holder);\n-\n-  static void value_array_load(JavaThread* thread, arrayOopDesc* array, int index);\n-  static void value_array_store(JavaThread* thread, void* val, arrayOopDesc* array, int index);\n-\n-  static jboolean is_substitutable(JavaThread* thread, oopDesc* aobj, oopDesc* bobj);\n+  static void    _new          (JavaThread* current, ConstantPool* pool, int index);\n+  static void    newarray      (JavaThread* current, BasicType type, jint size);\n+  static void    anewarray     (JavaThread* threcurrentad, ConstantPool* pool, int index, jint size);\n+  static void    multianewarray(JavaThread* current, jint* first_size_address);\n+  static void    register_finalizer(JavaThread* current, oopDesc* obj);\n+  static void    defaultvalue  (JavaThread* current, ConstantPool* pool, int index);\n+  static int     withfield     (JavaThread* current, ConstantPoolCache* cp_cache);\n+  static void    uninitialized_static_inline_type_field(JavaThread* current, oopDesc* mirror, int offset);\n+  static void    write_heap_copy (JavaThread* current, oopDesc* value, int offset, oopDesc* rcv);\n+  static void    read_inlined_field(JavaThread* current, oopDesc* value, int index, Klass* field_holder);\n+\n+  static void value_array_load(JavaThread* current, arrayOopDesc* array, int index);\n+  static void value_array_store(JavaThread* current, void* val, arrayOopDesc* array, int index);\n+\n+  static jboolean is_substitutable(JavaThread* current, oopDesc* aobj, oopDesc* bobj);\n@@ -79,1 +79,1 @@\n-  static void    quicken_io_cc(JavaThread* thread);\n+  static void    quicken_io_cc(JavaThread* current);\n@@ -82,3 +82,3 @@\n-  static void    throw_AbstractMethodError(JavaThread* thread);\n-  static void    throw_AbstractMethodErrorWithMethod(JavaThread* thread, Method* oop);\n-  static void    throw_AbstractMethodErrorVerbose(JavaThread* thread,\n+  static void    throw_AbstractMethodError(JavaThread* current);\n+  static void    throw_AbstractMethodErrorWithMethod(JavaThread* current, Method* oop);\n+  static void    throw_AbstractMethodErrorVerbose(JavaThread* current,\n@@ -88,3 +88,3 @@\n-  static void    throw_InstantiationError(JavaThread* thread);\n-  static void    throw_IncompatibleClassChangeError(JavaThread* thread);\n-  static void    throw_IncompatibleClassChangeErrorVerbose(JavaThread* thread,\n+  static void    throw_InstantiationError(JavaThread* current);\n+  static void    throw_IncompatibleClassChangeError(JavaThread* current);\n+  static void    throw_IncompatibleClassChangeErrorVerbose(JavaThread* current,\n@@ -93,9 +93,9 @@\n-  static void    throw_StackOverflowError(JavaThread* thread);\n-  static void    throw_delayed_StackOverflowError(JavaThread* thread);\n-  static void    throw_ArrayIndexOutOfBoundsException(JavaThread* thread, arrayOopDesc* a, jint index);\n-  static void    throw_ClassCastException(JavaThread* thread, oopDesc* obj);\n-  static void    throw_NullPointerException(JavaThread* thread);\n-\n-  static void    create_exception(JavaThread* thread, char* name, char* message);\n-  static void    create_klass_exception(JavaThread* thread, char* name, oopDesc* obj);\n-  static address exception_handler_for_exception(JavaThread* thread, oopDesc* exception);\n+  static void    throw_StackOverflowError(JavaThread* current);\n+  static void    throw_delayed_StackOverflowError(JavaThread* current);\n+  static void    throw_ArrayIndexOutOfBoundsException(JavaThread* current, arrayOopDesc* a, jint index);\n+  static void    throw_ClassCastException(JavaThread* current, oopDesc* obj);\n+  static void    throw_NullPointerException(JavaThread* current);\n+\n+  static void    create_exception(JavaThread* current, char* name, char* message);\n+  static void    create_klass_exception(JavaThread* current, char* name, oopDesc* obj);\n+  static address exception_handler_for_exception(JavaThread* current, oopDesc* exception);\n@@ -103,1 +103,1 @@\n-  static void    member_name_arg_or_null(JavaThread* thread, address dmh, Method* m, address bcp);\n+  static void    member_name_arg_or_null(JavaThread* current, address dmh, Method* m, address bcp);\n@@ -105,1 +105,1 @@\n-  static void    throw_pending_exception(JavaThread* thread);\n+  static void    throw_pending_exception(JavaThread* current);\n@@ -107,1 +107,1 @@\n-  static void resolve_from_cache(JavaThread* thread, Bytecodes::Code bytecode);\n+  static void resolve_from_cache(JavaThread* current, Bytecodes::Code bytecode);\n@@ -110,1 +110,1 @@\n-  static void resolve_get_put(JavaThread* thread, Bytecodes::Code bytecode);\n+  static void resolve_get_put(JavaThread* current, Bytecodes::Code bytecode);\n@@ -113,3 +113,3 @@\n-  static void resolve_invoke(JavaThread* thread, Bytecodes::Code bytecode);\n-  static void resolve_invokehandle (JavaThread* thread);\n-  static void resolve_invokedynamic(JavaThread* thread);\n+  static void resolve_invoke(JavaThread* current, Bytecodes::Code bytecode);\n+  static void resolve_invokehandle (JavaThread* current);\n+  static void resolve_invokedynamic(JavaThread* current);\n@@ -119,1 +119,1 @@\n-  static void    monitorenter(JavaThread* thread, BasicObjectLock* elem);\n+  static void    monitorenter(JavaThread* current, BasicObjectLock* elem);\n@@ -122,2 +122,2 @@\n-  static void    throw_illegal_monitor_state_exception(JavaThread* thread);\n-  static void    new_illegal_monitor_state_exception(JavaThread* thread);\n+  static void    throw_illegal_monitor_state_exception(JavaThread* current);\n+  static void    new_illegal_monitor_state_exception(JavaThread* current);\n@@ -126,3 +126,3 @@\n-  static void _breakpoint(JavaThread* thread, Method* method, address bcp);\n-  static Bytecodes::Code get_original_bytecode_at(JavaThread* thread, Method* method, address bcp);\n-  static void            set_original_bytecode_at(JavaThread* thread, Method* method, address bcp, Bytecodes::Code new_code);\n+  static void _breakpoint(JavaThread* current, Method* method, address bcp);\n+  static Bytecodes::Code get_original_bytecode_at(JavaThread* current, Method* method, address bcp);\n+  static void            set_original_bytecode_at(JavaThread* current, Method* method, address bcp, Bytecodes::Code new_code);\n@@ -131,2 +131,2 @@\n-  static void    at_safepoint(JavaThread* thread);\n-  static void    at_unwind(JavaThread* thread);\n+  static void    at_safepoint(JavaThread* current);\n+  static void    at_unwind(JavaThread* current);\n@@ -135,1 +135,1 @@\n-  static void post_field_access(JavaThread *thread, oopDesc* obj,\n+  static void post_field_access(JavaThread* current, oopDesc* obj,\n@@ -137,1 +137,1 @@\n-  static void post_field_modification(JavaThread *thread, oopDesc* obj,\n+  static void post_field_modification(JavaThread* current, oopDesc* obj,\n@@ -139,2 +139,2 @@\n-  static void post_method_entry(JavaThread *thread);\n-  static void post_method_exit (JavaThread *thread);\n+  static void post_method_entry(JavaThread* current);\n+  static void post_method_exit (JavaThread* current);\n@@ -144,2 +144,2 @@\n-  static void prepare_native_call(JavaThread* thread, Method* method);\n-  static address slow_signature_handler(JavaThread* thread,\n+  static void prepare_native_call(JavaThread* current, Method* method);\n+  static address slow_signature_handler(JavaThread* current,\n@@ -151,1 +151,1 @@\n-  static void popframe_move_outgoing_args(JavaThread* thread, void* src_address, void* dest_address);\n+  static void popframe_move_outgoing_args(JavaThread* current, void* src_address, void* dest_address);\n@@ -155,1 +155,1 @@\n-  static intptr_t trace_bytecode(JavaThread* thread, intptr_t preserve_this_value, intptr_t tos, intptr_t tos2) PRODUCT_RETURN0;\n+  static intptr_t trace_bytecode(JavaThread* current, intptr_t preserve_this_value, intptr_t tos, intptr_t tos2) PRODUCT_RETURN0;\n@@ -164,1 +164,1 @@\n-  static nmethod* frequency_counter_overflow(JavaThread* thread, address branch_bcp);\n+  static nmethod* frequency_counter_overflow(JavaThread* current, address branch_bcp);\n@@ -168,1 +168,1 @@\n-  static void    update_mdp_for_ret(JavaThread* thread, int bci);\n+  static void    update_mdp_for_ret(JavaThread* current, int bci);\n@@ -172,1 +172,1 @@\n-  static MethodCounters* build_method_counters(JavaThread* thread, Method* m);\n+  static MethodCounters* build_method_counters(JavaThread* current, Method* m);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":64,"deletions":64,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-#include \"prims\/nativeLookup.hpp\"\n@@ -153,2 +152,1 @@\n-    index = LinkResolver::vtable_index_of_interface_method(resolved_klass,\n-                           _resolved_method);\n+    index = LinkResolver::vtable_index_of_interface_method(resolved_klass, _resolved_method);\n@@ -386,1 +384,1 @@\n-                                                        Klass::PrivateLookupMode private_mode, TRAPS) {\n+                                                        Klass::PrivateLookupMode private_mode) {\n@@ -409,6 +407,1 @@\n-int LinkResolver::vtable_index_of_interface_method(Klass* klass,\n-                                                   const methodHandle& resolved_method) {\n-\n-  int vtable_index = Method::invalid_vtable_index;\n-  Symbol* name = resolved_method->name();\n-  Symbol* signature = resolved_method->signature();\n+int LinkResolver::vtable_index_of_interface_method(Klass* klass, const methodHandle& resolved_method) {\n@@ -416,18 +409,1 @@\n-\n-  \/\/ First check in default method array\n-  if (!resolved_method->is_abstract() && ik->default_methods() != NULL) {\n-    int index = InstanceKlass::find_method_index(ik->default_methods(),\n-                                                 name, signature,\n-                                                 Klass::OverpassLookupMode::find,\n-                                                 Klass::StaticLookupMode::find,\n-                                                 Klass::PrivateLookupMode::find);\n-    if (index >= 0 ) {\n-      vtable_index = ik->default_vtable_indices()->at(index);\n-    }\n-  }\n-  if (vtable_index == Method::invalid_vtable_index) {\n-    \/\/ get vtable_index for miranda methods\n-    klassVtable vt = ik->vtable();\n-    vtable_index = vt.index_of_miranda(name, signature);\n-  }\n-  return vtable_index;\n+  return ik->vtable_index_of_interface_method(resolved_method());\n@@ -466,1 +442,1 @@\n-        MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK_NULL);\n+        MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg);\n@@ -523,1 +499,1 @@\n-          MethodHandles::lookup_basic_type_signature(full_signature, CHECK_NULL);\n+          MethodHandles::lookup_basic_type_signature(full_signature);\n@@ -547,1 +523,1 @@\n-static void print_nest_host_error_on(stringStream* ss, Klass* ref_klass, Klass* sel_klass, TRAPS) {\n+static void print_nest_host_error_on(stringStream* ss, Klass* ref_klass, Klass* sel_klass) {\n@@ -552,2 +528,2 @@\n-  const char* nest_host_error_1 = ref_ik->nest_host_error(THREAD);\n-  const char* nest_host_error_2 = sel_ik->nest_host_error(THREAD);\n+  const char* nest_host_error_1 = ref_ik->nest_host_error();\n+  const char* nest_host_error_2 = sel_ik->nest_host_error();\n@@ -614,1 +590,1 @@\n-      print_nest_host_error_on(&ss, ref_klass, sel_klass, THREAD);\n+      print_nest_host_error_on(&ss, ref_klass, sel_klass);\n@@ -679,1 +655,1 @@\n-                                              resolved_loader, true, CHECK);\n+                                              resolved_loader, true);\n@@ -716,2 +692,1 @@\n-                                              false,\n-                                              CHECK);\n+                                              false);\n@@ -959,1 +934,1 @@\n-      print_nest_host_error_on(&ss, ref_klass, sel_klass, THREAD);\n+      print_nest_host_error_on(&ss, ref_klass, sel_klass);\n@@ -1166,1 +1141,1 @@\n-  Method* resolved_method;\n+  Method* resolved_method = NULL;\n@@ -1266,1 +1241,1 @@\n-                                                     Klass::PrivateLookupMode::find, CHECK);\n+                                                     Klass::PrivateLookupMode::find);\n@@ -1508,1 +1483,1 @@\n-                                                       Klass::PrivateLookupMode::skip, CHECK);\n+                                                       Klass::PrivateLookupMode::skip);\n@@ -1789,1 +1764,1 @@\n-  ArchiveUtils::log_to_classlist(&bootstrap_specifier, THREAD);\n+  ArchiveUtils::log_to_classlist(&bootstrap_specifier, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":17,"deletions":42,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,1 +214,1 @@\n-                                                    Klass::PrivateLookupMode private_mode, TRAPS);\n+                                                    Klass::PrivateLookupMode private_mode);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -246,0 +246,2 @@\n+  void pass_byte()                               { \/* ignore *\/ }\n+  void pass_short()                              { \/* ignore *\/ }\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -60,0 +61,1 @@\n+#include \"runtime\/stackFrameStream.inline.hpp\"\n@@ -129,4 +131,5 @@\n-#define JVMCI_VM_ENTRY_MARK                   \\\n-  ThreadInVMfromNative __tiv(thread);         \\\n-  HandleMarkCleaner __hm(thread);             \\\n-  Thread* THREAD = thread;                    \\\n+#define JVMCI_VM_ENTRY_MARK                                       \\\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));       \\\n+  ThreadInVMfromNative __tiv(thread);                             \\\n+  HandleMarkCleaner __hm(thread);                                 \\\n+  Thread* THREAD = thread;                                        \\\n@@ -373,1 +376,1 @@\n-  Method* method;\n+  Method* method = NULL;\n@@ -460,1 +463,1 @@\n-  Klass* holder = JVMCIENV->asKlass(jvmci_type);\n+  InstanceKlass* holder = InstanceKlass::cast(JVMCIENV->asKlass(jvmci_type));\n@@ -468,0 +471,4 @@\n+  if (method->is_abstract()) {\n+    return NULL;\n+  }\n+\n@@ -731,0 +738,1 @@\n+  InstanceKlass* holder = method->method_holder();\n@@ -734,1 +742,1 @@\n-  if (!method->method_holder()->is_interface()) {\n+  if (!holder->is_interface()) {\n@@ -743,0 +751,3 @@\n+  if (!klass->is_subtype_of(holder)) {\n+    JVMCI_THROW_MSG_0(InternalError, err_msg(\"Class %s does not implement interface %s\", klass->external_name(), holder->external_name()));\n+  }\n@@ -1048,1 +1059,1 @@\n-    return JNIHandles::make_local(THREAD, (oop) result.get_jobject());\n+    return JNIHandles::make_local(THREAD, result.get_oop());\n@@ -1332,2 +1343,2 @@\n-        if (result.get_jobject() != NULL) {\n-          return JNIHandles::make_local(thread, (oop) result.get_jobject());\n+        if (result.get_oop() != NULL) {\n+          return JNIHandles::make_local(thread, result.get_oop());\n@@ -1835,1 +1846,1 @@\n-  oop hotspot_box = (oop) box_result.get_jobject();\n+  oop hotspot_box = box_result.get_oop();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/klassVtable.hpp\"\n@@ -185,0 +186,3 @@\n+  nonstatic_field(JavaThread,                  _jvmci_reserved0,                              intptr_t*)                             \\\n+  nonstatic_field(JavaThread,                  _jvmci_reserved1,                              intptr_t*)                             \\\n+  nonstatic_field(JavaThread,                  _jvmci_reserved_oop0,                          oop)                                   \\\n@@ -261,1 +265,1 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _succ,                                         Thread*)                               \\\n+  volatile_nonstatic_field(ObjectMonitor,      _succ,                                         JavaThread*)                           \\\n@@ -689,0 +693,2 @@\n+  declare_function(JVMCIRuntime::invoke_static_method_one_arg) \\\n+  \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -168,0 +168,1 @@\n+  LOG_TAG(startup) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -349,0 +349,3 @@\n+  void* operator new(size_t size, ClassLoaderData* loader_data,\n+                     size_t word_size,\n+                     Type type) throw();\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n@@ -330,1 +332,1 @@\n-  total += _total_dump_regions * reserve_alignment();\n+  total += _total_dump_regions * MetaspaceShared::core_region_alignment();\n@@ -337,1 +339,1 @@\n-  return align_up(total, reserve_alignment());\n+  return align_up(total, MetaspaceShared::core_region_alignment());\n@@ -342,1 +344,1 @@\n-  ReservedSpace rs(buffer_size);\n+  ReservedSpace rs(buffer_size, MetaspaceShared::core_region_alignment(), false);\n@@ -380,1 +382,1 @@\n-    my_archive_requested_bottom = align_up(_requested_static_archive_top, MetaspaceShared::reserved_space_alignment());\n+    my_archive_requested_bottom = align_up(_requested_static_archive_top, MetaspaceShared::core_region_alignment());\n@@ -826,2 +828,2 @@\n-    log_debug(cds)(\"Relocating archive from [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \" ] to \"\n-                   \"[\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \" ]\",\n+    log_debug(cds)(\"Relocating archive from [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] to \"\n+                   \"[\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"]\",\n@@ -1103,0 +1105,4 @@\n+  if (mapinfo->header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+    mapinfo->set_header_base_archive_name_size(strlen(Arguments::GetSharedArchivePath()) + 1);\n+    mapinfo->set_header_base_archive_is_default(FLAG_IS_DEFAULT(SharedArchiveFile));\n+  }\n@@ -1104,0 +1110,2 @@\n+  \/\/ After this point, we should not write any data into mapinfo->header() since this\n+  \/\/ would corrupt its checksum we have calculated before.\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -231,3 +231,2 @@\n-  \/\/ Use this when you allocate space with MetaspaceShare::read_only_space_alloc()\n-  \/\/ outside of ArchiveBuilder::dump_{rw,ro}_region. These are usually for misc tables\n-  \/\/ that are allocated in the RO space.\n+  \/\/ Use this when you allocate space outside of ArchiveBuilder::dump_{rw,ro}_region.\n+  \/\/ These are usually for misc tables that are allocated in the RO space.\n@@ -273,4 +272,0 @@\n-  static size_t reserve_alignment() {\n-    return os::vm_allocation_granularity();\n-  }\n-\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -96,0 +97,1 @@\n+  {\"java\/lang\/ModuleLayer\",                       \"EMPTY_LAYER\"},\n@@ -171,1 +173,1 @@\n-  reset_states(SystemDictionary::java_system_loader(), THREAD);\n+  reset_states(SystemDictionary::java_system_loader(), CHECK);\n@@ -266,1 +268,1 @@\n-  oop archived_oop = (oop)G1CollectedHeap::heap()->archive_mem_allocate(len);\n+  oop archived_oop = cast_to_oop(G1CollectedHeap::heap()->archive_mem_allocate(len));\n@@ -347,0 +349,2 @@\n+    log_info(cds)(\"Heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n+                  p2i(CompressedOops::begin()), p2i(CompressedOops::end()));\n@@ -363,1 +367,0 @@\n-  Thread* THREAD = Thread::current();\n@@ -428,1 +431,1 @@\n-  _roots = OopHandle(Universe::vm_global(), (oop)mem);\n+  _roots = OopHandle(Universe::vm_global(), cast_to_oop(mem));\n@@ -704,1 +707,2 @@\n- const ArchivedKlassSubGraphInfoRecord* record =\n+  ExceptionMark em(THREAD);\n+  const ArchivedKlassSubGraphInfoRecord* record =\n@@ -706,1 +710,1 @@\n- if (HAS_PENDING_EXCEPTION) {\n+  if (HAS_PENDING_EXCEPTION) {\n@@ -708,2 +712,2 @@\n- }\n- if (record == NULL) {\n+  }\n+  if (record == NULL) {\n@@ -711,1 +715,1 @@\n- }\n+  }\n@@ -719,0 +723,1 @@\n+  ExceptionMark em(THREAD);\n@@ -750,1 +755,1 @@\n-        ResourceMark rm;\n+        ResourceMark rm(THREAD);\n@@ -759,1 +764,1 @@\n-        ResourceMark rm;\n+        ResourceMark rm(THREAD);\n@@ -1247,1 +1252,1 @@\n-                                            int num, Thread* THREAD) {\n+                                            int num, TRAPS) {\n@@ -1253,8 +1258,1 @@\n-    Klass* k = SystemDictionary::resolve_or_null(klass_name, THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      ResourceMark rm(THREAD);\n-      ArchiveUtils::check_for_oom(PENDING_EXCEPTION); \/\/ exit on OOM\n-      log_info(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),\n-                    java_lang_String::as_utf8_string(java_lang_Throwable::message(PENDING_EXCEPTION)));\n-      vm_direct_exit(-1, \"VM exits due to exception, use -Xlog:cds,exceptions=trace for detail\");\n-    }\n+    Klass* k = SystemDictionary::resolve_or_fail(klass_name, true, CHECK);\n@@ -1264,2 +1262,1 @@\n-    ik->initialize(THREAD);\n-    guarantee(!HAS_PENDING_EXCEPTION, \"exception in initialize\");\n+    ik->initialize(CHECK);\n@@ -1276,1 +1273,1 @@\n-void HeapShared::init_subgraph_entry_fields(Thread* THREAD) {\n+void HeapShared::init_subgraph_entry_fields(TRAPS) {\n@@ -1281,1 +1278,1 @@\n-                             THREAD);\n+                             CHECK);\n@@ -1284,1 +1281,1 @@\n-                             THREAD);\n+                             CHECK);\n@@ -1288,1 +1285,1 @@\n-                               THREAD);\n+                               CHECK);\n@@ -1292,1 +1289,1 @@\n-void HeapShared::init_for_dumping(Thread* THREAD) {\n+void HeapShared::init_for_dumping(TRAPS) {\n@@ -1295,1 +1292,1 @@\n-    init_subgraph_entry_fields(THREAD);\n+    init_subgraph_entry_fields(CHECK);\n@@ -1405,1 +1402,1 @@\n-    oop o = (oop)p;\n+    oop o = cast_to_oop(p);\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":26,"deletions":29,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -66,0 +67,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -70,1 +72,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -125,1 +126,15 @@\n-size_t MetaspaceShared::reserved_space_alignment() { return os::vm_allocation_granularity(); }\n+\/\/ os::vm_allocation_granularity() is usually 4K for most OSes. However, on Linux\/aarch64,\n+\/\/ it can be either 4K or 64K and on Macosx-arm it is 16K. To generate archives that are\n+\/\/ compatible for both settings, an alternative cds core region alignment can be enabled\n+\/\/ at building time:\n+\/\/   --enable-compactible-cds-alignment\n+\/\/ Upon successful configuration, the compactible alignment then can be defined as in:\n+\/\/   os_linux_aarch64.hpp\n+\/\/ which is the highest page size configured on the platform.\n+size_t MetaspaceShared::core_region_alignment() {\n+#if defined(CDS_CORE_REGION_ALIGNMENT)\n+  return CDS_CORE_REGION_ALIGNMENT;\n+#else\n+  return (size_t)os::vm_allocation_granularity();\n+#endif \/\/ CDS_CORE_REGION_ALIGNMENT\n+}\n@@ -135,0 +150,27 @@\n+class DumpClassListCLDClosure : public CLDClosure {\n+  fileStream *_stream;\n+public:\n+  DumpClassListCLDClosure(fileStream* f) : CLDClosure() { _stream = f; }\n+  void do_cld(ClassLoaderData* cld) {\n+    for (Klass* klass = cld->klasses(); klass != NULL; klass = klass->next_link()) {\n+      if (klass->is_instance_klass()) {\n+        InstanceKlass* ik = InstanceKlass::cast(klass);\n+        if (ik->is_shareable()) {\n+          _stream->print_cr(\"%s\", ik->name()->as_C_string());\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+void MetaspaceShared::dump_loaded_classes(const char* file_name, TRAPS) {\n+  fileStream stream(file_name, \"w\");\n+  if (stream.is_open()) {\n+    MutexLocker lock(ClassLoaderDataGraph_lock);\n+    DumpClassListCLDClosure collect_classes(&stream);\n+    ClassLoaderDataGraph::loaded_cld_do(&collect_classes);\n+  } else {\n+    THROW_MSG(vmSymbols::java_io_IOException(), \"Failed to open file\");\n+  }\n+}\n+\n@@ -138,1 +180,1 @@\n-    \/\/ align_up(SharedBaseAddress, MetaspaceShared::reserved_space_alignment()) has wrapped around.\n+    \/\/ align_up(SharedBaseAddress, MetaspaceShared::core_region_alignment()) has wrapped around.\n@@ -151,1 +193,1 @@\n-  char* aligned_base = align_up(specified_base, MetaspaceShared::reserved_space_alignment());\n+  char* aligned_base = align_up(specified_base, MetaspaceShared::core_region_alignment());\n@@ -167,1 +209,1 @@\n-  aligned_base = align_up(specified_base, MetaspaceShared::reserved_space_alignment());\n+  aligned_base = align_up(specified_base, MetaspaceShared::core_region_alignment());\n@@ -177,1 +219,1 @@\n-\n+  log_info(cds)(\"Core region alignment: \" SIZE_FORMAT, core_region_alignment());\n@@ -181,1 +223,1 @@\n-  const size_t reserve_alignment = MetaspaceShared::reserved_space_alignment();\n+  const size_t reserve_alignment = core_region_alignment();\n@@ -209,1 +251,1 @@\n-      SystemDictionaryShared::allocate_shared_data_arrays(size, THREAD);\n+      SystemDictionaryShared::allocate_shared_data_arrays(size, CHECK);\n@@ -227,1 +269,1 @@\n-void MetaspaceShared::read_extra_data(const char* filename, TRAPS) {\n+void MetaspaceShared::read_extra_data(Thread* current, const char* filename) {\n@@ -237,1 +279,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -251,0 +293,2 @@\n+      ExceptionMark em(current);\n+      Thread* THREAD = current; \/\/ For exception macros.\n@@ -377,3 +421,6 @@\n-  VM_PopulateDumpSharedSpace() : VM_GC_Operation(0, \/* total collections, ignored *\/\n-                                                 GCCause::_archive_time_gc)\n-  { }\n+  VM_PopulateDumpSharedSpace() :\n+    VM_GC_Operation(0 \/* total collections, ignored *\/, GCCause::_archive_time_gc),\n+    _closed_archive_heap_regions(NULL),\n+    _open_archive_heap_regions(NULL),\n+    _closed_archive_heap_oopmaps(NULL),\n+    _open_archive_heap_oopmaps(NULL) {}\n@@ -423,2 +470,0 @@\n-  _closed_archive_heap_oopmaps = NULL;\n-  _open_archive_heap_oopmaps = NULL;\n@@ -442,2 +487,0 @@\n-  Thread* THREAD = VMThread::vm_thread();\n-\n@@ -470,2 +513,0 @@\n-  _closed_archive_heap_regions = NULL;\n-  _open_archive_heap_regions = NULL;\n@@ -496,1 +537,1 @@\n-  mapinfo->populate_header(os::vm_allocation_granularity());\n+  mapinfo->populate_header(MetaspaceShared::core_region_alignment());\n@@ -521,5 +562,7 @@\n-static GrowableArray<ClassLoaderData*>* _loaded_cld = NULL;\n-\n-  void do_cld(ClassLoaderData* cld) {\n-    if (_loaded_cld == NULL) {\n-      _loaded_cld = new (ResourceObj::C_HEAP, mtClassShared)GrowableArray<ClassLoaderData*>(10, mtClassShared);\n+  GrowableArray<ClassLoaderData*> _loaded_cld;\n+public:\n+  CollectCLDClosure() {}\n+  ~CollectCLDClosure() {\n+    for (int i = 0; i < _loaded_cld.length(); i++) {\n+      ClassLoaderData* cld = _loaded_cld.at(i);\n+      cld->dec_keep_alive();\n@@ -528,0 +571,2 @@\n+  }\n+  void do_cld(ClassLoaderData* cld) {\n@@ -530,1 +575,1 @@\n-      _loaded_cld->append(cld);\n+      _loaded_cld.append(cld);\n@@ -533,0 +578,3 @@\n+\n+  int nof_cld() const                { return _loaded_cld.length(); }\n+  ClassLoaderData* cld_at(int index) { return _loaded_cld.at(index); }\n@@ -544,2 +592,1 @@\n-  bool res = MetaspaceShared::try_link_class(ik, THREAD);\n-  guarantee(!HAS_PENDING_EXCEPTION, \"exception in link_class\");\n+  bool res = MetaspaceShared::try_link_class(THREAD, ik);\n@@ -551,1 +598,1 @@\n-    ik->constants()->resolve_class_constants(THREAD);\n+    ik->constants()->resolve_class_constants(CHECK_(false)); \/\/ may throw OOM when interning strings.\n@@ -558,0 +605,1 @@\n+  ResourceMark rm;\n@@ -560,0 +608,4 @@\n+    \/\/ ClassLoaderDataGraph::loaded_cld_do requires ClassLoaderDataGraph_lock.\n+    \/\/ We cannot link the classes while holding this lock (or else we may run into deadlock).\n+    \/\/ Therefore, we need to first collect all the CLDs, and then link their classes after\n+    \/\/ releasing the lock.\n@@ -566,2 +618,2 @@\n-    for (int i = 0; i < _loaded_cld->length(); i++) {\n-      ClassLoaderData* cld = _loaded_cld->at(i);\n+    for (int i = 0; i < collect_cld.nof_cld(); i++) {\n+      ClassLoaderData* cld = collect_cld.cld_at(i);\n@@ -572,1 +624,1 @@\n-            has_linked |= link_class_for_cds(ik, THREAD);\n+            has_linked |= link_class_for_cds(ik, CHECK);\n@@ -584,5 +636,0 @@\n-\n-  for (int i = 0; i < _loaded_cld->length(); i++) {\n-    ClassLoaderData* cld = _loaded_cld->at(i);\n-    cld->dec_keep_alive();\n-  }\n@@ -595,0 +642,6 @@\n+  ClassLoader::initialize_shared_path(Thread::current());\n+}\n+\n+\/\/ Preload classes from a list, populate the shared spaces and dump to a\n+\/\/ file.\n+void MetaspaceShared::preload_and_dump() {\n@@ -596,1 +649,2 @@\n-  ClassLoader::initialize_shared_path(THREAD);\n+  ResourceMark rm(THREAD);\n+  preload_and_dump_impl(THREAD);\n@@ -598,2 +652,12 @@\n-    java_lang_Throwable::print(PENDING_EXCEPTION, tty);\n-    vm_exit_during_initialization(\"ClassLoader::initialize_shared_path() failed unexpectedly\");\n+    if (PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())) {\n+      vm_direct_exit(-1,  err_msg(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n+                                  SIZE_FORMAT \"M\", MaxHeapSize\/M));\n+    } else {\n+      log_error(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),\n+                     java_lang_String::as_utf8_string(java_lang_Throwable::message(PENDING_EXCEPTION)));\n+      vm_direct_exit(-1, \"VM exits due to exception, use -Xlog:cds,exceptions=trace for detail\");\n+    }\n+  } else {\n+    \/\/ On success, the VM_PopulateDumpSharedSpace op should have\n+    \/\/ exited the VM.\n+    ShouldNotReachHere();\n@@ -603,26 +667,21 @@\n-\/\/ Preload classes from a list, populate the shared spaces and dump to a\n-\/\/ file.\n-void MetaspaceShared::preload_and_dump(TRAPS) {\n-  { TraceTime timer(\"Dump Shared Spaces\", TRACETIME_LOG(Info, startuptime));\n-    ResourceMark rm(THREAD);\n-    char class_list_path_str[JVM_MAXPATHLEN];\n-    \/\/ Preload classes to be shared.\n-    const char* class_list_path;\n-    if (SharedClassListFile == NULL) {\n-      \/\/ Construct the path to the class list (in jre\/lib)\n-      \/\/ Walk up two directories from the location of the VM and\n-      \/\/ optionally tack on \"lib\" (depending on platform)\n-      os::jvm_path(class_list_path_str, sizeof(class_list_path_str));\n-      for (int i = 0; i < 3; i++) {\n-        char *end = strrchr(class_list_path_str, *os::file_separator());\n-        if (end != NULL) *end = '\\0';\n-      }\n-      int class_list_path_len = (int)strlen(class_list_path_str);\n-      if (class_list_path_len >= 3) {\n-        if (strcmp(class_list_path_str + class_list_path_len - 3, \"lib\") != 0) {\n-          if (class_list_path_len < JVM_MAXPATHLEN - 4) {\n-            jio_snprintf(class_list_path_str + class_list_path_len,\n-                         sizeof(class_list_path_str) - class_list_path_len,\n-                         \"%slib\", os::file_separator());\n-            class_list_path_len += 4;\n-          }\n+void MetaspaceShared::preload_classes(TRAPS) {\n+  char default_classlist[JVM_MAXPATHLEN];\n+  const char* classlist_path;\n+\n+  if (SharedClassListFile == NULL) {\n+    \/\/ Construct the path to the class list (in jre\/lib)\n+    \/\/ Walk up two directories from the location of the VM and\n+    \/\/ optionally tack on \"lib\" (depending on platform)\n+    os::jvm_path(default_classlist, sizeof(default_classlist));\n+    for (int i = 0; i < 3; i++) {\n+      char *end = strrchr(default_classlist, *os::file_separator());\n+      if (end != NULL) *end = '\\0';\n+    }\n+    int classlist_path_len = (int)strlen(default_classlist);\n+    if (classlist_path_len >= 3) {\n+      if (strcmp(default_classlist + classlist_path_len - 3, \"lib\") != 0) {\n+        if (classlist_path_len < JVM_MAXPATHLEN - 4) {\n+          jio_snprintf(default_classlist + classlist_path_len,\n+                       sizeof(default_classlist) - classlist_path_len,\n+                       \"%slib\", os::file_separator());\n+          classlist_path_len += 4;\n@@ -631,14 +690,4 @@\n-      if (class_list_path_len < JVM_MAXPATHLEN - 10) {\n-        jio_snprintf(class_list_path_str + class_list_path_len,\n-                     sizeof(class_list_path_str) - class_list_path_len,\n-                     \"%sclasslist\", os::file_separator());\n-      }\n-      class_list_path = class_list_path_str;\n-    } else {\n-      class_list_path = SharedClassListFile;\n-\n-    log_info(cds)(\"Loading classes to share ...\");\n-    _has_error_classes = false;\n-    int class_count = preload_classes(class_list_path, THREAD);\n-    if (ExtraSharedClassListFile) {\n-      class_count += preload_classes(ExtraSharedClassListFile, THREAD);\n+    if (classlist_path_len < JVM_MAXPATHLEN - 10) {\n+      jio_snprintf(default_classlist + classlist_path_len,\n+                   sizeof(default_classlist) - classlist_path_len,\n+                   \"%sclasslist\", os::file_separator());\n@@ -647,1 +696,4 @@\n-    log_info(cds)(\"Loading classes to share: done.\");\n+    classlist_path = default_classlist;\n+  } else {\n+    classlist_path = SharedClassListFile;\n+  }\n@@ -649,1 +701,6 @@\n-    log_info(cds)(\"Shared spaces: preloaded %d classes\", class_count);\n+  log_info(cds)(\"Loading classes to share ...\");\n+  _has_error_classes = false;\n+  int class_count = parse_classlist(classlist_path, CHECK);\n+  if (ExtraSharedClassListFile) {\n+    class_count += parse_classlist(ExtraSharedClassListFile, CHECK);\n+  }\n@@ -651,5 +708,4 @@\n-    if (SharedArchiveConfigFile) {\n-      log_info(cds)(\"Reading extra data from %s ...\", SharedArchiveConfigFile);\n-      read_extra_data(SharedArchiveConfigFile, THREAD);\n-      log_info(cds)(\"Reading extra data: done.\");\n-    }\n+  \/\/ Exercise the manifest processing code to ensure classes used by CDS at runtime\n+  \/\/ are always archived\n+  const char* dummy = \"Manifest-Version: 1.0\\n\";\n+  SystemDictionaryShared::create_jar_manifest(dummy, strlen(dummy), CHECK);\n@@ -657,5 +713,18 @@\n-    if (LambdaFormInvokers::lambdaform_lines() != NULL) {\n-      log_info(cds)(\"Regenerate MethodHandle Holder classes...\");\n-      LambdaFormInvokers::regenerate_holder_classes(THREAD);\n-      log_info(cds)(\"Regenerate MethodHandle Holder classes done.\");\n-    }\n+  log_info(cds)(\"Loading classes to share: done.\");\n+  log_info(cds)(\"Shared spaces: preloaded %d classes\", class_count);\n+}\n+\n+void MetaspaceShared::preload_and_dump_impl(TRAPS) {\n+  preload_classes(CHECK);\n+\n+  if (SharedArchiveConfigFile) {\n+    log_info(cds)(\"Reading extra data from %s ...\", SharedArchiveConfigFile);\n+    read_extra_data(THREAD, SharedArchiveConfigFile);\n+    log_info(cds)(\"Reading extra data: done.\");\n+  }\n+\n+  if (LambdaFormInvokers::lambdaform_lines() != NULL) {\n+    log_info(cds)(\"Regenerate MethodHandle Holder classes...\");\n+    LambdaFormInvokers::regenerate_holder_classes(CHECK);\n+    log_info(cds)(\"Regenerate MethodHandle Holder classes done.\");\n+  }\n@@ -663,1 +732,1 @@\n-    HeapShared::init_for_dumping(THREAD);\n+  HeapShared::init_for_dumping(CHECK);\n@@ -665,4 +734,2 @@\n-    \/\/ exercise the manifest processing code to ensure classes used by CDS are always archived\n-    SystemDictionaryShared::create_jar_manifest(\"Manifest-Version: 1.0\\n\", strlen(\"Manifest-Version: 1.0\\n\"), THREAD);\n-    \/\/ Rewrite and link classes\n-    log_info(cds)(\"Rewriting and linking classes ...\");\n+  \/\/ Rewrite and link classes\n+  log_info(cds)(\"Rewriting and linking classes ...\");\n@@ -670,6 +737,6 @@\n-    \/\/ Link any classes which got missed. This would happen if we have loaded classes that\n-    \/\/ were not explicitly specified in the classlist. E.g., if an interface implemented by class K\n-    \/\/ fails verification, all other interfaces that were not specified in the classlist but\n-    \/\/ are implemented by K are not verified.\n-    link_and_cleanup_shared_classes(CATCH);\n-    log_info(cds)(\"Rewriting and linking classes: done\");\n+  \/\/ Link any classes which got missed. This would happen if we have loaded classes that\n+  \/\/ were not explicitly specified in the classlist. E.g., if an interface implemented by class K\n+  \/\/ fails verification, all other interfaces that were not specified in the classlist but\n+  \/\/ are implemented by K are not verified.\n+  link_and_cleanup_shared_classes(CATCH);\n+  log_info(cds)(\"Rewriting and linking classes: done\");\n@@ -679,1 +746,1 @@\n-      HeapShared::reset_archived_object_states(THREAD);\n+      HeapShared::reset_archived_object_states(CHECK);\n@@ -683,3 +750,2 @@\n-    VM_PopulateDumpSharedSpace op;\n-    VMThread::execute(&op);\n-  }\n+  VM_PopulateDumpSharedSpace op;\n+  VMThread::execute(&op);\n@@ -689,39 +755,3 @@\n-int MetaspaceShared::preload_classes(const char* class_list_path, TRAPS) {\n-  ClassListParser parser(class_list_path);\n-  int class_count = 0;\n-\n-  while (parser.parse_one_line()) {\n-    if (parser.lambda_form_line()) {\n-      continue;\n-    }\n-    Klass* klass = parser.load_current_class(THREAD);\n-    if (HAS_PENDING_EXCEPTION) {\n-      if (klass == NULL &&\n-          (PENDING_EXCEPTION->klass()->name() == vmSymbols::java_lang_ClassNotFoundException())) {\n-        \/\/ print a warning only when the pending exception is class not found\n-        log_warning(cds)(\"Preload Warning: Cannot find %s\", parser.current_class_name());\n-      }\n-      CLEAR_PENDING_EXCEPTION;\n-    }\n-    if (klass != NULL) {\n-      if (log_is_enabled(Trace, cds)) {\n-        ResourceMark rm(THREAD);\n-        log_trace(cds)(\"Shared spaces preloaded: %s\", klass->external_name());\n-      }\n-\n-      if (klass->is_instance_klass()) {\n-        InstanceKlass* ik = InstanceKlass::cast(klass);\n-\n-        \/\/ Link the class to cause the bytecodes to be rewritten and the\n-        \/\/ cpcache to be created. The linking is done as soon as classes\n-        \/\/ are loaded in order that the related data structures (klass and\n-        \/\/ cpCache) are located together.\n-        try_link_class(ik, THREAD);\n-        guarantee(!HAS_PENDING_EXCEPTION, \"exception in link_class\");\n-      }\n-\n-      class_count++;\n-    }\n-  }\n-\n-  return class_count;\n+int MetaspaceShared::parse_classlist(const char* classlist_path, TRAPS) {\n+  ClassListParser parser(classlist_path);\n+  return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n@@ -730,2 +760,4 @@\n-\/\/ Returns true if the class's status has changed\n-bool MetaspaceShared::try_link_class(InstanceKlass* ik, TRAPS) {\n+\/\/ Returns true if the class's status has changed.\n+bool MetaspaceShared::try_link_class(Thread* current, InstanceKlass* ik) {\n+  ExceptionMark em(current);\n+  Thread* THREAD = current; \/\/ For exception macros.\n@@ -859,0 +891,1 @@\n+    log_info(cds)(\"Core region alignment: \" SIZE_FORMAT, static_mapinfo->core_region_alignment());\n@@ -979,1 +1012,1 @@\n-                        MetaspaceShared::reserved_space_alignment()),\n+                        core_region_alignment()),\n@@ -987,1 +1020,1 @@\n-    log_debug(cds)(\"Reserved archive_space_rs     [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (\" SIZE_FORMAT \") bytes\",\n+    log_info(cds)(\"Reserved archive_space_rs [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (\" SIZE_FORMAT \") bytes\",\n@@ -989,1 +1022,1 @@\n-    log_debug(cds)(\"Reserved class_space_rs [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (\" SIZE_FORMAT \") bytes\",\n+    log_info(cds)(\"Reserved class_space_rs   [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (\" SIZE_FORMAT \") bytes\",\n@@ -1151,1 +1184,1 @@\n-  const size_t archive_space_alignment = MetaspaceShared::reserved_space_alignment();\n+  const size_t archive_space_alignment = core_region_alignment();\n@@ -1209,2 +1242,1 @@\n-      align_up(archive_space_size + gap_size + class_space_size,\n-               os::vm_allocation_granularity());\n+      align_up(archive_space_size + gap_size + class_space_size, core_region_alignment());\n@@ -1253,1 +1285,1 @@\n-                                                 (size_t)os::vm_allocation_granularity());\n+                                                 (size_t)archive_space_alignment);\n@@ -1304,4 +1336,3 @@\n-\n-  if (mapinfo->alignment() != (size_t)os::vm_allocation_granularity()) {\n-    log_info(cds)(\"Unable to map CDS archive -- os::vm_allocation_granularity() expected: \" SIZE_FORMAT\n-                  \" actual: %d\", mapinfo->alignment(), os::vm_allocation_granularity());\n+  if (mapinfo->core_region_alignment() != (size_t)core_region_alignment()) {\n+    log_info(cds)(\"Unable to map CDS archive -- core_region_alignment() expected: \" SIZE_FORMAT\n+                  \" actual: \" SIZE_FORMAT, mapinfo->core_region_alignment(), core_region_alignment());\n@@ -1337,0 +1368,28 @@\n+\/\/ For -XX:PrintSharedArchiveAndExit\n+class CountSharedSymbols : public SymbolClosure {\n+ private:\n+   int _count;\n+ public:\n+   CountSharedSymbols() : _count(0) {}\n+  void do_symbol(Symbol** sym) {\n+    _count++;\n+  }\n+  int total() { return _count; }\n+\n+};\n+\n+\/\/ For -XX:PrintSharedArchiveAndExit\n+class CountSharedStrings : public OopClosure {\n+ private:\n+  int _count;\n+ public:\n+  CountSharedStrings() : _count(0) {}\n+  void do_oop(oop* p) {\n+    _count++;\n+  }\n+  void do_oop(narrowOop* p) {\n+    _count++;\n+  }\n+  int total() { return _count; }\n+};\n+\n@@ -1371,3 +1430,7 @@\n-    if (PrintSharedDictionary) {\n-      tty->print_cr(\"\\nShared classes:\\n\");\n-      SystemDictionaryShared::print_on(tty);\n+    \/\/ Print archive names\n+    if (dynamic_mapinfo != nullptr) {\n+      tty->print_cr(\"\\n\\nBase archive name: %s\", Arguments::GetSharedArchivePath());\n+      tty->print_cr(\"Base archive version %d\", static_mapinfo->version());\n+    } else {\n+      tty->print_cr(\"Static archive name: %s\", static_mapinfo->full_path());\n+      tty->print_cr(\"Static archive version %d\", static_mapinfo->version());\n@@ -1375,0 +1438,16 @@\n+\n+    SystemDictionaryShared::print_shared_archive(tty);\n+    if (dynamic_mapinfo != nullptr) {\n+      tty->print_cr(\"\\n\\nDynamic archive name: %s\", dynamic_mapinfo->full_path());\n+      tty->print_cr(\"Dynamic archive version %d\", dynamic_mapinfo->version());\n+      SystemDictionaryShared::print_shared_archive(tty, false\/*dynamic*\/);\n+    }\n+\n+    \/\/ collect shared symbols and strings\n+    CountSharedSymbols cl;\n+    SymbolTable::shared_symbols_do(&cl);\n+    tty->print_cr(\"Number of shared symbols: %d\", cl.total());\n+    CountSharedStrings cs;\n+    StringTable::shared_oops_do(&cs);\n+    tty->print_cr(\"Number of shared strings: %d\", cs.total());\n+    tty->print_cr(\"VM version: %s\\r\\n\", static_mapinfo->vm_version());\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":241,"deletions":162,"binary":false,"changes":403,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -344,1 +345,1 @@\n-    vmSymbols::initialize(CHECK);\n+    vmSymbols::initialize();\n@@ -515,1 +516,0 @@\n-    EXCEPTION_MARK;\n@@ -554,1 +554,1 @@\n-void Universe::reinitialize_vtable_of(Klass* ko, TRAPS) {\n+static void reinitialize_vtable_of(Klass* ko) {\n@@ -556,1 +556,1 @@\n-  ko->vtable().initialize_vtable(false, CHECK);\n+  ko->vtable().initialize_vtable();\n@@ -561,1 +561,1 @@\n-      reinitialize_vtable_of(sk, CHECK);\n+      reinitialize_vtable_of(sk);\n@@ -566,1 +566,1 @@\n-void Universe::reinitialize_vtables(TRAPS) {\n+static void reinitialize_vtables() {\n@@ -571,1 +571,1 @@\n-  Universe::reinitialize_vtable_of(ok, THREAD);\n+  reinitialize_vtable_of(ok);\n@@ -575,2 +575,2 @@\n-void initialize_itable_for_klass(InstanceKlass* k, TRAPS) {\n-  k->itable().initialize_itable(false, CHECK);\n+static void initialize_itable_for_klass(InstanceKlass* k) {\n+  k->itable().initialize_itable();\n@@ -580,3 +580,3 @@\n-void Universe::reinitialize_itables(TRAPS) {\n-  MutexLocker mcld(THREAD, ClassLoaderDataGraph_lock);\n-  ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass, CHECK);\n+static void reinitialize_itables() {\n+  MutexLocker mcld(ClassLoaderDataGraph_lock);\n+  ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass);\n@@ -757,0 +757,4 @@\n+bool Universe::contains_non_oop_word(void* p) {\n+  return *(void**)p == non_oop_word();\n+}\n+\n@@ -910,2 +914,2 @@\n-  Universe::_vm_global = OopStorageSet::create_strong(\"VM Global\");\n-  Universe::_vm_weak = OopStorageSet::create_weak(\"VM Weak\");\n+  Universe::_vm_global = OopStorageSet::create_strong(\"VM Global\", mtInternal);\n+  Universe::_vm_weak = OopStorageSet::create_weak(\"VM Weak\", mtInternal);\n@@ -995,3 +999,2 @@\n-    ResourceMark rm;\n-    Universe::reinitialize_vtables(CHECK_false);\n-    Universe::reinitialize_itables(CHECK_false);\n+    reinitialize_vtables();\n+    reinitialize_itables();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -180,3 +180,0 @@\n-  static void reinitialize_vtable_of(Klass* k, TRAPS);\n-  static void reinitialize_vtables(TRAPS);\n-  static void reinitialize_itables(TRAPS);\n@@ -390,1 +387,2 @@\n-  static void*   non_oop_word();\n+  static void*         non_oop_word();\n+  static bool contains_non_oop_word(void* p);\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-  k->vtable().initialize_vtable(false, CHECK);\n+  k->vtable().initialize_vtable();\n@@ -186,3 +186,1 @@\n-\/\/ JVM support\n-\n-jint ArrayKlass::compute_modifier_flags(TRAPS) const {\n+jint ArrayKlass::compute_modifier_flags() const {\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-  jint compute_modifier_flags(TRAPS) const;\n+  jint compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-    Handle refs_handle (THREAD, (oop)stom);  \/\/ must handleize.\n+    Handle refs_handle (THREAD, stom);  \/\/ must handleize.\n@@ -388,1 +388,1 @@\n-        Handle refs_handle(THREAD, (oop)stom);  \/\/ must handleize.\n+        Handle refs_handle(THREAD, stom);  \/\/ must handleize.\n@@ -496,1 +496,1 @@\n-                                   bool save_resolution_error, TRAPS) {\n+                                   TRAPS) {\n@@ -507,3 +507,7 @@\n-  Klass* klass = this_cp->resolved_klasses()->at(resolved_klass_index);\n-  if (klass != NULL) {\n-    return klass;\n+  \/\/ The tag must be JVM_CONSTANT_Class in order to read the correct value from\n+  \/\/ the unresolved_klasses() array.\n+  if (this_cp->tag_at(which).is_klass()) {\n+    Klass* klass = this_cp->resolved_klasses()->at(resolved_klass_index);\n+    if (klass != NULL) {\n+      return klass;\n+    }\n@@ -572,14 +576,3 @@\n-    if (save_resolution_error) {\n-      jbyte tag = JVM_CONSTANT_UnresolvedClass;\n-      if (this_cp->tag_at(which).is_Qdescriptor_klass()) {\n-        tag |= JVM_CONSTANT_QDescBit;\n-      }\n-      save_and_throw_exception(this_cp, which, constantTag(tag), CHECK_NULL);\n-      \/\/ If CHECK_NULL above doesn't return the exception, that means that\n-      \/\/ some other thread has beaten us and has resolved the class.\n-      \/\/ To preserve old behavior, we return the resolved class.\n-      klass = this_cp->resolved_klasses()->at(resolved_klass_index);\n-      assert(klass != NULL, \"must be resolved if exception was cleared\");\n-      return klass;\n-    } else {\n-      return NULL;  \/\/ return the pending exception\n+    jbyte tag = JVM_CONSTANT_UnresolvedClass;\n+    if (this_cp->tag_at(which).is_Qdescriptor_klass()) {\n+      tag |= JVM_CONSTANT_QDescBit;\n@@ -587,0 +580,7 @@\n+    save_and_throw_exception(this_cp, which, constantTag(tag), CHECK_NULL);\n+    \/\/ If CHECK_NULL above doesn't return the exception, that means that\n+    \/\/ some other thread has beaten us and has resolved the class.\n+    \/\/ To preserve old behavior, we return the resolved class.\n+    Klass* klass = this_cp->resolved_klasses()->at(resolved_klass_index);\n+    assert(klass != NULL, \"must be resolved if exception was cleared\");\n+    return klass;\n@@ -593,0 +593,1 @@\n+\n@@ -602,1 +603,13 @@\n-  this_cp->release_tag_at_put(which, tag);\n+  \/\/ We also need to CAS to not overwrite an error from a racing thread.\n+\n+  jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp->tag_addr_at(which),\n+                                  (jbyte)JVM_CONSTANT_UnresolvedClass,\n+                                  tag);\n+\n+  \/\/ We need to recheck exceptions from racing thread and return the same.\n+  if (old_tag == JVM_CONSTANT_UnresolvedClassInError) {\n+    \/\/ Remove klass.\n+    this_cp->resolved_klasses()->at_put(resolved_klass_index, NULL);\n+    throw_resolution_error(this_cp, which, CHECK_NULL);\n+  }\n+\n@@ -617,2 +630,3 @@\n-  Klass* k = this_cp->resolved_klasses()->at(resolved_klass_index);\n-  if (k != NULL) {\n+  if (this_cp->tag_at(which).is_klass()) {\n+    Klass* k = this_cp->resolved_klasses()->at(resolved_klass_index);\n+    assert(k != NULL, \"should be resolved\");\n@@ -620,0 +634,2 @@\n+  } else if (this_cp->tag_at(which).is_unresolved_klass_in_error()) {\n+    return NULL;\n@@ -632,1 +648,2 @@\n-      EXCEPTION_MARK;\n+      ExceptionMark em(thread);\n+      Thread* THREAD = thread; \/\/ For exception macros.\n@@ -812,1 +829,1 @@\n-Symbol* ConstantPool::exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception) {\n+static Symbol* exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception) {\n@@ -844,0 +861,19 @@\n+static void add_resolution_error(const constantPoolHandle& this_cp, int which,\n+                                 constantTag tag, oop pending_exception) {\n+\n+  Symbol* error = pending_exception->klass()->name();\n+  oop cause = java_lang_Throwable::cause(pending_exception);\n+\n+  \/\/ Also dig out the exception cause, if present.\n+  Symbol* cause_sym = NULL;\n+  Symbol* cause_msg = NULL;\n+  if (cause != NULL && cause != pending_exception) {\n+    cause_sym = cause->klass()->name();\n+    cause_msg = java_lang_Throwable::detail_message(cause);\n+  }\n+\n+  Symbol* message = exception_message(this_cp, which, tag, pending_exception);\n+  SystemDictionary::add_resolution_error(this_cp, which, error, message, cause_sym, cause_msg);\n+}\n+\n+\n@@ -845,0 +881,1 @@\n+  ResourceMark rm(THREAD);\n@@ -846,1 +883,3 @@\n-  Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &message);\n+  Symbol* cause = NULL;\n+  Symbol* cause_msg = NULL;\n+  Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &message, &cause, &cause_msg);\n@@ -848,0 +887,2 @@\n+  const char* cause_str = cause_msg != NULL ? cause_msg->as_C_string() : NULL;\n+\n@@ -850,2 +891,7 @@\n-    ResourceMark rm;\n-    THROW_MSG(error, message->as_C_string());\n+    char* msg = message->as_C_string();\n+    if (cause != NULL) {\n+      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_str);\n+      THROW_MSG_CAUSE(error, msg, h_cause);\n+    } else {\n+      THROW_MSG(error, msg);\n+    }\n@@ -853,1 +899,6 @@\n-    THROW(error);\n+    if (cause != NULL) {\n+      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_str);\n+      THROW_CAUSE(error, h_cause);\n+    } else {\n+      THROW(error);\n+    }\n@@ -861,1 +912,0 @@\n-  Symbol* error = PENDING_EXCEPTION->klass()->name();\n@@ -872,2 +922,1 @@\n-    Symbol* message = exception_message(this_cp, which, tag, PENDING_EXCEPTION);\n-    SystemDictionary::add_resolution_error(this_cp, which, error, message);\n+    add_resolution_error(this_cp, which, tag, PENDING_EXCEPTION);\n@@ -992,1 +1041,1 @@\n-      Klass* resolved = klass_at_impl(this_cp, index, true, CHECK_NULL);\n+      Klass* resolved = klass_at_impl(this_cp, index, CHECK_NULL);\n@@ -1081,1 +1130,1 @@\n-      Klass* callee = klass_at_impl(this_cp, callee_index, true, CHECK_NULL);\n+      Klass* callee = klass_at_impl(this_cp, callee_index, CHECK_NULL);\n@@ -1264,1 +1313,1 @@\n-       int index2, TRAPS) {\n+       int index2) {\n@@ -1283,2 +1332,2 @@\n-    Klass* k1 = klass_at(index1, CHECK_false);\n-    Klass* k2 = cp2->klass_at(index2, CHECK_false);\n+    Klass* k1 = resolved_klass_at(index1);\n+    Klass* k2 = cp2->resolved_klass_at(index2);\n@@ -1294,2 +1343,1 @@\n-    bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);\n-    if (match) {\n+    if (compare_entry_to(recur1, cp2, recur2)) {\n@@ -1315,1 +1363,1 @@\n-    bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);\n+    bool match = compare_entry_to(recur1, cp2, recur2);\n@@ -1319,2 +1367,1 @@\n-      match = compare_entry_to(recur1, cp2, recur2, CHECK_false);\n-      if (match) {\n+      if (compare_entry_to(recur1, cp2, recur2)) {\n@@ -1357,2 +1404,1 @@\n-    bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);\n-    if (match) {\n+    if (compare_entry_to(recur1, cp2, recur2)) {\n@@ -1361,2 +1407,1 @@\n-      match = compare_entry_to(recur1, cp2, recur2, CHECK_false);\n-      if (match) {\n+      if (compare_entry_to(recur1, cp2, recur2)) {\n@@ -1372,2 +1417,1 @@\n-    bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);\n-    if (match) {\n+    if (compare_entry_to(recur1, cp2, recur2)) {\n@@ -1391,2 +1435,1 @@\n-    bool match = compare_entry_to(k1, cp2, k2, CHECK_false);\n-    if (match) {\n+    if (compare_entry_to(k1, cp2, k2)) {\n@@ -1404,2 +1447,1 @@\n-      bool match = compare_entry_to(i1, cp2, i2, CHECK_false);\n-      if (match) {\n+      if (compare_entry_to(i1, cp2, i2)) {\n@@ -1417,3 +1459,2 @@\n-    \/\/ separate statements and variables because CHECK_false is used\n-    bool match_entry = compare_entry_to(k1, cp2, k2, CHECK_false);\n-    bool match_operand = compare_operand_to(i1, cp2, i2, CHECK_false);\n+    bool match_entry = compare_entry_to(k1, cp2, k2);\n+    bool match_operand = compare_operand_to(i1, cp2, i2);\n@@ -1429,3 +1470,2 @@\n-    \/\/ separate statements and variables because CHECK_false is used\n-    bool match_entry = compare_entry_to(k1, cp2, k2, CHECK_false);\n-    bool match_operand = compare_operand_to(i1, cp2, i2, CHECK_false);\n+    bool match_entry = compare_entry_to(k1, cp2, k2);\n+    bool match_operand = compare_operand_to(i1, cp2, i2);\n@@ -1612,1 +1652,1 @@\n-    copy_entry_to(from_cp, src_i, to_cp, dest_i, CHECK);\n+    copy_entry_to(from_cp, src_i, to_cp, dest_i);\n@@ -1637,2 +1677,1 @@\n-                                        const constantPoolHandle& to_cp, int to_i,\n-                                        TRAPS) {\n+                                        const constantPoolHandle& to_cp, int to_i) {\n@@ -1782,1 +1821,1 @@\n-      const constantPoolHandle& search_cp, TRAPS) {\n+      const constantPoolHandle& search_cp) {\n@@ -1786,1 +1825,1 @@\n-    bool found = compare_entry_to(pattern_i, search_cp, i, CHECK_0);\n+    bool found = compare_entry_to(pattern_i, search_cp, i);\n@@ -1798,1 +1837,1 @@\n-bool ConstantPool::compare_operand_to(int idx1, const constantPoolHandle& cp2, int idx2, TRAPS) {\n+bool ConstantPool::compare_operand_to(int idx1, const constantPoolHandle& cp2, int idx2) {\n@@ -1801,1 +1840,1 @@\n-  bool match = compare_entry_to(k1, cp2, k2, CHECK_false);\n+  bool match = compare_entry_to(k1, cp2, k2);\n@@ -1811,1 +1850,1 @@\n-      match = compare_entry_to(k1, cp2, k2, CHECK_false);\n+      match = compare_entry_to(k1, cp2, k2);\n@@ -1825,1 +1864,1 @@\n-                    const constantPoolHandle& search_cp, int search_len, TRAPS) {\n+                    const constantPoolHandle& search_cp, int search_len) {\n@@ -1827,1 +1866,1 @@\n-    bool found = compare_operand_to(pattern_i, search_cp, i, CHECK_(-1));\n+    bool found = compare_operand_to(pattern_i, search_cp, i);\n@@ -2392,7 +2431,1 @@\n-\n-        Klass* klass = resolved_klasses()->at(resolved_klass_index);\n-        if (klass != NULL) {\n-          klass->print_value_on(st);\n-        } else {\n-          symbol_at(name_index)->print_value_on(st);\n-        }\n+        symbol_at(name_index)->print_value_on(st);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":108,"deletions":75,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -430,7 +430,1 @@\n-    return klass_at_impl(h_this, which, true, THREAD);\n-  }\n-\n-  \/\/ Version of klass_at that doesn't save the resolution error, called during deopt\n-  Klass* klass_at_ignore_error(int which, TRAPS) {\n-    constantPoolHandle h_this(THREAD, this);\n-    return klass_at_impl(h_this, which, false, THREAD);\n+    return klass_at_impl(h_this, which, THREAD);\n@@ -678,1 +672,1 @@\n-                          int bsms_attribute_index2, TRAPS);\n+                          int bsms_attribute_index2);\n@@ -681,1 +675,1 @@\n-                            int operands_cur_len, TRAPS);\n+                            int operands_cur_len);\n@@ -898,2 +892,1 @@\n-  static Klass* klass_at_impl(const constantPoolHandle& this_cp, int which,\n-                              bool save_resolution_error, TRAPS);\n+  static Klass* klass_at_impl(const constantPoolHandle& this_cp, int which, TRAPS);\n@@ -915,1 +908,0 @@\n-  static Symbol* exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception);\n@@ -923,1 +915,1 @@\n-  bool compare_entry_to(int index1, const constantPoolHandle& cp2, int index2, TRAPS);\n+  bool compare_entry_to(int index1, const constantPoolHandle& cp2, int index2);\n@@ -929,1 +921,1 @@\n-  static void copy_entry_to(const constantPoolHandle& from_cp, int from_i, const constantPoolHandle& to_cp, int to_i, TRAPS);\n+  static void copy_entry_to(const constantPoolHandle& from_cp, int from_i, const constantPoolHandle& to_cp, int to_i);\n@@ -931,1 +923,1 @@\n-  int  find_matching_entry(int pattern_i, const constantPoolHandle& search_cp, TRAPS);\n+  int  find_matching_entry(int pattern_i, const constantPoolHandle& search_cp);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -140,2 +140,1 @@\n-                                       bool is_inline_type,\n-                                       Klass* root_klass) {\n+                                       bool is_inline_type) {\n@@ -383,1 +382,2 @@\n-  objArrayHandle resolved_references(Thread::current(), cpool->resolved_references());\n+  JavaThread* current = JavaThread::current();\n+  objArrayHandle resolved_references(current, cpool->resolved_references());\n@@ -389,1 +389,1 @@\n-  ObjectLocker ol(resolved_references, Thread::current());\n+  ObjectLocker ol(resolved_references, current);\n@@ -491,1 +491,2 @@\n-  objArrayHandle resolved_references(Thread::current(), cpool->resolved_references());\n+  JavaThread* current = THREAD->as_Java_thread();\n+  objArrayHandle resolved_references(current, cpool->resolved_references());\n@@ -494,1 +495,1 @@\n-  ObjectLocker ol(resolved_references, THREAD);\n+  ObjectLocker ol(resolved_references, current);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -232,2 +232,1 @@\n-    bool            is_inline_type,              \/\/ the field is an inline type (must never be null)\n-    Klass*          root_klass                   \/\/ needed by the GC to dirty the klass\n+    bool            is_inline_type               \/\/ the field is an inline type (must never be null)\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -451,1 +451,1 @@\n-    oop obj = (oop) ((address)va->value_at_addr(index, layout_helper()) - vk->first_field_offset());\n+    oop obj = cast_to_oop((address)va->value_at_addr(index, layout_helper()) - vk->first_field_offset());\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -910,1 +911,1 @@\n-void GenerateOopMap::do_interpretation()\n+void GenerateOopMap::do_interpretation(Thread* thread)\n@@ -912,2 +913,0 @@\n-  \/\/ \"i\" is just for debugging, so we can detect cases where this loop is\n-  \/\/ iterated more than once.\n@@ -916,0 +915,8 @@\n+    if (i != 0 && thread->is_Java_thread()) {\n+      JavaThread* jt = thread->as_Java_thread();\n+      if (jt->thread_state() == _thread_in_vm) {\n+        \/\/ Since this JavaThread has looped at least once and is _thread_in_vm,\n+        \/\/ we honor any pending blocking request.\n+        ThreadBlockInVM tbivm(jt);\n+      }\n+    }\n@@ -2166,1 +2173,1 @@\n-    do_interpretation();\n+    do_interpretation(THREAD);\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -382,1 +382,1 @@\n-  void  do_interpretation                   ();\n+  void  do_interpretation                   (Thread* thread);\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-    oopDesc::verify(oop((HeapWord*)ptr));\n+    oopDesc::verify(cast_to_oop(ptr));\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/registerMap.hpp\"\n@@ -160,1 +161,0 @@\n-  oop oop_for_data(address data) const;\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,6 +77,0 @@\n-inline oop InlineKlass::oop_for_data(address data) const {\n-  oop o = (oop) (data - first_field_offset());\n-  assert(oopDesc::is_oop(o, false), \"Not an oop\");\n-  return o;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-void InstanceKlass::set_nest_host(InstanceKlass* host, TRAPS) {\n+void InstanceKlass::set_nest_host(InstanceKlass* host) {\n@@ -399,2 +399,2 @@\n-  assert(nest_host_error(THREAD) == NULL, \"unexpected nest host resolution error exists: %s\",\n-         nest_host_error(THREAD));\n+  assert(nest_host_error() == NULL, \"unexpected nest host resolution error exists: %s\",\n+         nest_host_error());\n@@ -407,1 +407,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm;\n@@ -458,1 +458,1 @@\n-const char* InstanceKlass::nest_host_error(TRAPS) {\n+const char* InstanceKlass::nest_host_error() {\n@@ -462,1 +462,1 @@\n-    constantPoolHandle cph(THREAD, constants());\n+    constantPoolHandle cph(Thread::current(), constants());\n@@ -840,1 +840,1 @@\n-  assert((oop)lock != NULL || !is_not_initialized(), \/\/ initialized or in_error state\n+  assert(lock != NULL || !is_not_initialized(), \/\/ initialized or in_error state\n@@ -860,1 +860,1 @@\n-  ObjectLocker ol(h_init_lock, THREAD);\n+  ObjectLocker ol(h_init_lock, THREAD->as_Java_thread());\n@@ -1052,1 +1052,1 @@\n-    ObjectLocker ol(h_init_lock, THREAD);\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -1093,1 +1093,1 @@\n-      if (is_shared() && SystemDictionaryShared::check_linking_constraints(this, THREAD)) {\n+      if (is_shared() && SystemDictionaryShared::check_linking_constraints(THREAD, this)) {\n@@ -1097,2 +1097,2 @@\n-        vtable().initialize_vtable(true, CHECK_false);\n-        itable().initialize_itable(true, CHECK_false);\n+        vtable().initialize_vtable_and_check_constraints(CHECK_false);\n+        itable().initialize_itable_and_check_constraints(CHECK_false);\n@@ -1178,1 +1178,1 @@\n-    ObjectLocker ol(h_init_lock, THREAD);\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -1350,1 +1350,1 @@\n-    ObjectLocker ol(h_init_lock, THREAD);\n+    ObjectLocker ol(h_init_lock, THREAD->as_Java_thread());\n@@ -2763,2 +2763,2 @@\n-    vtable().initialize_vtable(false, CHECK);\n-    itable().initialize_itable(false, CHECK);\n+    vtable().initialize_vtable();\n+    itable().initialize_itable();\n@@ -3273,1 +3273,1 @@\n-jint InstanceKlass::compute_modifier_flags(TRAPS) const {\n+jint InstanceKlass::compute_modifier_flags() const {\n@@ -3314,7 +3314,11 @@\n-Method* InstanceKlass::method_at_itable(Klass* holder, int index, TRAPS) {\n-  itableOffsetEntry* ioe = (itableOffsetEntry*)start_of_itable();\n-  int method_table_offset_in_words = ioe->offset()\/wordSize;\n-  int nof_interfaces = (method_table_offset_in_words - itable_offset_in_words())\n-                       \/ itableOffsetEntry::size();\n-\n-  for (int cnt = 0 ; ; cnt ++, ioe ++) {\n+Method* InstanceKlass::method_at_itable(InstanceKlass* holder, int index, TRAPS) {\n+  bool implements_interface; \/\/ initialized by method_at_itable_or_null\n+  Method* m = method_at_itable_or_null(holder, index,\n+                                       implements_interface); \/\/ out parameter\n+  if (m != NULL) {\n+    assert(implements_interface, \"sanity\");\n+    return m;\n+  } else if (implements_interface) {\n+    \/\/ Throw AbstractMethodError since corresponding itable slot is empty.\n+    THROW_NULL(vmSymbols::java_lang_AbstractMethodError());\n+  } else {\n@@ -3323,12 +3327,23 @@\n-    if (cnt >= nof_interfaces) {\n-      ResourceMark rm(THREAD);\n-      stringStream ss;\n-      bool same_module = (module() == holder->module());\n-      ss.print(\"Receiver class %s does not implement \"\n-               \"the interface %s defining the method to be called \"\n-               \"(%s%s%s)\",\n-               external_name(), holder->external_name(),\n-               (same_module) ? joint_in_module_of_loader(holder) : class_in_module_of_loader(),\n-               (same_module) ? \"\" : \"; \",\n-               (same_module) ? \"\" : holder->class_in_module_of_loader());\n-      THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());\n+    ResourceMark rm(THREAD);\n+    stringStream ss;\n+    bool same_module = (module() == holder->module());\n+    ss.print(\"Receiver class %s does not implement \"\n+             \"the interface %s defining the method to be called \"\n+             \"(%s%s%s)\",\n+             external_name(), holder->external_name(),\n+             (same_module) ? joint_in_module_of_loader(holder) : class_in_module_of_loader(),\n+             (same_module) ? \"\" : \"; \",\n+             (same_module) ? \"\" : holder->class_in_module_of_loader());\n+    THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());\n+  }\n+}\n+\n+Method* InstanceKlass::method_at_itable_or_null(InstanceKlass* holder, int index, bool& implements_interface) {\n+  klassItable itable(this);\n+  for (int i = 0; i < itable.size_offset_table(); i++) {\n+    itableOffsetEntry* offset_entry = itable.offset_entry(i);\n+    if (offset_entry->interface_klass() == holder) {\n+      implements_interface = true;\n+      itableMethodEntry* ime = offset_entry->first_method_entry(this);\n+      Method* m = ime[index].method();\n+      return m;\n@@ -3336,3 +3351,3 @@\n-\n-    Klass* ik = ioe->interface_klass();\n-    if (ik == holder) break;\n+  implements_interface = false;\n+  return NULL; \/\/ offset entry not found\n+}\n@@ -3341,4 +3356,19 @@\n-  itableMethodEntry* ime = ioe->first_method_entry(this);\n-  Method* m = ime[index].method();\n-  if (m == NULL) {\n-    THROW_NULL(vmSymbols::java_lang_AbstractMethodError());\n+int InstanceKlass::vtable_index_of_interface_method(Method* intf_method) {\n+  assert(is_linked(), \"required\");\n+  assert(intf_method->method_holder()->is_interface(), \"not an interface method\");\n+  assert(is_subtype_of(intf_method->method_holder()), \"interface not implemented\");\n+\n+  int vtable_index = Method::invalid_vtable_index;\n+  Symbol* name = intf_method->name();\n+  Symbol* signature = intf_method->signature();\n+\n+  \/\/ First check in default method array\n+  if (!intf_method->is_abstract() && default_methods() != NULL) {\n+    int index = find_method_index(default_methods(),\n+                                  name, signature,\n+                                  Klass::OverpassLookupMode::find,\n+                                  Klass::StaticLookupMode::find,\n+                                  Klass::PrivateLookupMode::find);\n+    if (index >= 0) {\n+      vtable_index = default_vtable_indices()->at(index);\n+    }\n@@ -3346,1 +3376,6 @@\n-  return m;\n+  if (vtable_index == Method::invalid_vtable_index) {\n+    \/\/ get vtable_index for miranda methods\n+    klassVtable vt = vtable();\n+    vtable_index = vt.index_of_miranda(name, signature);\n+  }\n+  return vtable_index;\n@@ -3349,1 +3384,0 @@\n-\n@@ -3826,1 +3860,1 @@\n-  log_to_classlist(cfs);\n+  log_to_classlist();\n@@ -4419,1 +4453,22 @@\n-void InstanceKlass::log_to_classlist(const ClassFileStream* stream) const {\n+bool InstanceKlass::is_shareable() const {\n+#if INCLUDE_CDS\n+  ClassLoaderData* loader_data = class_loader_data();\n+  if (!SystemDictionaryShared::is_sharing_possible(loader_data)) {\n+    return false;\n+  }\n+\n+  if (is_hidden() || unsafe_anonymous_host() != NULL) {\n+    return false;\n+  }\n+\n+  if (module()->is_patched()) {\n+    return false;\n+  }\n+\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n+void InstanceKlass::log_to_classlist() const {\n@@ -4421,0 +4476,1 @@\n+  ResourceMark rm;\n@@ -4427,39 +4483,1 @@\n-    ClassLoaderData* loader_data = class_loader_data();\n-    if (!SystemDictionaryShared::is_sharing_possible(loader_data)) {\n-      return;\n-    }\n-    bool skip = false;\n-    if (is_shared()) {\n-      assert(stream == NULL, \"shared class with stream\");\n-      if (is_hidden()) {\n-        \/\/ Don't include archived lambda proxy class in the classlist.\n-        assert(!is_non_strong_hidden(), \"unexpected non-strong hidden class\");\n-        return;\n-      }\n-    } else {\n-      assert(stream != NULL, \"non-shared class without stream\");\n-      \/\/ skip hidden class and unsafe anonymous class.\n-      if ( is_hidden() || unsafe_anonymous_host() != NULL) {\n-        return;\n-      }\n-      oop class_loader = loader_data->class_loader();\n-      if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {\n-        \/\/ For the boot and platform class loaders, skip classes that are not found in the\n-        \/\/ java runtime image, such as those found in the --patch-module entries.\n-        \/\/ These classes can't be loaded from the archive during runtime.\n-        if (!stream->from_boot_loader_modules_image() && strncmp(stream->source(), \"jrt:\", 4) != 0) {\n-          skip = true;\n-        }\n-\n-        if (class_loader == NULL && ClassLoader::contains_append_entry(stream->source())) {\n-          \/\/ .. but don't skip the boot classes that are loaded from -Xbootclasspath\/a\n-          \/\/ as they can be loaded from the archive during runtime.\n-          skip = false;\n-        }\n-      }\n-    }\n-    ResourceMark rm;\n-    if (skip) {\n-      tty->print_cr(\"skip writing class %s from source %s to classlist file\",\n-                    name()->as_C_string(), stream->source());\n-    } else {\n+    if (is_shareable()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":104,"deletions":86,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"oops\/klassVtable.hpp\"\n@@ -44,0 +43,1 @@\n+class klassItable;\n@@ -403,0 +403,3 @@\n+  \/\/ Check if the class can be shared in CDS\n+  bool is_shareable() const;\n+\n@@ -582,1 +585,1 @@\n-  void set_nest_host(InstanceKlass* host, TRAPS);\n+  void set_nest_host(InstanceKlass* host);\n@@ -603,1 +606,1 @@\n-  const char* nest_host_error(TRAPS);\n+  const char* nest_host_error();\n@@ -1246,1 +1249,3 @@\n-  Method* method_at_itable(Klass* holder, int index, TRAPS);\n+  Method* method_at_itable(InstanceKlass* holder, int index, TRAPS);\n+  Method* method_at_itable_or_null(InstanceKlass* holder, int index, bool& itable_entry_found);\n+  int vtable_index_of_interface_method(Method* method);\n@@ -1399,1 +1404,1 @@\n-  void log_to_classlist(const ClassFileStream* cfs) const;\n+  void log_to_classlist() const;\n@@ -1407,2 +1412,1 @@\n-  \/\/ jvm support\n-  jint compute_modifier_flags(TRAPS) const;\n+  jint compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"classfile\/dictionary.hpp\"\n@@ -755,5 +754,0 @@\n-\/\/ Unless overridden, modifier_flags is 0.\n-jint Klass::compute_modifier_flags(TRAPS) const {\n-  return 0;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -728,2 +728,1 @@\n-  \/\/ jvm support\n-  virtual jint compute_modifier_flags(TRAPS) const;\n+  virtual jint compute_modifier_flags() const = 0;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/klassVtable.hpp\"\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/java.hpp\"\n@@ -71,2 +71,1 @@\n-    Handle classloader, Symbol* classname, Array<InstanceKlass*>* local_interfaces,\n-    TRAPS) {\n+    Handle classloader, Symbol* classname, Array<InstanceKlass*>* local_interfaces) {\n@@ -163,1 +162,1 @@\n-void klassVtable::initialize_vtable(bool checkconstraints, TRAPS) {\n+void klassVtable::initialize_vtable(GrowableArray<InstanceKlass*>* supers) {\n@@ -169,0 +168,1 @@\n+  Thread* current = Thread::current();\n@@ -171,1 +171,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -202,1 +202,1 @@\n-      methodHandle mh(THREAD, methods->at(i));\n+      methodHandle mh(current, methods->at(i));\n@@ -204,1 +204,1 @@\n-      bool needs_new_entry = update_inherited_vtable(mh, super_vtable_len, -1, checkconstraints, CHECK);\n+      bool needs_new_entry = update_inherited_vtable(current, mh, super_vtable_len, -1, supers);\n@@ -218,7 +218,3 @@\n-        Array<int>* def_vtable_indices = NULL;\n-        if ((def_vtable_indices = ik()->default_vtable_indices()) == NULL) {\n-          assert(!is_shared, \"shared class def_vtable_indices does not exist\");\n-          def_vtable_indices = ik()->create_new_default_vtable_indices(len, CHECK);\n-        } else {\n-          assert(def_vtable_indices->length() == len, \"reinit vtable len?\");\n-        }\n+        Array<int>* def_vtable_indices = ik()->default_vtable_indices();\n+        assert(def_vtable_indices != NULL, \"should be created\");\n+        assert(def_vtable_indices->length() == len, \"reinit vtable len?\");\n@@ -231,1 +227,1 @@\n-            methodHandle mh(THREAD, default_methods->at(i));\n+            methodHandle mh(current, default_methods->at(i));\n@@ -233,1 +229,1 @@\n-            needs_new_entry = update_inherited_vtable(mh, super_vtable_len, i, checkconstraints, CHECK);\n+            needs_new_entry = update_inherited_vtable(current, mh, super_vtable_len, i, supers);\n@@ -261,1 +257,1 @@\n-      initialized = fill_in_mirandas(initialized, THREAD);\n+      initialized = fill_in_mirandas(current, initialized);\n@@ -361,2 +357,1 @@\n-                        Klass* target_klass, Method* super_method,\n-                        Thread* thread) {\n+                        Klass* target_klass, Method* super_method) {\n@@ -365,1 +360,1 @@\n-    ResourceMark rm(thread);\n+    ResourceMark rm;\n@@ -388,1 +383,2 @@\n-bool klassVtable::update_inherited_vtable(const methodHandle& target_method,\n+bool klassVtable::update_inherited_vtable(Thread* current,\n+                                          const methodHandle& target_method,\n@@ -390,2 +386,1 @@\n-                                          bool checkconstraints, TRAPS) {\n-  ResourceMark rm(THREAD);\n+                                          GrowableArray<InstanceKlass*>* supers) {\n@@ -464,2 +459,2 @@\n-  HandleMark hm(THREAD);\n-  Handle target_loader(THREAD, target_klass->class_loader());\n+  HandleMark hm(current);\n+  Handle target_loader(current, target_klass->class_loader());\n@@ -511,36 +506,3 @@\n-\n-        \/\/ Do not check loader constraints for overpass methods because overpass\n-        \/\/ methods are created by the jvm to throw exceptions.\n-        if (checkconstraints && !target_method->is_overpass()) {\n-          \/\/ Override vtable entry if passes loader constraint check\n-          \/\/ if loader constraint checking requested\n-          \/\/ No need to visit his super, since he and his super\n-          \/\/ have already made any needed loader constraints.\n-          \/\/ Since loader constraints are transitive, it is enough\n-          \/\/ to link to the first super, and we get all the others.\n-          Handle super_loader(THREAD, super_klass->class_loader());\n-\n-          if (target_loader() != super_loader()) {\n-            ResourceMark rm(THREAD);\n-            Symbol* failed_type_symbol =\n-              SystemDictionary::check_signature_loaders(signature, _klass,\n-                                                        target_loader, super_loader,\n-                                                        true, CHECK_(false));\n-            if (failed_type_symbol != NULL) {\n-              stringStream ss;\n-              ss.print(\"loader constraint violation for class %s: when selecting \"\n-                       \"overriding method '\", klass->external_name());\n-              target_method->print_external_name(&ss),\n-              ss.print(\"' the class loader %s of the \"\n-                       \"selected method's type %s, and the class loader %s for its super \"\n-                       \"type %s have different Class objects for the type %s used in the signature (%s; %s)\",\n-                       target_klass->class_loader_data()->loader_name_and_id(),\n-                       target_klass->external_name(),\n-                       super_klass->class_loader_data()->loader_name_and_id(),\n-                       super_klass->external_name(),\n-                       failed_type_symbol->as_klass_external_name(),\n-                       target_klass->class_in_module_of_loader(false, true),\n-                       super_klass->class_in_module_of_loader(false, true));\n-              THROW_MSG_(vmSymbols::java_lang_LinkageError(), ss.as_string(), false);\n-            }\n-          }\n+        \/\/ Save super for constraint checking.\n+        if (supers != NULL) {\n+          supers->at_put(i, super_klass);\n@@ -570,1 +532,1 @@\n-      log_vtables(i, overrides, target_method, target_klass, super_method, THREAD);\n+      log_vtables(i, overrides, target_method, target_klass, super_method);\n@@ -602,0 +564,60 @@\n+void klassVtable::check_constraints(GrowableArray<InstanceKlass*>* supers, TRAPS) {\n+  assert(supers->length() == length(), \"lengths are different\");\n+  \/\/ For each method in the vtable, check constraints against any super class\n+  \/\/ if overridden.\n+  for (int i = 0; i < length(); i++) {\n+    methodHandle target_method(THREAD, unchecked_method_at(i));\n+    InstanceKlass* super_klass = supers->at(i);\n+    if (target_method() != NULL && super_klass != NULL) {\n+      \/\/ Do not check loader constraints for overpass methods because overpass\n+      \/\/ methods are created by the jvm to throw exceptions.\n+      if (!target_method->is_overpass()) {\n+        \/\/ Override vtable entry if passes loader constraint check\n+        \/\/ if loader constraint checking requested\n+        \/\/ No need to visit his super, since he and his super\n+        \/\/ have already made any needed loader constraints.\n+        \/\/ Since loader constraints are transitive, it is enough\n+        \/\/ to link to the first super, and we get all the others.\n+        Handle super_loader(THREAD, super_klass->class_loader());\n+        InstanceKlass* target_klass = target_method->method_holder();\n+        Handle target_loader(THREAD, target_klass->class_loader());\n+\n+        if (target_loader() != super_loader()) {\n+          ResourceMark rm(THREAD);\n+          Symbol* failed_type_symbol =\n+            SystemDictionary::check_signature_loaders(target_method->signature(),\n+                                                      _klass,\n+                                                      target_loader, super_loader,\n+                                                      true);\n+          if (failed_type_symbol != NULL) {\n+            stringStream ss;\n+            ss.print(\"loader constraint violation for class %s: when selecting \"\n+                     \"overriding method '\", _klass->external_name());\n+            target_method->print_external_name(&ss),\n+            ss.print(\"' the class loader %s of the \"\n+                     \"selected method's type %s, and the class loader %s for its super \"\n+                     \"type %s have different Class objects for the type %s used in the signature (%s; %s)\",\n+                     target_klass->class_loader_data()->loader_name_and_id(),\n+                     target_klass->external_name(),\n+                     super_klass->class_loader_data()->loader_name_and_id(),\n+                     super_klass->external_name(),\n+                     failed_type_symbol->as_klass_external_name(),\n+                     target_klass->class_in_module_of_loader(false, true),\n+                     super_klass->class_in_module_of_loader(false, true));\n+            THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void klassVtable::initialize_vtable_and_check_constraints(TRAPS) {\n+  \/\/ Save a superclass from each vtable entry to do constraint checking\n+  ResourceMark rm(THREAD);\n+  GrowableArray<InstanceKlass*>* supers = new GrowableArray<InstanceKlass*>(_length, _length, NULL);\n+  initialize_vtable(supers);\n+  check_constraints(supers, CHECK);\n+}\n+\n+\n@@ -940,2 +962,2 @@\n-int klassVtable::fill_in_mirandas(int initialized, TRAPS) {\n-  ResourceMark rm(THREAD);\n+int klassVtable::fill_in_mirandas(Thread* current, int initialized) {\n+  ResourceMark rm(current);\n@@ -1111,1 +1133,1 @@\n-void klassItable::initialize_itable(bool checkconstraints, TRAPS) {\n+void klassItable::initialize_itable(GrowableArray<Method*>* supers) {\n@@ -1115,1 +1137,1 @@\n-    assign_itable_indices_for_interface(InstanceKlass::cast(_klass), THREAD);\n+    assign_itable_indices_for_interface(InstanceKlass::cast(_klass));\n@@ -1128,2 +1150,3 @@\n-    ResourceMark rm(THREAD);\n-    log_develop_debug(itables)(\"%3d: Initializing itables for %s\", ++initialize_count,\n+    if (log_develop_is_enabled(Debug, itables)) {\n+      ResourceMark rm;\n+      log_develop_debug(itables)(\"%3d: Initializing itables for %s\", ++initialize_count,\n@@ -1131,1 +1154,1 @@\n-\n+    }\n@@ -1134,2 +1157,1 @@\n-    int i;\n-    for(i = 0; i < num_interfaces; i++) {\n+    for(int i = 0; i < num_interfaces; i++) {\n@@ -1137,1 +1159,0 @@\n-      HandleMark hm(THREAD);\n@@ -1140,1 +1161,2 @@\n-      initialize_itable_for_interface(ioe->offset(), interf, checkconstraints, CHECK);\n+      initialize_itable_for_interface(ioe->offset(), interf, supers,\n+                       (ioe->offset() - offset_entry(0)->offset())\/wordSize);\n@@ -1142,1 +1164,0 @@\n-\n@@ -1149,0 +1170,56 @@\n+void klassItable::check_constraints(GrowableArray<Method*>* supers, TRAPS) {\n+\n+  assert(_size_method_table == supers->length(), \"wrong size\");\n+  itableMethodEntry* ime = method_entry(0);\n+  for (int i = 0; i < _size_method_table; i++) {\n+    Method* target = ime->method();\n+    Method* interface_method = supers->at(i); \/\/ method overridden\n+\n+    if (target != NULL && interface_method != NULL) {\n+      InstanceKlass* method_holder = target->method_holder();\n+      InstanceKlass* interf = interface_method->method_holder();\n+      HandleMark hm(THREAD);\n+      Handle method_holder_loader(THREAD, method_holder->class_loader());\n+      Handle interface_loader(THREAD, interf->class_loader());\n+\n+      if (method_holder_loader() != interface_loader()) {\n+        ResourceMark rm(THREAD);\n+        Symbol* failed_type_symbol =\n+          SystemDictionary::check_signature_loaders(target->signature(),\n+                                                    _klass,\n+                                                    method_holder_loader,\n+                                                    interface_loader,\n+                                                    true);\n+        if (failed_type_symbol != NULL) {\n+          stringStream ss;\n+          ss.print(\"loader constraint violation in interface itable\"\n+                   \" initialization for class %s: when selecting method '\",\n+                   _klass->external_name());\n+          interface_method->print_external_name(&ss),\n+          ss.print(\"' the class loader %s for super interface %s, and the class\"\n+                   \" loader %s of the selected method's %s, %s have\"\n+                   \" different Class objects for the type %s used in the signature (%s; %s)\",\n+                   interf->class_loader_data()->loader_name_and_id(),\n+                   interf->external_name(),\n+                   method_holder->class_loader_data()->loader_name_and_id(),\n+                   method_holder->external_kind(),\n+                   method_holder->external_name(),\n+                   failed_type_symbol->as_klass_external_name(),\n+                   interf->class_in_module_of_loader(false, true),\n+                   method_holder->class_in_module_of_loader(false, true));\n+          THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n+        }\n+      }\n+    }\n+    ime++;\n+  }\n+}\n+\n+void klassItable::initialize_itable_and_check_constraints(TRAPS) {\n+  \/\/ Save a super interface from each itable entry to do constraint checking\n+  ResourceMark rm(THREAD);\n+  GrowableArray<Method*>* supers =\n+    new GrowableArray<Method*>(_size_method_table, _size_method_table, NULL);\n+  initialize_itable(supers);\n+  check_constraints(supers, CHECK);\n+}\n@@ -1162,1 +1239,1 @@\n-int klassItable::assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS) {\n+int klassItable::assign_itable_indices_for_interface(InstanceKlass* klass) {\n@@ -1164,3 +1241,6 @@\n-  ResourceMark rm(THREAD);\n-  log_develop_debug(itables)(\"%3d: Initializing itable indices for interface %s\",\n-                             ++initialize_count, klass->name()->as_C_string());\n+  if (log_develop_is_enabled(Trace, itables)) {\n+    ResourceMark rm;\n+    log_develop_debug(itables)(\"%3d: Initializing itable indices for interface %s\",\n+                               ++initialize_count, klass->name()->as_C_string());\n+  }\n+\n@@ -1176,0 +1256,1 @@\n+        ResourceMark rm;\n@@ -1230,1 +1311,3 @@\n-void klassItable::initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf, bool checkconstraints, TRAPS) {\n+void klassItable::initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf,\n+                                                  GrowableArray<Method*>* supers,\n+                                                  int start_offset) {\n@@ -1234,2 +1317,0 @@\n-  HandleMark hm(THREAD);\n-  Handle interface_loader (THREAD, interf->class_loader());\n@@ -1249,1 +1330,1 @@\n-                                                               Klass::PrivateLookupMode::skip, CHECK);\n+                                                               Klass::PrivateLookupMode::skip);\n@@ -1261,35 +1342,0 @@\n-      \/\/ Entry did resolve, check loader constraints before initializing\n-      \/\/ if checkconstraints requested\n-      if (checkconstraints) {\n-        Handle method_holder_loader (THREAD, target->method_holder()->class_loader());\n-        InstanceKlass* method_holder = target->method_holder();\n-        if (method_holder_loader() != interface_loader()) {\n-          ResourceMark rm(THREAD);\n-          Symbol* failed_type_symbol =\n-            SystemDictionary::check_signature_loaders(m->signature(),\n-                                                      _klass,\n-                                                      method_holder_loader,\n-                                                      interface_loader,\n-                                                      true, CHECK);\n-          if (failed_type_symbol != NULL) {\n-            stringStream ss;\n-            ss.print(\"loader constraint violation in interface itable\"\n-                     \" initialization for class %s: when selecting method '\",\n-                     _klass->external_name());\n-            m->print_external_name(&ss),\n-            ss.print(\"' the class loader %s for super interface %s, and the class\"\n-                     \" loader %s of the selected method's %s, %s have\"\n-                     \" different Class objects for the type %s used in the signature (%s; %s)\",\n-                     interf->class_loader_data()->loader_name_and_id(),\n-                     interf->external_name(),\n-                     method_holder->class_loader_data()->loader_name_and_id(),\n-                     method_holder->external_kind(),\n-                     method_holder->external_name(),\n-                     failed_type_symbol->as_klass_external_name(),\n-                     interf->class_in_module_of_loader(false, true),\n-                     method_holder->class_in_module_of_loader(false, true));\n-            THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n-          }\n-        }\n-      }\n-      \/\/ ime may have moved during GC so recalculate address\n@@ -1299,0 +1345,7 @@\n+\n+      \/\/ Save super interface method to perform constraint checks.\n+      \/\/ The method is in the error message, that's why.\n+      if (supers != NULL) {\n+        supers->at_put(start_offset + ime_num, m);\n+      }\n+\n@@ -1301,1 +1354,1 @@\n-        ResourceMark rm(THREAD);\n+        ResourceMark rm;\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":172,"deletions":119,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,2 @@\n+  void check_constraints(GrowableArray<InstanceKlass*>* supers, TRAPS);\n+\n@@ -66,1 +68,3 @@\n-  void initialize_vtable(bool checkconstraints, TRAPS);   \/\/ initialize vtable of a new klass\n+  \/\/ initialize vtable of a new klass\n+  void initialize_vtable(GrowableArray<InstanceKlass*>* supers = NULL);\n+  void initialize_vtable_and_check_constraints(TRAPS);\n@@ -78,2 +82,1 @@\n-                                                   Array<InstanceKlass*>* local_interfaces,\n-                                                   TRAPS);\n+                                                   Array<InstanceKlass*>* local_interfaces);\n@@ -119,1 +122,2 @@\n-  bool update_inherited_vtable(const methodHandle& target_method,\n+  bool update_inherited_vtable(Thread* current,\n+                               const methodHandle& target_method,\n@@ -122,1 +126,1 @@\n-                               bool checkconstraints, TRAPS);\n+                               GrowableArray<InstanceKlass*>* supers);\n@@ -129,1 +133,1 @@\n-  int fill_in_mirandas(int initialized, TRAPS);\n+  int fill_in_mirandas(Thread* current, int initialized);\n@@ -282,1 +286,3 @@\n-  void initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf_h, bool checkconstraints, TRAPS);\n+  void initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf_h,\n+                                       GrowableArray<Method*>* supers, int start_offset);\n+  void check_constraints(GrowableArray<Method*>* supers, TRAPS);\n@@ -298,1 +304,2 @@\n-  void initialize_itable(bool checkconstraints, TRAPS);\n+  void initialize_itable_and_check_constraints(TRAPS);\n+  void initialize_itable(GrowableArray<Method*>* supers = NULL);\n@@ -313,1 +320,1 @@\n-  static int assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS);\n+  static int assign_itable_indices_for_interface(InstanceKlass* klass);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-#include \"prims\/nativeLookup.hpp\"\n@@ -571,1 +570,1 @@\n-MethodCounters* Method::build_method_counters(Method* m, TRAPS) {\n+MethodCounters* Method::build_method_counters(Thread* current, Method* m) {\n@@ -577,3 +576,17 @@\n-  methodHandle mh(THREAD, m);\n-  MethodCounters* counters = MethodCounters::allocate(mh, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n+  methodHandle mh(current, m);\n+  MethodCounters* counters;\n+  if (current->is_Java_thread()) {\n+    Thread* THREAD = current;\n+    \/\/ Use the TRAPS version for a JavaThread so it will adjust the GC threshold\n+    \/\/ if needed.\n+    counters = MethodCounters::allocate_with_exception(mh, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      CLEAR_PENDING_EXCEPTION;\n+    }\n+  } else {\n+    \/\/ Call metaspace allocation that doesn't throw exception if the\n+    \/\/ current thread isn't a JavaThread, ie. the VMThread.\n+    counters = MethodCounters::allocate_no_exception(mh);\n+  }\n+\n+  if (counters == NULL) {\n@@ -582,1 +595,1 @@\n-    return NULL;   \/\/ return the exception (which is cleared)\n+    return NULL;\n@@ -584,0 +597,1 @@\n+\n@@ -589,1 +603,1 @@\n-    mh->log_touched(CHECK_NULL);\n+    mh->log_touched(current);\n@@ -1458,1 +1472,1 @@\n-  m->init_intrinsic_id();\n+  m->init_intrinsic_id(klass_id_for_intrinsics(m->method_holder()));\n@@ -1612,1 +1626,6 @@\n-  return vmSymbols::find_sid(klass_name);\n+  vmSymbolID id = vmSymbols::find_sid(klass_name);\n+  if (id != vmSymbolID::NO_SID && vmIntrinsics::class_has_intrinsics(id)) {\n+    return id;\n+  } else {\n+    return vmSymbolID::NO_SID;\n+  }\n@@ -1615,1 +1634,1 @@\n-void Method::init_intrinsic_id() {\n+void Method::init_intrinsic_id(vmSymbolID klass_id) {\n@@ -1622,1 +1641,1 @@\n-  vmSymbolID klass_id = klass_id_for_intrinsics(method_holder());\n+  assert(klass_id == klass_id_for_intrinsics(method_holder()), \"must be\");\n@@ -2309,2 +2328,2 @@\n-void Method::print_jmethod_ids(const ClassLoaderData* loader_data, outputStream* out) {\n-  out->print(\" jni_method_id count = %d\", loader_data->jmethod_ids()->count_methods());\n+void Method::print_jmethod_ids_count(const ClassLoaderData* loader_data, outputStream* out) {\n+  out->print(\"%d\", loader_data->jmethod_ids()->count_methods());\n@@ -2450,1 +2469,1 @@\n-void Method::log_touched(TRAPS) {\n+void Method::log_touched(Thread* current) {\n@@ -2462,1 +2481,1 @@\n-  MutexLocker ml(THREAD, TouchedMethodLog_lock);\n+  MutexLocker ml(current, TouchedMethodLog_lock);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":34,"deletions":15,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"compiler\/oopMap.hpp\"\n@@ -238,1 +237,1 @@\n-  u2   number_of_breakpoints()             const {\n+  u2   number_of_breakpoints() const {\n@@ -246,2 +245,2 @@\n-  void incr_number_of_breakpoints(TRAPS)         {\n-    MethodCounters* mcs = get_method_counters(CHECK);\n+  void incr_number_of_breakpoints(Thread* current) {\n+    MethodCounters* mcs = get_method_counters(current);\n@@ -252,2 +251,2 @@\n-  void decr_number_of_breakpoints(TRAPS)         {\n-    MethodCounters* mcs = get_method_counters(CHECK);\n+  void decr_number_of_breakpoints(Thread* current) {\n+    MethodCounters* mcs = get_method_counters(current);\n@@ -259,1 +258,1 @@\n-  void clear_number_of_breakpoints()             {\n+  void clear_number_of_breakpoints() {\n@@ -302,2 +301,2 @@\n-  void interpreter_throwout_increment(TRAPS) {\n-    MethodCounters* mcs = get_method_counters(CHECK);\n+  void interpreter_throwout_increment(Thread* current) {\n+    MethodCounters* mcs = get_method_counters(current);\n@@ -442,1 +441,1 @@\n-  static MethodCounters* build_method_counters(Method* m, TRAPS);\n+  static MethodCounters* build_method_counters(Thread* current, Method* m);\n@@ -846,1 +845,1 @@\n-  static void print_jmethod_ids(const ClassLoaderData* loader_data, outputStream* out) PRODUCT_RETURN;\n+  static void print_jmethod_ids_count(const ClassLoaderData* loader_data, outputStream* out) PRODUCT_RETURN;\n@@ -863,1 +862,1 @@\n-  void init_intrinsic_id();     \/\/ updates from _none if a match\n+  void init_intrinsic_id(vmSymbolID klass_id);     \/\/ updates from _none if a match\n@@ -992,1 +991,1 @@\n-  MethodCounters* get_method_counters(TRAPS) {\n+  MethodCounters* get_method_counters(Thread* current) {\n@@ -994,1 +993,1 @@\n-      build_method_counters(this, CHECK_AND_CLEAR_NULL);\n+      build_method_counters(current, this);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/arguments.hpp\"\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -333,2 +333,1 @@\n-    ResourceMark rm;\n-    JavaThread *jt = THREAD->as_Java_thread();\n+    ResourceMark rm(THREAD);\n@@ -409,3 +408,1 @@\n-\/\/ JVM support\n-\n-jint ObjArrayKlass::compute_modifier_flags(TRAPS) const {\n+jint ObjArrayKlass::compute_modifier_flags() const {\n@@ -418,1 +415,1 @@\n-  jint element_flags = bottom_klass()->compute_modifier_flags(CHECK_0);\n+  jint element_flags = bottom_klass()->compute_modifier_flags();\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -148,2 +148,1 @@\n-  \/\/ JVM support\n-  jint compute_modifier_flags(TRAPS) const;\n+  jint compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  klass()->oop_print_on(oop(this), st);\n+  klass()->oop_print_on(const_cast<oopDesc*>(this), st);\n@@ -71,1 +71,1 @@\n-  oop obj = oop(this);\n+  oop obj = const_cast<oopDesc*>(this);\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-    return (oop)old_mark.decode_pointer();\n+    return cast_to_oop(old_mark.decode_pointer());\n@@ -320,1 +320,1 @@\n-  return (oop) mark().decode_pointer();\n+  return cast_to_oop(mark().decode_pointer());\n@@ -327,1 +327,1 @@\n-  return (oop) Atomic::load_acquire(&_mark).decode_pointer();\n+  return cast_to_oop(Atomic::load_acquire(&_mark).decode_pointer());\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,3 +90,3 @@\n-  oop()              : _o(NULL)        { register_if_checking(); }\n-  oop(const oop& o)  : _o(o._o)        { register_if_checking(); }\n-  oop(const void* p) : _o((oopDesc*)p) { register_if_checking(); }\n+  oop()             : _o(nullptr) { register_if_checking(); }\n+  oop(const oop& o) : _o(o._o)    { register_if_checking(); }\n+  oop(oopDesc* o)   : _o(o)       { register_if_checking(); }\n@@ -102,3 +102,4 @@\n-  bool operator==(void *p) const       { return _o == p; }\n-  bool operator!=(void *p) const       { return _o != p; }\n-  oop& operator=(const oop& o)        { _o = o._o; return *this; }\n+  bool operator==(std::nullptr_t) const     { return _o == nullptr; }\n+  bool operator!=(std::nullptr_t) const     { return _o != nullptr; }\n+\n+  oop& operator=(const oop& o)         { _o = o._o; return *this; }\n@@ -125,1 +126,1 @@\n-       type##Oop(const void* p) : oop(p) {}                                \\\n+       type##Oop(type##OopDesc* o) : oop((oopDesc*)o) {}                   \\\n@@ -153,5 +154,3 @@\n-\/\/ For CHECK_UNHANDLED_OOPS, it is ambiguous C++ behavior to have the oop\n-\/\/ structure contain explicit user defined conversions of both numerical\n-\/\/ and pointer type. Define inline methods to provide the numerical conversions.\n-template <class T> inline oop cast_to_oop(T value) {\n-  return (oop)(CHECK_UNHANDLED_OOPS_ONLY((void *))(value));\n+\/\/ Cast functions to convert to and from oops.\n+template <typename T> inline oop cast_to_oop(T value) {\n+  return (oopDesc*)value;\n@@ -159,1 +158,1 @@\n-template <class T> inline T cast_from_oop(oop o) {\n+template <typename T> inline T cast_from_oop(oop o) {\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-\n+  JFR_ONLY(ASSIGN_PRIMITIVE_CLASS_ID(ak);)\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -148,8 +148,2 @@\n-      PhaseIterGVN *igvn = phase->is_IterGVN();\n-      if (igvn) {\n-        set_req_X(2,x2,igvn);\n-        set_req_X(1,x1,igvn);\n-      } else {\n-        set_req(2,x2);\n-        set_req(1,x1);\n-      }\n+      set_req_X(2, x2, phase);\n+      set_req_X(1, x1, phase);\n@@ -172,2 +166,2 @@\n-      set_req(1, add2);\n-      set_req(2, a12);\n+      set_req_X(1, add2, phase);\n+      set_req_X(2, a12, phase);\n@@ -191,2 +185,2 @@\n-      set_req(1, addx);\n-      set_req(2, a22);\n+      set_req_X(1, addx, phase);\n+      set_req_X(2, a22, phase);\n@@ -194,5 +188,0 @@\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      if (add2->outcnt() == 0 && igvn) {\n-        \/\/ add disconnected.\n-        igvn->_worklist.push(add2);\n-      }\n@@ -645,8 +634,2 @@\n-      PhaseIterGVN *igvn = phase->is_IterGVN();\n-      if( igvn ) {\n-        set_req_X(Address,address,igvn);\n-        set_req_X(Offset,offset,igvn);\n-      } else {\n-        set_req(Address,address);\n-        set_req(Offset,offset);\n-      }\n+      set_req_X(Address, address, phase);\n+      set_req_X(Offset, offset, phase);\n@@ -1138,2 +1121,2 @@\n-    set_req(1, l);\n-    set_req(2, r);\n+    set_req_X(1, l, phase);\n+    set_req_X(2, r, phase);\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":10,"deletions":27,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1248,2 +1248,11 @@\n-          assert(get_block_for_node(def) || def->is_Con(), \"must have block; constants for debug info ok\");\n-          \/\/ Verify that instructions in the block is in correct order.\n+          Block* def_block = get_block_for_node(def);\n+          assert(def_block || def->is_Con(), \"must have block; constants for debug info ok\");\n+          \/\/ Verify that all definitions dominate their uses (except for virtual\n+          \/\/ instructions merging multiple definitions).\n+          \/\/ TODO re-enable\n+          \/*\n+          assert(n->is_Root() || n->is_Region() || n->is_Phi() || n->is_MachMerge() ||\n+                 def_block->dominates(block),\n+                 \"uses must be dominated by definitions\");\n+          *\/\n+          \/\/ Verify that instructions in the block are in correct order.\n@@ -1253,1 +1262,1 @@\n-          if (get_block_for_node(def) == block && !(block->head()->is_Loop() && n->is_Phi()) &&\n+          if (def_block == block && !(block->head()->is_Loop() && n->is_Phi()) &&\n@@ -1269,0 +1278,8 @@\n+      if (n->is_Proj()) {\n+        assert(j >= 1, \"a projection cannot be the first instruction in a block\");\n+        Node* pred = block->get_node(j - 1);\n+        Node* parent = n->in(0);\n+        assert(parent != NULL, \"projections must have a parent\");\n+        assert(pred == parent || (pred->is_Proj() && pred->in(0) == parent),\n+               \"projections must follow their parents or other sibling projections\");\n+      }\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-    if (!Matcher::has_match_rule(Op_StrCompressedCopy)) return false;\n+    if (!Matcher::match_rule_supported(Op_StrCompressedCopy)) return false;\n@@ -186,1 +186,1 @@\n-    if (!Matcher::has_match_rule(Op_StrInflatedCopy)) return false;\n+    if (!Matcher::match_rule_supported(Op_StrInflatedCopy)) return false;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -584,0 +584,56 @@\n+static bool has_non_debug_usages(Node* n) {\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* m = n->fast_out(i);\n+    if (!m->is_SafePoint()\n+        || (m->is_Call() && m->as_Call()->has_non_debug_use(n))) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+static bool is_box_cache_valid(CallNode* call) {\n+  ciInstanceKlass* klass = call->as_CallStaticJava()->method()->holder();\n+  return klass->is_box_cache_valid();\n+}\n+\n+\/\/ delay box in runtime, treat box as a scalarized object\n+static void scalarize_debug_usages(CallNode* call, Node* resproj) {\n+  GraphKit kit(call->jvms());\n+  PhaseGVN& gvn = kit.gvn();\n+\n+  ProjNode* res = resproj->as_Proj();\n+  ciInstanceKlass* klass = call->as_CallStaticJava()->method()->holder();\n+  int n_fields = klass->nof_nonstatic_fields();\n+  assert(n_fields == 1, \"the klass must be an auto-boxing klass\");\n+\n+  for (DUIterator_Last imin, i = res->last_outs(imin); i >= imin;) {\n+    SafePointNode* sfpt = res->last_out(i)->as_SafePoint();\n+    uint first_ind = sfpt->req() - sfpt->jvms()->scloff();\n+    Node* sobj = new SafePointScalarObjectNode(gvn.type(res)->isa_oopptr(),\n+#ifdef ASSERT\n+                                                call,\n+#endif \/\/ ASSERT\n+                                                first_ind, n_fields, true);\n+    sobj->init_req(0, kit.root());\n+    sfpt->add_req(call->in(TypeFunc::Parms));\n+    sobj = gvn.transform(sobj);\n+    JVMState* jvms = sfpt->jvms();\n+    jvms->set_endoff(sfpt->req());\n+    int start = jvms->debug_start();\n+    int end   = jvms->debug_end();\n+    int num_edges = sfpt->replace_edges_in_range(res, sobj, start, end, &gvn);\n+    i -= num_edges;\n+  }\n+\n+  assert(res->outcnt() == 0, \"the box must have no use after replace\");\n+\n+#ifndef PRODUCT\n+  if (PrintEliminateAllocations) {\n+    tty->print(\"++++ Eliminated: %d \", call->_idx);\n+    call->as_CallStaticJava()->method()->print_short_name(tty);\n+    tty->cr();\n+  }\n+#endif\n+}\n+\n@@ -624,11 +680,0 @@\n-  bool result_not_used = true;\n-  for (uint i = 0; i < callprojs->nb_resproj; i++) {\n-    if (callprojs->resproj[i] != NULL) {\n-      if (callprojs->resproj[i]->outcnt() != 0) {\n-        result_not_used = false;\n-      }\n-      if (call->find_edge(callprojs->resproj[i]) != -1) {\n-        return;\n-      }\n-    }\n-  }\n@@ -642,1 +687,11 @@\n-  if (is_pure_call() && result_not_used) {\n+  bool result_not_used = false;\n+\n+  if (is_pure_call()) {\n+    if (is_boxing_late_inline() && callprojs->resproj[0] != nullptr) {\n+        \/\/ replace box node to scalar node only in case it is directly referenced by debug info\n+        assert(call->as_CallStaticJava()->is_boxing_method(), \"sanity\");\n+        if (!has_non_debug_usages(callprojs->resproj[0]) && is_box_cache_valid(call)) {\n+          scalarize_debug_usages(call, callprojs->resproj[0]);\n+        }\n+    }\n+\n@@ -645,0 +700,14 @@\n+    result_not_used = true;\n+    for (uint i = 0; i < callprojs->nb_resproj; i++) {\n+      if (callprojs->resproj[i] != NULL) {\n+        if (callprojs->resproj[i]->outcnt() != 0) {\n+          result_not_used = false;\n+        }\n+        if (call->find_edge(callprojs->resproj[i]) != -1) {\n+          return;\n+        }\n+      }\n+    }\n+  }\n+\n+  if (result_not_used) {\n@@ -840,0 +909,2 @@\n+  virtual bool is_boxing_late_inline() const { return true; }\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":84,"deletions":13,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  virtual bool      is_boxing_late_inline() const  { return false; }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1719,1 +1719,1 @@\n-                                                     AllocateNode* alloc,\n+                                                     Node* alloc,\n@@ -1722,1 +1722,2 @@\n-                                                     uint n_fields) :\n+                                                     uint n_fields,\n+                                                     bool is_auto_box) :\n@@ -1725,1 +1726,2 @@\n-  _n_fields(n_fields)\n+  _n_fields(n_fields),\n+  _is_auto_box(is_auto_box)\n@@ -1730,0 +1732,8 @@\n+#ifdef ASSERT\n+  if (alloc != NULL && !alloc->is_Allocate()\n+      && !(alloc->Opcode() == Op_VectorBox)\n+      && (!alloc->is_CallStaticJava() || !alloc->as_CallStaticJava()->is_boxing_method())) {\n+    alloc->dump();\n+    assert(false, \"unexpected call node\");\n+  }\n+#endif\n@@ -2275,1 +2285,1 @@\n-    \/\/ If we are locking an unescaped object, the lock\/unlock is unnecessary\n+    \/\/ If we are locking an non-escaped object, the lock\/unlock is unnecessary\n@@ -2445,1 +2455,1 @@\n-    \/\/ If we are unlocking an unescaped object, the lock\/unlock is unnecessary.\n+    \/\/ If we are unlocking an non-escaped object, the lock\/unlock is unnecessary.\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -486,2 +486,0 @@\n-  static  bool           needs_polling_address_input();\n-\n@@ -503,1 +501,2 @@\n-  DEBUG_ONLY(AllocateNode* _alloc;)\n+  bool _is_auto_box; \/\/ True if the scalarized object is an auto box.\n+  DEBUG_ONLY(Node* _alloc;)\n@@ -513,1 +512,1 @@\n-                            AllocateNode* alloc,\n+                            Node* alloc,\n@@ -515,1 +514,1 @@\n-                            uint first_index, uint n_fields);\n+                            uint first_index, uint n_fields, bool is_auto_box = false);\n@@ -528,0 +527,1 @@\n+  bool is_auto_box() const { return _is_auto_box; }\n@@ -529,1 +529,1 @@\n-  AllocateNode* alloc() const { return _alloc; }\n+  Node* alloc() const { return _alloc; }\n@@ -636,2 +636,3 @@\n-  virtual void clone_jvms(Compile* C) {\n-    if (C->needs_clone_jvms() && jvms() != NULL) {\n+  virtual bool needs_clone_jvms(Compile* C) { return C->needs_clone_jvms(); }\n+  void clone_jvms(Compile* C) {\n+    if ((jvms() != NULL) && needs_clone_jvms(C)) {\n@@ -773,5 +774,2 @@\n-  virtual void  clone_jvms(Compile* C) {\n-    if ((jvms() != NULL) && is_boxing_method()) {\n-      set_jvms(jvms()->clone_deep(C));\n-      jvms()->set_map_deep(this);\n-    }\n+  virtual bool needs_clone_jvms(Compile* C) {\n+    return is_boxing_method() || CallNode::needs_clone_jvms(C);\n@@ -802,5 +800,2 @@\n-  virtual void clone_jvms(Compile* C) {\n-    if ((jvms() != NULL) && IncrementalInlineVirtual) {\n-      set_jvms(jvms()->clone_deep(C));\n-      jvms()->set_map_deep(this);\n-    }\n+  virtual bool needs_clone_jvms(Compile* C) {\n+    return IncrementalInlineVirtual || CallNode::needs_clone_jvms(C);\n@@ -968,6 +963,1 @@\n-  virtual void  clone_jvms(Compile* C) {\n-    if (jvms() != NULL) {\n-      set_jvms(jvms()->clone_deep(C));\n-      jvms()->set_map_deep(this);\n-    }\n-  }\n+  virtual bool needs_clone_jvms(Compile* C) { return true; }\n@@ -1187,6 +1177,1 @@\n-  virtual void  clone_jvms(Compile* C) {\n-    if (jvms() != NULL) {\n-      set_jvms(jvms()->clone_deep(C));\n-      jvms()->set_map_deep(this);\n-    }\n-  }\n+  virtual bool needs_clone_jvms(Compile* C) { return true; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":15,"deletions":30,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -246,3 +246,2 @@\n-static Node* find_or_make_CastII(PhaseIterGVN* igvn, Node* parent, Node* control,\n-                                 const TypeInt* type) {\n-  Node* n = new CastIINode(parent, type);\n+static Node* find_or_make_CastII(PhaseIterGVN* igvn, Node* parent, Node* control, const TypeInt* type, bool carry_dependency) {\n+  Node* n = new CastIINode(parent, type, carry_dependency);\n@@ -281,2 +280,2 @@\n-    Node* cx = find_or_make_CastII(igvn, x, in(0), rx->is_int());\n-    Node* cy = find_or_make_CastII(igvn, y, in(0), ry->is_int());\n+    Node* cx = find_or_make_CastII(igvn, x, in(0), rx->is_int(), _carry_dependency);\n+    Node* cy = find_or_make_CastII(igvn, y, in(0), ry->is_int(), _carry_dependency);\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -635,0 +635,7 @@\n+        if (n->outcnt() == 0) {\n+          int uses_found = n->replace_edge(this, phase->C->top(), igvn);\n+          if (uses_found > 1) { \/\/ (--i) done at the end of the loop.\n+            i -= (uses_found - 1);\n+          }\n+          continue;\n+        }\n@@ -651,8 +658,2 @@\n-          uint uses_found = 0;\n-          for( uint k=1; k < n->req(); k++ ) {\n-            if( n->in(k) == this ) {\n-              n->set_req(k, parent_ctrl);\n-              uses_found++;\n-            }\n-          }\n-          if( uses_found > 1 ) { \/\/ (--i) done at the end of the loop.\n+          int uses_found = n->replace_edge(this, parent_ctrl, igvn);\n+          if (uses_found > 1) { \/\/ (--i) done at the end of the loop.\n@@ -892,0 +893,3 @@\n+    if (new_bol->outcnt() == 0) {\n+      igvn->remove_dead_node(new_bol);\n+    }\n@@ -1956,5 +1960,1 @@\n-        if (can_reshape) {\n-          set_req_X(j, top, igvn);\n-        } else {\n-          set_req(j, top);\n-        }\n+        set_req_X(j, top, phase);\n@@ -1998,1 +1998,1 @@\n-          replace_edge(uin, top);\n+          replace_edge(uin, top, phase);\n@@ -2271,1 +2271,1 @@\n-              set_req(i, new_mem);\n+              set_req_X(i, new_mem, phase->is_IterGVN());\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -827,1 +827,2 @@\n-        assert(n_type->isa_vect() == NULL || lrg._is_vector || ireg == Op_RegD || ireg == Op_RegL,\n+        assert(n_type->isa_vect() == NULL || lrg._is_vector ||\n+               ireg == Op_RegD || ireg == Op_RegL  || ireg == Op_RegVectMask,\n@@ -920,0 +921,4 @@\n+        case Op_RegVectMask:\n+          lrg.set_num_regs(RegMask::SlotsPerRegVectMask);\n+          lrg.set_reg_pressure(1);\n+          break;\n@@ -1039,2 +1044,2 @@\n-        assert(n->in(k)->bottom_type()->isa_vect() == NULL ||\n-               is_vect || kreg == Op_RegD || kreg == Op_RegL,\n+        assert(n->in(k)->bottom_type()->isa_vect() == NULL || is_vect ||\n+               kreg == Op_RegD || kreg == Op_RegL || kreg == Op_RegVectMask,\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -452,0 +452,1 @@\n+macro(VectorMaskCast)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -2792,0 +2791,2 @@\n+ check_no_dead_use();\n+\n@@ -2807,0 +2808,19 @@\n+#ifdef ASSERT\n+void Compile::check_no_dead_use() const {\n+  ResourceMark rm;\n+  Unique_Node_List wq;\n+  wq.push(root());\n+  for (uint i = 0; i < wq.size(); ++i) {\n+    Node* n = wq.at(i);\n+    for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+      Node* u = n->fast_out(j);\n+      if (u->outcnt() == 0 && !u->is_Con()) {\n+        u->dump();\n+        fatal(\"no reachable node should have no use\");\n+      }\n+      wq.push(u);\n+    }\n+  }\n+}\n+#endif\n+\n@@ -2866,1 +2886,1 @@\n-  if (!is_vector_bitwise_op(n)) {\n+  if (n->bottom_type()->isa_vectmask() || !is_vector_bitwise_op(n)) {\n@@ -3180,1 +3200,0 @@\n-    print_method(PHASE_AFTER_MATCHING, 3);\n@@ -3956,1 +3975,1 @@\n-    assert(!n->as_Loop()->is_transformed_long_loop() || _loop_opts_cnt == 0, \"should have been turned into a counted loop\");\n+    assert(!n->as_Loop()->is_transformed_long_inner_loop() || _loop_opts_cnt == 0, \"should have been turned into a counted loop\");\n@@ -5159,1 +5178,1 @@\n-void Compile::print_method(CompilerPhaseType cpt, const char *name, int level, int idx) {\n+void Compile::print_method(CompilerPhaseType cpt, const char *name, int level) {\n@@ -5181,1 +5200,1 @@\n-  print_method(cpt, output, level, idx);\n+  print_method(cpt, output, level);\n@@ -5247,1 +5266,1 @@\n-  Compile::current()->print_method(PHASE_DEBUG, 0, 0);\n+  Compile::current()->print_method(PHASE_DEBUG, 0);\n@@ -5270,1 +5289,1 @@\n-  _debug_file_printer->print_method(phase_name, 0);\n+  _debug_file_printer->print(phase_name, (Node*)C->root());\n@@ -5280,1 +5299,1 @@\n-  _debug_network_printer->print_method(phase_name, 0);\n+  _debug_network_printer->print(phase_name, (Node*)C->root());\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -661,1 +661,1 @@\n-  void print_method(CompilerPhaseType cpt, const char *name, int level = 1, int idx = 0);\n+  void print_method(CompilerPhaseType cpt, const char *name, int level = 1);\n@@ -1141,0 +1141,1 @@\n+  void check_no_dead_use() const NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-#include \"prims\/nativeLookup.hpp\"\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,2 +67,0 @@\n-  _pcmp_neq = NULL; \/\/ Should be initialized\n-  _pcmp_eq  = NULL;\n@@ -77,1 +75,1 @@\n-    if (n->is_Allocate())\n+    if (n->is_Allocate()) {\n@@ -79,0 +77,1 @@\n+    }\n@@ -81,1 +80,1 @@\n-      if (!(obj->is_Parm() || obj->is_Con()))\n+      if (!(obj->is_Parm() || obj->is_Con())) {\n@@ -83,0 +82,1 @@\n+      }\n@@ -107,1 +107,1 @@\n-  if (oop_null->outcnt() == 0)\n+  if (oop_null->outcnt() == 0) {\n@@ -109,1 +109,2 @@\n-  if (noop_null->outcnt() == 0)\n+  }\n+  if (noop_null->outcnt() == 0) {\n@@ -111,0 +112,1 @@\n+  }\n@@ -125,1 +127,1 @@\n-  GrowableArray<JavaObjectNode*> non_escaped_worklist;\n+  GrowableArray<JavaObjectNode*> non_escaped_allocs_worklist;\n@@ -167,1 +169,1 @@\n-          non_escaped_worklist.append(ptn->as_JavaObject());\n+          non_escaped_allocs_worklist.append(ptn->as_JavaObject());\n@@ -207,1 +209,1 @@\n-  if (non_escaped_worklist.length() == 0) {\n+  if (non_escaped_allocs_worklist.length() == 0) {\n@@ -216,1 +218,0 @@\n-  int ptnodes_length = ptnodes_worklist.length();\n@@ -223,0 +224,1 @@\n+    int ptnodes_length = ptnodes_worklist.length();\n@@ -242,1 +244,1 @@\n-  if (!complete_connection_graph(ptnodes_worklist, non_escaped_worklist,\n+  if (!complete_connection_graph(ptnodes_worklist, non_escaped_allocs_worklist,\n@@ -252,1 +254,1 @@\n-  int non_escaped_length = non_escaped_worklist.length();\n+  int non_escaped_length = non_escaped_allocs_worklist.length();\n@@ -254,1 +256,1 @@\n-    JavaObjectNode* ptn = non_escaped_worklist.at(next);\n+    JavaObjectNode* ptn = non_escaped_allocs_worklist.at(next);\n@@ -271,1 +273,1 @@\n-    verify_connection_graph(ptnodes_worklist, non_escaped_worklist,\n+    verify_connection_graph(ptnodes_worklist, non_escaped_allocs_worklist,\n@@ -286,1 +288,1 @@\n-  bool has_non_escaping_obj = (non_escaped_worklist.length() > 0);\n+  bool has_non_escaping_obj = (non_escaped_allocs_worklist.length() > 0);\n@@ -297,1 +299,0 @@\n-  bool has_scalar_replaceable_candidates = (alloc_worklist.length() > 0);\n@@ -310,0 +311,1 @@\n+  bool has_scalar_replaceable_candidates = (alloc_worklist.length() > 0);\n@@ -322,1 +324,1 @@\n-    if(!EliminateAllocations) {\n+    if (!EliminateAllocations) {\n@@ -442,1 +444,1 @@\n-  if (n_ptn != NULL)\n+  if (n_ptn != NULL) {\n@@ -444,1 +446,1 @@\n-\n+  }\n@@ -463,1 +465,1 @@\n-        if (name != NULL && strcmp(name, \"uncommon_trap\") == 0)\n+        if (name != NULL && strcmp(name, \"uncommon_trap\") == 0) {\n@@ -465,0 +467,1 @@\n+        }\n@@ -491,1 +494,1 @@\n-  if (n_ptn == phantom_obj || n_ptn == null_obj)\n+  if (n_ptn == phantom_obj || n_ptn == null_obj) {\n@@ -493,1 +496,1 @@\n-\n+  }\n@@ -613,1 +616,1 @@\n-      \/\/ fallthrough\n+      \/\/ fall-through\n@@ -702,1 +705,1 @@\n-        if (in == NULL)\n+        if (in == NULL) {\n@@ -704,0 +707,1 @@\n+        }\n@@ -705,1 +709,1 @@\n-        if (uncast_in->is_top() || uncast_in == n)\n+        if (uncast_in->is_top() || uncast_in == n) {\n@@ -707,0 +711,1 @@\n+        }\n@@ -733,1 +738,1 @@\n-          if (in == NULL)\n+          if (in == NULL) {\n@@ -735,0 +740,1 @@\n+          }\n@@ -736,1 +742,1 @@\n-          if (uncast_in->is_top() || uncast_in == n)\n+          if (uncast_in->is_top() || uncast_in == n) {\n@@ -738,0 +744,1 @@\n+          }\n@@ -977,1 +984,1 @@\n-      \/\/ Returns a newly allocated unescaped object.\n+      \/\/ Returns a newly allocated non-escaped object.\n@@ -996,1 +1003,1 @@\n-        \/\/ Returns a newly allocated unescaped object, simply\n+        \/\/ Returns a newly allocated non-escaped object, simply\n@@ -1060,1 +1067,1 @@\n-        if (arg->is_top() || !at->isa_ptr() || !aat->isa_ptr())\n+        if (arg->is_top() || !at->isa_ptr() || !aat->isa_ptr()) {\n@@ -1062,0 +1069,1 @@\n+        }\n@@ -1258,1 +1266,1 @@\n-                         GrowableArray<JavaObjectNode*>& non_escaped_worklist,\n+                         GrowableArray<JavaObjectNode*>& non_escaped_allocs_worklist,\n@@ -1266,1 +1274,1 @@\n-#define CG_BUILD_ITER_LIMIT 20\n+#define GRAPH_BUILD_ITER_LIMIT 20\n@@ -1271,1 +1279,1 @@\n-  if (!find_non_escaped_objects(ptnodes_worklist, non_escaped_worklist)) {\n+  if (!find_non_escaped_objects(ptnodes_worklist, non_escaped_allocs_worklist)) {\n@@ -1276,0 +1284,2 @@\n+  elapsedTimer build_time;\n+  build_time.start();\n@@ -1282,1 +1292,1 @@\n-           (iterations++ < CG_BUILD_ITER_LIMIT)) {\n+           (iterations++ < GRAPH_BUILD_ITER_LIMIT)) {\n@@ -1317,1 +1327,1 @@\n-        if (!find_non_escaped_objects(ptnodes_worklist, non_escaped_worklist)) {\n+        if (!find_non_escaped_objects(ptnodes_worklist, non_escaped_allocs_worklist)) {\n@@ -1327,1 +1337,1 @@\n-    if ((iterations < CG_BUILD_ITER_LIMIT) && !timeout) {\n+    if ((iterations < GRAPH_BUILD_ITER_LIMIT) && !timeout) {\n@@ -1349,0 +1359,4 @@\n+  build_time.stop();\n+  _build_time = build_time.seconds();\n+  _build_iterations = iterations;\n+\n@@ -1350,1 +1364,1 @@\n-  if ((iterations >= CG_BUILD_ITER_LIMIT) || timeout) {\n+  if ((iterations >= GRAPH_BUILD_ITER_LIMIT) || timeout) {\n@@ -1358,1 +1372,1 @@\n-           time.seconds(), iterations, nodes_size(), ptnodes_worklist.length());\n+           _build_time, _build_iterations, nodes_size(), ptnodes_worklist.length());\n@@ -1365,2 +1379,2 @@\n-    tty->print_cr(\"EA: %d iterations to build connection graph with %d nodes and worklist size %d\",\n-                  iterations, nodes_size(), ptnodes_worklist.length());\n+    tty->print_cr(\"EA: %d iterations and %f sec to build connection graph with %d nodes and worklist size %d\",\n+                  _build_iterations, _build_time, nodes_size(), ptnodes_worklist.length());\n@@ -1370,1 +1384,1 @@\n-#undef CG_BUILD_ITER_LIMIT\n+#undef GRAPH_BUILD_ITER_LIMIT\n@@ -1373,1 +1387,1 @@\n-  int non_escaped_length = non_escaped_worklist.length();\n+  int non_escaped_length = non_escaped_allocs_worklist.length();\n@@ -1375,1 +1389,1 @@\n-    JavaObjectNode* ptn = non_escaped_worklist.at(next);\n+    JavaObjectNode* ptn = non_escaped_allocs_worklist.at(next);\n@@ -1379,1 +1393,1 @@\n-      if (find_init_values(ptn, null_obj, _igvn) > 0) {\n+      if (find_init_values_null(ptn, _igvn) > 0) {\n@@ -1401,1 +1415,1 @@\n-                                               GrowableArray<JavaObjectNode*>& non_escaped_worklist) {\n+                                               GrowableArray<JavaObjectNode*>& non_escaped_allocs_worklist) {\n@@ -1464,2 +1478,2 @@\n-  for (int next = non_escaped_worklist.length()-1; next >= 0 ; --next) {\n-    JavaObjectNode* ptn = non_escaped_worklist.at(next);\n+  for (int next = non_escaped_allocs_worklist.length()-1; next >= 0 ; --next) {\n+    JavaObjectNode* ptn = non_escaped_allocs_worklist.at(next);\n@@ -1467,1 +1481,1 @@\n-      non_escaped_worklist.delete_at(next);\n+      non_escaped_allocs_worklist.delete_at(next);\n@@ -1471,1 +1485,1 @@\n-      find_init_values(ptn, phantom_obj, NULL);\n+      find_init_values_phantom(ptn);\n@@ -1474,1 +1488,1 @@\n-  return (non_escaped_worklist.length() > 0);\n+  return (non_escaped_allocs_worklist.length() > 0);\n@@ -1484,1 +1498,1 @@\n-      if (use->is_Arraycopy())\n+      if (use->is_Arraycopy()) {\n@@ -1486,0 +1500,1 @@\n+      }\n@@ -1506,1 +1521,1 @@\n-      if (jobj == null_obj) \/\/ NULL object does not have field edges\n+      if (jobj == null_obj) { \/\/ NULL object does not have field edges\n@@ -1508,0 +1523,1 @@\n+      }\n@@ -1516,1 +1532,1 @@\n-    if (!add_edge(use, jobj))\n+    if (!add_edge(use, jobj)) {\n@@ -1518,0 +1534,1 @@\n+    }\n@@ -1525,1 +1542,1 @@\n-            if (jobj == null_obj) \/\/ NULL object does not have field edges\n+            if (jobj == null_obj) { \/\/ NULL object does not have field edges\n@@ -1527,0 +1544,1 @@\n+            }\n@@ -1585,1 +1603,1 @@\n-        if (f == field || !f->as_Field()->is_oop())\n+        if (f == field || !f->as_Field()->is_oop()) {\n@@ -1587,0 +1605,1 @@\n+        }\n@@ -1608,1 +1627,1 @@\n-        if (f == field || !f->as_Field()->is_oop())\n+        if (f == field || !f->as_Field()->is_oop()) {\n@@ -1610,0 +1629,1 @@\n+        }\n@@ -1628,1 +1648,1 @@\n-      if (base->ideal_node()->is_Allocate())\n+      if (base->ideal_node()->is_Allocate()) {\n@@ -1630,0 +1650,1 @@\n+      }\n@@ -1642,1 +1663,1 @@\n-int ConnectionGraph::find_init_values(JavaObjectNode* pta, PointsToNode* init_val, PhaseTransform* phase) {\n+int ConnectionGraph::find_init_values_phantom(JavaObjectNode* pta) {\n@@ -1644,1 +1665,1 @@\n-  int new_edges = 0;\n+  PointsToNode* init_val = phantom_obj;\n@@ -1646,12 +1667,11 @@\n-  if (init_val == phantom_obj) {\n-    \/\/ Do nothing for Allocate nodes since its fields values are\n-    \/\/ \"known\" unless they are initialized by arraycopy\/clone.\n-    if (alloc->is_Allocate() && !pta->arraycopy_dst()) {\n-      if (alloc->as_Allocate()->in(AllocateNode::DefaultValue) != NULL) {\n-        \/\/ Non-flattened inline type arrays are initialized with\n-        \/\/ the default value instead of null. Handle them here.\n-        init_val = ptnode_adr(alloc->as_Allocate()->in(AllocateNode::DefaultValue)->_idx);\n-        assert(init_val != NULL, \"default value should be registered\");\n-      } else {\n-        return 0;\n-      }\n+\n+  \/\/ Do nothing for Allocate nodes since its fields values are\n+  \/\/ \"known\" unless they are initialized by arraycopy\/clone.\n+  if (alloc->is_Allocate() && !pta->arraycopy_dst()) {\n+    if (alloc->as_Allocate()->in(AllocateNode::DefaultValue) != NULL) {\n+      \/\/ Non-flattened inline type arrays are initialized with\n+      \/\/ the default value instead of null. Handle them here.\n+      init_val = ptnode_adr(alloc->as_Allocate()->in(AllocateNode::DefaultValue)->_idx);\n+      assert(init_val != NULL, \"default value should be registered\");\n+    } else {\n+      return 0;\n@@ -1659,2 +1679,3 @@\n-    \/\/ Non-escaped allocation returned from Java or runtime call has unknown values in fields.\n-    assert(pta->arraycopy_dst() || alloc->is_CallStaticJava() || init_val != phantom_obj, \"sanity\");\n+  }\n+  \/\/ Non-escaped allocation returned from Java or runtime call has unknown values in fields.\n+  assert(pta->arraycopy_dst() || alloc->is_CallStaticJava() || init_val != phantom_obj, \"sanity\");\n@@ -1662,4 +1683,4 @@\n-    if (alloc->is_CallStaticJava() && alloc->as_CallStaticJava()->method() == NULL) {\n-      const char* name = alloc->as_CallStaticJava()->_name;\n-      assert(strncmp(name, \"_multianewarray\", 15) == 0, \"sanity\");\n-    }\n+  if (alloc->is_CallStaticJava() && alloc->as_CallStaticJava()->method() == NULL) {\n+    const char* name = alloc->as_CallStaticJava()->_name;\n+    assert(strncmp(name, \"_multianewarray\", 15) == 0, \"sanity\");\n+  }\n@@ -1667,8 +1688,9 @@\n-    for (EdgeIterator i(pta); i.has_next(); i.next()) {\n-      PointsToNode* field = i.get();\n-      if (field->is_Field() && field->as_Field()->is_oop()) {\n-        if (add_edge(field, init_val)) {\n-          \/\/ New edge was added\n-          new_edges++;\n-          add_field_uses_to_worklist(field->as_Field());\n-        }\n+  \/\/ Non-escaped allocation returned from Java or runtime call have unknown values in fields.\n+  int new_edges = 0;\n+  for (EdgeIterator i(pta); i.has_next(); i.next()) {\n+    PointsToNode* field = i.get();\n+    if (field->is_Field() && field->as_Field()->is_oop()) {\n+      if (add_edge(field, init_val)) {\n+        \/\/ New edge was added\n+        new_edges++;\n+        add_field_uses_to_worklist(field->as_Field());\n@@ -1677,2 +1699,7 @@\n-    return new_edges;\n-  assert(init_val == null_obj, \"sanity\");\n+  return new_edges;\n+}\n+\n+\/\/ Find fields initializing values for allocations.\n+int ConnectionGraph::find_init_values_null(JavaObjectNode* pta, PhaseTransform* phase) {\n+  assert(pta->escape_state() == PointsToNode::NoEscape, \"Not escaped Allocate nodes only\");\n+  Node* alloc = pta->ideal_node();\n@@ -1684,1 +1711,0 @@\n-\n@@ -1688,0 +1714,1 @@\n+  int new_edges = 0;\n@@ -1696,1 +1723,1 @@\n-    if (!field->is_Field() || !field->as_Field()->is_oop())\n+    if (!field->is_Field() || !field->as_Field()->is_oop()) {\n@@ -1698,0 +1725,1 @@\n+    }\n@@ -1804,3 +1832,0 @@\n-  \/\/ 1. An object is not scalar replaceable if the field into which it is\n-  \/\/ stored has unknown offset (stored into unknown element of an array).\n-  \/\/\n@@ -1815,0 +1840,2 @@\n+      \/\/ 1. An object is not scalar replaceable if the field into which it is\n+      \/\/ stored has unknown offset (stored into unknown element of an array).\n@@ -1920,1 +1947,1 @@\n-                         GrowableArray<JavaObjectNode*>& non_escaped_worklist,\n+                         GrowableArray<JavaObjectNode*>& non_escaped_allocs_worklist,\n@@ -1925,1 +1952,1 @@\n-  int non_escaped_length  = non_escaped_worklist.length();\n+  int non_escaped_length  = non_escaped_allocs_worklist.length();\n@@ -1933,3 +1960,3 @@\n-  int length = non_escaped_worklist.length();\n-  find_non_escaped_objects(ptnodes_worklist, non_escaped_worklist);\n-  assert((non_escaped_length == non_escaped_worklist.length()) &&\n+  int length = non_escaped_allocs_worklist.length();\n+  find_non_escaped_objects(ptnodes_worklist, non_escaped_allocs_worklist);\n+  assert((non_escaped_length == non_escaped_allocs_worklist.length()) &&\n@@ -1996,1 +2023,1 @@\n-    for( int i=0; i < cnt; i++ ) {\n+    for (int i = 0; i < cnt; i++) {\n@@ -2019,8 +2046,5 @@\n-    \/\/ Add ConI(#CC_GT) and ConI(#CC_EQ).\n-    _pcmp_neq = igvn->makecon(TypeInt::CC_GT);\n-    _pcmp_eq = igvn->makecon(TypeInt::CC_EQ);\n-    \/\/ Optimize objects compare.\n-    while (ptr_cmp_worklist.length() != 0) {\n-      Node *n = ptr_cmp_worklist.pop();\n-      Node *res = optimize_ptr_compare(n);\n-      if (res != NULL) {\n+    for (int i = 0; i < ptr_cmp_worklist.length(); i++) {\n+      Node *n = ptr_cmp_worklist.at(i);\n+      const TypeInt* tcmp = optimize_ptr_compare(n);\n+      if (tcmp->singleton()) {\n+        Node* cmp = igvn->makecon(tcmp);\n@@ -2029,1 +2053,1 @@\n-          tty->print_cr(\"++++ Replaced: %d %s(%d,%d) --> %s\", n->_idx, (n->Opcode() == Op_CmpP ? \"CmpP\" : \"CmpN\"), n->in(1)->_idx, n->in(2)->_idx, (res == _pcmp_eq ? \"EQ\" : \"NotEQ\"));\n+          tty->print_cr(\"++++ Replaced: %d %s(%d,%d) --> %s\", n->_idx, (n->Opcode() == Op_CmpP ? \"CmpP\" : \"CmpN\"), n->in(1)->_idx, n->in(2)->_idx, (tcmp == TypeInt::CC_EQ ? \"EQ\" : \"NotEQ\"));\n@@ -2035,1 +2059,1 @@\n-        igvn->replace_node(n, res);\n+        igvn->replace_node(n, cmp);\n@@ -2038,5 +2062,0 @@\n-    \/\/ cleanup\n-    if (_pcmp_neq->outcnt() == 0)\n-      igvn->hash_delete(_pcmp_neq);\n-    if (_pcmp_eq->outcnt()  == 0)\n-      igvn->hash_delete(_pcmp_eq);\n@@ -2048,4 +2067,4 @@\n-  while (storestore_worklist.length() != 0) {\n-    Node *n = storestore_worklist.pop();\n-    MemBarStoreStoreNode *storestore = n ->as_MemBarStoreStore();\n-    Node *alloc = storestore->in(MemBarNode::Precedent)->in(0);\n+  for (int i = 0; i < storestore_worklist.length(); i++) {\n+    Node* storestore = storestore_worklist.at(i);\n+    assert(storestore->is_MemBarStoreStore(), \"\");\n+    Node* alloc = storestore->in(MemBarNode::Precedent)->in(0);\n@@ -2054,1 +2073,1 @@\n-      mb->init_req(TypeFunc::Memory, storestore->in(TypeFunc::Memory));\n+      mb->init_req(TypeFunc::Memory,  storestore->in(TypeFunc::Memory));\n@@ -2063,1 +2082,1 @@\n-Node* ConnectionGraph::optimize_ptr_compare(Node* n) {\n+const TypeInt* ConnectionGraph::optimize_ptr_compare(Node* n) {\n@@ -2065,0 +2084,4 @@\n+  const TypeInt* EQ = TypeInt::CC_EQ; \/\/ [0] == ZERO\n+  const TypeInt* NE = TypeInt::CC_GT; \/\/ [1] == ONE\n+  const TypeInt* UNKNOWN = TypeInt::CC;    \/\/ [-1, 0,1]\n+\n@@ -2077,1 +2100,1 @@\n-        return _pcmp_eq;\n+        return EQ;\n@@ -2083,1 +2106,1 @@\n-        return _pcmp_neq; \/\/ This includes nullness check.\n+        return NE; \/\/ This includes nullness check.\n@@ -2093,1 +2116,1 @@\n-        return _pcmp_neq; \/\/ This includes nullness check.\n+        return NE; \/\/ This includes nullness check.\n@@ -2106,1 +2129,1 @@\n-      return _pcmp_eq;\n+      return EQ;\n@@ -2108,1 +2131,1 @@\n-      return _pcmp_neq;\n+      return NE;\n@@ -2112,1 +2135,1 @@\n-    return NULL; \/\/ Sets are not disjoint\n+    return UNKNOWN; \/\/ Sets are not disjoint\n@@ -2123,1 +2146,1 @@\n-    return NULL;\n+    return UNKNOWN;\n@@ -2132,1 +2155,1 @@\n-      return _pcmp_neq;\n+      return NE;\n@@ -2137,1 +2160,1 @@\n-      return _pcmp_neq;\n+      return NE;\n@@ -2140,1 +2163,1 @@\n-  return NULL;\n+  return UNKNOWN;\n@@ -2143,1 +2166,1 @@\n-\/\/ Connection Graph constuction functions.\n+\/\/ Connection Graph construction functions.\n@@ -2153,1 +2176,1 @@\n-  _nodes.at_put(n->_idx, ptadr);\n+  map_ideal_node(n, ptadr);\n@@ -2164,1 +2187,1 @@\n-  _nodes.at_put(n->_idx, ptadr);\n+  map_ideal_node(n, ptadr);\n@@ -2180,1 +2203,1 @@\n-  _nodes.at_put(n->_idx, field);\n+  map_ideal_node(n, field);\n@@ -2194,1 +2217,1 @@\n-  _nodes.at_put(n->_idx, ptadr);\n+  map_ideal_node(n, ptadr);\n@@ -2331,1 +2354,1 @@\n-  if (es >= PointsToNode::GlobalEscape)\n+  if (es >= PointsToNode::GlobalEscape) {\n@@ -2333,0 +2356,1 @@\n+  }\n@@ -2339,1 +2363,1 @@\n-    if (i.get()->escape_state() >= PointsToNode::GlobalEscape)\n+    if (i.get()->escape_state() >= PointsToNode::GlobalEscape) {\n@@ -2341,0 +2365,1 @@\n+    }\n@@ -2355,1 +2380,1 @@\n-    if (i.get() == ptn)\n+    if (i.get() == ptn) {\n@@ -2357,0 +2382,1 @@\n+    }\n@@ -2375,1 +2401,1 @@\n-      if (this_e == ptn->edge(j))\n+      if (this_e == ptn->edge(j)) {\n@@ -2377,0 +2403,1 @@\n+      }\n@@ -2386,1 +2413,1 @@\n-    if (i.get() == jobj)\n+    if (i.get() == jobj) {\n@@ -2388,0 +2415,1 @@\n+    }\n@@ -2839,1 +2867,1 @@\n-      imax -= use->replace_edge(n, m);\n+      imax -= use->replace_edge(n, m, igvn);\n@@ -2874,1 +2902,1 @@\n-  if (orig_mem == NULL)\n+  if (orig_mem == NULL) {\n@@ -2876,0 +2904,1 @@\n+  }\n@@ -2885,1 +2914,1 @@\n-    if (result == start_mem)\n+    if (result == start_mem) {\n@@ -2887,0 +2916,1 @@\n+    }\n@@ -2889,1 +2919,1 @@\n-      if (at == Type::TOP)\n+      if (at == Type::TOP) {\n@@ -2891,0 +2921,1 @@\n+      }\n@@ -2893,1 +2924,1 @@\n-      if (idx == alias_idx)\n+      if (idx == alias_idx) {\n@@ -2895,0 +2926,1 @@\n+      }\n@@ -2901,1 +2933,1 @@\n-    if (!is_instance)\n+    if (!is_instance) {\n@@ -2903,0 +2935,1 @@\n+    }\n@@ -3018,1 +3051,1 @@\n-\/\/  Convert the types of unescaped object to instance types where possible,\n+\/\/  Convert the types of non-escaped object to instance types where possible,\n@@ -3046,1 +3079,1 @@\n-\/\/ results and the allocation of node 29 is unescaped and eligible to be an\n+\/\/ results and the allocation of node 29 is non-escaped and eligible to be an\n@@ -3131,2 +3164,2 @@\n-      \/\/ see if it is unescaped.\n-      if (es != PointsToNode::NoEscape || !ptn->scalar_replaceable())\n+      \/\/ see if it is non-escaped.\n+      if (es != PointsToNode::NoEscape || !ptn->scalar_replaceable()) {\n@@ -3134,0 +3167,1 @@\n+      }\n@@ -3180,1 +3214,1 @@\n-      if (t == NULL)\n+      if (t == NULL) {\n@@ -3182,1 +3216,2 @@\n-      if (!t->klass_is_exact())\n+      }\n+      if (!t->klass_is_exact()) {\n@@ -3184,1 +3219,1 @@\n-\n+      }\n@@ -3431,1 +3466,1 @@\n-    if (visited.test_set(n->_idx))\n+    if (visited.test_set(n->_idx)) {\n@@ -3433,0 +3468,1 @@\n+    }\n@@ -3438,1 +3474,1 @@\n-      if (n == NULL)\n+      if (n == NULL) {\n@@ -3440,0 +3476,1 @@\n+      }\n@@ -3452,1 +3489,1 @@\n-      if (addr_t == Type::TOP)\n+      if (addr_t == Type::TOP) {\n@@ -3454,0 +3491,1 @@\n+      }\n@@ -3480,1 +3518,1 @@\n-        if (use->Opcode() == Op_StoreCM) \/\/ Ignore cardmark stores\n+        if (use->Opcode() == Op_StoreCM) { \/\/ Ignore cardmark stores\n@@ -3482,0 +3520,1 @@\n+        }\n@@ -3536,1 +3575,1 @@\n-      if (mem == NULL || mem->is_top())\n+      if (mem == NULL || mem->is_top()) {\n@@ -3538,0 +3577,1 @@\n+      }\n@@ -3546,1 +3586,1 @@\n-            if (cur == NULL)\n+            if (cur == NULL) {\n@@ -3548,0 +3588,1 @@\n+            }\n@@ -3683,1 +3724,1 @@\n-    if (nt == PointsToNode::JavaObject && !this->scalar_replaceable())\n+    if (nt == PointsToNode::JavaObject && !this->scalar_replaceable()) {\n@@ -3685,0 +3726,1 @@\n+    }\n@@ -3688,1 +3730,1 @@\n-    if (f->is_oop())\n+    if (f->is_oop()) {\n@@ -3690,1 +3732,2 @@\n-    if (f->offset() > 0)\n+    }\n+    if (f->offset() > 0) {\n@@ -3692,0 +3735,1 @@\n+    }\n@@ -3715,1 +3759,1 @@\n-  if (_node == NULL)\n+  if (_node == NULL) {\n@@ -3717,1 +3761,1 @@\n-  else\n+  } else {\n@@ -3719,0 +3763,1 @@\n+  }\n@@ -3726,1 +3771,1 @@\n-    if (ptn == NULL || !ptn->is_JavaObject())\n+    if (ptn == NULL || !ptn->is_JavaObject()) {\n@@ -3728,0 +3773,1 @@\n+    }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":211,"deletions":165,"binary":false,"changes":376,"status":"modified"},{"patch":"@@ -4633,1 +4633,1 @@\n-  Node* res_mem = _gvn.transform(new SCMemProjNode(str));\n+  Node* res_mem = _gvn.transform(new SCMemProjNode(_gvn.transform(str)));\n@@ -4655,0 +4655,2 @@\n+  C->set_has_loops(true);\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1131,1 +1131,1 @@\n-              int rep = clone->replace_edge(init_n, new_n);\n+              int rep = clone->replace_edge(init_n, new_n, igvn);\n@@ -1138,1 +1138,1 @@\n-            int rep = use->replace_edge(init_n, new_n);\n+            int rep = use->replace_edge(init_n, new_n, igvn);\n@@ -1384,1 +1384,1 @@\n-  iff->set_req(1, new_bol);\n+  iff->set_req_X(1, new_bol, phase);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-  return sfpt->replace_edges_in_range(this, sobj, jvms->debug_start(), jvms->debug_end());\n+  return sfpt->replace_edges_in_range(this, sobj, jvms->debug_start(), jvms->debug_end(), igvn);\n@@ -234,1 +234,1 @@\n-        nb = sfpt->replace_edges_in_range(this, get_oop(), sfpt->jvms()->debug_start(), sfpt->jvms()->debug_end());\n+        nb = sfpt->replace_edges_in_range(this, get_oop(), sfpt->jvms()->debug_start(), sfpt->jvms()->debug_end(), igvn);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1418,1 +1418,1 @@\n-  for(uint i4 = 0; i4 < block->_num_succs; i4++ ) {\n+  for (uint i4 = 0; i4 < block->_num_succs; i4++) {\n@@ -1421,2 +1421,4 @@\n-    \/\/ Remove any newly created, but dead, nodes.\n-    for( uint j = new_cnt; j > 0; j-- ) {\n+    \/\/ Remove any newly created, but dead, nodes by traversing their schedule\n+    \/\/ backwards. Here, a dead node is a node whose only outputs (if any) are\n+    \/\/ unused projections.\n+    for (uint j = new_cnt; j > 0; j--) {\n@@ -1424,2 +1426,26 @@\n-      if (n->outcnt() == 0 &&\n-          (!n->is_Proj() || n->as_Proj()->in(0)->outcnt() == 1) ){\n+      \/\/ Individual projections are examined together with all siblings when\n+      \/\/ their parent is visited.\n+      if (n->is_Proj()) {\n+        continue;\n+      }\n+      bool dead = true;\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        Node* out = n->fast_out(i);\n+        \/\/ n is live if it has a non-projection output or a used projection.\n+        if (!out->is_Proj() || out->outcnt() > 0) {\n+          dead = false;\n+          break;\n+        }\n+      }\n+      if (dead) {\n+        \/\/ n's only outputs (if any) are unused projections scheduled next to n\n+        \/\/ (see PhaseCFG::select()). Remove these projections backwards.\n+        for (uint k = j + n->outcnt(); k > j; k--) {\n+          Node* proj = sb->get_node(k);\n+          assert(proj->is_Proj() && proj->in(0) == n,\n+                 \"projection should correspond to dead node\");\n+          proj->disconnect_inputs(C);\n+          sb->remove_node(k);\n+          new_cnt--;\n+        }\n+        \/\/ Now remove the node itself.\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-#include \"prims\/nativeLookup.hpp\"\n@@ -1281,1 +1280,1 @@\n-  AllocateArrayNode* alloc = tightly_coupled_allocation(dst, NULL);\n+  AllocateArrayNode* alloc = tightly_coupled_allocation(dst);\n@@ -1398,1 +1397,2 @@\n-    AllocateArrayNode* alloc = tightly_coupled_allocation(newcopy, NULL);\n+    AllocateArrayNode* alloc = tightly_coupled_allocation(newcopy);\n+    guarantee(alloc != NULL, \"created above\");\n@@ -1416,19 +1416,7 @@\n-    if (alloc != NULL) {\n-      if (alloc->maybe_set_complete(&_gvn)) {\n-        \/\/ \"You break it, you buy it.\"\n-        InitializeNode* init = alloc->initialization();\n-        assert(init->is_complete(), \"we just did this\");\n-        init->set_complete_with_arraycopy();\n-        assert(newcopy->is_CheckCastPP(), \"sanity\");\n-        assert(newcopy->in(0)->in(0) == init, \"dest pinned\");\n-      }\n-      \/\/ Do not let stores that initialize this object be reordered with\n-      \/\/ a subsequent store that would make this object accessible by\n-      \/\/ other threads.\n-      \/\/ Record what AllocateNode this StoreStore protects so that\n-      \/\/ escape analysis can go from the MemBarStoreStoreNode to the\n-      \/\/ AllocateNode and eliminate the MemBarStoreStoreNode if possible\n-      \/\/ based on the escape status of the AllocateNode.\n-      insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n-    } else {\n-      insert_mem_bar(Op_MemBarCPUOrder);\n+    if (alloc->maybe_set_complete(&_gvn)) {\n+      \/\/ \"You break it, you buy it.\"\n+      InitializeNode* init = alloc->initialization();\n+      assert(init->is_complete(), \"we just did this\");\n+      init->set_complete_with_arraycopy();\n+      assert(newcopy->is_CheckCastPP(), \"sanity\");\n+      assert(newcopy->in(0)->in(0) == init, \"dest pinned\");\n@@ -1436,0 +1424,8 @@\n+    \/\/ Do not let stores that initialize this object be reordered with\n+    \/\/ a subsequent store that would make this object accessible by\n+    \/\/ other threads.\n+    \/\/ Record what AllocateNode this StoreStore protects so that\n+    \/\/ escape analysis can go from the MemBarStoreStoreNode to the\n+    \/\/ AllocateNode and eliminate the MemBarStoreStoreNode if possible\n+    \/\/ based on the escape status of the AllocateNode.\n+    insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n@@ -1463,1 +1459,1 @@\n-  AllocateArrayNode* alloc = tightly_coupled_allocation(dst, NULL);\n+  AllocateArrayNode* alloc = tightly_coupled_allocation(dst);\n@@ -4465,2 +4461,2 @@\n-            Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);\n-            ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);\n+            \/\/ Clones are always tightly coupled.\n+            ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, true, false);\n@@ -4714,1 +4710,1 @@\n-  AllocateArrayNode* alloc = tightly_coupled_allocation(dest, NULL);\n+  AllocateArrayNode* alloc = tightly_coupled_allocation(dest);\n@@ -4750,1 +4746,1 @@\n-    alloc = tightly_coupled_allocation(dest, NULL);\n+    alloc = tightly_coupled_allocation(dest);\n@@ -4987,2 +4983,1 @@\n-LibraryCallKit::tightly_coupled_allocation(Node* ptr,\n-                                           RegionNode* slow_region) {\n+LibraryCallKit::tightly_coupled_allocation(Node* ptr) {\n@@ -5026,4 +5021,0 @@\n-      if (slow_region != NULL && slow_region->find_edge(not_ctl) >= 1) {\n-        ctl = iff->in(0);       \/\/ This test feeds the known slow_region.\n-        continue;\n-      }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":24,"deletions":33,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -287,2 +287,1 @@\n-  AllocateArrayNode* tightly_coupled_allocation(Node* ptr,\n-                                                RegionNode* slow_region);\n+  AllocateArrayNode* tightly_coupled_allocation(Node* ptr);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,18 +64,19 @@\n-         MainHasNoPreLoop=4,\n-         HasExactTripCount=8,\n-         InnerLoop=16,\n-         PartialPeelLoop=32,\n-         PartialPeelFailed=64,\n-         HasReductions=128,\n-         WasSlpAnalyzed=256,\n-         PassedSlpAnalysis=512,\n-         DoUnrollOnly=1024,\n-         VectorizedLoop=2048,\n-         HasAtomicPostLoop=4096,\n-         HasRangeChecks=8192,\n-         IsMultiversioned=16384,\n-         StripMined=32768,\n-         SubwordLoop=65536,\n-         ProfileTripFailed=131072,\n-         TransformedLongLoop=262144,\n-         FlattenedArrays=524288};\n+         MainHasNoPreLoop    = 1<<2,\n+         HasExactTripCount   = 1<<3,\n+         InnerLoop           = 1<<4,\n+         PartialPeelLoop     = 1<<5,\n+         PartialPeelFailed   = 1<<6,\n+         HasReductions       = 1<<7,\n+         WasSlpAnalyzed      = 1<<8,\n+         PassedSlpAnalysis   = 1<<9,\n+         DoUnrollOnly        = 1<<10,\n+         VectorizedLoop      = 1<<11,\n+         HasAtomicPostLoop   = 1<<12,\n+         HasRangeChecks      = 1<<13,\n+         IsMultiversioned    = 1<<14,\n+         StripMined          = 1<<15,\n+         SubwordLoop         = 1<<16,\n+         ProfileTripFailed   = 1<<17,\n+         TransformedLongInnerLoop = 1<<18,\n+         TransformedLongOuterLoop = 1<<19,\n+         FlattenedArrays     = 1<<20};\n@@ -106,1 +107,2 @@\n-  bool is_transformed_long_loop() const { return _loop_flags & TransformedLongLoop; }\n+  bool is_transformed_long_inner_loop() const { return _loop_flags & TransformedLongInnerLoop; }\n+  bool is_transformed_long_outer_loop() const { return _loop_flags & TransformedLongOuterLoop; }\n@@ -122,1 +124,2 @@\n-  void mark_transformed_long_loop() { _loop_flags |= TransformedLongLoop; }\n+  void mark_transformed_long_inner_loop() { _loop_flags |= TransformedLongInnerLoop; }\n+  void mark_transformed_long_outer_loop() { _loop_flags |= TransformedLongOuterLoop; }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -934,1 +934,1 @@\n-            int count = phi->replace_edge(n, hook);\n+            int count = phi->replace_edge(n, hook, &_igvn);\n@@ -1109,1 +1109,1 @@\n-  if (((n_blk->is_CountedLoop() || (n_blk->is_Loop() && n_blk->as_Loop()->is_transformed_long_loop())) && n->Opcode() == Op_AddI) ||\n+  if (((n_blk->is_CountedLoop() || (n_blk->is_Loop() && n_blk->as_Loop()->is_transformed_long_inner_loop())) && n->Opcode() == Op_AddI) ||\n@@ -1645,1 +1645,1 @@\n-                if (is_dominator(n_ctrl, x_head)) {\n+                if (is_dominator(n_ctrl, x_head) && n_ctrl != x_head) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -107,0 +107,6 @@\n+  KRegister  as_KRegister(PhaseRegAlloc *ra_, const Node *node)   const {\n+    return ::as_KRegister(reg(ra_, node));\n+  }\n+  KRegister  as_KRegister(PhaseRegAlloc *ra_, const Node *node, int idx)   const {\n+    return ::as_KRegister(reg(ra_, node, idx));\n+  }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -150,55 +150,0 @@\n-void PhaseMacroExpand::extract_call_projections(CallNode *call) {\n-  _fallthroughproj = NULL;\n-  _fallthroughcatchproj = NULL;\n-  _ioproj_fallthrough = NULL;\n-  _ioproj_catchall = NULL;\n-  _catchallcatchproj = NULL;\n-  _memproj_fallthrough = NULL;\n-  _memproj_catchall = NULL;\n-  _resproj = NULL;\n-  for (DUIterator_Fast imax, i = call->fast_outs(imax); i < imax; i++) {\n-    ProjNode *pn = call->fast_out(i)->as_Proj();\n-    switch (pn->_con) {\n-      case TypeFunc::Control:\n-      {\n-        \/\/ For Control (fallthrough) and I_O (catch_all_index) we have CatchProj -> Catch -> Proj\n-        _fallthroughproj = pn;\n-        DUIterator_Fast jmax, j = pn->fast_outs(jmax);\n-        const Node *cn = pn->fast_out(j);\n-        if (cn->is_Catch()) {\n-          ProjNode *cpn = NULL;\n-          for (DUIterator_Fast kmax, k = cn->fast_outs(kmax); k < kmax; k++) {\n-            cpn = cn->fast_out(k)->as_Proj();\n-            assert(cpn->is_CatchProj(), \"must be a CatchProjNode\");\n-            if (cpn->_con == CatchProjNode::fall_through_index)\n-              _fallthroughcatchproj = cpn;\n-            else {\n-              assert(cpn->_con == CatchProjNode::catch_all_index, \"must be correct index.\");\n-              _catchallcatchproj = cpn;\n-            }\n-          }\n-        }\n-        break;\n-      }\n-      case TypeFunc::I_O:\n-        if (pn->_is_io_use)\n-          _ioproj_catchall = pn;\n-        else\n-          _ioproj_fallthrough = pn;\n-        break;\n-      case TypeFunc::Memory:\n-        if (pn->_is_io_use)\n-          _memproj_catchall = pn;\n-        else\n-          _memproj_fallthrough = pn;\n-        break;\n-      case TypeFunc::Parms:\n-        _resproj = pn;\n-        break;\n-      default:\n-        assert(false, \"unexpected projection from allocation node.\");\n-    }\n-  }\n-\n-}\n-\n@@ -245,0 +190,3 @@\n+#ifdef ASSERT\n+        in->dump();\n+        mem->dump();\n@@ -246,0 +194,1 @@\n+#endif\n@@ -256,1 +205,1 @@\n-        if (adr_offset == offset && adr_iid == alloc->_idx)\n+        if (adr_offset == offset && adr_iid == alloc->_idx) {\n@@ -258,0 +207,1 @@\n+        }\n@@ -271,1 +221,1 @@\n-        if (init != NULL)\n+        if (init != NULL) {\n@@ -273,1 +223,1 @@\n-        else\n+        } else {\n@@ -275,0 +225,1 @@\n+        }\n@@ -491,2 +442,1 @@\n-#ifdef ASSERT\n-        val->dump();\n+        DEBUG_ONLY( val->dump(); )\n@@ -494,1 +444,0 @@\n-#endif\n@@ -570,0 +519,1 @@\n+      DEBUG_ONLY( mem->dump(); )\n@@ -987,1 +937,1 @@\n-    sfpt->replace_edges_in_range(res, sobj, start, end);\n+    sfpt->replace_edges_in_range(res, sobj, start, end, &_igvn);\n@@ -1070,1 +1020,1 @@\n-          ac->replace_edge(res, top());\n+          ac->replace_edge(res, top(), &_igvn);\n@@ -1075,1 +1025,1 @@\n-          ac->replace_edge(src, top());\n+          ac->replace_edge(src, top(), &_igvn);\n@@ -1109,1 +1059,1 @@\n-  if (_resproj != NULL && _resproj->outcnt() != 0) {\n+  if (_callprojs->resproj[0] != NULL && _callprojs->resproj[0]->outcnt() != 0) {\n@@ -1113,2 +1063,2 @@\n-    for (DUIterator_Fast jmax, j = _resproj->fast_outs(jmax);  j < jmax; j++) {\n-      Node *use = _resproj->fast_out(j);\n+    for (DUIterator_Fast jmax, j = _callprojs->resproj[0]->fast_outs(jmax);  j < jmax; j++) {\n+      Node* use = _callprojs->resproj[0]->fast_out(j);\n@@ -1121,3 +1071,3 @@\n-    for (DUIterator_Last jmin, j = _resproj->last_outs(jmin); j >= jmin; ) {\n-      Node *use = _resproj->last_out(j);\n-      uint oc1 = _resproj->outcnt();\n+    for (DUIterator_Last jmin, j = _callprojs->resproj[0]->last_outs(jmin); j >= jmin; ) {\n+      Node* use = _callprojs->resproj[0]->last_out(j);\n+      uint oc1 = _callprojs->resproj[0]->outcnt();\n@@ -1138,1 +1088,1 @@\n-          assert(tmp == _fallthroughcatchproj, \"allocation control projection\");\n+          assert(tmp == _callprojs->fallthrough_catchproj, \"allocation control projection\");\n@@ -1146,1 +1096,1 @@\n-            assert(mem->in(TypeFunc::Memory) == _memproj_fallthrough, \"allocation memory projection\");\n+            assert(mem->in(TypeFunc::Memory) == _callprojs->fallthrough_memproj, \"allocation memory projection\");\n@@ -1148,1 +1098,1 @@\n-            assert(mem == _memproj_fallthrough, \"allocation memory projection\");\n+            assert(mem == _callprojs->fallthrough_memproj, \"allocation memory projection\");\n@@ -1160,1 +1110,1 @@\n-      j -= (oc1 - _resproj->outcnt());\n+      j -= (oc1 - _callprojs->resproj[0]->outcnt());\n@@ -1163,2 +1113,2 @@\n-  if (_fallthroughcatchproj != NULL) {\n-    _igvn.replace_node(_fallthroughcatchproj, alloc->in(TypeFunc::Control));\n+  if (_callprojs->fallthrough_catchproj != NULL) {\n+    _igvn.replace_node(_callprojs->fallthrough_catchproj, alloc->in(TypeFunc::Control));\n@@ -1166,2 +1116,2 @@\n-  if (_memproj_fallthrough != NULL) {\n-    _igvn.replace_node(_memproj_fallthrough, alloc->in(TypeFunc::Memory));\n+  if (_callprojs->fallthrough_memproj != NULL) {\n+    _igvn.replace_node(_callprojs->fallthrough_memproj, alloc->in(TypeFunc::Memory));\n@@ -1169,2 +1119,2 @@\n-  if (_memproj_catchall != NULL) {\n-    _igvn.replace_node(_memproj_catchall, C->top());\n+  if (_callprojs->catchall_memproj != NULL) {\n+    _igvn.replace_node(_callprojs->catchall_memproj, C->top());\n@@ -1172,2 +1122,2 @@\n-  if (_ioproj_fallthrough != NULL) {\n-    _igvn.replace_node(_ioproj_fallthrough, alloc->in(TypeFunc::I_O));\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    _igvn.replace_node(_callprojs->fallthrough_ioproj, alloc->in(TypeFunc::I_O));\n@@ -1175,2 +1125,2 @@\n-  if (_ioproj_catchall != NULL) {\n-    _igvn.replace_node(_ioproj_catchall, C->top());\n+  if (_callprojs->catchall_ioproj != NULL) {\n+    _igvn.replace_node(_callprojs->catchall_ioproj, C->top());\n@@ -1178,2 +1128,2 @@\n-  if (_catchallcatchproj != NULL) {\n-    _igvn.replace_node(_catchallcatchproj, C->top());\n+  if (_callprojs->catchall_catchproj != NULL) {\n+    _igvn.replace_node(_callprojs->catchall_catchproj, C->top());\n@@ -1211,1 +1161,1 @@\n-  extract_call_projections(alloc);\n+  _callprojs = alloc->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -1267,1 +1217,1 @@\n-  extract_call_projections(boxing);\n+  _callprojs = boxing->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -1601,1 +1551,1 @@\n-  extract_call_projections(call);\n+  _callprojs = call->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -1607,9 +1557,9 @@\n-  if (expand_fast_path && _memproj_fallthrough != NULL) {\n-    _igvn.replace_in_uses(_memproj_fallthrough, result_phi_rawmem);\n-  }\n-  \/\/ Now change uses of _memproj_catchall to use _memproj_fallthrough and delete\n-  \/\/ _memproj_catchall so we end up with a call that has only 1 memory projection.\n-  if (_memproj_catchall != NULL) {\n-    if (_memproj_fallthrough == NULL) {\n-      _memproj_fallthrough = new ProjNode(call, TypeFunc::Memory);\n-      transform_later(_memproj_fallthrough);\n+  if (expand_fast_path && _callprojs->fallthrough_memproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_memproj, result_phi_rawmem);\n+  }\n+  \/\/ Now change uses of catchall_memproj to use fallthrough_memproj and delete\n+  \/\/ catchall_memproj so we end up with a call that has only 1 memory projection.\n+  if (_callprojs->catchall_memproj != NULL) {\n+    if (_callprojs->fallthrough_memproj == NULL) {\n+      _callprojs->fallthrough_memproj = new ProjNode(call, TypeFunc::Memory);\n+      transform_later(_callprojs->fallthrough_memproj);\n@@ -1617,2 +1567,2 @@\n-    _igvn.replace_in_uses(_memproj_catchall, _memproj_fallthrough);\n-    _igvn.remove_dead_node(_memproj_catchall);\n+    _igvn.replace_in_uses(_callprojs->catchall_memproj, _callprojs->fallthrough_memproj);\n+    _igvn.remove_dead_node(_callprojs->catchall_memproj);\n@@ -1626,9 +1576,9 @@\n-  if (_ioproj_fallthrough != NULL) {\n-    _igvn.replace_in_uses(_ioproj_fallthrough, result_phi_i_o);\n-  }\n-  \/\/ Now change uses of _ioproj_catchall to use _ioproj_fallthrough and delete\n-  \/\/ _ioproj_catchall so we end up with a call that has only 1 i_o projection.\n-  if (_ioproj_catchall != NULL) {\n-    if (_ioproj_fallthrough == NULL) {\n-      _ioproj_fallthrough = new ProjNode(call, TypeFunc::I_O);\n-      transform_later(_ioproj_fallthrough);\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_ioproj, result_phi_i_o);\n+  }\n+  \/\/ Now change uses of catchall_ioproj to use fallthrough_ioproj and delete\n+  \/\/ catchall_ioproj so we end up with a call that has only 1 i_o projection.\n+  if (_callprojs->catchall_ioproj != NULL) {\n+    if (_callprojs->fallthrough_ioproj == NULL) {\n+      _callprojs->fallthrough_ioproj = new ProjNode(call, TypeFunc::I_O);\n+      transform_later(_callprojs->fallthrough_ioproj);\n@@ -1636,2 +1586,2 @@\n-    _igvn.replace_in_uses(_ioproj_catchall, _ioproj_fallthrough);\n-    _igvn.remove_dead_node(_ioproj_catchall);\n+    _igvn.replace_in_uses(_callprojs->catchall_ioproj, _callprojs->fallthrough_ioproj);\n+    _igvn.remove_dead_node(_callprojs->catchall_ioproj);\n@@ -1656,2 +1606,2 @@\n-  if (_fallthroughcatchproj != NULL) {\n-    ctrl = _fallthroughcatchproj->clone();\n+  if (_callprojs->fallthrough_catchproj != NULL) {\n+    ctrl = _callprojs->fallthrough_catchproj->clone();\n@@ -1659,1 +1609,1 @@\n-    _igvn.replace_node(_fallthroughcatchproj, result_region);\n+    _igvn.replace_node(_callprojs->fallthrough_catchproj, result_region);\n@@ -1664,1 +1614,1 @@\n-  if (_resproj == NULL) {\n+  if (_callprojs->resproj[0] == NULL) {\n@@ -1668,1 +1618,1 @@\n-    slow_result = _resproj->clone();\n+    slow_result = _callprojs->resproj[0]->clone();\n@@ -1670,1 +1620,1 @@\n-    _igvn.replace_node(_resproj, result_phi_rawoop);\n+    _igvn.replace_node(_callprojs->resproj[0], result_phi_rawoop);\n@@ -1680,1 +1630,1 @@\n-  result_phi_rawmem->init_req(slow_result_path, _memproj_fallthrough);\n+  result_phi_rawmem->init_req(slow_result_path, _callprojs->fallthrough_memproj);\n@@ -1692,4 +1642,4 @@\n-  extract_call_projections(alloc);\n-  if (_resproj != NULL) {\n-    for (DUIterator_Fast imax, i = _resproj->fast_outs(imax); i < imax; i++) {\n-      Node* use = _resproj->fast_out(i);\n+  _callprojs = alloc->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  if (_callprojs->resproj[0] != NULL) {\n+    for (DUIterator_Fast imax, i = _callprojs->resproj[0]->fast_outs(imax); i < imax; i++) {\n+      Node* use = _callprojs->resproj[0]->fast_out(i);\n@@ -1700,2 +1650,2 @@\n-    assert(_resproj->outcnt() == 0, \"all uses must be deleted\");\n-    _igvn.remove_dead_node(_resproj);\n+    assert(_callprojs->resproj[0]->outcnt() == 0, \"all uses must be deleted\");\n+    _igvn.remove_dead_node(_callprojs->resproj[0]);\n@@ -1703,3 +1653,3 @@\n-  if (_fallthroughcatchproj != NULL) {\n-    _igvn.replace_in_uses(_fallthroughcatchproj, ctrl);\n-    _igvn.remove_dead_node(_fallthroughcatchproj);\n+  if (_callprojs->fallthrough_catchproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_catchproj, ctrl);\n+    _igvn.remove_dead_node(_callprojs->fallthrough_catchproj);\n@@ -1707,3 +1657,3 @@\n-  if (_catchallcatchproj != NULL) {\n-    _igvn.rehash_node_delayed(_catchallcatchproj);\n-    _catchallcatchproj->set_req(0, top());\n+  if (_callprojs->catchall_catchproj != NULL) {\n+    _igvn.rehash_node_delayed(_callprojs->catchall_catchproj);\n+    _callprojs->catchall_catchproj->set_req(0, top());\n@@ -1711,2 +1661,2 @@\n-  if (_fallthroughproj != NULL) {\n-    Node* catchnode = _fallthroughproj->unique_ctrl_out();\n+  if (_callprojs->fallthrough_proj != NULL) {\n+    Node* catchnode = _callprojs->fallthrough_proj->unique_ctrl_out();\n@@ -1714,1 +1664,1 @@\n-    _igvn.remove_dead_node(_fallthroughproj);\n+    _igvn.remove_dead_node(_callprojs->fallthrough_proj);\n@@ -1716,3 +1666,3 @@\n-  if (_memproj_fallthrough != NULL) {\n-    _igvn.replace_in_uses(_memproj_fallthrough, mem);\n-    _igvn.remove_dead_node(_memproj_fallthrough);\n+  if (_callprojs->fallthrough_memproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_memproj, mem);\n+    _igvn.remove_dead_node(_callprojs->fallthrough_memproj);\n@@ -1720,3 +1670,3 @@\n-  if (_ioproj_fallthrough != NULL) {\n-    _igvn.replace_in_uses(_ioproj_fallthrough, i_o);\n-    _igvn.remove_dead_node(_ioproj_fallthrough);\n+  if (_callprojs->fallthrough_ioproj != NULL) {\n+    _igvn.replace_in_uses(_callprojs->fallthrough_ioproj, i_o);\n+    _igvn.remove_dead_node(_callprojs->fallthrough_ioproj);\n@@ -1724,3 +1674,3 @@\n-  if (_memproj_catchall != NULL) {\n-    _igvn.rehash_node_delayed(_memproj_catchall);\n-    _memproj_catchall->set_req(0, top());\n+  if (_callprojs->catchall_memproj != NULL) {\n+    _igvn.rehash_node_delayed(_callprojs->catchall_memproj);\n+    _callprojs->catchall_memproj->set_req(0, top());\n@@ -1728,3 +1678,3 @@\n-  if (_ioproj_catchall != NULL) {\n-    _igvn.rehash_node_delayed(_ioproj_catchall);\n-    _ioproj_catchall->set_req(0, top());\n+  if (_callprojs->catchall_ioproj != NULL) {\n+    _igvn.rehash_node_delayed(_callprojs->catchall_ioproj);\n+    _callprojs->catchall_ioproj->set_req(0, top());\n@@ -2333,1 +2283,1 @@\n-  extract_call_projections(alock);\n+  _callprojs = alock->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -2337,2 +2287,2 @@\n-         _fallthroughproj != NULL &&\n-         _memproj_fallthrough != NULL,\n+         _callprojs->fallthrough_proj != NULL &&\n+         _callprojs->fallthrough_memproj != NULL,\n@@ -2341,2 +2291,2 @@\n-  Node* fallthroughproj = _fallthroughproj;\n-  Node* memproj_fallthrough = _memproj_fallthrough;\n+  Node* fallthroughproj = _callprojs->fallthrough_proj;\n+  Node* memproj_fallthrough = _callprojs->fallthrough_memproj;\n@@ -2602,1 +2552,1 @@\n-  extract_call_projections(call);\n+  _callprojs = call->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -2608,2 +2558,2 @@\n-  assert ( _ioproj_fallthrough == NULL && _ioproj_catchall == NULL &&\n-           _memproj_catchall == NULL && _catchallcatchproj == NULL, \"Unexpected projection from Lock\");\n+  assert(_callprojs->fallthrough_ioproj == NULL && _callprojs->catchall_ioproj == NULL &&\n+         _callprojs->catchall_memproj == NULL && _callprojs->catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n@@ -2614,1 +2564,1 @@\n-  Node *slow_ctrl = _fallthroughproj->clone();\n+  Node *slow_ctrl = _callprojs->fallthrough_proj->clone();\n@@ -2616,2 +2566,2 @@\n-  _igvn.hash_delete(_fallthroughproj);\n-  _fallthroughproj->disconnect_inputs(C);\n+  _igvn.hash_delete(_callprojs->fallthrough_proj);\n+  _callprojs->fallthrough_proj->disconnect_inputs(C);\n@@ -2621,1 +2571,1 @@\n-  _igvn.replace_node(_fallthroughproj, region);\n+  _igvn.replace_node(_callprojs->fallthrough_proj, region);\n@@ -2626,1 +2576,1 @@\n-  _igvn.replace_node(_memproj_fallthrough, mem_phi);\n+  _igvn.replace_node(_callprojs->fallthrough_memproj, mem_phi);\n@@ -2673,4 +2623,3 @@\n-  extract_call_projections(call);\n-\n-  assert ( _ioproj_fallthrough == NULL && _ioproj_catchall == NULL &&\n-           _memproj_catchall == NULL && _catchallcatchproj == NULL, \"Unexpected projection from Lock\");\n+  _callprojs = call->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  assert(_callprojs->fallthrough_ioproj == NULL && _callprojs->catchall_ioproj == NULL &&\n+         _callprojs->catchall_memproj == NULL && _callprojs->catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n@@ -2682,1 +2631,1 @@\n-  Node *slow_ctrl = _fallthroughproj->clone();\n+  Node *slow_ctrl = _callprojs->fallthrough_proj->clone();\n@@ -2684,2 +2633,2 @@\n-  _igvn.hash_delete(_fallthroughproj);\n-  _fallthroughproj->disconnect_inputs(C);\n+  _igvn.hash_delete(_callprojs->fallthrough_proj);\n+  _callprojs->fallthrough_proj->disconnect_inputs(C);\n@@ -2689,1 +2638,1 @@\n-  _igvn.replace_node(_fallthroughproj, region);\n+  _igvn.replace_node(_callprojs->fallthrough_proj, region);\n@@ -2695,1 +2644,1 @@\n-  _igvn.replace_node(_memproj_fallthrough, mem_phi);\n+  _igvn.replace_node(_callprojs->fallthrough_memproj, mem_phi);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":116,"deletions":167,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,8 +85,1 @@\n-  ProjNode *_fallthroughproj;\n-  ProjNode *_fallthroughcatchproj;\n-  ProjNode *_ioproj_fallthrough;\n-  ProjNode *_ioproj_catchall;\n-  ProjNode *_catchallcatchproj;\n-  ProjNode *_memproj_fallthrough;\n-  ProjNode *_memproj_catchall;\n-  ProjNode *_resproj;\n+  CallProjections* _callprojs;\n@@ -216,1 +209,0 @@\n-  void extract_call_projections(CallNode *call);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  Node* mask_gen =  new VectorMaskGenNode(length, TypeLong::LONG, Type::get_const_basic_type(type));\n+  Node* mask_gen =  new VectorMaskGenNode(length, TypeVect::VECTMASK, Type::get_const_basic_type(type));\n@@ -449,1 +449,3 @@\n-  bool  dest_uninitialized = false;\n+  Node* original_dest = dest;\n+  bool  dest_needs_zeroing   = false;\n+  bool  acopy_to_uninitialized = false;\n@@ -458,16 +460,29 @@\n-  if (can_try_zeroing_elimination(alloc, src, dest) &&\n-      basic_elem_type != T_CONFLICT \/* avoid corner case *\/) {\n-    \/\/ \"You break it, you buy it.\"\n-    InitializeNode* init = alloc->initialization();\n-    assert(init->is_complete(), \"we just did this\");\n-    init->set_complete_with_arraycopy();\n-    assert(dest->is_CheckCastPP(), \"sanity\");\n-    assert(dest->in(0)->in(0) == init, \"dest pinned\");\n-    adr_type = TypeRawPtr::BOTTOM;  \/\/ all initializations are into raw memory\n-    \/\/ From this point on, every exit path is responsible for\n-    \/\/ initializing any non-copied parts of the object to zero.\n-    \/\/ Also, if this flag is set we make sure that arraycopy interacts properly\n-    \/\/ with G1, eliding pre-barriers. See CR 6627983.\n-    dest_uninitialized = true;\n-    default_value = alloc->in(AllocateNode::DefaultValue);\n-    raw_default_value = alloc->in(AllocateNode::RawDefaultValue);\n+  if (ReduceBulkZeroing\n+      && !(UseTLAB && ZeroTLAB) \/\/ pointless if already zeroed\n+      && basic_elem_type != T_CONFLICT \/\/ avoid corner case\n+      && !src->eqv_uncast(dest)\n+      && alloc != NULL\n+      && _igvn.find_int_con(alloc->in(AllocateNode::ALength), 1) > 0) {\n+    assert(ac->is_alloc_tightly_coupled(), \"sanity\");\n+    \/\/ acopy to uninitialized tightly coupled allocations\n+    \/\/ needs zeroing outside the copy range\n+    \/\/ and the acopy itself will be to uninitialized memory\n+    acopy_to_uninitialized = true;\n+    if (alloc->maybe_set_complete(&_igvn)) {\n+      \/\/ \"You break it, you buy it.\"\n+      InitializeNode* init = alloc->initialization();\n+      assert(init->is_complete(), \"we just did this\");\n+      init->set_complete_with_arraycopy();\n+      assert(dest->is_CheckCastPP(), \"sanity\");\n+      assert(dest->in(0)->in(0) == init, \"dest pinned\");\n+      adr_type = TypeRawPtr::BOTTOM;  \/\/ all initializations are into raw memory\n+      \/\/ From this point on, every exit path is responsible for\n+      \/\/ initializing any non-copied parts of the object to zero.\n+      \/\/ Also, if this flag is set we make sure that arraycopy interacts properly\n+      \/\/ with G1, eliding pre-barriers. See CR 6627983.\n+      dest_needs_zeroing = true;\n+      default_value = alloc->in(AllocateNode::DefaultValue);\n+      raw_default_value = alloc->in(AllocateNode::RawDefaultValue);\n+    } else {\n+      \/\/ dest_need_zeroing = false;\n+    }\n@@ -475,2 +490,5 @@\n-    \/\/ No zeroing elimination here.\n-    alloc             = NULL;\n+    \/\/ No zeroing elimination needed here.\n+    alloc                  = NULL;\n+    acopy_to_uninitialized = false;\n+    \/\/original_dest        = dest;\n+    \/\/dest_needs_zeroing   = false;\n@@ -510,1 +528,1 @@\n-    assert(!dest_uninitialized, \"\");\n+    assert(!dest_needs_zeroing, \"\");\n@@ -514,1 +532,1 @@\n-                                          copy_length, dest_uninitialized);\n+                                          copy_length, acopy_to_uninitialized);\n@@ -535,1 +553,1 @@\n-    if (dest_uninitialized) {\n+    if (dest_needs_zeroing) {\n@@ -571,1 +589,1 @@\n-  if (!(*ctrl)->is_top() && dest_uninitialized) {\n+  if (!(*ctrl)->is_top() && dest_needs_zeroing) {\n@@ -613,1 +631,1 @@\n-                                         dest_size, dest_uninitialized);\n+                                         dest_size, acopy_to_uninitialized);\n@@ -705,1 +723,1 @@\n-                                                ConvI2X(copy_length), dest_uninitialized);\n+                                                ConvI2X(copy_length), acopy_to_uninitialized);\n@@ -730,1 +748,0 @@\n-\n@@ -734,1 +751,1 @@\n-                                                         ConvI2X(copy_length), dest_uninitialized);\n+                                                         ConvI2X(copy_length), acopy_to_uninitialized);\n@@ -823,1 +840,1 @@\n-    if (dest_uninitialized) {\n+    if (dest_needs_zeroing) {\n@@ -893,3 +910,3 @@\n-  _igvn.replace_node(_memproj_fallthrough, out_mem);\n-  _igvn.replace_node(_ioproj_fallthrough, *io);\n-  _igvn.replace_node(_fallthroughcatchproj, *ctrl);\n+  _igvn.replace_node(_callprojs->fallthrough_memproj, out_mem);\n+  _igvn.replace_node(_callprojs->fallthrough_ioproj, *io);\n+  _igvn.replace_node(_callprojs->fallthrough_catchproj, *ctrl);\n@@ -1150,2 +1167,2 @@\n-  extract_call_projections(call);\n-  *ctrl = _fallthroughcatchproj->clone();\n+  _callprojs = call->extract_projections(false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  *ctrl = _callprojs->fallthrough_catchproj->clone();\n@@ -1154,1 +1171,1 @@\n-  Node* m = _memproj_fallthrough->clone();\n+  Node* m = _callprojs->fallthrough_memproj->clone();\n@@ -1167,1 +1184,1 @@\n-  *io = _ioproj_fallthrough->clone();\n+  *io = _callprojs->fallthrough_ioproj->clone();\n@@ -1480,3 +1497,3 @@\n-    _igvn.replace_node(_memproj_fallthrough, merge_mem);\n-    _igvn.replace_node(_ioproj_fallthrough, io);\n-    _igvn.replace_node(_fallthroughcatchproj, ctrl);\n+    _igvn.replace_node(_callprojs->fallthrough_memproj, merge_mem);\n+    _igvn.replace_node(_callprojs->fallthrough_ioproj, io);\n+    _igvn.replace_node(_callprojs->fallthrough_catchproj, ctrl);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":56,"deletions":39,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,1 @@\n+  idealreg2spillmask  [Op_RegVectMask] = NULL;\n@@ -112,0 +113,1 @@\n+  idealreg2debugmask  [Op_RegVectMask] = NULL;\n@@ -126,0 +128,1 @@\n+  idealreg2mhdebugmask[Op_RegVectMask] = NULL;\n@@ -468,1 +471,1 @@\n-#define NOF_STACK_MASKS (3*12)\n+#define NOF_STACK_MASKS (3*13)\n@@ -525,0 +528,4 @@\n+  idealreg2spillmask  [Op_RegVectMask] = &rms[36];\n+  idealreg2debugmask  [Op_RegVectMask] = &rms[37];\n+  idealreg2mhdebugmask[Op_RegVectMask] = &rms[38];\n+\n@@ -570,0 +577,5 @@\n+  if (Matcher::has_predicated_vectors()) {\n+    *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n+     idealreg2spillmask[Op_RegVectMask]->OR(aligned_stack_mask);\n+  }\n+\n@@ -688,0 +700,1 @@\n+  *idealreg2debugmask  [Op_RegVectMask] = *idealreg2spillmask[Op_RegVectMask];\n@@ -702,0 +715,1 @@\n+  *idealreg2mhdebugmask[Op_RegVectMask] = *idealreg2spillmask[Op_RegVectMask];\n@@ -722,0 +736,1 @@\n+  idealreg2debugmask[Op_RegVectMask]->SUBTRACT(*caller_save_mask);\n@@ -736,0 +751,1 @@\n+  idealreg2mhdebugmask[Op_RegVectMask]->SUBTRACT(*mh_caller_save_mask);\n@@ -1003,0 +1019,1 @@\n+  idealreg2regmask[Op_RegVectMask] = regmask_for_ideal_register(Op_RegVectMask, ret);\n@@ -2613,0 +2630,1 @@\n+    case Op_RegVectMask: return Matcher::predicate_reg_mask();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -324,0 +324,2 @@\n+  static const RegMask* predicate_reg_mask(void);\n+  static const TypeVect* predicate_reg_type(const Type* elemTy, int length);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -342,1 +342,1 @@\n-        int nb = u->replace_edge(ctl, phase->C->top());\n+        int nb = u->replace_edge(ctl, phase->C->top(), igvn);\n@@ -534,2 +534,8 @@\n-\/\/ Find an arraycopy that must have set (can_see_stored_value=true) or\n-\/\/ could have set (can_see_stored_value=false) the value for this load\n+\/\/ Find an arraycopy ac that produces the memory state represented by parameter mem.\n+\/\/ Return ac if\n+\/\/ (a) can_see_stored_value=true  and ac must have set the value for this load or if\n+\/\/ (b) can_see_stored_value=false and ac could have set the value for this load or if\n+\/\/ (c) can_see_stored_value=false and ac cannot have set the value for this load.\n+\/\/ In case (c) change the parameter mem to the memory input of ac to skip it\n+\/\/ when searching stored value.\n+\/\/ Otherwise return NULL.\n@@ -539,1 +545,24 @@\n-    return ac;\n+    Node* ld_addp = in(MemNode::Address);\n+    Node* src = ac->in(ArrayCopyNode::Src);\n+    const TypeAryPtr* ary_t = phase->type(src)->isa_aryptr();\n+\n+    \/\/ This is a load from a cloned array. The corresponding arraycopy ac must\n+    \/\/ have set the value for the load and we can return ac but only if the load\n+    \/\/ is known to be within bounds. This is checked below.\n+    if (ary_t != NULL && ld_addp->is_AddP()) {\n+      Node* ld_offs = ld_addp->in(AddPNode::Offset);\n+      BasicType ary_elem = ary_t->klass()->as_array_klass()->element_type()->basic_type();\n+      jlong header = arrayOopDesc::base_offset_in_bytes(ary_elem);\n+      jlong elemsize = type2aelembytes(ary_elem);\n+\n+      const TypeX*   ld_offs_t = phase->type(ld_offs)->isa_intptr_t();\n+      const TypeInt* sizetype  = ary_t->size();\n+\n+      if (ld_offs_t->_lo >= header && ld_offs_t->_hi < (sizetype->_lo * elemsize + header)) {\n+        \/\/ The load is known to be within bounds. It receives its value from ac.\n+        return ac;\n+      }\n+      \/\/ The load is known to be out-of-bounds.\n+    }\n+    \/\/ The load could be out-of-bounds. It must not be hoisted but must remain\n+    \/\/ dependent on the runtime range check. This is achieved by returning NULL.\n@@ -560,0 +589,1 @@\n+            return ac;\n@@ -2744,7 +2774,3 @@\n-        if (can_reshape) {\n-          use->set_req_X(MemNode::Memory, st->in(MemNode::Memory), phase->is_IterGVN());\n-        } else {\n-          \/\/ It's OK to do this in the parser, since DU info is always accurate,\n-          \/\/ and the parser always refers to nodes via SafePointNode maps.\n-          use->set_req(MemNode::Memory, st->in(MemNode::Memory));\n-        }\n+        \/\/ It's OK to do this in the parser, since DU info is always accurate,\n+        \/\/ and the parser always refers to nodes via SafePointNode maps.\n+        use->set_req_X(MemNode::Memory, st->in(MemNode::Memory), phase);\n@@ -2904,1 +2930,1 @@\n-      set_req(MemNode::ValueIn, val->in(1));\n+      set_req_X(MemNode::ValueIn, val->in(1), phase);\n@@ -2926,1 +2952,1 @@\n-          set_req(MemNode::ValueIn, shl->in(1));\n+          set_req_X(MemNode::ValueIn, shl->in(1), phase);\n@@ -3040,1 +3066,1 @@\n-      set_req(MemNode::OopStore, mem);\n+      set_req_X(MemNode::OopStore, mem, phase);\n@@ -3050,7 +3076,1 @@\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type *t = phase->type( in(MemNode::Memory) );\n-  if( t == Type::TOP ) return Type::TOP;\n-  t = phase->type( in(MemNode::Address) );\n-  if( t == Type::TOP ) return Type::TOP;\n-  t = phase->type( in(MemNode::ValueIn) );\n-  if( t == Type::TOP ) return Type::TOP;\n+  \/\/ Either input is TOP ==> the result is TOP (checked in StoreNode::Value).\n@@ -3058,4 +3078,5 @@\n-  t = phase->type( in(MemNode::OopStore) );\n-  if( t == Type::TOP ) return Type::TOP;\n-\n-  return StoreNode::Value( phase );\n+  const Type* t = phase->type(in(MemNode::OopStore));\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  return StoreNode::Value(phase);\n@@ -3069,0 +3090,3 @@\n+  if (in(0) == NULL || phase->type(in(0)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -3087,0 +3111,21 @@\n+\/\/------------------------------Value-----------------------------------------\n+const Type* LoadStoreNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  if (!in(MemNode::Control) || phase->type(in(MemNode::Control)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  const Type* t = phase->type(in(MemNode::Memory));\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  t = phase->type(in(MemNode::Address));\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  t = phase->type(in(MemNode::ValueIn));\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  return bottom_type();\n+}\n+\n@@ -3132,0 +3177,9 @@\n+const Type* LoadStoreConditionalNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t = phase->type(in(ExpectedIn));\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  return LoadStoreNode::Value(phase);\n+}\n+\n@@ -4873,1 +4927,1 @@\n-      set_req(i, new_in);\n+      set_req_X(i, new_in, phase);\n@@ -4879,1 +4933,1 @@\n-    set_req(Compile::AliasIdxBot, new_base);\n+    set_req_X(Compile::AliasIdxBot, new_base, phase);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":81,"deletions":27,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -855,0 +855,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -869,0 +870,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-          set_req(1, mul1->in(1));\n-          set_req(2, phase->makecon( tcon01 ));\n+          set_req_X(1, mul1->in(1), phase);\n+          set_req_X(2, phase->makecon(tcon01), phase);\n@@ -978,2 +978,2 @@\n-      set_req(1, ld);\n-      set_req(2, phase->intcon(0));\n+      set_req_X(1, ld, phase);\n+      set_req_X(2, phase->intcon(0), phase);\n@@ -982,1 +982,1 @@\n-    else if( can_reshape &&\n+    else if (can_reshape &&\n@@ -994,1 +994,1 @@\n-    if( ld->Opcode() == Op_LoadB ) {\n+    if (ld->Opcode() == Op_LoadB) {\n@@ -996,2 +996,2 @@\n-      set_req(1, ld);\n-      set_req(2, phase->intcon(0));\n+      set_req_X(1, ld, phase);\n+      set_req_X(2, phase->intcon(0), phase);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -877,1 +877,1 @@\n-int Node::replace_edge(Node* old, Node* neww) {\n+int Node::replace_edge(Node* old, Node* neww, PhaseGVN* gvn) {\n@@ -883,1 +883,5 @@\n-        set_req(i, neww);\n+        if (gvn != NULL) {\n+          set_req_X(i, neww, gvn);\n+        } else {\n+          set_req(i, neww);\n+        }\n@@ -885,0 +889,1 @@\n+        assert(gvn == NULL || gvn->is_IterGVN() == NULL, \"no support for igvn here\");\n@@ -897,1 +902,1 @@\n-int Node::replace_edges_in_range(Node* old, Node* neww, int start, int end) {\n+int Node::replace_edges_in_range(Node* old, Node* neww, int start, int end, PhaseGVN* gvn) {\n@@ -902,1 +907,1 @@\n-      set_req(i, neww);\n+      set_req_X(i, neww, gvn);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -463,2 +463,2 @@\n-  int replace_edge(Node* old, Node* neww);\n-  int replace_edges_in_range(Node* old, Node* neww, int start, int end);\n+  int replace_edge(Node* old, Node* neww, PhaseGVN* gvn = NULL);\n+  int replace_edges_in_range(Node* old, Node* neww, int start, int end, PhaseGVN* gvn);\n@@ -538,1 +538,2 @@\n-  void set_req_X( uint i, Node *n, PhaseIterGVN *igvn );\n+  void set_req_X(uint i, Node *n, PhaseIterGVN *igvn);\n+  void set_req_X(uint i, Node *n, PhaseGVN *gvn);\n@@ -703,0 +704,2 @@\n+      DEFINE_CLASS_ID(Vector, Type, 7)\n+        DEFINE_CLASS_ID(VectorMaskCmp, Vector, 0)\n@@ -751,2 +754,0 @@\n-    DEFINE_CLASS_ID(Vector,   Node, 13)\n-      DEFINE_CLASS_ID(VectorMaskCmp, Vector, 0)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -873,2 +873,3 @@\n-      sv = new ObjectValue(spobj->_idx,\n-                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n+      ScopeValue* klass_sv = new ConstantOopWriteValue(cik->java_mirror()->constant_encoding());\n+      sv = spobj->is_auto_box() ? new AutoBoxObjectValue(spobj->_idx, klass_sv)\n+                                    : new ObjectValue(spobj->_idx, klass_sv);\n@@ -1150,2 +1151,3 @@\n-          ObjectValue* sv = new ObjectValue(spobj->_idx,\n-                                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n+          ScopeValue* klass_sv = new ConstantOopWriteValue(cik->java_mirror()->constant_encoding());\n+          ObjectValue* sv = spobj->is_auto_box() ? new AutoBoxObjectValue(spobj->_idx, klass_sv)\n+                                        : new ObjectValue(spobj->_idx, klass_sv);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"runtime\/arguments.hpp\"\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -839,1 +839,1 @@\n-Node *PhaseGVN::transform_no_reclaim( Node *n ) {\n+Node *PhaseGVN::transform_no_reclaim(Node *n) {\n@@ -843,6 +843,5 @@\n-  Node *k = n;\n-  NOT_PRODUCT( uint loop_count = 0; )\n-  while( 1 ) {\n-    Node *i = apply_ideal(k, \/*can_reshape=*\/false);\n-    if( !i ) break;\n-    assert( i->_idx >= k->_idx, \"Idealize should return new nodes, use Identity to return old nodes\" );\n+  Node* k = n;\n+  Node* i = apply_ideal(k, \/*can_reshape=*\/false);\n+  NOT_PRODUCT(uint loop_count = 1;)\n+  while (i != NULL) {\n+    assert(i->_idx >= k->_idx, \"Idealize should return new nodes, use Identity to return old nodes\" );\n@@ -850,1 +849,7 @@\n-    assert(loop_count++ < K, \"infinite loop in PhaseGVN::transform\");\n+#ifdef ASSERT\n+    if (loop_count >= K + C->live_nodes()) {\n+      dump_infinite_loop_info(i, \"PhaseGVN::transform_no_reclaim\");\n+    }\n+#endif\n+    i = apply_ideal(k, \/*can_reshape=*\/false);\n+    NOT_PRODUCT(loop_count++;)\n@@ -852,2 +857,1 @@\n-  NOT_PRODUCT( if( loop_count != 0 ) { set_progress(); } )\n-\n+  NOT_PRODUCT(if (loop_count != 0) { set_progress(); })\n@@ -862,1 +866,1 @@\n-  const Type *t = k->Value(this); \/\/ Get runtime Value set\n+  const Type* t = k->Value(this); \/\/ Get runtime Value set\n@@ -877,2 +881,2 @@\n-  if( t->singleton() && !k->is_Con() ) {\n-    NOT_PRODUCT( set_progress(); )\n+  if (t->singleton() && !k->is_Con()) {\n+    NOT_PRODUCT(set_progress();)\n@@ -883,3 +887,3 @@\n-  Node *i = k->Identity(this);  \/\/ Look for a nearby replacement\n-  if( i != k ) {                \/\/ Found? Return replacement!\n-    NOT_PRODUCT( set_progress(); )\n+  i = k->Identity(this);        \/\/ Look for a nearby replacement\n+  if (i != k) {                 \/\/ Found? Return replacement!\n+    NOT_PRODUCT(set_progress();)\n@@ -891,1 +895,1 @@\n-  if( i && (i != k) ) {\n+  if (i && (i != k)) {\n@@ -893,1 +897,1 @@\n-    NOT_PRODUCT( set_progress(); )\n+    NOT_PRODUCT(set_progress();)\n@@ -946,0 +950,10 @@\n+\n+\n+\/**\n+ * Dumps information that can help to debug the problem. A debug\n+ * build fails with an assert.\n+ *\/\n+void PhaseGVN::dump_infinite_loop_info(Node* n, const char* where) {\n+  n->dump(4);\n+  assert(false, \"infinite loop in %s\", where);\n+}\n@@ -1141,1 +1155,1 @@\n-void PhaseIterGVN::dump_infinite_loop_info(Node* n) {\n+void PhaseIterGVN::dump_infinite_loop_info(Node* n, const char* where) {\n@@ -1144,1 +1158,1 @@\n-  assert(false, \"infinite loop in PhaseIterGVN::optimize\");\n+  assert(false, \"infinite loop in %s\", where);\n@@ -1176,2 +1190,2 @@\n-    if (++loop_count >= K * C->live_nodes()) {\n-      DEBUG_ONLY(dump_infinite_loop_info(n);)\n+    if (loop_count >= K * C->live_nodes()) {\n+      DEBUG_ONLY(dump_infinite_loop_info(n, \"PhaseIterGVN::optimize\");)\n@@ -1190,0 +1204,1 @@\n+    loop_count++;\n@@ -1225,2 +1240,0 @@\n-  DEBUG_ONLY(uint loop_count = 0;);\n-\n@@ -1245,0 +1258,1 @@\n+  DEBUG_ONLY(uint loop_count = 1;)\n@@ -1247,2 +1261,2 @@\n-    if (loop_count >= K) {\n-      dump_infinite_loop_info(i);\n+    if (loop_count >= K + C->live_nodes()) {\n+      dump_infinite_loop_info(i, \"PhaseIterGVN::transform_old\");\n@@ -1250,1 +1264,0 @@\n-    loop_count++;\n@@ -1270,0 +1283,1 @@\n+    DEBUG_ONLY(loop_count++;)\n@@ -1363,1 +1377,1 @@\n-            int nrep = dead->replace_edge(in, NULL);  \/\/ Kill edges\n+            int nrep = dead->replace_edge(in, NULL, this);  \/\/ Kill edges\n@@ -1470,0 +1484,3 @@\n+  if (nn != NULL && nn->outcnt() == 0) {\n+    _worklist.push(nn);\n+  }\n@@ -2165,0 +2182,1 @@\n+}\n@@ -2166,0 +2184,7 @@\n+void Node::set_req_X(uint i, Node *n, PhaseGVN *gvn) {\n+  PhaseIterGVN* igvn = gvn->is_IterGVN();\n+  if (igvn == NULL) {\n+    set_req(i, n);\n+    return;\n+  }\n+  set_req_X(i, n, igvn);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":53,"deletions":28,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -432,0 +432,2 @@\n+#ifdef ASSERT\n+  void dump_infinite_loop_info(Node* n, const char* where);\n@@ -433,1 +435,2 @@\n-  DEBUG_ONLY(void dead_loop_check(Node *n);)\n+  void dead_loop_check(Node *n);\n+#endif\n@@ -451,1 +454,0 @@\n-\n@@ -484,1 +486,1 @@\n-  void dump_infinite_loop_info(Node* n);\n+  void dump_infinite_loop_info(Node* n, const char* where);\n@@ -530,1 +532,1 @@\n-    n->set_req(i, in);\n+    n->set_req_X(i, in, this);\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  PHASE_AFTER_MATCHING,\n@@ -104,1 +103,0 @@\n-      case PHASE_AFTER_MATCHING:             return \"After Matching\";\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -201,1 +202,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, bool is_larval, JavaThread* thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, bool is_larval, JavaThread* current))\n@@ -206,1 +207,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -211,1 +212,1 @@\n-    Handle holder(THREAD, klass->klass_holder()); \/\/ keep the klass alive\n+    Handle holder(current, klass->klass_holder()); \/\/ keep the klass alive\n@@ -220,1 +221,1 @@\n-    Handle holder(THREAD, klass->klass_holder()); \/\/ keep the klass alive\n+    Handle holder(current, klass->klass_holder()); \/\/ keep the klass alive\n@@ -226,1 +227,1 @@\n-    thread->set_vm_result(result);\n+    current->set_vm_result(result);\n@@ -234,1 +235,1 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n@@ -238,1 +239,1 @@\n-  SharedRuntime::on_slowpath_allocation_exit(thread);\n+  SharedRuntime::on_slowpath_allocation_exit(current);\n@@ -243,1 +244,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_C(Klass* array_type, int len, JavaThread *thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_C(Klass* array_type, int len, JavaThread* current))\n@@ -248,1 +249,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -262,1 +263,1 @@\n-    Handle holder(THREAD, array_type->klass_holder()); \/\/ keep the array klass alive\n+    Handle holder(current, array_type->klass_holder()); \/\/ keep the array klass alive\n@@ -270,2 +271,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(result);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(result);\n@@ -275,1 +276,1 @@\n-  SharedRuntime::on_slowpath_allocation_exit(thread);\n+  SharedRuntime::on_slowpath_allocation_exit(current);\n@@ -279,1 +280,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_nozero_C(Klass* array_type, int len, JavaThread *thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_nozero_C(Klass* array_type, int len, JavaThread* current))\n@@ -284,1 +285,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -298,2 +299,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(result);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(result);\n@@ -304,1 +305,1 @@\n-  SharedRuntime::on_slowpath_allocation_exit(thread);\n+  SharedRuntime::on_slowpath_allocation_exit(current);\n@@ -306,1 +307,1 @@\n-  oop result = thread->vm_result();\n+  oop result = current->vm_result();\n@@ -308,1 +309,1 @@\n-      is_deoptimized_caller_frame(thread)) {\n+      is_deoptimized_caller_frame(current)) {\n@@ -328,1 +329,1 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarray2_C(Klass* elem_type, int len1, int len2, JavaThread *thread))\n+JRT_ENTRY(void, OptoRuntime::multianewarray2_C(Klass* elem_type, int len1, int len2, JavaThread* current))\n@@ -332,1 +333,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -337,1 +338,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -339,2 +340,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -344,1 +345,1 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarray3_C(Klass* elem_type, int len1, int len2, int len3, JavaThread *thread))\n+JRT_ENTRY(void, OptoRuntime::multianewarray3_C(Klass* elem_type, int len1, int len2, int len3, JavaThread* current))\n@@ -348,1 +349,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -354,1 +355,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -356,2 +357,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -361,1 +362,1 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarray4_C(Klass* elem_type, int len1, int len2, int len3, int len4, JavaThread *thread))\n+JRT_ENTRY(void, OptoRuntime::multianewarray4_C(Klass* elem_type, int len1, int len2, int len3, int len4, JavaThread* current))\n@@ -365,1 +366,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -372,1 +373,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -374,2 +375,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -379,1 +380,1 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarray5_C(Klass* elem_type, int len1, int len2, int len3, int len4, int len5, JavaThread *thread))\n+JRT_ENTRY(void, OptoRuntime::multianewarray5_C(Klass* elem_type, int len1, int len2, int len3, int len4, int len5, JavaThread* current))\n@@ -383,1 +384,1 @@\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -391,1 +392,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -393,2 +394,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -397,2 +398,2 @@\n-JRT_ENTRY(void, OptoRuntime::multianewarrayN_C(Klass* elem_type, arrayOopDesc* dims, JavaThread *thread))\n-  assert(check_compiled_frame(thread), \"incorrect caller\");\n+JRT_ENTRY(void, OptoRuntime::multianewarrayN_C(Klass* elem_type, arrayOopDesc* dims, JavaThread* current))\n+  assert(check_compiled_frame(current), \"incorrect caller\");\n@@ -409,1 +410,1 @@\n-  Handle holder(THREAD, elem_type->klass_holder()); \/\/ keep the klass alive\n+  Handle holder(current, elem_type->klass_holder()); \/\/ keep the klass alive\n@@ -411,2 +412,2 @@\n-  deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);\n-  thread->set_vm_result(obj);\n+  deoptimize_caller_frame(current, HAS_PENDING_EXCEPTION);\n+  current->set_vm_result(obj);\n@@ -415,1 +416,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notify_C(oopDesc* obj, JavaThread *thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notify_C(oopDesc* obj, JavaThread* current))\n@@ -422,1 +423,1 @@\n-    if (ObjectSynchronizer::quick_notify(obj, thread, false)) {\n+    if (ObjectSynchronizer::quick_notify(obj, current, false)) {\n@@ -432,1 +433,1 @@\n-  Handle h_obj(THREAD, obj);\n+  Handle h_obj(current, obj);\n@@ -437,1 +438,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notifyAll_C(oopDesc* obj, JavaThread *thread))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notifyAll_C(oopDesc* obj, JavaThread* current))\n@@ -440,1 +441,1 @@\n-    if (ObjectSynchronizer::quick_notify(obj, thread, true)) {\n+    if (ObjectSynchronizer::quick_notify(obj, current, true)) {\n@@ -450,1 +451,1 @@\n-  Handle h_obj(THREAD, obj);\n+  Handle h_obj(current, obj);\n@@ -1242,1 +1243,1 @@\n-JRT_ENTRY_NO_ASYNC(address, OptoRuntime::handle_exception_C_helper(JavaThread* thread, nmethod* &nm))\n+JRT_ENTRY_NO_ASYNC(address, OptoRuntime::handle_exception_C_helper(JavaThread* current, nmethod* &nm))\n@@ -1247,1 +1248,1 @@\n-  assert(thread->exception_oop() != NULL, \"exception oop is found\");\n+  assert(current->exception_oop() != NULL, \"exception oop is found\");\n@@ -1250,2 +1251,2 @@\n-  Handle exception(thread, thread->exception_oop());\n-  address pc = thread->exception_pc();\n+  Handle exception(current, current->exception_oop());\n+  address pc = current->exception_pc();\n@@ -1257,1 +1258,1 @@\n-  thread->clear_exception_oop_and_pc();\n+  current->clear_exception_oop_and_pc();\n@@ -1293,1 +1294,1 @@\n-      deoptimize_caller_frame(thread);\n+      deoptimize_caller_frame(current);\n@@ -1300,1 +1301,1 @@\n-    bool force_unwind = !thread->stack_overflow_state()->reguard_stack();\n+    bool force_unwind = !current->stack_overflow_state()->reguard_stack();\n@@ -1304,2 +1305,2 @@\n-      RegisterMap map(thread, false);\n-      frame deoptee = thread->last_frame().sender(&map);\n+      RegisterMap map(current, false);\n+      frame deoptee = current->last_frame().sender(&map);\n@@ -1342,2 +1343,2 @@\n-    thread->set_exception_pc(pc);\n-    thread->set_exception_handler_pc(handler_address);\n+    current->set_exception_pc(pc);\n+    current->set_exception_handler_pc(handler_address);\n@@ -1346,1 +1347,1 @@\n-    thread->set_is_method_handle_return(nm->is_method_handle_return(pc));\n+    current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -1350,1 +1351,1 @@\n-  thread->set_exception_oop(exception());\n+  current->set_exception_oop(exception());\n@@ -1362,1 +1363,1 @@\n-address OptoRuntime::handle_exception_C(JavaThread* thread) {\n+address OptoRuntime::handle_exception_C(JavaThread* current) {\n@@ -1376,1 +1377,1 @@\n-    handler_address = handle_exception_C_helper(thread, nm);\n+    handler_address = handle_exception_C_helper(current, nm);\n@@ -1385,2 +1386,2 @@\n-    RegisterMap map(thread, false);\n-    frame caller = thread->last_frame().sender(&map);\n+    RegisterMap map(current, false);\n+    frame caller = current->last_frame().sender(&map);\n@@ -1420,0 +1421,4 @@\n+\n+  \/\/ Enable WXWrite: the function called directly by compiled code.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n@@ -1538,1 +1543,1 @@\n-JRT_ENTRY_NO_ASYNC(void, OptoRuntime::register_finalizer(oopDesc* obj, JavaThread* thread))\n+JRT_ENTRY_NO_ASYNC(void, OptoRuntime::register_finalizer(oopDesc* obj, JavaThread* current))\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":74,"deletions":69,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,1 @@\n-  static void new_instance_C(Klass* instance_klass, bool is_larval, JavaThread* thread);\n+  static void new_instance_C(Klass* instance_klass, bool is_larval, JavaThread* current);\n@@ -161,2 +161,2 @@\n-  static void new_array_C(Klass* array_klass, int len, JavaThread *thread);\n-  static void new_array_nozero_C(Klass* array_klass, int len, JavaThread *thread);\n+  static void new_array_C(Klass* array_klass, int len, JavaThread* current);\n+  static void new_array_nozero_C(Klass* array_klass, int len, JavaThread* current);\n@@ -166,5 +166,5 @@\n-  static void multianewarray2_C(Klass* klass, int len1, int len2, JavaThread *thread);\n-  static void multianewarray3_C(Klass* klass, int len1, int len2, int len3, JavaThread *thread);\n-  static void multianewarray4_C(Klass* klass, int len1, int len2, int len3, int len4, JavaThread *thread);\n-  static void multianewarray5_C(Klass* klass, int len1, int len2, int len3, int len4, int len5, JavaThread *thread);\n-  static void multianewarrayN_C(Klass* klass, arrayOopDesc* dims, JavaThread *thread);\n+  static void multianewarray2_C(Klass* klass, int len1, int len2, JavaThread* current);\n+  static void multianewarray3_C(Klass* klass, int len1, int len2, int len3, JavaThread* current);\n+  static void multianewarray4_C(Klass* klass, int len1, int len2, int len3, int len4, JavaThread* current);\n+  static void multianewarray5_C(Klass* klass, int len1, int len2, int len3, int len4, int len5, JavaThread* current);\n+  static void multianewarrayN_C(Klass* klass, arrayOopDesc* dims, JavaThread* current);\n@@ -177,2 +177,2 @@\n-  static void monitor_notify_C(oopDesc* obj, JavaThread* thread);\n-  static void monitor_notifyAll_C(oopDesc* obj, JavaThread* thread);\n+  static void monitor_notify_C(oopDesc* obj, JavaThread* current);\n+  static void monitor_notifyAll_C(oopDesc* obj, JavaThread* current);\n@@ -186,2 +186,2 @@\n-  static address handle_exception_C       (JavaThread* thread);\n-  static address handle_exception_C_helper(JavaThread* thread, nmethod*& nm);\n+  static address handle_exception_C       (JavaThread* current);\n+  static address handle_exception_C_helper(JavaThread* current, nmethod*& nm);\n@@ -199,1 +199,1 @@\n-  static void register_finalizer(oopDesc* obj, JavaThread* thread);\n+  static void register_finalizer(oopDesc* obj, JavaThread* current);\n@@ -305,8 +305,0 @@\n-  \/\/ leaf on stack replacement interpreter accessor types\n-  static const TypeFunc* fetch_int_Type();\n-  static const TypeFunc* fetch_long_Type();\n-  static const TypeFunc* fetch_float_Type();\n-  static const TypeFunc* fetch_double_Type();\n-  static const TypeFunc* fetch_oop_Type();\n-  static const TypeFunc* fetch_monitor_Type();\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":14,"deletions":22,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,3 +238,4 @@\n-  \/\/ Convert \"0 - (x-y)\" into \"y-x\"\n-  if( t1 == TypeInt::ZERO && op2 == Op_SubI )\n-    return new SubINode( in2->in(2), in2->in(1) );\n+  \/\/ Convert \"0 - (x-y)\" into \"y-x\", leave the double negation \"-(-y)\" to SubNode::Identity().\n+  if (t1 == TypeInt::ZERO && op2 == Op_SubI && phase->type(in2->in(1)) != TypeInt::ZERO) {\n+    return new SubINode(in2->in(2), in2->in(1));\n+  }\n@@ -376,3 +377,4 @@\n-  \/\/ Convert \"0 - (x-y)\" into \"y-x\"\n-  if( phase->type( in1 ) == TypeLong::ZERO && op2 == Op_SubL )\n-    return new SubLNode( in2->in(2), in2->in(1) );\n+  \/\/ Convert \"0 - (x-y)\" into \"y-x\", leave the double negation \"-(-y)\" to SubNode::Identity.\n+  if (t1 == TypeLong::ZERO && op2 == Op_SubL && phase->type(in2->in(1)) != TypeLong::ZERO) {\n+    return new SubLNode(in2->in(2), in2->in(1));\n+  }\n@@ -1108,8 +1110,2 @@\n-      PhaseIterGVN* igvn = phase->is_IterGVN();\n-      if (igvn != NULL) {\n-        set_req_X(1, lhs, igvn);\n-        set_req_X(2, rhs, igvn);\n-      } else {\n-        set_req(1, lhs);\n-        set_req(2, rhs);\n-      }\n+      set_req_X(1, lhs, phase);\n+      set_req_X(2, rhs, phase);\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -213,0 +213,14 @@\n+  Node *p1 = phase->transform(new AddPNode(superklass, superklass, phase->MakeConX(in_bytes(Klass::super_check_offset_offset()))));\n+  Node* m = phase->C->immutable_memory();\n+  LoadINode* chk_off_ld = new LoadINode(NULL, m, p1, phase->type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered);\n+  Node *chk_off = phase->transform(chk_off_ld);\n+  int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());\n+  bool might_be_cache = (phase->find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n+\n+  if (might_be_cache) {\n+    if (phase->is_IterGVN()) {\n+      phase->is_IterGVN()->_worklist.push(chk_off_ld);\n+    }\n+    return NULL;\n+  }\n+\n@@ -222,10 +236,0 @@\n-    Node *p1 = phase->transform(new AddPNode(superklass, superklass, phase->MakeConX(in_bytes(Klass::super_check_offset_offset()))));\n-    Node* m = phase->C->immutable_memory();\n-    Node *chk_off = phase->transform(new LoadINode(NULL, m, p1, phase->type(p1)->is_ptr(), TypeInt::INT, MemNode::unordered));\n-    int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());\n-    bool might_be_cache = (phase->find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n-\n-    if (might_be_cache) {\n-      return NULL;\n-    }\n-\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectormask:\",   false, Op_RegVectMask,       relocInfo::none          },  \/\/ VectorMask.\n@@ -122,0 +123,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectormask:\",   false, Op_RegVectMask,       relocInfo::none          },  \/\/ VectorMask.\n@@ -129,0 +131,1 @@\n+  { Bad,             T_ILLEGAL,    \"vectormask:\",   false, Op_RegVectMask,       relocInfo::none          },  \/\/ VectorMask.\n@@ -729,0 +732,3 @@\n+  TypeVect::VECTMASK = (TypeVect*)(new TypeVectMask(TypeInt::BOOL, MaxVectorSize))->hashcons();\n+  mreg2type[Op_RegVectMask] = TypeVect::VECTMASK;\n+\n@@ -1061,42 +1067,0 @@\n-\/\/ Compute dual right now.\n-const Type::TYPES Type::dual_type[Type::lastype] = {\n-  Bad,          \/\/ Bad\n-  Control,      \/\/ Control\n-  Bottom,       \/\/ Top\n-  Bad,          \/\/ Int - handled in v-call\n-  Bad,          \/\/ Long - handled in v-call\n-  Half,         \/\/ Half\n-  Bad,          \/\/ NarrowOop - handled in v-call\n-  Bad,          \/\/ NarrowKlass - handled in v-call\n-\n-  Bad,          \/\/ Tuple - handled in v-call\n-  Bad,          \/\/ Array - handled in v-call\n-  Bad,          \/\/ VectorA - handled in v-call\n-  Bad,          \/\/ VectorS - handled in v-call\n-  Bad,          \/\/ VectorD - handled in v-call\n-  Bad,          \/\/ VectorX - handled in v-call\n-  Bad,          \/\/ VectorY - handled in v-call\n-  Bad,          \/\/ VectorZ - handled in v-call\n-  Bad,          \/\/ InlineType - handled in v-call\n-\n-  Bad,          \/\/ AnyPtr - handled in v-call\n-  Bad,          \/\/ RawPtr - handled in v-call\n-  Bad,          \/\/ OopPtr - handled in v-call\n-  Bad,          \/\/ InstPtr - handled in v-call\n-  Bad,          \/\/ AryPtr - handled in v-call\n-\n-  Bad,          \/\/  MetadataPtr - handled in v-call\n-  Bad,          \/\/ KlassPtr - handled in v-call\n-\n-  Bad,          \/\/ Function - handled in v-call\n-  Abio,         \/\/ Abio\n-  Return_Address,\/\/ Return_Address\n-  Memory,       \/\/ Memory\n-  FloatBot,     \/\/ FloatTop\n-  FloatCon,     \/\/ FloatCon\n-  FloatTop,     \/\/ FloatBot\n-  DoubleBot,    \/\/ DoubleTop\n-  DoubleCon,    \/\/ DoubleCon\n-  DoubleTop,    \/\/ DoubleBot\n-  Top           \/\/ Bottom\n-};\n@@ -2629,0 +2593,1 @@\n+const TypeVect *TypeVect::VECTMASK = NULL; \/\/ predicate\/mask vector\n@@ -2656,0 +2621,9 @@\n+const TypeVect *TypeVect::makemask(const Type* elem, uint length) {\n+  if (Matcher::has_predicated_vectors()) {\n+    const TypeVect* mtype = Matcher::predicate_reg_type(elem, length);\n+    return (TypeVect*)(const_cast<TypeVect*>(mtype))->hashcons();\n+  } else {\n+    return make(elem, length);\n+  }\n+}\n+\n@@ -2670,0 +2644,7 @@\n+  case VectorMask: {\n+    const TypeVectMask* v = t->is_vectmask();\n+    assert(  base() == v->base(), \"\");\n+    assert(length() == v->length(), \"\");\n+    assert(element_basic_type() == v->element_basic_type(), \"\");\n+    return TypeVect::makemask(_elem->xmeet(v->_elem), _length);\n+  }\n@@ -2737,0 +2718,2 @@\n+  case VectorMask:\n+    st->print(\"vectormask[\"); break;\n@@ -2746,0 +2729,8 @@\n+bool TypeVectMask::eq(const Type *t) const {\n+  const TypeVectMask *v = t->is_vectmask();\n+  return (element_type() == v->element_type()) && (length() == v->length());\n+}\n+\n+const Type *TypeVectMask::xdual() const {\n+  return new TypeVectMask(element_type()->dual(), length());\n+}\n@@ -4061,44 +4052,2 @@\n-    const TypeAryPtr *tp = t->is_aryptr();\n-    Offset offset = meet_offset(tp->offset());\n-    PTR ptr = meet_ptr(tp->ptr());\n-    int instance_id = meet_instance_id(tp->instance_id());\n-    const TypePtr* speculative = xmeet_speculative(tp);\n-    int depth = meet_inline_depth(tp->inline_depth());\n-    switch (ptr) {\n-    case TopPTR:\n-    case AnyNull:                \/\/ Fall 'down' to dual of object klass\n-      \/\/ For instances when a subclass meets a superclass we fall\n-      \/\/ below the centerline when the superclass is exact. We need to\n-      \/\/ do the same here.\n-      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact() && !flatten_array()) {\n-        return TypeAryPtr::make(ptr, tp->ary(), tp->klass(), tp->klass_is_exact(), offset, tp->field_offset(), instance_id, speculative, depth);\n-      } else {\n-        \/\/ cannot subclass, so the meet has to fall badly below the centerline\n-        ptr = NotNull;\n-        instance_id = InstanceBot;\n-        return TypeInstPtr::make( ptr, ciEnv::current()->Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);\n-      }\n-    case Constant:\n-    case NotNull:\n-    case BotPTR:                \/\/ Fall down to object klass\n-      \/\/ LCA is object_klass, but if we subclass from the top we can do better\n-      if( above_centerline(_ptr) ) { \/\/ if( _ptr == TopPTR || _ptr == AnyNull )\n-        \/\/ If 'this' (InstPtr) is above the centerline and it is Object class\n-        \/\/ then we can subclass in the Java class hierarchy.\n-        \/\/ For instances when a subclass meets a superclass we fall\n-        \/\/ below the centerline when the superclass is exact. We need\n-        \/\/ to do the same here.\n-        if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact() && !flatten_array()) {\n-          \/\/ that is, tp's array type is a subtype of my klass\n-          return TypeAryPtr::make(ptr, (ptr == Constant ? tp->const_oop() : NULL),\n-                                  tp->ary(), tp->klass(), tp->klass_is_exact(), offset, tp->field_offset(), instance_id, speculative, depth);\n-        }\n-      }\n-      \/\/ The other case cannot happen, since I cannot be a subtype of an array.\n-      \/\/ The meet falls down to Object class below centerline.\n-      if( ptr == Constant )\n-         ptr = NotNull;\n-      instance_id = InstanceBot;\n-      return make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, false, instance_id, speculative, depth);\n-    default: typerr(t);\n-    }\n+    \/\/ Call in reverse direction to avoid duplication\n+    return t->is_aryptr()->xmeet_helper(this);\n@@ -4251,2 +4200,6 @@\n-        if (ptr == Constant)  ptr = NotNull;   \/\/ forget it was a constant\n-        instance_id = InstanceBot;\n+        if (ptr == Constant) {\n+          ptr = NotNull;  \/\/ forget it was a constant\n+        }\n+        if (instance_id > 0) {\n+          instance_id = InstanceBot;\n+        }\n@@ -4349,1 +4302,1 @@\n-    if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )\n+    if (ptr == TopPTR || ptr == AnyNull || ptr == Constant) {\n@@ -4351,1 +4304,1 @@\n-\n+    }\n@@ -4875,1 +4828,1 @@\n-      return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);\n+      return make(ptr, o, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);\n@@ -4880,5 +4833,7 @@\n-      if (above_centerline(this->_ptr))\n-            xk = tap->_klass_is_exact;\n-      else  xk = (tap->_klass_is_exact & this->_klass_is_exact) &&\n-              (klass() == tap->klass()); \/\/ Only precise for identical arrays\n-      return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);\n+      if (above_centerline(this->_ptr)) {\n+        xk = tap->_klass_is_exact;\n+      } else {\n+        xk = (tap->_klass_is_exact & this->_klass_is_exact) &&\n+             (klass() == tap->klass()); \/\/ Only precise for identical arrays\n+      }\n+      return make(ptr, NULL, tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);\n@@ -4904,1 +4859,1 @@\n-        return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);\n+        return make(ptr, _ary, _klass, _klass_is_exact, offset, _field_offset, instance_id, speculative, depth);\n@@ -4929,1 +4884,1 @@\n-      if( ptr == Constant )\n+      if (ptr == Constant) {\n@@ -4931,1 +4886,4 @@\n-      instance_id = InstanceBot;\n+      }\n+      if (instance_id > 0) {\n+        instance_id = InstanceBot;\n+      }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":57,"deletions":99,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+class     TypeVectMask;\n@@ -95,0 +96,2 @@\n+\n+    VectorMask,                 \/\/ Vector predicate\/mask type\n@@ -191,2 +194,0 @@\n-  \/\/ Table for efficient dualing of base types\n-  static const TYPES dual_type[lastype];\n@@ -327,0 +328,2 @@\n+  const TypeVectMask *is_vectmask() const;       \/\/ Predicate\/Mask Vector\n+  const TypeVectMask *isa_vectmask() const;      \/\/ Returns NULL if not a Vector Predicate\/Mask\n@@ -877,0 +880,7 @@\n+  static const TypeVect *makemask(const BasicType elem_bt, uint length) {\n+    \/\/ Use bottom primitive type.\n+    return makemask(get_const_basic_type(elem_bt), length);\n+  }\n+  static const TypeVect *makemask(const Type* elem, uint length);\n+\n+\n@@ -886,0 +896,1 @@\n+  static const TypeVect *VECTMASK;\n@@ -922,0 +933,8 @@\n+class TypeVectMask : public TypeVect {\n+public:\n+  friend class TypeVect;\n+  TypeVectMask(const Type* elem, uint length) : TypeVect(VectorMask, elem, length) {}\n+  virtual bool eq(const Type *t) const;\n+  virtual const Type *xdual() const;\n+};\n+\n@@ -1808,0 +1827,9 @@\n+inline const TypeVectMask *Type::is_vectmask() const {\n+  assert( _base == VectorMask, \"Not a Vector Mask\" );\n+  return (TypeVectMask*)this;\n+}\n+\n+inline const TypeVectMask *Type::isa_vectmask() const {\n+  return (_base == VectorMask) ? (TypeVectMask*)this : NULL;\n+}\n+\n@@ -1809,1 +1837,1 @@\n-  assert( _base >= VectorA && _base <= VectorZ, \"Not a Vector\" );\n+  assert( _base >= VectorMask && _base <= VectorZ, \"Not a Vector\" );\n@@ -1814,1 +1842,1 @@\n-  return (_base >= VectorA && _base <= VectorZ) ? (TypeVect*)this : NULL;\n+  return (_base >= VectorMask && _base <= VectorZ) ? (TypeVect*)this : NULL;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-                                               NULL,\n+                                               vec_box,\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -32,0 +33,2 @@\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoadInfo.hpp\"\n@@ -287,1 +290,3 @@\n-  Klass* k = SystemDictionary::resolve_from_stream(class_name,\n+  Handle protection_domain;\n+  ClassLoadInfo cl_info(protection_domain);\n+  Klass* k = SystemDictionary::resolve_from_stream(&st, class_name,\n@@ -289,2 +294,1 @@\n-                                                   Handle(),\n-                                                   &st,\n+                                                   cl_info,\n@@ -336,1 +340,1 @@\n-      oop mirror = (oop) result.get_jobject();\n+      oop mirror = result.get_oop();\n@@ -892,1 +896,1 @@\n-    result->set_jobject(JNIHandles::make_local(THREAD, (oop) result->get_jobject()));\n+    result->set_jobject(JNIHandles::make_local(THREAD, result->get_oop()));\n@@ -909,1 +913,1 @@\n-    Klass* holder = m->method_holder();\n+    InstanceKlass* holder = m->method_holder();\n@@ -954,1 +958,1 @@\n-    result->set_jobject(JNIHandles::make_local(THREAD, (oop) result->get_jobject()));\n+    result->set_jobject(JNIHandles::make_local(THREAD, result->get_oop()));\n@@ -1126,1 +1130,1 @@\n-    ResourceMark rm;\n+    ResourceMark rm(THREAD);\n@@ -1150,1 +1154,1 @@\n-    ResourceMark rm;\n+    ResourceMark rm(THREAD);\n@@ -2824,1 +2828,1 @@\n-  ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));\n+  ObjectSynchronizer::jni_enter(obj, thread);\n@@ -4035,0 +4039,1 @@\n+    MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n@@ -4125,0 +4130,4 @@\n+\n+  \/\/ We are going to VM, change W^X state to the expected one.\n+  MACOS_AARCH64_ONLY(WXMode oldmode = thread->enable_wx(WXWrite));\n+\n@@ -4126,10 +4135,4 @@\n-  if (Threads::destroy_vm()) {\n-    \/\/ Should not change thread state, VM is gone\n-    vm_created = 0;\n-    res = JNI_OK;\n-    return res;\n-  } else {\n-    ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);\n-    res = JNI_ERR;\n-    return res;\n-  }\n+  Threads::destroy_vm();\n+  \/\/ Don't bother restoring thread state, VM is gone.\n+  vm_created = 0;\n+  return JNI_OK;\n@@ -4186,0 +4189,1 @@\n+  MACOS_AARCH64_ONLY(thread->init_wx());\n@@ -4259,0 +4263,1 @@\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n@@ -4310,0 +4315,3 @@\n+  \/\/ We are going to VM, change W^X state to the expected one.\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXWrite));\n+\n@@ -4326,0 +4334,4 @@\n+  \/\/ Go to the execute mode, the initial state of the thread on creation.\n+  \/\/ Use os interface as the thread is not a JavaThread anymore.\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n+\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thr));         \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-#include \"prims\/nativeLookup.hpp\"\n@@ -98,0 +97,1 @@\n+#include \"utilities\/dtrace.hpp\"\n@@ -625,1 +625,1 @@\n-    JvmtiExport::post_monitor_wait(thread, (oop)obj(), ms);\n+    JvmtiExport::post_monitor_wait(thread, obj(), ms);\n@@ -886,1 +886,2 @@\n-  Klass* k = SystemDictionary::resolve_from_stream(class_name,\n+  ClassLoadInfo cl_info(protection_domain);\n+  Klass* k = SystemDictionary::resolve_from_stream(&st, class_name,\n@@ -888,2 +889,1 @@\n-                                                   protection_domain,\n-                                                   &st,\n+                                                   cl_info,\n@@ -973,1 +973,2 @@\n-    ik = SystemDictionary::resolve_from_stream(class_name,\n+    ClassLoadInfo cl_info(protection_domain);\n+    ik = SystemDictionary::resolve_from_stream(&st, class_name,\n@@ -975,2 +976,1 @@\n-                                               protection_domain,\n-                                               &st,\n+                                               cl_info,\n@@ -992,5 +992,4 @@\n-    ik = SystemDictionary::parse_stream(class_name,\n-                                        class_loader,\n-                                        &st,\n-                                        cl_info,\n-                                        CHECK_NULL);\n+    ik = SystemDictionary::resolve_from_stream(&st, class_name,\n+                                               class_loader,\n+                                               cl_info,\n+                                               CHECK_NULL);\n@@ -1379,1 +1378,1 @@\n-  debug_only(int computed_modifiers = k->compute_modifier_flags(CHECK_0));\n+  debug_only(int computed_modifiers = k->compute_modifier_flags());\n@@ -1532,1 +1531,1 @@\n-static bool jvm_get_field_common(jobject field, fieldDescriptor& fd, TRAPS) {\n+static bool jvm_get_field_common(jobject field, fieldDescriptor& fd) {\n@@ -1623,1 +1622,1 @@\n-  bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);\n+  bool gotFd = jvm_get_field_common(field, fd);\n@@ -3726,1 +3725,1 @@\n-    return Arguments::is_dumping_archive();\n+  return Arguments::is_dumping_archive();\n@@ -3730,1 +3729,1 @@\n-    return UseSharedSpaces;\n+  return UseSharedSpaces;\n@@ -3776,0 +3775,18 @@\n+JVM_ENTRY(void, JVM_DumpClassListToFile(JNIEnv *env, jstring listFileName))\n+#if INCLUDE_CDS\n+  ResourceMark rm(THREAD);\n+  Handle file_handle(THREAD, JNIHandles::resolve_non_null(listFileName));\n+  char* file_name  = java_lang_String::as_utf8_string(file_handle());\n+  MetaspaceShared::dump_loaded_classes(file_name, THREAD);\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_DumpDynamicArchive(JNIEnv *env, jstring archiveName))\n+#if INCLUDE_CDS\n+  ResourceMark rm(THREAD);\n+  Handle file_handle(THREAD, JNIHandles::resolve_non_null(archiveName));\n+  char* archive_name  = java_lang_String::as_utf8_string(file_handle());\n+  DynamicArchive::dump(archive_name, THREAD);\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":35,"deletions":18,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));\n@@ -225,6 +226,2 @@\n-  jobject module = Modules::get_named_module(h_loader, package_name, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    CLEAR_PENDING_EXCEPTION;\n-    return JVMTI_ERROR_INTERNAL; \/\/ unexpected exception\n-  }\n-  *module_ptr = module;\n+  oop module = Modules::get_named_module(h_loader, package_name);\n+  *module_ptr = module != NULL ? JNIHandles::make_local(THREAD, module) : NULL;\n@@ -696,1 +693,1 @@\n-    Thread* THREAD = Thread::current();\n+    JavaThread* THREAD = JavaThread::current();\n@@ -1449,1 +1446,1 @@\n-  oop group_obj = (oop) JNIHandles::resolve_external_guard(group);\n+  oop group_obj = JNIHandles::resolve_external_guard(group);\n@@ -2369,6 +2366,1 @@\n-    result = k->compute_modifier_flags(current_thread);\n-    JavaThread* THREAD = current_thread; \/\/ pass to macros\n-    if (HAS_PENDING_EXCEPTION) {\n-      CLEAR_PENDING_EXCEPTION;\n-      return JVMTI_ERROR_INTERNAL;\n-    };\n+    result = k->compute_modifier_flags();\n@@ -2376,2 +2368,2 @@\n-    \/\/ Reset the deleted  ACC_SUPER bit ( deleted in compute_modifier_flags()).\n-    if(k->is_super()) {\n+    \/\/ Reset the deleted  ACC_SUPER bit (deleted in compute_modifier_flags()).\n+    if (k->is_super()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1084,3 +1084,2 @@\n-          Thread *t = mon->thread_of_waiter(waiter);\n-          if (t != NULL && t->is_Java_thread()) {\n-            JavaThread *wjava_thread = t->as_Java_thread();\n+          JavaThread *w = mon->thread_of_waiter(waiter);\n+          if (w != NULL) {\n@@ -1090,1 +1089,1 @@\n-            Handle th(current_thread, wjava_thread->threadObj());\n+            Handle th(current_thread, w->threadObj());\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/klassFactory.hpp\"\n@@ -211,1 +211,1 @@\n-  _res = load_new_class_versions(Thread::current());\n+  _res = load_new_class_versions();\n@@ -239,1 +239,1 @@\n-  Thread *thread = Thread::current();\n+  Thread* current = Thread::current();\n@@ -258,2 +258,2 @@\n-  HandleMark hm(thread);   \/\/ make sure any handles created are deleted\n-                           \/\/ before the stack walk again.\n+  HandleMark hm(current);   \/\/ make sure any handles created are deleted\n+                            \/\/ before the stack walk again.\n@@ -262,1 +262,1 @@\n-    redefine_single_class(_class_defs[i].klass, _scratch_classes[i], thread);\n+    redefine_single_class(current, _class_defs[i].klass, _scratch_classes[i]);\n@@ -272,1 +272,1 @@\n-  AdjustAndCleanMetadata adjust_and_clean_metadata(thread);\n+  AdjustAndCleanMetadata adjust_and_clean_metadata(current);\n@@ -291,1 +291,1 @@\n-    CheckClass check_class(thread);\n+    CheckClass check_class(current);\n@@ -366,2 +366,1 @@\n-       int scratch_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p,\n-       TRAPS) {\n+       int scratch_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p) {\n@@ -389,1 +388,1 @@\n-                                                     merge_cp_length_p, THREAD);\n+                                                     merge_cp_length_p);\n@@ -411,2 +410,1 @@\n-      ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p,\n-        THREAD);\n+      ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p);\n@@ -431,2 +429,1 @@\n-      ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p,\n-        THREAD);\n+      ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p);\n@@ -447,1 +444,1 @@\n-                                                         merge_cp_length_p, THREAD);\n+                                                         merge_cp_length_p);\n@@ -451,2 +448,1 @@\n-                                                              merge_cp_p, merge_cp_length_p,\n-                                                              THREAD);\n+                                                              merge_cp_p, merge_cp_length_p);\n@@ -485,1 +481,1 @@\n-                                                          merge_cp_p, merge_cp_length_p, THREAD);\n+                                                          merge_cp_p, merge_cp_length_p);\n@@ -489,1 +485,1 @@\n-                                                          merge_cp_p, merge_cp_length_p, THREAD);\n+                                                          merge_cp_p, merge_cp_length_p);\n@@ -536,1 +532,1 @@\n-                                                    merge_cp_length_p, THREAD);\n+                                                    merge_cp_length_p);\n@@ -556,1 +552,1 @@\n-                                                    merge_cp_length_p, THREAD);\n+                                                    merge_cp_length_p);\n@@ -577,1 +573,1 @@\n-                                            merge_cp_length_p, THREAD);\n+                                            merge_cp_length_p);\n@@ -581,1 +577,1 @@\n-                                                    merge_cp_length_p, THREAD);\n+                                                    merge_cp_length_p);\n@@ -630,1 +626,1 @@\n-      int ref_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {\n+      int ref_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p) {\n@@ -634,1 +630,1 @@\n-               scratch_cp->compare_entry_to(ref_i, *merge_cp_p, ref_i, THREAD);\n+               scratch_cp->compare_entry_to(ref_i, *merge_cp_p, ref_i);\n@@ -638,1 +634,1 @@\n-    int found_i = scratch_cp->find_matching_entry(ref_i, *merge_cp_p, THREAD);\n+    int found_i = scratch_cp->find_matching_entry(ref_i, *merge_cp_p);\n@@ -646,1 +642,1 @@\n-      append_entry(scratch_cp, ref_i, merge_cp_p, merge_cp_length_p, THREAD);\n+      append_entry(scratch_cp, ref_i, merge_cp_p, merge_cp_length_p);\n@@ -662,1 +658,1 @@\n-       constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {\n+       constantPoolHandle *merge_cp_p, int *merge_cp_length_p) {\n@@ -666,1 +662,1 @@\n-                                                merge_cp_length_p, THREAD);\n+                                                merge_cp_length_p);\n@@ -687,1 +683,1 @@\n-                                                      merge_cp_length_p, THREAD);\n+                                                      merge_cp_length_p);\n@@ -705,1 +701,1 @@\n-      int old_bs_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {\n+      int old_bs_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p) {\n@@ -709,1 +705,1 @@\n-               scratch_cp->compare_operand_to(old_bs_i, *merge_cp_p, old_bs_i, THREAD);\n+               scratch_cp->compare_operand_to(old_bs_i, *merge_cp_p, old_bs_i);\n@@ -714,1 +710,1 @@\n-                                                    _operands_cur_length, THREAD);\n+                                                    _operands_cur_length);\n@@ -722,1 +718,1 @@\n-      append_operand(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p, THREAD);\n+      append_operand(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p);\n@@ -1356,1 +1352,1 @@\n-jvmtiError VM_RedefineClasses::load_new_class_versions(TRAPS) {\n+jvmtiError VM_RedefineClasses::load_new_class_versions() {\n@@ -1369,1 +1365,2 @@\n-  ResourceMark rm(THREAD);\n+  JavaThread* current = JavaThread::current();\n+  ResourceMark rm(current);\n@@ -1371,1 +1368,1 @@\n-  JvmtiThreadState *state = JvmtiThreadState::state_for(JavaThread::current());\n+  JvmtiThreadState *state = JvmtiThreadState::state_for(current);\n@@ -1379,1 +1376,1 @@\n-    HandleMark hm(THREAD);\n+    HandleMark hm(current);\n@@ -1381,1 +1378,0 @@\n-    Symbol*  the_class_sym = the_class->name();\n@@ -1392,3 +1388,0 @@\n-    \/\/ Parse the stream.\n-    Handle the_class_loader(THREAD, the_class->class_loader());\n-    Handle protection_domain(THREAD, the_class->protection_domain());\n@@ -1400,0 +1393,3 @@\n+    Thread* THREAD = current;  \/\/ for exception processing\n+    ExceptionMark em(THREAD);\n+    Handle protection_domain(THREAD, the_class->protection_domain());\n@@ -1401,4 +1397,5 @@\n-    InstanceKlass* scratch_class = SystemDictionary::parse_stream(\n-                                                      the_class_sym,\n-                                                      the_class_loader,\n-                                                      &st,\n+    \/\/ Parse and create a class from the bytes, but this class isn't added\n+    \/\/ to the dictionary, so do not call resolve_from_stream.\n+    InstanceKlass* scratch_class = KlassFactory::create_from_stream(&st,\n+                                                      the_class->name(),\n+                                                      the_class->class_loader_data(),\n@@ -1407,0 +1404,1 @@\n+\n@@ -1419,1 +1417,1 @@\n-      log_info(redefine, class, load, exceptions)(\"parse_stream exception: '%s'\", ex_name->as_C_string());\n+      log_info(redefine, class, load, exceptions)(\"create_from_stream exception: '%s'\", ex_name->as_C_string());\n@@ -1656,1 +1654,1 @@\n-        ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_false);\n+        ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i);\n@@ -1662,1 +1660,1 @@\n-        ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_false);\n+        ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i);\n@@ -1701,2 +1699,1 @@\n-      bool match = scratch_cp->compare_entry_to(scratch_i, *merge_cp_p,\n-        scratch_i, CHECK_false);\n+      bool match = scratch_cp->compare_entry_to(scratch_i, *merge_cp_p, scratch_i);\n@@ -1716,2 +1713,1 @@\n-      int found_i = scratch_cp->find_matching_entry(scratch_i, *merge_cp_p,\n-        CHECK_false);\n+      int found_i = scratch_cp->find_matching_entry(scratch_i, *merge_cp_p);\n@@ -1737,2 +1733,1 @@\n-      append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,\n-        CHECK_false);\n+      append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p);\n@@ -1766,1 +1761,1 @@\n-        scratch_cp->find_matching_entry(scratch_i, *merge_cp_p, CHECK_false);\n+        scratch_cp->find_matching_entry(scratch_i, *merge_cp_p);\n@@ -1776,2 +1771,1 @@\n-      append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,\n-        CHECK_false);\n+      append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p);\n@@ -1784,1 +1778,1 @@\n-  finalize_operands_merge(*merge_cp_p, THREAD);\n+  finalize_operands_merge(*merge_cp_p, CHECK_false);\n@@ -1929,1 +1923,1 @@\n-    if (!rewrite_cp_refs(scratch_class, THREAD)) {\n+    if (!rewrite_cp_refs(scratch_class)) {\n@@ -1949,2 +1943,1 @@\n-bool VM_RedefineClasses::rewrite_cp_refs(InstanceKlass* scratch_class,\n-       TRAPS) {\n+bool VM_RedefineClasses::rewrite_cp_refs(InstanceKlass* scratch_class) {\n@@ -1959,1 +1952,1 @@\n-  if (!rewrite_cp_refs_in_record_attribute(scratch_class, THREAD)) {\n+  if (!rewrite_cp_refs_in_record_attribute(scratch_class)) {\n@@ -1971,1 +1964,1 @@\n-  if (!rewrite_cp_refs_in_methods(scratch_class, THREAD)) {\n+  if (!rewrite_cp_refs_in_methods(scratch_class)) {\n@@ -1977,1 +1970,1 @@\n-  if (!rewrite_cp_refs_in_class_annotations(scratch_class, THREAD)) {\n+  if (!rewrite_cp_refs_in_class_annotations(scratch_class)) {\n@@ -1983,1 +1976,1 @@\n-  if (!rewrite_cp_refs_in_fields_annotations(scratch_class, THREAD)) {\n+  if (!rewrite_cp_refs_in_fields_annotations(scratch_class)) {\n@@ -1989,1 +1982,1 @@\n-  if (!rewrite_cp_refs_in_methods_annotations(scratch_class, THREAD)) {\n+  if (!rewrite_cp_refs_in_methods_annotations(scratch_class)) {\n@@ -1995,2 +1988,1 @@\n-  if (!rewrite_cp_refs_in_methods_parameter_annotations(scratch_class,\n-         THREAD)) {\n+  if (!rewrite_cp_refs_in_methods_parameter_annotations(scratch_class)) {\n@@ -2002,2 +1994,1 @@\n-  if (!rewrite_cp_refs_in_methods_default_annotations(scratch_class,\n-         THREAD)) {\n+  if (!rewrite_cp_refs_in_methods_default_annotations(scratch_class)) {\n@@ -2009,1 +2000,1 @@\n-  if (!rewrite_cp_refs_in_class_type_annotations(scratch_class, THREAD)) {\n+  if (!rewrite_cp_refs_in_class_type_annotations(scratch_class)) {\n@@ -2015,1 +2006,1 @@\n-  if (!rewrite_cp_refs_in_fields_type_annotations(scratch_class, THREAD)) {\n+  if (!rewrite_cp_refs_in_fields_type_annotations(scratch_class)) {\n@@ -2021,1 +2012,1 @@\n-  if (!rewrite_cp_refs_in_methods_type_annotations(scratch_class, THREAD)) {\n+  if (!rewrite_cp_refs_in_methods_type_annotations(scratch_class)) {\n@@ -2069,2 +2060,1 @@\n-bool VM_RedefineClasses::rewrite_cp_refs_in_record_attribute(\n-       InstanceKlass* scratch_class, TRAPS) {\n+bool VM_RedefineClasses::rewrite_cp_refs_in_record_attribute(InstanceKlass* scratch_class) {\n@@ -2087,1 +2077,1 @@\n-        if (!rewrite_cp_refs_in_annotations_typeArray(annotations, byte_i, THREAD)) {\n+        if (!rewrite_cp_refs_in_annotations_typeArray(annotations, byte_i)) {\n@@ -2097,1 +2087,1 @@\n-        if (!rewrite_cp_refs_in_annotations_typeArray(type_annotations, byte_i, THREAD)) {\n+        if (!rewrite_cp_refs_in_annotations_typeArray(type_annotations, byte_i)) {\n@@ -2122,2 +2112,1 @@\n-bool VM_RedefineClasses::rewrite_cp_refs_in_methods(\n-       InstanceKlass* scratch_class, TRAPS) {\n+bool VM_RedefineClasses::rewrite_cp_refs_in_methods(InstanceKlass* scratch_class) {\n@@ -2132,0 +2121,3 @@\n+  Thread* THREAD = Thread::current();  \/\/ For exception processing\n+  ExceptionMark em(THREAD);\n+\n@@ -2303,2 +2295,1 @@\n-bool VM_RedefineClasses::rewrite_cp_refs_in_class_annotations(\n-       InstanceKlass* scratch_class, TRAPS) {\n+bool VM_RedefineClasses::rewrite_cp_refs_in_class_annotations(InstanceKlass* scratch_class) {\n@@ -2315,2 +2306,1 @@\n-  return rewrite_cp_refs_in_annotations_typeArray(class_annotations, byte_i,\n-           THREAD);\n+  return rewrite_cp_refs_in_annotations_typeArray(class_annotations, byte_i);\n@@ -2330,1 +2320,1 @@\n-       AnnotationArray* annotations_typeArray, int &byte_i_ref, TRAPS) {\n+       AnnotationArray* annotations_typeArray, int &byte_i_ref) {\n@@ -2346,2 +2336,1 @@\n-    if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,\n-           byte_i_ref, THREAD)) {\n+    if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray, byte_i_ref)) {\n@@ -2373,1 +2362,1 @@\n-       AnnotationArray* annotations_typeArray, int &byte_i_ref, TRAPS) {\n+       AnnotationArray* annotations_typeArray, int &byte_i_ref) {\n@@ -2381,1 +2370,1 @@\n-                    byte_i_ref, \"type_index\", THREAD);\n+                    byte_i_ref, \"type_index\");\n@@ -2402,1 +2391,1 @@\n-                              \"element_name_index\", THREAD);\n+                              \"element_name_index\");\n@@ -2406,2 +2395,1 @@\n-    if (!rewrite_cp_refs_in_element_value(annotations_typeArray,\n-           byte_i_ref, THREAD)) {\n+    if (!rewrite_cp_refs_in_element_value(annotations_typeArray, byte_i_ref)) {\n@@ -2426,1 +2414,1 @@\n-     const char * trace_mesg, TRAPS) {\n+     const char * trace_mesg) {\n@@ -2464,1 +2452,1 @@\n-       AnnotationArray* annotations_typeArray, int &byte_i_ref, TRAPS) {\n+       AnnotationArray* annotations_typeArray, int &byte_i_ref) {\n@@ -2502,1 +2490,1 @@\n-                               \"const_value_index\", THREAD);\n+                               \"const_value_index\");\n@@ -2519,1 +2507,1 @@\n-                             \"type_name_index\", THREAD);\n+                             \"type_name_index\");\n@@ -2523,1 +2511,1 @@\n-                              \"const_name_index\", THREAD);\n+                              \"const_name_index\");\n@@ -2541,1 +2529,1 @@\n-                              \"class_info_index\", THREAD);\n+                              \"class_info_index\");\n@@ -2549,2 +2537,1 @@\n-      if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,\n-             byte_i_ref, THREAD)) {\n+      if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray, byte_i_ref)) {\n@@ -2573,2 +2560,1 @@\n-        if (!rewrite_cp_refs_in_element_value(\n-               annotations_typeArray, byte_i_ref, THREAD)) {\n+        if (!rewrite_cp_refs_in_element_value(annotations_typeArray, byte_i_ref)) {\n@@ -2594,1 +2580,1 @@\n-       InstanceKlass* scratch_class, TRAPS) {\n+       InstanceKlass* scratch_class) {\n@@ -2613,2 +2599,1 @@\n-    if (!rewrite_cp_refs_in_annotations_typeArray(field_annotations, byte_i,\n-           THREAD)) {\n+    if (!rewrite_cp_refs_in_annotations_typeArray(field_annotations, byte_i)) {\n@@ -2627,1 +2612,1 @@\n-       InstanceKlass* scratch_class, TRAPS) {\n+       InstanceKlass* scratch_class) {\n@@ -2639,2 +2624,1 @@\n-    if (!rewrite_cp_refs_in_annotations_typeArray(method_annotations, byte_i,\n-           THREAD)) {\n+    if (!rewrite_cp_refs_in_annotations_typeArray(method_annotations, byte_i)) {\n@@ -2665,1 +2649,1 @@\n-       InstanceKlass* scratch_class, TRAPS) {\n+       InstanceKlass* scratch_class) {\n@@ -2691,2 +2675,1 @@\n-      if (!rewrite_cp_refs_in_annotations_typeArray(\n-             method_parameter_annotations, byte_i, THREAD)) {\n+      if (!rewrite_cp_refs_in_annotations_typeArray(method_parameter_annotations, byte_i)) {\n@@ -2714,1 +2697,1 @@\n-       InstanceKlass* scratch_class, TRAPS) {\n+       InstanceKlass* scratch_class) {\n@@ -2728,1 +2711,1 @@\n-           method_default_annotations, byte_i, THREAD)) {\n+           method_default_annotations, byte_i)) {\n@@ -2741,1 +2724,1 @@\n-       InstanceKlass* scratch_class, TRAPS) {\n+       InstanceKlass* scratch_class) {\n@@ -2753,1 +2736,1 @@\n-      byte_i, \"ClassFile\", THREAD);\n+      byte_i, \"ClassFile\");\n@@ -2758,2 +2741,1 @@\n-bool VM_RedefineClasses::rewrite_cp_refs_in_fields_type_annotations(\n-       InstanceKlass* scratch_class, TRAPS) {\n+bool VM_RedefineClasses::rewrite_cp_refs_in_fields_type_annotations(InstanceKlass* scratch_class) {\n@@ -2778,1 +2760,1 @@\n-           byte_i, \"field_info\", THREAD)) {\n+           byte_i, \"field_info\")) {\n@@ -2791,1 +2773,1 @@\n-       InstanceKlass* scratch_class, TRAPS) {\n+       InstanceKlass* scratch_class) {\n@@ -2806,1 +2788,1 @@\n-           byte_i, \"method_info\", THREAD)) {\n+           byte_i, \"method_info\")) {\n@@ -2829,1 +2811,1 @@\n-       const char * location_mesg, TRAPS) {\n+       const char * location_mesg) {\n@@ -2846,1 +2828,1 @@\n-           byte_i_ref, location_mesg, THREAD)) {\n+           byte_i_ref, location_mesg)) {\n@@ -2890,1 +2872,1 @@\n-       const char * location_mesg, TRAPS) {\n+       const char * location_mesg) {\n@@ -2893,1 +2875,1 @@\n-         byte_i_ref, location_mesg, THREAD)) {\n+         byte_i_ref, location_mesg)) {\n@@ -2897,2 +2879,1 @@\n-  if (!skip_type_annotation_type_path(type_annotations_typeArray,\n-         byte_i_ref, THREAD)) {\n+  if (!skip_type_annotation_type_path(type_annotations_typeArray, byte_i_ref)) {\n@@ -2902,2 +2883,1 @@\n-  if (!rewrite_cp_refs_in_annotation_struct(type_annotations_typeArray,\n-         byte_i_ref, THREAD)) {\n+  if (!rewrite_cp_refs_in_annotation_struct(type_annotations_typeArray, byte_i_ref)) {\n@@ -2930,1 +2910,1 @@\n-       const char * location_mesg, TRAPS) {\n+       const char * location_mesg) {\n@@ -3242,1 +3222,1 @@\n-       AnnotationArray* type_annotations_typeArray, int &byte_i_ref, TRAPS) {\n+       AnnotationArray* type_annotations_typeArray, int &byte_i_ref) {\n@@ -3297,1 +3277,1 @@\n-       const methodHandle& method, TRAPS) {\n+       const methodHandle& method) {\n@@ -3346,1 +3326,1 @@\n-        calc_number_of_entries, frame_type, THREAD);\n+        calc_number_of_entries, frame_type);\n@@ -3362,1 +3342,1 @@\n-        calc_number_of_entries, frame_type, THREAD);\n+        calc_number_of_entries, frame_type);\n@@ -3393,1 +3373,1 @@\n-          calc_number_of_entries, frame_type, THREAD);\n+          calc_number_of_entries, frame_type);\n@@ -3415,1 +3395,1 @@\n-          calc_number_of_entries, frame_type, THREAD);\n+          calc_number_of_entries, frame_type);\n@@ -3425,1 +3405,1 @@\n-          calc_number_of_entries, frame_type, THREAD);\n+          calc_number_of_entries, frame_type);\n@@ -3456,1 +3436,1 @@\n-       u1 frame_type, TRAPS) {\n+       u1 frame_type) {\n@@ -3725,1 +3705,1 @@\n-    rewrite_cp_refs_in_stack_map_table(method, THREAD);\n+    rewrite_cp_refs_in_stack_map_table(method);\n@@ -3815,1 +3795,1 @@\n-void VM_RedefineClasses::update_jmethod_ids(Thread* thread) {\n+void VM_RedefineClasses::update_jmethod_ids() {\n@@ -3821,2 +3801,2 @@\n-      methodHandle new_method_h(thread, _matching_new_methods[j]);\n-      Method::change_method_associated_with_jmethod_id(jmid, new_method_h());\n+      Method* new_method = _matching_new_methods[j];\n+      Method::change_method_associated_with_jmethod_id(jmid, new_method);\n@@ -4234,2 +4214,2 @@\n-void VM_RedefineClasses::redefine_single_class(jclass the_jclass,\n-       InstanceKlass* scratch_class, TRAPS) {\n+void VM_RedefineClasses::redefine_single_class(Thread* current, jclass the_jclass,\n+                                               InstanceKlass* scratch_class) {\n@@ -4237,1 +4217,1 @@\n-  HandleMark hm(THREAD);   \/\/ make sure handles from this call are freed\n+  HandleMark hm(current);   \/\/ make sure handles from this call are freed\n@@ -4259,1 +4239,1 @@\n-  update_jmethod_ids(THREAD);\n+  update_jmethod_ids();\n@@ -4400,3 +4380,2 @@\n-  the_class->vtable().initialize_vtable(false, THREAD);\n-  the_class->itable().initialize_itable(false, THREAD);\n-  assert(!HAS_PENDING_EXCEPTION || (THREAD->pending_exception()->is_a(vmClasses::ThreadDeath_klass())), \"redefine exception\");\n+  the_class->vtable().initialize_vtable();\n+  the_class->itable().initialize_itable();\n@@ -4448,1 +4427,1 @@\n-    AOTLoader::load_for_klass(the_class, THREAD);\n+    AOTLoader::load_for_klass(the_class, current);\n@@ -4465,1 +4444,1 @@\n-  increment_class_counter((InstanceKlass *)the_class, THREAD);\n+  increment_class_counter((InstanceKlass *)the_class);\n@@ -4476,1 +4455,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -4482,1 +4461,1 @@\n-    Events::log_redefinition(THREAD, \"redefined class name=%s, count=%d\",\n+    Events::log_redefinition(current, \"redefined class name=%s, count=%d\",\n@@ -4494,1 +4473,1 @@\n-void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik, TRAPS) {\n+void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik) {\n@@ -4511,1 +4490,1 @@\n-      increment_class_counter(subik, THREAD);\n+      increment_class_counter(subik);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":134,"deletions":155,"binary":false,"changes":289,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-      return init_method_MemberName(mname, info, THREAD);\n+      return init_method_MemberName(mname, info);\n@@ -227,1 +227,1 @@\n-      return init_method_MemberName(mname, info, THREAD);\n+      return init_method_MemberName(mname, info);\n@@ -233,1 +233,1 @@\n-oop MethodHandles::init_method_MemberName(Handle mname, CallInfo& info, TRAPS) {\n+oop MethodHandles::init_method_MemberName(Handle mname, CallInfo& info) {\n@@ -580,1 +580,1 @@\n-Symbol* MethodHandles::lookup_basic_type_signature(Symbol* sig, bool keep_last_arg, TRAPS) {\n+Symbol* MethodHandles::lookup_basic_type_signature(Symbol* sig, bool keep_last_arg) {\n@@ -807,1 +807,1 @@\n-      oop mname2 = init_method_MemberName(mname, result, THREAD);\n+      oop mname2 = init_method_MemberName(mname, result);\n@@ -833,1 +833,1 @@\n-      oop mname2 = init_method_MemberName(mname, result, THREAD);\n+      oop mname2 = init_method_MemberName(mname, result);\n@@ -1034,1 +1034,1 @@\n-        oop saved = MethodHandles::init_method_MemberName(result, info, THREAD);\n+        oop saved = MethodHandles::init_method_MemberName(result, info);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -536,0 +536,1 @@\n+      MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));\n@@ -587,0 +588,1 @@\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, Thread::current()));\n@@ -593,0 +595,1 @@\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, Thread::current()));\n@@ -1004,5 +1007,4 @@\n-  InstanceKlass* anonk = SystemDictionary::parse_stream(no_class_name,\n-                                                        host_loader,\n-                                                        &st,\n-                                                        cl_info,\n-                                                        CHECK_NULL);\n+  InstanceKlass* anonk = SystemDictionary::resolve_from_stream(&st, no_class_name,\n+                                                               host_loader,\n+                                                               cl_info,\n+                                                               CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+#include \"runtime\/stackFrameStream.inline.hpp\"\n@@ -838,0 +839,19 @@\n+static bool is_excluded_for_compiler(AbstractCompiler* comp, methodHandle& mh) {\n+  if (comp == NULL) {\n+    return true;\n+  }\n+  DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);\n+  if (directive->ExcludeOption) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+static bool can_be_compiled_at_level(methodHandle& mh, jboolean is_osr, int level) {\n+  if (is_osr) {\n+    return CompilationPolicy::can_be_osr_compiled(mh, level);\n+  } else {\n+    return CompilationPolicy::can_be_compiled(mh, level);\n+  }\n+}\n+\n@@ -846,4 +866,23 @@\n-  if (is_osr) {\n-    return CompilationPolicy::can_be_osr_compiled(mh, comp_level);\n-  } else {\n-    return CompilationPolicy::can_be_compiled(mh, comp_level);\n+\n+  \/\/ The ExcludeOption directive is evaluated lazily upon compilation attempt. If a method was not tried to be compiled by\n+  \/\/ a compiler, yet, the method object is not set to be not compilable by that compiler. Thus, evaluate the compiler directive\n+  \/\/ to exclude a compilation of 'method'.\n+  if (comp_level == CompLevel_any) {\n+    \/\/ Both compilers could have ExcludeOption set. Check all combinations.\n+    bool excluded_c1 = is_excluded_for_compiler(CompileBroker::compiler1(), mh);\n+    bool excluded_c2 = is_excluded_for_compiler(CompileBroker::compiler2(), mh);\n+    if (excluded_c1 && excluded_c2) {\n+      \/\/ Compilation of 'method' excluded by both compilers.\n+      return false;\n+    }\n+\n+    if (excluded_c1) {\n+      \/\/ C1 only has ExcludeOption set: Check if compilable with C2.\n+      return can_be_compiled_at_level(mh, is_osr, CompLevel_full_optimization);\n+    } else if (excluded_c2) {\n+      \/\/ C2 only has ExcludeOption set: Check if compilable with C1.\n+      return can_be_compiled_at_level(mh, is_osr, CompLevel_simple);\n+    }\n+  } else if (comp_level > CompLevel_none && is_excluded_for_compiler(CompileBroker::compiler((int)comp_level), mh)) {\n+    \/\/ Compilation of 'method' excluded by compiler used for 'comp_level'.\n+    return false;\n@@ -851,0 +890,2 @@\n+\n+  return can_be_compiled_at_level(mh, is_osr, (int)comp_level);\n@@ -1214,3 +1255,4 @@\n-WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))\n-  int result;\n-  if (GetVMFlag <JVM_FLAG_TYPE(int)> (thread, env, name, &result)) {\n+template <typename T, int type_enum>\n+jobject GetVMFlag_longBox(JNIEnv* env, JavaThread* thread, jstring name) {\n+  T result;\n+  if (GetVMFlag <T, type_enum> (thread, env, name, &result)) {\n@@ -1221,0 +1263,4 @@\n+}\n+\n+WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))\n+  return GetVMFlag_longBox<JVM_FLAG_TYPE(int)>(env, thread, name);\n@@ -1224,6 +1270,1 @@\n-  uint result;\n-  if (GetVMFlag <JVM_FLAG_TYPE(uint)> (thread, env, name, &result)) {\n-    ThreadToNativeFromVM ttnfv(thread);   \/\/ can't be in VM when we call JNI\n-    return longBox(thread, env, result);\n-  }\n-  return NULL;\n+  return GetVMFlag_longBox<JVM_FLAG_TYPE(uint)>(env, thread, name);\n@@ -1233,6 +1274,1 @@\n-  intx result;\n-  if (GetVMFlag <JVM_FLAG_TYPE(intx)> (thread, env, name, &result)) {\n-    ThreadToNativeFromVM ttnfv(thread);   \/\/ can't be in VM when we call JNI\n-    return longBox(thread, env, result);\n-  }\n-  return NULL;\n+  return GetVMFlag_longBox<JVM_FLAG_TYPE(intx)>(env, thread, name);\n@@ -1242,6 +1278,1 @@\n-  uintx result;\n-  if (GetVMFlag <JVM_FLAG_TYPE(uintx)> (thread, env, name, &result)) {\n-    ThreadToNativeFromVM ttnfv(thread);   \/\/ can't be in VM when we call JNI\n-    return longBox(thread, env, result);\n-  }\n-  return NULL;\n+  return GetVMFlag_longBox<JVM_FLAG_TYPE(uintx)>(env, thread, name);\n@@ -1251,6 +1282,1 @@\n-  uint64_t result;\n-  if (GetVMFlag <JVM_FLAG_TYPE(uint64_t)> (thread, env, name, &result)) {\n-    ThreadToNativeFromVM ttnfv(thread);   \/\/ can't be in VM when we call JNI\n-    return longBox(thread, env, result);\n-  }\n-  return NULL;\n+  return GetVMFlag_longBox<JVM_FLAG_TYPE(uint64_t)>(env, thread, name);\n@@ -1260,6 +1286,1 @@\n-  size_t result;\n-  if (GetVMFlag <JVM_FLAG_TYPE(size_t)> (thread, env, name, &result)) {\n-    ThreadToNativeFromVM ttnfv(thread);   \/\/ can't be in VM when we call JNI\n-    return longBox(thread, env, result);\n-  }\n-  return NULL;\n+  return GetVMFlag_longBox<JVM_FLAG_TYPE(size_t)>(env, thread, name);\n@@ -1338,2 +1359,1 @@\n-  ccstr ccstrResult = ccstrValue;\n-  bool needFree;\n+    ccstr param = ccstrValue;\n@@ -1342,1 +1362,3 @@\n-    needFree = SetVMFlag <JVM_FLAG_TYPE(ccstr)> (thread, env, name, &ccstrResult);\n+    if (SetVMFlag <JVM_FLAG_TYPE(ccstr)> (thread, env, name, &param)) {\n+      assert(param == NULL, \"old value is freed automatically and not returned\");\n+    }\n@@ -1347,3 +1369,0 @@\n-  if (needFree) {\n-    FREE_C_HEAP_ARRAY(char, ccstrResult);\n-  }\n@@ -1746,2 +1765,8 @@\n-WB_ENTRY(jlong, WB_MetaspaceReserveAlignment(JNIEnv* env, jobject wb))\n-  return (jlong)Metaspace::reserve_alignment();\n+\/\/ The function is only valid when CDS is available.\n+WB_ENTRY(jlong, WB_MetaspaceSharedRegionAlignment(JNIEnv* env, jobject wb))\n+#if INCLUDE_CDS\n+  return (jlong)MetaspaceShared::core_region_alignment();\n+#else\n+  ShouldNotReachHere();\n+  return 0L;\n+#endif\n@@ -2558,1 +2583,1 @@\n-  {CC\"metaspaceReserveAlignment\", CC\"()J\",            (void*)&WB_MetaspaceReserveAlignment },\n+  {CC\"metaspaceSharedRegionAlignment\", CC\"()J\",       (void*)&WB_MetaspaceSharedRegionAlignment },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":71,"deletions":46,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -541,0 +541,2 @@\n+  { \"AssertOnSuspendWaitFailure\",   JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"TraceSuspendWaitFailures\",     JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n@@ -807,1 +809,1 @@\n-  if (JVMFlagAccess::boolAtPut(flag, &value, origin) == JVMFlag::SUCCESS) {\n+  if (JVMFlagAccess::set_bool(flag, &value, origin) == JVMFlag::SUCCESS) {\n@@ -822,1 +824,1 @@\n-  if (JVMFlagAccess::doubleAtPut(flag, &v, origin) == JVMFlag::SUCCESS) {\n+  if (JVMFlagAccess::set_double(flag, &v, origin) == JVMFlag::SUCCESS) {\n@@ -854,1 +856,1 @@\n-    return JVMFlagAccess::intAtPut(flag, &int_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_int(flag, &int_v, origin) == JVMFlag::SUCCESS;\n@@ -857,1 +859,1 @@\n-    return JVMFlagAccess::uintAtPut(flag, &uint_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_uint(flag, &uint_v, origin) == JVMFlag::SUCCESS;\n@@ -863,1 +865,1 @@\n-    return JVMFlagAccess::intxAtPut(flag, &intx_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_intx(flag, &intx_v, origin) == JVMFlag::SUCCESS;\n@@ -866,1 +868,1 @@\n-    return JVMFlagAccess::uintxAtPut(flag, &uintx_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_uintx(flag, &uintx_v, origin) == JVMFlag::SUCCESS;\n@@ -869,1 +871,1 @@\n-    return JVMFlagAccess::uint64_tAtPut(flag, &uint64_t_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_uint64_t(flag, &uint64_t_v, origin) == JVMFlag::SUCCESS;\n@@ -872,1 +874,1 @@\n-    return JVMFlagAccess::size_tAtPut(flag, &size_t_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_size_t(flag, &size_t_v, origin) == JVMFlag::SUCCESS;\n@@ -875,1 +877,1 @@\n-    return JVMFlagAccess::doubleAtPut(flag, &double_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_double(flag, &double_v, origin) == JVMFlag::SUCCESS;\n@@ -882,1 +884,1 @@\n-  if (JVMFlagAccess::ccstrAtPut(flag, &value, origin) != JVMFlag::SUCCESS) return false;\n+  if (JVMFlagAccess::set_ccstr(flag, &value, origin) != JVMFlag::SUCCESS) return false;\n@@ -890,1 +892,1 @@\n-  if (JVMFlagAccess::ccstrAt(flag, &old_value) != JVMFlag::SUCCESS) return false;\n+  if (JVMFlagAccess::get_ccstr(flag, &old_value) != JVMFlag::SUCCESS) return false;\n@@ -907,1 +909,1 @@\n-  (void) JVMFlagAccess::ccstrAtPut(flag, &value, origin);\n+  (void) JVMFlagAccess::set_ccstr(flag, &value, origin);\n@@ -3150,1 +3152,8 @@\n-  if (ArchiveClassesAtExit == NULL) {\n+\n+  \/\/ RecordDynamicDumpInfo is not compatible with ArchiveClassesAtExit\n+  if (ArchiveClassesAtExit != NULL && RecordDynamicDumpInfo) {\n+    log_info(cds)(\"RecordDynamicDumpInfo is for jcmd only, could not set with -XX:ArchiveClassesAtExit.\");\n+    return JNI_ERR;\n+  }\n+\n+  if (ArchiveClassesAtExit == NULL && !RecordDynamicDumpInfo) {\n@@ -3152,0 +3161,2 @@\n+  } else {\n+    FLAG_SET_DEFAULT(DynamicDumpSharedSpaces, true);\n@@ -3153,0 +3164,1 @@\n+\n@@ -3474,1 +3486,1 @@\n-               UseCompressedOops ? \"%s%sclasses.jsa\": \"%s%sclasses_nocoops.jsa\",\n+               LP64_ONLY(!UseCompressedOops ? \"%s%sclasses_nocoops.jsa\":) \"%s%sclasses.jsa\",\n@@ -3533,0 +3545,5 @@\n+  } else {\n+    if (SharedDynamicArchivePath != nullptr) {\n+      os::free(SharedDynamicArchivePath);\n+      SharedDynamicArchivePath = nullptr;\n+    }\n@@ -4003,0 +4020,6 @@\n+  if (TraceDependencies && VerifyDependencies) {\n+    if (!FLAG_IS_DEFAULT(TraceDependencies)) {\n+      warning(\"TraceDependencies results may be inflated by VerifyDependencies\");\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":37,"deletions":14,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -734,1 +734,1 @@\n-void BiasedLocking::revoke_own_lock(Handle obj, TRAPS) {\n+void BiasedLocking::revoke_own_lock(JavaThread* current, Handle obj) {\n@@ -736,2 +736,0 @@\n-  JavaThread* thread = THREAD->as_Java_thread();\n-\n@@ -745,1 +743,1 @@\n-  assert(mark.biased_locker() == thread &&\n+  assert(mark.biased_locker() == current &&\n@@ -747,1 +745,1 @@\n-  ResourceMark rm;\n+  ResourceMark rm(current);\n@@ -750,2 +748,2 @@\n-  BiasedLocking::walk_stack_and_revoke(obj(), thread);\n-  thread->set_cached_monitor_info(NULL);\n+  BiasedLocking::walk_stack_and_revoke(obj(), current);\n+  current->set_cached_monitor_info(NULL);\n@@ -758,1 +756,1 @@\n-void BiasedLocking::revoke(Handle obj, TRAPS) {\n+void BiasedLocking::revoke(JavaThread* current, Handle obj) {\n@@ -824,1 +822,1 @@\n-      if (blt == THREAD) {\n+      if (blt == current) {\n@@ -832,1 +830,1 @@\n-        ResourceMark rm;\n+        ResourceMark rm(current);\n@@ -841,1 +839,1 @@\n-        BiasedLocking::Condition cond = single_revoke_with_handshake(obj, THREAD->as_Java_thread(), blt);\n+        BiasedLocking::Condition cond = single_revoke_with_handshake(obj, current, blt);\n@@ -850,2 +848,1 @@\n-      VM_BulkRevokeBias bulk_revoke(&obj, THREAD->as_Java_thread(),\n-                                    (heuristics == HR_BULK_REBIAS));\n+      VM_BulkRevokeBias bulk_revoke(&obj, current, (heuristics == HR_BULK_REBIAS));\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"runtime\/stackFrameStream.inline.hpp\"\n@@ -81,0 +82,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -163,1 +165,1 @@\n-JRT_BLOCK_ENTRY(Deoptimization::UnrollBlock*, Deoptimization::fetch_unroll_info(JavaThread* thread, int exec_mode))\n+JRT_BLOCK_ENTRY(Deoptimization::UnrollBlock*, Deoptimization::fetch_unroll_info(JavaThread* current, int exec_mode))\n@@ -169,1 +171,1 @@\n-    tty->print_cr(\"Deoptimizing thread \" INTPTR_FORMAT, p2i(thread));\n+    tty->print_cr(\"Deoptimizing thread \" INTPTR_FORMAT, p2i(current));\n@@ -171,1 +173,1 @@\n-  thread->inc_in_deopt_handler();\n+  current->inc_in_deopt_handler();\n@@ -177,1 +179,1 @@\n-    StackWatermarkSet::after_unwind(thread);\n+    StackWatermarkSet::after_unwind(current);\n@@ -180,1 +182,1 @@\n-  return fetch_unroll_info_helper(thread, exec_mode);\n+  return fetch_unroll_info_helper(current, exec_mode);\n@@ -184,1 +186,1 @@\n-static bool eliminate_allocations(JavaThread* thread, int exec_mode, CompiledMethod* compiled_method,\n+static bool rematerialize_objects(JavaThread* thread, int exec_mode, CompiledMethod* compiled_method,\n@@ -245,0 +247,1 @@\n+      JavaThread* current = thread; \/\/ For JRT_BLOCK\n@@ -272,2 +275,2 @@\n-static void eliminate_locks(JavaThread* thread, GrowableArray<compiledVFrame*>* chunk, bool realloc_failures,\n-                            frame& deoptee, int exec_mode, bool& deoptimized_objects) {\n+static void restore_eliminated_locks(JavaThread* thread, GrowableArray<compiledVFrame*>* chunk, bool realloc_failures,\n+                                     frame& deoptee, int exec_mode, bool& deoptimized_objects) {\n@@ -301,1 +304,1 @@\n-              if (monitor != NULL && (oop)monitor->object() == mi->owner()) {\n+              if (monitor != NULL && monitor->object() == mi->owner()) {\n@@ -333,2 +336,3 @@\n-  if (jvmci_enabled COMPILER2_PRESENT(|| (DoEscapeAnalysis && EliminateAllocations))) {\n-    realloc_failures = eliminate_allocations(thread, Unpack_none, cm, deoptee, map, chunk, deoptimized_objects);\n+  if (jvmci_enabled COMPILER2_PRESENT(|| (DoEscapeAnalysis && EliminateAllocations)\n+                                      || EliminateAutoBox || EnableVectorAggressiveReboxing)) {\n+    realloc_failures = rematerialize_objects(thread, Unpack_none, cm, deoptee, map, chunk, deoptimized_objects);\n@@ -345,1 +349,1 @@\n-    eliminate_locks(thread, chunk, realloc_failures, deoptee, Unpack_none, deoptimized_objects);\n+    restore_eliminated_locks(thread, chunk, realloc_failures, deoptee, Unpack_none, deoptimized_objects);\n@@ -352,1 +356,1 @@\n-Deoptimization::UnrollBlock* Deoptimization::fetch_unroll_info_helper(JavaThread* thread, int exec_mode) {\n+Deoptimization::UnrollBlock* Deoptimization::fetch_unroll_info_helper(JavaThread* current, int exec_mode) {\n@@ -356,1 +360,1 @@\n-  StackWatermarkSet::before_unwind(thread);\n+  StackWatermarkSet::before_unwind(current);\n@@ -364,3 +368,3 @@\n-  DeoptResourceMark* dmark = new DeoptResourceMark(thread);\n-  assert(thread->deopt_mark() == NULL, \"Pending deopt!\");\n-  thread->set_deopt_mark(dmark);\n+  DeoptResourceMark* dmark = new DeoptResourceMark(current);\n+  assert(current->deopt_mark() == NULL, \"Pending deopt!\");\n+  current->set_deopt_mark(dmark);\n@@ -368,3 +372,3 @@\n-  frame stub_frame = thread->last_frame(); \/\/ Makes stack walkable as side effect\n-  RegisterMap map(thread, true);\n-  RegisterMap dummy_map(thread, false);\n+  frame stub_frame = current->last_frame(); \/\/ Makes stack walkable as side effect\n+  RegisterMap map(current, true);\n+  RegisterMap dummy_map(current, false);\n@@ -374,1 +378,1 @@\n-  assert(thread->deopt_compiled_method() == NULL, \"Pending deopt!\");\n+  assert(current->deopt_compiled_method() == NULL, \"Pending deopt!\");\n@@ -376,1 +380,1 @@\n-  thread->set_deopt_compiled_method(cm);\n+  current->set_deopt_compiled_method(cm);\n@@ -379,1 +383,1 @@\n-    thread->validate_frame_layout();\n+    current->validate_frame_layout();\n@@ -386,1 +390,1 @@\n-  vframe* vf = vframe::new_vframe(&deoptee, &map, thread);\n+  vframe* vf = vframe::new_vframe(&deoptee, &map, current);\n@@ -398,5 +402,1 @@\n-#if INCLUDE_JVMCI\n-  bool jvmci_enabled = true;\n-#else\n-  bool jvmci_enabled = false;\n-#endif\n+  bool const jvmci_enabled = JVMCI_ONLY(EnableJVMCI) NOT_JVMCI(false);\n@@ -406,1 +406,2 @@\n-  if (jvmci_enabled COMPILER2_PRESENT( || (DoEscapeAnalysis && EliminateAllocations) )) {\n+  if (jvmci_enabled COMPILER2_PRESENT( || (DoEscapeAnalysis && EliminateAllocations)\n+                                       || EliminateAutoBox || EnableVectorAggressiveReboxing )) {\n@@ -408,1 +409,1 @@\n-    realloc_failures = eliminate_allocations(thread, exec_mode, cm, deoptee, map, chunk, unused);\n+    realloc_failures = rematerialize_objects(current, exec_mode, cm, deoptee, map, chunk, unused);\n@@ -414,1 +415,1 @@\n-  revoke_from_deopt_handler(thread, deoptee, &map);\n+  revoke_from_deopt_handler(current, deoptee, &map);\n@@ -424,1 +425,1 @@\n-      && !EscapeBarrier::objs_are_deoptimized(thread, deoptee.id())) {\n+      && !EscapeBarrier::objs_are_deoptimized(current, deoptee.id())) {\n@@ -426,1 +427,1 @@\n-    eliminate_locks(thread, chunk, realloc_failures, deoptee, exec_mode, unused);\n+    restore_eliminated_locks(current, chunk, realloc_failures, deoptee, exec_mode, unused);\n@@ -443,1 +444,1 @@\n-  vframeArray* array = create_vframeArray(thread, deoptee, &map, chunk, realloc_failures);\n+  vframeArray* array = create_vframeArray(current, deoptee, &map, chunk, realloc_failures);\n@@ -446,1 +447,1 @@\n-    pop_frames_failed_reallocs(thread, array);\n+    pop_frames_failed_reallocs(current, array);\n@@ -450,2 +451,2 @@\n-  assert(thread->vframe_array_head() == NULL, \"Pending deopt!\");\n-  thread->set_vframe_array_head(array);\n+  assert(current->vframe_array_head() == NULL, \"Pending deopt!\");\n+  current->set_vframe_array_head(array);\n@@ -457,1 +458,1 @@\n-  JvmtiDeferredUpdates::delete_updates_for_frame(thread, array->original().id());\n+  JvmtiDeferredUpdates::delete_updates_for_frame(current, array->original().id());\n@@ -503,2 +504,2 @@\n-  if (JvmtiExport::can_pop_frame() && thread->popframe_forcing_deopt_reexecution()) {\n-    popframe_extra_args = in_words(thread->popframe_preserved_args_size_in_words());\n+  if (JvmtiExport::can_pop_frame() && current->popframe_forcing_deopt_reexecution()) {\n+    popframe_extra_args = in_words(current->popframe_preserved_args_size_in_words());\n@@ -521,1 +522,1 @@\n-    methodHandle method(thread, deopt_sender.interpreter_frame_method());\n+    methodHandle method(current, deopt_sender.interpreter_frame_method());\n@@ -569,1 +570,1 @@\n-    methodHandle method(thread, array->element(0)->method());\n+    methodHandle method(current, array->element(0)->method());\n@@ -608,1 +609,1 @@\n-    thread->set_exception_oop(exceptionObject());\n+    current->set_exception_oop(exceptionObject());\n@@ -613,4 +614,4 @@\n-  if (thread->frames_to_pop_failed_realloc() > 0 && exec_mode != Unpack_uncommon_trap) {\n-    assert(thread->has_pending_exception(), \"should have thrown OOME\");\n-    thread->set_exception_oop(thread->pending_exception());\n-    thread->clear_pending_exception();\n+  if (current->frames_to_pop_failed_realloc() > 0 && exec_mode != Unpack_uncommon_trap) {\n+    assert(current->has_pending_exception(), \"should have thrown OOME\");\n+    current->set_exception_oop(current->pending_exception());\n+    current->clear_pending_exception();\n@@ -621,2 +622,2 @@\n-  if (thread->frames_to_pop_failed_realloc() > 0) {\n-    thread->set_pending_monitorenter(false);\n+  if (current->frames_to_pop_failed_realloc() > 0) {\n+    current->set_pending_monitorenter(false);\n@@ -929,1 +930,1 @@\n-#if INCLUDE_JVMCI || INCLUDE_AOT\n+#if COMPILER2_OR_JVMCI || INCLUDE_AOT\n@@ -1057,1 +1058,1 @@\n-#endif \/\/ INCLUDE_JVMCI || INCLUDE_AOT\n+#endif \/\/ COMPILER2_OR_JVMCI || INCLUDE_AOT\n@@ -1076,3 +1077,2 @@\n-#if INCLUDE_JVMCI || INCLUDE_AOT\n-      CompiledMethod* cm = fr->cb()->as_compiled_method_or_null();\n-      if (cm->is_compiled_by_jvmci() && sv->is_auto_box()) {\n+#if COMPILER2_OR_JVMCI || INCLUDE_AOT\n+      if (sv->is_auto_box()) {\n@@ -1086,1 +1086,1 @@\n-#endif \/\/ INCLUDE_JVMCI || INCLUDE_AOT\n+#endif \/\/ COMPILER2_OR_JVMCI || INCLUDE_AOT\n@@ -1481,1 +1481,1 @@\n-#if INCLUDE_JVMCI || INCLUDE_AOT\n+#if COMPILER2_OR_JVMCI || INCLUDE_AOT\n@@ -1486,1 +1486,1 @@\n-#endif \/\/ INCLUDE_JVMCI || INCLUDE_AOT\n+#endif \/\/ COMPILER2_OR_JVMCI || INCLUDE_AOT\n@@ -1489,1 +1489,15 @@\n-      continue; \/\/ skip field reassignment for vectors\n+      assert(sv->field_size() == 1, \"%s not a vector\", k->name()->as_C_string());\n+      ScopeValue* payload = sv->field_at(0);\n+      if (payload->is_location() &&\n+          payload->as_LocationValue()->location().type() == Location::vector) {\n+        if (PrintDeoptimizationDetails) {\n+          tty->print_cr(\"skip field reassignment for this vector - it should be assigned already\");\n+          if (Verbose) {\n+            Handle obj = sv->value();\n+            k->oop_print_on(obj(), tty);\n+          }\n+        }\n+        continue; \/\/ Such vector's value was already restored in VectorSupport::allocate_vector().\n+      }\n+      \/\/ Else fall-through to do assignment for scalar-replaced boxed vector representation\n+      \/\/ which could be restored after vector object allocation.\n@@ -1541,1 +1555,1 @@\n-            if (waiting_monitor != NULL && (oop)waiting_monitor->object() == obj()) {\n+            if (waiting_monitor != NULL && waiting_monitor->object() == obj()) {\n@@ -1728,1 +1742,1 @@\n-    BiasedLocking::revoke_own_lock(objects_to_revoke->at(i), thread);\n+    BiasedLocking::revoke_own_lock(thread, objects_to_revoke->at(i));\n@@ -1761,1 +1775,1 @@\n-    BiasedLocking::revoke(objects_to_revoke->at(i), thread);\n+    BiasedLocking::revoke(thread, objects_to_revoke->at(i));\n@@ -1907,1 +1921,1 @@\n-    Klass* tk = constant_pool->klass_at_ignore_error(index, THREAD);\n+    Klass* tk = constant_pool->klass_at(index, THREAD);\n@@ -1993,2 +2007,2 @@\n-JRT_ENTRY(void, Deoptimization::uncommon_trap_inner(JavaThread* thread, jint trap_request)) {\n-  HandleMark hm(thread);\n+JRT_ENTRY(void, Deoptimization::uncommon_trap_inner(JavaThread* current, jint trap_request)) {\n+  HandleMark hm(current);\n@@ -2000,1 +2014,1 @@\n-  thread->inc_in_deopt_handler();\n+  current->inc_in_deopt_handler();\n@@ -2005,1 +2019,1 @@\n-  RegisterMap reg_map(thread, true);\n+  RegisterMap reg_map(current, true);\n@@ -2007,1 +2021,1 @@\n-  RegisterMap reg_map(thread, UseBiasedLocking);\n+  RegisterMap reg_map(current, UseBiasedLocking);\n@@ -2009,1 +2023,1 @@\n-  frame stub_frame = thread->last_frame();\n+  frame stub_frame = current->last_frame();\n@@ -2016,1 +2030,1 @@\n-  Events::log_deopt_message(thread, \"Uncommon trap: trap_request=\" PTR32_FORMAT \" fr.pc=\" INTPTR_FORMAT \" relative=\" INTPTR_FORMAT,\n+  Events::log_deopt_message(current, \"Uncommon trap: trap_request=\" PTR32_FORMAT \" fr.pc=\" INTPTR_FORMAT \" relative=\" INTPTR_FORMAT,\n@@ -2029,1 +2043,1 @@\n-    vframe*  vf  = vframe::new_vframe(&fr, &reg_map, thread);\n+    vframe*  vf  = vframe::new_vframe(&fr, &reg_map, current);\n@@ -2045,1 +2059,1 @@\n-    methodHandle    trap_method(THREAD, trap_scope->method());\n+    methodHandle    trap_method(current, trap_scope->method());\n@@ -2048,1 +2062,1 @@\n-    jlong           speculation = thread->pending_failed_speculation();\n+    jlong           speculation = current->pending_failed_speculation();\n@@ -2050,1 +2064,1 @@\n-      nm->as_nmethod()->update_speculation(thread);\n+      nm->as_nmethod()->update_speculation(current);\n@@ -2057,1 +2071,1 @@\n-      thread->set_pending_monitorenter(true);\n+      current->set_pending_monitorenter(true);\n@@ -2061,1 +2075,1 @@\n-      thread->set_pending_transfer_to_interpreter(true);\n+      current->set_pending_transfer_to_interpreter(true);\n@@ -2076,1 +2090,1 @@\n-      profiled_method = methodHandle(THREAD, nm->method());\n+      profiled_method = methodHandle(current, nm->method());\n@@ -2085,1 +2099,1 @@\n-      get_method_data(thread, profiled_method, create_if_missing);\n+      get_method_data(current, profiled_method, create_if_missing);\n@@ -2090,1 +2104,1 @@\n-    Events::log_deopt_message(thread, \"Uncommon trap: reason=%s action=%s pc=\" INTPTR_FORMAT \" method=%s @ %d %s\",\n+    Events::log_deopt_message(current, \"Uncommon trap: reason=%s action=%s pc=\" INTPTR_FORMAT \" method=%s @ %d %s\",\n@@ -2113,1 +2127,1 @@\n-        constantPoolHandle constants (THREAD, trap_method->constants());\n+        constantPoolHandle constants (current, trap_method->constants());\n@@ -2190,1 +2204,1 @@\n-      constantPoolHandle constants(THREAD, trap_method->constants());\n+      constantPoolHandle constants(current, trap_method->constants());\n@@ -2302,1 +2316,1 @@\n-      assert(trap_mdo == get_method_data(thread, profiled_method, false), \"sanity\");\n+      assert(trap_mdo == get_method_data(current, profiled_method, false), \"sanity\");\n@@ -2543,1 +2557,4 @@\n-Deoptimization::UnrollBlock* Deoptimization::uncommon_trap(JavaThread* thread, jint trap_request, jint exec_mode) {\n+Deoptimization::UnrollBlock* Deoptimization::uncommon_trap(JavaThread* current, jint trap_request, jint exec_mode) {\n+  \/\/ Enable WXWrite: current function is called from methods compiled by C2 directly\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n+\n@@ -2550,1 +2567,1 @@\n-    uncommon_trap_inner(thread, trap_request);\n+    uncommon_trap_inner(current, trap_request);\n@@ -2552,2 +2569,2 @@\n-  HandleMark hm(thread);\n-  return fetch_unroll_info_helper(thread, exec_mode);\n+  HandleMark hm(current);\n+  return fetch_unroll_info_helper(current, exec_mode);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":103,"deletions":86,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-  static oop get_cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, TRAPS);\n@@ -170,0 +169,2 @@\n+  static oop get_cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, TRAPS);\n+\n@@ -280,1 +281,1 @@\n-  static UnrollBlock* fetch_unroll_info(JavaThread* thread, int exec_mode);\n+  static UnrollBlock* fetch_unroll_info(JavaThread* current, int exec_mode);\n@@ -305,1 +306,1 @@\n-  static UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index, jint exec_mode);\n+  static UnrollBlock* uncommon_trap(JavaThread* current, jint unloaded_class_index, jint exec_mode);\n@@ -307,1 +308,1 @@\n-  static void uncommon_trap_inner(JavaThread* thread, jint unloaded_class_index);\n+  static void uncommon_trap_inner(JavaThread* current, jint unloaded_class_index);\n@@ -472,1 +473,1 @@\n-  static UnrollBlock* fetch_unroll_info_helper(JavaThread* thread, int exec_mode);\n+  static UnrollBlock* fetch_unroll_info_helper(JavaThread* current, int exec_mode);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-        obj = (oop)(cast_from_oop<address>(obj) + field_offset);\n+        obj = cast_to_oop(cast_from_oop<address>(obj) + field_offset);\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -990,1 +991,1 @@\n-    oop *loc = _fr.oopmapreg_to_location(reg, _reg_map);\n+    oop *loc = _fr.oopmapreg_to_oop_location(reg, _reg_map);\n@@ -1041,1 +1042,1 @@\n-  oop* oop_adr = caller.oopmapreg_to_location(reg, reg_map);\n+  oop* oop_adr = caller.oopmapreg_to_oop_location(reg, reg_map);\n@@ -1282,11 +1283,0 @@\n-\n-\/\/-----------------------------------------------------------------------------------\n-\/\/ StackFrameStream implementation\n-\n-StackFrameStream::StackFrameStream(JavaThread *thread, bool update, bool process_frames) : _reg_map(thread, update, process_frames) {\n-  assert(thread->has_last_Java_frame(), \"sanity check\");\n-  _fr = thread->last_frame();\n-  _is_done = false;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/vmregTypes.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/registerMap.hpp\"\n@@ -46,0 +46,1 @@\n+class RegisterMap;\n@@ -367,1 +368,2 @@\n-  oop* oopmapreg_to_location(VMReg reg, const RegisterMap* reg_map) const;\n+  address oopmapreg_to_location(VMReg reg, const RegisterMap* reg_map) const;\n+  oop* oopmapreg_to_oop_location(VMReg reg, const RegisterMap* reg_map) const;\n@@ -453,35 +455,0 @@\n-\/\/\n-\/\/ StackFrameStream iterates through the frames of a thread starting from\n-\/\/ top most frame. It automatically takes care of updating the location of\n-\/\/ all (callee-saved) registers iff the update flag is set. It also\n-\/\/ automatically takes care of lazily applying deferred GC processing\n-\/\/ onto exposed frames, such that all oops are valid iff the process_frames\n-\/\/ flag is set.\n-\/\/\n-\/\/ Notice: If a thread is stopped at a safepoint, all registers are saved,\n-\/\/ not only the callee-saved ones.\n-\/\/\n-\/\/ Use:\n-\/\/\n-\/\/   for(StackFrameStream fst(thread, true \/* update *\/, true \/* process_frames *\/);\n-\/\/       !fst.is_done();\n-\/\/       fst.next()) {\n-\/\/     ...\n-\/\/   }\n-\/\/\n-class StackFrameStream : public StackObj {\n- private:\n-  frame       _fr;\n-  RegisterMap _reg_map;\n-  bool        _is_done;\n- public:\n-  StackFrameStream(JavaThread *thread, bool update, bool process_frames);\n-\n-  \/\/ Iteration\n-  inline bool is_done();\n-  void next()                     { if (!_is_done) _fr = _fr.sender(&_reg_map); }\n-\n-  \/\/ Query\n-  frame *current()                { return &_fr; }\n-  RegisterMap* register_map()     { return &_reg_map; }\n-};\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":4,"deletions":37,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -439,6 +439,0 @@\n-  product(bool, AssertOnSuspendWaitFailure, false,                          \\\n-          \"Assert\/Guarantee on external suspend wait failure\")              \\\n-                                                                            \\\n-  product(bool, TraceSuspendWaitFailures, false,                            \\\n-          \"Trace external suspend wait failures\")                           \\\n-                                                                            \\\n@@ -686,3 +680,0 @@\n-  develop(bool, MemProfiling, false,                                        \\\n-          \"Write memory usage profiling to log file\")                       \\\n-                                                                            \\\n@@ -692,0 +683,3 @@\n+  notproduct(bool, PrintClassLoaderDataGraphAtExit, false,                  \\\n+          \"Print the class loader data graph at exit\")                      \\\n+                                                                            \\\n@@ -1398,3 +1392,0 @@\n-  notproduct(intx, MemProfilingInterval, 500,                               \\\n-          \"Time between each invocation of the MemProfiler\")                \\\n-                                                                            \\\n@@ -1913,0 +1904,3 @@\n+  product(bool, RecordDynamicDumpInfo, false,                               \\\n+          \"Record class info for jcmd VM.cds dynamic_dump\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  oop* raw_value()                               { return _handle; }\n+  oop* raw_value() const                         { return _handle; }\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,1 @@\n+void AOTLoader_init();\n@@ -87,0 +88,1 @@\n+void dependencies_init();\n@@ -118,2 +120,3 @@\n-  VM_Version_init();\n-  VMRegImpl::set_regName();  \/\/ need this before generate_stubs (for printing oop maps).\n+  VM_Version_init();              \/\/ depends on codeCache_init for emitting code\n+  VMRegImpl::set_regName();       \/\/ need this before generate_stubs (for printing oop maps).\n+  AOTLoader_init();               \/\/ depends on VM_Version_init to adjust vm options\n@@ -144,0 +147,1 @@\n+  dependencies_init();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -82,1 +83,0 @@\n-\n@@ -112,0 +112,2 @@\n+\n+  MACOS_AARCH64_ONLY(_thread->enable_wx(WXExec));\n@@ -118,0 +120,2 @@\n+  MACOS_AARCH64_ONLY(_thread->enable_wx(WXWrite));\n+\n@@ -313,1 +317,1 @@\n-    return Handle(THREAD, (oop)factory_result.get_jobject());\n+    return Handle(THREAD, factory_result.get_oop());\n@@ -469,1 +473,1 @@\n-        thread->set_vm_result((oop) result->get_jobject());\n+        thread->set_vm_result(result->get_oop());\n@@ -480,1 +484,1 @@\n-    result->set_jobject(cast_from_oop<jobject>(thread->vm_result()));\n+    result->set_oop(thread->vm_result());\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-  JNIHandles::_global_handles = OopStorageSet::create_strong(\"JNI Global\");\n-  JNIHandles::_weak_global_handles = OopStorageSet::create_weak(\"JNI Weak\");\n+  JNIHandles::_global_handles = OopStorageSet::create_strong(\"JNI Global\", mtInternal);\n+  JNIHandles::_weak_global_handles = OopStorageSet::create_weak(\"JNI Weak\", mtInternal);\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,1 @@\n-    static void detach(char* addr, size_t bytes, TRAPS);\n+    static void detach(char* addr, size_t bytes);\n","filename":"src\/hotspot\/share\/runtime\/perfMemory.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -105,1 +104,1 @@\n-    return (oop) value->l;\n+    return cast_to_oop(value->l);\n@@ -279,1 +278,1 @@\n-      oop obj = (oop) value->l;\n+      oop obj = cast_to_oop(value->l);\n@@ -963,1 +962,1 @@\n-static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {\n+static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror) {\n@@ -1115,1 +1114,1 @@\n-      BasicType ptype = basic_type_mirror_to_basic_type(type_mirror, CHECK_NULL);\n+      BasicType ptype = basic_type_mirror_to_basic_type(type_mirror);\n@@ -1187,1 +1186,1 @@\n-    rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);\n+    rtype = basic_type_mirror_to_basic_type(return_type_mirror);\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -761,0 +762,3 @@\n+  \/\/ Enable WXWrite: the function is called implicitly from java code.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n@@ -999,1 +1003,1 @@\n-      ThreadInVMfromJavaNoAsyncException __tiv(self);\n+      ThreadInVMfromJava __tiv(self, false \/* check asyncs *\/);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-#include \"runtime\/arguments.hpp\"\n@@ -462,1 +461,1 @@\n-address SharedRuntime::raw_exception_handler_for_return_address(JavaThread* thread, address return_address) {\n+address SharedRuntime::raw_exception_handler_for_return_address(JavaThread* current, address return_address) {\n@@ -470,1 +469,1 @@\n-  assert(thread->frames_to_pop_failed_realloc() == 0 || Interpreter::contains(return_address), \"missed frames to pop?\");\n+  assert(current->frames_to_pop_failed_realloc() == 0 || Interpreter::contains(return_address), \"missed frames to pop?\");\n@@ -473,1 +472,1 @@\n-  thread->set_is_method_handle_return(false);\n+  current->set_is_method_handle_return(false);\n@@ -478,1 +477,1 @@\n-  thread->set_exception_pc(NULL);\n+  current->set_exception_pc(NULL);\n@@ -486,1 +485,1 @@\n-    thread->set_is_method_handle_return(nm->is_method_handle_return(return_address));\n+    current->set_is_method_handle_return(nm->is_method_handle_return(return_address));\n@@ -495,1 +494,1 @@\n-      StackOverflow* overflow_state = thread->stack_overflow_state();\n+      StackOverflow* overflow_state = current->stack_overflow_state();\n@@ -497,2 +496,2 @@\n-      if (overflow_state->reserved_stack_activation() != thread->stack_base()) {\n-        overflow_state->set_reserved_stack_activation(thread->stack_base());\n+      if (overflow_state->reserved_stack_activation() != current->stack_base()) {\n+        overflow_state->set_reserved_stack_activation(current->stack_base());\n@@ -541,2 +540,2 @@\n-JRT_LEAF(address, SharedRuntime::exception_handler_for_return_address(JavaThread* thread, address return_address))\n-  return raw_exception_handler_for_return_address(thread, return_address);\n+JRT_LEAF(address, SharedRuntime::exception_handler_for_return_address(JavaThread* current, address return_address))\n+  return raw_exception_handler_for_return_address(current, return_address);\n@@ -599,1 +598,1 @@\n-void SharedRuntime::throw_and_post_jvmti_exception(JavaThread *thread, Handle h_exception) {\n+void SharedRuntime::throw_and_post_jvmti_exception(JavaThread* current, Handle h_exception) {\n@@ -601,2 +600,2 @@\n-    vframeStream vfst(thread, true);\n-    methodHandle method = methodHandle(thread, vfst.method());\n+    vframeStream vfst(current, true);\n+    methodHandle method = methodHandle(current, vfst.method());\n@@ -604,1 +603,1 @@\n-    JvmtiExport::post_exception_throw(thread, method(), bcp, h_exception());\n+    JvmtiExport::post_exception_throw(current, method(), bcp, h_exception());\n@@ -609,2 +608,2 @@\n-    vframeStream vfst(thread, true);\n-    methodHandle method = methodHandle(thread, vfst.method());\n+    vframeStream vfst(current, true);\n+    methodHandle method = methodHandle(current, vfst.method());\n@@ -617,1 +616,1 @@\n-        ResourceMark rm(thread);\n+        ResourceMark rm(current);\n@@ -628,1 +627,1 @@\n-  Exceptions::_throw(thread, __FILE__, __LINE__, h_exception);\n+  Exceptions::_throw(current, __FILE__, __LINE__, h_exception);\n@@ -631,3 +630,3 @@\n-void SharedRuntime::throw_and_post_jvmti_exception(JavaThread *thread, Symbol* name, const char *message) {\n-  Handle h_exception = Exceptions::new_exception(thread, name, message);\n-  throw_and_post_jvmti_exception(thread, h_exception);\n+void SharedRuntime::throw_and_post_jvmti_exception(JavaThread* current, Symbol* name, const char *message) {\n+  Handle h_exception = Exceptions::new_exception(current, name, message);\n+  throw_and_post_jvmti_exception(current, h_exception);\n@@ -759,1 +758,1 @@\n-JRT_ENTRY(void, SharedRuntime::throw_AbstractMethodError(JavaThread* thread))\n+JRT_ENTRY(void, SharedRuntime::throw_AbstractMethodError(JavaThread* current))\n@@ -761,1 +760,1 @@\n-  throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_AbstractMethodError());\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_AbstractMethodError());\n@@ -764,1 +763,1 @@\n-JRT_ENTRY(void, SharedRuntime::throw_IncompatibleClassChangeError(JavaThread* thread))\n+JRT_ENTRY(void, SharedRuntime::throw_IncompatibleClassChangeError(JavaThread* current))\n@@ -766,1 +765,1 @@\n-  throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IncompatibleClassChangeError(), \"vtable stub\");\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_IncompatibleClassChangeError(), \"vtable stub\");\n@@ -769,2 +768,2 @@\n-JRT_ENTRY(void, SharedRuntime::throw_ArithmeticException(JavaThread* thread))\n-  throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArithmeticException(), \"\/ by zero\");\n+JRT_ENTRY(void, SharedRuntime::throw_ArithmeticException(JavaThread* current))\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_ArithmeticException(), \"\/ by zero\");\n@@ -773,2 +772,2 @@\n-JRT_ENTRY(void, SharedRuntime::throw_NullPointerException(JavaThread* thread))\n-  throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());\n+JRT_ENTRY(void, SharedRuntime::throw_NullPointerException(JavaThread* current))\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException(), NULL);\n@@ -777,1 +776,1 @@\n-JRT_ENTRY(void, SharedRuntime::throw_NullPointerException_at_call(JavaThread* thread))\n+JRT_ENTRY(void, SharedRuntime::throw_NullPointerException_at_call(JavaThread* current))\n@@ -780,1 +779,1 @@\n-  throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());\n+  throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException(), NULL);\n@@ -783,2 +782,2 @@\n-JRT_ENTRY(void, SharedRuntime::throw_StackOverflowError(JavaThread* thread))\n-  throw_StackOverflowError_common(thread, false);\n+JRT_ENTRY(void, SharedRuntime::throw_StackOverflowError(JavaThread* current))\n+  throw_StackOverflowError_common(current, false);\n@@ -787,2 +786,2 @@\n-JRT_ENTRY(void, SharedRuntime::throw_delayed_StackOverflowError(JavaThread* thread))\n-  throw_StackOverflowError_common(thread, true);\n+JRT_ENTRY(void, SharedRuntime::throw_delayed_StackOverflowError(JavaThread* current))\n+  throw_StackOverflowError_common(current, true);\n@@ -791,1 +790,1 @@\n-void SharedRuntime::throw_StackOverflowError_common(JavaThread* thread, bool delayed) {\n+void SharedRuntime::throw_StackOverflowError_common(JavaThread* current, bool delayed) {\n@@ -794,1 +793,1 @@\n-  Thread* THREAD = thread;\n+  Thread* THREAD = current; \/\/ For exception processing.\n@@ -801,1 +800,1 @@\n-  Handle exception (thread, exception_oop);\n+  Handle exception (current, exception_oop);\n@@ -807,1 +806,1 @@\n-  throw_and_post_jvmti_exception(thread, exception);\n+  throw_and_post_jvmti_exception(current, exception);\n@@ -810,1 +809,1 @@\n-address SharedRuntime::continuation_for_implicit_exception(JavaThread* thread,\n+address SharedRuntime::continuation_for_implicit_exception(JavaThread* current,\n@@ -836,2 +835,2 @@\n-        assert(thread->deopt_mark() == NULL, \"no stack overflow from deopt blob\/uncommon trap\");\n-        Events::log_exception(thread, \"StackOverflowError at \" INTPTR_FORMAT, p2i(pc));\n+        assert(current->deopt_mark() == NULL, \"no stack overflow from deopt blob\/uncommon trap\");\n+        Events::log_exception(current, \"StackOverflowError at \" INTPTR_FORMAT, p2i(pc));\n@@ -854,1 +853,1 @@\n-            Events::log_exception(thread, \"AbstractMethodError at \" INTPTR_FORMAT, p2i(pc));\n+            Events::log_exception(current, \"AbstractMethodError at \" INTPTR_FORMAT, p2i(pc));\n@@ -860,1 +859,1 @@\n-            Events::log_exception(thread, \"NullPointerException at vtable entry \" INTPTR_FORMAT, p2i(pc));\n+            Events::log_exception(current, \"NullPointerException at vtable entry \" INTPTR_FORMAT, p2i(pc));\n@@ -883,1 +882,1 @@\n-            Events::log_exception(thread, \"NullPointerException in code blob at \" INTPTR_FORMAT, p2i(pc));\n+            Events::log_exception(current, \"NullPointerException in code blob at \" INTPTR_FORMAT, p2i(pc));\n@@ -895,1 +894,1 @@\n-            Events::log_exception(thread, \"NullPointerException in IC check \" INTPTR_FORMAT, p2i(pc));\n+            Events::log_exception(current, \"NullPointerException in IC check \" INTPTR_FORMAT, p2i(pc));\n@@ -901,1 +900,1 @@\n-            Events::log_exception(thread, \"NullPointerException in MH adapter \" INTPTR_FORMAT, p2i(pc));\n+            Events::log_exception(current, \"NullPointerException in MH adapter \" INTPTR_FORMAT, p2i(pc));\n@@ -941,1 +940,1 @@\n-      Events::log_exception(thread, \"Implicit null exception at \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, p2i(pc), p2i(target_pc));\n+      Events::log_exception(current, \"Implicit null exception at \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, p2i(pc), p2i(target_pc));\n@@ -947,1 +946,1 @@\n-      Events::log_exception(thread, \"Implicit division by zero exception at \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, p2i(pc), p2i(target_pc));\n+      Events::log_exception(current, \"Implicit division by zero exception at \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, p2i(pc), p2i(target_pc));\n@@ -981,1 +980,1 @@\n-JRT_ENTRY_NO_ASYNC(void, SharedRuntime::register_finalizer(JavaThread* thread, oopDesc* obj))\n+JRT_ENTRY_NO_ASYNC(void, SharedRuntime::register_finalizer(JavaThread* current, oopDesc* obj))\n@@ -1023,1 +1022,1 @@\n-    JavaThread* thread, Method* method))\n+    JavaThread* current, Method* method))\n@@ -1029,1 +1028,1 @@\n-      get_java_tid(thread),\n+      get_java_tid(current),\n@@ -1037,1 +1036,1 @@\n-    JavaThread* thread, Method* method))\n+    JavaThread* current, Method* method))\n@@ -1043,1 +1042,1 @@\n-      get_java_tid(thread),\n+      get_java_tid(current),\n@@ -1055,2 +1054,3 @@\n-Handle SharedRuntime::find_callee_info(JavaThread* thread, Bytecodes::Code& bc, CallInfo& callinfo, TRAPS) {\n-  ResourceMark rm(THREAD);\n+Handle SharedRuntime::find_callee_info(Bytecodes::Code& bc, CallInfo& callinfo, TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n+  ResourceMark rm(current);\n@@ -1059,1 +1059,1 @@\n-  vframeStream vfst(thread, true);  \/\/ Do not skip and javaCalls\n+  vframeStream vfst(current, true);  \/\/ Do not skip and javaCalls\n@@ -1061,1 +1061,1 @@\n-  return find_callee_info_helper(thread, vfst, bc, callinfo, THREAD);\n+  return find_callee_info_helper(vfst, bc, callinfo, THREAD);\n@@ -1080,3 +1080,1 @@\n-Handle SharedRuntime::find_callee_info_helper(JavaThread* thread,\n-                                              vframeStream& vfst,\n-                                              Bytecodes::Code& bc,\n+Handle SharedRuntime::find_callee_info_helper(vframeStream& vfst, Bytecodes::Code& bc,\n@@ -1085,1 +1083,2 @@\n-  Handle nullHandle;  \/\/create a handy null handle for exception returns\n+  Handle nullHandle;  \/\/ create a handy null handle for exception returns\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -1090,1 +1089,1 @@\n-  methodHandle caller(THREAD, vfst.method());\n+  methodHandle caller(current, vfst.method());\n@@ -1112,1 +1111,1 @@\n-  methodHandle attached_method(THREAD, extract_attached_method(vfst));\n+  methodHandle attached_method(current, extract_attached_method(vfst));\n@@ -1147,1 +1146,1 @@\n-        attached_method = methodHandle(thread, NULL);\n+        attached_method = methodHandle(current, NULL);\n@@ -1163,2 +1162,2 @@\n-    RegisterMap reg_map2(thread);\n-    frame stubFrame   = thread->last_frame();\n+    RegisterMap reg_map2(current);\n+    frame stubFrame   = current->last_frame();\n@@ -1191,1 +1190,1 @@\n-      receiver = Handle(THREAD, callerFrame.retrieve_receiver(&reg_map2));\n+      receiver = Handle(current, callerFrame.retrieve_receiver(&reg_map2));\n@@ -1204,1 +1203,1 @@\n-    constantPoolHandle constants(THREAD, caller->constants());\n+    constantPoolHandle constants(current, caller->constants());\n@@ -1219,1 +1218,1 @@\n-      constantPoolHandle constants(THREAD, caller->constants());\n+      constantPoolHandle constants(current, caller->constants());\n@@ -1238,2 +1237,3 @@\n-methodHandle SharedRuntime::find_callee_method(JavaThread* thread, TRAPS) {\n-  ResourceMark rm(THREAD);\n+methodHandle SharedRuntime::find_callee_method(TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n+  ResourceMark rm(current);\n@@ -1243,1 +1243,1 @@\n-  vframeStream vfst(thread, true);  \/\/ Do not skip any javaCalls\n+  vframeStream vfst(current, true);  \/\/ Do not skip any javaCalls\n@@ -1249,2 +1249,2 @@\n-    RegisterMap reg_map(thread, false);\n-    frame fr = thread->last_frame();\n+    RegisterMap reg_map(current, false);\n+    frame fr = current->last_frame();\n@@ -1255,1 +1255,1 @@\n-    callee_method = methodHandle(THREAD, fr.entry_frame_call_wrapper()->callee_method());\n+    callee_method = methodHandle(current, fr.entry_frame_call_wrapper()->callee_method());\n@@ -1259,2 +1259,2 @@\n-    find_callee_info_helper(thread, vfst, bc, callinfo, CHECK_(methodHandle()));\n-    callee_method = methodHandle(THREAD, callinfo.selected_method());\n+    find_callee_info_helper(vfst, bc, callinfo, CHECK_(methodHandle()));\n+    callee_method = methodHandle(current, callinfo.selected_method());\n@@ -1267,4 +1267,1 @@\n-methodHandle SharedRuntime::resolve_helper(JavaThread *thread,\n-                                           bool is_virtual,\n-                                           bool is_optimized,\n-                                           bool* caller_is_c1, TRAPS) {\n+methodHandle SharedRuntime::resolve_helper(bool is_virtual, bool is_optimized, bool* caller_is_c1, TRAPS) {\n@@ -1272,1 +1269,1 @@\n-  callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, caller_is_c1, THREAD);\n+  callee_method = resolve_sub_helper(is_virtual, is_optimized, caller_is_c1, THREAD);\n@@ -1289,1 +1286,1 @@\n-      callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, caller_is_c1, THREAD);\n+      callee_method = resolve_sub_helper(is_virtual, is_optimized, caller_is_c1, THREAD);\n@@ -1388,8 +1385,5 @@\n-methodHandle SharedRuntime::resolve_sub_helper(JavaThread *thread,\n-                                               bool is_virtual,\n-                                               bool is_optimized,\n-                                               bool* caller_is_c1, TRAPS) {\n-\n-  ResourceMark rm(thread);\n-  RegisterMap cbl_map(thread, false);\n-  frame caller_frame = thread->last_frame().sender(&cbl_map);\n+methodHandle SharedRuntime::resolve_sub_helper(bool is_virtual, bool is_optimized, bool* caller_is_c1, TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n+  ResourceMark rm(current);\n+  RegisterMap cbl_map(current, false);\n+  frame caller_frame = current->last_frame().sender(&cbl_map);\n@@ -1412,3 +1406,2 @@\n-  Handle receiver = find_callee_info(thread, invoke_code,\n-                                     call_info, CHECK_(methodHandle()));\n-  methodHandle callee_method(THREAD, call_info.selected_method());\n+  Handle receiver = find_callee_info(invoke_code, call_info, CHECK_(methodHandle()));\n+  methodHandle callee_method(current, call_info.selected_method());\n@@ -1432,1 +1425,1 @@\n-    ResourceMark rm(thread);\n+    ResourceMark rm(current);\n@@ -1434,2 +1427,2 @@\n-      (is_optimized) ? \"optimized \" : \"\", (is_virtual) ? \"virtual\" : \"static\",\n-      Bytecodes::name(invoke_code));\n+               (is_optimized) ? \"optimized \" : \"\", (is_virtual) ? \"virtual\" : \"static\",\n+               Bytecodes::name(invoke_code));\n@@ -1444,1 +1437,1 @@\n-           callee_method->method_holder()->is_reentrant_initialization(thread),\n+           callee_method->method_holder()->is_reentrant_initialization(current),\n@@ -1492,1 +1485,1 @@\n-JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_ic_miss(JavaThread* thread))\n+JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_ic_miss(JavaThread* current))\n@@ -1494,2 +1487,2 @@\n-  RegisterMap reg_map(thread, false);\n-  frame stub_frame = thread->last_frame();\n+  RegisterMap reg_map(current, false);\n+  frame stub_frame = current->last_frame();\n@@ -1505,1 +1498,1 @@\n-    callee_method = SharedRuntime::handle_ic_miss_helper(thread, is_optimized, caller_is_c1, CHECK_NULL);\n+    callee_method = SharedRuntime::handle_ic_miss_helper(is_optimized, caller_is_c1, CHECK_NULL);\n@@ -1507,1 +1500,1 @@\n-    thread->set_vm_result_2(callee_method());\n+    current->set_vm_result_2(callee_method());\n@@ -1515,1 +1508,1 @@\n-JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method(JavaThread* thread))\n+JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method(JavaThread* current))\n@@ -1525,2 +1518,2 @@\n-  RegisterMap reg_map(thread, false);\n-  frame stub_frame = thread->last_frame();\n+  RegisterMap reg_map(current, false);\n+  frame stub_frame = current->last_frame();\n@@ -1532,1 +1525,1 @@\n-    Method* callee = thread->callee_target();\n+    Method* callee = current->callee_target();\n@@ -1534,2 +1527,2 @@\n-    thread->set_vm_result_2(callee);\n-    thread->set_callee_target(NULL);\n+    current->set_vm_result_2(callee);\n+    current->set_callee_target(NULL);\n@@ -1558,2 +1551,2 @@\n-    callee_method = SharedRuntime::reresolve_call_site(thread, is_static_call, is_optimized, caller_is_c1, CHECK_NULL);\n-    thread->set_vm_result_2(callee_method());\n+    callee_method = SharedRuntime::reresolve_call_site(is_static_call, is_optimized, caller_is_c1, CHECK_NULL);\n+    current->set_vm_result_2(callee_method());\n@@ -1566,1 +1559,1 @@\n-JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_abstract(JavaThread* thread))\n+JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_abstract(JavaThread* current))\n@@ -1569,1 +1562,1 @@\n-  vframeStream vfst(thread, true);\n+  vframeStream vfst(current, true);\n@@ -1571,1 +1564,1 @@\n-  methodHandle caller(thread, vfst.method());\n+  methodHandle caller(current, vfst.method());\n@@ -1576,2 +1569,2 @@\n-  RegisterMap reg_map(thread);\n-  frame stubFrame = thread->last_frame();\n+  RegisterMap reg_map(current);\n+  frame stubFrame = current->last_frame();\n@@ -1585,1 +1578,1 @@\n-    methodHandle callee(thread, invoke.static_target(thread));\n+    methodHandle callee(current, invoke.static_target(current));\n@@ -1589,1 +1582,1 @@\n-      LinkResolver::throw_abstract_method_error(callee, recv_klass, thread);\n+      LinkResolver::throw_abstract_method_error(callee, recv_klass, CHECK_(res));\n@@ -1598,1 +1591,1 @@\n-JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_static_call_C(JavaThread *thread ))\n+JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_static_call_C(JavaThread* current ))\n@@ -1602,2 +1595,2 @@\n-    callee_method = SharedRuntime::resolve_helper(thread, false, false, &caller_is_c1, CHECK_NULL);\n-    thread->set_vm_result_2(callee_method());\n+    callee_method = SharedRuntime::resolve_helper(false, false, &caller_is_c1, CHECK_NULL);\n+    current->set_vm_result_2(callee_method());\n@@ -1614,1 +1607,1 @@\n-JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_virtual_call_C(JavaThread *thread ))\n+JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_virtual_call_C(JavaThread* current))\n@@ -1618,2 +1611,2 @@\n-    callee_method = SharedRuntime::resolve_helper(thread, true, false, &caller_is_c1, CHECK_NULL);\n-    thread->set_vm_result_2(callee_method());\n+    callee_method = SharedRuntime::resolve_helper(true, false, &caller_is_c1, CHECK_NULL);\n+    current->set_vm_result_2(callee_method());\n@@ -1631,1 +1624,1 @@\n-JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_opt_virtual_call_C(JavaThread *thread))\n+JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_opt_virtual_call_C(JavaThread* current))\n@@ -1635,2 +1628,2 @@\n-    callee_method = SharedRuntime::resolve_helper(thread, true, true, &caller_is_c1, CHECK_NULL);\n-    thread->set_vm_result_2(callee_method());\n+    callee_method = SharedRuntime::resolve_helper(true, true, &caller_is_c1, CHECK_NULL);\n+    current->set_vm_result_2(callee_method());\n@@ -1727,2 +1720,3 @@\n-methodHandle SharedRuntime::handle_ic_miss_helper(JavaThread *thread, bool& is_optimized, bool& caller_is_c1, TRAPS) {\n-  ResourceMark rm(thread);\n+methodHandle SharedRuntime::handle_ic_miss_helper(bool& is_optimized, bool& caller_is_c1, TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n+  ResourceMark rm(current);\n@@ -1734,2 +1728,1 @@\n-  Handle receiver = find_callee_info(thread, bc, call_info,\n-                                     CHECK_(methodHandle()));\n+  Handle receiver = find_callee_info(bc, call_info, CHECK_(methodHandle()));\n@@ -1748,1 +1741,1 @@\n-    methodHandle callee_method = SharedRuntime::reresolve_call_site(thread, is_static_call, is_optimized, caller_is_c1, CHECK_(methodHandle()));\n+    methodHandle callee_method = SharedRuntime::reresolve_call_site(is_static_call, is_optimized, caller_is_c1, CHECK_(methodHandle()));\n@@ -1751,3 +1744,3 @@\n-      RegisterMap reg_map(thread, false);\n-      frame caller_frame = thread->last_frame().sender(&reg_map);\n-      ResourceMark rm(thread);\n+      RegisterMap reg_map(current, false);\n+      frame caller_frame = current->last_frame().sender(&reg_map);\n+      ResourceMark rm(current);\n@@ -1762,1 +1755,1 @@\n-  methodHandle callee_method(thread, call_info.selected_method());\n+  methodHandle callee_method(current, call_info.selected_method());\n@@ -1769,1 +1762,1 @@\n-    ResourceMark rm(thread);\n+    ResourceMark rm(current);\n@@ -1777,2 +1770,2 @@\n-    RegisterMap reg_map(thread, false);\n-    frame f = thread->last_frame().real_sender(&reg_map);\/\/ skip runtime stub\n+    RegisterMap reg_map(current, false);\n+    frame f = current->last_frame().real_sender(&reg_map);\/\/ skip runtime stub\n@@ -1795,2 +1788,2 @@\n-  RegisterMap reg_map(thread, false);\n-  frame caller_frame = thread->last_frame().sender(&reg_map);\n+  RegisterMap reg_map(current, false);\n+  frame caller_frame = current->last_frame().sender(&reg_map);\n@@ -1837,4 +1830,5 @@\n-methodHandle SharedRuntime::reresolve_call_site(JavaThread *thread, bool& is_static_call, bool& is_optimized, bool& caller_is_c1, TRAPS) {\n-  ResourceMark rm(thread);\n-  RegisterMap reg_map(thread, false);\n-  frame stub_frame = thread->last_frame();\n+methodHandle SharedRuntime::reresolve_call_site(bool& is_static_call, bool& is_optimized, bool& caller_is_c1, TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n+  ResourceMark rm(current);\n+  RegisterMap reg_map(current, false);\n+  frame stub_frame = current->last_frame();\n@@ -1922,1 +1916,1 @@\n-  methodHandle callee_method = find_callee_method(thread, CHECK_(methodHandle()));\n+  methodHandle callee_method = find_callee_method(CHECK_(methodHandle()));\n@@ -1928,1 +1922,1 @@\n-    ResourceMark rm(thread);\n+    ResourceMark rm(current);\n@@ -2092,1 +2086,1 @@\n-                                                JavaThread* thread)) {\n+                                                JavaThread* current)) {\n@@ -2108,1 +2102,1 @@\n-                                        length, thread);\n+                                        length, current);\n@@ -2180,1 +2174,1 @@\n-void SharedRuntime::monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread) {\n+void SharedRuntime::monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* current) {\n@@ -2184,1 +2178,1 @@\n-    if (ObjectSynchronizer::quick_enter(obj, thread, lock)) return;\n+    if (ObjectSynchronizer::quick_enter(obj, current, lock)) return;\n@@ -2195,1 +2189,1 @@\n-  ObjectSynchronizer::enter(h_obj, lock, CHECK);\n+  ObjectSynchronizer::enter(h_obj, lock, current);\n@@ -2201,2 +2195,2 @@\n-JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread))\n-  SharedRuntime::monitor_enter_helper(obj, lock, thread);\n+JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* current))\n+  SharedRuntime::monitor_enter_helper(obj, lock, current);\n@@ -2205,2 +2199,2 @@\n-void SharedRuntime::monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread) {\n-  assert(JavaThread::current() == thread, \"invariant\");\n+void SharedRuntime::monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* current) {\n+  assert(JavaThread::current() == current, \"invariant\");\n@@ -2208,1 +2202,1 @@\n-  EXCEPTION_MARK;\n+  ExceptionMark em(current);\n@@ -2217,1 +2211,1 @@\n-  ObjectSynchronizer::exit(obj, lock, THREAD);\n+  ObjectSynchronizer::exit(obj, lock, current);\n@@ -2221,2 +2215,2 @@\n-JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread))\n-  SharedRuntime::monitor_exit_helper(obj, lock, thread);\n+JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* current))\n+  SharedRuntime::monitor_exit_helper(obj, lock, current);\n@@ -3306,1 +3300,1 @@\n-JRT_LEAF(intptr_t*, SharedRuntime::OSR_migration_begin( JavaThread *thread) )\n+JRT_LEAF(intptr_t*, SharedRuntime::OSR_migration_begin( JavaThread *current) )\n@@ -3312,1 +3306,1 @@\n-  StackWatermarkSet::before_unwind(thread);\n+  StackWatermarkSet::before_unwind(current);\n@@ -3322,1 +3316,1 @@\n-  frame fr = thread->last_frame();\n+  frame fr = current->last_frame();\n@@ -3435,2 +3429,2 @@\n-JRT_LEAF(void, SharedRuntime::enable_stack_reserved_zone(JavaThread* thread))\n-  StackOverflow* overflow_state = thread->stack_overflow_state();\n+JRT_LEAF(void, SharedRuntime::enable_stack_reserved_zone(JavaThread* current))\n+  StackOverflow* overflow_state = current->stack_overflow_state();\n@@ -3438,1 +3432,1 @@\n-  overflow_state->set_reserved_stack_activation(thread->stack_base());\n+  overflow_state->set_reserved_stack_activation(current->stack_base());\n@@ -3441,2 +3435,2 @@\n-frame SharedRuntime::look_for_reserved_stack_annotated_method(JavaThread* thread, frame fr) {\n-  ResourceMark rm(thread);\n+frame SharedRuntime::look_for_reserved_stack_annotated_method(JavaThread* current, frame fr) {\n+  ResourceMark rm(current);\n@@ -3492,1 +3486,1 @@\n-void SharedRuntime::on_slowpath_allocation_exit(JavaThread* thread) {\n+void SharedRuntime::on_slowpath_allocation_exit(JavaThread* current) {\n@@ -3498,1 +3492,1 @@\n-  oop new_obj = thread->vm_result();\n+  oop new_obj = current->vm_result();\n@@ -3502,1 +3496,1 @@\n-  bs->on_slowpath_allocation_exit(thread, new_obj);\n+  bs->on_slowpath_allocation_exit(current, new_obj);\n@@ -3509,1 +3503,1 @@\n-oop SharedRuntime::allocate_inline_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS) {\n+oop SharedRuntime::allocate_inline_types_impl(JavaThread* current, methodHandle callee, bool allocate_receiver, TRAPS) {\n@@ -3544,5 +3538,5 @@\n-JRT_ENTRY(void, SharedRuntime::allocate_inline_types(JavaThread* thread, Method* callee_method, bool allocate_receiver))\n-  methodHandle callee(thread, callee_method);\n-  oop array = SharedRuntime::allocate_inline_types_impl(thread, callee, allocate_receiver, CHECK);\n-  thread->set_vm_result(array);\n-  thread->set_vm_result_2(callee()); \/\/ TODO: required to keep callee live?\n+JRT_ENTRY(void, SharedRuntime::allocate_inline_types(JavaThread* current, Method* callee_method, bool allocate_receiver))\n+  methodHandle callee(current, callee_method);\n+  oop array = SharedRuntime::allocate_inline_types_impl(current, callee, allocate_receiver, CHECK);\n+  current->set_vm_result(array);\n+  current->set_vm_result_2(callee()); \/\/ TODO: required to keep callee live?\n@@ -3554,1 +3548,1 @@\n-JRT_LEAF(void, SharedRuntime::apply_post_barriers(JavaThread* thread, objArrayOopDesc* array))\n+JRT_LEAF(void, SharedRuntime::apply_post_barriers(JavaThread* current, objArrayOopDesc* array))\n@@ -3578,1 +3572,1 @@\n-JRT_LEAF(void, SharedRuntime::load_inline_type_fields_in_regs(JavaThread* thread, oopDesc* res))\n+JRT_LEAF(void, SharedRuntime::load_inline_type_fields_in_regs(JavaThread* current, oopDesc* res))\n@@ -3582,2 +3576,2 @@\n-  RegisterMap reg_map(thread);\n-  frame stubFrame = thread->last_frame();\n+  RegisterMap reg_map(current);\n+  frame stubFrame = current->last_frame();\n@@ -3662,1 +3656,1 @@\n-  thread->set_vm_result(res);\n+  current->set_vm_result(res);\n@@ -3669,1 +3663,1 @@\n-JRT_BLOCK_ENTRY(void, SharedRuntime::store_inline_type_fields_to_buf(JavaThread* thread, intptr_t res))\n+JRT_BLOCK_ENTRY(void, SharedRuntime::store_inline_type_fields_to_buf(JavaThread* current, intptr_t res))\n@@ -3672,2 +3666,2 @@\n-  RegisterMap reg_map(thread);\n-  frame stubFrame = thread->last_frame();\n+  RegisterMap reg_map(current);\n+  frame stubFrame = current->last_frame();\n@@ -3684,1 +3678,1 @@\n-    thread->set_vm_result((oopDesc*)res);\n+    current->set_vm_result((oopDesc*)res);\n@@ -3702,1 +3696,1 @@\n-    Thread* THREAD = thread;\n+    Thread* THREAD = current;\n@@ -3704,1 +3698,1 @@\n-    thread->set_vm_result(vt);\n+    current->set_vm_result(vt);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":184,"deletions":190,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"interpreter\/bytecodeHistogram.hpp\"\n+#include \"code\/vmreg.hpp\"\n@@ -58,4 +58,1 @@\n-  static methodHandle resolve_sub_helper(JavaThread *thread,\n-                                         bool is_virtual,\n-                                         bool is_optimized,\n-                                         bool* caller_is_c1, TRAPS);\n+  static methodHandle resolve_sub_helper(bool is_virtual, bool is_optimized, bool* caller_is_c1, TRAPS);\n@@ -188,2 +185,2 @@\n-  static address raw_exception_handler_for_return_address(JavaThread* thread, address return_address);\n-  static address exception_handler_for_return_address(JavaThread* thread, address return_address);\n+  static address raw_exception_handler_for_return_address(JavaThread* current, address return_address);\n+  static address exception_handler_for_return_address(JavaThread* current, address return_address);\n@@ -199,9 +196,9 @@\n-  static void    throw_AbstractMethodError(JavaThread* thread);\n-  static void    throw_IncompatibleClassChangeError(JavaThread* thread);\n-  static void    throw_ArithmeticException(JavaThread* thread);\n-  static void    throw_NullPointerException(JavaThread* thread);\n-  static void    throw_NullPointerException_at_call(JavaThread* thread);\n-  static void    throw_StackOverflowError(JavaThread* thread);\n-  static void    throw_delayed_StackOverflowError(JavaThread* thread);\n-  static void    throw_StackOverflowError_common(JavaThread* thread, bool delayed);\n-  static address continuation_for_implicit_exception(JavaThread* thread,\n+  static void    throw_AbstractMethodError(JavaThread* current);\n+  static void    throw_IncompatibleClassChangeError(JavaThread* current);\n+  static void    throw_ArithmeticException(JavaThread* current);\n+  static void    throw_NullPointerException(JavaThread* current);\n+  static void    throw_NullPointerException_at_call(JavaThread* current);\n+  static void    throw_StackOverflowError(JavaThread* current);\n+  static void    throw_delayed_StackOverflowError(JavaThread* current);\n+  static void    throw_StackOverflowError_common(JavaThread* current, bool delayed);\n+  static address continuation_for_implicit_exception(JavaThread* current,\n@@ -213,1 +210,1 @@\n-  static void on_slowpath_allocation_exit(JavaThread* thread);\n+  static void on_slowpath_allocation_exit(JavaThread* current);\n@@ -215,2 +212,2 @@\n-  static void enable_stack_reserved_zone(JavaThread* thread);\n-  static frame look_for_reserved_stack_annotated_method(JavaThread* thread, frame fr);\n+  static void enable_stack_reserved_zone(JavaThread* current);\n+  static frame look_for_reserved_stack_annotated_method(JavaThread* current, frame fr);\n@@ -264,2 +261,2 @@\n-  static void throw_and_post_jvmti_exception(JavaThread *thread, Handle h_exception);\n-  static void throw_and_post_jvmti_exception(JavaThread *thread, Symbol* name, const char *message = NULL);\n+  static void throw_and_post_jvmti_exception(JavaThread* current, Handle h_exception);\n+  static void throw_and_post_jvmti_exception(JavaThread* current, Symbol* name, const char *message = NULL);\n@@ -321,4 +318,1 @@\n-  static methodHandle resolve_helper(JavaThread *thread,\n-                                     bool is_virtual,\n-                                     bool is_optimized,\n-                                     bool* caller_is_c1, TRAPS);\n+  static methodHandle resolve_helper(bool is_virtual, bool is_optimized, bool* caller_is_c1, TRAPS);\n@@ -338,1 +332,1 @@\n-  static methodHandle reresolve_call_site(JavaThread *thread, bool& is_static_call, bool& is_optimized, bool& caller_is_c1, TRAPS);\n+  static methodHandle reresolve_call_site(bool& is_static_call, bool& is_optimized, bool& caller_is_c1, TRAPS);\n@@ -342,1 +336,1 @@\n-  static methodHandle handle_ic_miss_helper(JavaThread* thread, bool& is_optimized, bool& caller_is_c1, TRAPS);\n+  static methodHandle handle_ic_miss_helper(bool& is_optimized, bool& caller_is_c1, TRAPS);\n@@ -345,1 +339,1 @@\n-  static methodHandle find_callee_method(JavaThread* thread, TRAPS);\n+  static methodHandle find_callee_method(TRAPS);\n@@ -349,1 +343,1 @@\n-  static void monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n+  static void monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* current);\n@@ -365,7 +359,2 @@\n-  static Handle find_callee_info(JavaThread* thread,\n-                                 Bytecodes::Code& bc,\n-                                 CallInfo& callinfo, TRAPS);\n-  static Handle find_callee_info_helper(JavaThread* thread,\n-                                        vframeStream& vfst,\n-                                        Bytecodes::Code& bc,\n-                                        CallInfo& callinfo, TRAPS);\n+  static Handle find_callee_info(Bytecodes::Code& bc, CallInfo& callinfo, TRAPS);\n+  static Handle find_callee_info_helper(vframeStream& vfst, Bytecodes::Code& bc, CallInfo& callinfo, TRAPS);\n@@ -524,2 +513,2 @@\n-  static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n-  static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n+  static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* current);\n+  static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* current);\n@@ -528,3 +517,3 @@\n-  static address resolve_static_call_C     (JavaThread *thread);\n-  static address resolve_virtual_call_C    (JavaThread *thread);\n-  static address resolve_opt_virtual_call_C(JavaThread *thread);\n+  static address resolve_static_call_C     (JavaThread* current);\n+  static address resolve_virtual_call_C    (JavaThread* current);\n+  static address resolve_opt_virtual_call_C(JavaThread* current);\n@@ -532,2 +521,2 @@\n-  static void load_inline_type_fields_in_regs(JavaThread *thread, oopDesc* res);\n-  static void store_inline_type_fields_to_buf(JavaThread *thread, intptr_t res);\n+  static void load_inline_type_fields_in_regs(JavaThread* current, oopDesc* res);\n+  static void store_inline_type_fields_to_buf(JavaThread* current, intptr_t res);\n@@ -542,6 +531,6 @@\n-  static address handle_wrong_method(JavaThread* thread);\n-  static address handle_wrong_method_abstract(JavaThread* thread);\n-  static address handle_wrong_method_ic_miss(JavaThread* thread);\n-  static void allocate_inline_types(JavaThread* thread, Method* callee, bool allocate_receiver);\n-  static oop allocate_inline_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS);\n-  static void apply_post_barriers(JavaThread* thread, objArrayOopDesc* array);\n+  static address handle_wrong_method(JavaThread* current);\n+  static address handle_wrong_method_abstract(JavaThread* current);\n+  static address handle_wrong_method_ic_miss(JavaThread* current);\n+  static void allocate_inline_types(JavaThread* current, Method* callee, bool allocate_receiver);\n+  static oop allocate_inline_types_impl(JavaThread* current, methodHandle callee, bool allocate_receiver, TRAPS);\n+  static void apply_post_barriers(JavaThread* current, objArrayOopDesc* array);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":38,"deletions":49,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -471,1 +471,1 @@\n-void ResolvingSignatureStream::cache_handles(TRAPS) {\n+void ResolvingSignatureStream::cache_handles() {\n@@ -473,2 +473,3 @@\n-  _class_loader = Handle(THREAD, _load_origin->class_loader());\n-  _protection_domain = Handle(THREAD, _load_origin->protection_domain());\n+  JavaThread* current = JavaThread::current();\n+  _class_loader = Handle(current, _load_origin->class_loader());\n+  _protection_domain = Handle(current, _load_origin->protection_domain());\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -386,2 +387,2 @@\n-    case T_SHORT:\n-    case T_INT:\n+      pass_byte();  _jni_offset++; _offset++;\n+      break;\n@@ -390,0 +391,4 @@\n+    case T_SHORT:\n+      pass_short();  _jni_offset++; _offset++;\n+      break;\n+    case T_INT:\n@@ -424,0 +429,2 @@\n+  virtual void pass_byte()             { pass_int(); };\n+  virtual void pass_short()            { pass_int(); };\n@@ -631,1 +638,1 @@\n-  void need_handles(TRAPS) {\n+  void need_handles() {\n@@ -633,1 +640,1 @@\n-      cache_handles(THREAD);\n+      cache_handles();\n@@ -637,1 +644,1 @@\n-  void cache_handles(TRAPS);\n+  void cache_handles();\n@@ -645,3 +652,3 @@\n-  Klass* load_origin()            { return _load_origin; }\n-  Handle class_loader(TRAPS)      { need_handles(THREAD); return _class_loader; }\n-  Handle protection_domain(TRAPS) { need_handles(THREAD); return _protection_domain; }\n+  Klass* load_origin()       { return _load_origin; }\n+  Handle class_loader()      { need_handles(); return _class_loader; }\n+  Handle protection_domain() { need_handles(); return _protection_domain; }\n@@ -651,1 +658,1 @@\n-    need_handles(THREAD);\n+    need_handles();\n@@ -657,1 +664,1 @@\n-      need_handles(THREAD);\n+      need_handles();\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -292,0 +292,2 @@\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n+\n@@ -365,0 +367,2 @@\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+\n@@ -522,2 +526,2 @@\n-#define RETURN_STUB_PARM(xxx_arraycopy, parm) {           \\\n-  name = #xxx_arraycopy; \\\n+#define RETURN_STUB_PARM(xxx_arraycopy, parm) { \\\n+  name = parm ? #xxx_arraycopy \"_uninit\": #xxx_arraycopy; \\\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-size_t MonitorList::unlink_deflated(Thread* self, LogStream* ls,\n+size_t MonitorList::unlink_deflated(Thread* current, LogStream* ls,\n@@ -127,1 +127,1 @@\n-    if (self->is_Java_thread()) {\n+    if (current->is_Java_thread()) {\n@@ -129,1 +129,1 @@\n-      ObjectSynchronizer::chk_for_block_req(self->as_Java_thread(), \"unlinking\",\n+      ObjectSynchronizer::chk_for_block_req(current->as_Java_thread(), \"unlinking\",\n@@ -244,0 +244,1 @@\n+\/\/ TODO The THREAD declarations below should be removed\n@@ -246,0 +247,1 @@\n+    JavaThread* THREAD = current;           \\\n@@ -251,1 +253,2 @@\n-    if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n+  if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n+    JavaThread* THREAD = current;             \\\n@@ -278,3 +281,2 @@\n-bool ObjectSynchronizer::quick_notify(oopDesc* obj, Thread* self, bool all) {\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  assert(self->as_Java_thread()->thread_state() == _thread_in_Java, \"invariant\");\n+bool ObjectSynchronizer::quick_notify(oopDesc* obj, JavaThread* current, bool all) {\n+  assert(current->thread_state() == _thread_in_Java, \"invariant\");\n@@ -286,1 +288,1 @@\n-  if (mark.has_locker() && self->is_lock_owned((address)mark.locker())) {\n+  if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n@@ -295,1 +297,1 @@\n-    if (mon->owner() != self) return false;  \/\/ slow-path for IMS exception\n+    if (mon->owner() != current) return false;  \/\/ slow-path for IMS exception\n@@ -302,1 +304,1 @@\n-        DTRACE_MONITOR_PROBE(notifyAll, mon, obj, self);\n+        DTRACE_MONITOR_PROBE(notifyAll, mon, obj, current);\n@@ -304,1 +306,1 @@\n-        DTRACE_MONITOR_PROBE(notify, mon, obj, self);\n+        DTRACE_MONITOR_PROBE(notify, mon, obj, current);\n@@ -308,1 +310,1 @@\n-        mon->INotify(self);\n+        mon->INotify(current);\n@@ -327,1 +329,1 @@\n-bool ObjectSynchronizer::quick_enter(oop obj, Thread* self,\n+bool ObjectSynchronizer::quick_enter(oop obj, JavaThread* current,\n@@ -329,2 +331,1 @@\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  assert(self->as_Java_thread()->thread_state() == _thread_in_Java, \"invariant\");\n+  assert(current->thread_state() == _thread_in_Java, \"invariant\");\n@@ -349,1 +350,1 @@\n-    Thread* const owner = (Thread *) m->owner_raw();\n+    JavaThread* const owner = (JavaThread*) m->owner_raw();\n@@ -356,1 +357,1 @@\n-    if (owner == self) {\n+    if (owner == current) {\n@@ -373,1 +374,1 @@\n-    if (owner == NULL && m->try_set_owner_from(NULL, self) == NULL) {\n+    if (owner == NULL && m->try_set_owner_from(NULL, current) == NULL) {\n@@ -390,4 +391,2 @@\n-void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, Thread* current) {\n-  JavaThread* self = current->as_Java_thread();\n-\n-  frame last_frame = self->last_frame();\n+void ObjectSynchronizer::handle_sync_on_value_based_class(Handle obj, JavaThread* current) {\n+  frame last_frame = current->last_frame();\n@@ -406,1 +405,1 @@\n-    ResourceMark rm(self);\n+    ResourceMark rm(current);\n@@ -408,1 +407,1 @@\n-    self->print_stack_on(&ss);\n+    current->print_stack_on(&ss);\n@@ -417,1 +416,1 @@\n-    ResourceMark rm(self);\n+    ResourceMark rm(current);\n@@ -421,1 +420,1 @@\n-    if (self->has_last_Java_frame()) {\n+    if (current->has_last_Java_frame()) {\n@@ -423,1 +422,1 @@\n-      self->print_stack_on(&info_stream);\n+      current->print_stack_on(&info_stream);\n@@ -446,1 +445,1 @@\n-void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, TRAPS) {\n+void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n@@ -449,1 +448,1 @@\n-    handle_sync_on_value_based_class(obj, THREAD);\n+    handle_sync_on_value_based_class(obj, current);\n@@ -453,5 +452,1 @@\n-    if (!SafepointSynchronize::is_at_safepoint()) {\n-      BiasedLocking::revoke(obj, THREAD);\n-    } else {\n-      BiasedLocking::revoke_at_safepoint(obj);\n-    }\n+    BiasedLocking::revoke(current, obj);\n@@ -472,1 +467,1 @@\n-             THREAD->is_lock_owned((address)mark.locker())) {\n+             current->is_lock_owned((address)mark.locker())) {\n@@ -488,2 +483,2 @@\n-    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_monitor_enter);\n-    if (monitor->enter(THREAD)) {\n+    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n+    if (monitor->enter(current)) {\n@@ -495,1 +490,1 @@\n-void ObjectSynchronizer::exit(oop object, BasicLock* lock, TRAPS) {\n+void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n@@ -517,1 +512,1 @@\n-             THREAD->is_lock_owned((address)mark.locker()), \"invariant\");\n+             current->is_lock_owned((address)mark.locker()), \"invariant\");\n@@ -529,1 +524,1 @@\n-        assert(m->is_entered(THREAD), \"invariant\");\n+        assert(m->is_entered(current), \"invariant\");\n@@ -548,2 +543,2 @@\n-  ObjectMonitor* monitor = inflate(THREAD, object, inflate_cause_vm_internal);\n-  monitor->exit(true, THREAD);\n+  ObjectMonitor* monitor = inflate(current, object, inflate_cause_vm_internal);\n+  monitor->exit(current);\n@@ -564,1 +559,1 @@\n-intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {\n+intx ObjectSynchronizer::complete_exit(Handle obj, JavaThread* current) {\n@@ -567,1 +562,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(current, obj);\n@@ -573,2 +568,2 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);\n-  intptr_t ret_code = monitor->complete_exit(THREAD);\n+  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_vm_internal);\n+  intptr_t ret_code = monitor->complete_exit(current);\n@@ -579,1 +574,1 @@\n-void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {\n+void ObjectSynchronizer::reenter(Handle obj, intx recursions, JavaThread* current) {\n@@ -582,1 +577,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(current, obj);\n@@ -591,2 +586,2 @@\n-    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);\n-    if (monitor->reenter(recursions, THREAD)) {\n+    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_vm_internal);\n+    if (monitor->reenter(recursions, current)) {\n@@ -601,1 +596,1 @@\n-void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {\n+void ObjectSynchronizer::jni_enter(Handle obj, JavaThread* current) {\n@@ -603,1 +598,1 @@\n-    handle_sync_on_value_based_class(obj, THREAD);\n+    handle_sync_on_value_based_class(obj, current);\n@@ -609,1 +604,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(current, obj);\n@@ -612,1 +607,1 @@\n-  THREAD->set_current_pending_monitor_is_from_java(false);\n+  current->set_current_pending_monitor_is_from_java(false);\n@@ -617,2 +612,2 @@\n-    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_jni_enter);\n-    if (monitor->enter(THREAD)) {\n+    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_jni_enter);\n+    if (monitor->enter(current)) {\n@@ -622,1 +617,1 @@\n-  THREAD->set_current_pending_monitor_is_from_java(true);\n+  current->set_current_pending_monitor_is_from_java(true);\n@@ -626,1 +621,2 @@\n-void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {\n+void ObjectSynchronizer::jni_exit(oop obj, TRAPS) {\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -629,2 +625,2 @@\n-    Handle h_obj(THREAD, obj);\n-    BiasedLocking::revoke(h_obj, THREAD);\n+    Handle h_obj(current, obj);\n+    BiasedLocking::revoke(current, h_obj);\n@@ -637,1 +633,1 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);\n+  ObjectMonitor* monitor = inflate(current, obj, inflate_cause_jni_exit);\n@@ -639,2 +635,2 @@\n-  \/\/ intentionally do not use CHECK here because we must exit the\n-  \/\/ monitor even if an exception is pending.\n+  \/\/ intentionally do not use CHECK on check_owner because we must exit the\n+  \/\/ monitor even if an exception was already pending.\n@@ -642,1 +638,1 @@\n-    monitor->exit(true, THREAD);\n+    monitor->exit(current);\n@@ -649,1 +645,1 @@\n-ObjectLocker::ObjectLocker(Handle obj, Thread* thread) {\n+ObjectLocker::ObjectLocker(Handle obj, JavaThread* thread) {\n@@ -670,0 +666,1 @@\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -672,1 +669,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(current, obj);\n@@ -681,1 +678,1 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);\n+  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_wait);\n@@ -683,2 +680,2 @@\n-  DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);\n-  monitor->wait(millis, true, THREAD);\n+  DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), current, millis);\n+  monitor->wait(millis, true, THREAD); \/\/ Not CHECK as we need following code\n@@ -694,1 +691,3 @@\n-void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {\n+\/\/ No exception are possible in this case as we only use this internally when locking is\n+\/\/ correct and we have to wait until notified - so no interrupts or timeouts.\n+void ObjectSynchronizer::wait_uninterruptibly(Handle obj, JavaThread* current) {\n@@ -697,1 +696,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(current, obj);\n@@ -700,3 +699,0 @@\n-  if (millis < 0) {\n-    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"timeout value is negative\");\n-  }\n@@ -706,2 +702,2 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);\n-  monitor->wait(millis, false, THREAD);\n+  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_wait);\n+  monitor->wait(0 \/* wait-forever *\/, false \/* not interruptible *\/, current);\n@@ -711,0 +707,1 @@\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -713,1 +710,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(current, obj);\n@@ -718,1 +715,2 @@\n-  if (mark.has_locker() && THREAD->is_lock_owned((address)mark.locker())) {\n+  if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n+    \/\/ Not inflated so there can't be any waiters to notify.\n@@ -723,2 +721,2 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);\n-  monitor->notify(THREAD);\n+  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_notify);\n+  monitor->notify(CHECK);\n@@ -729,0 +727,1 @@\n+  JavaThread* current = THREAD->as_Java_thread();\n@@ -731,1 +730,1 @@\n-    BiasedLocking::revoke(obj, THREAD);\n+    BiasedLocking::revoke(current, obj);\n@@ -736,1 +735,2 @@\n-  if (mark.has_locker() && THREAD->is_lock_owned((address)mark.locker())) {\n+  if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n+    \/\/ Not inflated so there can't be any waiters to notify.\n@@ -741,2 +741,2 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);\n-  monitor->notifyAll(THREAD);\n+  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_notify);\n+  monitor->notifyAll(CHECK);\n@@ -805,1 +805,1 @@\n-          \/\/ so we periodically call self->_ParkEvent->park(1).\n+          \/\/ so we periodically call current->_ParkEvent->park(1).\n@@ -838,1 +838,1 @@\n-static inline intptr_t get_next_hash(Thread* self, oop obj) {\n+static inline intptr_t get_next_hash(Thread* current, oop obj) {\n@@ -861,1 +861,1 @@\n-    unsigned t = self->_hashStateX;\n+    unsigned t = current->_hashStateX;\n@@ -863,4 +863,4 @@\n-    self->_hashStateX = self->_hashStateY;\n-    self->_hashStateY = self->_hashStateZ;\n-    self->_hashStateZ = self->_hashStateW;\n-    unsigned v = self->_hashStateW;\n+    current->_hashStateX = current->_hashStateY;\n+    current->_hashStateY = current->_hashStateZ;\n+    current->_hashStateZ = current->_hashStateW;\n+    unsigned v = current->_hashStateW;\n@@ -868,1 +868,1 @@\n-    self->_hashStateW = v;\n+    current->_hashStateW = v;\n@@ -878,1 +878,1 @@\n-intptr_t ObjectSynchronizer::FastHashCode(Thread* self, oop obj) {\n+intptr_t ObjectSynchronizer::FastHashCode(Thread* current, oop obj) {\n@@ -892,1 +892,1 @@\n-      Handle hobj(self, obj);\n+      Handle hobj(current, obj);\n@@ -896,1 +896,1 @@\n-        BiasedLocking::revoke(hobj, self);\n+        BiasedLocking::revoke(current->as_Java_thread(), hobj);\n@@ -912,1 +912,1 @@\n-    if (mark.is_neutral()) {            \/\/ if this is a normal header\n+    if (mark.is_neutral()) {               \/\/ if this is a normal header\n@@ -914,1 +914,1 @@\n-      if (hash != 0) {                  \/\/ if it has a hash, just return it\n+      if (hash != 0) {                     \/\/ if it has a hash, just return it\n@@ -917,3 +917,3 @@\n-      hash = get_next_hash(self, obj);  \/\/ get a new hash\n-      temp = mark.copy_set_hash(hash);  \/\/ merge the hash into header\n-                                        \/\/ try to install the hash\n+      hash = get_next_hash(current, obj);  \/\/ get a new hash\n+      temp = mark.copy_set_hash(hash);     \/\/ merge the hash into header\n+                                           \/\/ try to install the hash\n@@ -921,1 +921,1 @@\n-      if (test == mark) {               \/\/ if the hash was installed, return it\n+      if (test == mark) {                  \/\/ if the hash was installed, return it\n@@ -955,1 +955,1 @@\n-    } else if (self->is_lock_owned((address)mark.locker())) {\n+    } else if (current->is_lock_owned((address)mark.locker())) {\n@@ -978,1 +978,1 @@\n-    monitor = inflate(self, obj, inflate_cause_hash_code);\n+    monitor = inflate(current, obj, inflate_cause_hash_code);\n@@ -983,3 +983,3 @@\n-    if (hash == 0) {                    \/\/ if it does not have a hash\n-      hash = get_next_hash(self, obj);  \/\/ get a new hash\n-      temp = mark.copy_set_hash(hash);  \/\/ merge the hash into header\n+    if (hash == 0) {                       \/\/ if it does not have a hash\n+      hash = get_next_hash(current, obj);  \/\/ get a new hash\n+      temp = mark.copy_set_hash(hash)   ;  \/\/ merge the hash into header\n@@ -1013,1 +1013,1 @@\n-bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* thread,\n+bool ObjectSynchronizer::current_thread_holds_lock(JavaThread* current,\n@@ -1020,1 +1020,1 @@\n-    BiasedLocking::revoke(h_obj, thread);\n+    BiasedLocking::revoke(current, h_obj);\n@@ -1024,1 +1024,1 @@\n-  assert(thread == JavaThread::current(), \"Can only be called on current thread\");\n+  assert(current == JavaThread::current(), \"Can only be called on current thread\");\n@@ -1031,1 +1031,1 @@\n-    return thread->is_lock_owned((address)mark.locker());\n+    return current->is_lock_owned((address)mark.locker());\n@@ -1038,1 +1038,1 @@\n-    return monitor->is_entered(thread) != 0;\n+    return monitor->is_entered(current) != 0;\n@@ -1051,1 +1051,1 @@\n-      BiasedLocking::revoke(h_obj, JavaThread::current());\n+      BiasedLocking::revoke(JavaThread::current(), h_obj);\n@@ -1145,1 +1145,1 @@\n-  Atomic::add(&_in_use_list_ceiling, -AvgMonitorsPerThreadEstimate);\n+  Atomic::sub(&_in_use_list_ceiling, AvgMonitorsPerThreadEstimate);\n@@ -1174,1 +1174,1 @@\n-  Thread* self = Thread::current();\n+  JavaThread* current = JavaThread::current();\n@@ -1190,1 +1190,1 @@\n-    if (self->is_Java_thread()) {\n+    {\n@@ -1192,3 +1192,1 @@\n-      ThreadBlockInVM tbivm(self->as_Java_thread());\n-      os::naked_short_sleep(999);  \/\/ sleep for almost 1 second\n-    } else {\n+      ThreadBlockInVM tbivm(current);\n@@ -1232,1 +1230,1 @@\n-ObjectMonitor* ObjectSynchronizer::inflate(Thread* self, oop object,\n+ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop object,\n@@ -1333,1 +1331,1 @@\n-      \/\/ with this thread we could simply set m->_owner = self.\n+      \/\/ with this thread we could simply set m->_owner = current.\n@@ -1354,1 +1352,1 @@\n-        ResourceMark rm(self);\n+        ResourceMark rm(current);\n@@ -1371,1 +1369,1 @@\n-    \/\/ to inflate and then CAS() again to try to swing _owner from NULL to self.\n+    \/\/ to inflate and then CAS() again to try to swing _owner from NULL to current.\n@@ -1398,1 +1396,1 @@\n-      ResourceMark rm(self);\n+      ResourceMark rm(current);\n@@ -1410,1 +1408,1 @@\n-void ObjectSynchronizer::chk_for_block_req(JavaThread* self, const char* op_name,\n+void ObjectSynchronizer::chk_for_block_req(JavaThread* current, const char* op_name,\n@@ -1413,1 +1411,1 @@\n-  if (!SafepointMechanism::should_process(self)) {\n+  if (!SafepointMechanism::should_process(current)) {\n@@ -1428,1 +1426,1 @@\n-    ThreadBlockInVM tbivm(self);\n+    ThreadBlockInVM tbivm(current);\n@@ -1441,1 +1439,1 @@\n-size_t ObjectSynchronizer::deflate_monitor_list(Thread *self, LogStream* ls,\n+size_t ObjectSynchronizer::deflate_monitor_list(Thread* current, LogStream* ls,\n@@ -1455,1 +1453,1 @@\n-    if (self->is_Java_thread()) {\n+    if (current->is_Java_thread()) {\n@@ -1457,1 +1455,1 @@\n-      chk_for_block_req(self->as_Java_thread(), \"deflation\", \"deflated_count\",\n+      chk_for_block_req(current->as_Java_thread(), \"deflation\", \"deflated_count\",\n@@ -1479,2 +1477,2 @@\n-  Thread* self = Thread::current();\n-  if (self->is_Java_thread()) {\n+  Thread* current = Thread::current();\n+  if (current->is_Java_thread()) {\n@@ -1503,1 +1501,1 @@\n-  size_t deflated_count = deflate_monitor_list(self, ls, &timer);\n+  size_t deflated_count = deflate_monitor_list(current, ls, &timer);\n@@ -1513,1 +1511,1 @@\n-    size_t unlinked_count = _in_use_list.unlink_deflated(self, ls, &timer,\n+    size_t unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer,\n@@ -1515,1 +1513,1 @@\n-    if (self->is_Java_thread()) {\n+    if (current->is_Java_thread()) {\n@@ -1545,1 +1543,1 @@\n-      if (self->is_Java_thread()) {\n+      if (current->is_Java_thread()) {\n@@ -1547,1 +1545,1 @@\n-        chk_for_block_req(self->as_Java_thread(), \"deletion\", \"deleted_count\",\n+        chk_for_block_req(current->as_Java_thread(), \"deletion\", \"deleted_count\",\n@@ -1580,2 +1578,0 @@\n-\/\/ Gives up on a particular monitor if an exception occurs, but continues\n-\/\/ the overall iteration, swallowing the exception.\n@@ -1584,1 +1580,1 @@\n-  TRAPS;\n+  JavaThread* _thread;\n@@ -1587,1 +1583,1 @@\n-  ReleaseJavaMonitorsClosure(Thread* thread) : THREAD(thread) {}\n+  ReleaseJavaMonitorsClosure(JavaThread* thread) : _thread(thread) {}\n@@ -1589,2 +1585,2 @@\n-    if (mid->owner() == THREAD) {\n-      (void)mid->complete_exit(CHECK);\n+    if (mid->owner() == _thread) {\n+      (void)mid->complete_exit(_thread);\n@@ -1595,1 +1591,1 @@\n-\/\/ Release all inflated monitors owned by THREAD.  Lightweight monitors are\n+\/\/ Release all inflated monitors owned by current thread.  Lightweight monitors are\n@@ -1610,2 +1606,2 @@\n-void ObjectSynchronizer::release_monitors_owned_by_thread(TRAPS) {\n-  assert(THREAD == JavaThread::current(), \"must be current Java thread\");\n+void ObjectSynchronizer::release_monitors_owned_by_thread(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be current Java thread\");\n@@ -1613,1 +1609,1 @@\n-  ReleaseJavaMonitorsClosure rjmc(THREAD);\n+  ReleaseJavaMonitorsClosure rjmc(current);\n@@ -1615,1 +1611,2 @@\n-  THREAD->clear_pending_exception();\n+  assert(!current->has_pending_exception(), \"Should not be possible\");\n+  current->clear_pending_exception();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":144,"deletions":147,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -90,1 +91,0 @@\n-#include \"runtime\/memprofiler.hpp\"\n@@ -103,0 +103,1 @@\n+#include \"runtime\/stackFrameStream.inline.hpp\"\n@@ -110,0 +111,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -327,0 +329,2 @@\n+\n+  MACOS_AARCH64_ONLY(DEBUG_ONLY(_wx_init = false));\n@@ -390,0 +394,2 @@\n+  MACOS_AARCH64_ONLY(this->init_wx());\n+\n@@ -1201,0 +1207,3 @@\n+  _jvmci_reserved0(nullptr),\n+  _jvmci_reserved1(nullptr),\n+  _jvmci_reserved_oop0(nullptr),\n@@ -2161,0 +2170,3 @@\n+  \/\/ Enable WXWrite: called directly from interpreter native wrapper.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n@@ -2305,0 +2317,3 @@\n+#if INCLUDE_JVMCI\n+  f->do_oop((oop*) &_jvmci_reserved_oop0);\n+#endif\n@@ -3043,0 +3058,2 @@\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+\n@@ -3136,1 +3153,1 @@\n-  _thread_oop_storage = OopStorageSet::create_strong(\"Thread OopStorage\");\n+  _thread_oop_storage = OopStorageSet::create_strong(\"Thread OopStorage\", mtThread);\n@@ -3146,0 +3163,1 @@\n+  MACOS_AARCH64_ONLY(main_thread->init_wx());\n@@ -3368,1 +3386,0 @@\n-  if (MemProfiling)                   MemProfiler::engage();\n@@ -3405,1 +3422,1 @@\n-    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);\n+    MetaspaceShared::preload_and_dump();\n@@ -3686,1 +3703,1 @@\n-bool Threads::destroy_vm() {\n+void Threads::destroy_vm() {\n@@ -3779,2 +3796,0 @@\n-\n-  return true;\n@@ -3947,11 +3962,0 @@\n-void Threads::nmethods_do(CodeBlobClosure* cf) {\n-  ALL_JAVA_THREADS(p) {\n-    \/\/ This is used by the code cache sweeper to mark nmethods that are active\n-    \/\/ on the stack of a Java thread. Ignore the sweeper thread itself to avoid\n-    \/\/ marking CodeCacheSweeperThread::_scanned_compiled_method as active.\n-    if(!p->is_Code_cache_sweeper_thread()) {\n-      p->nmethods_do(cf);\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -175,0 +176,1 @@\n+  friend class ValidateHazardPtrsClosure;  \/\/ for get_threads_hazard_ptr(), untag_hazard_ptr() access\n@@ -179,1 +181,1 @@\n-  ThreadsList*          get_threads_hazard_ptr();\n+  ThreadsList*          get_threads_hazard_ptr() const;\n@@ -826,0 +828,9 @@\n+\n+#if defined(__APPLE__) && defined(AARCH64)\n+ private:\n+  DEBUG_ONLY(bool _wx_init);\n+  WXMode _wx_state;\n+ public:\n+  void init_wx();\n+  WXMode enable_wx(WXMode new_state);\n+#endif \/\/ __APPLE__ && AARCH64\n@@ -1020,0 +1031,5 @@\n+  \/\/ Fast thread locals for use by JVMCI\n+  intptr_t*  _jvmci_reserved0;\n+  intptr_t*  _jvmci_reserved1;\n+  oop        _jvmci_reserved_oop0;\n+\n@@ -1806,1 +1822,1 @@\n-  static bool destroy_vm();\n+  static void destroy_vm();\n@@ -1838,3 +1854,0 @@\n-  \/\/ Sweeper\n-  static void nmethods_do(CodeBlobClosure* cf);\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -354,1 +354,1 @@\n-          oop o = (oop)(address)(*addr);\n+          oop o = cast_to_oop((address)(*addr));\n@@ -392,1 +392,1 @@\n-          oop o = (oop)(address)(*addr);\n+          oop o = cast_to_oop((address)(*addr));\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -463,1 +463,1 @@\n-        Handle obj(Thread::current(), (oop)value.l);\n+        Handle obj(Thread::current(), cast_to_oop(value.l));\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  template(ShenandoahFinalRoots)                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+#include \"runtime\/stackFrameStream.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"oops\/klassVtable.hpp\"\n@@ -494,4 +495,0 @@\n-  volatile_nonstatic_field(BasicHashtable<mtInternal>,  _free_list,                           BasicHashtableEntry<mtInternal>*)      \\\n-  nonstatic_field(BasicHashtable<mtInternal>,  _first_free_entry,                             char*)                                 \\\n-  nonstatic_field(BasicHashtable<mtInternal>,  _end_block,                                    char*)                                 \\\n-  nonstatic_field(BasicHashtable<mtInternal>,  _entry_size,                                   int)                                   \\\n@@ -1885,0 +1882,1 @@\n+  declare_c2_type(VectorMaskCastNode, VectorNode)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -144,0 +144,3 @@\n+#if INCLUDE_CDS\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<DumpSharedArchiveDCmd>(full_export, true, false));\n+#endif \/\/ INCLUDE_CDS\n@@ -222,11 +225,0 @@\n-int HelpDCmd::num_arguments() {\n-  ResourceMark rm;\n-  HelpDCmd* dcmd = new HelpDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -261,11 +253,0 @@\n-int PrintVMFlagsDCmd::num_arguments() {\n-    ResourceMark rm;\n-    PrintVMFlagsDCmd* dcmd = new PrintVMFlagsDCmd(NULL, false);\n-    if (dcmd != NULL) {\n-      DCmdMark mark(dcmd);\n-      return dcmd->_dcmdparser.num_arguments();\n-    } else {\n-      return 0;\n-    }\n-}\n-\n@@ -295,11 +276,0 @@\n-int SetVMFlagDCmd::num_arguments() {\n-  ResourceMark rm;\n-  SetVMFlagDCmd* dcmd = new SetVMFlagDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -363,10 +333,0 @@\n-int JVMTIAgentLoadDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JVMTIAgentLoadDCmd* dcmd = new JVMTIAgentLoadDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n@@ -410,1 +370,1 @@\n-  oop res = (oop)result.get_jobject();\n+  oop res = result.get_oop();\n@@ -435,11 +395,0 @@\n-int VMUptimeDCmd::num_arguments() {\n-  ResourceMark rm;\n-  VMUptimeDCmd* dcmd = new VMUptimeDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -482,1 +431,1 @@\n-  objArrayOop result_oop = (objArrayOop) result.get_jobject();\n+  objArrayOop result_oop = (objArrayOop) result.get_oop();\n@@ -547,11 +496,0 @@\n-int HeapDumpDCmd::num_arguments() {\n-  ResourceMark rm;\n-  HeapDumpDCmd* dcmd = new HeapDumpDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -571,11 +509,0 @@\n-int ClassHistogramDCmd::num_arguments() {\n-  ResourceMark rm;\n-  ClassHistogramDCmd* dcmd = new ClassHistogramDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -606,11 +533,0 @@\n-int ThreadDumpDCmd::num_arguments() {\n-  ResourceMark rm;\n-  ThreadDumpDCmd* dcmd = new ThreadDumpDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -732,13 +648,0 @@\n-\n-int JMXStartRemoteDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JMXStartRemoteDCmd* dcmd = new JMXStartRemoteDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n-\n@@ -873,1 +776,1 @@\n-  oop str = (oop) jv->l;\n+  oop str = cast_to_oop(jv->l);\n@@ -932,11 +835,0 @@\n-\n-int CodeHeapAnalyticsDCmd::num_arguments() {\n-  ResourceMark rm;\n-  CodeHeapAnalyticsDCmd* dcmd = new CodeHeapAnalyticsDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n@@ -973,11 +865,0 @@\n-int EventLogDCmd::num_arguments() {\n-  ResourceMark rm;\n-  EventLogDCmd* dcmd = new EventLogDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -998,11 +879,0 @@\n-int CompilerDirectivesAddDCmd::num_arguments() {\n-  ResourceMark rm;\n-  CompilerDirectivesAddDCmd* dcmd = new CompilerDirectivesAddDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -1036,11 +906,0 @@\n-int ClassHierarchyDCmd::num_arguments() {\n-  ResourceMark rm;\n-  ClassHierarchyDCmd* dcmd = new ClassHierarchyDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -1087,4 +946,0 @@\n-TouchedMethodsDCmd::TouchedMethodsDCmd(outputStream* output, bool heap) :\n-                                       DCmdWithParser(output, heap)\n-{}\n-\n@@ -1100,2 +955,8 @@\n-int TouchedMethodsDCmd::num_arguments() {\n-  return 0;\n+#if INCLUDE_CDS\n+DumpSharedArchiveDCmd::DumpSharedArchiveDCmd(outputStream* output, bool heap) :\n+                                     DCmdWithParser(output, heap),\n+  _suboption(\"subcmd\", \"static_dump | dynamic_dump\", \"STRING\", true),\n+  _filename(\"filename\", \"Name of shared archive to be dumped\", \"STRING\", false)\n+{\n+  _dcmdparser.add_dcmd_argument(&_suboption);\n+  _dcmdparser.add_dcmd_argument(&_filename);\n@@ -1104,0 +965,43 @@\n+void DumpSharedArchiveDCmd::execute(DCmdSource source, TRAPS) {\n+  jboolean is_static;\n+  const char* scmd = _suboption.value();\n+  const char* file = _filename.value();\n+\n+  if (strcmp(scmd, \"static_dump\") == 0) {\n+    is_static = JNI_TRUE;\n+    output()->print_cr(\"Static dump:\");\n+  } else if (strcmp(scmd, \"dynamic_dump\") == 0) {\n+    is_static = JNI_FALSE;\n+    output()->print_cr(\"Dynamic dump:\");\n+    if (!UseSharedSpaces) {\n+      output()->print_cr(\"Dynamic dump is unsupported when base CDS archive is not loaded\");\n+      return;\n+    }\n+    if (!RecordDynamicDumpInfo) {\n+      output()->print_cr(\"Dump dynamic should run with -XX:+RecordDynamicDumpInfo\");\n+      return;\n+    }\n+  } else {\n+    output()->print_cr(\"Invalid command for VM.cds, valid input is static_dump or dynamic_dump\");\n+    return;\n+  }\n+\n+  \/\/ call CDS.dumpSharedArchive\n+  Handle fileh;\n+  if (file != NULL) {\n+    fileh =  java_lang_String::create_from_str(_filename.value(), CHECK);\n+  }\n+  Symbol* cds_name  = vmSymbols::jdk_internal_misc_CDS();\n+  Klass*  cds_klass = SystemDictionary::resolve_or_fail(cds_name, true \/*throw error*\/,  CHECK);\n+  JavaValue result(T_VOID);\n+  JavaCallArguments args;\n+  args.push_int(is_static);\n+  args.push_oop(fileh);\n+  JavaCalls::call_static(&result,\n+                         cds_klass,\n+                         vmSymbols::dumpSharedArchive(),\n+                         vmSymbols::dumpSharedArchive_signature(),\n+                         &args, CHECK);\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -1109,3 +1013,0 @@\n-DebugOnCmdStartDCmd::DebugOnCmdStartDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap) {\n-}\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":57,"deletions":156,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-  static int num_arguments();\n@@ -72,1 +71,0 @@\n-  static int num_arguments() { return 0; }\n@@ -89,1 +87,0 @@\n-  static int num_arguments() { return 0; }\n@@ -111,1 +108,0 @@\n-    static int num_arguments() { return 0; }\n@@ -133,1 +129,0 @@\n-  static int num_arguments();\n@@ -156,1 +151,0 @@\n-  static int num_arguments();\n@@ -175,1 +169,0 @@\n-  static int num_arguments() { return 0; }\n@@ -197,1 +190,0 @@\n-  static int num_arguments();\n@@ -220,3 +212,0 @@\n-  static int num_arguments() {\n-    return 0;\n-  };\n@@ -238,1 +227,0 @@\n-  static int num_arguments();\n@@ -255,1 +243,0 @@\n-  static int num_arguments() { return 0; }\n@@ -269,1 +256,0 @@\n-    static int num_arguments() { return 0; }\n@@ -283,1 +269,0 @@\n-    static int num_arguments() { return 0; }\n@@ -297,1 +282,0 @@\n-  static int num_arguments() { return 0; }\n@@ -317,1 +301,0 @@\n-  static int num_arguments() { return 0; }\n@@ -351,1 +334,0 @@\n-  static int num_arguments();\n@@ -376,1 +358,0 @@\n-  static int num_arguments();\n@@ -403,1 +384,0 @@\n-  static int num_arguments();\n@@ -432,2 +412,1 @@\n-\n-class TouchedMethodsDCmd : public DCmdWithParser {\n+class TouchedMethodsDCmd : public DCmd {\n@@ -435,1 +414,1 @@\n-  TouchedMethodsDCmd(outputStream* output, bool heap);\n+  TouchedMethodsDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n@@ -445,0 +424,24 @@\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+#if INCLUDE_CDS\n+class DumpSharedArchiveDCmd: public DCmdWithParser {\n+protected:\n+  DCmdArgument<char*> _suboption;   \/\/ option of VM.cds\n+  DCmdArgument<char*> _filename;    \/\/ file name, optional\n+public:\n+  DumpSharedArchiveDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"VM.cds\";\n+  }\n+  static const char* description() {\n+    return \"Dump a static or dynamic shared archive including all shareable classes\";\n+  }\n+  static const char* impact() {\n+    return \"Medium: Pause time depends on number of loaded classes\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n@@ -448,0 +451,1 @@\n+#endif \/\/ INCLUDE_CDS\n@@ -468,1 +472,0 @@\n-  static int num_arguments();\n@@ -517,3 +520,0 @@\n-  static int num_arguments();\n-\n-\n@@ -602,1 +602,0 @@\n-  static int num_arguments() { return 0; }\n@@ -624,1 +623,0 @@\n-  static int num_arguments() { return 0; }\n@@ -646,1 +644,0 @@\n-  static int num_arguments() { return 0; }\n@@ -667,1 +664,0 @@\n-  static int num_arguments() { return 0; }\n@@ -693,1 +689,0 @@\n-  static int num_arguments();\n@@ -715,1 +710,0 @@\n-  static int num_arguments() { return 0; }\n@@ -736,1 +730,0 @@\n-  static int num_arguments() { return 0; }\n@@ -759,1 +752,0 @@\n-  static int num_arguments();\n@@ -780,1 +772,0 @@\n-  static int num_arguments() { return 0; }\n@@ -846,1 +837,0 @@\n-  static int num_arguments();\n@@ -869,1 +859,0 @@\n-  static int num_arguments();\n@@ -892,1 +881,0 @@\n-  static int num_arguments();\n@@ -897,1 +885,1 @@\n-class DebugOnCmdStartDCmd : public DCmdWithParser {\n+class DebugOnCmdStartDCmd : public DCmd {\n@@ -899,1 +887,1 @@\n-  DebugOnCmdStartDCmd(outputStream* output, bool heap);\n+  DebugOnCmdStartDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n@@ -913,1 +901,0 @@\n-  static int num_arguments() { return 0; }\n@@ -938,1 +925,0 @@\n-  static int num_arguments();\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":30,"deletions":44,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -336,0 +336,1 @@\n+  inline void check_no_pending_exception();\n@@ -338,1 +339,2 @@\n-  ExceptionMark(Thread*& thread);\n+  ExceptionMark();\n+  ExceptionMark(Thread* thread);\n@@ -340,2 +342,4 @@\n-};\n-\n+  Thread* thread() {\n+    return _thread;\n+  }\n+};\n@@ -352,1 +356,1 @@\n-#define EXCEPTION_MARK                           Thread* THREAD = NULL; ExceptionMark __em(THREAD);\n+#define EXCEPTION_MARK                           ExceptionMark __em; Thread* THREAD = __em.thread();\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -399,3 +399,0 @@\n-\n-STATIC_ASSERT(left_n_bits(3)   == (intptr_t) LP64_ONLY(0xE000000000000000) NOT_LP64(0xE0000000));\n-STATIC_ASSERT(left_n_bits(1|2) == (intptr_t) LP64_ONLY(0xE000000000000000) NOT_LP64(0xE0000000));\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,4 @@\n+#include <cstddef>\n+\n+class oopDesc;\n+\n@@ -822,0 +826,1 @@\n+    oopDesc* o;\n@@ -846,0 +851,1 @@\n+ oopDesc* get_oop() const { return _value.o; }\n@@ -854,0 +860,1 @@\n+ void set_oop(oopDesc* o) { _value.o = o;}\n@@ -1000,1 +1007,0 @@\n-#define left_n_bits(n)    (right_n_bits(n) << (((n) >= BitsPerWord) ? 0 : (BitsPerWord - (n))))\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -837,1 +837,1 @@\n-                in.readTypeString() : new String(new char[] { tcode });\n+                in.readTypeString() : String.valueOf(tcode);\n@@ -1200,1 +1200,1 @@\n-                Throwable th = ex.getTargetException();\n+                Throwable th = ex.getCause();\n@@ -1230,1 +1230,1 @@\n-                Throwable th = ex.getTargetException();\n+                Throwable th = ex.getCause();\n@@ -1261,1 +1261,1 @@\n-                Throwable th = ex.getTargetException();\n+                Throwable th = ex.getCause();\n@@ -1290,1 +1290,1 @@\n-                Throwable th = ex.getTargetException();\n+                Throwable th = ex.getCause();\n@@ -1320,1 +1320,1 @@\n-                Throwable th = ex.getTargetException();\n+                Throwable th = ex.getCause();\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -949,2 +949,2 @@\n-     * Returns {@code true} if and only if this class has the synthetic modifier\n-     * bit set.\n+     *{@return {@code true} if and only if this class has the synthetic modifier\n+     * bit set}\n@@ -952,1 +952,0 @@\n-     * @return {@code true} if and only if this class has the synthetic modifier bit set\n@@ -955,0 +954,3 @@\n+     * @see <a\n+     * href=\"{@docRoot}\/java.base\/java\/lang\/reflect\/package-summary.html#LanguageJvmModel\">Java\n+     * programming language and JVM modeling in core reflection<\/a>\n@@ -1445,0 +1447,3 @@\n+     * @see <a\n+     * href=\"{@docRoot}\/java.base\/java\/lang\/reflect\/package-summary.html#LanguageJvmModel\">Java\n+     * programming language and JVM modeling in core reflection<\/a>\n@@ -1446,0 +1451,2 @@\n+     * @jls 8.1.1 Class Modifiers\n+     * @jls 9.1.1. Interface Modifiers\n@@ -1794,2 +1801,5 @@\n-     * source code. Returns an empty string if the underlying class is\n-     * anonymous.\n+     * source code. An empty string is returned if the underlying class is\n+     * {@linkplain #isAnonymousClass() anonymous}.\n+     * A {@linkplain #isSynthetic() synthetic class}, one not present\n+     * in source code, can have a non-empty name including special\n+     * characters, such as \"{@code $}\".\n@@ -1797,1 +1807,1 @@\n-     * <p>The simple name of an array is the simple name of the\n+     * <p>The simple name of an {@linkplain isArray() array class} is the simple name of the\n@@ -1799,1 +1809,1 @@\n-     * name of an array whose component type is anonymous is \"[]\".\n+     * name of an array class whose component type is anonymous is \"[]\".\n@@ -1901,0 +1911,1 @@\n+     * @jls 15.9.5 Anonymous Class Declarations\n@@ -1913,0 +1924,1 @@\n+     * @jls 14.3 Local Class Declarations\n@@ -1925,0 +1937,1 @@\n+     * @jls 8.5 Member Type Declarations\n@@ -2449,0 +2462,1 @@\n+     * @jls 8.5 Member Type Declarations\n@@ -2567,0 +2581,4 @@\n+     * The declared methods may include methods <em>not<\/em> in the\n+     * source of the class or interface, including {@linkplain\n+     * Method#isBridge bridge methods} and other {@linkplain\n+     * Executable#isSynthetic synthetic} methods added by compilers.\n@@ -2611,0 +2629,3 @@\n+     * @see <a\n+     * href=\"{@docRoot}\/java.base\/java\/lang\/reflect\/package-summary.html#LanguageJvmModel\">Java\n+     * programming language and JVM modeling in core reflection<\/a>\n@@ -2661,0 +2682,1 @@\n+     * @jls 8.8 Constructor Declarations\n@@ -3917,0 +3939,1 @@\n+     * @jls 8.9.1 Enum Constants\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -302,1 +302,1 @@\n-        @Stable final private SpeciesData[] extensions = new SpeciesData[ARG_TYPE_LIMIT];\n+        @Stable private final SpeciesData[] extensions = new SpeciesData[ARG_TYPE_LIMIT];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+    private final String name;\n@@ -120,1 +121,1 @@\n-                                     String className, String invokerName, MethodType invokerType) {\n+                                     String name, String invokerName, MethodType invokerType) {\n@@ -123,1 +124,1 @@\n-            className = invokerName.substring(0, p);\n+            name = invokerName.substring(0, p);\n@@ -127,1 +128,1 @@\n-            className = makeDumpableClassName(className);\n+            name = makeDumpableClassName(name);\n@@ -129,1 +130,2 @@\n-        this.className  = className;\n+        this.name = name;\n+        this.className = CLASS_PREFIX + name;\n@@ -138,1 +140,1 @@\n-    private InvokerBytecodeGenerator(String className, String invokerName, MethodType invokerType) {\n+    private InvokerBytecodeGenerator(String name, String invokerName, MethodType invokerType) {\n@@ -140,1 +142,1 @@\n-             className, invokerName, invokerType);\n+             name, invokerName, invokerType);\n@@ -152,2 +154,2 @@\n-    private InvokerBytecodeGenerator(String className, LambdaForm form, MethodType invokerType) {\n-        this(className, form.lambdaName(), form, invokerType);\n+    private InvokerBytecodeGenerator(String name, LambdaForm form, MethodType invokerType) {\n+        this(name, form.lambdaName(), form, invokerType);\n@@ -157,1 +159,1 @@\n-    InvokerBytecodeGenerator(String className, String invokerName,\n+    InvokerBytecodeGenerator(String name, String invokerName,\n@@ -160,1 +162,1 @@\n-             className, invokerName, invokerType);\n+             name, invokerName, invokerType);\n@@ -198,1 +200,1 @@\n-            maybeDump(CLASS_PREFIX + className, classFile);\n+            maybeDump(className, classFile);\n@@ -234,1 +236,1 @@\n-            sfx = \"0\"+sfx;\n+            sfx = \"0\" + sfx;\n@@ -268,5 +270,10 @@\n-        Class<?> c = arg.getClass();\n-        while (c.isArray()) {\n-            c = c.getComponentType();\n-        }\n-        String name = \"_DATA_\" + c.getSimpleName() + \"_\" + classData.size();\n+        String name;\n+        if (DUMP_CLASS_FILES) {\n+            Class<?> c = arg.getClass();\n+            while (c.isArray()) {\n+                c = c.getComponentType();\n+            }\n+            name = \"_DATA_\" + c.getSimpleName() + \"_\" + classData.size();\n+        } else {\n+            name = \"_D_\" + classData.size();\n+        }\n@@ -276,1 +283,1 @@\n-        return cd.name();\n+        return name;\n@@ -280,5 +287,15 @@\n-        Object[] data = new Object[classData.size()];\n-        for (int i = 0; i < classData.size(); i++) {\n-            data[i] = classData.get(i).value;\n-        }\n-        return List.of(data);\n+        final List<ClassData> cd = classData;\n+        return switch(cd.size()) {\n+            case 0 -> List.of();\n+            case 1 -> List.of(cd.get(0).value);\n+            case 2 -> List.of(cd.get(0).value, cd.get(1).value);\n+            case 3 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value);\n+            case 4 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value, cd.get(3).value);\n+            default -> {\n+                Object[] data = new Object[classData.size()];\n+                for (int i = 0; i < classData.size(); i++) {\n+                    data[i] = classData.get(i).value;\n+                }\n+                yield List.of(data);\n+            }\n+        };\n@@ -288,2 +305,1 @@\n-        if (arg instanceof MethodHandle) {\n-            MethodHandle mh = (MethodHandle) arg;\n+        if (arg instanceof MethodHandle mh) {\n@@ -298,15 +314,0 @@\n-    \/**\n-     * Extract the number of constant pool entries from a given class file.\n-     *\n-     * @param classFile the bytes of the class file in question.\n-     * @return the number of entries in the constant pool.\n-     *\/\n-    private static int getConstantPoolSize(byte[] classFile) {\n-        \/\/ The first few bytes:\n-        \/\/ u4 magic;\n-        \/\/ u2 minor_version;\n-        \/\/ u2 major_version;\n-        \/\/ u2 constant_pool_count;\n-        return ((classFile[8] & 0xFF) << 8) | (classFile[9] & 0xFF);\n-    }\n-\n@@ -317,1 +318,1 @@\n-        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className(), classFile)\n+        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className, classFile)\n@@ -342,2 +343,2 @@\n-                CLASS_PREFIX + className, null, INVOKER_SUPER_NAME, null);\n-        cw.visitSource(SOURCE_PREFIX + className, null);\n+                className, null, INVOKER_SUPER_NAME, null);\n+        cw.visitSource(SOURCE_PREFIX + name, null);\n@@ -360,8 +361,0 @@\n-    private String className() {\n-        return CLASS_PREFIX + className;\n-    }\n-\n-    private void clinit() {\n-        clinit(cw, className(), classData);\n-    }\n-\n@@ -636,2 +629,1 @@\n-        if (arg instanceof Name) {\n-            Name n = (Name) arg;\n+        if (arg instanceof Name n) {\n@@ -650,1 +642,1 @@\n-            mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(cls), \"Ljava\/lang\/Class;\");\n+            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(cls), \"Ljava\/lang\/Class;\");\n@@ -668,11 +660,9 @@\n-        int opcode;\n-        switch (type) {\n-        case I_TYPE:  opcode = Opcodes.IRETURN;  break;\n-        case J_TYPE:  opcode = Opcodes.LRETURN;  break;\n-        case F_TYPE:  opcode = Opcodes.FRETURN;  break;\n-        case D_TYPE:  opcode = Opcodes.DRETURN;  break;\n-        case L_TYPE:  opcode = Opcodes.ARETURN;  break;\n-        case V_TYPE:  opcode = Opcodes.RETURN;   break;\n-        default:\n-            throw new InternalError(\"unknown return type: \" + type);\n-        }\n+        int opcode = switch (type) {\n+            case I_TYPE -> Opcodes.IRETURN;\n+            case J_TYPE -> Opcodes.LRETURN;\n+            case F_TYPE -> Opcodes.FRETURN;\n+            case D_TYPE -> Opcodes.DRETURN;\n+            case L_TYPE -> Opcodes.ARETURN;\n+            case V_TYPE -> Opcodes.RETURN;\n+            default -> throw new InternalError(\"unknown return type: \" + type);\n+        };\n@@ -725,1 +715,1 @@\n-            case GENERIC_LINKER:            return resolveFrom(name, invokerType.basicType(), Invokers.Holder.class);\n+            case GENERIC_LINKER:            return resolveFrom(name, invokerType, Invokers.Holder.class);\n@@ -806,1 +796,1 @@\n-        clinit();\n+        clinit(cw, className, classData);\n@@ -841,1 +831,1 @@\n-            mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(lambdaForm.customized), MH_SIG);\n+            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(lambdaForm.customized), MH_SIG);\n@@ -882,7 +872,0 @@\n-                case NEW_ARRAY:\n-                    Class<?> rtype = name.function.methodType().returnType();\n-                    if (isStaticallyNameable(rtype)) {\n-                        emitNewArray(name);\n-                        continue;\n-                    }\n-                    break;\n@@ -974,1 +957,1 @@\n-            mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(target), MH_SIG);\n+            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(target), MH_SIG);\n@@ -993,1 +976,1 @@\n-    private static Class<?>[] STATICALLY_INVOCABLE_PACKAGES = {\n+    private static final Class<?>[] STATICALLY_INVOCABLE_PACKAGES = {\n@@ -1126,37 +1109,0 @@\n-    void emitNewArray(Name name) throws InternalError {\n-        Class<?> rtype = name.function.methodType().returnType();\n-        if (name.arguments.length == 0) {\n-            \/\/ The array will be a constant.\n-            Object emptyArray;\n-            try {\n-                emptyArray = name.function.resolvedHandle().invoke();\n-            } catch (Throwable ex) {\n-                throw uncaughtException(ex);\n-            }\n-            assert(java.lang.reflect.Array.getLength(emptyArray) == 0);\n-            assert(emptyArray.getClass() == rtype);  \/\/ exact typing\n-            mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(emptyArray), \"Ljava\/lang\/Object;\");\n-            emitReferenceCast(rtype, emptyArray);\n-            return;\n-        }\n-        Class<?> arrayElementType = rtype.getComponentType();\n-        assert(arrayElementType != null);\n-        emitIconstInsn(name.arguments.length);\n-        int xas = Opcodes.AASTORE;\n-        if (!arrayElementType.isPrimitive()) {\n-            mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(arrayElementType));\n-        } else {\n-            byte tc = arrayTypeCode(Wrapper.forPrimitiveType(arrayElementType));\n-            xas = arrayInsnOpcode(tc, xas);\n-            mv.visitIntInsn(Opcodes.NEWARRAY, tc);\n-        }\n-        \/\/ store arguments\n-        for (int i = 0; i < name.arguments.length; i++) {\n-            mv.visitInsn(Opcodes.DUP);\n-            emitIconstInsn(i);\n-            emitPushArgument(name, i);\n-            mv.visitInsn(xas);\n-        }\n-        \/\/ the array is left on the stack\n-        assertStaticType(rtype, name);\n-    }\n@@ -1691,2 +1637,1 @@\n-        if (arg instanceof Name) {\n-            Name n = (Name) arg;\n+        if (arg instanceof Name n) {\n@@ -1695,2 +1640,4 @@\n-        } else if ((arg == null || arg instanceof String) && bptype == L_TYPE) {\n-            emitConst(arg);\n+        } else if (arg == null && bptype == L_TYPE) {\n+            mv.visitInsn(Opcodes.ACONST_NULL);\n+        } else if (arg instanceof String && bptype == L_TYPE) {\n+            mv.visitLdcInsn(arg);\n@@ -1701,1 +1648,1 @@\n-                mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(arg), \"Ljava\/lang\/Object;\");\n+                mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(arg), \"Ljava\/lang\/Object;\");\n@@ -1832,4 +1779,4 @@\n-        case LONG:    mv.visitInsn(Opcodes.L2I);  break;\n-        case FLOAT:   mv.visitInsn(Opcodes.F2I);  break;\n-        case DOUBLE:  mv.visitInsn(Opcodes.D2I);  break;\n-        default:      throw new InternalError(\"unknown type: \" + type);\n+            case LONG -> mv.visitInsn(Opcodes.L2I);\n+            case FLOAT -> mv.visitInsn(Opcodes.F2I);\n+            case DOUBLE -> mv.visitInsn(Opcodes.D2I);\n+            default -> throw new InternalError(\"unknown type: \" + type);\n@@ -1893,1 +1840,1 @@\n-        clinit();\n+        clinit(cw, className, classData);\n@@ -1962,1 +1909,1 @@\n-        clinit();\n+        clinit(cw, className, classData);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":72,"deletions":125,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -215,20 +215,0 @@\n-        static BasicType[] basicTypes(String types) {\n-            BasicType[] btypes = new BasicType[types.length()];\n-            for (int i = 0; i < btypes.length; i++) {\n-                btypes[i] = basicType(types.charAt(i));\n-            }\n-            return btypes;\n-        }\n-        static String basicTypeDesc(BasicType[] types) {\n-            if (types == null) {\n-                return null;\n-            }\n-            if (types.length == 0) {\n-                return \"\";\n-            }\n-            StringBuilder sb = new StringBuilder();\n-            for (BasicType bt : types) {\n-                sb.append(bt.basicTypeChar());\n-            }\n-            return sb.toString();\n-        }\n@@ -342,0 +322,1 @@\n+        COLLECTOR(\"collector\"),\n@@ -395,3 +376,0 @@\n-    LambdaForm(int arity, Name[] names, boolean forceInline) {\n-        this(arity, names, LAST_RESULT, forceInline, \/*customized=*\/null, Kind.GENERIC);\n-    }\n@@ -401,6 +379,0 @@\n-    LambdaForm(Name[] formals, Name[] temps, Name result) {\n-        this(formals.length, buildNames(formals, temps, result), LAST_RESULT, \/*forceInline=*\/true, \/*customized=*\/null);\n-    }\n-    LambdaForm(Name[] formals, Name[] temps, Name result, boolean forceInline) {\n-        this(formals.length, buildNames(formals, temps, result), LAST_RESULT, forceInline, \/*customized=*\/null);\n-    }\n@@ -604,2 +576,1 @@\n-                if (arg instanceof Name) {\n-                    Name n2 = (Name) arg;\n+                if (arg instanceof Name n2) {\n@@ -636,2 +607,1 @@\n-        assert(n < arity);\n-        assert(param.isParam());\n+        assert(n < arity && param.isParam());\n@@ -677,3 +647,0 @@\n-    static BasicType signatureReturn(String sig) {\n-        return basicType(sig.charAt(signatureArity(sig) + 1));\n-    }\n@@ -694,10 +661,0 @@\n-    static MethodType signatureType(String sig) {\n-        Class<?>[] ptypes = new Class<?>[signatureArity(sig)];\n-        for (int i = 0; i < ptypes.length; i++)\n-            ptypes[i] = basicType(sig.charAt(i)).btClass;\n-        Class<?> rtype = signatureReturn(sig).btClass;\n-        return MethodType.makeImpl(rtype, ptypes, true);\n-    }\n-    static MethodType basicMethodType(MethodType mt) {\n-        return signatureType(basicTypeSignature(mt));\n-    }\n@@ -1183,3 +1140,3 @@\n-            if (!(other instanceof NamedFunction)) return false;\n-            NamedFunction that = (NamedFunction) other;\n-            return this.member != null && this.member.equals(that.member);\n+            return (other instanceof NamedFunction that)\n+                    && this.member != null\n+                    && this.member.equals(that.member);\n@@ -1334,1 +1291,1 @@\n-                    buf.append(signature.substring(i - c1reps, len));\n+                    buf.append(signature, i - c1reps, len);\n@@ -1417,5 +1374,0 @@\n-        void resolve() {\n-            if (function != null)\n-                function.resolve();\n-        }\n-\n@@ -1462,2 +1414,1 @@\n-                if (arguments[j] instanceof Name) {\n-                    Name n = (Name) arguments[j];\n+                if (arguments[j] instanceof Name n) {\n@@ -1490,2 +1441,1 @@\n-                if (arguments[j] instanceof Name) {\n-                    Name n = (Name) arguments[j];\n+                if (arguments[j] instanceof Name n) {\n@@ -1605,3 +1555,6 @@\n-            if (arguments == null)  return 0;\n-            for (int i = arguments.length; --i >= 0; ) {\n-                if (arguments[i] == n)  ++count;\n+            if (arguments != null) {\n+                for (Object argument : arguments) {\n+                    if (argument == n) {\n+                        count++;\n+                    }\n+                }\n@@ -1613,4 +1566,0 @@\n-        boolean contains(Name n) {\n-            return this == n || lastUseIndex(n) >= 0;\n-        }\n-\n@@ -1656,9 +1605,4 @@\n-        int nmax = names.length;\n-        int end = lastUseIndex(n);\n-        if (end < 0)  return 0;\n-        int count = 0;\n-        if (end == nmax) { count++; end--; }\n-        int beg = n.index() + 1;\n-        if (beg < arity)  beg = arity;\n-        for (int i = beg; i <= end; i++) {\n-            count += names[i].useCount(n);\n+        int count = (result == n.index) ? 1 : 0;\n+        int i = Math.max(n.index + 1, arity);\n+        while (i < names.length) {\n+            count += names[i++].useCount(n);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":19,"deletions":75,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-        } else if (c instanceof Transform) {\n+        } else if (c instanceof Transform t) {\n@@ -343,1 +343,0 @@\n-            Transform t = (Transform)c;\n@@ -393,2 +392,1 @@\n-                if (c instanceof Transform) {\n-                    Transform k = (Transform)c;\n+                if (c instanceof Transform k) {\n@@ -654,51 +652,0 @@\n-    LambdaForm collectArgumentArrayForm(int pos, MethodHandle arrayCollector) {\n-        MethodType collectorType = arrayCollector.type();\n-        int collectorArity = collectorType.parameterCount();\n-        assert(arrayCollector.intrinsicName() == Intrinsic.NEW_ARRAY);\n-        Class<?> arrayType = collectorType.returnType();\n-        Class<?> elementType = arrayType.getComponentType();\n-        BasicType argType = basicType(elementType);\n-        int argTypeKey = argType.ordinal();\n-        if (argType.basicTypeClass() != elementType) {\n-            \/\/ return null if it requires more metadata (like String[].class)\n-            if (!elementType.isPrimitive())\n-                return null;\n-            argTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();\n-        }\n-        assert(collectorType.parameterList().equals(Collections.nCopies(collectorArity, elementType)));\n-        byte kind = COLLECT_ARGS_TO_ARRAY;\n-        TransformKey key = TransformKey.of(kind, pos, collectorArity, argTypeKey);\n-        LambdaForm form = getInCache(key);\n-        if (form != null) {\n-            assert(form.arity == lambdaForm.arity - 1 + collectorArity);\n-            return form;\n-        }\n-        LambdaFormBuffer buf = buffer();\n-        buf.startEdit();\n-\n-        assert(pos + 1 <= lambdaForm.arity);\n-        assert(pos > 0);  \/\/ cannot filter the MH arg itself\n-\n-        Name[] newParams = new Name[collectorArity];\n-        for (int i = 0; i < collectorArity; i++) {\n-            newParams[i] = new Name(pos + i, argType);\n-        }\n-        Name callCombiner = new Name(new NamedFunction(arrayCollector, Intrinsic.NEW_ARRAY),\n-                                        (Object[]) \/*...*\/ newParams);\n-\n-        \/\/ insert the new expression\n-        int exprPos = lambdaForm.arity();\n-        buf.insertExpression(exprPos, callCombiner);\n-\n-        \/\/ insert new arguments\n-        int argPos = pos + 1;  \/\/ skip result parameter\n-        for (Name newParam : newParams) {\n-            buf.insertParameter(argPos++, newParam);\n-        }\n-        assert(buf.lastIndexOf(callCombiner) == exprPos+newParams.length);\n-        buf.replaceParameterByCopy(pos, exprPos+newParams.length);\n-\n-        form = buf.endEdit();\n-        return putInCache(key, form);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":2,"deletions":55,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -150,2 +150,1 @@\n-            if (type instanceof String) {\n-                String sig = (String) type;\n+            if (type instanceof String sig) {\n@@ -154,2 +153,1 @@\n-            } else if (type instanceof Object[]) {\n-                Object[] typeInfo = (Object[]) type;\n+            } else if (type instanceof Object[] typeInfo) {\n@@ -238,2 +236,1 @@\n-            if (type instanceof String) {\n-                String sig = (String) type;\n+            if (type instanceof String sig) {\n@@ -967,2 +964,1 @@\n-                if (from instanceof MethodHandles.Lookup) {\n-                    MethodHandles.Lookup lookup = (MethodHandles.Lookup)from;\n+                if (from instanceof MethodHandles.Lookup lookup) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -569,49 +569,0 @@\n-    \/** Factory method:  Spread selected argument. *\/\n-    static MethodHandle makeSpreadArguments(MethodHandle target,\n-                                            Class<?> spreadArgType, int spreadArgPos, int spreadArgCount) {\n-        MethodType targetType = target.type();\n-\n-        for (int i = 0; i < spreadArgCount; i++) {\n-            Class<?> arg = VerifyType.spreadArgElementType(spreadArgType, i);\n-            if (arg == null)  arg = Object.class;\n-            targetType = targetType.changeParameterType(spreadArgPos + i, arg);\n-        }\n-        target = target.asType(targetType);\n-\n-        MethodType srcType = targetType\n-                .replaceParameterTypes(spreadArgPos, spreadArgPos + spreadArgCount, spreadArgType);\n-        \/\/ Now build a LambdaForm.\n-        MethodType lambdaType = srcType.invokerType();\n-        Name[] names = arguments(spreadArgCount + 2, lambdaType);\n-        int nameCursor = lambdaType.parameterCount();\n-        int[] indexes = new int[targetType.parameterCount()];\n-\n-        for (int i = 0, argIndex = 1; i < targetType.parameterCount() + 1; i++, argIndex++) {\n-            Class<?> src = lambdaType.parameterType(i);\n-            if (i == spreadArgPos) {\n-                \/\/ Spread the array.\n-                MethodHandle aload = MethodHandles.arrayElementGetter(spreadArgType);\n-                Name array = names[argIndex];\n-                names[nameCursor++] = new Name(getFunction(NF_checkSpreadArgument), array, spreadArgCount);\n-                for (int j = 0; j < spreadArgCount; i++, j++) {\n-                    indexes[i] = nameCursor;\n-                    names[nameCursor++] = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), array, j);\n-                }\n-            } else if (i < indexes.length) {\n-                indexes[i] = argIndex;\n-            }\n-        }\n-        assert(nameCursor == names.length-1);  \/\/ leave room for the final call\n-\n-        \/\/ Build argument array for the call.\n-        Name[] targetArgs = new Name[targetType.parameterCount()];\n-        for (int i = 0; i < targetType.parameterCount(); i++) {\n-            int idx = indexes[i];\n-            targetArgs[i] = names[idx];\n-        }\n-        names[names.length - 1] = new Name(target, (Object[]) targetArgs);\n-\n-        LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.SPREAD);\n-        return SimpleMethodHandle.make(srcType, form);\n-    }\n-\n@@ -634,54 +585,0 @@\n-    \/** Factory method:  Collect or filter selected argument(s). *\/\n-    static MethodHandle makeCollectArguments(MethodHandle target,\n-                MethodHandle collector, int collectArgPos, boolean retainOriginalArgs) {\n-        MethodType targetType = target.type();          \/\/ (a..., c, [b...])=>r\n-        MethodType collectorType = collector.type();    \/\/ (b...)=>c\n-        int collectArgCount = collectorType.parameterCount();\n-        Class<?> collectValType = collectorType.returnType();\n-        int collectValCount = (collectValType == void.class ? 0 : 1);\n-        MethodType srcType = targetType                 \/\/ (a..., [b...])=>r\n-                .dropParameterTypes(collectArgPos, collectArgPos+collectValCount);\n-        if (!retainOriginalArgs) {                      \/\/ (a..., b...)=>r\n-            srcType = srcType.insertParameterTypes(collectArgPos, collectorType.parameterArray());\n-        }\n-        \/\/ in  arglist: [0: ...keep1 | cpos: collect...  | cpos+cacount: keep2... ]\n-        \/\/ out arglist: [0: ...keep1 | cpos: collectVal? | cpos+cvcount: keep2... ]\n-        \/\/ out(retain): [0: ...keep1 | cpos: cV? coll... | cpos+cvc+cac: keep2... ]\n-\n-        \/\/ Now build a LambdaForm.\n-        MethodType lambdaType = srcType.invokerType();\n-        Name[] names = arguments(2, lambdaType);\n-        final int collectNamePos = names.length - 2;\n-        final int targetNamePos  = names.length - 1;\n-\n-        Name[] collectorArgs = Arrays.copyOfRange(names, 1 + collectArgPos, 1 + collectArgPos + collectArgCount);\n-        names[collectNamePos] = new Name(collector, (Object[]) collectorArgs);\n-\n-        \/\/ Build argument array for the target.\n-        \/\/ Incoming LF args to copy are: [ (mh) headArgs collectArgs tailArgs ].\n-        \/\/ Output argument array is [ headArgs (collectVal)? (collectArgs)? tailArgs ].\n-        Name[] targetArgs = new Name[targetType.parameterCount()];\n-        int inputArgPos  = 1;  \/\/ incoming LF args to copy to target\n-        int targetArgPos = 0;  \/\/ fill pointer for targetArgs\n-        int chunk = collectArgPos;  \/\/ |headArgs|\n-        System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);\n-        inputArgPos  += chunk;\n-        targetArgPos += chunk;\n-        if (collectValType != void.class) {\n-            targetArgs[targetArgPos++] = names[collectNamePos];\n-        }\n-        chunk = collectArgCount;\n-        if (retainOriginalArgs) {\n-            System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);\n-            targetArgPos += chunk;   \/\/ optionally pass on the collected chunk\n-        }\n-        inputArgPos += chunk;\n-        chunk = targetArgs.length - targetArgPos;  \/\/ all the rest\n-        System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);\n-        assert(inputArgPos + chunk == collectNamePos);  \/\/ use of rest of input args also\n-        names[targetNamePos] = new Name(target, (Object[]) targetArgs);\n-\n-        LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.COLLECT);\n-        return SimpleMethodHandle.make(srcType, form);\n-    }\n-\n@@ -770,1 +667,1 @@\n-    private final static class Makers {\n+    private static final class Makers {\n@@ -1333,1 +1230,0 @@\n-        NEW_ARRAY,\n@@ -1398,46 +1294,0 @@\n-    \/\/\/ Collection of multiple arguments.\n-\n-    private static MethodHandle findCollector(String name, int nargs, Class<?> rtype, Class<?>... ptypes) {\n-        MethodType type = MethodType.genericMethodType(nargs)\n-                .changeReturnType(rtype)\n-                .insertParameterTypes(0, ptypes);\n-        try {\n-            return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, name, type);\n-        } catch (ReflectiveOperationException ex) {\n-            return null;\n-        }\n-    }\n-\n-    private static final Object[] NO_ARGS_ARRAY = {};\n-    private static Object[] makeArray(Object... args) { return args; }\n-    private static Object[] array() { return NO_ARGS_ARRAY; }\n-    private static Object[] array(Object a0)\n-                { return makeArray(a0); }\n-    private static Object[] array(Object a0, Object a1)\n-                { return makeArray(a0, a1); }\n-    private static Object[] array(Object a0, Object a1, Object a2)\n-                { return makeArray(a0, a1, a2); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3)\n-                { return makeArray(a0, a1, a2, a3); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4)\n-                { return makeArray(a0, a1, a2, a3, a4); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5)\n-                { return makeArray(a0, a1, a2, a3, a4, a5); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6)\n-                { return makeArray(a0, a1, a2, a3, a4, a5, a6); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6, Object a7)\n-                { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6, Object a7,\n-                                  Object a8)\n-                { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6, Object a7,\n-                                  Object a8, Object a9)\n-                { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }\n-\n-    private static final int ARRAYS_COUNT = 11;\n@@ -1446,66 +1296,0 @@\n-    \/\/ filling versions of the above:\n-    \/\/ using Integer len instead of int len and no varargs to avoid bootstrapping problems\n-    private static Object[] fillNewArray(Integer len, Object[] \/*not ...*\/ args) {\n-        Object[] a = new Object[len];\n-        fillWithArguments(a, 0, args);\n-        return a;\n-    }\n-    private static Object[] fillNewTypedArray(Object[] example, Integer len, Object[] \/*not ...*\/ args) {\n-        Object[] a = Arrays.copyOf(example, len);\n-        assert(a.getClass() != Object[].class);\n-        fillWithArguments(a, 0, args);\n-        return a;\n-    }\n-    private static void fillWithArguments(Object[] a, int pos, Object... args) {\n-        System.arraycopy(args, 0, a, pos, args.length);\n-    }\n-    \/\/ using Integer pos instead of int pos to avoid bootstrapping problems\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0)\n-                { fillWithArguments(a, pos, a0); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1)\n-                { fillWithArguments(a, pos, a0, a1); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2)\n-                { fillWithArguments(a, pos, a0, a1, a2); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3, a4); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6, Object a7)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6, Object a7,\n-                                  Object a8)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6, Object a7,\n-                                  Object a8, Object a9)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); return a; }\n-\n-    private static final int FILL_ARRAYS_COUNT = 11; \/\/ current number of fillArray methods\n-    private static final @Stable MethodHandle[] FILL_ARRAYS = new MethodHandle[FILL_ARRAYS_COUNT];\n-\n-    private static MethodHandle getFillArray(int count) {\n-        assert (count > 0 && count < FILL_ARRAYS_COUNT);\n-        MethodHandle mh = FILL_ARRAYS[count];\n-        if (mh != null) {\n-            return mh;\n-        }\n-        mh = findCollector(\"fillArray\", count, Object[].class, Integer.class, Object[].class);\n-        FILL_ARRAYS[count] = mh;\n-        return mh;\n-    }\n-\n-    private static Object copyAsPrimitiveArray(Wrapper w, Object... boxes) {\n-        Object a = w.makeArray(boxes.length);\n-        w.copyArrayUnboxing(boxes, 0, a, 0, boxes.length);\n-        return a;\n-    }\n-\n@@ -1520,6 +1304,1 @@\n-        if (nargs < ARRAYS_COUNT) {\n-            mh = findCollector(\"array\", nargs, Object[].class);\n-        } else {\n-            mh = buildVarargsArray(getConstantHandle(MH_fillNewArray),\n-                    getConstantHandle(MH_arrayIdentity), nargs);\n-        }\n+        mh = makeCollector(Object[].class, nargs);\n@@ -1527,1 +1306,0 @@\n-        mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);\n@@ -1531,80 +1309,0 @@\n-    private static boolean assertCorrectArity(MethodHandle mh, int arity) {\n-        assert(mh.type().parameterCount() == arity) : \"arity != \"+arity+\": \"+mh;\n-        return true;\n-    }\n-\n-    \/\/ Array identity function (used as getConstantHandle(MH_arrayIdentity)).\n-    static <T> T[] identity(T[] x) {\n-        return x;\n-    }\n-\n-    private static MethodHandle buildVarargsArray(MethodHandle newArray, MethodHandle finisher, int nargs) {\n-        \/\/ Build up the result mh as a sequence of fills like this:\n-        \/\/   finisher(fill(fill(newArrayWA(23,x1..x10),10,x11..x20),20,x21..x23))\n-        \/\/ The various fill(_,10*I,___*[J]) are reusable.\n-        int leftLen = Math.min(nargs, LEFT_ARGS);  \/\/ absorb some arguments immediately\n-        int rightLen = nargs - leftLen;\n-        MethodHandle leftCollector = newArray.bindTo(nargs);\n-        leftCollector = leftCollector.asCollector(Object[].class, leftLen);\n-        MethodHandle mh = finisher;\n-        if (rightLen > 0) {\n-            MethodHandle rightFiller = fillToRight(LEFT_ARGS + rightLen);\n-            if (mh.equals(getConstantHandle(MH_arrayIdentity)))\n-                mh = rightFiller;\n-            else\n-                mh = MethodHandles.collectArguments(mh, 0, rightFiller);\n-        }\n-        if (mh.equals(getConstantHandle(MH_arrayIdentity)))\n-            mh = leftCollector;\n-        else\n-            mh = MethodHandles.collectArguments(mh, 0, leftCollector);\n-        return mh;\n-    }\n-\n-    private static final int LEFT_ARGS = FILL_ARRAYS_COUNT - 1;\n-    private static final @Stable MethodHandle[] FILL_ARRAY_TO_RIGHT = new MethodHandle[MAX_ARITY + 1];\n-    \/** fill_array_to_right(N).invoke(a, argL..arg[N-1])\n-     *  fills a[L]..a[N-1] with corresponding arguments,\n-     *  and then returns a.  The value L is a global constant (LEFT_ARGS).\n-     *\/\n-    private static MethodHandle fillToRight(int nargs) {\n-        MethodHandle filler = FILL_ARRAY_TO_RIGHT[nargs];\n-        if (filler != null)  return filler;\n-        filler = buildFiller(nargs);\n-        assert(assertCorrectArity(filler, nargs - LEFT_ARGS + 1));\n-        return FILL_ARRAY_TO_RIGHT[nargs] = filler;\n-    }\n-    private static MethodHandle buildFiller(int nargs) {\n-        if (nargs <= LEFT_ARGS)\n-            return getConstantHandle(MH_arrayIdentity);  \/\/ no args to fill; return the array unchanged\n-        \/\/ we need room for both mh and a in mh.invoke(a, arg*[nargs])\n-        final int CHUNK = LEFT_ARGS;\n-        int rightLen = nargs % CHUNK;\n-        int midLen = nargs - rightLen;\n-        if (rightLen == 0) {\n-            midLen = nargs - (rightLen = CHUNK);\n-            if (FILL_ARRAY_TO_RIGHT[midLen] == null) {\n-                \/\/ build some precursors from left to right\n-                for (int j = LEFT_ARGS % CHUNK; j < midLen; j += CHUNK)\n-                    if (j > LEFT_ARGS)  fillToRight(j);\n-            }\n-        }\n-        if (midLen < LEFT_ARGS) rightLen = nargs - (midLen = LEFT_ARGS);\n-        assert(rightLen > 0);\n-        MethodHandle midFill = fillToRight(midLen);  \/\/ recursive fill\n-        MethodHandle rightFill = getFillArray(rightLen).bindTo(midLen);  \/\/ [midLen..nargs-1]\n-        assert(midFill.type().parameterCount()   == 1 + midLen - LEFT_ARGS);\n-        assert(rightFill.type().parameterCount() == 1 + rightLen);\n-\n-        \/\/ Combine the two fills:\n-        \/\/   right(mid(a, x10..x19), x20..x23)\n-        \/\/ The final product will look like this:\n-        \/\/   right(mid(newArrayLeft(24, x0..x9), x10..x19), x20..x23)\n-        if (midLen == LEFT_ARGS)\n-            return rightFill;\n-        else\n-            return MethodHandles.collectArguments(rightFill, 0, midFill);\n-    }\n-\n-    static final int MAX_JVM_ARITY = 255;  \/\/ limit imposed by the JVM\n-\n@@ -1618,1 +1316,0 @@\n-        \/\/ FIXME: Need more special casing and caching here.\n@@ -1633,16 +1330,1 @@\n-        if (nargs == 0) {\n-            Object example = java.lang.reflect.Array.newInstance(arrayType.getComponentType(), 0);\n-            mh = MethodHandles.constant(arrayType, example);\n-        } else if (elemType.isPrimitive()) {\n-            MethodHandle builder = getConstantHandle(MH_fillNewArray);\n-            MethodHandle producer = buildArrayProducer(arrayType);\n-            mh = buildVarargsArray(builder, producer, nargs);\n-        } else {\n-            Class<? extends Object[]> objArrayType = arrayType.asSubclass(Object[].class);\n-            Object[] example = Arrays.copyOf(NO_ARGS_ARRAY, 0, objArrayType);\n-            MethodHandle builder = getConstantHandle(MH_fillNewTypedArray).bindTo(example);\n-            MethodHandle producer = getConstantHandle(MH_arrayIdentity); \/\/ must be weakly typed\n-            mh = buildVarargsArray(builder, producer, nargs);\n-        }\n-        mh = mh.asType(MethodType.methodType(arrayType, Collections.<Class<?>>nCopies(nargs, elemType)));\n-        mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);\n+        mh = makeCollector(arrayType, nargs);\n@@ -1655,4 +1337,3 @@\n-    private static MethodHandle buildArrayProducer(Class<?> arrayType) {\n-        Class<?> elemType = arrayType.getComponentType();\n-        assert(elemType.isPrimitive());\n-        return getConstantHandle(MH_copyAsPrimitiveArray).bindTo(Wrapper.forPrimitiveType(elemType));\n+    private static boolean assertCorrectArity(MethodHandle mh, int arity) {\n+        assert(mh.type().parameterCount() == arity) : \"arity != \"+arity+\": \"+mh;\n+        return true;\n@@ -1661,0 +1342,2 @@\n+    static final int MAX_JVM_ARITY = 255;  \/\/ limit imposed by the JVM\n+\n@@ -1955,1 +1638,1 @@\n-            StringBuffer sb = new StringBuffer(\"LoopClauses -- \");\n+            StringBuilder sb = new StringBuilder(\"LoopClauses -- \");\n@@ -2199,0 +1882,77 @@\n+    \/\/ see varargsArray method for chaching\/package-private version of this\n+    private static MethodHandle makeCollector(Class<?> arrayType, int parameterCount) {\n+        MethodType type = MethodType.methodType(arrayType, Collections.nCopies(parameterCount, arrayType.componentType()));\n+        MethodHandle newArray = MethodHandles.arrayConstructor(arrayType);\n+\n+        LambdaForm form = makeCollectorForm(type.basicType(), arrayType);\n+\n+        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_L();\n+        BoundMethodHandle mh;\n+        try {\n+            mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) newArray);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n+        assert(mh.type() == type);\n+        return mh;\n+    }\n+\n+    private static LambdaForm makeCollectorForm(MethodType basicType, Class<?> arrayType) {\n+        MethodType lambdaType = basicType.invokerType();\n+        int parameterCount = basicType.parameterCount();\n+\n+        \/\/ Only share the lambda form for empty arrays and reference types.\n+        \/\/ Sharing based on the basic type alone doesn't work because\n+        \/\/ we need a separate lambda form for byte\/short\/char\/int which\n+        \/\/ are all erased to int otherwise.\n+        \/\/ Other caching for primitive types happens at the MethodHandle level (see varargsArray).\n+        boolean isReferenceType = !arrayType.componentType().isPrimitive();\n+        boolean isSharedLambdaForm = parameterCount == 0 || isReferenceType;\n+        if (isSharedLambdaForm) {\n+            LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_COLLECTOR);\n+            if (lform != null) {\n+                return lform;\n+            }\n+        }\n+\n+        \/\/ use erased accessor for reference types\n+        MethodHandle storeFunc = isReferenceType\n+                ? ArrayAccessor.OBJECT_ARRAY_SETTER\n+                : makeArrayElementAccessor(arrayType, ArrayAccess.SET);\n+\n+        final int THIS_MH      = 0;  \/\/ the BMH_L\n+        final int ARG_BASE     = 1;  \/\/ start of incoming arguments\n+        final int ARG_LIMIT    = ARG_BASE + parameterCount;\n+\n+        int nameCursor = ARG_LIMIT;\n+        final int GET_NEW_ARRAY       = nameCursor++;\n+        final int CALL_NEW_ARRAY      = nameCursor++;\n+        final int STORE_ELEMENT_BASE  = nameCursor;\n+        final int STORE_ELEMENT_LIMIT = STORE_ELEMENT_BASE + parameterCount;\n+        nameCursor = STORE_ELEMENT_LIMIT;\n+\n+        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);\n+\n+        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_L();\n+        names[THIS_MH]          = names[THIS_MH].withConstraint(data);\n+        names[GET_NEW_ARRAY]    = new Name(data.getterFunction(0), names[THIS_MH]);\n+\n+        MethodHandle invokeBasic = MethodHandles.basicInvoker(MethodType.methodType(Object.class, int.class));\n+        names[CALL_NEW_ARRAY] = new Name(new NamedFunction(invokeBasic), names[GET_NEW_ARRAY], parameterCount);\n+        for (int storeIndex = 0,\n+             storeNameCursor = STORE_ELEMENT_BASE,\n+             argCursor = ARG_BASE;\n+             storeNameCursor < STORE_ELEMENT_LIMIT;\n+             storeIndex++, storeNameCursor++, argCursor++){\n+\n+            names[storeNameCursor] = new Name(new NamedFunction(storeFunc, Intrinsic.ARRAY_STORE),\n+                    names[CALL_NEW_ARRAY], storeIndex, names[argCursor]);\n+        }\n+\n+        LambdaForm lform = new LambdaForm(lambdaType.parameterCount(), names, CALL_NEW_ARRAY, Kind.COLLECTOR);\n+        if (isSharedLambdaForm) {\n+            lform = basicType.form().setCachedLambdaForm(MethodTypeForm.LF_COLLECTOR, lform);\n+        }\n+        return lform;\n+    }\n+\n@@ -2201,13 +1961,9 @@\n-            MH_cast                  =  0,\n-            MH_selectAlternative     =  1,\n-            MH_copyAsPrimitiveArray  =  2,\n-            MH_fillNewTypedArray     =  3,\n-            MH_fillNewArray          =  4,\n-            MH_arrayIdentity         =  5,\n-            MH_countedLoopPred       =  6,\n-            MH_countedLoopStep       =  7,\n-            MH_initIterator          =  8,\n-            MH_iteratePred           =  9,\n-            MH_iterateNext           = 10,\n-            MH_Array_newInstance     = 11,\n-            MH_LIMIT                 = 12;\n+            MH_cast                  = 0,\n+            MH_selectAlternative     = 1,\n+            MH_countedLoopPred       = 2,\n+            MH_countedLoopStep       = 3,\n+            MH_initIterator          = 4,\n+            MH_iteratePred           = 5,\n+            MH_iterateNext           = 6,\n+            MH_Array_newInstance     = 7,\n+            MH_LIMIT                 = 8;\n@@ -2242,12 +1998,0 @@\n-                case MH_copyAsPrimitiveArray:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"copyAsPrimitiveArray\",\n-                            MethodType.methodType(Object.class, Wrapper.class, Object[].class));\n-                case MH_arrayIdentity:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"identity\",\n-                            MethodType.methodType(Object[].class, Object[].class));\n-                case MH_fillNewArray:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"fillNewArray\",\n-                            MethodType.methodType(Object[].class, Integer.class, Object[].class));\n-                case MH_fillNewTypedArray:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"fillNewTypedArray\",\n-                            MethodType.methodType(Object[].class, Object[].class, Integer.class, Object[].class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":96,"deletions":352,"binary":false,"changes":448,"status":"modified"},{"patch":"@@ -670,5 +670,2 @@\n-        switch (mem.getName()) {\n-        case \"getContextClassLoader\":\n-            return canBeCalledVirtual(mem, java.lang.Thread.class);\n-        }\n-        return false;\n+        return mem.getName().equals(\"getContextClassLoader\") &&\n+            canBeCalledVirtual(mem, java.lang.Thread.class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1894,1 +1894,1 @@\n-             * <a href=\"..\/ref\/package.html#reachability\">reachable<\/a>.\n+             * <a href=\"..\/ref\/package-summary.html#reachability\">reachable<\/a>.\n@@ -2034,1 +2034,1 @@\n-         * <a href=\"..\/ref\/package.html#reachability\">reachable<\/a>.\n+         * <a href=\"..\/ref\/package-summary.html#reachability\">reachable<\/a>.\n@@ -2265,1 +2265,1 @@\n-                    if (!(constant instanceof Type)) {\n+                    if (!(constant instanceof Type type)) {\n@@ -2268,1 +2268,0 @@\n-                    Type type = ((Type) constant);\n@@ -3672,2 +3671,1 @@\n-            Objects.requireNonNull(name);\n-            checkMethodName(refKind, name);  \/\/ NPE check on name\n+            checkMethodName(refKind, name);  \/\/ implicit null-check of name\n@@ -3697,0 +3695,13 @@\n+        MemberName resolveOrNull(byte refKind, Class<?> refc, String name, MethodType type) {\n+            \/\/ do this before attempting to resolve\n+            if (!isClassAccessible(refc)) {\n+                return null;\n+            }\n+            Objects.requireNonNull(type);\n+            \/\/ implicit null-check of name\n+            if (name.startsWith(\"<\") && refKind != REF_newInvokeSpecial) {\n+                return null;\n+            }\n+            return IMPL_NAMES.resolveOrNull(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(), allowedModes);\n+        }\n+\n@@ -5770,8 +5781,1 @@\n-        LambdaForm lform;\n-        if (collectorType.returnType().isArray() && filter.intrinsicName() == Intrinsic.NEW_ARRAY) {\n-            lform = result.editor().collectArgumentArrayForm(1 + pos, filter);\n-            if (lform != null) {\n-                return result.copyWith(newType, lform);\n-            }\n-        }\n-        lform = result.editor().collectArgumentsForm(1 + pos, collectorType.basicType());\n+        LambdaForm lform = result.editor().collectArgumentsForm(1 + pos, collectorType.basicType());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -377,3 +377,3 @@\n-        Objects.nonNull(target);\n-        Objects.nonNull(filterToTarget);\n-        Objects.nonNull(filterFromTarget);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(filterToTarget);\n+        Objects.requireNonNull(filterFromTarget);\n@@ -476,2 +476,2 @@\n-        Objects.nonNull(target);\n-        Objects.nonNull(filters);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(filters);\n@@ -505,2 +505,2 @@\n-        Objects.nonNull(target);\n-        Objects.nonNull(values);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(values);\n@@ -534,3 +534,3 @@\n-        Objects.nonNull(target);\n-        Objects.nonNull(newCoordinates);\n-        Objects.nonNull(reorder);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(newCoordinates);\n+        Objects.requireNonNull(reorder);\n@@ -582,2 +582,2 @@\n-        Objects.nonNull(target);\n-        Objects.nonNull(filter);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(filter);\n@@ -604,2 +604,2 @@\n-        Objects.nonNull(target);\n-        Objects.nonNull(valueTypes);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(valueTypes);\n@@ -622,2 +622,1 @@\n-        if (handle instanceof DirectMethodHandle) {\n-            DirectMethodHandle directHandle = (DirectMethodHandle)handle;\n+        if (handle instanceof DirectMethodHandle directHandle) {\n@@ -703,1 +702,1 @@\n-\/\/                final static <METHOD> throws Throwable {\n+\/\/                static final <METHOD> throws Throwable {\n@@ -721,1 +720,1 @@\n-\/\/                final static <METHOD> throws Throwable {\n+\/\/                static final <METHOD> throws Throwable {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -202,0 +202,2 @@\n+     * @jls 8.3 Field Declarations\n+     * @jls 9.3 Field (Constant) Declarations\n@@ -214,0 +216,1 @@\n+     * @jls 8.9.1 Enum Constants\n@@ -226,0 +229,3 @@\n+     * @see <a\n+     * href=\"{@docRoot}\/java.base\/java\/lang\/reflect\/package-summary.html#LanguageJvmModel\">Java\n+     * programming language and JVM modeling in core reflection<\/a>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -101,3 +101,3 @@\n-    private final static ProxyMethod hashCodeMethod;\n-    private final static ProxyMethod equalsMethod;\n-    private final static ProxyMethod toStringMethod;\n+    private static final ProxyMethod hashCodeMethod;\n+    private static final ProxyMethod equalsMethod;\n+    private static final ProxyMethod toStringMethod;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+    exports java.util.random;\n@@ -250,0 +251,2 @@\n+    exports jdk.internal.util.random to\n+        jdk.random;\n@@ -378,0 +381,1 @@\n+    uses java.util.random.RandomGenerator;\n@@ -401,0 +405,6 @@\n+\n+    provides java.util.random.RandomGenerator with\n+        java.security.SecureRandom,\n+        java.util.Random,\n+        java.util.SplittableRandom;\n+\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -829,1 +829,1 @@\n-        static public Name formFullName(Name name, Symbol owner) {\n+        public static Name formFullName(Name name, Symbol owner) {\n@@ -844,1 +844,1 @@\n-        static public Name formFlatName(Name name, Symbol owner) {\n+        public static Name formFlatName(Name name, Symbol owner) {\n@@ -2503,1 +2503,1 @@\n-            static public AccessCode getFromCode(int code) {\n+            public static AccessCode getFromCode(int code) {\n@@ -2547,1 +2547,1 @@\n-        public final static Completer NULL_COMPLETER = new Completer() {\n+        public static final Completer NULL_COMPLETER = new Completer() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -414,1 +414,1 @@\n-        private final static TypeMapping<Void> stripMetadata = new StructuralTypeMapping<Void>() {\n+        private static final TypeMapping<Void> stripMetadata = new StructuralTypeMapping<Void>() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1093,1 +1093,1 @@\n-    final public boolean isSubtype(Type t, Type s) {\n+    public final boolean isSubtype(Type t, Type s) {\n@@ -1096,1 +1096,1 @@\n-    final public boolean isSubtypeNoCapture(Type t, Type s) {\n+    public final boolean isSubtypeNoCapture(Type t, Type s) {\n@@ -4220,1 +4220,1 @@\n-        private Type arraySuperType = null;\n+        private Type arraySuperType;\n@@ -4224,8 +4224,3 @@\n-                synchronized (this) {\n-                    if (arraySuperType == null) {\n-                        \/\/ JLS 10.8: all arrays implement Cloneable and Serializable.\n-                        List<Type> ifaces =\n-                                List.of(syms.serializableType, syms.cloneableType, syms.identityObjectType);\n-                        arraySuperType = makeIntersectionType(ifaces, true);\n-                    }\n-                }\n+                \/\/ JLS 10.8: all arrays implement Cloneable and Serializable.\n+                arraySuperType = makeIntersectionType(List.of(syms.serializableType,\n+                        syms.cloneableType, syms.identityObjectType), true);\n@@ -5058,1 +5053,1 @@\n-        final public R visit(Type t, S s)               { return t.accept(this, s); }\n+        public final R visit(Type t, S s)               { return t.accept(this, s); }\n@@ -5085,1 +5080,1 @@\n-        final public R visit(Symbol s, S arg)                   { return s.accept(this, arg); }\n+        public final R visit(Symbol s, S arg)                   { return s.accept(this, arg); }\n@@ -5138,1 +5133,1 @@\n-        final public R visit(Type t) { return t.accept(this, null); }\n+        public final R visit(Type t) { return t.accept(this, null); }\n@@ -5152,1 +5147,1 @@\n-        final public Type visit(Type t) { return t.accept(this, null); }\n+        public final Type visit(Type t) { return t.accept(this, null); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2136,1 +2136,1 @@\n-    final static TypeTag[] primitiveTags = new TypeTag[]{\n+    static final TypeTag[] primitiveTags = new TypeTag[]{\n@@ -4097,0 +4097,1 @@\n+        boolean checkRawTypes;\n@@ -4109,0 +4110,1 @@\n+            checkRawTypes = true;\n@@ -4112,0 +4114,1 @@\n+            checkRawTypes = false;\n@@ -4141,1 +4144,1 @@\n-        chk.validate(typeTree, env, false);\n+        chk.validate(typeTree, env, checkRawTypes);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import java.util.stream.StreamSupport;\n@@ -388,3 +389,8 @@\n-        return (t.hasTag(ARRAY))\n-            ? isAccessible(env, types.cvarUpperBound(types.elemtype(t)))\n-            : isAccessible(env, t.tsym, checkInner);\n+        if (t.hasTag(ARRAY)) {\n+            return isAccessible(env, types.cvarUpperBound(types.elemtype(t)));\n+        } else if (t.isUnion()) {\n+            return StreamSupport.stream(((UnionClassType) t).getAlternativeTypes().spliterator(), false)\n+                    .allMatch(alternative -> isAccessible(env, alternative.tsym, checkInner));\n+        } else {\n+            return isAccessible(env, t.tsym, checkInner);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-    final static boolean checkClash = true;\n+    static final boolean checkClash = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    public final static int JAVA_MAGIC = 0xCAFEBABE;\n+    public static final int JAVA_MAGIC = 0xCAFEBABE;\n@@ -70,18 +70,18 @@\n-    public final static int CONSTANT_Utf8 = 1;\n-    public final static int CONSTANT_Unicode = 2;\n-    public final static int CONSTANT_Integer = 3;\n-    public final static int CONSTANT_Float = 4;\n-    public final static int CONSTANT_Long = 5;\n-    public final static int CONSTANT_Double = 6;\n-    public final static int CONSTANT_Class = 7;\n-    public final static int CONSTANT_String = 8;\n-    public final static int CONSTANT_Fieldref = 9;\n-    public final static int CONSTANT_Methodref = 10;\n-    public final static int CONSTANT_InterfaceMethodref = 11;\n-    public final static int CONSTANT_NameandType = 12;\n-    public final static int CONSTANT_MethodHandle = 15;\n-    public final static int CONSTANT_MethodType = 16;\n-    public final static int CONSTANT_Dynamic = 17;\n-    public final static int CONSTANT_InvokeDynamic = 18;\n-    public final static int CONSTANT_Module = 19;\n-    public final static int CONSTANT_Package = 20;\n+    public static final int CONSTANT_Utf8 = 1;\n+    public static final int CONSTANT_Unicode = 2;\n+    public static final int CONSTANT_Integer = 3;\n+    public static final int CONSTANT_Float = 4;\n+    public static final int CONSTANT_Long = 5;\n+    public static final int CONSTANT_Double = 6;\n+    public static final int CONSTANT_Class = 7;\n+    public static final int CONSTANT_String = 8;\n+    public static final int CONSTANT_Fieldref = 9;\n+    public static final int CONSTANT_Methodref = 10;\n+    public static final int CONSTANT_InterfaceMethodref = 11;\n+    public static final int CONSTANT_NameandType = 12;\n+    public static final int CONSTANT_MethodHandle = 15;\n+    public static final int CONSTANT_MethodType = 16;\n+    public static final int CONSTANT_Dynamic = 17;\n+    public static final int CONSTANT_InvokeDynamic = 18;\n+    public static final int CONSTANT_Module = 19;\n+    public static final int CONSTANT_Package = 20;\n@@ -89,9 +89,9 @@\n-    public final static int REF_getField = 1;\n-    public final static int REF_getStatic = 2;\n-    public final static int REF_putField = 3;\n-    public final static int REF_putStatic = 4;\n-    public final static int REF_invokeVirtual = 5;\n-    public final static int REF_invokeStatic = 6;\n-    public final static int REF_invokeSpecial = 7;\n-    public final static int REF_newInvokeSpecial = 8;\n-    public final static int REF_invokeInterface = 9;\n+    public static final int REF_getField = 1;\n+    public static final int REF_getStatic = 2;\n+    public static final int REF_putField = 3;\n+    public static final int REF_putStatic = 4;\n+    public static final int REF_invokeVirtual = 5;\n+    public static final int REF_invokeStatic = 6;\n+    public static final int REF_invokeSpecial = 7;\n+    public static final int REF_newInvokeSpecial = 8;\n+    public static final int REF_invokeInterface = 9;\n@@ -99,5 +99,5 @@\n-    public final static int MAX_PARAMETERS = 0xff;\n-    public final static int MAX_DIMENSIONS = 0xff;\n-    public final static int MAX_CODE = 0xffff;\n-    public final static int MAX_LOCALS = 0xffff;\n-    public final static int MAX_STACK = 0xffff;\n+    public static final int MAX_PARAMETERS = 0xff;\n+    public static final int MAX_DIMENSIONS = 0xff;\n+    public static final int MAX_CODE = 0xffff;\n+    public static final int MAX_LOCALS = 0xffff;\n+    public static final int MAX_STACK = 0xffff;\n@@ -105,1 +105,1 @@\n-    public final static int PREVIEW_MINOR_VERSION = 0xffff;\n+    public static final int PREVIEW_MINOR_VERSION = 0xffff;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-        private final static String[] flagName = {\n+        private static final String[] flagName = {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2254,1 +2254,1 @@\n-        private final static String[] mnem = new String[ByteCodeCount];\n+        private static final String[] mnem = new String[ByteCodeCount];\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1946,1 +1946,1 @@\n-    private final static Fragment[][] decisionTable = new Fragment[][] {\n+    private static final Fragment[][] decisionTable = new Fragment[][] {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-    final static class NamedToken extends Token {\n+    static final class NamedToken extends Token {\n@@ -439,1 +439,1 @@\n-    final static class NumericToken extends StringToken {\n+    static final class NumericToken extends StringToken {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    private final static String trimSequence = \"[...]\";\n+    private static final String trimSequence = \"[...]\";\n@@ -91,1 +91,1 @@\n-    private final static int PREFERRED_LENGTH = 20;\n+    private static final int PREFERRED_LENGTH = 20;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1042,1 +1042,1 @@\n-        while ((flag & flags & ExtendedStandardFlags) == 0)\n+        while ((flag & flags) == 0)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -931,1 +931,1 @@\n-                unsafe.copyMemory(bytes, vm.ARRAY_BYTE_BASE_OFFSET, null, buffer, length);\n+                unsafe.copyMemory(bytes, Unsafe.ARRAY_BYTE_BASE_OFFSET, null, buffer, length);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3178,1 +3178,1 @@\n-            parentPreviewAPI = configuration.workArounds.isPreviewAPI(el.getEnclosingElement());\n+            parentPreviewAPI = configuration.workArounds.isPreviewAPI(enclosing);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -272,1 +272,14 @@\n-        super.visitDocComment(tree, ignore);\n+        scan(tree.getFirstSentence(), ignore);\n+        scan(tree.getBody(), ignore);\n+        checkTagStack();\n+\n+        for (DocTree blockTag : tree.getBlockTags()) {\n+            tagStack.clear();\n+            scan(blockTag, ignore);\n+            checkTagStack();\n+        }\n+\n+        return null;\n+    }\n+\n+    private void checkTagStack() {\n@@ -281,1 +294,0 @@\n-        return null;\n@@ -551,0 +563,1 @@\n+                    warnIfEmpty(top, null);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    Thread* THREAD = Thread::current();\n+    JavaThread* THREAD = JavaThread::current();\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-compiler\/codecache\/jmx\/PoolsIndependenceTest.java 8167015 generic-all\n@@ -47,0 +46,1 @@\n+compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/NativeCallTest.java 8262901 macosx-aarch64\n@@ -66,8 +66,0 @@\n-compiler\/arguments\/CheckCICompilerCount.java                        8205030 generic-all\n-compiler\/arguments\/CheckCompileThresholdScaling.java                8205030 generic-all\n-compiler\/codecache\/CheckSegmentedCodeCache.java                     8205030 generic-all\n-compiler\/codecache\/cli\/TestSegmentedCodeCacheOption.java            8205030 generic-all\n-compiler\/codecache\/cli\/codeheapsize\/TestCodeHeapSizeOptions.java    8205030 generic-all\n-compiler\/codecache\/cli\/printcodecache\/TestPrintCodeCacheOption.java 8205030 generic-all\n-compiler\/whitebox\/OSRFailureLevel4Test.java                         8205030 generic-all\n-\n@@ -144,0 +136,4 @@\n+compiler\/whitebox\/ClearMethodStateTest.java 8265360 macosx-aarch64\n+compiler\/whitebox\/EnqueueMethodForCompilationTest.java 8265360 macosx-aarch64\n+compiler\/whitebox\/MakeMethodNotCompilableTest.java 8265360 macosx-aarch64\n+\n@@ -188,0 +184,17 @@\n+runtime\/cds\/appcds\/cacheObject\/CheckCachedMirrorTest.java 8265719 generic-all\n+runtime\/cds\/appcds\/cacheObject\/CheckCachedResolvedReferences.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/ClassListFormatA.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/ClassListFormatD.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/ClassListFormatE.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/HelloCustom.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/HelloCustom_JFR.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/LoaderSegregationTest.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/ParallelTestMultiFP.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/ParallelTestSingleFP.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/PrintSharedArchiveAndExit.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/ProtectionDomain.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/SameNameInTwoLoadersTest.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/UnintendedLoadersTest.java 8265719 generic-all\n+runtime\/cds\/appcds\/customLoader\/UnloadUnregisteredLoaderTest.java 8265719 generic-all\n+runtime\/cds\/appcds\/jvmti\/transformRelatedClasses\/TransformInterfaceImplementorAppCDS.java 8265719 generic-all\n+runtime\/cds\/appcds\/jvmti\/transformRelatedClasses\/TransformSuperSubAppCDS.java 8265719 generic-all\n@@ -270,7 +283,1 @@\n-vmTestbase\/vm\/mlvm\/meth\/func\/java\/throwException\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/deoptimize\/Test.java#id1 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/i2c_c2i\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/sequences\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/gc\/callSequencesDuringGC\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/java\/sequences\/Test.java 8058176 generic-all\n-vmTestbase\/vm\/mlvm\/meth\/stress\/jdi\/breakpointInCompiledCode\/Test.java 8058176 generic-all\n+vmTestbase\/vm\/mlvm\/meth\/stress\/jdi\/breakpointInCompiledCode\/Test.java 8257761 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -346,0 +346,1 @@\n+ -runtime\/cds\/appcds\/jcmd\/JCmdTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n","filename":"test\/hotspot\/jtreg\/compiler\/tiered\/ConstantGettersTransitionsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestMeetIncompatibleInterfaceArrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC2CCalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConventionC1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestDeoptimizationWhenBuffering.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestGetfieldChains.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestJNICalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNewAcmp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOnStackReplacement.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedInlineTypeField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestWithfieldC1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run driver ClassFileInstaller -jar hello.jar Hello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar Hello\n@@ -38,0 +38,1 @@\n+import jdk.test.lib.helpers.ClassFileInstaller;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ArchiveRelocationTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run driver ClassFileInstaller -jar hello_inline.jar HelloInlineClassApp HelloInlineClassApp$Point HelloInlineClassApp$Point$ref HelloInlineClassApp$Rectangle HelloInlineClassApp$Rectangle$ref\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello_inline.jar HelloInlineClassApp HelloInlineClassApp$Point HelloInlineClassApp$Point$ref HelloInlineClassApp$Rectangle HelloInlineClassApp$Rectangle$ref\n@@ -35,0 +35,1 @@\n+import jdk.test.lib.helpers.ClassFileInstaller;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/HelloInlineClassTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/RewriteBytecodesInlineTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n- * @run driver ClassFileInstaller -jar hello.jar HelloRelocation HelloInlineClassApp HelloInlineClassApp$Point HelloInlineClassApp$Point$ref HelloInlineClassApp$Rectangle HelloInlineClassApp$Rectangle$ref\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar HelloRelocation HelloInlineClassApp HelloInlineClassApp$Point HelloInlineClassApp$Point$ref HelloInlineClassApp$Rectangle HelloInlineClassApp$Rectangle$ref\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n@@ -41,0 +41,1 @@\n+import jdk.test.lib.helpers.ClassFileInstaller;\n@@ -90,6 +91,0 @@\n-        String runtimeRelocMsg = \"runtime archive relocation start\";\n-        String unmapPrefix = \".*Unmapping region #3 at base 0x.*\";\n-        String unmapPattern = unmapPrefix + \"(Bitmap)\";\n-        String archiveRelocPattern = \".*ArchiveRelocationMode == 1.*\";\n-        String unmapRgn1Pattern = \".*Unmapping region #1 at base 0x.*\";\n-        String unmapRgn0Pattern = \".*Unmapping region #0 at base 0x.*(ReadWrite)\";\n@@ -100,2 +95,2 @@\n-        OutputAnalyzer out = TestCommon.dumpBaseArchive(baseArchiveName, unlockArg, logArg);\n-        out.shouldContain(\"Relocating archive from\");\n+        TestCommon.dumpBaseArchive(baseArchiveName, unlockArg, logArg)\n+          .shouldContain(\"Relocating archive from\");\n@@ -124,14 +119,0 @@\n-                        try {\n-                            output.shouldContain(runtimeRelocMsg)\n-                                  \/\/ Check that there are two of the following lines in\n-                                  \/\/ the output. One for static archive and one for\n-                                  \/\/ dynamic archive:\n-                                  \/\/ Unmapping region #3 at base 0x<hex digits> (Bitmap)\n-                                  .shouldMatchByLine(unmapPrefix, \"Hello World\", unmapPattern);\n-                        } catch(java.lang.RuntimeException ex) {\n-                            \/\/ On Windows, sometimes the OS picks the same archive\n-                            \/\/ base address even with ArchiveRelcationMode=1. In\n-                            \/\/ this case, runtime relocation won't happen. Checking\n-                            \/\/ for \"Unmapping region #0\" messages instead.\n-                            output.shouldMatchByLine(archiveRelocPattern, unmapRgn1Pattern, unmapRgn0Pattern);\n-                        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveRelocationTest.java","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n- * @run driver ClassFileInstaller -jar hello_inline.jar HelloInlineClassApp HelloInlineClassApp$Point HelloInlineClassApp$Point$ref HelloInlineClassApp$Rectangle HelloInlineClassApp$Rectangle$ref\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello_inline.jar HelloInlineClassApp HelloInlineClassApp$Point HelloInlineClassApp$Point$ref HelloInlineClassApp$Rectangle HelloInlineClassApp$Rectangle$ref\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission\n@@ -37,0 +37,2 @@\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/HelloDynamicInlineClass.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import jdk.test.lib.helpers.ClassFileInstaller;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/LockDuringDump.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n@@ -58,1 +58,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n@@ -73,1 +73,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n@@ -88,1 +88,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n@@ -104,1 +104,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n@@ -119,1 +119,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n@@ -134,1 +134,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n@@ -149,1 +149,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineOops.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeDensity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValueTearing.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Heap\/IterateHeapWithEscapeAnalysisEnabled.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n@@ -90,1 +90,1 @@\n- * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -34,0 +35,1 @@\n+import java.util.Collections;\n@@ -38,0 +40,1 @@\n+import java.util.Set;\n@@ -121,0 +124,1 @@\n+        map.put(\"vm.flagless\", this::isFlagless);\n@@ -536,0 +540,59 @@\n+    \/**\n+     * Checks if we are in <i>almost<\/i> out-of-box configuration, i.e. the flags\n+     * which JVM is started with don't affect its behavior \"significantly\".\n+     * {@code TEST_VM_FLAGLESS} enviroment variable can be used to force this\n+     * method to return true and allow any flags.\n+     *\n+     * @return true if there are no JVM flags\n+     *\/\n+    private String isFlagless() {\n+        boolean result = true;\n+        if (System.getenv(\"TEST_VM_FLAGLESS\") != null) {\n+            return \"\" + result;\n+        }\n+\n+        List<String> allFlags = new ArrayList<String>();\n+        Collections.addAll(allFlags, System.getProperty(\"test.vm.opts\", \"\").trim().split(\"\\\\s+\"));\n+        Collections.addAll(allFlags, System.getProperty(\"test.java.opts\", \"\").trim().split(\"\\\\s+\"));\n+\n+        \/\/ check -XX flags\n+        var ignoredXXFlags = Set.of(\n+                \/\/ added by run-test framework\n+                \"MaxRAMPercentage\",\n+                \/\/ added by test environment\n+                \"CreateCoredumpOnCrash\"\n+        );\n+        result &= allFlags.stream()\n+                          .filter(s -> s.startsWith(\"-XX:\"))\n+                          \/\/ map to names:\n+                              \/\/ remove -XX:\n+                              .map(s -> s.substring(4))\n+                              \/\/ remove +\/- from bool flags\n+                              .map(s -> s.charAt(0) == '+' || s.charAt(0) == '-' ? s.substring(1) : s)\n+                              \/\/ remove =.* from others\n+                              .map(s -> s.contains(\"=\") ? s.substring(0, s.indexOf('=')) : s)\n+                          \/\/ skip known-to-be-there flags\n+                          .filter(s -> !ignoredXXFlags.contains(s))\n+                          .findAny()\n+                          .isEmpty();\n+\n+        \/\/ check -X flags\n+        var ignoredXFlags = Set.of(\n+                \/\/ default, yet still seen to be explicitly set\n+                \"mixed\"\n+        );\n+        result &= allFlags.stream()\n+                          .filter(s -> s.startsWith(\"-X\") && !s.startsWith(\"-XX:\"))\n+                          \/\/ map to names:\n+                              \/\/ remove -X\n+                              .map(s -> s.substring(2))\n+                              \/\/ remove :.* from flags with values\n+                              .map(s -> s.contains(\":\") ? s.substring(0, s.indexOf(':')) : s)\n+                          \/\/ skip known-to-be-there flags\n+                          .filter(s -> !ignoredXFlags.contains(s))\n+                          .findAny()\n+                          .isEmpty();\n+\n+        return \"\" + result;\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -414,1 +414,1 @@\n-  public native long metaspaceReserveAlignment();\n+  public native long metaspaceSharedRegionAlignment();\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}