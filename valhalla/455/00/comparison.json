{"files":[{"patch":"@@ -482,1 +482,1 @@\n-    \/** Is this symbol a value factory?\n+    \/** Is this symbol a primitive object factory?\n@@ -484,1 +484,1 @@\n-    public boolean isValueFactory() {\n+    public boolean isPrimitiveObjectFactory() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-                    \/* Temporary treatment for inline class: Given an inline class V that implements\n+                    \/* Temporary treatment for primitive class: Given a primitive class V that implements\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-     * @return true IFF the receiver is a reference projection of an inline type and false\n+     * @return true IFF the receiver is a reference projection of a primitive class type and false\n@@ -261,1 +261,1 @@\n-     * @return the value projection type IFF the receiver is a reference projection of an inline type\n+     * @return the value projection type IFF the receiver is a reference projection of a primitive class type\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1648,1 +1648,1 @@\n-                    \/* If a value class V implements an interface I, then does \"? extends I\" contain V?\n+                    \/* If a primitive class V implements an interface I, then does \"? extends I\" contain V?\n@@ -2377,1 +2377,1 @@\n-                \/\/ No instance fields and no arged constructors both mean inner classes cannot be inline supers.\n+                \/\/ No instance fields and no arged constructors both mean inner classes cannot be primitive class supers.\n@@ -2479,1 +2479,1 @@\n-        \/* If any inline types are involved, switch over to the reference universe,\n+        \/* If any primitive class types are involved, switch over to the reference universe,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-                \/* Allow updates to instance fields of value classes by any method in the same nest via the\n+                \/* Allow updates to instance fields of primitive classes by any method in the same nest via the\n@@ -1323,1 +1323,1 @@\n-            \/* Don't want constant propagation\/folding for instance fields of value classes,\n+            \/* Don't want constant propagation\/folding for instance fields of primitive classes,\n@@ -2208,2 +2208,2 @@\n-            \/\/ Those were all the cases that could result in a primitive. See if primitive boxing and inline\n-            \/\/ narrowing conversions bring about a convergence.\n+            \/\/ Those were all the cases that could result in a primitive. See if primitive boxing and primitive\n+            \/\/ value conversions bring about a convergence.\n@@ -2653,1 +2653,1 @@\n-                \/* Is this an ill conceived attempt to invoke jlO methods not available on value types ??\n+                \/* Is this an ill conceived attempt to invoke jlO methods not available on primitive class types ??\n@@ -2655,1 +2655,1 @@\n-                boolean superCallOnValueReceiver = types.isPrimitiveClass(env.enclClass.sym.type)\n+                boolean superCallOnPrimitiveReceiver = types.isPrimitiveClass(env.enclClass.sym.type)\n@@ -2659,1 +2659,1 @@\n-                if (types.isPrimitiveClass(qualifier) || superCallOnValueReceiver) {\n+                if (types.isPrimitiveClass(qualifier) || superCallOnPrimitiveReceiver) {\n@@ -2695,1 +2695,1 @@\n-                \/\/ Temporary treatment for inline class: Given an inline class V that implements\n+                \/\/ Temporary treatment for primitive classes: Given a primitive class V that implements\n@@ -3059,1 +3059,1 @@\n-                    chk.checkParameterizationWithValues(tree, clazztype);\n+                    chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n@@ -3132,1 +3132,1 @@\n-        \/\/ Likewise arg can't be null if it is a value.\n+        \/\/ Likewise arg can't be null if it is a primitive class instance.\n@@ -5540,1 +5540,1 @@\n-                if ((c.flags() & (PRIMITIVE_CLASS | ABSTRACT)) == PRIMITIVE_CLASS) { \/\/ for non-intersection, concrete values.\n+                if ((c.flags() & (PRIMITIVE_CLASS | ABSTRACT)) == PRIMITIVE_CLASS) { \/\/ for non-intersection, concrete primitive classes.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -608,1 +608,1 @@\n-                    checkParameterizationWithValues(pos, found);\n+                    checkParameterizationByPrimitiveClass(pos, found);\n@@ -752,1 +752,2 @@\n-            \/\/ No instance fields and no arged constructors both mean inner classes cannot be inline supers.\n+            \/\/ No instance fields and no arged constructors both mean inner classes\n+            \/\/ cannot be super classes for primitive classes.\n@@ -839,1 +840,1 @@\n-     *  @param valueOK       If false, a value class does not qualify\n+     *  @param primitiveClassOK       If false, a primitive class does not qualify\n@@ -841,2 +842,2 @@\n-    Type checkRefType(DiagnosticPosition pos, Type t, boolean valueOK) {\n-        if (t.isReference() && (valueOK || !types.isPrimitiveClass(t)))\n+    Type checkRefType(DiagnosticPosition pos, Type t, boolean primitiveClassOK) {\n+        if (t.isReference() && (primitiveClassOK || !types.isPrimitiveClass(t)))\n@@ -926,2 +927,2 @@\n-    void checkParameterizationWithValues(DiagnosticPosition pos, Type t) {\n-        valueParameterizationChecker.visit(t, pos);\n+    void checkParameterizationByPrimitiveClass(DiagnosticPosition pos, Type t) {\n+        parameterizationByPrimitiveClassChecker.visit(t, pos);\n@@ -930,1 +931,1 @@\n-    \/** valueParameterizationChecker: A type visitor that descends down the given type looking for instances of value types\n+    \/** parameterizationByPrimitiveClassChecker: A type visitor that descends down the given type looking for instances of primitive classes\n@@ -933,1 +934,2 @@\n-    private final Types.SimpleVisitor<Void, DiagnosticPosition> valueParameterizationChecker = new Types.SimpleVisitor<Void, DiagnosticPosition>() {\n+    private final Types.SimpleVisitor<Void, DiagnosticPosition> parameterizationByPrimitiveClassChecker =\n+            new Types.SimpleVisitor<Void, DiagnosticPosition>() {\n@@ -1124,1 +1126,1 @@\n-            checkParameterizationWithValues(pos, varType);\n+            checkParameterizationByPrimitiveClass(pos, varType);\n@@ -1390,1 +1392,1 @@\n-                \/\/ instance methods of value types do not have a monitor associated with their `this'\n+                \/\/ instance methods of primitive classes do not have a monitor associated with their `this'\n@@ -1429,1 +1431,1 @@\n-                \/\/ enums can't be declared abstract, final, sealed or non-sealed or value type\n+                \/\/ enums can't be declared abstract, final, sealed or non-sealed or primitive\n@@ -2451,1 +2453,1 @@\n-    \/\/ A value class cannot contain a field of its own type either or indirectly.\n+    \/\/ A primitive class cannot contain a field of its own type either or indirectly.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1680,2 +1680,2 @@\n-        ALLOWED,     \/\/ Normal Object classes - NOP\n-        BANNED,      \/\/ Value types           - Error\n+        ALLOWED,     \/\/ identity Object classes - NOP\n+        BANNED,      \/\/ primitive classes - Error\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2276,2 +2276,2 @@\n-            \/* Per our interim inline class translation scheme, the reference projection classes\n-               are completely empty, so we want the methods in the value class to be invoked instead.\n+            \/* Per our interim primitive class translation scheme, the reference projection classes\n+               are completely empty, so we want the methods in the primitive class to be invoked instead.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-        \/* Don't want constant propagation\/folding for instance fields of value classes,\n+        \/* Don't want constant propagation\/folding for instance fields of primitive classes,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -423,1 +423,1 @@\n-            \/* If any inline types are involved, ask the same question in the reference universe,\n+            \/* If any primitive class types are involved, ask the same question in the reference universe,\n@@ -488,1 +488,1 @@\n-        \/* If any inline types are involved, ask the same question in the reference universe,\n+        \/* If any primitive class types are involved, ask the same question in the reference universe,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-        \/\/ value-type bytecodes\n+        \/\/ primitive classes related bytecodes\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ByteCodes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2739,1 +2739,1 @@\n-               reference projection; instead, the two are related by inline narrowing and widening\n+               reference projection; instead, the two are related by primitive reference and value\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-    private final TransValues transValues;\n+    private final TransPrimitiveClass transPrimitiveClass;\n@@ -119,1 +119,1 @@\n-        transValues = TransValues.instance(context);\n+        transPrimitiveClass = TransPrimitiveClass.instance(context);\n@@ -1004,1 +1004,1 @@\n-                    } else if (env.enclMethod.sym.isValueFactory()) {\n+                    } else if (env.enclMethod.sym.isPrimitiveObjectFactory()) {\n@@ -2282,1 +2282,1 @@\n-        \/\/ inline widening conversion is a nop when we bifurcate the primitive class, as the VM sees a subtyping relationship.\n+        \/\/ primitive reference conversion is a nop when we bifurcate the primitive class, as the VM sees a subtyping relationship.\n@@ -2482,1 +2482,1 @@\n-            cdef = transValues.translateTopLevelClass(cdef, make);\n+            cdef = transPrimitiveClass.translateTopLevelClass(cdef, make);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n- * This pass translates value constructors into static factory methods and patches up constructor\n+ * This pass translates primitive class constructors into static factory methods and patches up constructor\n@@ -85,1 +85,1 @@\n-public class TransValues extends TreeTranslator {\n+public class TransPrimitiveClass extends TreeTranslator {\n@@ -87,1 +87,1 @@\n-    protected static final Context.Key<TransValues> transValuesKey = new Context.Key<>();\n+    protected static final Context.Key<TransPrimitiveClass> transPrimitiveClass = new Context.Key<>();\n@@ -111,2 +111,2 @@\n-    public static TransValues instance(Context context) {\n-        TransValues instance = context.get(transValuesKey);\n+    public static TransPrimitiveClass instance(Context context) {\n+        TransPrimitiveClass instance = context.get(transPrimitiveClass);\n@@ -114,1 +114,1 @@\n-            instance = new TransValues(context);\n+            instance = new TransPrimitiveClass(context);\n@@ -118,2 +118,2 @@\n-    protected TransValues(Context context) {\n-        context.put(transValuesKey, this);\n+    protected TransPrimitiveClass(Context context) {\n+        context.put(transPrimitiveClass, this);\n@@ -183,1 +183,1 @@\n-            if (constructingValue()) {\n+            if (constructingPrimitiveObject()) {\n@@ -185,1 +185,1 @@\n-                \/\/ Mutate this value constructor into an equivalent static value factory\n+                \/\/ Mutate this primitive class constructor into an equivalent static factory\n@@ -192,1 +192,1 @@\n-                   is passed as an argument into the <init> method, a value factory must allocate the value\n+                   is passed as an argument into the <init> method, the primitive static factory must allocate the\n@@ -209,1 +209,1 @@\n-                    MethodSymbol factory = getValueFactory(symbol);\n+                    MethodSymbol factory = getPrimitiveObjectFactory(symbol);\n@@ -215,1 +215,1 @@\n-                \/* The value product allocation prologue must precede any synthetic inits !!!\n+                \/* The static factory product allocation prologue must precede any synthetic inits !!!\n@@ -217,1 +217,1 @@\n-                   not for values.\n+                   not for primitive objects.\n@@ -223,1 +223,1 @@\n-                MethodSymbol factorySym = getValueFactory(tree.sym);\n+                MethodSymbol factorySym = getPrimitiveObjectFactory(tree.sym);\n@@ -231,1 +231,1 @@\n-                \/* We may need an epilogue that returns the value product, but we can't eagerly insert\n+                \/* We may need an epilogue that returns the factory product, but we can't eagerly insert\n@@ -248,1 +248,1 @@\n-        if (constructingValue()) {\n+        if (constructingPrimitiveObject()) {\n@@ -255,1 +255,1 @@\n-    \/* Note: 1. Assignop does not call for any translation, since value instance fields are final and\n+    \/* Note: 1. Assignop does not call for any translation, since primitive class instance fields are final and\n@@ -260,1 +260,1 @@\n-        if (constructingValue()) {\n+        if (constructingPrimitiveObject()) {\n@@ -289,1 +289,1 @@\n-        if (constructingValue()) {\n+        if (constructingPrimitiveObject()) {\n@@ -299,1 +299,1 @@\n-        if (constructingValue()) {\n+        if (constructingPrimitiveObject()) {\n@@ -315,1 +315,1 @@\n-        if (constructingValue()) { \/\/ Qualified this would have been lowered already.\n+        if (constructingPrimitiveObject()) { \/\/ Qualified this would have been lowered already.\n@@ -356,1 +356,1 @@\n-    \/\/ Translate a reference style instance creation attempt on a value type to a static factory call.\n+    \/\/ Translate a reference style instance creation attempt on a primitive class to a static factory call.\n@@ -364,1 +364,1 @@\n-            MethodSymbol sFactory = getValueFactory((MethodSymbol) tree.constructor);\n+            MethodSymbol sFactory = getPrimitiveObjectFactory((MethodSymbol) tree.constructor);\n@@ -379,1 +379,1 @@\n-    private boolean constructingValue() {\n+    private boolean constructingPrimitiveObject() {\n@@ -390,1 +390,1 @@\n-    private MethodSymbol getValueFactory(MethodSymbol init) {\n+    private MethodSymbol getPrimitiveObjectFactory(MethodSymbol init) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransPrimitiveClass.java","additions":26,"deletions":26,"binary":false,"changes":52,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","status":"renamed"},{"patch":"@@ -3357,1 +3357,1 @@\n-        \/\/ Force value classes to be automatically final.\n+        \/\/ Force primitive classes to be automatically final.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-        \/\/ value types\n+        \/\/ primitive classes\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2495,1 +2495,1 @@\n-        return isKind(doctree, Kind.VALUE);\n+        return isKind(doctree, VALUE);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1150,2 +1150,0 @@\n-            case METHOD:\n-                \/\/ Ditto for a synthetic method injected by the compiler (for value types)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-                if (!returnType.equals(\"void\")) { \/\/ value static factories\n+                if (!returnType.equals(\"void\")) { \/\/ static factories for primitive classes\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -168,3 +168,1 @@\n-        }\n-        String s;\n-        if (longform) {\n+        } else if (longform) {\n@@ -178,1 +176,1 @@\n-            s = fullClassNameAndPackageToClass.apply(\n+            return fullClassNameAndPackageToClass.apply(\n@@ -183,1 +181,1 @@\n-            s = sym.name.toString();\n+            return sym.name.toString();\n@@ -185,1 +183,0 @@\n-        return s;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/TypePrinter.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary [lworld] javac issues bogus \"no comment\" doclint warning while compiling value class\n+ * @summary [lworld] javac issues bogus \"no comment\" doclint warning while compiling primitive class\n@@ -32,1 +32,2 @@\n- * Test javadoc\n+ * NOTE: This test is not relevant as we don't inject synthetic methods into primitive\n+ *       classes anymore, but is still left in just the same.\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/DocLintSyntheticsTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}