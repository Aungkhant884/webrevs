{"files":[{"patch":"@@ -964,1 +964,1 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n@@ -973,1 +973,2 @@\n-                                                            AdapterBlob*& new_adapter) {\n+                                                            AdapterBlob*& new_adapter,\n+                                                            bool allocate_code_blob) {\n@@ -1038,3 +1039,4 @@\n-\n-  bool caller_must_gc_arguments = (regs != regs_cc);\n-  new_adapter = AdapterBlob::create(masm->code(), frame_complete, frame_size_in_words, oop_maps, caller_must_gc_arguments);\n+  if (allocate_code_blob) {\n+    bool caller_must_gc_arguments = (regs != regs_cc);\n+    new_adapter = AdapterBlob::create(masm->code(), frame_complete, frame_size_in_words, oop_maps, caller_must_gc_arguments);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1199,1 +1199,1 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n@@ -1208,1 +1208,2 @@\n-                                                            AdapterBlob*& new_adapter) {\n+                                                            AdapterBlob*& new_adapter,\n+                                                            bool allocate_code_blob) {\n@@ -1285,2 +1286,4 @@\n-  bool caller_must_gc_arguments = (regs != regs_cc);\n-  new_adapter = AdapterBlob::create(masm->code(), frame_complete, frame_size_in_words, oop_maps, caller_must_gc_arguments);\n+  if (allocate_code_blob) {\n+    bool caller_must_gc_arguments = (regs != regs_cc);\n+    new_adapter = AdapterBlob::create(masm->code(), frame_complete, frame_size_in_words, oop_maps, caller_must_gc_arguments);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler* masm,\n@@ -71,9 +71,12 @@\n-                                                            const GrowableArray <SigEntry> *sig,\n-                                                            const VMRegPair *regs,\n-                                                            const GrowableArray <SigEntry> *sig_cc,\n-                                                            const VMRegPair *regs_cc,\n-                                                            const GrowableArray <SigEntry> *sig_cc_ro,\n-                                                            const VMRegPair *regs_cc_ro,\n-                                                            AdapterFingerPrint *fingerprint,\n-                                                            AdapterBlob *&new_adapter) {\n-  new_adapter = AdapterBlob::create(masm->code(), 0, 0, NULL);\n+                                                            const GrowableArray <SigEntry>* sig,\n+                                                            const VMRegPair* regs,\n+                                                            const GrowableArray <SigEntry>* sig_cc,\n+                                                            const VMRegPair* regs_cc,\n+                                                            const GrowableArray <SigEntry>* sig_cc_ro,\n+                                                            const VMRegPair* regs_cc_ro,\n+                                                            AdapterFingerPrint* fingerprint,\n+                                                            AdapterBlob*& new_adapter,\n+                                                            bool allocate_code_blob) {\n+  if (allocate_code_blob) {\n+    new_adapter = AdapterBlob::create(masm->code(), 0, 0, NULL);\n+  }\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -115,0 +115,2 @@\n+  AdapterHandlerLibrary::initialize();\n+\n@@ -2535,1 +2537,1 @@\n-      st.print(\"%08x\", value(i));\n+      st.print(\"%x\", value(i));\n@@ -2540,0 +2542,41 @@\n+#ifndef PRODUCT\n+  \/\/ Reconstitutes the basic type arguments from the fingerprint,\n+  \/\/ producing strings like LIJDF\n+  const char* as_basic_args_string() {\n+    stringStream st;\n+    bool long_prev = false;\n+    for (int i = 0; i < length(); i++) {\n+      unsigned val = (unsigned)value(i);\n+      \/\/ args are packed so that first\/lower arguments are in the highest\n+      \/\/ bits of each int value, so iterate from highest to the lowest\n+      for (int j = 32 - _basic_type_bits; j >= 0; j -= _basic_type_bits) {\n+        unsigned v = (val >> j) & _basic_type_mask;\n+        if (v == 0) {\n+          assert(i == length() - 1, \"Only expect zeroes in the last word\");\n+          continue;\n+        }\n+        if (long_prev) {\n+          long_prev = false;\n+          if (v == T_VOID) {\n+            st.print(\"J\");\n+          } else {\n+            st.print(\"L\");\n+          }\n+        }\n+        switch (v) {\n+          case T_INT:    st.print(\"I\");    break;\n+          case T_LONG:   long_prev = true; break;\n+          case T_FLOAT:  st.print(\"F\");    break;\n+          case T_DOUBLE: st.print(\"D\");    break;\n+          case T_VOID:   break;\n+          default: ShouldNotReachHere();\n+        }\n+      }\n+    }\n+    if (long_prev) {\n+      st.print(\"L\");\n+    }\n+    return st.as_string();\n+  }\n+#endif \/\/ !product\n+\n@@ -2703,0 +2746,5 @@\n+AdapterHandlerEntry* AdapterHandlerLibrary::_no_arg_handler = NULL;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_int_arg_handler = NULL;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_obj_arg_handler = NULL;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_obj_int_arg_handler = NULL;\n+AdapterHandlerEntry* AdapterHandlerLibrary::_obj_obj_arg_handler = NULL;\n@@ -2707,3 +2755,0 @@\n-  \/\/ Should be called only when AdapterHandlerLibrary_lock is active.\n-  if (_buffer == NULL) \/\/ Initialize lazily\n-      _buffer = BufferBlob::create(\"adapters\", AdapterHandlerLibrary_size);\n@@ -2717,0 +2762,14 @@\n+static void post_adapter_creation(const AdapterBlob* new_adapter, const AdapterHandlerEntry* entry) {\n+  char blob_id[256];\n+  jio_snprintf(blob_id,\n+                sizeof(blob_id),\n+                \"%s(%s)\",\n+                new_adapter->name(),\n+                entry->fingerprint()->as_string());\n+  Forte::register_stub(blob_id, new_adapter->content_begin(), new_adapter->content_end());\n+\n+  if (JvmtiExport::should_post_dynamic_code_generated()) {\n+    JvmtiExport::post_dynamic_code_generated(blob_id, new_adapter->content_begin(), new_adapter->content_end());\n+  }\n+}\n+\n@@ -2718,13 +2777,64 @@\n-  if (_adapters != NULL) return;\n-  _adapters = new AdapterHandlerTable();\n-\n-  \/\/ Create a special handler for abstract methods.  Abstract methods\n-  \/\/ are never compiled so an i2c entry is somewhat meaningless, but\n-  \/\/ throw AbstractMethodError just in case.\n-  \/\/ Pass wrong_method_abstract for the c2i transitions to return\n-  \/\/ AbstractMethodError for invalid invocations.\n-  address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n-  _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),\n-                                                              StubRoutines::throw_AbstractMethodError_entry(),\n-                                                              wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n-                                                              wrong_method_abstract, wrong_method_abstract);\n+  ResourceMark rm;\n+  AdapterBlob* no_arg_blob = NULL;\n+  AdapterBlob* int_arg_blob = NULL;\n+  AdapterBlob* obj_arg_blob = NULL;\n+  AdapterBlob* obj_int_arg_blob = NULL;\n+  AdapterBlob* obj_obj_arg_blob = NULL;\n+  {\n+    MutexLocker mu(AdapterHandlerLibrary_lock);\n+    assert(_adapters == NULL, \"Initializing more than once\");\n+\n+    _adapters = new AdapterHandlerTable();\n+\n+    \/\/ Create a special handler for abstract methods.  Abstract methods\n+    \/\/ are never compiled so an i2c entry is somewhat meaningless, but\n+    \/\/ throw AbstractMethodError just in case.\n+    \/\/ Pass wrong_method_abstract for the c2i transitions to return\n+    \/\/ AbstractMethodError for invalid invocations.\n+    address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),\n+                                                                StubRoutines::throw_AbstractMethodError_entry(),\n+                                                                wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n+                                                                wrong_method_abstract, wrong_method_abstract);\n+    _buffer = BufferBlob::create(\"adapters\", AdapterHandlerLibrary_size);\n+\n+    CompiledEntrySignature no_args;\n+    no_args.compute_calling_conventions();\n+    _no_arg_handler = create_adapter(no_arg_blob, no_args, true);\n+\n+    CompiledEntrySignature obj_args;\n+    SigEntry::add_entry(&obj_args.sig(), T_OBJECT, NULL);\n+    obj_args.compute_calling_conventions();\n+    _obj_arg_handler = create_adapter(obj_arg_blob, obj_args, true);\n+\n+    CompiledEntrySignature int_args;\n+    SigEntry::add_entry(&int_args.sig(), T_INT, NULL);\n+    int_args.compute_calling_conventions();\n+    _int_arg_handler = create_adapter(int_arg_blob, int_args, true);\n+\n+    CompiledEntrySignature obj_int_args;\n+    SigEntry::add_entry(&obj_int_args.sig(), T_OBJECT, NULL);\n+    SigEntry::add_entry(&obj_int_args.sig(), T_INT, NULL);\n+    obj_int_args.compute_calling_conventions();\n+    _obj_int_arg_handler = create_adapter(obj_int_arg_blob, obj_int_args, true);\n+\n+    CompiledEntrySignature obj_obj_args;\n+    SigEntry::add_entry(&obj_obj_args.sig(), T_OBJECT, NULL);\n+    SigEntry::add_entry(&obj_obj_args.sig(), T_OBJECT, NULL);\n+    obj_obj_args.compute_calling_conventions();\n+    _obj_obj_arg_handler = create_adapter(obj_obj_arg_blob, obj_obj_args, true);\n+\n+    assert(no_arg_blob != NULL &&\n+          obj_arg_blob != NULL &&\n+          int_arg_blob != NULL &&\n+          obj_int_arg_blob != NULL &&\n+          obj_obj_arg_blob != NULL, \"Initial adapters must be properly created\");\n+  }\n+  return;\n+\n+  \/\/ Outside of the lock\n+  post_adapter_creation(no_arg_blob, _no_arg_handler);\n+  post_adapter_creation(obj_arg_blob, _obj_arg_handler);\n+  post_adapter_creation(int_arg_blob, _int_arg_handler);\n+  post_adapter_creation(obj_int_arg_blob, _obj_int_arg_handler);\n+  post_adapter_creation(obj_obj_arg_blob, _obj_obj_arg_handler);\n@@ -2745,0 +2855,39 @@\n+AdapterHandlerEntry* AdapterHandlerLibrary::get_simple_adapter(const methodHandle& method) {\n+  if (method->is_abstract()) {\n+    return NULL;\n+  }\n+  int total_args_passed = method->size_of_parameters(); \/\/ All args on stack\n+  if (total_args_passed == 0) {\n+    return _no_arg_handler;\n+  } else if (total_args_passed == 1) {\n+    if (!method->is_static() && !method->method_holder()->is_inline_klass()) {\n+      return _obj_arg_handler;\n+    }\n+    switch (method->signature()->char_at(1)) {\n+      case JVM_SIGNATURE_CLASS:\n+      case JVM_SIGNATURE_ARRAY:\n+        return _obj_arg_handler;\n+      case JVM_SIGNATURE_INT:\n+      case JVM_SIGNATURE_BOOLEAN:\n+      case JVM_SIGNATURE_CHAR:\n+      case JVM_SIGNATURE_BYTE:\n+      case JVM_SIGNATURE_SHORT:\n+        return _int_arg_handler;\n+    }\n+  } else if (total_args_passed == 2 &&\n+             !method->is_static() && !method->method_holder()->is_inline_klass()) {\n+    switch (method->signature()->char_at(1)) {\n+      case JVM_SIGNATURE_CLASS:\n+      case JVM_SIGNATURE_ARRAY:\n+        return _obj_obj_arg_handler;\n+      case JVM_SIGNATURE_INT:\n+      case JVM_SIGNATURE_BOOLEAN:\n+      case JVM_SIGNATURE_CHAR:\n+      case JVM_SIGNATURE_BYTE:\n+      case JVM_SIGNATURE_SHORT:\n+        return _obj_int_arg_handler;\n+    }\n+  }\n+  return NULL;\n+}\n+\n@@ -2747,1 +2896,1 @@\n-  _sig_cc(NULL), _sig_cc_ro(NULL), _regs(NULL), _regs_cc(NULL), _regs_cc_ro(NULL),\n+  _regs(NULL), _regs_cc(NULL), _regs_cc_ro(NULL),\n@@ -2749,3 +2898,4 @@\n-  _c1_needs_stack_repair(false), _c2_needs_stack_repair(false), _has_scalarized_args(false) {\n-  _sig = new GrowableArray<SigEntry>(method->size_of_parameters());\n-\n+  _c1_needs_stack_repair(false), _c2_needs_stack_repair(false) {\n+  _sig = new GrowableArray<SigEntry>((method != NULL) ? method->size_of_parameters() : 1);\n+  _sig_cc = _sig;\n+  _sig_cc_ro = _sig;\n@@ -2819,1 +2969,0 @@\n-\n@@ -2822,11 +2971,4 @@\n-  if (!_method->is_static()) {\n-    if (_method->method_holder()->is_inline_klass() && InlineKlass::cast(_method->method_holder())->can_be_passed_as_fields()) {\n-      _has_inline_recv = true;\n-      _num_inline_args++;\n-    }\n-    SigEntry::add_entry(_sig, T_OBJECT, _method->name());\n-  }\n-  for (SignatureStream ss(_method->signature()); !ss.at_return_type(); ss.next()) {\n-    BasicType bt = ss.type();\n-    if (bt == T_INLINE_TYPE) {\n-      if (ss.as_inline_klass(_method->method_holder())->can_be_passed_as_fields()) {\n+  if (_method != NULL) {\n+    if (!_method->is_static()) {\n+      if (_method->method_holder()->is_inline_klass() && InlineKlass::cast(_method->method_holder())->can_be_passed_as_fields()) {\n+        _has_inline_recv = true;\n@@ -2835,1 +2977,14 @@\n-      bt = T_OBJECT;\n+      SigEntry::add_entry(_sig, T_OBJECT, _method->name());\n+    }\n+    for (SignatureStream ss(_method->signature()); !ss.at_return_type(); ss.next()) {\n+      BasicType bt = ss.type();\n+      if (bt == T_INLINE_TYPE) {\n+        if (ss.as_inline_klass(_method->method_holder())->can_be_passed_as_fields()) {\n+          _num_inline_args++;\n+        }\n+        bt = T_OBJECT;\n+      }\n+      SigEntry::add_entry(_sig, bt, ss.as_symbol());\n+    }\n+    if (_method->is_abstract() && !has_inline_arg()) {\n+      return;\n@@ -2837,4 +2992,0 @@\n-    SigEntry::add_entry(_sig, bt, ss.as_symbol());\n-  }\n-  if (_method->is_abstract() && !has_inline_arg()) {\n-    return;\n@@ -2848,2 +2999,0 @@\n-  _sig_cc = _sig;\n-  _sig_cc_ro = _sig;\n@@ -2880,1 +3029,0 @@\n-      _has_scalarized_args = true;\n@@ -2886,3 +3034,0 @@\n-\n-  \/\/ TODO 8268946: Reimplement JDK-8266015, dropped from jdk->lworld merge\n-\n@@ -2893,0 +3038,1 @@\n+  assert(_adapters != NULL, \"Uninitialized\");\n@@ -2894,1 +3040,5 @@\n-  ResourceMark rm;\n+  \/\/ Fast-path for trivial adapters\n+  AdapterHandlerEntry* entry = get_simple_adapter(method);\n+  if (entry != NULL) {\n+    return entry;\n+  }\n@@ -2896,1 +3046,1 @@\n-  NOT_PRODUCT(int insts_size = 0);\n+  ResourceMark rm;\n@@ -2898,2 +3048,10 @@\n-  AdapterHandlerEntry* entry = NULL;\n-  AdapterFingerPrint* fingerprint = NULL;\n+\n+  CompiledEntrySignature ces(method());\n+  ces.compute_calling_conventions();\n+  if (ces.has_scalarized_args()) {\n+    method->set_has_scalarized_args(true);\n+    method->set_c1_needs_stack_repair(ces.c1_needs_stack_repair());\n+    method->set_c2_needs_stack_repair(ces.c2_needs_stack_repair());\n+  } else if (method->is_abstract()) {\n+    return _abstract_method_handler;\n+  }\n@@ -2903,2 +3061,0 @@\n-    \/\/ make sure data structure is initialized\n-    initialize();\n@@ -2906,33 +3062,11 @@\n-    CompiledEntrySignature ces(method());\n-    {\n-       MutexUnlocker mul(AdapterHandlerLibrary_lock);\n-       ces.compute_calling_conventions();\n-    }\n-    GrowableArray<SigEntry>& sig       = ces.sig();\n-    GrowableArray<SigEntry>& sig_cc    = ces.sig_cc();\n-    GrowableArray<SigEntry>& sig_cc_ro = ces.sig_cc_ro();\n-    VMRegPair* regs         = ces.regs();\n-    VMRegPair* regs_cc      = ces.regs_cc();\n-    VMRegPair* regs_cc_ro   = ces.regs_cc_ro();\n-\n-    if (ces.has_scalarized_args()) {\n-      method->set_has_scalarized_args(true);\n-      method->set_c1_needs_stack_repair(ces.c1_needs_stack_repair());\n-      method->set_c2_needs_stack_repair(ces.c2_needs_stack_repair());\n-    }\n-\n-    if (method->is_abstract()) {\n-      if (ces.has_scalarized_args()) {\n-        \/\/ Save a C heap allocated version of the signature for abstract methods with scalarized inline type arguments\n-        address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n-        entry = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),\n-                                                 StubRoutines::throw_AbstractMethodError_entry(),\n-                                                 wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n-                                                 wrong_method_abstract, wrong_method_abstract);\n-        GrowableArray<SigEntry>* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<SigEntry>(sig_cc_ro.length(), mtInternal);\n-        heap_sig->appendAll(&sig_cc_ro);\n-        entry->set_sig_cc(heap_sig);\n-        return entry;\n-      } else {\n-        return _abstract_method_handler;\n-      }\n+    if (ces.has_scalarized_args() && method->is_abstract()) {\n+      \/\/ Save a C heap allocated version of the signature for abstract methods with scalarized inline type arguments\n+      address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+      entry = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),\n+                                               StubRoutines::throw_AbstractMethodError_entry(),\n+                                               wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n+                                               wrong_method_abstract, wrong_method_abstract);\n+      GrowableArray<SigEntry>* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<SigEntry>(ces.sig_cc_ro().length(), mtInternal);\n+      heap_sig->appendAll(&ces.sig_cc_ro());\n+      entry->set_sig_cc(heap_sig);\n+      return entry;\n@@ -2942,1 +3076,1 @@\n-    entry = _adapters->lookup(&sig_cc, regs_cc != regs_cc_ro);\n+    entry = _adapters->lookup(&ces.sig_cc(), ces.regs_cc() != ces.regs_cc_ro());\n@@ -2944,0 +3078,1 @@\n+    if (entry != NULL) {\n@@ -2945,6 +3080,8 @@\n-    AdapterHandlerEntry* shared_entry = NULL;\n-    \/\/ Start adapter sharing verification only after the VM is booted.\n-    if (VerifyAdapterSharing && (entry != NULL)) {\n-      shared_entry = entry;\n-      entry = NULL;\n-    }\n+      if (VerifyAdapterSharing) {\n+        AdapterBlob* comparison_blob = NULL;\n+        AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, ces, false);\n+        assert(comparison_blob == NULL, \"no blob should be created when creating an adapter for comparison\");\n+        assert(comparison_entry->compare_code(entry), \"code must match\");\n+        \/\/ Release the one just created and return the original\n+        _adapters->free_entry(comparison_entry);\n+      }\n@@ -2952,2 +3089,0 @@\n-\n-    if (entry != NULL) {\n@@ -2957,8 +3092,2 @@\n-    \/\/ Make a C heap allocated version of the fingerprint to store in the adapter\n-    fingerprint = new AdapterFingerPrint(&sig_cc, regs_cc != regs_cc_ro);\n-\n-    \/\/ StubRoutines::code2() is initialized after this function can be called. As a result,\n-    \/\/ VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated\n-    \/\/ prior to StubRoutines::code2() being set. Checks refer to checks generated in an I2C\n-    \/\/ stub that ensure that an I2C stub is called from an interpreter frame.\n-    bool contains_all_checks = StubRoutines::code2() != NULL;\n+    entry = create_adapter(new_adapter, ces, \/* allocate_code_blob *\/ true);\n+  }\n@@ -2966,7 +3095,6 @@\n-    \/\/ Create I2C & C2I handlers\n-    BufferBlob* buf = buffer_blob(); \/\/ the temporary code buffer in CodeCache\n-    if (buf != NULL) {\n-      CodeBuffer buffer(buf);\n-      short buffer_locs[20];\n-      buffer.insts()->initialize_shared_locs((relocInfo*)buffer_locs,\n-                                             sizeof(buffer_locs)\/sizeof(relocInfo));\n+  \/\/ Outside of the lock\n+  if (new_adapter != NULL) {\n+    post_adapter_creation(new_adapter, entry);\n+  }\n+  return entry;\n+}\n@@ -2974,18 +3102,37 @@\n-      MacroAssembler _masm(&buffer);\n-      entry = SharedRuntime::generate_i2c2i_adapters(&_masm,\n-                                                     ces.args_on_stack(),\n-                                                     &sig,\n-                                                     regs,\n-                                                     &sig_cc,\n-                                                     regs_cc,\n-                                                     &sig_cc_ro,\n-                                                     regs_cc_ro,\n-                                                     fingerprint,\n-                                                     new_adapter);\n-\n-      if (ces.has_scalarized_args()) {\n-        \/\/ Save a C heap allocated version of the scalarized signature and store it in the adapter\n-        GrowableArray<SigEntry>* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<SigEntry>(sig_cc.length(), mtInternal);\n-        heap_sig->appendAll(&sig_cc);\n-        entry->set_sig_cc(heap_sig);\n-      }\n+AdapterHandlerEntry* AdapterHandlerLibrary::create_adapter(AdapterBlob*& new_adapter,\n+                                                           CompiledEntrySignature& ces,\n+                                                           bool allocate_code_blob) {\n+\n+  \/\/ StubRoutines::code2() is initialized after this function can be called. As a result,\n+  \/\/ VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated\n+  \/\/ prior to StubRoutines::code2() being set. Checks refer to checks generated in an I2C\n+  \/\/ stub that ensure that an I2C stub is called from an interpreter frame.\n+  bool contains_all_checks = StubRoutines::code2() != NULL;\n+\n+  BufferBlob* buf = buffer_blob(); \/\/ the temporary code buffer in CodeCache\n+  CodeBuffer buffer(buf);\n+  short buffer_locs[20];\n+  buffer.insts()->initialize_shared_locs((relocInfo*)buffer_locs,\n+                                          sizeof(buffer_locs)\/sizeof(relocInfo));\n+\n+  \/\/ Make a C heap allocated version of the fingerprint to store in the adapter\n+  AdapterFingerPrint* fingerprint = new AdapterFingerPrint(&ces.sig_cc(), ces.regs_cc() != ces.regs_cc_ro());\n+  MacroAssembler _masm(&buffer);\n+  AdapterHandlerEntry* entry = SharedRuntime::generate_i2c2i_adapters(&_masm,\n+                                                ces.args_on_stack(),\n+                                                &ces.sig(),\n+                                                ces.regs(),\n+                                                &ces.sig_cc(),\n+                                                ces.regs_cc(),\n+                                                &ces.sig_cc_ro(),\n+                                                ces.regs_cc_ro(),\n+                                                fingerprint,\n+                                                new_adapter,\n+                                                allocate_code_blob);\n+\n+  if (ces.has_scalarized_args()) {\n+    \/\/ Save a C heap allocated version of the scalarized signature and store it in the adapter\n+    GrowableArray<SigEntry>* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<SigEntry>(ces.sig_cc().length(), mtInternal);\n+    heap_sig->appendAll(&ces.sig_cc());\n+    entry->set_sig_cc(heap_sig);\n+  }\n@@ -2994,11 +3141,6 @@\n-      \/\/ TODO fix with 8268946\n-      if (false && VerifyAdapterSharing) {\n-        if (shared_entry != NULL) {\n-          assert(shared_entry->compare_code(buf->code_begin(), buffer.insts_size()), \"code must match\");\n-          \/\/ Release the one just created and return the original\n-          _adapters->free_entry(entry);\n-          return shared_entry;\n-        } else  {\n-          entry->save_code(buf->code_begin(), buffer.insts_size());\n-        }\n-      }\n+  if (VerifyAdapterSharing) {\n+    entry->save_code(buf->code_begin(), buffer.insts_size());\n+    if (!allocate_code_blob) {\n+      return entry;\n+    }\n+  }\n@@ -3007,9 +3149,8 @@\n-      NOT_PRODUCT(insts_size = buffer.insts_size());\n-    }\n-    if (new_adapter == NULL) {\n-      \/\/ CodeCache is full, disable compilation\n-      \/\/ Ought to log this but compile log is only per compile thread\n-      \/\/ and we're some non descript Java thread.\n-      return NULL; \/\/ Out of CodeCache space\n-    }\n-    entry->relocate(new_adapter->content_begin());\n+  NOT_PRODUCT(int insts_size = buffer.insts_size());\n+  if (new_adapter == NULL) {\n+    \/\/ CodeCache is full, disable compilation\n+    \/\/ Ought to log this but compile log is only per compile thread\n+    \/\/ and we're some non descript Java thread.\n+    return NULL;\n+  }\n+  entry->relocate(new_adapter->content_begin());\n@@ -3017,14 +3158,13 @@\n-    \/\/ debugging suppport\n-    if (PrintAdapterHandlers || PrintStubCode) {\n-      ttyLocker ttyl;\n-      entry->print_adapter_on(tty);\n-      tty->print_cr(\"i2c argument handler #%d for: %s %s %s (%d bytes generated)\",\n-                    _adapters->number_of_entries(), (method->is_static() ? \"static\" : \"receiver\"),\n-                    method->signature()->as_C_string(), fingerprint->as_string(), insts_size);\n-      tty->print_cr(\"c2i argument handler starts at %p\", entry->get_c2i_entry());\n-      if (Verbose || PrintStubCode) {\n-        address first_pc = entry->base_address();\n-        if (first_pc != NULL) {\n-          Disassembler::decode(first_pc, first_pc + insts_size);\n-          tty->cr();\n-        }\n+  \/\/ debugging suppport\n+  if (PrintAdapterHandlers || PrintStubCode) {\n+    ttyLocker ttyl;\n+    entry->print_adapter_on(tty);\n+    tty->print_cr(\"i2c argument handler #%d for: %s %s (%d bytes generated)\",\n+                  _adapters->number_of_entries(), fingerprint->as_basic_args_string(),\n+                  fingerprint->as_string(), insts_size);\n+    tty->print_cr(\"c2i argument handler starts at %p\", entry->get_c2i_entry());\n+    if (Verbose || PrintStubCode) {\n+      address first_pc = entry->base_address();\n+      if (first_pc != NULL) {\n+        Disassembler::decode(first_pc, first_pc + insts_size);\n+        tty->cr();\n@@ -3033,6 +3173,0 @@\n-#endif\n-    \/\/ Add the entry only if the entry contains all required checks (see sharedRuntime_xxx.cpp)\n-    \/\/ The checks are inserted only if -XX:+VerifyAdapterCalls is specified.\n-    if (contains_all_checks || !VerifyAdapterCalls) {\n-      _adapters->add(entry);\n-    }\n@@ -3040,10 +3174,1 @@\n-  \/\/ Outside of the lock\n-  if (new_adapter != NULL) {\n-    char blob_id[256];\n-    jio_snprintf(blob_id,\n-                 sizeof(blob_id),\n-                 \"%s(%s)@\" PTR_FORMAT,\n-                 new_adapter->name(),\n-                 fingerprint->as_string(),\n-                 new_adapter->content_begin());\n-    Forte::register_stub(blob_id, new_adapter->content_begin(), new_adapter->content_end());\n+#endif\n@@ -3051,3 +3176,4 @@\n-    if (JvmtiExport::should_post_dynamic_code_generated()) {\n-      JvmtiExport::post_dynamic_code_generated(blob_id, new_adapter->content_begin(), new_adapter->content_end());\n-    }\n+  \/\/ Add the entry only if the entry contains all required checks (see sharedRuntime_xxx.cpp)\n+  \/\/ The checks are inserted only if -XX:+VerifyAdapterCalls is specified.\n+  if (contains_all_checks || !VerifyAdapterCalls) {\n+    _adapters->add(entry);\n@@ -3114,2 +3240,4 @@\n-bool AdapterHandlerEntry::compare_code(unsigned char* buffer, int length) {\n-  if (length != _saved_code_length) {\n+bool AdapterHandlerEntry::compare_code(AdapterHandlerEntry* other) {\n+  assert(_saved_code != NULL && other->_saved_code != NULL, \"code not saved\");\n+\n+  if (other->_saved_code_length != _saved_code_length) {\n@@ -3119,1 +3247,1 @@\n-  return (memcmp(buffer, _saved_code, length) == 0) ? true : false;\n+  return memcmp(other->_saved_code, _saved_code, _saved_code_length) == 0;\n@@ -3179,1 +3307,1 @@\n-      if (!method->is_static())  \/\/ Pass in receiver first\n+      if (!method->is_static()) {  \/\/ Pass in receiver first\n@@ -3181,0 +3309,1 @@\n+      }\n@@ -3183,3 +3312,2 @@\n-        BasicType bt = ss.type();\n-        sig_bt[i++] = bt;  \/\/ Collect remaining bits of signature\n-        if (ss.type() == T_LONG || ss.type() == T_DOUBLE)\n+        sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n+        if (ss.type() == T_LONG || ss.type() == T_DOUBLE) {\n@@ -3187,0 +3315,1 @@\n+        }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":314,"deletions":185,"binary":false,"changes":499,"status":"modified"},{"patch":"@@ -446,1 +446,2 @@\n-                                                      AdapterBlob*& new_adapter);\n+                                                      AdapterBlob*& new_adapter,\n+                                                      bool allocate_code_blob);\n@@ -732,1 +733,1 @@\n-  bool compare_code(unsigned char* buffer, int length);\n+  bool compare_code(AdapterHandlerEntry* other);\n@@ -739,0 +740,2 @@\n+class CompiledEntrySignature;\n+\n@@ -754,2 +757,1 @@\n-                                             int total_args_passed,\n-                                             BasicType* sig_bt,\n+                                             CompiledEntrySignature& ces,\n@@ -797,1 +799,0 @@\n-  bool _has_scalarized_args;\n@@ -823,1 +824,1 @@\n-  bool has_scalarized_args()           const { return _has_scalarized_args; }\n+  bool has_scalarized_args()           const { return _sig != _sig_cc; }\n@@ -828,1 +829,1 @@\n-  CompiledEntrySignature(Method* method);\n+  CompiledEntrySignature(Method* method = NULL);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"}]}