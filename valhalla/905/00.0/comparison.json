{"files":[{"patch":"@@ -2289,1 +2289,1 @@\n-const bool Matcher::match_rule_supported(int opcode) {\n+bool Matcher::match_rule_supported(int opcode) {\n@@ -2324,1 +2324,1 @@\n-const bool Matcher::supports_vector_calling_convention(void) {\n+bool Matcher::supports_vector_calling_convention(void) {\n@@ -2344,1 +2344,1 @@\n-const int Matcher::vector_width_in_bytes(BasicType bt) {\n+int Matcher::vector_width_in_bytes(BasicType bt) {\n@@ -2355,1 +2355,1 @@\n-const int Matcher::max_vector_size(const BasicType bt) {\n+int Matcher::max_vector_size(const BasicType bt) {\n@@ -2359,1 +2359,1 @@\n-const int Matcher::min_vector_size(const BasicType bt) {\n+int Matcher::min_vector_size(const BasicType bt) {\n@@ -2374,1 +2374,1 @@\n-const int Matcher::superword_max_vector_size(const BasicType bt) {\n+int Matcher::superword_max_vector_size(const BasicType bt) {\n@@ -2379,1 +2379,1 @@\n-const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+int Matcher::scalable_vector_reg_size(const BasicType bt) {\n@@ -2384,1 +2384,1 @@\n-const uint Matcher::vector_ideal_reg(int len) {\n+uint Matcher::vector_ideal_reg(int len) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-    ? sender_sp() - sp()\n+    ? pointer_delta_as_int(sender_sp(), sp())\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -767,0 +767,6 @@\n+    \/\/ check if already enabled - if so no re-enabling needed\n+    assert(sizeof(StackOverflow::StackGuardState) == 4, \"unexpected size\");\n+    ldrw(rscratch1, Address(rthread, JavaThread::stack_guard_state_offset()));\n+    cmpw(rscratch1, (u1)StackOverflow::stack_guard_enabled);\n+    br(Assembler::EQ, no_reserved_zone_enabling);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -891,0 +891,6 @@\n+    \/\/ check if already enabled - if so no re-enabling needed\n+    assert(sizeof(StackOverflow::StackGuardState) == 4, \"unexpected size\");\n+    lwz(R0, in_bytes(JavaThread::stack_guard_state_offset()), R16_thread);\n+    cmpwi(CCR0, R0, StackOverflow::stack_guard_enabled);\n+    beq_predict_taken(CCR0, no_reserved_zone_enabling);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -955,0 +955,5 @@\n+    \/\/ check if already enabled - if so no re-enabling needed\n+    assert(sizeof(StackOverflow::StackGuardState) == 4, \"unexpected size\");\n+    z_ly(Z_R0, Address(Z_thread, JavaThread::stack_guard_state_offset()));\n+    compare32_and_branch(Z_R0, StackOverflow::stack_guard_enabled, bcondEqual, no_reserved_zone_enabling);\n+\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-    ? sender_sp() - sp()\n+    ? pointer_delta_as_int(sender_sp(), sp())\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-static const int entry_barrier_offset(nmethod* nm) {\n+static int entry_barrier_offset(nmethod* nm) {\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1159,0 +1159,2 @@\n+    \/\/ check if already enabled - if so no re-enabling needed\n+    assert(sizeof(StackOverflow::StackGuardState) == 4, \"unexpected size\");\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2034,4 +2034,4 @@\n-  emit_int8((int8_t)0x0f);\n-  emit_int8((int8_t)0x1f);\n-  emit_int8((int8_t)0x84);\n-  emit_int8((int8_t)0x00);\n+  emit_int8((uint8_t)0x0f);\n+  emit_int8((uint8_t)0x1f);\n+  emit_int8((uint8_t)0x84);\n+  emit_int8((uint8_t)0x00);\n@@ -2046,5 +2046,5 @@\n-    emit_int8((int8_t)0x26); \/\/ es:\n-    emit_int8((int8_t)0x2e); \/\/ cs:\n-    emit_int8((int8_t)0x64); \/\/ fs:\n-    emit_int8((int8_t)0x65); \/\/ gs:\n-    emit_int8((int8_t)0x90);\n+    emit_int8((uint8_t)0x26); \/\/ es:\n+    emit_int8((uint8_t)0x2e); \/\/ cs:\n+    emit_int8((uint8_t)0x64); \/\/ fs:\n+    emit_int8((uint8_t)0x65); \/\/ gs:\n+    emit_int8((uint8_t)0x90);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-      int imm8 = target - (address) &disp[1];\n+      int imm8 = checked_cast<int>(target - (address) &disp[1]);\n@@ -157,1 +157,1 @@\n-      *disp = imm8;\n+      *disp = (char)imm8;\n@@ -160,1 +160,1 @@\n-      int imm32 = target - (address) &disp[1];\n+      int imm32 = checked_cast<int>(target - (address) &disp[1]);\n@@ -811,1 +811,1 @@\n-    if (src.is_constant()) addptr(dst, src.as_constant());\n+    if (src.is_constant()) addptr(dst, checked_cast<int>(src.as_constant()));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3140,2 +3140,2 @@\n-intx VM_Version::L1_line_size() {\n-  intx result = 0;\n+uint VM_Version::L1_line_size() {\n+  uint result = 0;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1395,1 +1395,1 @@\n-const bool Matcher::match_rule_supported(int opcode) {\n+bool Matcher::match_rule_supported(int opcode) {\n@@ -1697,1 +1697,1 @@\n-const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n@@ -1703,1 +1703,1 @@\n-const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n+bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n@@ -1991,1 +1991,1 @@\n-const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n+bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n@@ -2150,1 +2150,1 @@\n-const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n+bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n@@ -2154,13 +2154,0 @@\n-\/\/ Return true if Vector::rearrange needs preparation of the shuffle argument\n-const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n-  switch (elem_bt) {\n-    case T_BYTE:  return false;\n-    case T_SHORT: return !VM_Version::supports_avx512bw();\n-    case T_INT:   return !VM_Version::supports_avx();\n-    case T_LONG:  return vlen < 8 && !VM_Version::supports_avx512vl();\n-    default:\n-      ShouldNotReachHere();\n-      return false;\n-  }\n-}\n-\n@@ -2235,1 +2222,1 @@\n-const int Matcher::vector_width_in_bytes(BasicType bt) {\n+int Matcher::vector_width_in_bytes(BasicType bt) {\n@@ -2278,1 +2265,1 @@\n-const int Matcher::max_vector_size(const BasicType bt) {\n+int Matcher::max_vector_size(const BasicType bt) {\n@@ -2281,1 +2268,1 @@\n-const int Matcher::min_vector_size(const BasicType bt) {\n+int Matcher::min_vector_size(const BasicType bt) {\n@@ -2292,1 +2279,1 @@\n-const int Matcher::superword_max_vector_size(const BasicType bt) {\n+int Matcher::superword_max_vector_size(const BasicType bt) {\n@@ -2301,1 +2288,1 @@\n-const int Matcher::scalable_vector_reg_size(const BasicType bt) {\n+int Matcher::scalable_vector_reg_size(const BasicType bt) {\n@@ -2306,1 +2293,1 @@\n-const uint Matcher::vector_ideal_reg(int size) {\n+uint Matcher::vector_ideal_reg(int size) {\n@@ -3677,1 +3664,1 @@\n-instruct convF2HF_reg_reg(rRegI dst, regF src, regF tmp) %{\n+instruct convF2HF_reg_reg(rRegI dst, vlRegF src, vlRegF tmp) %{\n@@ -3721,1 +3708,1 @@\n-instruct convHF2F_reg_reg(regF dst, rRegI src) %{\n+instruct convHF2F_reg_reg(vlRegF dst, rRegI src) %{\n@@ -8379,0 +8366,11 @@\n+\n+instruct loadShuffleB(vec dst) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadShuffle dst));\n+  format %{ \"vector_load_shuffle $dst, $dst\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -8445,1 +8443,1 @@\n-            !VM_Version::supports_avx512bw());\n+            Matcher::vector_length(n) <= 16 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n@@ -8456,1 +8454,1 @@\n-      __ movdqu($vtmp$$XMMRegister, $src$$XMMRegister);\n+      __ pmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister);\n@@ -8471,1 +8469,2 @@\n-      __ vpsllw($vtmp$$XMMRegister, $src$$XMMRegister, 1, vlen_enc);\n+      __ vpmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+      __ vpsllw($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n@@ -8518,0 +8517,15 @@\n+instruct loadShuffleS_evex(vec dst, vec src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_SHORT &&\n+            VM_Version::supports_avx512bw());\n+  match(Set dst (VectorLoadShuffle src));\n+  format %{ \"vector_load_shuffle $dst, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    if (!VM_Version::supports_avx512vl()) {\n+      vlen_enc = Assembler::AVX_512bit;\n+    }\n+    __ vpmovzxbw($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -8548,1 +8562,1 @@\n-    __ movdqu($vtmp$$XMMRegister, $src$$XMMRegister);\n+    __ pmovzxbd($vtmp$$XMMRegister, $src$$XMMRegister);\n@@ -8577,0 +8591,12 @@\n+instruct loadShuffleI_avx(vec dst, vec src) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_INT || Matcher::vector_element_basic_type(n) == T_FLOAT) &&\n+            UseAVX > 0);\n+  match(Set dst (VectorLoadShuffle src));\n+  format %{ \"vector_load_shuffle $dst, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpmovzxbd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -8606,1 +8632,2 @@\n-    __ vpsllq($vtmp$$XMMRegister, $src$$XMMRegister, 1, vlen_enc);\n+    __ vpmovzxbq($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ vpsllq($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n@@ -8632,0 +8659,14 @@\n+instruct loadShuffleL_evex(vec dst, vec src) %{\n+  predicate(is_double_word_type(Matcher::vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n+            (Matcher::vector_length(n) == 8 || VM_Version::supports_avx512vl()));\n+  match(Set dst (VectorLoadShuffle src));\n+  format %{ \"vector_load_shuffle $dst, $src\" %}\n+  ins_encode %{\n+    assert(UseAVX > 2, \"required\");\n+\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpmovzxbq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":72,"deletions":31,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -1407,1 +1407,1 @@\n-const bool Matcher::supports_vector_calling_convention() {\n+bool Matcher::supports_vector_calling_convention() {\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1726,1 +1726,1 @@\n-const bool Matcher::supports_vector_calling_convention(void) {\n+bool Matcher::supports_vector_calling_convention(void) {\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,4 +43,0 @@\n-#ifdef _WINDOWS\n-  \/\/ jint is defined as long in jni_md.h, so convert from int to jint\n-  void set_constant(int x)                       { set_constant((jint)x); }\n-#endif\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -534,1 +534,1 @@\n-    _bytes_to_copy = masm->pc() - pc_start();\n+    _bytes_to_copy = pointer_delta_as_int(masm->pc(), pc_start());\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-          _nonnull_state |= nth_bit(i);\n+          _nonnull_state |= (int)nth_bit(i);\n@@ -353,1 +353,1 @@\n-          _nonnull_state &= ~(nth_bit(i));\n+          _nonnull_state &= (int)~(nth_bit(i));\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-    BasicType basic_type = as_BasicType(type); assert(basic_type >= 0 && basic_type < T_VOID, \"Invalid type\");\n+    BasicType basic_type = as_BasicType(type); assert(basic_type < T_VOID, \"Invalid type\");\n@@ -301,1 +301,1 @@\n-    assert(type >= 0 && type < T_VOID, \"Invalid type\");\n+    assert(type < T_VOID, \"Invalid type\");\n@@ -306,1 +306,1 @@\n-    assert(type >= 0 && type < T_VOID, \"Invalid type\");\n+    assert(type < T_VOID, \"Invalid type\");\n@@ -362,0 +362,27 @@\n+class CheckInsertionPoint : public ValueVisitor {\n+ private:\n+  Value _insert;\n+  bool _valid = true;\n+\n+  void visit(Value* vp) {\n+    assert(*vp != nullptr, \"value should not be null\");\n+    if (_insert->dominator_depth() < (*vp)->dominator_depth()) {\n+      _valid = false;\n+    }\n+  }\n+\n+ public:\n+  bool is_valid() { return _valid; }\n+  CheckInsertionPoint(Value insert)\n+    : _insert(insert) {\n+    assert(insert != nullptr, \"insertion point should not be null\");\n+  }\n+};\n+\n+\/\/ Check that insertion point has higher dom depth than all inputs to cur\n+static bool is_dominated_by_inputs(Instruction* insertion_point, Instruction* cur) {\n+  CheckInsertionPoint v(insertion_point);\n+  cur->input_values_do(&v);\n+  return v.is_valid();\n+}\n+\n@@ -397,1 +424,1 @@\n-    if (cur_invariant) {\n+    if (cur_invariant && is_dominated_by_inputs(_insertion_point, cur)) {\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.cpp","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -290,1 +290,0 @@\n-  _narrow_klass_shift = CompressedKlassPointers::shift();\n@@ -352,1 +351,0 @@\n-  st->print_cr(\"- narrow_klass_shift:             %d\", _narrow_klass_shift);\n@@ -2090,0 +2088,7 @@\n+  \/\/ We pre-compute narrow Klass IDs with the runtime mapping start intended to be the base, and a shift of\n+  \/\/ ArchiveHeapWriter::precomputed_narrow_klass_shift. We enforce this encoding at runtime (see\n+  \/\/ CompressedKlassPointers::initialize_for_given_encoding()). Therefore, the following assertions must\n+  \/\/ hold:\n+  address archive_narrow_klass_base = (address)header()->mapped_base_address();\n+  const int archive_narrow_klass_shift = ArchiveHeapWriter::precomputed_narrow_klass_shift;\n+\n@@ -2092,2 +2097,2 @@\n-  log_info(cds)(\"    narrow_klass_base = \" PTR_FORMAT \", narrow_klass_shift = %d\",\n-                p2i(narrow_klass_base()), narrow_klass_shift());\n+  log_info(cds)(\"    narrow_klass_base at mapping start address, narrow_klass_shift = %d\",\n+                archive_narrow_klass_shift);\n@@ -2111,5 +2116,5 @@\n-  if (narrow_klass_base() != CompressedKlassPointers::base() ||\n-      narrow_klass_shift() != CompressedKlassPointers::shift()) {\n-    log_info(cds)(\"CDS heap data cannot be used because the archive was created with an incompatible narrow klass encoding mode.\");\n-    return false;\n-  }\n+  assert(archive_narrow_klass_base == CompressedKlassPointers::base(), \"Unexpected encoding base encountered \"\n+         \"(\" PTR_FORMAT \", expected \" PTR_FORMAT \")\", p2i(CompressedKlassPointers::base()), p2i(archive_narrow_klass_base));\n+  assert(archive_narrow_klass_shift == CompressedKlassPointers::shift(), \"Unexpected encoding shift encountered \"\n+         \"(%d, expected %d)\", CompressedKlassPointers::shift(), archive_narrow_klass_shift);\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -226,1 +226,0 @@\n-  int     _narrow_klass_shift;                    \/\/ save narrow klass base and shift\n@@ -295,2 +294,0 @@\n-  int narrow_klass_shift()                 const { return _narrow_klass_shift; }\n-  address narrow_klass_base()              const { return (address)mapped_base_address(); }\n@@ -419,2 +416,0 @@\n-  address narrow_klass_base()  const { return header()->narrow_klass_base(); }\n-  int     narrow_klass_shift() const { return header()->narrow_klass_shift(); }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -1141,1 +1142,1 @@\n-    LP64_ONLY({\n+#ifdef _LP64\n@@ -1151,2 +1152,13 @@\n-          CompressedKlassPointers::initialize(cds_base, ccs_end - cds_base);\n-\n+#if INCLUDE_CDS_JAVA_HEAP\n+          \/\/ We archived objects with pre-computed narrow Klass id. Set up encoding such that these Ids stay valid.\n+          address precomputed_narrow_klass_base = cds_base;\n+          const int precomputed_narrow_klass_shift = ArchiveHeapWriter::precomputed_narrow_klass_shift;\n+          CompressedKlassPointers::initialize_for_given_encoding(\n+            cds_base, ccs_end - cds_base, \/\/ Klass range\n+            precomputed_narrow_klass_base, precomputed_narrow_klass_shift \/\/ precomputed encoding, see ArchiveHeapWriter\n+            );\n+#else\n+          CompressedKlassPointers::initialize (\n+            cds_base, ccs_end - cds_base \/\/ Klass range\n+            );\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n@@ -1157,1 +1169,1 @@\n-      });\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -538,1 +538,1 @@\n-    return dp - ((address)_data);\n+    return pointer_delta_as_int(dp, ((address)_data));\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,3 +113,3 @@\n-  int next_bci() const          { return _pc - _start; }\n-  int cur_bci() const           { return _bc_start - _start; }\n-  int instruction_size() const  { return _pc - _bc_start; }\n+  int next_bci() const          { return pointer_delta_as_int(_pc, _start); }\n+  int cur_bci() const           { return pointer_delta_as_int(_bc_start, _start); }\n+  int instruction_size() const  { return pointer_delta_as_int(_pc, _bc_start); }\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5343,1 +5343,1 @@\n-  const char* const bytes = (const char* const)signature->bytes();\n+  const char* const bytes = (const char*)signature->bytes();\n@@ -6118,1 +6118,1 @@\n-  assert(cp_size == (const u2)cp->length(), \"invariant\");\n+  assert(cp_size == (u2)cp->length(), \"invariant\");\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/symbol.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"runtime\/os.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,2 +53,3 @@\n-ResourceHashtable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, AnyObj::C_HEAP, mtClass,\n-                  PlaceholderKey::hash, PlaceholderKey::equals> _placeholders;\n+using InternalPlaceholderTable = ResourceHashtable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, AnyObj::C_HEAP, mtClass,\n+                  PlaceholderKey::hash, PlaceholderKey::equals>;\n+static InternalPlaceholderTable* _placeholders;\n@@ -218,1 +219,1 @@\n-  PlaceholderEntry* table_copy = _placeholders.put_if_absent(key, entry, &created);\n+  PlaceholderEntry* table_copy = _placeholders->put_if_absent(key, entry, &created);\n@@ -228,1 +229,1 @@\n-  _placeholders.remove(key);\n+  _placeholders->remove(key);\n@@ -235,1 +236,1 @@\n-  return _placeholders.get(key);\n+  return _placeholders->get(key);\n@@ -283,0 +284,4 @@\n+void PlaceholderTable::initialize(){\n+  _placeholders = new (mtClass) InternalPlaceholderTable();\n+}\n+\n@@ -356,2 +361,2 @@\n-                _placeholders.table_size(), _placeholders.number_of_entries());\n-  _placeholders.iterate(printer);\n+                _placeholders->table_size(), _placeholders->number_of_entries());\n+  _placeholders->iterate(printer);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n- };\n-\n+  };\n+  static void initialize();\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,3 +119,5 @@\n-ResourceHashtable<InvokeMethodKey, Method*, 139, AnyObj::C_HEAP, mtClass,\n-                  InvokeMethodKey::compute_hash, InvokeMethodKey::key_comparison> _invoke_method_intrinsic_table;\n-ResourceHashtable<SymbolHandle, OopHandle, 139, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash> _invoke_method_type_table;\n+using InvokeMethodIntrinsicTable = ResourceHashtable<InvokeMethodKey, Method*, 139, AnyObj::C_HEAP, mtClass,\n+                  InvokeMethodKey::compute_hash, InvokeMethodKey::key_comparison>;\n+static InvokeMethodIntrinsicTable* _invoke_method_intrinsic_table;\n+using InvokeMethodTypeTable = ResourceHashtable<SymbolHandle, OopHandle, 139, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n+static InvokeMethodTypeTable* _invoke_method_type_table;\n@@ -1672,1 +1674,1 @@\n-    _invoke_method_intrinsic_table.iterate_all(doit);\n+    _invoke_method_intrinsic_table->iterate_all(doit);\n@@ -1681,0 +1683,6 @@\n+  _invoke_method_intrinsic_table = new (mtClass) InvokeMethodIntrinsicTable();\n+  _invoke_method_type_table = new (mtClass) InvokeMethodTypeTable();\n+  ResolutionErrorTable::initialize();\n+  LoaderConstraintTable::initialize();\n+  PlaceholderTable::initialize();\n+  ProtectionDomainCacheTable::initialize();\n@@ -1684,1 +1692,0 @@\n-\n@@ -2038,1 +2045,1 @@\n-      met = _invoke_method_intrinsic_table.put_if_absent(key, &created);\n+      met = _invoke_method_intrinsic_table->put_if_absent(key, &created);\n@@ -2069,1 +2076,1 @@\n-      bool removed = _invoke_method_intrinsic_table.remove(key);\n+      bool removed = _invoke_method_intrinsic_table->remove(key);\n@@ -2232,1 +2239,1 @@\n-    o = _invoke_method_type_table.get(signature);\n+    o = _invoke_method_type_table->get(signature);\n@@ -2303,1 +2310,1 @@\n-    OopHandle* h = _invoke_method_type_table.get(signature);\n+    OopHandle* h = _invoke_method_type_table->get(signature);\n@@ -2307,1 +2314,1 @@\n-      bool created = _invoke_method_type_table.put(signature, elem);\n+      bool created = _invoke_method_type_table->put(signature, elem);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-\/\/ by the VM, suhch as java.lang.Object and java.lang.String. These\n+\/\/ by the VM, such as java.lang.Object and java.lang.String. These\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -984,0 +984,18 @@\n+  do_intrinsic(_VectorShuffleIota, jdk_internal_vm_vector_VectorSupport, vector_shuffle_step_iota_name, vector_shuffle_step_iota_sig, F_S)     \\\n+   do_signature(vector_shuffle_step_iota_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n+                                               \"Ljava\/lang\/Class;\"                                                                             \\\n+                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;\"                                          \\\n+                                               \"IIII\"                                                                                          \\\n+                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$ShuffleIotaOperation;)\"                                  \\\n+                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\")                                         \\\n+   do_name(vector_shuffle_step_iota_name, \"shuffleIota\")                                                                                       \\\n+                                                                                                                                               \\\n+  do_intrinsic(_VectorShuffleToVector, jdk_internal_vm_vector_VectorSupport, vector_shuffle_to_vector_name, vector_shuffle_to_vector_sig, F_S) \\\n+   do_signature(vector_shuffle_to_vector_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n+                                               \"Ljava\/lang\/Class;\"                                                                             \\\n+                                               \"Ljava\/lang\/Class;\"                                                                             \\\n+                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\"                                          \\\n+                                               \"ILjdk\/internal\/vm\/vector\/VectorSupport$ShuffleToVectorOperation;)\"                             \\\n+                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                \\\n+   do_name(vector_shuffle_to_vector_name, \"shuffleToVector\")                                                                                   \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -766,1 +766,1 @@\n-  template(decodeAndThrowThrowable_signature,          \"(JZ)V\")                                                   \\\n+  template(decodeAndThrowThrowable_signature,          \"(IJZ)V\")                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -196,3 +196,3 @@\n-  int relocation_size() const                    { return (address) relocation_end() - (address) relocation_begin(); }\n-  int content_size() const                       { return           content_end()    -           content_begin();    }\n-  int code_size() const                          { return           code_end()       -           code_begin();       }\n+  int relocation_size() const                    { return pointer_delta_as_int((address) relocation_end(), (address) relocation_begin()); }\n+  int content_size() const                       { return pointer_delta_as_int(content_end(), content_begin()); }\n+  int code_size() const                          { return pointer_delta_as_int(code_end(), code_begin()); }\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-  VtableStub(bool is_vtable_stub, int index, bool caller_is_c1)\n+  VtableStub(bool is_vtable_stub, short index, bool caller_is_c1)\n@@ -156,2 +156,2 @@\n-    _npe_offset = npe_addr - code_begin();\n-    _ame_offset = ame_addr - code_begin();\n+    _npe_offset = checked_cast<short>(npe_addr - code_begin());\n+    _ame_offset = checked_cast<short>(ame_addr - code_begin());\n","filename":"src\/hotspot\/share\/code\/vtableStubs.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-        tty->print_cr(\"[%c][%d] -> reg (\" INTPTR_FORMAT \")\", omv.type() == OopMapValue::narrowoop_value ? 'n' : 'o', i, omv.reg()->value());\n+        tty->print_cr(\"[%c][%d] -> reg (%d)\", omv.type() == OopMapValue::narrowoop_value ? 'n' : 'o', i, omv.reg()->value());\n@@ -287,1 +287,1 @@\n-        tty->print_cr(\"[%c][%d] -> stack (\"  INTPTR_FORMAT \")\", omv.type() == OopMapValue::narrowoop_value ? 'n' : 'o', i, omv.reg()->reg2stack() * VMRegImpl::stack_slot_size);\n+        tty->print_cr(\"[%c][%d] -> stack (%d)\", omv.type() == OopMapValue::narrowoop_value ? 'n' : 'o', i, omv.reg()->reg2stack() * VMRegImpl::stack_slot_size);\n@@ -291,1 +291,1 @@\n-        tty->print_cr(\"[d][%d] -> reg (\" INTPTR_FORMAT \") stack (\" INTPTR_FORMAT \")\", i, omv.content_reg()->value(), omv.reg()->reg2stack() * VMRegImpl::stack_slot_size);\n+        tty->print_cr(\"[d][%d] -> reg (%d) stack (%d)\", i, omv.content_reg()->value(), omv.reg()->reg2stack() * VMRegImpl::stack_slot_size);\n@@ -293,1 +293,1 @@\n-        tty->print_cr(\"[d][%d] -> stack (\" INTPTR_FORMAT \") reg (\" INTPTR_FORMAT \")\", i, omv.content_reg()->reg2stack() * VMRegImpl::stack_slot_size, omv.reg()->value());\n+        tty->print_cr(\"[d][%d] -> stack (%d) reg (%d)\", i, omv.content_reg()->reg2stack() * VMRegImpl::stack_slot_size, omv.reg()->value());\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  AllocateNode* alloc = AllocateNode::Ideal_allocation(base, phase);\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(base);\n@@ -145,1 +145,1 @@\n-                                              AllocateNode::Ideal_allocation(st_base, phase),\n+                                              AllocateNode::Ideal_allocation(st_base),\n@@ -310,1 +310,1 @@\n-  AllocateNode* alloc  = AllocateNode::Ideal_allocation(base, phase);\n+  AllocateNode* alloc  = AllocateNode::Ideal_allocation(base);\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -408,9 +408,0 @@\n-MemRegion ObjArrayAllocator::obj_memory_range(oop obj) const {\n-  if (_do_zero) {\n-    return MemAllocator::obj_memory_range(obj);\n-  }\n-  ArrayKlass* array_klass = ArrayKlass::cast(_klass);\n-  const size_t hs = arrayOopDesc::header_size(array_klass->element_type());\n-  return MemRegion(cast_from_oop<HeapWord*>(obj) + hs, _word_size - hs);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -81,4 +81,0 @@\n-  virtual MemRegion obj_memory_range(oop obj) const {\n-    return MemRegion(cast_from_oop<HeapWord*>(obj), _word_size);\n-  }\n-\n@@ -111,2 +107,0 @@\n-  virtual MemRegion obj_memory_range(oop obj) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2023, Red Hat, Inc. All rights reserved.\n@@ -104,1 +104,1 @@\n-  AllocateNode* alloc = AllocateNode::Ideal_allocation(base, phase);\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(base);\n@@ -152,1 +152,1 @@\n-                                              AllocateNode::Ideal_allocation(st_base, phase),\n+                                              AllocateNode::Ideal_allocation(st_base),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  bool      _is_linked;\n@@ -59,0 +60,1 @@\n+  bool      is_linked() const        { return _is_linked; }\n@@ -61,18 +63,14 @@\n-  short     get_short()              { short i=Bytes::get_Java_u2(_next_pc); _next_pc+=2; return i; }\n-  int       get_int()                { int i=Bytes::get_Java_u4(_next_pc); _next_pc+=4; return i; }\n-\n-  int       get_index_u1()           { return *(address)_next_pc++; }\n-  int       get_index_u2()           { int i=Bytes::get_Java_u2(_next_pc); _next_pc+=2; return i; }\n-  int       get_index_u1_cpcache()   { return get_index_u1() + ConstantPool::CPCACHE_INDEX_TAG; }\n-  int       get_index_u2_cpcache()   { int i=Bytes::get_native_u2(_next_pc); _next_pc+=2; return i + ConstantPool::CPCACHE_INDEX_TAG; }\n-  int       get_index_u4()           { int i=Bytes::get_native_u4(_next_pc); _next_pc+=4; return i; }\n-  int       get_index_special()      { return (is_wide()) ? get_index_u2() : get_index_u1(); }\n-  Method* method()                 { return _current_method; }\n-  bool      is_wide()                { return _is_wide; }\n-  Bytecodes::Code raw_code()         { return Bytecodes::Code(_code); }\n-\n-\n-  bool      check_index(int i, int& cp_index, outputStream* st);\n-  bool      check_cp_cache_index(int i, int& cp_index, outputStream* st);\n-  bool      check_obj_index(int i, int& cp_index, outputStream* st);\n-  bool      check_invokedynamic_index(int i, int& cp_index, outputStream* st);\n+  int       get_index_u1()           { return *(address)_next_pc++; }  \/\/ returns 0x00 - 0xff as an int\n+  short     get_short()              { short i = Bytes::get_Java_u2  (_next_pc); _next_pc += 2; return i; }\n+  int       get_int()                { int   i = Bytes::get_Java_u4  (_next_pc); _next_pc += 4; return i; }\n+  int       get_native_index_u2()    { int   i = Bytes::get_native_u2(_next_pc); _next_pc += 2; return i; }\n+  int       get_native_index_u4()    { int   i = Bytes::get_native_u4(_next_pc); _next_pc += 4; return i; }\n+  int       get_Java_index_u2()      { int   i = Bytes::get_Java_u2  (_next_pc); _next_pc += 2; return i; }\n+  int       get_Java_index_u4()      { int   i = Bytes::get_Java_u4  (_next_pc); _next_pc += 4; return i; }\n+  int       get_index_special()      { return (is_wide()) ? get_Java_index_u2() : get_index_u1(); }\n+  Method*   method() const           { return _current_method; }\n+  bool      is_wide() const          { return _is_wide; }\n+  Bytecodes::Code raw_code() const   { return Bytecodes::Code(_code); }\n+  ConstantPool* constants() const    { return method()->constants(); }\n+  ConstantPoolCache* cpcache() const { assert(is_linked(), \"must be\"); return constants()->cache(); }\n+\n@@ -80,5 +78,4 @@\n-  void      print_constant_nocheck(int i, outputStream* st);\n-  void      print_dynamic(int orig_i, int i, constantTag tag, outputStream* st);\n-  void      print_field_or_method(int i, outputStream* st);\n-  void      print_field_or_method(int orig_i, int i, outputStream* st);\n-  void      print_invoke_handle(int i, outputStream* st);\n+  void      print_invokedynamic(int indy_index, int cp_index, outputStream* st);\n+  void      print_bsm(int cp_index, outputStream* st);\n+  void      print_field_or_method(int cp_index, outputStream* st);\n+  void      print_dynamic(int cp_index, outputStream* st);\n@@ -112,0 +109,2 @@\n+      _is_linked = method->method_holder()->is_linked();\n+      assert(_is_linked, \"this function must be called on methods that are already executing\");\n@@ -121,1 +120,1 @@\n-     int bci = bcp - method->code_base();\n+     int bci = (int)(bcp - method->code_base());\n@@ -136,0 +135,6 @@\n+\n+#ifndef PRODUCT\n+    if (TraceBytecodesStopAt != 0 && BytecodeCounter::counter_value() >= TraceBytecodesStopAt) {\n+      TraceBytecodes = false;\n+    }\n+#endif\n@@ -142,0 +147,1 @@\n+    _is_linked = method->method_holder()->is_linked();\n@@ -150,1 +156,1 @@\n-    int bci = bcp - method->code_base();\n+    int bci = (int)(bcp - method->code_base());\n@@ -193,99 +199,1 @@\n-void print_symbol(Symbol* sym, outputStream* st) {\n-  char buf[40];\n-  int len = sym->utf8_length();\n-  if (len >= (int)sizeof(buf)) {\n-    st->print_cr(\" %s...[%d]\", sym->as_C_string(buf, sizeof(buf)), len);\n-  } else {\n-    st->print(\" \");\n-    sym->print_on(st); st->cr();\n-  }\n-}\n-\n-void print_oop(oop value, outputStream* st) {\n-  if (value == nullptr) {\n-    st->print_cr(\" null\");\n-  } else if (java_lang_String::is_instance(value)) {\n-    char buf[40];\n-    int len = java_lang_String::utf8_length(value);\n-    java_lang_String::as_utf8_string(value, buf, sizeof(buf));\n-    if (len >= (int)sizeof(buf)) {\n-      st->print_cr(\" %s...[%d]\", buf, len);\n-    } else {\n-      st->print_cr(\" %s\", buf);\n-    }\n-  } else {\n-    st->print_cr(\" \" INTPTR_FORMAT, p2i((void *)value));\n-  }\n-}\n-\n-bool BytecodePrinter::check_index(int i, int& cp_index, outputStream* st) {\n-  ConstantPool* constants = method()->constants();\n-  int ilimit = constants->length();\n-  Bytecodes::Code code = raw_code();\n-\n-  if (Bytecodes::uses_cp_cache(code)) {\n-    bool okay = true;\n-    switch (code) {\n-    case Bytecodes::_fast_aldc:\n-    case Bytecodes::_fast_aldc_w:\n-      okay = check_obj_index(i, cp_index, st);\n-      break;\n-    case Bytecodes::_invokedynamic:\n-      okay = check_invokedynamic_index(i, cp_index, st);\n-      break;\n-    default:\n-      okay = check_cp_cache_index(i, cp_index, st);\n-      break;\n-    }\n-    if (!okay) return false;\n-  }\n-\n-\n-  \/\/ check cp index\n-  if (cp_index >= 0 && cp_index < ilimit) {\n-    if (WizardMode)  st->print(\" cp[%d]\", cp_index);\n-    return true;\n-  }\n-\n-  st->print_cr(\" CP[%d] not in CP\", cp_index);\n-  return false;\n-}\n-\n-bool BytecodePrinter::check_cp_cache_index(int i, int& cp_index, outputStream* st) {\n-  ConstantPool* constants = method()->constants();\n-  int climit = 0;\n-\n-  ConstantPoolCache* cache = constants->cache();\n-  \/\/ If rewriter hasn't run, the index is the cp_index\n-  if (cache == nullptr) {\n-    cp_index = i;\n-    return true;\n-  }\n-  \/\/climit = cache->length();  \/\/ %%% private!\n-  size_t size = cache->size() * wordSize;\n-  size -= sizeof(ConstantPoolCache);\n-  size \/= sizeof(ConstantPoolCacheEntry);\n-  climit = (int) size;\n-\n-#ifdef ASSERT\n-  {\n-    const int CPCACHE_INDEX_TAG = ConstantPool::CPCACHE_INDEX_TAG;\n-    if (i >= CPCACHE_INDEX_TAG && i < climit + CPCACHE_INDEX_TAG) {\n-      i -= CPCACHE_INDEX_TAG;\n-    } else {\n-      st->print_cr(\" CP[%d] missing bias?\", i);\n-      return false;\n-    }\n-  }\n-#endif \/\/ASSERT\n-  if (i >= 0 && i < climit) {\n-    cp_index = cache->entry_at(i)->constant_pool_index();\n-  } else {\n-    st->print_cr(\"%d not in CP[*]?\", i);\n-      return false;\n-    }\n-  return true;\n-  }\n-\n-\n-bool BytecodePrinter::check_obj_index(int i, int& cp_index, outputStream* st) {\n+void BytecodePrinter::print_constant(int cp_index, outputStream* st) {\n@@ -293,35 +201,1 @@\n-  i -= ConstantPool::CPCACHE_INDEX_TAG;\n-\n-  if (i >= 0 && i < constants->resolved_references()->length()) {\n-     cp_index = constants->object_to_cp_index(i);\n-     return true;\n-  } else {\n-    st->print_cr(\"%d not in OBJ[*]?\", i);\n-  return false;\n-}\n-}\n-\n-\n-bool BytecodePrinter::check_invokedynamic_index(int i, int& cp_index, outputStream* st) {\n-  ConstantPool* constants = _current_method->constants();\n-  if (constants->cache() == nullptr) {\n-    cp_index = i; \/\/ TODO: This is wrong on little-endian. See JDK-8309811.\n-  } else {\n-    assert(ConstantPool::is_invokedynamic_index(i), \"must be\");\n-    int indy_index = ConstantPool::decode_invokedynamic_index(i);\n-    ResolvedIndyEntry* indy_entry = constants->resolved_indy_entry_at(indy_index);\n-    cp_index = indy_entry->constant_pool_index();\n-  }\n-  return true;\n-}\n-\n-void BytecodePrinter::print_constant(int i, outputStream* st) {\n-  int orig_i = i;\n-  if (!check_index(orig_i, i, st))  return;\n-\n-  print_constant_nocheck(i, st);\n-}\n-\n-void BytecodePrinter::print_constant_nocheck(int i, outputStream* st) {\n-  ConstantPool* constants = method()->constants();\n-  constantTag tag = constants->tag_at(i);\n+  constantTag tag = constants->tag_at(cp_index);\n@@ -330,1 +204,1 @@\n-    st->print_cr(\" \" INT32_FORMAT, constants->int_at(i));\n+    st->print_cr(\" \" INT32_FORMAT, constants->int_at(cp_index));\n@@ -332,1 +206,1 @@\n-    st->print_cr(\" \" INT64_FORMAT, (int64_t)(constants->long_at(i)));\n+    st->print_cr(\" \" INT64_FORMAT, (int64_t)(constants->long_at(cp_index)));\n@@ -334,1 +208,1 @@\n-    st->print_cr(\" %f\", constants->float_at(i));\n+    st->print_cr(\" %f\", constants->float_at(cp_index));\n@@ -336,1 +210,1 @@\n-    st->print_cr(\" %f\", constants->double_at(i));\n+    st->print_cr(\" %f\", constants->double_at(cp_index));\n@@ -338,2 +212,2 @@\n-    const char* string = constants->string_at_noresolve(i);\n-    st->print_cr(\" %s\", string);\n+    const char* string = constants->unresolved_string_at(cp_index)->as_quoted_ascii();\n+    st->print_cr(\" \\\"%s\\\"\", string);\n@@ -341,1 +215,1 @@\n-    st->print_cr(\" %s\", constants->resolved_klass_at(i)->external_name());\n+    st->print_cr(\" %s\", constants->resolved_klass_at(cp_index)->external_name());\n@@ -343,1 +217,1 @@\n-    st->print_cr(\" <unresolved klass at %d>\", i);\n+    st->print_cr(\" %s\", constants->klass_at_noresolve(cp_index)->as_quoted_ascii());\n@@ -345,1 +219,1 @@\n-    int i2 = constants->method_type_index_at(i);\n+    int i2 = constants->method_type_index_at(cp_index);\n@@ -347,1 +221,1 @@\n-    print_symbol(constants->symbol_at(i2), st);\n+    st->print_cr(\" %s\", constants->symbol_at(i2)->as_quoted_ascii());\n@@ -349,2 +223,2 @@\n-    int kind = constants->method_handle_ref_kind_at(i);\n-    int i2 = constants->method_handle_index_at(i);\n+    int kind = constants->method_handle_ref_kind_at(cp_index);\n+    int i2 = constants->method_handle_index_at(cp_index);\n@@ -352,1 +226,6 @@\n-    print_field_or_method(-i, i2, st);\n+    print_field_or_method(i2, st);\n+  } else if (tag.is_dynamic_constant()) {\n+    print_dynamic(cp_index, st);\n+    if (ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_DYNAMIC)) {\n+      print_bsm(cp_index, st);\n+    }\n@@ -354,1 +233,1 @@\n-    st->print_cr(\" bad tag=%d at %d\", tag.value(), i);\n+    st->print_cr(\" bad tag=%d at %d\", tag.value(), cp_index);\n@@ -358,7 +237,2 @@\n-void BytecodePrinter::print_field_or_method(int i, outputStream* st) {\n-  int orig_i = i;\n-  if (!check_index(orig_i, i, st))  return;\n-  print_field_or_method(orig_i, i, st);\n-}\n-\n-void BytecodePrinter::print_field_or_method(int orig_i, int i, outputStream* st) {\n+\/\/ Fieldref, Methodref, or InterfaceMethodref\n+void BytecodePrinter::print_field_or_method(int cp_index, outputStream* st) {\n@@ -366,3 +240,1 @@\n-  constantTag tag = constants->tag_at(i);\n-\n-  bool has_klass = true;\n+  constantTag tag = constants->tag_at(cp_index);\n@@ -371,2 +243,2 @@\n-  case JVM_CONSTANT_InterfaceMethodref:\n-  case JVM_CONSTANT_Methodref:\n+  case JVM_CONSTANT_Methodref:\n+  case JVM_CONSTANT_InterfaceMethodref:\n@@ -375,1 +247,18 @@\n-  case JVM_CONSTANT_NameAndType:\n+  default:\n+    st->print_cr(\" bad tag=%d at %d\", tag.value(), cp_index);\n+    return;\n+  }\n+\n+  Symbol* name = constants->uncached_name_ref_at(cp_index);\n+  Symbol* signature = constants->uncached_signature_ref_at(cp_index);\n+  Symbol* klass = constants->klass_name_at(constants->uncached_klass_ref_index_at(cp_index));\n+  const char* sep = (tag.is_field() ? \":\" : \"\");\n+  st->print_cr(\" %d <%s.%s%s%s> \", cp_index, klass->as_C_string(), name->as_C_string(), sep, signature->as_C_string());\n+}\n+\n+\/\/ JVM_CONSTANT_Dynamic or JVM_CONSTANT_InvokeDynamic\n+void BytecodePrinter::print_dynamic(int cp_index, outputStream* st) {\n+  ConstantPool* constants = method()->constants();\n+  constantTag tag = constants->tag_at(cp_index);\n+\n+  switch (tag.value()) {\n@@ -378,1 +267,0 @@\n-    has_klass = false;\n@@ -381,1 +269,1 @@\n-    st->print_cr(\" bad tag=%d at %d\", tag.value(), i);\n+    st->print_cr(\" bad tag=%d at %d\", tag.value(), cp_index);\n@@ -385,13 +273,2 @@\n-  Symbol* name = constants->uncached_name_ref_at(i);\n-  Symbol* signature = constants->uncached_signature_ref_at(i);\n-  const char* sep = (tag.is_field() ? \"\/\" : \"\");\n-  if (has_klass) {\n-    Symbol* klass = constants->klass_name_at(constants->uncached_klass_ref_index_at(i));\n-    st->print_cr(\" %d <%s.%s%s%s> \", i, klass->as_C_string(), name->as_C_string(), sep, signature->as_C_string());\n-  } else {\n-    if (tag.is_dynamic_constant() || tag.is_invoke_dynamic()) {\n-      int bsm = constants->bootstrap_method_ref_index_at(i);\n-      st->print(\" bsm=%d\", bsm);\n-    }\n-    st->print_cr(\" %d <%s%s%s>\", i, name->as_C_string(), sep, signature->as_C_string());\n-  }\n+  int bsm = constants->bootstrap_method_ref_index_at(cp_index);\n+  st->print(\" bsm=%d\", bsm);\n@@ -399,3 +276,17 @@\n-  if (ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_DYNAMIC) &&\n-      (tag.is_dynamic_constant() || tag.is_invoke_dynamic())) {\n-    print_dynamic(orig_i, i, tag, st);\n+  Symbol* name = constants->uncached_name_ref_at(cp_index);\n+  Symbol* signature = constants->uncached_signature_ref_at(cp_index);\n+  const char* sep = tag.is_dynamic_constant() ? \":\" : \"\";\n+  st->print_cr(\" %d <%s%s%s>\", cp_index, name->as_C_string(), sep, signature->as_C_string());\n+}\n+\n+void BytecodePrinter::print_invokedynamic(int indy_index, int cp_index, outputStream* st) {\n+  print_dynamic(cp_index, st);\n+\n+  if (ClassPrinter::has_mode(_flags, ClassPrinter::PRINT_DYNAMIC)) {\n+    print_bsm(cp_index, st);\n+\n+    if (is_linked()) {\n+      ResolvedIndyEntry* indy_entry = constants()->resolved_indy_entry_at(indy_index);\n+      st->print(\"  ResolvedIndyEntry: \");\n+      indy_entry->print_on(st);\n+    }\n@@ -405,3 +296,4 @@\n-void BytecodePrinter::print_dynamic(int orig_i, int bsm_cpindex, constantTag tag, outputStream* st) {\n-  ConstantPool* constants = method()->constants();\n-  int bsm = constants->bootstrap_method_ref_index_at(bsm_cpindex);\n+\/\/ cp_index: must be the cp_index of a JVM_CONSTANT_{Dynamic, DynamicInError, InvokeDynamic}\n+void BytecodePrinter::print_bsm(int cp_index, outputStream* st) {\n+  assert(constants()->tag_at(cp_index).has_bootstrap(), \"must be\");\n+  int bsm = constants()->bootstrap_method_ref_index_at(cp_index);\n@@ -409,1 +301,1 @@\n-  switch (constants->method_handle_ref_kind_at(bsm)) {\n+  switch (constants()->method_handle_ref_kind_at(bsm)) {\n@@ -422,2 +314,2 @@\n-  print_field_or_method(-1, constants->method_handle_index_at(bsm), st);\n-  int argc = constants->bootstrap_argument_count_at(bsm_cpindex);\n+  print_field_or_method(constants()->method_handle_index_at(bsm), st);\n+  int argc = constants()->bootstrap_argument_count_at(cp_index);\n@@ -428,1 +320,1 @@\n-      int arg = constants->bootstrap_argument_index_at(bsm_cpindex, arg_i);\n+      int arg = constants()->bootstrap_argument_index_at(cp_index, arg_i);\n@@ -430,1 +322,1 @@\n-      print_constant_nocheck(arg, st);\n+      print_constant(arg, st);\n@@ -434,12 +326,0 @@\n-  if (tag.is_invoke_dynamic()) {\n-    int indy_index = constants->decode_invokedynamic_index(orig_i);\n-    ResolvedIndyEntry* indy_entry = constants->resolved_indy_entry_at(indy_index);\n-    st->print(\"  ResolvedIndyEntry: \");\n-    indy_entry->print_on(st);\n-  } else {\n-    \/\/ TODO: print info for tag.is_dynamic_constant()\n-  }\n-}\n-\n-void BytecodePrinter::print_invoke_handle(int i, outputStream* st) {\n-  print_cpcache_entry(ConstantPool::decode_cpcache_index(i), st);\n@@ -475,4 +355,10 @@\n-      if (Bytecodes::uses_cp_cache(raw_code())) {\n-        print_constant(get_index_u1_cpcache(), st);\n-      } else {\n-        print_constant(get_index_u1(), st);\n+      {\n+        int cp_index;\n+        if (Bytecodes::uses_cp_cache(raw_code())) {\n+          assert(is_linked(), \"fast ldc bytecode must be in linked classes\");\n+          int obj_index = get_index_u1();\n+          cp_index = constants()->object_to_cp_index(obj_index);\n+        } else {\n+          cp_index = get_index_u1();\n+        }\n+        print_constant(cp_index, st);\n@@ -484,4 +370,10 @@\n-      if (Bytecodes::uses_cp_cache(raw_code())) {\n-        print_constant(get_index_u2_cpcache(), st);\n-      } else {\n-        print_constant(get_index_u2(), st);\n+      {\n+        int cp_index;\n+        if (Bytecodes::uses_cp_cache(raw_code())) {\n+          assert(is_linked(), \"fast ldc bytecode must be in linked classes\");\n+          int obj_index = get_native_index_u2();\n+          cp_index = constants()->object_to_cp_index(obj_index);\n+        } else {\n+          cp_index = get_Java_index_u2();\n+        }\n+        print_constant(cp_index, st);\n@@ -521,1 +413,1 @@\n-        int klass_index = get_index_u2();\n+        int klass_index = get_Java_index_u2();\n@@ -528,1 +420,1 @@\n-        int klass_index = get_index_u2();\n+        int klass_index = get_Java_index_u2();\n@@ -610,1 +502,10 @@\n-      print_field_or_method(get_index_u2_cpcache(), st);\n+      {\n+        int cp_index;\n+        if (is_linked()) {\n+          int cpcache_index = get_native_index_u2();\n+          cp_index = cpcache()->entry_at(cpcache_index)->constant_pool_index();\n+        } else {\n+          cp_index = get_Java_index_u2();\n+        }\n+        print_field_or_method(cp_index, st);\n+      }\n@@ -617,2 +518,10 @@\n-        int i = get_index_u2_cpcache();\n-        print_field_or_method(i, st);\n+        int cp_index;\n+        int cpcache_index;\n+        if (is_linked()) {\n+          cpcache_index = get_native_index_u2();\n+          cp_index = cpcache()->entry_at(cpcache_index)->constant_pool_index();\n+        } else {\n+          cpcache_index = -1;\n+          cp_index = get_Java_index_u2();\n+        }\n+        print_field_or_method(cp_index, st);\n@@ -621,1 +530,3 @@\n-          print_invoke_handle(i, st);\n+          assert(is_linked(), \"invokehandle is only in rewritten methods\");\n+          assert(cpcache_index >= 0, \"must be\");\n+          print_cpcache_entry(cpcache_index, st);\n@@ -627,4 +538,11 @@\n-      { int i = get_index_u2_cpcache();\n-        int n = get_index_u1();\n-        get_byte();            \/\/ ignore zero byte\n-        print_field_or_method(i, st);\n+      {\n+        int cp_index;\n+        if (is_linked()) {\n+          int cpcache_index = get_native_index_u2();\n+          cp_index = cpcache()->entry_at(cpcache_index)->constant_pool_index();\n+        } else {\n+          cp_index = get_Java_index_u2();\n+        }\n+        int count = get_index_u1(); \/\/ TODO: this is not printed.\n+        get_byte();                 \/\/ ignore zero byte\n+        print_field_or_method(cp_index, st);\n@@ -635,1 +553,15 @@\n-      print_field_or_method(get_index_u4(), st);\n+      {\n+        int indy_index;\n+        int cp_index;\n+        if (is_linked()) {\n+          int i = get_native_index_u4();\n+          indy_index = ConstantPool::decode_invokedynamic_index(i);\n+          cp_index = constants()->resolved_indy_entry_at(indy_index)->constant_pool_index();\n+        } else {\n+          indy_index = -1;\n+          cp_index = get_Java_index_u2();\n+          get_byte();            \/\/ ignore zero byte\n+          get_byte();            \/\/ ignore zero byte\n+        }\n+        print_invokedynamic(indy_index, cp_index, st);\n+      }\n@@ -642,1 +574,1 @@\n-      { int i = get_index_u2();\n+      { int i = get_Java_index_u2();\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":176,"deletions":244,"binary":false,"changes":420,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-StackSlotAnalysisData::StackSlotAnalysisData(int bci, BasicType type) : _bci(bci), _type(type) {\n+StackSlotAnalysisData::StackSlotAnalysisData(int bci, BasicType type) : _bci((u2)bci), _type(type) {\n@@ -1085,1 +1085,1 @@\n-  for (int64_t i = 0; i < dests.length(); ++i) {\n+  for (int i = 0; i < dests.length(); ++i) {\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -392,3 +392,3 @@\n-      jlong lo = (jint)Bytes::get_Java_u4(aligned_bcp + 1*jintSize);\n-      jlong hi = (jint)Bytes::get_Java_u4(aligned_bcp + 2*jintSize);\n-      jlong len = (aligned_bcp - bcp) + (3 + hi - lo + 1)*jintSize;\n+      int lo = Bytes::get_Java_u4(aligned_bcp + 1*jintSize);\n+      int hi = Bytes::get_Java_u4(aligned_bcp + 2*jintSize);\n+      int len = (int)(aligned_bcp - bcp) + (3 + hi - lo + 1)*jintSize;\n@@ -407,2 +407,2 @@\n-      jlong npairs = (jint)Bytes::get_Java_u4(aligned_bcp + jintSize);\n-      jlong len = (aligned_bcp - bcp) + (2 + 2*npairs)*jintSize;\n+      int npairs = Bytes::get_Java_u4(aligned_bcp + jintSize);\n+      int len = (int)(aligned_bcp - bcp) + (2 + 2*npairs)*jintSize;\n@@ -446,1 +446,1 @@\n-  int bc_flags = 0;\n+  jchar bc_flags = 0;\n@@ -476,1 +476,1 @@\n-int Bytecodes::compute_flags(const char* format, int more_flags) {\n+jchar Bytecodes::compute_flags(const char* format, jchar more_flags) {\n@@ -478,1 +478,1 @@\n-  int flags = more_flags;\n+  jchar flags = more_flags;\n@@ -498,1 +498,1 @@\n-    int this_flag = 0;\n+    jchar this_flag = 0;\n@@ -502,1 +502,0 @@\n-      assert(flags == (jchar)flags, \"change _format_flags\");\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-  enum Flags {\n+  enum Flags : jchar {\n@@ -363,0 +363,1 @@\n+  static jchar compute_flags  (const char* format, jchar more_flags);  \/\/ compute the flags\n@@ -432,1 +433,0 @@\n-  static int         compute_flags  (const char* format, int more_flags = 0);  \/\/ compute the flags\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-  set_bci(bci);\n+  set_bci(checked_cast<unsigned short>(bci));  \/\/ bci is always u2\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-    Bytes::put_native_u2(p, cache_index);\n+    Bytes::put_native_u2(p, (u2)cache_index);\n@@ -190,1 +190,1 @@\n-    Bytes::put_Java_u2(p, pool_index);\n+    Bytes::put_Java_u2(p, (u2)pool_index);\n@@ -209,1 +209,1 @@\n-      Bytes::put_native_u2(p, cache_index);\n+      Bytes::put_native_u2(p, (u2)cache_index);\n@@ -297,1 +297,1 @@\n-    Bytes::put_Java_u2(p, cp_index);\n+    Bytes::put_Java_u2(p, (u2)cp_index);\n@@ -321,1 +321,1 @@\n-        Bytes::put_native_u2(p, ref_index);\n+        Bytes::put_native_u2(p, (u2)ref_index);\n@@ -338,1 +338,1 @@\n-        Bytes::put_Java_u2(p, pool_index);\n+        Bytes::put_Java_u2(p, (u2)pool_index);\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-  int i = this - TemplateTable::_template_table;\n-  if (i < 0 || i >= Bytecodes::number_of_codes) i = this - TemplateTable::_template_table_wide;\n+  int i = (int)(this - TemplateTable::_template_table);\n+  if (i < 0 || i >= Bytecodes::number_of_codes) i = (int)(this - TemplateTable::_template_table_wide);\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -585,1 +585,1 @@\n-    JVMCI_THROW_MSG_0(InternalError, err_msg(\"Primitive type %s should be handled in Java code\", class_name->as_C_string()));\n+    JVMCI_THROW_MSG_0(InternalError, err_msg(\"Primitive type %s should be handled in Java code\", str));\n@@ -704,2 +704,2 @@\n-  if (tag.is_dynamic_constant() || tag.is_dynamic_constant_in_error()) {\n-    if (obj == Universe::the_null_sentinel()) {\n+  if (tag.is_dynamic_constant()) {\n+    if (obj == nullptr) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -558,2 +558,2 @@\n-  const int offset() { return _offset; }\n-  const int index() { return _index; }\n+  int offset() const { return _offset; }\n+  int index() const { return _index; }\n@@ -562,1 +562,1 @@\n-  const bool is_inline_type() { return Signature::basic_type(_signature) == T_PRIMITIVE_OBJECT; }\n+  bool is_inline_type() const { return Signature::basic_type(_signature) == T_PRIMITIVE_OBJECT; }\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    assert(type >= 0 && type < T_CONFLICT, \"wrong type\");\n+    assert(type < T_CONFLICT, \"wrong type\");\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -599,1 +599,1 @@\n-  int operand_bootstrap_method_ref_index_at(int bsms_attribute_index) {\n+  u2 operand_bootstrap_method_ref_index_at(int bsms_attribute_index) {\n@@ -603,1 +603,1 @@\n-  int operand_argument_count_at(int bsms_attribute_index) {\n+  u2 operand_argument_count_at(int bsms_attribute_index) {\n@@ -605,1 +605,1 @@\n-    int argc = operands()->at(offset + _indy_argc_offset);\n+    u2 argc = operands()->at(offset + _indy_argc_offset);\n@@ -608,1 +608,1 @@\n-  int operand_argument_index_at(int bsms_attribute_index, int j) {\n+  u2 operand_argument_index_at(int bsms_attribute_index, int j) {\n@@ -630,1 +630,1 @@\n-  int bootstrap_method_ref_index_at(int which) {\n+  u2 bootstrap_method_ref_index_at(int which) {\n@@ -635,1 +635,1 @@\n-  int bootstrap_argument_count_at(int which) {\n+  u2 bootstrap_argument_count_at(int which) {\n@@ -638,1 +638,1 @@\n-    int argc = operands()->at(op_base + _indy_argc_offset);\n+    u2 argc = operands()->at(op_base + _indy_argc_offset);\n@@ -644,1 +644,1 @@\n-  int bootstrap_argument_index_at(int which, int j) {\n+  u2 bootstrap_argument_index_at(int which, int j) {\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  int name_index() const {\n+  u2 name_index() const {\n@@ -153,1 +153,1 @@\n-  int signature_index() const {\n+  u2 signature_index() const {\n@@ -159,1 +159,1 @@\n-  int generic_signature_index() const {\n+  u2 generic_signature_index() const {\n@@ -167,1 +167,1 @@\n-  int initval_index() const {\n+  u2 initval_index() const {\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-  _jsrs = new GrowableArray<intptr_t>(_init_nof_jsrs);\n+  _jsrs = new GrowableArray<int>(_init_nof_jsrs);\n@@ -664,1 +664,1 @@\n- int bbNum = bb - _basic_blocks + 1;\n+ intptr_t bbNum = bb - _basic_blocks + 1;\n@@ -2094,1 +2094,1 @@\n-  GenerateOopMap::_total_byte_count \/ GenerateOopMap::_total_oopmap_time.seconds());\n+  (double)GenerateOopMap::_total_byte_count \/ GenerateOopMap::_total_oopmap_time.seconds());\n@@ -2138,1 +2138,1 @@\n-  _ret_adr_tos    = new GrowableArray<intptr_t>(5);  \/\/ 5 seems like a good number;\n+  _ret_adr_tos    = new GrowableArray<int>(5);  \/\/ 5 seems like a good number;\n@@ -2438,1 +2438,1 @@\n-    *bcp = bc0 + varNo;\n+    *bcp = (u1)(bc0 + varNo);\n@@ -2442,1 +2442,1 @@\n-    *(bcp + 1) = varNo;\n+    *(bcp + 1) = (u1)varNo;\n@@ -2447,1 +2447,1 @@\n-    Bytes::put_Java_u2(bcp+2, varNo);\n+    Bytes::put_Java_u2(bcp+2, (u2)varNo);\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  GrowableArray<intptr_t> * _jsrs;                     \/\/ List of return addresses  (bytecode index)\n+  GrowableArray<int> * _jsrs;                     \/\/ List of return addresses  (bytecode index)\n@@ -450,1 +450,1 @@\n-  GrowableArray<intptr_t> *_ret_adr_tos;\n+  GrowableArray<int>* _ret_adr_tos;\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1114,2 +1114,2 @@\n-ResourceHashtable<const InstanceKlass*, OopHandle, 107, AnyObj::C_HEAP, mtClass>\n-      _initialization_error_table;\n+using InitializationErrorTable = ResourceHashtable<const InstanceKlass*, OopHandle, 107, AnyObj::C_HEAP, mtClass>;\n+static InitializationErrorTable* _initialization_error_table;\n@@ -1142,1 +1142,4 @@\n-  _initialization_error_table.put_if_absent(this, elem, &created);\n+  if (_initialization_error_table == nullptr) {\n+    _initialization_error_table = new (mtClass) InitializationErrorTable();\n+  }\n+  _initialization_error_table->put_if_absent(this, elem, &created);\n@@ -1149,1 +1152,4 @@\n-  OopHandle* h = _initialization_error_table.get(this);\n+  if (_initialization_error_table == nullptr) {\n+    return nullptr;\n+  }\n+  OopHandle* h = _initialization_error_table->get(this);\n@@ -1168,1 +1174,3 @@\n-  _initialization_error_table.unlink(&cleaner);\n+  if (_initialization_error_table != nullptr) {\n+    _initialization_error_table->unlink(&cleaner);\n+  }\n@@ -3070,0 +3078,25 @@\n+\/\/ The constant pool is on stack if any of the methods are executing or\n+\/\/ referenced by handles.\n+bool InstanceKlass::on_stack() const {\n+  return _constants->on_stack();\n+}\n+\n+Symbol* InstanceKlass::source_file_name() const               { return _constants->source_file_name(); }\n+u2 InstanceKlass::source_file_name_index() const              { return _constants->source_file_name_index(); }\n+void InstanceKlass::set_source_file_name_index(u2 sourcefile_index) { _constants->set_source_file_name_index(sourcefile_index); }\n+\n+\/\/ minor and major version numbers of class file\n+u2 InstanceKlass::minor_version() const                 { return _constants->minor_version(); }\n+void InstanceKlass::set_minor_version(u2 minor_version) { _constants->set_minor_version(minor_version); }\n+u2 InstanceKlass::major_version() const                 { return _constants->major_version(); }\n+void InstanceKlass::set_major_version(u2 major_version) { _constants->set_major_version(major_version); }\n+\n+InstanceKlass* InstanceKlass::get_klass_version(int version) {\n+  for (InstanceKlass* ik = this; ik != nullptr; ik = ik->previous_versions()) {\n+    if (ik->constants()->version() == version) {\n+      return ik;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -3088,0 +3121,4 @@\n+Symbol* InstanceKlass::generic_signature() const                   { return _constants->generic_signature(); }\n+u2 InstanceKlass::generic_signature_index() const                  { return _constants->generic_signature_index(); }\n+void InstanceKlass::set_generic_signature_index(u2 sig_index)      { _constants->set_generic_signature_index(sig_index); }\n+\n@@ -4573,0 +4610,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"oops\/constantPool.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -39,0 +39,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -44,0 +45,1 @@\n+class ConstantPool;\n@@ -46,0 +48,1 @@\n+class Monitor;\n@@ -120,1 +123,1 @@\n-  static const int size_in_words() {\n+  static int size_in_words() {\n@@ -710,3 +713,3 @@\n-  Symbol* source_file_name() const               { return _constants->source_file_name(); }\n-  u2 source_file_name_index() const              { return _constants->source_file_name_index(); }\n-  void set_source_file_name_index(u2 sourcefile_index) { _constants->set_source_file_name_index(sourcefile_index); }\n+  Symbol* source_file_name() const;\n+  u2 source_file_name_index() const;\n+  void set_source_file_name_index(u2 sourcefile_index);\n@@ -715,4 +718,4 @@\n-  u2 minor_version() const                 { return _constants->minor_version(); }\n-  void set_minor_version(u2 minor_version) { _constants->set_minor_version(minor_version); }\n-  u2 major_version() const                 { return _constants->major_version(); }\n-  void set_major_version(u2 major_version) { _constants->set_major_version(major_version); }\n+  u2 minor_version() const;\n+  void set_minor_version(u2 minor_version);\n+  u2 major_version() const;\n+  void set_major_version(u2 major_version);\n@@ -755,8 +758,1 @@\n-  InstanceKlass* get_klass_version(int version) {\n-    for (InstanceKlass* ik = this; ik != nullptr; ik = ik->previous_versions()) {\n-      if (ik->constants()->version() == version) {\n-        return ik;\n-      }\n-    }\n-    return nullptr;\n-  }\n+  InstanceKlass* get_klass_version(int version);\n@@ -838,3 +834,3 @@\n-  Symbol* generic_signature() const                   { return _constants->generic_signature(); }\n-  u2 generic_signature_index() const                  { return _constants->generic_signature_index(); }\n-  void set_generic_signature_index(u2 sig_index)      { _constants->set_generic_signature_index(sig_index); }\n+  Symbol* generic_signature() const;\n+  u2 generic_signature_index() const;\n+  void set_generic_signature_index(u2 sig_index);\n@@ -1075,3 +1071,1 @@\n-  \/\/ The constant pool is on stack if any of the methods are executing or\n-  \/\/ referenced by handles.\n-  bool on_stack() const { return _constants->on_stack(); }\n+  virtual bool on_stack() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":17,"deletions":23,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-  static const uintptr_t no_hash_in_place         = (address_word)no_hash << hash_shift;\n+  static const uintptr_t no_hash_in_place         = (uintptr_t)no_hash << hash_shift;\n@@ -342,1 +342,1 @@\n-  uint     age()           const { return mask_bits(value() >> age_shift, age_mask); }\n+  uint     age()           const { return (uint) mask_bits(value() >> age_shift, age_mask); }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-  int code_size() const                  { return constMethod()->code_size(); }\n+  u2 code_size() const                   { return constMethod()->code_size(); }\n@@ -272,3 +272,3 @@\n-  int  verifier_max_stack() const                { return constMethod()->max_stack(); }\n-  int           max_stack() const                { return constMethod()->max_stack() + extra_stack_entries(); }\n-  void      set_max_stack(int size)              {        constMethod()->set_max_stack(size); }\n+  u2  verifier_max_stack() const               { return constMethod()->max_stack(); }\n+  int          max_stack() const               { return constMethod()->max_stack() + extra_stack_entries(); }\n+  void      set_max_stack(int size)            {        constMethod()->set_max_stack(size); }\n@@ -277,2 +277,2 @@\n-  int  max_locals() const                        { return constMethod()->max_locals(); }\n-  void set_max_locals(int size)                  { constMethod()->set_max_locals(size); }\n+  u2  max_locals() const                       { return constMethod()->max_locals(); }\n+  void set_max_locals(int size)                { constMethod()->set_max_locals(size); }\n@@ -419,1 +419,1 @@\n-  CompiledMethod* volatile code() const;\n+  CompiledMethod* code() const;\n@@ -537,1 +537,1 @@\n-                          { return constMethod()->method_parameters_start(); }\n+                         { return constMethod()->method_parameters_start(); }\n@@ -540,1 +540,1 @@\n-  int checked_exceptions_length() const\n+  u2 checked_exceptions_length() const\n@@ -543,1 +543,1 @@\n-                          { return constMethod()->checked_exceptions_start(); }\n+                         { return constMethod()->checked_exceptions_start(); }\n@@ -548,1 +548,1 @@\n-  int localvariable_table_length() const\n+  u2 localvariable_table_length() const\n@@ -1076,1 +1076,1 @@\n-  int length() const {\n+  u2 length() const {\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-inline CompiledMethod* volatile Method::code() const {\n+inline CompiledMethod* Method::code() const {\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,3 +55,0 @@\n-const char* C2Compiler::retry_class_loading_during_parsing() {\n-  return \"retry class loading during parsing\";\n-}\n@@ -122,4 +119,0 @@\n-      if (C.failure_reason_is(retry_class_loading_during_parsing())) {\n-        env->report_failure(C.failure_reason());\n-        continue;  \/\/ retry\n-      }\n@@ -765,0 +758,2 @@\n+  case vmIntrinsics::_VectorShuffleIota:\n+  case vmIntrinsics::_VectorShuffleToVector:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -817,1 +817,1 @@\n-          AllocateNode* alloc = AllocateNode::Ideal_allocation(buffer_oop, &kit.gvn());\n+          AllocateNode* alloc = AllocateNode::Ideal_allocation(buffer_oop);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -622,2 +622,2 @@\n-  const address  entry_point() const { return _entry_point; }\n-  const float    cnt()         const { return _cnt; }\n+  address  entry_point()       const { return _entry_point; }\n+  float    cnt()               const { return _cnt; }\n@@ -967,1 +967,1 @@\n-  static AllocateNode* Ideal_allocation(Node* ptr, PhaseValues* phase);\n+  static AllocateNode* Ideal_allocation(Node* ptr);\n@@ -977,1 +977,1 @@\n-    AllocateNode* allo = Ideal_allocation(ptr, phase);\n+    AllocateNode* allo = Ideal_allocation(ptr);\n@@ -1049,2 +1049,2 @@\n-  static AllocateArrayNode* Ideal_array_allocation(Node* ptr, PhaseValues* phase) {\n-    AllocateNode* allo = Ideal_allocation(ptr, phase);\n+  static AllocateArrayNode* Ideal_array_allocation(Node* ptr) {\n+    AllocateNode* allo = Ideal_allocation(ptr);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-  const bool has_range_check() {\n+  bool has_range_check() {\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,4 +241,4 @@\n-  const int inst_mem_id() const { return _inst_mem_id; }\n-  const int inst_id()     const { return _inst_id; }\n-  const int inst_index()  const { return _inst_index; }\n-  const int inst_offset() const { return _inst_offset; }\n+  int inst_mem_id() const { return _inst_mem_id; }\n+  int inst_id()     const { return _inst_id; }\n+  int inst_index()  const { return _inst_index; }\n+  int inst_offset() const { return _inst_offset; }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -567,1 +567,0 @@\n-  ttyLocker ttyl;\n@@ -572,6 +571,6 @@\n-  if (xtty != nullptr) {\n-    xtty->head(\"ideal compile_id='%d'%s compile_phase='%s'\",\n-               compile_id(),\n-               is_osr_compilation() ? \" compile_kind='osr'\" : \"\",\n-               phase_name);\n-  }\n+\n+  \/\/ Node dumping can cause a safepoint, which can break the tty lock.\n+  \/\/ Buffer all node dumps, so that all safepoints happen before we lock.\n+  ResourceMark rm;\n+  stringStream ss;\n+\n@@ -579,1 +578,1 @@\n-    tty->print_cr(\"AFTER: %s\", phase_name);\n+    ss.print_cr(\"AFTER: %s\", phase_name);\n@@ -581,1 +580,1 @@\n-    root()->dump_bfs(MaxNodeLimit, nullptr, \"+S$\");\n+    root()->dump_bfs(MaxNodeLimit, nullptr, \"+S$\", &ss);\n@@ -584,1 +583,1 @@\n-    _output->print_scheduling();\n+    _output->print_scheduling(&ss);\n@@ -587,0 +586,3 @@\n+  \/\/ Check that the lock is not broken by a safepoint.\n+  NoSafepointVerifier nsv;\n+  ttyLocker ttyl;\n@@ -588,0 +590,5 @@\n+    xtty->head(\"ideal compile_id='%d'%s compile_phase='%s'\",\n+               compile_id(),\n+               is_osr_compilation() ? \" compile_kind='osr'\" : \"\",\n+               phase_name);\n+    xtty->print(\"%s\", ss.as_string()); \/\/ print to tty would use xml escape encoding\n@@ -589,0 +596,2 @@\n+  } else {\n+    tty->print(\"%s\", ss.as_string());\n@@ -785,6 +794,4 @@\n-      if (!failure_reason_is(C2Compiler::retry_class_loading_during_parsing())) {\n-        assert(failure_reason() != nullptr, \"expect reason for parse failure\");\n-        stringStream ss;\n-        ss.print(\"method parse failed: %s\", failure_reason());\n-        record_method_not_compilable(ss.as_string());\n-      }\n+      assert(failure_reason() != nullptr, \"expect reason for parse failure\");\n+      stringStream ss;\n+      ss.print(\"method parse failed: %s\", failure_reason());\n+      record_method_not_compilable(ss.as_string());\n@@ -5540,2 +5547,2 @@\n-void NodeCloneInfo::dump() const {\n-  tty->print(\" {%d:%d} \", idx(), gen());\n+void NodeCloneInfo::dump_on(outputStream* st) const {\n+  st->print(\" {%d:%d} \", idx(), gen());\n@@ -5588,1 +5595,1 @@\n-void CloneMap::dump(node_idx_t key) const {\n+void CloneMap::dump(node_idx_t key, outputStream* st) const {\n@@ -5592,1 +5599,1 @@\n-    ni.dump();\n+    ni.dump_on(st);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-  void dump() const;\n+  void dump_on(outputStream* st) const;\n@@ -163,1 +163,1 @@\n-  void dump(node_idx_t key)       const;\n+  void dump(node_idx_t key, outputStream* st) const;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -691,0 +691,1 @@\n+    case Op_VectorizedHashCode:\n@@ -3668,1 +3669,1 @@\n-              op == Op_StrCompressedCopy || op == Op_StrInflatedCopy ||\n+              op == Op_StrCompressedCopy || op == Op_StrInflatedCopy || op == Op_VectorizedHashCode ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1229,1 +1229,1 @@\n-  AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(array, &_gvn);\n+  AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(array);\n@@ -4009,1 +4009,1 @@\n-    assert(AllocateNode::Ideal_allocation(rawoop, &_gvn) == alloc,\n+    assert(AllocateNode::Ideal_allocation(rawoop) == alloc,\n@@ -4011,1 +4011,1 @@\n-    assert(AllocateNode::Ideal_allocation(javaoop, &_gvn) == alloc,\n+    assert(AllocateNode::Ideal_allocation(javaoop) == alloc,\n@@ -4014,1 +4014,1 @@\n-      assert(AllocateArrayNode::Ideal_array_allocation(rawoop, &_gvn) == alloc->as_AllocateArray(),\n+      assert(AllocateArrayNode::Ideal_array_allocation(rawoop) == alloc->as_AllocateArray(),\n@@ -4016,1 +4016,1 @@\n-      assert(AllocateArrayNode::Ideal_array_allocation(javaoop, &_gvn) == alloc->as_AllocateArray(),\n+      assert(AllocateArrayNode::Ideal_array_allocation(javaoop) == alloc->as_AllocateArray(),\n@@ -4362,1 +4362,1 @@\n-AllocateNode* AllocateNode::Ideal_allocation(Node* ptr, PhaseValues* phase) {\n+AllocateNode* AllocateNode::Ideal_allocation(Node* ptr) {\n@@ -4393,1 +4393,1 @@\n-  return Ideal_allocation(base, phase);\n+  return Ideal_allocation(base);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -930,1 +930,1 @@\n-  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem);\n+  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector = false);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -558,1 +558,1 @@\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop, &kit->gvn());\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n@@ -934,1 +934,1 @@\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop, &kit->gvn());\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n@@ -956,1 +956,1 @@\n-  AllocateNode* alloc = AllocateNode::Ideal_allocation(obj, &kit->gvn());\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(obj);\n@@ -977,1 +977,1 @@\n-  AllocateNode* alloc = AllocateNode::Ideal_allocation(oop, gvn);\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(oop);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -711,0 +711,2 @@\n+  case vmIntrinsics::_VectorShuffleIota:\n+    return inline_vector_shuffle_iota();\n@@ -713,0 +715,2 @@\n+  case vmIntrinsics::_VectorShuffleToVector:\n+    return inline_vector_shuffle_to_vector();\n@@ -2648,1 +2652,1 @@\n-  if (AllocateNode::Ideal_allocation(vt->get_oop(), &_gvn) == nullptr) {\n+  if (AllocateNode::Ideal_allocation(vt->get_oop()) == nullptr) {\n@@ -4273,0 +4277,1 @@\n+    null_check_receiver();\n@@ -4332,1 +4337,1 @@\n-      AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(obj, &_gvn);\n+      AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(obj);\n@@ -4613,1 +4618,1 @@\n-    null_check_receiver();\n+    assert(!gvn().type(argument(0))->maybe_null(), \"should not be null\");\n@@ -4629,1 +4634,1 @@\n-    null_check_receiver();\n+    assert(!gvn().type(argument(0))->maybe_null(), \"should not be null\");\n@@ -5104,1 +5109,1 @@\n-    alloc = AllocateNode::Ideal_allocation(alloc_obj, &_gvn);\n+    alloc = AllocateNode::Ideal_allocation(alloc_obj);\n@@ -5852,1 +5857,1 @@\n-  AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(ptr, &_gvn);\n+  AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(ptr);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -371,0 +371,2 @@\n+  bool inline_vector_shuffle_to_vector();\n+  bool inline_vector_shuffle_iota();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4408,1 +4408,2 @@\n-            break; \/\/ Chain traversal fails.\n+            \/\/ Should not be allowed by SuperWord::mark_reductions\n+            return; \/\/ bail out of optimization\n@@ -4429,2 +4430,3 @@\n-        DEBUG_ONLY( current->dump(1); )\n-        assert(false, \"scalar_input is neither phi nor a matchin reduction\");\n+        \/\/ scalar_input is neither phi nor a matching reduction\n+        \/\/ Can for example be scalar reduction when we have\n+        \/\/ partial vectorization.\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -937,3 +937,3 @@\n-  const TypeFunc* tf()        const { return _tf; }\n-  const address entry_point() const { return _entry_point; }\n-  const float   cnt()         const { return _cnt; }\n+  const TypeFunc* tf()  const { return _tf; }\n+  address entry_point() const { return _entry_point; }\n+  float   cnt()         const { return _cnt; }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1353,1 +1353,1 @@\n-      alloc = AllocateArrayNode::Ideal_array_allocation(dest, &_igvn);\n+      alloc = AllocateArrayNode::Ideal_array_allocation(dest);\n@@ -1388,1 +1388,1 @@\n-    alloc = AllocateArrayNode::Ideal_array_allocation(dest, &_igvn);\n+    alloc = AllocateArrayNode::Ideal_array_allocation(dest);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -482,1 +482,1 @@\n-const int Matcher::scalable_predicate_reg_slots() {\n+int Matcher::scalable_predicate_reg_slots() {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -324,1 +324,1 @@\n-  static const bool has_match_rule(int opcode);\n+  static bool has_match_rule(int opcode);\n@@ -331,1 +331,1 @@\n-  static const bool match_rule_supported(int opcode);\n+  static bool match_rule_supported(int opcode);\n@@ -335,1 +335,1 @@\n-  static const bool match_rule_supported_superword(int opcode, int vlen, BasicType bt);\n+  static bool match_rule_supported_superword(int opcode, int vlen, BasicType bt);\n@@ -339,1 +339,1 @@\n-  static const bool match_rule_supported_vector(int opcode, int vlen, BasicType bt);\n+  static bool match_rule_supported_vector(int opcode, int vlen, BasicType bt);\n@@ -341,1 +341,1 @@\n-  static const bool match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt);\n+  static bool match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt);\n@@ -343,3 +343,1 @@\n-  static const bool vector_needs_partial_operations(Node* node, const TypeVect* vt);\n-\n-  static const bool vector_needs_load_shuffle(BasicType elem_bt, int vlen);\n+  static bool vector_needs_partial_operations(Node* node, const TypeVect* vt);\n@@ -351,1 +349,1 @@\n-  static const int vector_width_in_bytes(BasicType bt);\n+  static int vector_width_in_bytes(BasicType bt);\n@@ -354,3 +352,3 @@\n-  static const int max_vector_size(const BasicType bt);\n-  static const int min_vector_size(const BasicType bt);\n-  static const bool vector_size_supported(const BasicType bt, int size) {\n+  static int max_vector_size(const BasicType bt);\n+  static int min_vector_size(const BasicType bt);\n+  static bool vector_size_supported(const BasicType bt, int size) {\n@@ -361,1 +359,1 @@\n-  static const int superword_max_vector_size(const BasicType bt);\n+  static int superword_max_vector_size(const BasicType bt);\n@@ -364,1 +362,1 @@\n-  static const int scalable_vector_reg_size(const BasicType bt);\n+  static int scalable_vector_reg_size(const BasicType bt);\n@@ -366,1 +364,1 @@\n-  static const int scalable_predicate_reg_slots();\n+  static int scalable_predicate_reg_slots();\n@@ -369,1 +367,1 @@\n-  static const uint vector_ideal_reg(int len);\n+  static uint vector_ideal_reg(int len);\n@@ -456,1 +454,1 @@\n-  static const bool supports_vector_calling_convention();\n+  static bool supports_vector_calling_convention();\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -561,1 +561,1 @@\n-  ArrayCopyNode* ac = find_array_copy_clone(phase, ld_alloc, mem);\n+  ArrayCopyNode* ac = find_array_copy_clone(ld_alloc, mem);\n@@ -616,1 +616,1 @@\n-ArrayCopyNode* MemNode::find_array_copy_clone(PhaseValues* phase, Node* ld_alloc, Node* mem) const {\n+ArrayCopyNode* MemNode::find_array_copy_clone(Node* ld_alloc, Node* mem) const {\n@@ -637,1 +637,1 @@\n-        AllocateNode* alloc = AllocateNode::Ideal_allocation(ac->in(ArrayCopyNode::Dest), phase);\n+        AllocateNode* alloc = AllocateNode::Ideal_allocation(ac->in(ArrayCopyNode::Dest));\n@@ -665,1 +665,1 @@\n-  AllocateNode* alloc  = AllocateNode::Ideal_allocation(base, phase);\n+  AllocateNode* alloc  = AllocateNode::Ideal_allocation(base);\n@@ -713,1 +713,1 @@\n-                                  AllocateNode::Ideal_allocation(st_base, phase),\n+                                  AllocateNode::Ideal_allocation(st_base),\n@@ -1067,1 +1067,1 @@\n-  Node* ld_alloc = AllocateNode::Ideal_allocation(ld_base, phase);\n+  Node* ld_alloc = AllocateNode::Ideal_allocation(ld_base);\n@@ -1175,1 +1175,1 @@\n-        if (ReduceBulkZeroing || find_array_copy_clone(phase, ld_alloc, in(MemNode::Memory)) == nullptr) {\n+        if (ReduceBulkZeroing || find_array_copy_clone(ld_alloc, in(MemNode::Memory)) == nullptr) {\n@@ -1745,1 +1745,1 @@\n-AllocateNode* LoadNode::is_new_object_mark_load(PhaseGVN *phase) const {\n+AllocateNode* LoadNode::is_new_object_mark_load() const {\n@@ -1748,1 +1748,1 @@\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(address, phase);\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(address);\n@@ -2200,1 +2200,1 @@\n-  Node* alloc = is_new_object_mark_load(phase);\n+  Node* alloc = is_new_object_mark_load();\n@@ -2459,1 +2459,1 @@\n-      return tkls->is_aryklassptr()->elem();\n+      return tkls->is_aryklassptr()->elem()->isa_klassptr()->cast_to_exactness(tkls->klass_is_exact());\n@@ -2598,1 +2598,1 @@\n-    AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(base, phase);\n+    AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(base);\n@@ -2630,1 +2630,1 @@\n-    AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(base, phase);\n+    AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(base);\n@@ -3467,1 +3467,1 @@\n-      Node* alloc = AllocateNode::Ideal_allocation(in(MemBarNode::Precedent), phase);\n+      Node* alloc = AllocateNode::Ideal_allocation(in(MemBarNode::Precedent));\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  ArrayCopyNode* find_array_copy_clone(PhaseValues* phase, Node* ld_alloc, Node* mem) const;\n+  ArrayCopyNode* find_array_copy_clone(Node* ld_alloc, Node* mem) const;\n@@ -206,1 +206,1 @@\n-  AllocateNode* is_new_object_mark_load(PhaseGVN *phase) const;\n+  AllocateNode* is_new_object_mark_load() const;\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -921,1 +921,1 @@\n-            return new AndINode(lshift, phase->intcon(-(1 << con)));\n+            return new AndINode(lshift, phase->intcon(java_negate((jint)(1 << con))));\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1769,2 +1769,2 @@\n-  PrintBFS(const Node* start, const int max_distance, const Node* target, const char* options)\n-  : _start(start), _max_distance(max_distance), _target(target), _options(options),\n+  PrintBFS(const Node* start, const int max_distance, const Node* target, const char* options, outputStream* st)\n+  : _start(start), _max_distance(max_distance), _target(target), _options(options), _output(st),\n@@ -1790,0 +1790,1 @@\n+  outputStream* _output;\n@@ -1829,1 +1830,1 @@\n-  static void print_options_help(bool print_examples);\n+  void print_options_help(bool print_examples);\n@@ -1846,3 +1847,3 @@\n-  static void print_node_idx(const Node* n); \/\/ to tty\n-  static void print_block_id(const Block* b); \/\/ to tty\n-  static void print_node_block(const Node* n); \/\/ to tty: _pre_order, head idx, _idom, _dom_depth\n+  void print_node_idx(const Node* n);\n+  void print_block_id(const Block* b);\n+  void print_node_block(const Node* n); \/\/ _pre_order, head idx, _idom, _dom_depth\n@@ -1913,1 +1914,1 @@\n-    tty->print(\"dump_bfs: max_distance must be non-negative!\\n\");\n+    _output->print_cr(\"dump_bfs: max_distance must be non-negative!\");\n@@ -1951,1 +1952,1 @@\n-      tty->print(\"Could not find target in BFS.\\n\");\n+      _output->print_cr(\"Could not find target in BFS.\");\n@@ -2047,1 +2048,1 @@\n-    tty->print(\"No nodes to print.\\n\");\n+    _output->print_cr(\"No nodes to print.\");\n@@ -2052,57 +2053,57 @@\n-  tty->print(\"Usage: node->dump_bfs(int max_distance, Node* target, char* options)\\n\");\n-  tty->print(\"\\n\");\n-  tty->print(\"Use cases:\\n\");\n-  tty->print(\"  BFS traversal: no target required\\n\");\n-  tty->print(\"  shortest path: set target\\n\");\n-  tty->print(\"  all paths: set target and put 'A' in options\\n\");\n-  tty->print(\"  detect loop: subcase of all paths, have start==target\\n\");\n-  tty->print(\"\\n\");\n-  tty->print(\"Arguments:\\n\");\n-  tty->print(\"  this\/start: staring point of BFS\\n\");\n-  tty->print(\"  target:\\n\");\n-  tty->print(\"    if null: simple BFS\\n\");\n-  tty->print(\"    else: shortest path or all paths between this\/start and target\\n\");\n-  tty->print(\"  options:\\n\");\n-  tty->print(\"    if null: same as \\\"cdmox@B\\\"\\n\");\n-  tty->print(\"    else: use combination of following characters\\n\");\n-  tty->print(\"      h: display this help info\\n\");\n-  tty->print(\"      H: display this help info, with examples\\n\");\n-  tty->print(\"      +: traverse in-edges (on if neither + nor -)\\n\");\n-  tty->print(\"      -: traverse out-edges\\n\");\n-  tty->print(\"      c: visit control nodes\\n\");\n-  tty->print(\"      d: visit data nodes\\n\");\n-  tty->print(\"      m: visit memory nodes\\n\");\n-  tty->print(\"      o: visit other nodes\\n\");\n-  tty->print(\"      x: visit mixed nodes\\n\");\n-  tty->print(\"      C: boundary control nodes\\n\");\n-  tty->print(\"      D: boundary data nodes\\n\");\n-  tty->print(\"      M: boundary memory nodes\\n\");\n-  tty->print(\"      O: boundary other nodes\\n\");\n-  tty->print(\"      X: boundary mixed nodes\\n\");\n-  tty->print(\"      #: display node category in color (not supported in all terminals)\\n\");\n-  tty->print(\"      S: sort displayed nodes by node idx\\n\");\n-  tty->print(\"      A: all paths (not just shortest path to target)\\n\");\n-  tty->print(\"      @: print old nodes - before matching (if available)\\n\");\n-  tty->print(\"      B: print scheduling blocks (if available)\\n\");\n-  tty->print(\"      $: dump only, no header, no other columns\\n\");\n-  tty->print(\"\\n\");\n-  tty->print(\"recursively follow edges to nodes with permitted visit types,\\n\");\n-  tty->print(\"on the boundary additionally display nodes allowed in boundary types\\n\");\n-  tty->print(\"Note: the categories can be overlapping. For example a mixed node\\n\");\n-  tty->print(\"      can contain control and memory output. Some from the other\\n\");\n-  tty->print(\"      category are also control (Halt, Return, etc).\\n\");\n-  tty->print(\"\\n\");\n-  tty->print(\"output columns:\\n\");\n-  tty->print(\"  dist:  BFS distance to this\/start\\n\");\n-  tty->print(\"  apd:   all paths distance (d_start + d_target)\\n\");\n-  tty->print(\"  block: block identifier, based on _pre_order\\n\");\n-  tty->print(\"  head:  first node in block\\n\");\n-  tty->print(\"  idom:  head node of idom block\\n\");\n-  tty->print(\"  depth: depth of block (_dom_depth)\\n\");\n-  tty->print(\"  old:   old IR node - before matching\\n\");\n-  tty->print(\"  dump:  node->dump()\\n\");\n-  tty->print(\"\\n\");\n-  tty->print(\"Note: if none of the \\\"cmdxo\\\" characters are in the options string\\n\");\n-  tty->print(\"      then we set all of them.\\n\");\n-  tty->print(\"      This allows for short strings like \\\"#\\\" for colored input traversal\\n\");\n-  tty->print(\"      or \\\"-#\\\" for colored output traversal.\\n\");\n+  _output->print_cr(\"Usage: node->dump_bfs(int max_distance, Node* target, char* options)\");\n+  _output->print_cr(\"\");\n+  _output->print_cr(\"Use cases:\");\n+  _output->print_cr(\"  BFS traversal: no target required\");\n+  _output->print_cr(\"  shortest path: set target\");\n+  _output->print_cr(\"  all paths: set target and put 'A' in options\");\n+  _output->print_cr(\"  detect loop: subcase of all paths, have start==target\");\n+  _output->print_cr(\"\");\n+  _output->print_cr(\"Arguments:\");\n+  _output->print_cr(\"  this\/start: staring point of BFS\");\n+  _output->print_cr(\"  target:\");\n+  _output->print_cr(\"    if null: simple BFS\");\n+  _output->print_cr(\"    else: shortest path or all paths between this\/start and target\");\n+  _output->print_cr(\"  options:\");\n+  _output->print_cr(\"    if null: same as \\\"cdmox@B\\\"\");\n+  _output->print_cr(\"    else: use combination of following characters\");\n+  _output->print_cr(\"      h: display this help info\");\n+  _output->print_cr(\"      H: display this help info, with examples\");\n+  _output->print_cr(\"      +: traverse in-edges (on if neither + nor -)\");\n+  _output->print_cr(\"      -: traverse out-edges\");\n+  _output->print_cr(\"      c: visit control nodes\");\n+  _output->print_cr(\"      d: visit data nodes\");\n+  _output->print_cr(\"      m: visit memory nodes\");\n+  _output->print_cr(\"      o: visit other nodes\");\n+  _output->print_cr(\"      x: visit mixed nodes\");\n+  _output->print_cr(\"      C: boundary control nodes\");\n+  _output->print_cr(\"      D: boundary data nodes\");\n+  _output->print_cr(\"      M: boundary memory nodes\");\n+  _output->print_cr(\"      O: boundary other nodes\");\n+  _output->print_cr(\"      X: boundary mixed nodes\");\n+  _output->print_cr(\"      #: display node category in color (not supported in all terminals)\");\n+  _output->print_cr(\"      S: sort displayed nodes by node idx\");\n+  _output->print_cr(\"      A: all paths (not just shortest path to target)\");\n+  _output->print_cr(\"      @: print old nodes - before matching (if available)\");\n+  _output->print_cr(\"      B: print scheduling blocks (if available)\");\n+  _output->print_cr(\"      $: dump only, no header, no other columns\");\n+  _output->print_cr(\"\");\n+  _output->print_cr(\"recursively follow edges to nodes with permitted visit types,\");\n+  _output->print_cr(\"on the boundary additionally display nodes allowed in boundary types\");\n+  _output->print_cr(\"Note: the categories can be overlapping. For example a mixed node\");\n+  _output->print_cr(\"      can contain control and memory output. Some from the other\");\n+  _output->print_cr(\"      category are also control (Halt, Return, etc).\");\n+  _output->print_cr(\"\");\n+  _output->print_cr(\"output columns:\");\n+  _output->print_cr(\"  dist:  BFS distance to this\/start\");\n+  _output->print_cr(\"  apd:   all paths distance (d_outputart + d_target)\");\n+  _output->print_cr(\"  block: block identifier, based on _pre_order\");\n+  _output->print_cr(\"  head:  first node in block\");\n+  _output->print_cr(\"  idom:  head node of idom block\");\n+  _output->print_cr(\"  depth: depth of block (_dom_depth)\");\n+  _output->print_cr(\"  old:   old IR node - before matching\");\n+  _output->print_cr(\"  dump:  node->dump()\");\n+  _output->print_cr(\"\");\n+  _output->print_cr(\"Note: if none of the \\\"cmdxo\\\" characters are in the options string\");\n+  _output->print_cr(\"      then we set all of them.\");\n+  _output->print_cr(\"      This allows for short strings like \\\"#\\\" for colored input traversal\");\n+  _output->print_cr(\"      or \\\"-#\\\" for colored output traversal.\");\n@@ -2110,27 +2111,27 @@\n-    tty->print(\"\\n\");\n-    tty->print(\"Examples:\\n\");\n-    tty->print(\"  if->dump_bfs(10, 0, \\\"+cxo\\\")\\n\");\n-    tty->print(\"    starting at some if node, traverse inputs recursively\\n\");\n-    tty->print(\"    only along control (mixed and other can also be control)\\n\");\n-    tty->print(\"  phi->dump_bfs(5, 0, \\\"-dxo\\\")\\n\");\n-    tty->print(\"    starting at phi node, traverse outputs recursively\\n\");\n-    tty->print(\"    only along data (mixed and other can also have data flow)\\n\");\n-    tty->print(\"  find_node(385)->dump_bfs(3, 0, \\\"cdmox+#@B\\\")\\n\");\n-    tty->print(\"    find inputs of node 385, up to 3 nodes up (+)\\n\");\n-    tty->print(\"    traverse all nodes (cdmox), use colors (#)\\n\");\n-    tty->print(\"    display old nodes and blocks, if they exist\\n\");\n-    tty->print(\"    useful call to start with\\n\");\n-    tty->print(\"  find_node(102)->dump_bfs(10, 0, \\\"dCDMOX-\\\")\\n\");\n-    tty->print(\"    find non-data dependencies of a data node\\n\");\n-    tty->print(\"    follow data node outputs until we find another category\\n\");\n-    tty->print(\"    node as the boundary\\n\");\n-    tty->print(\"  x->dump_bfs(10, y, 0)\\n\");\n-    tty->print(\"    find shortest path from x to y, along any edge or node\\n\");\n-    tty->print(\"    will not find a path if it is longer than 10\\n\");\n-    tty->print(\"    useful to find how x and y are related\\n\");\n-    tty->print(\"  find_node(741)->dump_bfs(20, find_node(746), \\\"c+\\\")\\n\");\n-    tty->print(\"    find shortest control path between two nodes\\n\");\n-    tty->print(\"  find_node(741)->dump_bfs(8, find_node(746), \\\"cdmox+A\\\")\\n\");\n-    tty->print(\"    find all paths (A) between two nodes of length at most 8\\n\");\n-    tty->print(\"  find_node(741)->dump_bfs(7, find_node(741), \\\"c+A\\\")\\n\");\n-    tty->print(\"    find all control loops for this node\\n\");\n+    _output->print_cr(\"\");\n+    _output->print_cr(\"Examples:\");\n+    _output->print_cr(\"  if->dump_bfs(10, 0, \\\"+cxo\\\")\");\n+    _output->print_cr(\"    starting at some if node, traverse inputs recursively\");\n+    _output->print_cr(\"    only along control (mixed and other can also be control)\");\n+    _output->print_cr(\"  phi->dump_bfs(5, 0, \\\"-dxo\\\")\");\n+    _output->print_cr(\"    starting at phi node, traverse outputs recursively\");\n+    _output->print_cr(\"    only along data (mixed and other can also have data flow)\");\n+    _output->print_cr(\"  find_node(385)->dump_bfs(3, 0, \\\"cdmox+#@B\\\")\");\n+    _output->print_cr(\"    find inputs of node 385, up to 3 nodes up (+)\");\n+    _output->print_cr(\"    traverse all nodes (cdmox), use colors (#)\");\n+    _output->print_cr(\"    display old nodes and blocks, if they exist\");\n+    _output->print_cr(\"    useful call to start with\");\n+    _output->print_cr(\"  find_node(102)->dump_bfs(10, 0, \\\"dCDMOX-\\\")\");\n+    _output->print_cr(\"    find non-data dependencies of a data node\");\n+    _output->print_cr(\"    follow data node outputs until we find another category\");\n+    _output->print_cr(\"    node as the boundary\");\n+    _output->print_cr(\"  x->dump_bfs(10, y, 0)\");\n+    _output->print_cr(\"    find shortest path from x to y, along any edge or node\");\n+    _output->print_cr(\"    will not find a path if it is longer than 10\");\n+    _output->print_cr(\"    useful to find how x and y are related\");\n+    _output->print_cr(\"  find_node(741)->dump_bfs(20, find_node(746), \\\"c+\\\")\");\n+    _output->print_cr(\"    find shortest control path between two nodes\");\n+    _output->print_cr(\"  find_node(741)->dump_bfs(8, find_node(746), \\\"cdmox+A\\\")\");\n+    _output->print_cr(\"    find all paths (A) between two nodes of length at most 8\");\n+    _output->print_cr(\"  find_node(741)->dump_bfs(7, find_node(741), \\\"c+A\\\")\");\n+    _output->print_cr(\"    find all control loops for this node\");\n@@ -2208,2 +2209,2 @@\n-        tty->print_cr(\"dump_bfs: Unrecognized option \\'%c\\'\", _options[i]);\n-        tty->print_cr(\"for help, run: find_node(0)->dump_bfs(0,0,\\\"H\\\")\");\n+        _output->print_cr(\"dump_bfs: Unrecognized option \\'%c\\'\", _options[i]);\n+        _output->print_cr(\"for help, run: find_node(0)->dump_bfs(0,0,\\\"H\\\")\");\n@@ -2288,1 +2289,1 @@\n-  tty->print(\"%6s\", buf);\n+  _output->print(\"%6s\", buf);\n@@ -2295,1 +2296,1 @@\n-  tty->print(\"%7s\", buf);\n+  _output->print(\"%7s\", buf);\n@@ -2304,4 +2305,4 @@\n-    tty->print(\"      _\"); \/\/ Block\n-    tty->print(\"     _\");  \/\/ head\n-    tty->print(\"     _\");  \/\/ idom\n-    tty->print(\"      _\"); \/\/ depth\n+    _output->print(\"      _\"); \/\/ Block\n+    _output->print(\"     _\");  \/\/ head\n+    _output->print(\"     _\");  \/\/ idom\n+    _output->print(\"      _\"); \/\/ depth\n@@ -2314,1 +2315,1 @@\n-      tty->print(\"     _\"); \/\/ idom\n+      _output->print(\"     _\"); \/\/ idom\n@@ -2316,1 +2317,1 @@\n-    tty->print(\"%6d \", b->_dom_depth);\n+    _output->print(\"%6d \", b->_dom_depth);\n@@ -2346,1 +2347,1 @@\n-  tty->print(\"dist\");                         \/\/ distance\n+  _output->print(\"dist\");                         \/\/ distance\n@@ -2348,1 +2349,1 @@\n-    tty->print(\" apd\");                       \/\/ all paths distance\n+    _output->print(\" apd\");                       \/\/ all paths distance\n@@ -2351,1 +2352,1 @@\n-    tty->print(\" [block  head  idom depth]\"); \/\/ block\n+    _output->print(\" [block  head  idom depth]\"); \/\/ block\n@@ -2354,1 +2355,1 @@\n-    tty->print(\"   old\");                     \/\/ old node\n+    _output->print(\"   old\");                     \/\/ old node\n@@ -2356,2 +2357,2 @@\n-  tty->print(\" dump\\n\");                      \/\/ node dump\n-  tty->print(\"---------------------------------------------\\n\");\n+  _output->print(\" dump\\n\");                      \/\/ node dump\n+  _output->print_cr(\"---------------------------------------------\");\n@@ -2362,1 +2363,1 @@\n-    n->dump(\"\\n\", false, tty, &_dcc);\n+    n->dump(\"\\n\", false, _output, &_dcc);\n@@ -2365,1 +2366,1 @@\n-  tty->print(\"%4d\", find_info(n)->distance());\/\/ distance\n+  _output->print(\"%4d\", find_info(n)->distance());\/\/ distance\n@@ -2369,1 +2370,1 @@\n-    tty->print(\"%4d\", apd);                   \/\/ all paths distance\n+    _output->print(\"%4d\", apd);                   \/\/ all paths distance\n@@ -2372,1 +2373,1 @@\n-    print_node_block(n);                      \/\/ block\n+    print_node_block(n);                          \/\/ block\n@@ -2375,1 +2376,1 @@\n-    print_node_idx(old_node(n));              \/\/ old node\n+    print_node_idx(old_node(n));                  \/\/ old node\n@@ -2377,2 +2378,2 @@\n-  tty->print(\" \");\n-  n->dump(\"\\n\", false, tty, &_dcc);           \/\/ node dump\n+  _output->print(\" \");\n+  n->dump(\"\\n\", false, _output, &_dcc);           \/\/ node dump\n@@ -2388,1 +2389,6 @@\n-  PrintBFS bfs(this, max_distance, target, options);\n+  dump_bfs(max_distance, target, options, tty);\n+}\n+\n+\/\/ Used to dump to stream.\n+void Node::dump_bfs(const int max_distance, Node* target, const char* options, outputStream* st) const {\n+  PrintBFS bfs(this, max_distance, target, options, st);\n@@ -2532,1 +2538,1 @@\n-    C->clone_map().dump(_idx);\n+    C->clone_map().dump(_idx, st);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":124,"deletions":118,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -841,1 +841,1 @@\n-  const juint class_id() const { return _class_id; }\n+  juint class_id() const { return _class_id; }\n@@ -843,1 +843,1 @@\n-  const juint flags() const { return _flags; }\n+  juint flags() const { return _flags; }\n@@ -1232,1 +1232,2 @@\n-  void dump_bfs(const int max_distance, Node* target, const char* options) const; \/\/ Print BFS traversal\n+  void dump_bfs(const int max_distance, Node* target, const char* options, outputStream* st) const;\n+  void dump_bfs(const int max_distance, Node* target, const char* options) const; \/\/ directly to tty\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2139,2 +2139,6 @@\n-    tty->print(\"\\n---- After ScheduleAndBundle ----\\n\");\n-    print_scheduling();\n+    \/\/ Buffer and print all at once\n+    ResourceMark rm;\n+    stringStream ss;\n+    ss.print(\"\\n---- After ScheduleAndBundle ----\\n\");\n+    print_scheduling(&ss);\n+    tty->print(\"%s\", ss.as_string());\n@@ -2148,0 +2152,4 @@\n+  print_scheduling(tty);\n+}\n+\n+void PhaseOutput::print_scheduling(outputStream* output_stream) {\n@@ -2149,1 +2157,1 @@\n-    tty->print(\"\\nBB#%03d:\\n\", i);\n+    output_stream->print(\"\\nBB#%03d:\\n\", i);\n@@ -2154,2 +2162,2 @@\n-      tty->print(\" %-6s \", reg >= 0 && reg < REG_COUNT ? Matcher::regName[reg] : \"\");\n-      n->dump();\n+      output_stream->print(\" %-6s \", reg >= 0 && reg < REG_COUNT ? Matcher::regName[reg] : \"\");\n+      n->dump(\"\\n\", false, output_stream);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1085,1 +1085,1 @@\n-      AllocateNode *alloc = AllocateNode::Ideal_allocation(alloc_with_final(), &_gvn);\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_with_final());\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-      if (AllocateNode::Ideal_allocation(obj, &_gvn) != nullptr) {\n+      if (AllocateNode::Ideal_allocation(obj) != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1684,1 +1684,1 @@\n-  AllocateArrayNode* byte_alloc = AllocateArrayNode::Ideal_array_allocation(byte_array, _gvn);\n+  AllocateArrayNode* byte_alloc = AllocateArrayNode::Ideal_array_allocation(byte_array);\n@@ -2012,1 +2012,1 @@\n-    assert(AllocateNode::Ideal_allocation(result, _gvn) != nullptr, \"should be newly allocated\");\n+    assert(AllocateNode::Ideal_allocation(result) != nullptr, \"should be newly allocated\");\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1024,2 +1024,2 @@\n-      AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, nullptr);\n-      AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, nullptr);\n+      AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1);\n+      AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2);\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5573,1 +5573,1 @@\n-const int TypeAryPtr::flattened_offset() const {\n+int TypeAryPtr::flattened_offset() const {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1038,2 +1038,2 @@\n-  const int offset() const { return _offset.get(); }\n-  const PTR ptr()    const { return _ptr; }\n+  int offset() const { return _offset.get(); }\n+  PTR ptr()    const { return _ptr; }\n@@ -1053,1 +1053,1 @@\n-  virtual const int flattened_offset() const { return offset(); }\n+  virtual int flattened_offset() const { return offset(); }\n@@ -1565,1 +1565,1 @@\n-  const int flattened_offset() const;\n+  int flattened_offset() const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+static bool is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n+\n@@ -462,0 +467,2 @@\n+    } else if (is_vector_shuffle(from_kls)) {\n+      bt = T_BYTE;\n@@ -506,0 +513,3 @@\n+    } else if (is_vector_shuffle(from_kls) && !vec_unbox->is_shuffle_to_vector()) {\n+      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n+      vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  write_u2(java_fields);\n+  write_u2(checked_cast<u2>(java_fields));\n@@ -71,3 +71,3 @@\n-    int name_index = fs.name_index();\n-    int signature_index = fs.signature_index();\n-    int initial_value_index = fs.initval_index();\n+    u2 name_index = fs.name_index();\n+    u2 signature_index = fs.signature_index();\n+    u2 initial_value_index = fs.initval_index();\n@@ -76,1 +76,1 @@\n-    int generic_signature_index = fs.generic_signature_index();\n+    u2 generic_signature_index = fs.generic_signature_index();\n@@ -88,1 +88,1 @@\n-    write_u2(access_flags.as_int() & JVM_RECOGNIZED_FIELD_MODIFIERS);\n+    write_u2(access_flags.get_flags() & JVM_RECOGNIZED_FIELD_MODIFIERS);\n@@ -91,1 +91,1 @@\n-    int attr_count = 0;\n+    u2 attr_count = 0;\n@@ -151,2 +151,2 @@\n-  int local_variable_table_length = 0;\n-  int local_variable_type_table_length = 0;\n+  u2 local_variable_table_length = 0;\n+  u2 local_variable_type_table_length = 0;\n@@ -155,1 +155,1 @@\n-  int attr_count = 0;\n+  u2 attr_count = 0;\n@@ -233,1 +233,1 @@\n-  int exception_table_length = exception_table.length();\n+  u2 exception_table_length = exception_table.length();\n@@ -280,1 +280,1 @@\n-  int checked_exceptions_length = const_method->checked_exceptions_length();\n+  u2 checked_exceptions_length = const_method->checked_exceptions_length();\n@@ -311,1 +311,1 @@\n-  write_u1(length);\n+  write_u1((u1)length);\n@@ -365,1 +365,1 @@\n-  return iter.length();\n+  return checked_cast<u2>(iter.length());\n@@ -398,1 +398,1 @@\n-  int length = sizeof(u2); \/\/ num_bootstrap_methods\n+  u4 length = sizeof(u2); \/\/ num_bootstrap_methods\n@@ -403,1 +403,1 @@\n-    length += sizeof(u2) * num_bootstrap_arguments; \/\/ bootstrap_arguments[num_bootstrap_arguments]\n+    length += (u4)sizeof(u2) * num_bootstrap_arguments; \/\/ bootstrap_arguments[num_bootstrap_arguments]\n@@ -408,1 +408,1 @@\n-  write_u2(num_bootstrap_methods);\n+  write_u2(checked_cast<u2>(num_bootstrap_methods));\n@@ -428,1 +428,1 @@\n-  int host_class_index = ik()->nest_host_index();\n+  u2 host_class_index = ik()->nest_host_index();\n@@ -448,1 +448,1 @@\n-  write_u2(number_of_classes);\n+  write_u2(checked_cast<u2>(number_of_classes));\n@@ -468,1 +468,1 @@\n-  write_u2(number_of_classes);\n+  write_u2(checked_cast<u2>(number_of_classes));\n@@ -492,1 +492,1 @@\n-  int length = sizeof(u2) + (sizeof(u2) * 3 * number_of_components);\n+  u4 length = checked_cast<u4>(sizeof(u2) + (sizeof(u2) * 3 * number_of_components));\n@@ -509,1 +509,1 @@\n-  write_u2(number_of_components);\n+  write_u2(checked_cast<u2>(number_of_components));\n@@ -542,1 +542,1 @@\n-  u2 entry_count = length \/ InstanceKlass::inner_class_next_offset;\n+  u2 entry_count = checked_cast<u2>(length \/ InstanceKlass::inner_class_next_offset);\n@@ -596,2 +596,2 @@\n-    write_u2(stream.bci());\n-    write_u2(stream.line());\n+    write_u2(checked_cast<u2>(stream.bci()));\n+    write_u2(checked_cast<u2>(stream.line()));\n@@ -740,1 +740,1 @@\n-  write_u2(attr_count);\n+  write_u2(checked_cast<u2>(attr_count));\n@@ -780,1 +780,1 @@\n-  int attr_count = 0;\n+  u2 attr_count = 0;\n@@ -871,1 +871,1 @@\n-  write_u2(num_methods - num_overpass);\n+  write_u2(checked_cast<u2>(num_methods - num_overpass));\n@@ -915,1 +915,1 @@\n-  write_u2(cpool()->length());\n+  write_u2(checked_cast<u2>(cpool()->length()));\n@@ -931,2 +931,1 @@\n-  write_u2(num_interfaces);\n-\n+  write_u2(checked_cast<u2>(num_interfaces));\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":30,"deletions":31,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -578,1 +578,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(event_thread);\n+  JvmtiVTMSTransitionDisabler disabler;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -913,1 +913,1 @@\n-    _curr_len = *end_ptr - *data_ptr;\n+    _curr_len = pointer_delta_as_int(*end_ptr, *data_ptr);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-int VM_RedefineClasses::find_or_append_indirect_entry(const constantPoolHandle& scratch_cp,\n+u2 VM_RedefineClasses::find_or_append_indirect_entry(const constantPoolHandle& scratch_cp,\n@@ -649,1 +649,3 @@\n-  return new_ref_i;\n+  \/\/ constant pool indices are u2, unless the merged constant pool overflows which\n+  \/\/ we don't check for.\n+  return checked_cast<u2>(new_ref_i);\n@@ -659,3 +661,3 @@\n-  int old_ref_i = scratch_cp->operand_bootstrap_method_ref_index_at(old_bs_i);\n-  int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,\n-                                                merge_cp_length_p);\n+  u2 old_ref_i = scratch_cp->operand_bootstrap_method_ref_index_at(old_bs_i);\n+  u2 new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,\n+                                               merge_cp_length_p);\n@@ -673,1 +675,1 @@\n-  int argc     = scratch_cp->operand_argument_count_at(old_bs_i);\n+  u2 argc      = scratch_cp->operand_argument_count_at(old_bs_i);\n@@ -680,3 +682,3 @@\n-    int old_arg_ref_i = scratch_cp->operand_argument_index_at(old_bs_i, i);\n-    int new_arg_ref_i = find_or_append_indirect_entry(scratch_cp, old_arg_ref_i, merge_cp_p,\n-                                                      merge_cp_length_p);\n+    u2 old_arg_ref_i = scratch_cp->operand_argument_index_at(old_bs_i, i);\n+    u2 new_arg_ref_i = find_or_append_indirect_entry(scratch_cp, old_arg_ref_i, merge_cp_p,\n+                                                     merge_cp_length_p);\n@@ -1254,1 +1256,1 @@\n-int VM_RedefineClasses::find_new_index(int old_index) {\n+u2 VM_RedefineClasses::find_new_index(int old_index) {\n@@ -1273,1 +1275,3 @@\n-  return value;\n+  \/\/ constant pool indices are u2, unless the merged constant pool overflows which\n+  \/\/ we don't check for.\n+  return checked_cast<u2>(value);\n@@ -2227,2 +2231,2 @@\n-        int cp_index = *(bcp + 1);\n-        int new_index = find_new_index(cp_index);\n+        u1 cp_index = *(bcp + 1);\n+        u2 new_index = find_new_index(cp_index);\n@@ -2242,1 +2246,2 @@\n-            *(bcp + 1) = new_index;\n+            \/\/ We checked that new_index fits in a u1 so this cast is safe\n+            *(bcp + 1) = (u1)new_index;\n@@ -2303,1 +2308,1 @@\n-        int new_index = find_new_index(cp_index);\n+        u2 new_index = find_new_index(cp_index);\n@@ -3641,1 +3646,1 @@\n-    int new_index = find_new_index(cur_index);\n+    u2 new_index = find_new_index(cur_index);\n@@ -3667,1 +3672,1 @@\n-    int new_index = find_new_index(method->name_index());\n+    u2 new_index = find_new_index(method->name_index());\n@@ -3712,1 +3717,1 @@\n-      int new_index = find_new_index(cur_index);\n+      u2 new_index = find_new_index(cur_index);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":23,"deletions":18,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -435,1 +435,1 @@\n-  int find_or_append_indirect_entry(const constantPoolHandle& scratch_cp, int scratch_i,\n+  u2 find_or_append_indirect_entry(const constantPoolHandle& scratch_cp, int scratch_i,\n@@ -439,1 +439,1 @@\n-  int find_new_index(int old_index);\n+  u2 find_new_index(int old_index);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1060,1 +1060,1 @@\n-      assert(loc != nullptr, \"missing register map entry reg: \" INTPTR_FORMAT \" %s loc: \" INTPTR_FORMAT, reg->value(), reg->name(), p2i(loc));\n+      assert(loc != nullptr, \"missing register map entry reg: %d %s loc: \" INTPTR_FORMAT, reg->value(), reg->name(), p2i(loc));\n@@ -1485,1 +1485,1 @@\n-          assert(((int)fst->reg2stack()) >= 0, \"reg2stack: \" INTPTR_FORMAT, fst->reg2stack());\n+          assert(((int)fst->reg2stack()) >= 0, \"reg2stack: %d\", fst->reg2stack());\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -518,1 +518,1 @@\n-    return a->location - b->location;\n+    return checked_cast<int>(a->location - b->location);\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1260,1 +1260,1 @@\n-          constraint(AllocatePrefetchDistanceConstraintFunc,AfterMemoryInit)\\\n+          range(-1, 512)                                                    \\\n@@ -1608,0 +1608,3 @@\n+  develop(intx, TraceBytecodesStopAt, 0,                                    \\\n+          \"Stop bytecode tracing at the specified bytecode number\")         \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-    return (intptr_t)result;\n+    return result;\n","filename":"src\/hotspot\/share\/runtime\/jfieldIDWorkaround.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2075,1 +2075,1 @@\n-    assert(a->value() == b->value(), \"register allocation mismatch: a=\" INTX_FORMAT \", b=\" INTX_FORMAT, a->value(), b->value());\n+    assert(a->value() == b->value(), \"register allocation mismatch: a= %d, b= %d\", a->value(), b->value());\n@@ -2730,1 +2730,1 @@\n-ResourceHashtable<AdapterFingerPrint*, AdapterHandlerEntry*, 293,\n+using AdapterHandlerTable = ResourceHashtable<AdapterFingerPrint*, AdapterHandlerEntry*, 293,\n@@ -2733,1 +2733,2 @@\n-                  AdapterFingerPrint::equals> _adapter_handler_table;\n+                  AdapterFingerPrint::equals>;\n+static AdapterHandlerTable* _adapter_handler_table;\n@@ -2740,1 +2741,1 @@\n-  AdapterHandlerEntry** entry = _adapter_handler_table.get(&fp);\n+  AdapterHandlerEntry** entry = _adapter_handler_table->get(&fp);\n@@ -2756,1 +2757,1 @@\n-  TableStatistics ts = _adapter_handler_table.statistics_calculate(size);\n+  TableStatistics ts = _adapter_handler_table->statistics_calculate(size);\n@@ -2759,1 +2760,1 @@\n-                _adapter_handler_table.table_size(), _adapter_handler_table.number_of_entries());\n+                _adapter_handler_table->table_size(), _adapter_handler_table->number_of_entries());\n@@ -2807,0 +2808,1 @@\n+    _adapter_handler_table = new (mtCode) AdapterHandlerTable();\n@@ -3295,1 +3297,1 @@\n-                  _adapter_handler_table.number_of_entries(), fingerprint->as_basic_args_string(),\n+                  _adapter_handler_table->number_of_entries(), fingerprint->as_basic_args_string(),\n@@ -3313,1 +3315,1 @@\n-    _adapter_handler_table.put(fingerprint, entry);\n+    _adapter_handler_table->put(fingerprint, entry);\n@@ -3668,1 +3670,1 @@\n-  _adapter_handler_table.iterate(findblob);\n+  _adapter_handler_table->iterate(findblob);\n@@ -3685,1 +3687,1 @@\n-  _adapter_handler_table.iterate(findblob);\n+  _adapter_handler_table->iterate(findblob);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -246,2 +246,0 @@\n-const int WordsPerLong       = 2;       \/\/ Number of stack entries for longs\n-\n@@ -442,1 +440,0 @@\n-\n@@ -450,17 +447,0 @@\n-typedef uintptr_t     address_word; \/\/ unsigned integer which will hold a pointer\n-                                    \/\/ except for some implementations of a C++\n-                                    \/\/ linkage pointer to function. Should never\n-                                    \/\/ need one of those to be placed in this\n-                                    \/\/ type anyway.\n-\n-\/\/  Utility functions to \"portably\" (?) bit twiddle pointers\n-\/\/  Where portable means keep ANSI C++ compilers quiet\n-\n-inline address       set_address_bits(address x, int m)       { return address(intptr_t(x) | m); }\n-inline address       clear_address_bits(address x, int m)     { return address(intptr_t(x) & ~m); }\n-\n-\/\/  Utility functions to \"portably\" make cast to\/from function pointers.\n-\n-inline address_word  mask_address_bits(address x, int m)      { return address_word(x) & m; }\n-inline address_word  castable_address(address x)              { return address_word(x) ; }\n-inline address_word  castable_address(void* x)                { return address_word(x) ; }\n@@ -509,1 +489,1 @@\n-#define CAST_FROM_FN_PTR(new_type, func_ptr) ((new_type)((address_word)(func_ptr)))\n+#define CAST_FROM_FN_PTR(new_type, func_ptr) ((new_type)((uintptr_t)(func_ptr)))\n@@ -520,1 +500,1 @@\n-T2 checked_cast(T1 thing) {\n+constexpr T2 checked_cast(T1 thing) {\n@@ -526,0 +506,8 @@\n+\/\/ pointer_delta_as_int is called to do pointer subtraction for nearby pointers that\n+\/\/ returns a non-negative int, usually used as a size of a code buffer range.\n+\/\/ This scales to sizeof(T).\n+template <typename T>\n+inline int pointer_delta_as_int(const volatile T* left, const volatile T* right) {\n+  return checked_cast<int>(pointer_delta(left, right, sizeof(T)));\n+}\n+\n@@ -676,1 +664,1 @@\n-  return denominator != 0 ? (double)numerator \/ denominator * 100.0 : 0.0;\n+  return denominator != 0 ? (double)numerator \/ (double)denominator * 100.0 : 0.0;\n@@ -727,1 +715,1 @@\n-enum BasicType {\n+enum BasicType : u1 {\n@@ -1094,1 +1082,1 @@\n-#define TASKQUEUE_SIZE (NOT_LP64(1<<14) LP64_ONLY(1<<17))\n+const size_t TASKQUEUE_SIZE = (NOT_LP64(1<<14) LP64_ONLY(1<<17));\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n- * not a <a href=\"ClassLoader.html#binary-name\">binary name<\/a>,\n+ * not a {@linkplain ClassLoader##binary-name binary name},\n@@ -401,1 +401,1 @@\n-     * runtime {@code Class} descriptor for the class named\n+     * runtime {@code Class} object for the class named\n@@ -416,3 +416,4 @@\n-     * @param      className   the fully qualified name of the desired class.\n-     * @return     the {@code Class} object for the class with the\n-     *             specified name.\n+     * @param     className the {@linkplain ClassLoader##binary-name binary name}\n+     *                      of the class or the string representing an array type\n+     * @return    the {@code Class} object for the class with the\n+     *            specified name.\n@@ -447,5 +448,4 @@\n-     * Given the fully qualified name for a class or interface (in the same\n-     * format returned by {@code getName}) this method attempts to\n-     * locate and load the class or interface.  The specified class\n-     * loader is used to load the class or interface.  If the parameter\n-     * {@code loader} is null, the class is loaded through the bootstrap\n+     * Given the {@linkplain ClassLoader##binary-name binary name} for a class or interface,\n+     * this method attempts to locate and load the class or interface. The specified\n+     * class loader is used to load the class or interface.  If the parameter\n+     * {@code loader} is {@code null}, the class is loaded through the bootstrap\n@@ -456,5 +456,6 @@\n-     * <p> If {@code name} denotes a primitive type or void, an attempt\n-     * will be made to locate a user-defined class in the unnamed package whose\n-     * name is {@code name}. Therefore, this method cannot be used to\n-     * obtain any of the {@code Class} objects representing primitive\n-     * types or void.\n+     * <p> This method cannot be used to obtain any of the {@code Class} objects\n+     * representing primitive types or void, hidden classes or interfaces,\n+     * or array classes whose element type is a hidden class or interface.\n+     * If {@code name} denotes a primitive type or void, for example {@code I},\n+     * an attempt will be made to locate a user-defined class in the unnamed package\n+     * whose name is {@code I} instead.\n@@ -462,4 +463,4 @@\n-     * <p> If {@code name} denotes an array class, the component type of\n-     * the array class is loaded but not initialized.\n-     *\n-     * <p> For example, in an instance method the expression:\n+     * <p> To obtain the {@code Class} object associated with an array class,\n+     * the name consists of one or more {@code '['} representing the depth\n+     * of the array nesting, followed by the element type as encoded in\n+     * {@linkplain ##nameFormat the table} specified in {@code Class.getName()}.\n@@ -467,0 +468,1 @@\n+     * <p> Examples:\n@@ -468,1 +470,5 @@\n-     * Class.forName(\"Foo\")\n+     * Class<?> threadClass = Class.forName(\"java.lang.Thread\", false, currentLoader);\n+     * Class<?> stringArrayClass = Class.forName(\"[Ljava.lang.String;\", false, currentLoader);\n+     * Class<?> intArrayClass = Class.forName(\"[[[I\", false, currentLoader);   \/\/ Class of int[][][]\n+     * Class<?> nestedClass = Class.forName(\"java.lang.Character$UnicodeBlock\", false, currentLoader);\n+     * Class<?> fooClass = Class.forName(\"Foo\", true, currentLoader);\n@@ -471,1 +477,2 @@\n-     * is equivalent to:\n+     * <p> A call to {@code getName()} on the {@code Class} object returned\n+     * from {@code forName(}<i>N<\/i>{@code )} returns <i>N<\/i>.\n@@ -473,3 +480,3 @@\n-     * {@snippet lang=\"java\" :\n-     * Class.forName(\"Foo\", true, this.getClass().getClassLoader())\n-     * }\n+     * <p> A call to {@code forName(\"[L}<i>N<\/i>{@code ;\")} causes the element type\n+     * named <i>N<\/i> to be loaded but not initialized regardless of the value\n+     * of the {@code initialize} parameter.\n@@ -477,5 +484,5 @@\n-     * Note that this method throws errors related to loading, linking\n-     * or initializing as specified in Sections {@jls 12.2}, {@jls\n-     * 12.3}, and {@jls 12.4} of <cite>The Java Language\n-     * Specification<\/cite>.\n-     * Note that this method does not check whether the requested class\n+     * @apiNote\n+     * This method throws errors related to loading, linking or initializing\n+     * as specified in Sections {@jls 12.2}, {@jls 12.3}, and {@jls 12.4} of\n+     * <cite>The Java Language Specification<\/cite>.\n+     * In addition, this method does not check whether the requested class\n@@ -484,2 +491,3 @@\n-     * @param name       fully qualified name of the desired class\n-\n+     * @param name       the {@linkplain ClassLoader##binary-name binary name}\n+     *                   of the class or the string representing an array class\n+     *\n@@ -510,0 +518,1 @@\n+     * @jls 13.1 The Form of a Binary\n@@ -557,2 +566,2 @@\n-     * Returns the {@code Class} with the given <a href=\"ClassLoader.html#binary-name\">\n-     * binary name<\/a> in the given module.\n+     * Returns the {@code Class} with the given {@linkplain ClassLoader##binary-name\n+     * binary name} in the given module.\n@@ -572,1 +581,3 @@\n-     * This method returns {@code null} on failure rather than\n+     * This method does not support loading of array types, unlike\n+     * {@link #forName(String, boolean, ClassLoader)}. The class name must be\n+     * a binary name.  This method returns {@code null} on failure rather than\n@@ -579,1 +590,1 @@\n-     * @param  name     The <a href=\"ClassLoader.html#binary-name\">binary name<\/a>\n+     * @param  name     The {@linkplain ClassLoader##binary-name binary name}\n@@ -969,2 +980,10 @@\n-     * Determines if the specified {@code Class} object represents a\n-     * primitive type.\n+     * Determines if this {@code Class} object represents a primitive\n+     * type or void.\n+     *\n+     * <p> There are nine predefined {@code Class} objects to\n+     * represent the eight primitive types and void.  These are\n+     * created by the Java Virtual Machine, and have the same\n+     * {@linkplain #getName() names} as the primitive types that they\n+     * represent, namely {@code boolean}, {@code byte}, {@code char},\n+     * {@code short}, {@code int}, {@code long}, {@code float}, and\n+     * {@code double}.\n@@ -972,6 +991,1 @@\n-     * <p> There are nine predefined {@code Class} objects to represent\n-     * the eight primitive types and void.  These are created by the Java\n-     * Virtual Machine, and have the same names as the primitive types that\n-     * they represent, namely {@code boolean}, {@code byte},\n-     * {@code char}, {@code short}, {@code int},\n-     * {@code long}, {@code float}, and {@code double}.\n+     * <p>No other class objects are considered primitive.\n@@ -979,3 +993,9 @@\n-     * <p> These objects may only be accessed via the following public static\n-     * final variables, and are the only {@code Class} objects for which\n-     * this method returns {@code true}.\n+     * @apiNote\n+     * A {@code Class} object represented by a primitive type can be\n+     * accessed via the {@code TYPE} public static final variables\n+     * defined in the primitive wrapper classes such as {@link\n+     * java.lang.Integer#TYPE Integer.TYPE}. In the Java programming\n+     * language, the objects may be referred to by a class literal\n+     * expression such as {@code int.class}.  The {@code Class} object\n+     * for void can be expressed as {@code void.class} or {@link\n+     * java.lang.Void#TYPE Void.TYPE}.\n@@ -995,0 +1015,1 @@\n+     * @jls 15.8.2 Class Literals\n@@ -1035,1 +1056,1 @@\n-     *      then the <a href=\"ClassLoader.html#binary-name\">binary name<\/a>\n+     *      then the {@linkplain ClassLoader##binary-name binary name}\n@@ -1039,1 +1060,1 @@\n-     *      where {@code N} is the <a href=\"ClassLoader.html#binary-name\">binary name<\/a>\n+     *      where {@code N} is the {@linkplain ClassLoader##binary-name binary name}\n@@ -1050,1 +1071,1 @@\n-     * <blockquote><table class=\"striped\">\n+     * <blockquote><table class=\"striped\" id=\"nameFormat\">\n@@ -1059,1 +1080,1 @@\n-     * <tr><th scope=\"row\"> class or interface with <a href=\"ClassLoader.html#binary-name\">binary name<\/a> <i>N<\/i>\n+     * <tr><th scope=\"row\"> class or interface with {@linkplain ClassLoader##binary-name binary name} <i>N<\/i>\n@@ -1077,0 +1098,2 @@\n+     * Character.UnicodeBlock.class.getName()\n+     *     returns \"java.lang.Character$UnicodeBlock\"\n@@ -1085,0 +1108,3 @@\n+     * @apiNote\n+     * Distinct class objects can have the same name but different class loaders.\n+     *\n@@ -1737,4 +1763,2 @@\n-        if (o instanceof GenericArrayType)\n-            return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),\n-                                     0)\n-                .getClass();\n+        if (o instanceof GenericArrayType gat)\n+            return toClass(gat.getGenericComponentType()).arrayType();\n@@ -3166,2 +3190,2 @@\n-                } else if (cl instanceof BuiltinClassLoader) {\n-                    return ((BuiltinClassLoader) cl).findResourceAsStream(mn, name);\n+                } else if (cl instanceof BuiltinClassLoader bcl) {\n+                    return bcl.findResourceAsStream(mn, name);\n@@ -4692,1 +4716,1 @@\n-     *      where <em>N<\/em> is the <a href=\"ClassLoader.html#binary-name\">binary name<\/a>\n+     *      where <em>N<\/em> is the {@linkplain ClassLoader##binary-name binary name}\n@@ -4720,5 +4744,0 @@\n-     * @apiNote\n-     * This is not a strict inverse of {@link #forName};\n-     * distinct classes which share a common name but have different class loaders\n-     * will have identical descriptor strings.\n-     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":81,"deletions":62,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-     * Returns a hash code value for the object. This method is\n+     * {@return a hash code value for this object} This method is\n@@ -108,1 +108,5 @@\n-     * @return  a hash code value for this object.\n+     * @apiNote\n+     * The {@link java.util.Objects#hash(Object...) hash} and {@link\n+     * java.util.Objects#hashCode(Object) hashCode} methods of {@link\n+     * java.util.Objects} can be used to help construct simple hash codes.\n+     *\n@@ -166,0 +170,3 @@\n+     * <p>The two-argument {@link java.util.Objects#equals(Object,\n+     * Object) Objects.equals} method implements an equivalence relation\n+     * on two possibly-null object references.\n@@ -242,1 +249,1 @@\n-     * Returns a string representation of the object.\n+     * {@return a string representation of the object}\n@@ -259,2 +266,1 @@\n-     * <blockquote>\n-     * <pre>\n+     * {@snippet lang=java :\n@@ -262,3 +268,6 @@\n-     * <\/pre><\/blockquote>\n-     *\n-     * @return  a string representation of the object.\n+     * }\n+     * The {@link java.util.Objects#toIdentityString(Object)\n+     * Objects.toIdentityString} method returns the string for an\n+     * object equal to the string that would be returned if neither\n+     * the {@code toString} nor {@code hashCode} methods were\n+     * overridden by the object's class.\n@@ -459,1 +468,1 @@\n-     * <pre>{@code\n+     * {@snippet lang=java :\n@@ -461,1 +470,1 @@\n-     *         while (<condition does not hold> and <timeout not exceeded>) {\n+     *         while ( <condition does not hold and timeout not exceeded> ) {\n@@ -468,1 +477,1 @@\n-     * }<\/pre>\n+     * }\n@@ -568,1 +577,2 @@\n-     * <pre>{@code      @Override\n+     * {@snippet lang=\"java\":\n+     *     @Override\n@@ -576,1 +586,1 @@\n-     * }<\/pre>\n+     * }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2399,3 +2399,0 @@\n-            public String fastUUID(long lsb, long msb) {\n-                return Long.fastUUID(lsb, msb);\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-     * @throws IllegalArgumentException if the name string is not in the\n+     * @throws IllegalArgumentException if the descriptor string is not in the\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    \/\/ Map from DirectMethodHandle method type name to index to LambdForms\n+    \/\/ Map from DirectMethodHandle method type name to index to LambdaForms\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-        if (mem instanceof Method) {\n+        if (mem instanceof Method mth) {\n@@ -152,3 +152,3 @@\n-            return new MemberName((Method) mem, wantSpecial);\n-        } else if (mem instanceof Constructor) {\n-            return new MemberName((Constructor) mem);\n+            return new MemberName(mth, wantSpecial);\n+        } else if (mem instanceof Constructor<?> ctor) {\n+            return new MemberName(ctor);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InfoFromMemberName.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -807,2 +807,2 @@\n-                        assert(name.arguments[0] instanceof Name &&\n-                                ((Name)name.arguments[0]).refersTo(MethodHandleImpl.class, \"profileBoolean\"));\n+                        assert(name.arguments[0] instanceof Name n &&\n+                                n.refersTo(MethodHandleImpl.class, \"profileBoolean\"));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -339,1 +339,1 @@\n-    \/\/ root factory pre\/post processing and calls simple cosntructor\n+    \/\/ root factory pre\/post processing and calls simple constructor\n@@ -956,2 +956,2 @@\n-            if (a instanceof Name) {\n-                int i2 = ((Name)a).index();\n+            if (a instanceof Name n) {\n+                int i2 = n.index();\n@@ -1068,1 +1068,1 @@\n-        return obj instanceof LambdaForm && equals((LambdaForm)obj);\n+        return obj instanceof LambdaForm lf && equals(lf);\n@@ -1369,1 +1369,1 @@\n-            assert(arguments[0] instanceof Name && ((Name)arguments[0]).type == L_TYPE);\n+            assert(arguments[0] instanceof Name name && name.type == L_TYPE);\n@@ -1531,1 +1531,1 @@\n-            if (c instanceof Class)  c = ((Class<?>)c).getSimpleName();\n+            if (c instanceof Class<?> cl)  c = cl.getSimpleName();\n@@ -1563,2 +1563,2 @@\n-            if (object instanceof Name) {\n-                return ((Name)object).type == parameterType;\n+            if (object instanceof Name name) {\n+                return name.type == parameterType;\n@@ -1615,1 +1615,1 @@\n-            return x instanceof Name && equals((Name)x);\n+            return x instanceof Name n && equals(n);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,2 +105,2 @@\n-            if (obj instanceof TransformKey) {\n-                return equals((TransformKey) obj);\n+            if (obj instanceof TransformKey key) {\n+                return equals(key);\n@@ -108,1 +108,1 @@\n-            return obj instanceof Transform && equals((Transform)obj);\n+            return obj instanceof Transform transform && equals(transform);\n@@ -358,2 +358,2 @@\n-            if (obj instanceof TransformKey) {\n-                return equals((TransformKey) obj);\n+            if (obj instanceof TransformKey key) {\n+                return equals(key);\n@@ -361,1 +361,1 @@\n-            return obj instanceof Transform && equals((Transform)obj);\n+            return obj instanceof Transform transform && equals(transform);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,2 +140,2 @@\n-            if (type instanceof MethodType) {\n-                return (MethodType) type;\n+            if (type instanceof MethodType mt) {\n+                return mt;\n@@ -178,2 +178,2 @@\n-        if (type instanceof String) {\n-            return (String) type;\n+        if (type instanceof String str) {\n+            return str;\n@@ -217,2 +217,2 @@\n-            if (type instanceof Class<?>) {\n-                return (Class<?>) type;\n+            if (type instanceof Class<?> cl) {\n+                return cl;\n@@ -757,1 +757,1 @@\n-        return (that instanceof MemberName && this.equals((MemberName)that));\n+        return that instanceof MemberName mn && this.equals(mn);\n@@ -841,2 +841,2 @@\n-            if (this.type instanceof MethodType)\n-                type = (MethodType) this.type;\n+            if (this.type instanceof MethodType mt)\n+                type = mt;\n@@ -850,2 +850,2 @@\n-            if (this.type instanceof Class<?>)\n-                type = (Class<?>) this.type;\n+            if (this.type instanceof Class<?> cl)\n+                type = cl;\n@@ -896,2 +896,2 @@\n-        if (obj instanceof Class<?>)\n-            return ((Class<?>)obj).getName();\n+        if (obj instanceof Class<?> cl)\n+            return cl.getName();\n@@ -948,2 +948,2 @@\n-        if (resolution instanceof Throwable)\n-            ex.initCause((Throwable) resolution);\n+        if (resolution instanceof Throwable res)\n+            ex.initCause(res);\n@@ -1025,1 +1025,1 @@\n-            if (ex instanceof IllegalAccessException)  throw (IllegalAccessException) ex;\n+            if (ex instanceof IllegalAccessException iae) throw iae;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,4 +354,4 @@\n-        if (staticArguments instanceof Object[])\n-            return \"BSA=\"+java.util.Arrays.asList((Object[]) staticArguments);\n-        if (staticArguments instanceof int[])\n-            return \"BSA@\"+java.util.Arrays.toString((int[]) staticArguments);\n+        if (staticArguments instanceof Object[] array)\n+            return \"BSA=\"+java.util.Arrays.asList(array);\n+        if (staticArguments instanceof int[] array)\n+            return \"BSA@\"+java.util.Arrays.toString(array);\n@@ -513,2 +513,2 @@\n-        if (type instanceof MethodType)\n-            return (MethodType) type;\n+        if (type instanceof MethodType mt)\n+            return mt;\n@@ -641,2 +641,2 @@\n-            if (cause instanceof AbstractMethodError) {\n-                return (AbstractMethodError) cause;\n+            if (cause instanceof AbstractMethodError ame) {\n+                return ame;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3876,1 +3876,1 @@\n-         * for ensureInitialzed, findClass or accessClass.\n+         * for ensureInitialized, findClass or accessClass.\n@@ -4286,1 +4286,1 @@\n-            if (mh instanceof DirectMethodHandle\n+            if (mh instanceof DirectMethodHandle dmh\n@@ -4293,1 +4293,1 @@\n-                    LOOKASIDE_TABLE.put(key, (DirectMethodHandle) mh);\n+                    LOOKASIDE_TABLE.put(key, dmh);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -896,2 +896,2 @@\n-        if (x instanceof MethodType) {\n-            return equals((MethodType)x);\n+        if (x instanceof MethodType mt) {\n+            return equals(mt);\n@@ -899,5 +899,3 @@\n-        if (x instanceof ConcurrentWeakInternSet.WeakEntry) {\n-            Object o = ((ConcurrentWeakInternSet.WeakEntry)x).get();\n-            if (o instanceof MethodType) {\n-                return equals((MethodType)o);\n-            }\n+        if (x instanceof ConcurrentWeakInternSet.WeakEntry<?> e\n+                && e.get() instanceof MethodType mt) {\n+            return equals(mt);\n@@ -1171,2 +1169,3 @@\n-     * Finds or creates an instance of a method type, given the spelling of its bytecode descriptor.\n-     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.\n+     * Finds or creates an instance of a method type of the given method descriptor\n+     * (JVMS {@jvms 4.3.3}). This method is a convenience method for\n+     * {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.\n@@ -1174,5 +1173,6 @@\n-     * resolved by the given loader (or if it is null, on the system class loader).\n-     * <p>\n-     * Note that it is possible to encounter method types which cannot be\n-     * constructed by this method, because their component types are\n-     * not all reachable from a common class loader.\n+     * resolved by the given loader (or if it is {@code null}, on the system class loader).\n+     *\n+     * @apiNote\n+     * It is possible to encounter method types that have valid descriptors but\n+     * cannot be constructed by this method, because their component types are\n+     * not visible from a common class loader.\n@@ -1182,1 +1182,1 @@\n-     * @param descriptor a bytecode-level type descriptor string \"(T...)T\"\n+     * @param descriptor a method descriptor string\n@@ -1184,3 +1184,3 @@\n-     * @return a method type matching the bytecode-level type descriptor\n-     * @throws NullPointerException if the string is null\n-     * @throws IllegalArgumentException if the string is not well-formed\n+     * @return a method type of the given method descriptor\n+     * @throws NullPointerException if the string is {@code null}\n+     * @throws IllegalArgumentException if the string is not a method descriptor\n@@ -1191,0 +1191,1 @@\n+     * @jvms 4.3.3 Method Descriptors\n@@ -1230,1 +1231,1 @@\n-     * Returns a descriptor string for the method type.  This method\n+     * {@return the descriptor string for this method type} This method\n@@ -1233,4 +1234,8 @@\n-     * <p>\n-     * Note that this is not a strict inverse of {@link #fromMethodDescriptorString fromMethodDescriptorString}.\n-     * Two distinct classes which share a common name but have different class loaders\n-     * will appear identical when viewed within descriptor strings.\n+     * @apiNote\n+     * This is not a strict inverse of {@link #fromMethodDescriptorString\n+     * fromMethodDescriptorString} which requires a method type descriptor\n+     * (JVMS {@jvms 4.3.3}) and a suitable class loader argument.\n+     * Two distinct {@code MethodType} objects can have an identical\n+     * descriptor string as distinct classes can have the same name\n+     * but different class loaders.\n+     *\n@@ -1240,3 +1245,0 @@\n-     * {@link #fromMethodDescriptorString(java.lang.String, java.lang.ClassLoader) fromMethodDescriptorString},\n-     * because the latter requires a suitable class loader argument.\n-     * @return the descriptor string for this method type\n@@ -1256,1 +1258,1 @@\n-     * Returns a descriptor string for this method type.\n+     * {@return the descriptor string for this method type}\n@@ -1259,1 +1261,1 @@\n-     * If this method type can be <a href=\"#descriptor\">described nominally<\/a>,\n+     * If this method type can be {@linkplain ##descriptor described nominally},\n@@ -1265,1 +1267,1 @@\n-     * If this method type cannot be <a href=\"#descriptor\">described nominally<\/a>\n+     * If this method type cannot be {@linkplain ##descriptor described nominally}\n@@ -1274,1 +1276,0 @@\n-     * @return the descriptor string for this method type\n@@ -1493,2 +1494,2 @@\n-                if (obj instanceof WeakEntry) {\n-                    Object that = ((WeakEntry) obj).get();\n+                if (obj instanceof WeakEntry<?> we) {\n+                    Object that = we.get();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":34,"deletions":33,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -656,2 +656,2 @@\n-        } else if (handle instanceof DelegatingMethodHandle) {\n-            return exceptionTypes(((DelegatingMethodHandle)handle).getTarget());\n+        } else if (handle instanceof DelegatingMethodHandle delegatingMh) {\n+            return exceptionTypes(delegatingMh.getTarget());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -616,1 +616,1 @@\n-         * Method parameter loccation.\n+         * Method parameter location.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -689,2 +689,2 @@\n-        if (cache instanceof Cache) {\n-            return ((Cache) cache).isCacheFor(caller, targetClass);\n+        if (cache instanceof Cache c) {\n+            return c.isCacheFor(caller, targetClass);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessibleObject.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1056,2 +1056,2 @@\n-            if (t instanceof RuntimeException) {\n-                throw (RuntimeException) t;\n+            if (t instanceof RuntimeException re) {\n+                throw re;\n@@ -1272,1 +1272,1 @@\n-                \/\/ visit all superinteraces of one proxy interface to find if\n+                \/\/ visit all superinterfaces of one proxy interface to find if\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,2 @@\n-     * Returns {@code true} if the arguments are equal to each other\n-     * and {@code false} otherwise.\n+     * {@return {@code true} if the arguments are equal to each other\n+     * and {@code false} otherwise}\n@@ -61,2 +61,0 @@\n-     * @return {@code true} if the arguments are equal to each other\n-     * and {@code false} otherwise\n@@ -70,2 +68,2 @@\n-    * Returns {@code true} if the arguments are deeply equal to each other\n-    * and {@code false} otherwise.\n+    * {@return {@code true} if the arguments are deeply equal to each other\n+    * and {@code false} otherwise}\n@@ -81,2 +79,0 @@\n-    * @return {@code true} if the arguments are deeply equal to each other\n-    * and {@code false} otherwise\n@@ -96,2 +92,2 @@\n-     * Returns the hash code of a non-{@code null} argument and 0 for\n-     * a {@code null} argument.\n+     * {@return the hash code of a non-{@code null} argument and 0 for\n+     * a {@code null} argument}\n@@ -100,2 +96,0 @@\n-     * @return the hash code of a non-{@code null} argument and 0 for\n-     * a {@code null} argument\n@@ -109,1 +103,1 @@\n-    * Generates a hash code for a sequence of input values. The hash\n+    * {@return a hash code for a sequence of input values} The hash\n@@ -130,1 +124,0 @@\n-    * @return a hash value of the sequence of input values\n@@ -139,2 +132,3 @@\n-     * Returns the result of calling {@code toString} for a non-{@code\n-     * null} argument and {@code \"null\"} for a {@code null} argument.\n+     * {@return the result of calling {@code toString} for a\n+     * non-{@code null} argument and {@code \"null\"} for a\n+     * {@code null} argument}\n@@ -143,2 +137,0 @@\n-     * @return the result of calling {@code toString} for a non-{@code\n-     * null} argument and {@code \"null\"} for a {@code null} argument\n@@ -153,3 +145,3 @@\n-     * Returns the result of calling {@code toString} on the first\n-     * argument if the first argument is not {@code null} and returns\n-     * the second argument otherwise.\n+     * {@return the result of calling {@code toString} on the first\n+     * argument if the first argument is not {@code null} and the\n+     * second argument otherwise}\n@@ -160,3 +152,0 @@\n-     * @return the result of calling {@code toString} on the first\n-     * argument if it is not {@code null} and the second argument\n-     * otherwise.\n@@ -285,2 +274,2 @@\n-     * Returns 0 if the arguments are identical and {@code\n-     * c.compare(a, b)} otherwise.\n+     * {@return 0 if the arguments are identical and {@code\n+     * c.compare(a, b)} otherwise}\n@@ -299,2 +288,0 @@\n-     * @return 0 if the arguments are identical and {@code\n-     * c.compare(a, b)} otherwise.\n@@ -357,2 +344,2 @@\n-     * Returns {@code true} if the provided reference is {@code null} otherwise\n-     * returns {@code false}.\n+     * {@return {@code true} if the provided reference is {@code\n+     * null}; {@code false} otherwise}\n@@ -364,2 +351,0 @@\n-     * @return {@code true} if the provided reference is {@code null} otherwise\n-     * {@code false}\n@@ -375,2 +360,2 @@\n-     * Returns {@code true} if the provided reference is non-{@code null}\n-     * otherwise returns {@code false}.\n+     * {@return {@code true} if the provided reference is non-{@code null};\n+     * {@code false} otherwise}\n@@ -382,2 +367,0 @@\n-     * @return {@code true} if the provided reference is non-{@code null}\n-     * otherwise {@code false}\n@@ -393,2 +376,2 @@\n-     * Returns the first argument if it is non-{@code null} and\n-     * otherwise returns the non-{@code null} second argument.\n+     * {@return the first argument if it is non-{@code null} and\n+     * otherwise the second argument if it is non-{@code null}}\n@@ -400,2 +383,0 @@\n-     * @return the first argument if it is non-{@code null} and\n-     *        otherwise the second argument if it is non-{@code null}\n@@ -411,2 +392,3 @@\n-     * Returns the first argument if it is non-{@code null} and otherwise\n-     * returns the non-{@code null} value of {@code supplier.get()}.\n+     * {@return the first argument if it is non-{@code null} and\n+     * otherwise the value from {@code supplier.get()} if it is\n+     * non-{@code null}}\n@@ -418,2 +400,0 @@\n-     * @return the first argument if it is non-{@code null} and otherwise\n-     *         the value from {@code supplier.get()} if it is non-{@code null}\n","filename":"src\/java.base\/share\/classes\/java\/util\/Objects.java","additions":25,"deletions":45,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -180,5 +180,0 @@\n-    \/**\n-     * Invokes Long.fastUUID\n-     *\/\n-    String fastUUID(long lsb, long msb);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-        ArrayList<Class<?>> ptypes = new ArrayList<Class<?>>();\n+        var ptypes = new ArrayList<Class<?>>();\n@@ -103,1 +103,1 @@\n-                t = java.lang.reflect.Array.newInstance(t, 0).getClass();\n+                t = t.arrayType();\n@@ -120,4 +120,4 @@\n-        if (type instanceof Class<?>)\n-            return unparse((Class<?>) type);\n-        if (type instanceof MethodType)\n-            return ((MethodType) type).toMethodDescriptorString();\n+        if (type instanceof Class<?> cl)\n+            return unparse(cl);\n+        if (type instanceof MethodType mt)\n+            return mt.toMethodDescriptorString();\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5305,1 +5305,2 @@\n-                             TreeInfo.diagnosticPositionFor(spf, tree), Warnings.ImproperSPF);\n+                             TreeInfo.diagnosticPositionFor(spf, tree),\n+                             Warnings.ImproperSPF);\n@@ -5310,1 +5311,2 @@\n-                             TreeInfo.diagnosticPositionFor(spf, tree), Warnings.OSFArraySPF);\n+                             TreeInfo.diagnosticPositionFor(spf, tree),\n+                             Warnings.OSFArraySPF);\n@@ -5314,1 +5316,2 @@\n-                log.warning(LintCategory.SERIAL, tree.pos(),\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(spf, tree),\n@@ -5422,0 +5425,1 @@\n+                        var field = (VarSymbol)enclosed;\n@@ -5423,1 +5427,2 @@\n-                            log.warning(LintCategory.SERIAL, tree.pos(),\n+                            log.warning(LintCategory.SERIAL,\n+                                        TreeInfo.diagnosticPositionFor(field, tree),\n@@ -5429,0 +5434,1 @@\n+                        var method = (MethodSymbol)enclosed;\n@@ -5430,1 +5436,2 @@\n-                            log.warning(LintCategory.SERIAL, tree.pos(),\n+                            log.warning(LintCategory.SERIAL,\n+                                        TreeInfo.diagnosticPositionFor(method, tree),\n@@ -5550,0 +5557,1 @@\n+                        var field = (VarSymbol)enclosed;\n@@ -5552,1 +5560,2 @@\n-                            log.warning(LintCategory.SERIAL, tree.pos(),\n+                            log.warning(LintCategory.SERIAL,\n+                                        TreeInfo.diagnosticPositionFor(field, tree),\n@@ -5560,1 +5569,1 @@\n-                            checkSerialVersionUID(tree, e, (VarSymbol)enclosed);\n+                            checkSerialVersionUID(tree, e, field);\n@@ -5571,0 +5580,1 @@\n+\n@@ -5573,1 +5583,2 @@\n-                                log.warning(LintCategory.SERIAL, tree.pos(),\n+                                log.warning(LintCategory.SERIAL,\n+                                            TreeInfo.diagnosticPositionFor(method, tree),\n@@ -5651,1 +5662,2 @@\n-                log.warning(LintCategory.SERIAL, tree.pos(),\n+                log.warning(LintCategory.SERIAL,\n+                            TreeInfo.diagnosticPositionFor(method, tree),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -87,0 +87,2 @@\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -88,0 +90,1 @@\n+\n@@ -99,0 +102,1 @@\n+import static javax.tools.StandardLocation.ANNOTATION_PROCESSOR_PATH;\n@@ -235,0 +239,4 @@\n+    \/** Whether or not the options lint category was initially disabled\n+     *\/\n+    boolean optionsCheckingInitiallyDisabled;\n+\n@@ -427,0 +435,6 @@\n+        \/\/ See if lint options checking was explicitly disabled by the\n+        \/\/ user; this is distinct from the options check being\n+        \/\/ enabled\/disabled.\n+        optionsCheckingInitiallyDisabled =\n+            options.isSet(Option.XLINT_CUSTOM, \"-options\") ||\n+            options.isSet(Option.XLINT_CUSTOM, \"none\");\n@@ -1142,0 +1156,5 @@\n+                if (!explicitAnnotationProcessingRequested() &&\n+                    !optionsCheckingInitiallyDisabled) {\n+                    log.note(Notes.ImplicitAnnotationProcessing);\n+                }\n+\n@@ -1289,1 +1308,1 @@\n-            explicitAnnotationProcessingRequested(options);\n+            explicitAnnotationProcessingRequested(options, fileManager);\n@@ -1292,1 +1311,1 @@\n-    static boolean explicitAnnotationProcessingRequested(Options options) {\n+    static boolean explicitAnnotationProcessingRequested(Options options, JavaFileManager fileManager) {\n@@ -1300,1 +1319,2 @@\n-            options.isSet(XPRINT);\n+            options.isSet(XPRINT) ||\n+            fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -4033,2 +4033,0 @@\n-                if (token.kind == EOF)\n-                    break;\n@@ -4101,1 +4099,1 @@\n-                } else {\n+                } else if (token.kind != EOF) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -314,0 +314,4 @@\n+                 *\n+                 * Note: if an explicit processor path is not set,\n+                 * only the class path and _not_ the module path are\n+                 * searched for processors.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1778,0 +1778,9 @@\n+compiler.note.implicit.annotation.processing=\\\n+    Annotation processing is enabled because one or more processors were found\\n\\\n+    on the class path. A future release of javac may disable annotation processing\\n\\\n+    unless at least one processor is specified by name (-processor), or a search\\n\\\n+    path is specified (--processor-path, --processor-module-path), or annotation\\n\\\n+    processing is enabled explicitly (-proc:only, -proc:full).\\n\\\n+    Use -Xlint:-options to suppress this message.\\n\\\n+    Use -proc:none to disable annotation processing.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import sun.jvm.hotspot.utilities.U1Array;\n@@ -129,0 +130,6 @@\n+  public boolean      hasStackMapTable()              {\n+    return getConstMethod().hasStackMapTable();\n+  }\n+  public U1Array      getStackMapData()               {\n+    return getConstMethod().getStackMapData();\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Method.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+    protected short  _stackMapTableIndex;\n@@ -63,0 +64,1 @@\n+    protected short  _bootstrapMethodsIndex;\n@@ -144,0 +146,2 @@\n+        Short bootstrapMethodsIndex = utf8ToIndex.get(\"BootstrapMethods\");\n+        _bootstrapMethodsIndex = (bootstrapMethodsIndex != null) ? bootstrapMethodsIndex.shortValue() : 0;\n@@ -171,0 +175,5 @@\n+        Short stackMapTableIndex = utf8ToIndex.get(\"StackMapTable\");\n+        _stackMapTableIndex = (stackMapTableIndex != null) ?\n+                              stackMapTableIndex.shortValue() : 0;\n+        if (DEBUG) debugMessage(\"StackMapTable index = \" + _stackMapTableIndex);\n+\n@@ -519,0 +528,21 @@\n+            boolean hasStackMapTable = m.hasStackMapTable();\n+            U1Array stackMapData = null;\n+            int stackMapAttrLen = 0;\n+\n+            if (hasStackMapTable) {\n+                if (DEBUG) debugMessage(\"\\tmethod has stack map table\");\n+                stackMapData = m.getStackMapData();\n+                if (DEBUG) debugMessage(\"\\t\\tstack map table length = \" + stackMapData.length());\n+\n+                stackMapAttrLen = stackMapData.length();\n+\n+                codeSize += 2 \/* stack map table attr index *\/ +\n+                            4 \/* stack map table attr length *\/ +\n+                            stackMapAttrLen;\n+\n+                if (DEBUG) debugMessage(\"\\t\\tstack map table attr size = \" +\n+                                        stackMapAttrLen);\n+\n+                codeAttrCount++;\n+            }\n+\n@@ -605,0 +635,11 @@\n+            \/\/ write StackMapTable, if available\n+            if (hasStackMapTable) {\n+                writeIndex(_stackMapTableIndex);\n+                dos.writeInt(stackMapAttrLen);\n+                \/\/ We write bytes directly as stackMapData is\n+                \/\/ raw data (#entries + entries)\n+                for (int i = 0; i < stackMapData.length(); i++) {\n+                    dos.writeByte(stackMapData.at(i));\n+                }\n+            }\n+\n@@ -689,0 +730,5 @@\n+        int bsmCount = klass.getConstants().getBootstrapMethodsCount();\n+        if (bsmCount != 0) {\n+            classAttributeCount++;\n+        }\n+\n@@ -728,0 +774,22 @@\n+\n+        \/\/ write bootstrap method attribute, if any\n+        if (bsmCount != 0) {\n+            ConstantPool cpool = klass.getConstants();\n+            writeIndex(_bootstrapMethodsIndex);\n+            if (DEBUG) debugMessage(\"bootstrap methods attribute = \" + _bootstrapMethodsIndex);\n+            int attrLen = 2; \/\/ num_bootstrap_methods\n+            for (int index = 0; index < bsmCount; index++) {\n+                int bsmArgsCount = cpool.getBootstrapMethodArgsCount(index);\n+                attrLen += 2 \/\/ bootstrap_method_ref\n+                           + 2 \/\/ num_bootstrap_arguments\n+                           + bsmArgsCount * 2;\n+            }\n+            dos.writeInt(attrLen);\n+            dos.writeShort(bsmCount);\n+            for (int index = 0; index < bsmCount; index++) {\n+                short value[] = cpool.getBootstrapMethodAt(index);\n+                for (int i = 0; i < value.length; i++) {\n+                    dos.writeShort(value[i]);\n+                }\n+            }\n+        }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ClassWriter.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -72,2 +72,0 @@\n-compiler\/c2\/irTests\/TestVectorConditionalMove.java 8306922 generic-all\n-\n@@ -132,7 +130,7 @@\n-serviceability\/sa\/ClhsdbCDSCore.java 8294316,8267433 macosx-x64\n-serviceability\/sa\/ClhsdbFindPC.java#xcomp-core 8294316,8267433 macosx-x64\n-serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8294316,8267433 macosx-x64\n-serviceability\/sa\/ClhsdbPmap.java#core 8294316,8267433 macosx-x64\n-serviceability\/sa\/ClhsdbPstack.java#core 8294316,8267433 macosx-x64\n-serviceability\/sa\/TestJmapCore.java 8294316,8267433 macosx-x64\n-serviceability\/sa\/TestJmapCoreMetaspace.java 8294316,8267433 macosx-x64\n+serviceability\/sa\/ClhsdbCDSCore.java 8267433 macosx-x64\n+serviceability\/sa\/ClhsdbFindPC.java#xcomp-core 8267433 macosx-x64\n+serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8267433 macosx-x64\n+serviceability\/sa\/ClhsdbPmap.java#core 8267433 macosx-x64\n+serviceability\/sa\/ClhsdbPstack.java#core 8267433 macosx-x64\n+serviceability\/sa\/TestJmapCore.java 8267433 macosx-x64\n+serviceability\/sa\/TestJmapCoreMetaspace.java 8267433 macosx-x64\n@@ -211,0 +209,2 @@\n+\n+vmTestbase\/nsk\/jdb\/interrupt\/interrupt001\/interrupt001.java 8310551 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -364,1 +364,0 @@\n-  gc\/startup_warnings\/TestShenandoah.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1196,0 +1196,5 @@\n+    public static final String SUBTYPE_CHECK = PREFIX + \"SUBTYPE_CHECK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUBTYPE_CHECK, \"SubTypeCheck\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-                    \"TLAB\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+            \/\/ Let javap print additional info, e.g., StackMapTable\n+            launcher.addToolArg(\"-verbose\");\n@@ -89,0 +91,4 @@\n+            \/\/ StackMapTable might not be generated for a class\n+            \/\/ containing only methods with sequential control flows.\n+            \/\/ But the class used here (LingeredApp) is not such a case.\n+            out.shouldContain(\"StackMapTable:\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpclass.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-java\/awt\/Frame\/MaximizedToIconified\/MaximizedToIconified.java 8296972 macosx-all\n@@ -475,7 +474,0 @@\n-# jdk_foreign\n-\n-java\/foreign\/callarranger\/TestAarch64CallArranger.java generic-x86\n-java\/foreign\/TestLargeSegmentCopy.java generic-x86\n-\n-############################################################################\n-\n@@ -531,0 +523,2 @@\n+javax\/management\/remote\/mandatory\/subjectDelegation\/SubjectDelegation1Test.java 8149084 linux-aarch64\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"}]}