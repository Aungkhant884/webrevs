{"files":[{"patch":"@@ -206,1 +206,0 @@\n-    private static final int VALUE_CLASS     = 0x00000040;\n@@ -641,1 +640,10 @@\n-     * Returns {@code true} if this class is a value class.\n+     * {@return {@code true} if this class is an identity class, otherwise {@code false}}\n+     *\n+     * @since Valhalla\n+     *\/\n+    public boolean isIdentity() {\n+        return (this.getModifiers() & Modifier.IDENTITY) != 0;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if this class is a value class, otherwise {@code false}}\n@@ -643,2 +651,0 @@\n-     * @return {@code true} if this class is a value class;\n-     * otherwise {@code false}\n@@ -648,1 +654,1 @@\n-        return (this.getModifiers() & VALUE_CLASS) != 0;\n+        return (this.getModifiers() & Modifier.VALUE) != 0;\n@@ -1452,0 +1458,2 @@\n+     * The modifiers also include the Java Virtual Machine's constants for\n+     * {@code identity class} and {@code value class}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -191,2 +191,4 @@\n-     * The access flag {@code ACC_IDENTITY} with a mask value of {@code\n-     * 0x0020}.\n+     * The access flag {@code ACC_IDENTITY}, corresponding to the\n+     * source modifier {@link Modifier#IDENTITY identity}, with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#IDENTITY}<\/code>.\n+     * @jvms 4.1 -B. Class access and property modifiers\n@@ -194,1 +196,1 @@\n-\/\/    IDENTITY(0x0000_0020, false, Location.SET_CLASS),\n+    IDENTITY(Modifier.IDENTITY, true, Location.SET_CLASS_INNER_CLASS, null),\n@@ -201,8 +203,8 @@\n-        OPEN(0x0000_0020, false, Location.SET_MODULE,\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-                 @Override\n-                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                     return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                         Location.SET_MODULE:\n-                         Location.EMPTY_SET;}\n-             }),\n+    OPEN(0x0000_0020, false, Location.SET_MODULE,\n+         new Function<ClassFileFormatVersion, Set<Location>>() {\n+             @Override\n+             public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                 return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                     Location.SET_MODULE:\n+                     Location.EMPTY_SET;}\n+         }),\n@@ -245,1 +247,9 @@\n-   \/**\n+    \/**\n+     * The access flag {@code ACC_VALUE}, corresponding to the\n+     * source modifier {@link Modifier#VALUE value}, with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#VALUE}<\/code>.\n+     * @jvms 4.1 -B. Class access and property modifiers\n+     *\/\n+    VALUE(Modifier.VALUE, true, Set.of(Location.CLASS, Location.INNER_CLASS), null),\n+\n+    \/**\n@@ -251,1 +261,0 @@\n-\n@@ -497,0 +506,1 @@\n+        int unmatchedFlags = mask;\n@@ -501,1 +511,1 @@\n-                mask = mask & ~accessMask;\n+                unmatchedFlags = unmatchedFlags & ~accessMask;\n@@ -504,1 +514,1 @@\n-        if (mask != 0) {\n+        if (unmatchedFlags != 0) {\n@@ -506,1 +516,1 @@\n-                                               Integer.toHexString(mask) +\n+                                               Integer.toHexString(unmatchedFlags) +\n@@ -630,1 +640,1 @@\n-                                Set.of(PUBLIC, FINAL, SUPER,\n+                                Set.of(PUBLIC, FINAL, SUPER, IDENTITY, VALUE,\n@@ -644,1 +654,1 @@\n-                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED, IDENTITY, VALUE,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n- * constants to decode class and member access modifiers.  The sets of\n- * modifiers are represented as integers with distinct bit positions\n+ * constants to decode class and member access modifiers.\n+ * The {@link AccessFlag} class should be used instead of this class.\n+ * The sets of modifiers are represented as integers with non-distinct bit positions\n@@ -39,0 +40,2 @@\n+ * @see Class#accessFlags()\n+ * @see Member#accessFlags()\n@@ -117,0 +120,3 @@\n+     * @apiNote {@code isSynchronized} should only be called with the modifiers\n+     * of a {@linkplain Method#getModifiers() method}.\n+     *\n@@ -129,0 +135,3 @@\n+     * @apiNote {@code isIdentity} should only be called with the modifiers\n+     * of a {@linkplain Class#getModifiers() class}.\n+     *\n@@ -149,0 +158,15 @@\n+    \/**\n+     * Return {@code true} if the integer argument includes the\n+     * {@code value} modifier, {@code false} otherwise.\n+     *\n+     * @apiNote {@code isValue} should only be called with the modifiers\n+     * of a {@linkplain Class#getModifiers() class}.\n+     *\n+     * @param   mod a set of modifiers\n+     * @return {@code true} if {@code mod} includes the\n+     * {@code value} modifier; {@code false} otherwise.\n+     *\/\n+    public static boolean isValue(int mod) {\n+        return (mod & VALUE) != 0;\n+    }\n+\n@@ -312,1 +336,8 @@\n-    public static final int IDENTITY            = 0x00000020;\n+    public static final int IDENTITY         = 0x00000020;\n+\n+    \/**\n+     * The {@code int} value representing the {@code value}\n+     * modifier.\n+     * @see AccessFlag#VALUE\n+     *\/\n+    public static final int VALUE            = 0x00000040;\n@@ -360,3 +391,3 @@\n-    static final int BRIDGE      = 0x00000040;\n-    static final int VARARGS     = 0x00000080;\n-    static final int SYNTHETIC   = 0x00001000;\n+    static final int BRIDGE    = 0x00000040;\n+    static final int VARARGS   = 0x00000080;\n+    static final int SYNTHETIC = 0x00001000;\n@@ -364,2 +395,2 @@\n-    static final int ENUM        = 0x00004000;\n-    static final int MANDATED    = 0x00008000;\n+    static final int ENUM      = 0x00004000;\n+    static final int MANDATED  = 0x00008000;\n@@ -391,1 +422,2 @@\n-        Modifier.STRICT         | Modifier.IDENTITY;\n+        Modifier.IDENTITY       | Modifier.VALUE        |\n+        Modifier.STRICT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":41,"deletions":9,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import java.lang.reflect.Modifier;\n@@ -686,2 +687,1 @@\n-        int mods = clazz.getModifiers();\n-        return (mods & 0x00000100) != 0;\n+        return (clazz.getModifiers() & Opcodes.ACC_PRIMITIVE) != 0;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Type.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,3 @@\n-                                     AnotherEnum.class)) {\n+                                     AnotherEnum.class,\n+                                     AValueClass.class,\n+                                     APrimitiveClass.class)) {\n@@ -114,0 +116,6 @@\n+\n+@ExpectedGenericString(\"final value class AValueClass<E>\")\n+value class AValueClass<E> {}\n+\n+@ExpectedGenericString(\"final primitive class APrimitiveClass<E>\")\n+primitive class APrimitiveClass<E> {}\n","filename":"test\/jdk\/java\/lang\/Class\/GenericStringTest.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-                new Object[] { \"EmptyHiddenAbstractClass\", ACC_ABSTRACT },\n+                new Object[] { \"EmptyHiddenAbstractClass\", ACC_ABSTRACT | ACC_IDENTITY },\n@@ -284,1 +284,1 @@\n-            case ACC_ABSTRACT:\n+            case ACC_ABSTRACT | ACC_IDENTITY:\n@@ -306,1 +306,1 @@\n-        assertTrue(hc.getModifiers() == (ACC_PUBLIC|accessFlags));\n+        assertEquals(hc.getModifiers(), (ACC_PUBLIC|accessFlags));\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/BasicTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8266670\n+ * @bug 8266670 8281463\n@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -114,0 +115,2 @@\n+                if (accessFlag.equals(AccessFlag.SUPER))\n+                    continue;       \/\/ SUPER is defined to overlap with IDENTITY\n@@ -143,1 +146,3 @@\n-                if (!expectedSet.equals(computedSet)) {\n+                if (!computedSet.containsAll(expectedSet)) {\n+                    System.out.println(\"expected: \" + expectedSet);\n+                    System.out.println(\"computed: \" + computedSet);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER]\")\n+@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER, IDENTITY]\")\n@@ -182,1 +182,1 @@\n-    @ExpectedClassFlags(\"[FINAL]\")\n+    @ExpectedClassFlags(\"[FINAL, IDENTITY]\")\n@@ -185,1 +185,1 @@\n-    @ExpectedClassFlags(\"[ABSTRACT]\")\n+    @ExpectedClassFlags(\"[IDENTITY, ABSTRACT]\")\n@@ -191,1 +191,1 @@\n-    @ExpectedClassFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+    @ExpectedClassFlags(\"[PUBLIC, STATIC, FINAL, IDENTITY, ENUM]\")\n@@ -198,1 +198,1 @@\n-    @ExpectedClassFlags(\"[PROTECTED, STATIC, ABSTRACT, ENUM]\")\n+    @ExpectedClassFlags(\"[PROTECTED, STATIC, IDENTITY, ABSTRACT, ENUM]\")\n@@ -207,1 +207,1 @@\n-    @ExpectedClassFlags(\"[PRIVATE, ABSTRACT]\")\n+    @ExpectedClassFlags(\"[PRIVATE, IDENTITY, ABSTRACT]\")\n@@ -224,1 +224,1 @@\n-@ExpectedClassFlags(\"[FINAL, SUPER, ENUM]\")\n+@ExpectedClassFlags(\"[FINAL, SUPER, IDENTITY, ENUM]\")\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-public class StaticFactoryTest {\n+public final identity class StaticFactoryTest {\n@@ -46,0 +46,13 @@\n+\n+    static identity class SimpleIdentity {\n+        public final int x;\n+\n+        SimpleIdentity() {\n+            x = -1;\n+        }\n+\n+        public SimpleIdentity(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n@@ -73,2 +86,6 @@\n-                new Object[] { SimplePrimitive.class, true },\n-                new Object[] { SimpleValue.class, false },\n+                new Object[] { SimpleIdentity.class, true, false, false },\n+                new Object[] { SimplePrimitive.class, false, true, true },\n+                new Object[] { SimpleValue.class, false, true, false },\n+                new Object[] { InterfaceWithNested.IdentityClass.class, true, false, false },\n+                new Object[] { InterfaceWithNested.ValueClass.class, false, true, false },\n+                new Object[] { InterfaceWithNested.PrimitiveClass.class, false, true, true },\n@@ -79,1 +96,2 @@\n-    public void testConstructor(Class<?> c, boolean isPrimitiveClass) throws ReflectiveOperationException {\n+    public void testConstructor(Class<?> c, boolean isIdentityClass,\n+                                boolean isValueClass, boolean isPrimitiveClass) throws ReflectiveOperationException {\n@@ -82,0 +100,1 @@\n+        System.out.printf(\"cn: %s, mod: 0x%04X%n\", cn, c.getModifiers());\n@@ -83,2 +102,3 @@\n-        assertTrue(clz.isValue());\n-        assertTrue(clz.isPrimitiveClass() == isPrimitiveClass);\n+        assertEquals(clz.isIdentity(), isIdentityClass, \"identity class: \" + clz);\n+        assertEquals(clz.isValue(), isValueClass, \"value class: \" + clz);\n+        assertEquals(clz.isPrimitiveClass(), isPrimitiveClass, \"primitive class: \" + clz);\n@@ -97,2 +117,2 @@\n-            if (Modifier.isStatic(m.getModifiers())) {\n-                assertFalse(m.getName().equals(\"<init>\"));\n+            if (Modifier.isStatic(m.getModifiers()) && \"<init>\".equals(m.getName())) {\n+                assertTrue(isIdentityClass, \"<init> method is not in an identity class\");\n@@ -103,0 +123,13 @@\n+\n+    interface SimpleInterface {}\n+\n+    identity interface SimpleIdentityInterface {} \/\/ Illegal class modifiers from VM\n+\n+    value interface SimpleValueInterface {}\n+\n+    interface InterfaceWithNested {\n+        identity class IdentityClass {}\n+        value class ValueClass {}\n+        primitive class PrimitiveClass {}\n+    }\n+\n@@ -104,0 +137,21 @@\n+    static Object[][] interfaces() {\n+        return new Object[][]{\n+                new Object[] { SimpleInterface.class, false, false, true },\n+                new Object[] { SimpleIdentityInterface.class, true, false, true },  \/\/ VM throws\n+                new Object[] { SimpleValueInterface.class, false, true, true },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"interfaces\")\n+    public void testInterfaces(Class<?> c, boolean isIdentityClass,\n+                                boolean isValueClass, boolean isAbstract) throws ReflectiveOperationException {\n+        String cn = c.getName();\n+        Class<?> clz = Class.forName(cn);\n+        System.out.printf(\"cn: %s, mod: 0x%04X%n\", cn, c.getModifiers());\n+\n+        assertEquals(clz.isIdentity(), isIdentityClass, \"identity class: \" + clz);\n+        assertEquals(clz.isValue(), isValueClass, \"value class: \" + clz);\n+        assertEquals(Modifier.isAbstract(clz.getModifiers()), isAbstract, \"abstract: \" + clz);\n+    }\n+\n+        @DataProvider\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticFactoryTest.java","additions":63,"deletions":9,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,2 @@\n+            throw new AssertionError(\"Primitive flag missing\");\n+        if ((Inner.class.getModifiers() & AccessFlags.ACC_VALUE) == 0)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/InnerClassAttributeValuenessTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}