{"files":[{"patch":"@@ -207,1 +207,0 @@\n-    private static final int PERMITS_VALUE   = 0x00000100;\n@@ -514,2 +513,2 @@\n-                                    ClassLoader loader,\n-                                    Class<?> caller)\n+                                            ClassLoader loader,\n+                                            Class<?> caller)\n@@ -1508,0 +1507,8 @@\n+    \/**\n+     * {@return true if this class has the requested {@link AccessFlag}}\n+     * @param flag an {@link AccessFlag}\n+     *\/\n+    public boolean is(AccessFlag flag) {\n+        return (getModifiers() & flag.mask()) == flag.mask();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-            STATIC(AccessFlag.STATIC.mask()),\n+            STATIC(AccessFlag.STATIC_PHASE.mask()),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,2 +76,1 @@\n- * @see java.compiler\/javax.lang.model.element.Modifier\n- * @since 20\n+ * @since Valhalla\n@@ -126,0 +125,8 @@\n+     * <p>\n+     * @apiNote\n+     * NOTE: The Valhalla draft JVMS spec does not define a value for ACC_SUPER.\n+     * Historically, the value 0x0020 was used to indicate ACC_SUPER, which affected the\n+     * semantics of any invokespecial instructions (6.5.invokespecial) appearing in the class.\n+     * In Java SE 8, the ACC_SUPER semantics became mandatory, regardless of the setting of\n+     * ACC_SUPER or the class file version number, and the flag no longer had any effect.\n+     * Now the flag has been repurposed as ACC_IDENTITY.\n@@ -127,1 +134,7 @@\n-    SUPER(0x0000_0020, false, Set.of(Location.CLASS)),\n+\/\/    SUPER(0x0000_0020, false, Set.of(Location.CLASS)),\n+\n+    \/**\n+     * The access flag {@code ACC_IDENTITY} with a mask value of {@code 0x0020}.\n+     * @jls 4.1-B. Class access and property modifiers\n+     *\/\n+    IDENTITY(0x0000_0020, true, Set.of(Location.CLASS, Location.INNER_CLASS)),\n@@ -157,1 +170,7 @@\n-     \/**\n+    \/**\n+     * The access flag {@code ACC_VALUE} with a mask value of {@code 0x0040}.\n+     * @jls 4.1-B. Class access and property modifiers\n+     *\/\n+    VALUE(0x0000_0040, true, Set.of(Location.CLASS, Location.INNER_CLASS)),\n+\n+    \/**\n@@ -208,0 +227,6 @@\n+    \/**\n+     * The access flag {@code ACC_PRIMITIVE} with a mask value of {@code 0x0800}.\n+     * @jls 4.1-B. Class access and property modifiers\n+     *\/\n+    PRIMITIVE(0x0000_0800, true, Set.of(Location.CLASS, Location.INNER_CLASS)),\n+\n@@ -392,1 +417,1 @@\n-                                Set.of(PUBLIC, FINAL, SUPER,\n+                                Set.of(PUBLIC, FINAL, IDENTITY, VALUE, PRIMITIVE,\n@@ -406,1 +431,1 @@\n-                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED, IDENTITY, VALUE, PRIMITIVE,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":31,"deletions":6,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n- * constants to decode class and member access modifiers.  The sets of\n- * modifiers are represented as integers with distinct bit positions\n+ * constants to decode class and member access modifiers.\n+ * The {@link AccessFlag} class should be used instead of this class.\n+ * The sets of modifiers are represented as integers with non-distinct bit positions\n@@ -38,0 +39,8 @@\n+ * <p>\n+ * This class cannot distinguish among modifiers for a class, method, or field.\n+ * The modifier masks are not unique; it is up to the caller to use the correct\n+ * mask or method with the modifier bits returned from {@link Class#getModifiers()}\n+ * or {@link Member#getModifiers()}.\n+ * The {@link AccessFlag} class provides a model that distinguishes between access flags\n+ * for classes, methods, and field. The {@link Class#accessFlags()} and {@link Member#accessFlags()}\n+ * methods provide the access flags for the respective class, method, or field.\n@@ -39,0 +48,2 @@\n+ * @see Class#accessFlags()\n+ * @see Member#accessFlags()\n@@ -125,12 +136,0 @@\n-    \/**\n-     * Return {@code true} if the integer argument includes the\n-     * {@code permitsValue} modifier, {@code false} otherwise.\n-     *\n-     * @param   mod a set of modifiers\n-     * @return {@code true} if {@code mod} includes the\n-     * {@code permitsValue} modifier; {@code false} otherwise.\n-     *\/\n-    public static boolean isPermitsValue(int mod) {\n-        return (mod & PERMITS_VALUE) != 0;\n-    }\n-\n@@ -308,6 +307,0 @@\n-    \/**\n-     * The {@code int} value representing the {@code permits_value}\n-     * modifier.\n-     *\/\n-    public static final int PERMITS_VALUE    = 0x00000040;\n-\n@@ -359,3 +352,3 @@\n-    static final int BRIDGE      = 0x00000040;\n-    static final int VARARGS     = 0x00000080;\n-    static final int SYNTHETIC   = 0x00001000;\n+    static final int BRIDGE    = 0x00000040;\n+    static final int VARARGS   = 0x00000080;\n+    static final int SYNTHETIC = 0x00001000;\n@@ -363,2 +356,2 @@\n-    static final int ENUM        = 0x00004000;\n-    static final int MANDATED    = 0x00008000;\n+    static final int ENUM      = 0x00004000;\n+    static final int MANDATED  = 0x00008000;\n@@ -390,1 +383,1 @@\n-        Modifier.STRICT         | Modifier.PERMITS_VALUE;\n+        Modifier.STRICT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":19,"deletions":26,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -685,2 +686,1 @@\n-        int mods = clazz.getModifiers();\n-        return (mods & 0x00000100) != 0;\n+        return clazz.is(AccessFlag.PRIMITIVE);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Type.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import static java.lang.reflect.Modifier.PERMITS_VALUE;\n@@ -54,0 +53,1 @@\n+    public static final int PERMITS_VALUE  = 0x0000_0040;   \/\/ Temp\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotModifiers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8266670\n+ * @bug 8266670 8281463\n@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -49,0 +50,2 @@\n+        List<AccessFlag> valhallaOnly =\n+                List.of(AccessFlag.IDENTITY, AccessFlag.VALUE, AccessFlag.PRIMITIVE);\n@@ -51,1 +54,1 @@\n-            if (accessFlag.sourceModifier()) {\n+            if (accessFlag.sourceModifier()  && !valhallaOnly.contains(accessFlag)) {\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,3 +35,7 @@\n-        if(!Modifier.toString(test).equals(expected))\n-            throw new RuntimeException(test +\n-                                          \" yields incorrect toString result\");\n+        String actual = Modifier.toString(test);\n+        if(!actual.equals(expected)) {\n+            System.out.println(\"Actual:   \" + actual);\n+            System.out.println(\"Expected: \" + expected);\n+\n+            throw new RuntimeException(Integer.toHexString(test) + \" yields incorrect toString result\");\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/Modifier\/toStringTest.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n-import com.sun.tools.classfile.AccessFlags;\n+import java.lang.reflect.AccessFlag;\n+import java.util.Set;\n@@ -51,1 +52,4 @@\n-        if ((Inner.class.getModifiers() & AccessFlags.ACC_PRIMITIVE) == 0)\n+        Set<AccessFlag> flags = Inner.class.accessFlags();\n+        System.out.println(\"accessFlags: \" + flags);\n+\n+        if (!Inner.class.is(AccessFlag.VALUE))\n@@ -53,0 +57,2 @@\n+        if (!Inner.class.is(AccessFlag.PRIMITIVE))\n+            throw new AssertionError(\"Primitive Value flag missing\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/InnerClassAttributeValuenessTest.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}