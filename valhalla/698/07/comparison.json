{"files":[{"patch":"@@ -203,6 +203,3 @@\n-    private static final int ANNOTATION = 0x00002000;\n-    private static final int ENUM       = 0x00004000;\n-    private static final int SYNTHETIC  = 0x00001000;\n-    private static final int VALUE_CLASS     = 0x00000040;\n-    private static final int PERMITS_VALUE   = 0x00000100;\n-    private static final int PRIMITIVE_CLASS = 0x00000800;\n+    private static final int ANNOTATION= 0x00002000;\n+    private static final int ENUM      = 0x00004000;\n+    private static final int SYNTHETIC = 0x00001000;\n@@ -308,0 +305,2 @@\n+                \/\/ Modifier.toString() below mis-interprets IDENTITY, VALUE, and PRIMITIVE bits\n+                modifiers &= ~(AccessFlag.IDENTITY.mask() | AccessFlag.VALUE.mask() | AccessFlag.PRIMITIVE.mask());\n@@ -317,1 +316,1 @@\n-                    sb.append(isPrimitiveClass() ? \"primitive\" : \"value\");\n+                    sb.append(isPrimitiveClass() ? \"primitive \" : \"value \");\n@@ -514,2 +513,2 @@\n-                                    ClassLoader loader,\n-                                    Class<?> caller)\n+                                            ClassLoader loader,\n+                                            Class<?> caller)\n@@ -629,1 +628,1 @@\n-        return (this.getModifiers() & PRIMITIVE_CLASS) != 0;\n+        return (this.getModifiers() & AccessFlag.PRIMITIVE.mask()) != 0;\n@@ -640,1 +639,1 @@\n-        return (this.getModifiers() & VALUE_CLASS) != 0;\n+        return (this.getModifiers() & AccessFlag.VALUE.mask()) != 0;\n@@ -1491,0 +1490,13 @@\n+     *\n+     * <p> If the underlying class is an array class, then its\n+     * {@code PUBLIC}, {@code PRIVATE} and {@code PROTECTED}\n+     * access flags are the same as those of its component type.  If this\n+     * {@code Class} object represents a primitive type or void, the\n+     * {@code PUBLIC} access flag is present, and the\n+     * {@code PROTECTED} and {@code PRIVATE} access flags are always\n+     * absent. If this {@code Class} object represents an array class, a\n+     * primitive type or void, then the {@code FINAL} access flag is always\n+     * present and the interface access flag is always\n+     * absent. The values of its other access flags are not determined\n+     * by this specification.\n+     *\n@@ -1503,1 +1515,2 @@\n-                                            (isMemberClass() || isLocalClass() || isAnonymousClass()) ?\n+                                            (isMemberClass() || isLocalClass() ||\n+                                             isAnonymousClass() || isArray()) ?\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,1 @@\n-            STATIC(AccessFlag.STATIC.mask()),\n+            STATIC(AccessFlag.STATIC_PHASE.mask()),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n- * <p>The access flag constants are ordered by non-decreasing mask\n+ * @implSpec\n+ * The access flag constants are ordered by non-decreasing mask\n@@ -71,0 +72,12 @@\n+ * @apiNote\n+ * The JVM class file format has a new version defined for each new\n+ * {@linkplain Runtime.Version#feature() feature release}. A new class\n+ * file version may define new access flags or retire old ones. {@code\n+ * AccessFlag} is intended to model the set of access flags across\n+ * class file format versions. The range of versions an access flag is\n+ * recognized is not explicitly indicated in this API. See the current\n+ * <cite>The Java Virtual Machine Specification<\/cite> for\n+ * details. Unless otherwise indicated, access flags can be assumed to\n+ * be recognized in the {@linkplain Runtime#version() current\n+ * version}.\n+ *\n@@ -76,2 +89,1 @@\n- * @see java.compiler\/javax.lang.model.element.Modifier\n- * @since 20\n+ * @since Valhalla\n@@ -84,1 +96,1 @@\n-     * {@code 0x0001}.\n+     * <code>{@value Modifier#PUBLIC}<\/code>.\n@@ -93,1 +105,1 @@\n-     * value of {@code 0x0002}.\n+     * value of <code>{@value Modifier#PRIVATE}<\/code>.\n@@ -95,2 +107,1 @@\n-    PRIVATE(Modifier.PRIVATE, true,\n-            Set.of(Location.FIELD, Location.METHOD, Location.INNER_CLASS)),\n+    PRIVATE(Modifier.PRIVATE, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n@@ -101,1 +112,1 @@\n-     * value of {@code 0x0004}.\n+     * value of <code>{@value Modifier#PROTECTED}<\/code>.\n@@ -103,2 +114,1 @@\n-    PROTECTED(Modifier.PROTECTED, true,\n-              Set.of(Location.FIELD, Location.METHOD, Location.INNER_CLASS)),\n+    PROTECTED(Modifier.PROTECTED, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n@@ -109,1 +119,1 @@\n-     * {@code 0x0008}.\n+     * <code>{@value Modifier#STATIC}<\/code>.\n@@ -111,2 +121,1 @@\n-    STATIC(Modifier.STATIC, true,\n-           Set.of(Location.FIELD, Location.METHOD, Location.INNER_CLASS)),\n+    STATIC(Modifier.STATIC, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n@@ -117,1 +126,1 @@\n-     * value of {@code 0x0010}.\n+     * value of <code>{@value Modifier#FINAL}<\/code>.\n@@ -126,0 +135,10 @@\n+     *\n+     * @apiNote\n+     * In Java SE 8 and above, the JVM treats the {@code ACC_SUPER}\n+     * flag as set in every class file (JVMS {@jvms 4.1}).\n+     * NOTE: The Valhalla draft JVMS spec does not define a value for ACC_SUPER.\n+     * Historically, the value 0x0020 was used to indicate ACC_SUPER, which affected the\n+     * semantics of any invokespecial instructions (6.5.invokespecial) appearing in the class.\n+     * In Java SE 8, the ACC_SUPER semantics became mandatory, regardless of the setting of\n+     * ACC_SUPER or the class file version number, and the flag no longer had any effect.\n+     * Now the flag has been repurposed as ACC_IDENTITY.\n@@ -127,1 +146,7 @@\n-    SUPER(0x0000_0020, false, Set.of(Location.CLASS)),\n+    SUPER(0x0000_0020, false, Location.SET_CLASS),\n+\n+    \/**\n+     * The access flag {@code ACC_IDENTITY} with a mask value of {@code 0x0020}.\n+     * @jls 4.1-B. Class access and property modifiers\n+     *\/\n+    IDENTITY(0x0000_0020, true, Set.of(Location.CLASS, Location.INNER_CLASS)),\n@@ -141,1 +166,1 @@\n-    TRANSITIVE(0x0000_0020, false, Set.of(Location.MODULE_REQUIRES)),\n+    TRANSITIVE(0x0000_0020, false, Location.SET_MODULE_REQUIRES),\n@@ -146,1 +171,1 @@\n-     * a mask value of {@code 0x0020}.\n+     * a mask value of <code>{@value Modifier#SYNCHRONIZED}<\/code>.\n@@ -148,1 +173,1 @@\n-    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Set.of(Location.METHOD)),\n+    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD),\n@@ -155,1 +180,7 @@\n-    STATIC_PHASE(0x0000_0040, false, Set.of(Location.MODULE_REQUIRES)),\n+    STATIC_PHASE(0x0000_0040, false, Location.SET_MODULE_REQUIRES),\n+\n+    \/**\n+     * The access flag {@code ACC_VALUE} with a mask value of {@code 0x0040}.\n+     * @jls 4.1-B. Class access and property modifiers\n+     *\/\n+    VALUE(0x0000_0040, true, Set.of(Location.CLASS, Location.INNER_CLASS)),\n@@ -157,1 +188,1 @@\n-     \/**\n+    \/**\n@@ -160,1 +191,1 @@\n-      * value of {@code 0x0040}.\n+      * value of <code>{@value Modifier#VOLATILE}<\/code>.\n@@ -162,1 +193,1 @@\n-    VOLATILE(Modifier.VOLATILE, true, Set.of(Location.FIELD)),\n+    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD),\n@@ -165,2 +196,2 @@\n-     * The access flag {@code ACC_BRIDGE} with a mask value of {@code\n-     * 0x0040}.\n+     * The access flag {@code ACC_BRIDGE} with a mask value of\n+     * <code>{@value Modifier#BRIDGE}<\/code>\n@@ -169,1 +200,1 @@\n-    BRIDGE(0x0000_0040, false, Set.of(Location.METHOD)),\n+    BRIDGE(Modifier.BRIDGE, false, Location.SET_METHOD),\n@@ -174,1 +205,1 @@\n-     * mask value of {@code 0x0080}.\n+     * mask value of <code>{@value Modifier#TRANSIENT}<\/code>.\n@@ -176,1 +207,1 @@\n-    TRANSIENT(Modifier.TRANSIENT, true, Set.of(Location.FIELD)),\n+    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD),\n@@ -179,2 +210,2 @@\n-     * The access flag {@code ACC_VARARGS} with a mask value of {@code\n-     * 0x0080}.\n+     * The access flag {@code ACC_VARARGS} with a mask value of\n+     <code>{@value Modifier#VARARGS}<\/code>.\n@@ -183,1 +214,1 @@\n-    VARARGS(0x0000_0080, false, Set.of(Location.METHOD)),\n+    VARARGS(Modifier.VARARGS, false, Location.SET_METHOD),\n@@ -187,2 +218,2 @@\n-     * modifier {@link Modifier#NATIVE native} with a mask value of {@code\n-     * 0x0100}.\n+     * modifier {@link Modifier#NATIVE native} with a mask value of\n+     * <code>{@value Modifier#NATIVE}<\/code>.\n@@ -190,1 +221,1 @@\n-    NATIVE(Modifier.NATIVE, true, Set.of(Location.METHOD)),\n+    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD),\n@@ -197,2 +228,1 @@\n-    INTERFACE(Modifier.INTERFACE, false,\n-              Set.of(Location.CLASS, Location.INNER_CLASS)),\n+    INTERFACE(Modifier.INTERFACE, false, Location.SET_CLASS_INNER_CLASS),\n@@ -203,1 +233,1 @@\n-     * value of {@code 0x0400}.\n+     * value of <code>{@value Modifier#ABSTRACT}<\/code>.\n@@ -208,0 +238,6 @@\n+    \/**\n+     * The access flag {@code ACC_PRIMITIVE} with a mask value of {@code 0x0800}.\n+     * @jls 4.1-B. Class access and property modifiers\n+     *\/\n+    PRIMITIVE(0x0000_0800, true, Set.of(Location.CLASS, Location.INNER_CLASS)),\n+\n@@ -211,1 +247,6 @@\n-     * {@code 0x0800}.\n+     * <code>{@value Modifier#STRICT}<\/code>.\n+     *\n+     * @apiNote\n+     * The {@code ACC_STRICT} access flag is defined for class file\n+     * major versions 46 through 60, inclusive (JVMS {@jvms 4.6}),\n+     * corresponding to Java SE 1.2 through 16.\n@@ -213,1 +254,1 @@\n-    STRICT(Modifier.STRICT, true, Set.of(Location.METHOD)),\n+    STRICT(Modifier.STRICT, true, Location.SET_METHOD),\n@@ -217,1 +258,1 @@\n-     * {@code 0x1000}.\n+     * <code>{@value Modifier#SYNTHETIC}<\/code>.\n@@ -222,1 +263,1 @@\n-    SYNTHETIC(0x0000_1000, false,\n+    SYNTHETIC(Modifier.SYNTHETIC, false,\n@@ -230,1 +271,1 @@\n-     * {@code 0x2000}.\n+     * <code>{@value Modifier#ANNOTATION}<\/code>.\n@@ -233,2 +274,1 @@\n-    ANNOTATION(0x0000_2000, false,\n-               Set.of(Location.CLASS, Location.INNER_CLASS)),\n+    ANNOTATION(Modifier.ANNOTATION, false, Location.SET_CLASS_INNER_CLASS),\n@@ -237,2 +277,2 @@\n-     * The access flag {@code ACC_ENUM} with a mask value of {@code\n-     * 0x4000}.\n+     * The access flag {@code ACC_ENUM} with a mask value of\n+     * <code>{@value Modifier#ENUM}<\/code>.\n@@ -241,1 +281,1 @@\n-    ENUM(0x0000_4000, false,\n+    ENUM(Modifier.ENUM, false,\n@@ -246,1 +286,1 @@\n-     * {@code 0x8000}.\n+     * <code>{@value Modifier#MANDATED}<\/code>.\n@@ -248,1 +288,1 @@\n-    MANDATED(0x0000_8000, false,\n+    MANDATED(Modifier.MANDATED, false,\n@@ -257,1 +297,1 @@\n-    MODULE(0x0000_8000, false, Set.of(Location.CLASS))\n+    MODULE(0x0000_8000, false, Location.SET_CLASS)\n@@ -263,2 +303,2 @@\n-    private int mask;\n-    private boolean sourceModifier;\n+    private final int mask;\n+    private final boolean sourceModifier;\n@@ -268,1 +308,1 @@\n-    private Set<Location> locations;\n+    private final Set<Location> locations;\n@@ -299,1 +339,1 @@\n-     * {@return a set of access flags for the given mask value\n+     * {@return an unmodifiable set of access flags for the given mask value\n@@ -309,0 +349,1 @@\n+        int unmatchedFlags = mask;\n@@ -313,1 +354,1 @@\n-                mask = mask & ~accessMask;\n+                unmatchedFlags = unmatchedFlags & ~accessMask;\n@@ -316,1 +357,1 @@\n-        if (mask != 0) {\n+        if (unmatchedFlags != 0) {\n@@ -318,1 +359,1 @@\n-                                               Integer.toHexString(mask) +\n+                                               Integer.toHexString(unmatchedFlags) +\n@@ -387,0 +428,10 @@\n+        \/\/ Repeated sets of locations used by AccessFlag constants\n+        private static final Set<Location> SET_FIELD_METHOD_INNER_CLASS =\n+            Set.of(FIELD, METHOD, INNER_CLASS);\n+        private static final Set<Location> SET_METHOD = Set.of(METHOD);\n+        private static final Set<Location> SET_FIELD = Set.of(FIELD);\n+        private static final Set<Location> SET_CLASS = Set.of(CLASS);\n+        private static final Set<Location> SET_CLASS_INNER_CLASS =\n+            Set.of(CLASS, INNER_CLASS);\n+        private static final Set<Location> SET_MODULE_REQUIRES =\n+            Set.of(MODULE_REQUIRES);\n@@ -392,1 +443,1 @@\n-                                Set.of(PUBLIC, FINAL, SUPER,\n+                                Set.of(PUBLIC, FINAL, SUPER, IDENTITY, VALUE, PRIMITIVE,\n@@ -406,1 +457,1 @@\n-                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n+                                Set.of(PUBLIC, PRIVATE, PROTECTED, IDENTITY, VALUE, PRIMITIVE,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":109,"deletions":58,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,5 +217,0 @@\n-     * @implSpec\n-     * Map this executable's {@linkplain #getModifiers() modifiers} to\n-     * access flags using {@link AccessFlag#maskToAccessFlags} for a\n-     * {@linkplain AccessFlag.Location#METHOD method location}\n-     *\n@@ -228,1 +223,2 @@\n-        return AccessFlag.maskToAccessFlags(getModifiers(), AccessFlag.Location.METHOD);\n+        return AccessFlag.maskToAccessFlags(getModifiers(),\n+                                            AccessFlag.Location.METHOD);\n@@ -277,3 +273,1 @@\n-    public int getParameterCount() {\n-        throw new AbstractMethodError();\n-    }\n+    public abstract int getParameterCount();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-     * The default implementation returns an empty set.\n+     * The default implementation throws {@link\n+     * UnsupportedOperationException}.\n@@ -96,1 +97,1 @@\n-        return Set.of();\n+        throw new UnsupportedOperationException();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Member.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n- * constants to decode class and member access modifiers.  The sets of\n- * modifiers are represented as integers with distinct bit positions\n+ * constants to decode class and member access modifiers.\n+ * The {@link AccessFlag} class should be used instead of this class.\n+ * The sets of modifiers are represented as integers with non-distinct bit positions\n@@ -38,0 +39,8 @@\n+ * <p>\n+ * This class cannot distinguish among modifiers for a class, method, or field.\n+ * The modifier masks are not unique; it is up to the caller to use the correct\n+ * mask or method with the modifier bits returned from {@link Class#getModifiers()}\n+ * or {@link Member#getModifiers()}.\n+ * The {@link AccessFlag} class provides a model that distinguishes between access flags\n+ * for classes, methods, and field. The {@link Class#accessFlags()} and {@link Member#accessFlags()}\n+ * methods provide the access flags for the respective class, method, or field.\n@@ -39,0 +48,2 @@\n+ * @see Class#accessFlags()\n+ * @see Member#accessFlags()\n@@ -125,12 +136,0 @@\n-    \/**\n-     * Return {@code true} if the integer argument includes the\n-     * {@code permitsValue} modifier, {@code false} otherwise.\n-     *\n-     * @param   mod a set of modifiers\n-     * @return {@code true} if {@code mod} includes the\n-     * {@code permitsValue} modifier; {@code false} otherwise.\n-     *\/\n-    public static boolean isPermitsValue(int mod) {\n-        return (mod & PERMITS_VALUE) != 0;\n-    }\n-\n@@ -308,6 +307,0 @@\n-    \/**\n-     * The {@code int} value representing the {@code permits_value}\n-     * modifier.\n-     *\/\n-    public static final int PERMITS_VALUE    = 0x00000040;\n-\n@@ -352,0 +345,1 @@\n+     * @see AccessFlag#STRICT\n@@ -359,3 +353,3 @@\n-    static final int BRIDGE      = 0x00000040;\n-    static final int VARARGS     = 0x00000080;\n-    static final int SYNTHETIC   = 0x00001000;\n+    static final int BRIDGE    = 0x00000040;\n+    static final int VARARGS   = 0x00000080;\n+    static final int SYNTHETIC = 0x00001000;\n@@ -363,2 +357,2 @@\n-    static final int ENUM        = 0x00004000;\n-    static final int MANDATED    = 0x00008000;\n+    static final int ENUM      = 0x00004000;\n+    static final int MANDATED  = 0x00008000;\n@@ -390,1 +384,1 @@\n-        Modifier.STRICT         | Modifier.PERMITS_VALUE;\n+        Modifier.STRICT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":20,"deletions":26,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -500,1 +500,1 @@\n-            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;\n+            int accessFlags = Modifier.PUBLIC | Modifier.FINAL | AccessFlag.IDENTITY.mask();\n@@ -511,1 +511,1 @@\n-                    accessFlags = Modifier.FINAL;  \/\/ non-public, final\n+                    accessFlags = Modifier.FINAL | AccessFlag.IDENTITY.mask();  \/\/ non-public, final, identity\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -685,2 +686,1 @@\n-        int mods = clazz.getModifiers();\n-        return (mods & 0x00000100) != 0;\n+        return (clazz.getModifiers() & AccessFlag.PRIMITIVE.mask()) != 0;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Type.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import static java.lang.reflect.Modifier.PERMITS_VALUE;\n@@ -54,0 +53,1 @@\n+    public static final int PERMITS_VALUE  = 0x0000_0040;   \/\/ Temp\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotModifiers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,3 @@\n-                                     AnotherEnum.class)) {\n+                                     AnotherEnum.class,\n+                                     AValueClass.class,\n+                                     APrimitiveClass.class)) {\n@@ -114,0 +116,6 @@\n+\n+@ExpectedGenericString(\"final value class AValueClass<E>\")\n+value class AValueClass<E> {}\n+\n+@ExpectedGenericString(\"final primitive class APrimitiveClass<E>\")\n+primitive class APrimitiveClass<E> {}\n","filename":"test\/jdk\/java\/lang\/Class\/GenericStringTest.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8266670\n+ * @bug 8266670 8281463\n@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -47,0 +48,4 @@\n+    \/*\n+     * Verify sourceModifier() == true access flags have a\n+     * corresponding constant in java.lang.reflect.Modifier.\n+     *\/\n@@ -49,0 +54,2 @@\n+        List<AccessFlag> valhallaOnly =\n+                List.of(AccessFlag.IDENTITY, AccessFlag.VALUE, AccessFlag.PRIMITIVE);\n@@ -51,1 +58,1 @@\n-            if (accessFlag.sourceModifier()) {\n+            if (accessFlag.sourceModifier()  && !valhallaOnly.contains(accessFlag)) {\n@@ -97,1 +104,1 @@\n-        \/\/ Then test for disjointness\n+        \/\/ ...then test for disjointness\n@@ -110,0 +117,2 @@\n+                if (accessFlag.equals(AccessFlag.SUPER))\n+                    continue;       \/\/ SUPER is defined to overlap with IDENTITY\n@@ -139,1 +148,3 @@\n-                if (!expectedSet.equals(computedSet)) {\n+                if (!computedSet.containsAll(expectedSet)) {\n+                    System.out.println(\"expected: \" + expectedSet);\n+                    System.out.println(\"computed: \" + computedSet);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected AccessFlag's on classes.\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+\/*\n+ * Class access flags that can directly or indirectly declared in\n+ * source include:\n+ * public, private, protected, static, final, interface, abstract,\n+ * annotation, enum.\n+ *\n+ * Additionally, the access flags super and synthetic cannot be\n+ * explicitly applied.\n+ *\/\n+public class ClassAccessFlagTest {\n+    public static void main(String... args) {\n+        for (var clazz :\n+                 ClassAccessFlagTest.class.getDeclaredClasses()) {\n+            checkClass(clazz);\n+        }\n+        checkClass(TestInterface.class);\n+        checkClass(ExpectedClassFlags.class);\n+        checkPrimitives();\n+        checkArrays();\n+    }\n+\n+    private static void checkClass(Class<?> clazz) {\n+        ExpectedClassFlags expected =\n+            clazz.getAnnotation(ExpectedClassFlags.class);\n+        if (expected != null) {\n+            String actual = clazz.accessFlags().toString();\n+            if (!expected.value().equals(actual)) {\n+                throw new RuntimeException(\"On \" + clazz +\n+                                           \" expected \" + expected.value() +\n+                                           \" got \" + actual);\n+            }\n+        }\n+    }\n+\n+    private static void checkPrimitives() {\n+        final Class<?>[] primitives = {\n+            byte.class,\n+            int.class,\n+            long.class,\n+            short.class,\n+            char.class,\n+            float.class,\n+            double.class,\n+            boolean.class,\n+            void.class \/\/ same access flag rules\n+        };\n+\n+        var mustBePresent = Set.of(AccessFlag.PUBLIC, AccessFlag.FINAL);\n+        var mustBeAbsent = Set.of(AccessFlag.PRIVATE,\n+                                  AccessFlag.PROTECTED,\n+                                  AccessFlag.INTERFACE);\n+\n+        for(var primClass : primitives) {\n+            \/\/ PUBLIC must be present, PROTECTED and PRIVATE must be\n+            \/\/ absent.\n+            \/\/ FINAL must be present, INTERFACE must be absent.\n+            var accessFlags = primClass.accessFlags();\n+            if (!accessFlags.containsAll(mustBePresent)) {\n+                throw new RuntimeException(\"Missing mandatory flags on \" +\n+                                           primClass);\n+            }\n+\n+            if (containsAny(accessFlags, mustBeAbsent)) {\n+                throw new RuntimeException(\"Unexpected flags present on \" +\n+                                           primClass);\n+            }\n+        }\n+    }\n+\n+    private static boolean containsAny(Set<AccessFlag> input,\n+                                       Set<AccessFlag> test) {\n+        var copy = new HashSet<>(input);\n+        return copy.removeAll(test);\n+    }\n+\n+    private static void checkArrays() {\n+        Class<?>[] accessClasses = {\n+            PublicInterface.class,\n+            ProtectedInterface.class,\n+            PrivateInterface.class,\n+        };\n+\n+        for (var accessClass : accessClasses) {\n+            AccessFlag accessLevel;\n+            var flags = accessClass.accessFlags();\n+            if (flags.contains(AccessFlag.PUBLIC))\n+                accessLevel = AccessFlag.PUBLIC;\n+            else if (flags.contains(AccessFlag.PROTECTED))\n+                accessLevel = AccessFlag.PROTECTED;\n+            else if (flags.contains(AccessFlag.PRIVATE))\n+                accessLevel = AccessFlag.PRIVATE;\n+            else\n+                accessLevel = null;\n+\n+            var arrayClass = accessClass.arrayType();\n+            \/\/ Access modifier must match on the array type\n+            if (accessLevel != null) {\n+                if (!arrayClass.accessFlags().contains(accessLevel)) {\n+                    throw new RuntimeException(\"Mismatched access flags on \" +\n+                                               arrayClass);\n+                }\n+            } else {\n+                if (containsAny(arrayClass.accessFlags(),\n+                                Set.of(AccessFlag.PUBLIC,\n+                                       AccessFlag.PROTECTED,\n+                                       AccessFlag.PRIVATE))) {\n+                    throw new RuntimeException(\"Unexpected access flags on \" +\n+                                               arrayClass);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    public      interface PublicInterface {}\n+    protected   interface ProtectedInterface {}\n+    private     interface PrivateInterface {}\n+    \/*package*\/ interface PackageInterface {}\n+\n+    \/\/ Classes\n+    @ExpectedClassFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+    public enum MetaSynVar {\n+        QUUX;\n+    }\n+\n+    \/\/ Is there is at least one special enum constant, the enum class\n+    \/\/ itself is implicitly abstract rather than final.\n+    @ExpectedClassFlags(\"[PROTECTED, STATIC, ABSTRACT, ENUM]\")\n+    protected enum MetaSynVar2 {\n+        WOMBAT{\n+            @Override\n+            public int foo() {return 42;}\n+        };\n+        public abstract int foo();\n+    }\n+\n+    @ExpectedClassFlags(\"[PRIVATE, ABSTRACT]\")\n+    private abstract class Foo {}\n+\n+    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    interface StaticTestInterface {}\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@ExpectedClassFlags(\"[INTERFACE, ABSTRACT, ANNOTATION]\")\n+@interface ExpectedClassFlags {\n+    String value();\n+}\n+\n+@ExpectedClassFlags(\"[INTERFACE, ABSTRACT]\")\n+interface TestInterface {}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected AccessFlag's on fields.\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+\n+\/*\n+ * Field modifiers include:\n+ * public, private, protected, static, final, volatile, transient,\n+ *\n+ * Additionall, the access flags enum and synthetic cannot be\n+ * explicitly applied.\n+ *\/\n+public class FieldAccessFlagTest {\n+    public static void main(String... args) {\n+        for (var field :\n+                 FieldAccessFlagTest.class.getDeclaredFields()) {\n+            checkField(field);\n+        }\n+\n+        for (var field :\n+                 MetaSynVar.class.getDeclaredFields()) {\n+            checkField(field);\n+        }\n+    }\n+\n+    private static void checkField(Field field) {\n+        ExpectedFieldFlags expected =\n+            field.getAnnotation(ExpectedFieldFlags.class);\n+        if (expected != null) {\n+            String actual = field.accessFlags().toString();\n+            if (!expected.value().equals(actual)) {\n+                throw new RuntimeException(\"On \" + field +\n+                                           \" expected \" + expected.value() +\n+                                           \" got \" + actual);\n+            }\n+        }\n+    }\n+\n+    \/\/ Fields\n+    @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL]\")\n+    public static final String f1 = \"foo\";\n+\n+    @ExpectedFieldFlags(\"[PRIVATE, VOLATILE, TRANSIENT]\")\n+    private volatile transient String secret = \"xxyzzy\";\n+\n+    @ExpectedFieldFlags(\"[PROTECTED]\")\n+    protected String meadow = \"\";\n+\n+    \/\/ Enum constant should have the enum access flag set\n+    static enum MetaSynVar {\n+        @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+        FOO,\n+\n+        @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+        BAR;\n+\n+        @ExpectedFieldFlags(\"[PRIVATE]\") \/\/ no \"ENUM\"\n+        private int field = 0;\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    private @interface ExpectedFieldFlags {\n+        String value();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/FieldAccessFlagTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected AccessFlag's on methods and parameters\n+ * @compile -parameters MethodAccessFlagTest.java\n+ * @run main MethodAccessFlagTest\n+ *\/\n+\n+\/\/ Use -parameters flag to javac to have access flag information about\n+\/\/ parameters preserved in the resulting class file.\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+\n+\/*\n+ * Method modifiers include:\n+ * public, private, protected, static, final, synchronized,\n+ * bridge, varargs, native, abstract, strictfp, synthetic,\n+ *\n+ * At a source level, constructors can have modifiers public,\n+ * protected, or private.\n+ *\n+ * The modifiers bridge and synthetic cannot be applied directly and\n+ * strictfp can only be applied in older source versions.\n+ *\n+ * Method parameters can be final, synthetic, and mandated.\n+ *\/\n+public abstract class MethodAccessFlagTest {\n+    @ExpectedMethodFlags(\"[PUBLIC, STATIC, VARARGS]\")\n+    public static void main(String... args) {\n+        for (var ctor :\n+                 MethodAccessFlagTest.class.getDeclaredConstructors()) {\n+            checkExecutable(ctor);\n+        }\n+\n+        for (var method :\n+                 MethodAccessFlagTest.class.getDeclaredMethods()) {\n+            checkExecutable(method);\n+        }\n+\n+        \/\/ Hard-code information about parameter modifiers; could be\n+        \/\/ represented as annotations on the class and decoded.\n+        for (var ctor : NestedClass.class.getConstructors()) {\n+            for (var parameter : ctor.getParameters()) {\n+                String expected = null;\n+                if (parameter.getType() == int.class) {\n+                    \/\/ The explicit int parameter is expected to have\n+                    \/\/ the final flag\n+                    expected = \"[FINAL]\";\n+                } else {\n+                    \/\/ The implicit this$0 parameter is expected to have the\n+                    \/\/ final and mandated flags\n+                    expected = \"[FINAL, MANDATED]\";\n+                }\n+                checkString(parameter.toString(),\n+                            parameter.accessFlags().toString(),\n+                            expected);\n+            }\n+        }\n+\n+        for (var method : BridgeExample.class.getDeclaredMethods()) {\n+            \/\/ Find the two \"clone\" methods, one implicit and one\n+            \/\/ explicit\n+            if (!method.getName().equals(\"clone\")) {\n+                throw new RuntimeException(\"Unexpected name for \" + method);\n+            }\n+            String expected = null;\n+            if (method.getReturnType() == Object.class) {\n+                expected = \"[PUBLIC, BRIDGE, SYNTHETIC]\";\n+            } else {\n+                expected = \"[PUBLIC]\";\n+            }\n+            checkString(method.toString(),\n+                        method.accessFlags().toString(),\n+                        expected);\n+        }\n+\n+        \/\/ Hard-code information about parameter modifiers; could be\n+        \/\/ represented as annotations on the class and decoded.\n+        for (var ctor : TestEnum.class.getDeclaredConstructors()) {\n+            \/\/ Each of the two parameters used in javac's enum\n+            \/\/ constructor implementation is synthetic. This may need\n+            \/\/ to be updated if javac's enum constructor generation\n+            \/\/ idiom changes.\n+            for (var parameter : ctor.getParameters()) {\n+                checkString(parameter.toString(),\n+                            parameter.accessFlags().toString(),\n+                            \"[SYNTHETIC]\");\n+            }\n+        }\n+\n+    }\n+\n+    class NestedClass {\n+        private int i;\n+        \/\/ Implicit leading parameter\n+        public NestedClass(final int i) {\n+            this.i = i;\n+        }\n+    }\n+\n+    class BridgeExample implements Cloneable {\n+        public BridgeExample(){}\n+        \/\/ Triggers generation of a bridge method.\n+        public BridgeExample clone() {\n+            return new BridgeExample();\n+        }\n+    }\n+\n+    \/\/ Use as a host for a constructor with synthetic parameters\n+    enum TestEnum {\n+        INSTANCE;\n+    }\n+\n+    private static void checkExecutable(Executable method) {\n+        ExpectedMethodFlags emf =\n+            method.getAnnotation(ExpectedMethodFlags.class);\n+        if (emf != null) {\n+            String actual = method.accessFlags().toString();\n+            checkString(method.toString(), emf.value(), actual);\n+        }\n+    }\n+\n+    private static void checkString(String declaration,\n+                               String expected,\n+                               String actual) {\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"On \" + declaration +\n+                                       \" expected \" + expected +\n+                                       \" got \" + actual);\n+        }\n+    }\n+\n+    \/\/ Constructors\n+    @ExpectedMethodFlags(\"[PUBLIC]\")\n+    public MethodAccessFlagTest() {}\n+\n+    @ExpectedMethodFlags(\"[PROTECTED]\")\n+    protected MethodAccessFlagTest(int i) {super();}\n+\n+    @ExpectedMethodFlags(\"[PRIVATE]\")\n+    private MethodAccessFlagTest(String s) {super();}\n+\n+    \/\/ Methods\n+    @ExpectedMethodFlags(\"[PROTECTED, SYNCHRONIZED]\")\n+    protected synchronized void m0() {}\n+\n+    @ExpectedMethodFlags(\"[PRIVATE]\")\n+    private void m1() {}\n+\n+    @ExpectedMethodFlags(\"[ABSTRACT]\")\n+    abstract void m2();\n+\n+    @ExpectedMethodFlags(\"[PUBLIC, FINAL]\")\n+    public final void m3() {}\n+\n+    @ExpectedMethodFlags(\"[NATIVE]\")\n+    native void m4();\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    private @interface ExpectedMethodFlags {\n+        String value();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/MethodAccessFlagTest.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected AccessFlag's on module-related structures.\n+ *\/\n+\n+import java.lang.reflect.AccessFlag;\n+import java.lang.module.*;\n+import java.util.Set;\n+\n+public class ModuleDescriptorAccessFlagTest {\n+    public static void main(String... args) {\n+        \/\/ Test ModuleDescriptor.Modifier\n+        var openMod = ModuleDescriptor.newModule(\"foo\",\n+                                                 Set.of(ModuleDescriptor.Modifier.OPEN,\n+                                                        ModuleDescriptor.Modifier.SYNTHETIC,\n+                                                        ModuleDescriptor.Modifier.MANDATED)).build();\n+        checkAccessFlags(openMod, openMod.accessFlags(), \"[OPEN, SYNTHETIC, MANDATED]\");\n+        \/\/ AUTOMATIC does not have a corresponding access flag so is\n+        \/\/ *not* tested here.\n+\n+        \/\/ Test ModuleDescriptor.Requires.Modifier\n+        var requireMod = ModuleDescriptor.newModule(\"bar\")\n+            .requires(Set.of(ModuleDescriptor.Requires.Modifier.STATIC,\n+                             ModuleDescriptor.Requires.Modifier.SYNTHETIC,\n+                             ModuleDescriptor.Requires.Modifier.TRANSITIVE), \"baz\")\n+            .build();\n+\n+        for (ModuleDescriptor.Requires requires : requireMod.requires()) {\n+            if (\"java.base\".equals(requires.name())) {\n+                checkAccessFlags(requires, requires.accessFlags(), \"[MANDATED]\");\n+            } else {\n+                \/\/ Note \"STATIC_PHASE\" rather than \"STATIC\"\n+                checkAccessFlags(requires, requires.accessFlags(), \"[TRANSITIVE, STATIC_PHASE, SYNTHETIC]\");\n+            }\n+        }\n+\n+        \/\/ Test ModuleDescriptor.Exports.Modifier\n+        var exportMod = ModuleDescriptor.newModule(\"baz\")\n+            .exports(Set.of(ModuleDescriptor.Exports.Modifier.MANDATED,\n+                            ModuleDescriptor.Exports.Modifier.SYNTHETIC), \"quux\")\n+            .build();\n+        for (ModuleDescriptor.Exports exports : exportMod.exports()) {\n+            checkAccessFlags(exports, exports.accessFlags(), \"[SYNTHETIC, MANDATED]\");\n+        }\n+\n+        \/\/ Test ModuleDescriptor.Opens.Modifier\n+        var opensMod = ModuleDescriptor.newModule(\"quux\")\n+            .exports(Set.of(ModuleDescriptor.Exports.Modifier.MANDATED,\n+                            ModuleDescriptor.Exports.Modifier.SYNTHETIC), \"xxyzzy\")\n+            .build();\n+        for (ModuleDescriptor.Opens opens : exportMod.opens()) {\n+            checkAccessFlags(opens, opens.accessFlags(), \"[SYNTHETIC, MANDATED]\");\n+        }\n+    }\n+\n+    private static void checkAccessFlags(Object o, Set<AccessFlag> accessFlags, String expected) {\n+        String actual = accessFlags.toString();\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"On \" + o.toString() +\n+                                       \" expected \" + expected +\n+                                       \" got \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ModuleDescriptorAccessFlagTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266670\n+ * @summary Test expected value of STRICT AccessFlag\n+ * @compile -source 16 -target 16 StrictAccessFlagTest.java\n+ * @run main StrictAccessFlagTest\n+ *\/\n+\n+\/\/ Note: cannot use --release 16 because the accessFlags() method is\n+\/\/ not found in release 16; therefore -source and -target are used\n+\/\/ instead.\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+\n+\/*\n+ * Test expected value of ACC_STRICT access flag.\n+ *\/\n+\/\/ Declaring the class strictfp implicitly sets ACC_STRICT on all its\n+\/\/ methods and constructors.\n+public strictfp class StrictAccessFlagTest {\n+    @ExpectedFlags(\"[PUBLIC, STATIC, VARARGS, STRICT]\")\n+    public static void main(String... args) {\n+        for (var ctor :\n+                 StrictAccessFlagTest.class.getDeclaredConstructors()) {\n+            checkExecutable(ctor);\n+        }\n+\n+        for (var method :\n+                 StrictAccessFlagTest.class.getDeclaredMethods()) {\n+            checkExecutable(method);\n+        }\n+    }\n+\n+    private static void checkExecutable(Executable method) {\n+        ExpectedFlags expected =\n+            method.getAnnotation(ExpectedFlags.class);\n+        if (expected != null) {\n+            String actual = method.accessFlags().toString();\n+            if (!expected.value().equals(actual)) {\n+                throw new RuntimeException(\"On \" + method +\n+                                           \" expected \" + expected.value() +\n+                                           \" got \" + actual);\n+            }\n+        }\n+    }\n+\n+    \/\/ Constructor\n+    @ExpectedFlags(\"[PUBLIC, STRICT]\")\n+    public StrictAccessFlagTest() {}\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    private @interface ExpectedFlags {\n+        String value();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/StrictAccessFlagTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,2 @@\n+            throw new AssertionError(\"Primitive flag missing\");\n+        if ((Inner.class.getModifiers() & AccessFlags.ACC_VALUE) == 0)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/InnerClassAttributeValuenessTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}