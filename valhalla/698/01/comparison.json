{"files":[{"patch":"@@ -167,1 +167,1 @@\n-            STATIC(AccessFlag.STATIC.mask()),\n+            STATIC(AccessFlag.STATIC_PHASE.mask()),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,0 +126,7 @@\n+     * <p>\n+     * NOTE: The Valhalla draft JVMS spec does not define a value for ACC_SUPER.\n+     * Historically, the value 0x0020 was used to indicate ACC_SUPER, which affected the\n+     * semantics of any invokespecial instructions (6.5.invokespecial) appearing in the class.\n+     * In Java SE 8, the ACC_SUPER semantics became mandatory, regardless of the setting of\n+     * ACC_SUPER or the class file version number, and the flag no longer had any effect.\n+     * Now the flag has been repurposed as ACC_IDENTITY.\n@@ -129,0 +136,7 @@\n+    \/**\n+     * The access flag {@code ACC_IDENTITY} corresponding to the\n+     * source modifier {@link Modifier#VALUE value} with a mask\n+     * value of {@code 0x0020}.\n+     *\/\n+    IDENTITY(Modifier.IDENTITY, true, Set.of(Location.CLASS)),\n+\n@@ -157,1 +171,8 @@\n-     \/**\n+    \/**\n+     * The access flag {@code ACC_VALUE} corresponding to the\n+     * source modifier {@link Modifier#VALUE value} with a mask\n+     * value of {@code 0x0040}.\n+     *\/\n+    VALUE(Modifier.VALUE, true, Set.of(Location.CLASS)),\n+\n+    \/**\n@@ -208,0 +229,7 @@\n+    \/**\n+     * The access flag {@code ACC_PRIMITIVE}, corresponding to the source\n+     * modifier {@link Modifier#PRIMITIVE primitive} with a mask\n+     * value of {@code 0x0800}.\n+     *\/\n+    PRIMITIVE(Modifier.PRIMITIVE, true, Set.of(Location.CLASS)),\n+\n@@ -392,1 +420,1 @@\n-                                Set.of(PUBLIC, FINAL, SUPER,\n+                                Set.of(PUBLIC, FINAL, IDENTITY, VALUE, PRIMITIVE,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n- * constants to decode class and member access modifiers.  The sets of\n- * modifiers are represented as integers with distinct bit positions\n+ * constants to decode class and member access modifiers.\n+ * The {@link AccessFlag} class should be used instead of this class.\n+ * The sets of modifiers are represented as integers with non-distinct bit positions\n@@ -38,0 +39,8 @@\n+ * <p>\n+ * This class cannot distinguish among modifiers for a class, method, or field.\n+ * The modifier masks are not unique; it is up to the caller to use the correct\n+ * mask or method with the modifier bits returned from {@link Class#getModifiers()}\n+ * or {@link Member#getModifiers()}.\n+ * The {@link AccessFlag} class provides a model that distinguishes between access flags\n+ * for classes, methods, and field. The {@link Class#accessFlags()} and {@link Member#accessFlags()}\n+ * methods provide the access flags for the respective class, method, or field.\n@@ -39,0 +48,2 @@\n+ * @see Class#accessFlags()\n+ * @see Member#accessFlags()\n@@ -125,12 +136,0 @@\n-    \/**\n-     * Return {@code true} if the integer argument includes the\n-     * {@code permitsValue} modifier, {@code false} otherwise.\n-     *\n-     * @param   mod a set of modifiers\n-     * @return {@code true} if {@code mod} includes the\n-     * {@code permitsValue} modifier; {@code false} otherwise.\n-     *\/\n-    public static boolean isPermitsValue(int mod) {\n-        return (mod & PERMITS_VALUE) != 0;\n-    }\n-\n@@ -236,0 +235,3 @@\n+     * @apiNote TBD: This method does not reflect the class related modifiers including\n+     * {@link #IDENTITY}, {@link #VALUE}, and {@link #PRIMITIVE}.\n+     *\n@@ -301,0 +303,7 @@\n+    \/**\n+     * The {@code int} value representing the {@code ACC_IDENTITY}\n+     * modifier when applied to the modifiers of a class.\n+     * @see AccessFlag#IDENTITY\n+     *\/\n+    public static final int IDENTITY         = 0x00000020;\n+\n@@ -309,2 +318,3 @@\n-     * The {@code int} value representing the {@code permits_value}\n-     * modifier.\n+     * The {@code int} value representing the {@code ACC_VALUE}\n+     * modifier when applied to the modifiers of a class.\n+     * @see AccessFlag#VALUE\n@@ -312,1 +322,1 @@\n-    public static final int PERMITS_VALUE    = 0x00000040;\n+    public static final int VALUE            = 0x00000040;\n@@ -355,0 +365,7 @@\n+    \/**\n+     * The {@code int} value representing the {@code ACC_PRIMITIVE}\n+     * modifier when applied to the modifiers of a class.\n+     * @see AccessFlag#PRIMITIVE\n+     *\/\n+    public static final int PRIMITIVE        = 0x00000800;\n+\n@@ -359,3 +376,3 @@\n-    static final int BRIDGE      = 0x00000040;\n-    static final int VARARGS     = 0x00000080;\n-    static final int SYNTHETIC   = 0x00001000;\n+    static final int BRIDGE    = 0x00000040;\n+    static final int VARARGS   = 0x00000080;\n+    static final int SYNTHETIC = 0x00001000;\n@@ -363,2 +380,2 @@\n-    static final int ENUM        = 0x00004000;\n-    static final int MANDATED    = 0x00008000;\n+    static final int ENUM      = 0x00004000;\n+    static final int MANDATED  = 0x00008000;\n@@ -389,0 +406,1 @@\n+        Modifier.IDENTITY       | Modifier.VALUE        | Modifier.PRIMITIVE |\n@@ -390,1 +408,1 @@\n-        Modifier.STRICT         | Modifier.PERMITS_VALUE;\n+        Modifier.STRICT;\n@@ -398,0 +416,1 @@\n+        Modifier.IDENTITY       | Modifier.VALUE        |\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":42,"deletions":23,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import static java.lang.reflect.Modifier.PERMITS_VALUE;\n@@ -54,0 +53,1 @@\n+    public static final int PERMITS_VALUE  = 0x0000_0040;   \/\/ Temp\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotModifiers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,3 +35,7 @@\n-        if(!Modifier.toString(test).equals(expected))\n-            throw new RuntimeException(test +\n-                                          \" yields incorrect toString result\");\n+        String actual = Modifier.toString(test);\n+        if(!actual.equals(expected)) {\n+            System.out.println(\"Actual:   \" + actual);\n+            System.out.println(\"Expected: \" + expected);\n+\n+            throw new RuntimeException(Integer.toHexString(test) + \" yields incorrect toString result\");\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/Modifier\/toStringTest.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"}]}