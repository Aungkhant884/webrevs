{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4895,4 +4895,1 @@\n-    if (strstr(inner_class, \"VectorPayloadMF64\")  ||\n-        strstr(inner_class, \"VectorPayloadMF128\") ||\n-        strstr(inner_class, \"VectorPayloadMF256\") ||\n-        strstr(inner_class, \"VectorPayloadMF512\")) {\n+    if (strstr(inner_class, \"VectorPayloadMF\")) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,0 +196,10 @@\n+  do_klass(vector_VectorPayloadMF8Z_klass,              jdk_internal_vm_vector_VectorPayloadMF8Z              ) \\\n+  do_klass(vector_VectorPayloadMF16Z_klass,             jdk_internal_vm_vector_VectorPayloadMF16Z             ) \\\n+  do_klass(vector_VectorPayloadMF32Z_klass,             jdk_internal_vm_vector_VectorPayloadMF32Z             ) \\\n+  do_klass(vector_VectorPayloadMF64Z_klass,             jdk_internal_vm_vector_VectorPayloadMF64Z             ) \\\n+  do_klass(vector_VectorPayloadMF128Z_klass,            jdk_internal_vm_vector_VectorPayloadMF128Z            ) \\\n+  do_klass(vector_VectorPayloadMF256Z_klass,            jdk_internal_vm_vector_VectorPayloadMF256Z            ) \\\n+  do_klass(vector_VectorPayloadMF512Z_klass,            jdk_internal_vm_vector_VectorPayloadMF512Z            ) \\\n+  do_klass(vector_VectorPayloadMF8B_klass,              jdk_internal_vm_vector_VectorPayloadMF8B              ) \\\n+  do_klass(vector_VectorPayloadMF16B_klass,             jdk_internal_vm_vector_VectorPayloadMF16B             ) \\\n+  do_klass(vector_VectorPayloadMF32B_klass,             jdk_internal_vm_vector_VectorPayloadMF32B             ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,6 +91,16 @@\n-  template(jdk_internal_vm_vector_VectorSupport,      \"jdk\/internal\/vm\/vector\/VectorSupport\")               \\\n-  template(jdk_internal_vm_vector_VectorPayload,      \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload\") \\\n-  template(jdk_internal_vm_vector_Vector,             \"jdk\/internal\/vm\/vector\/VectorSupport$Vector\")        \\\n-  template(jdk_internal_vm_vector_VectorMask,         \"jdk\/internal\/vm\/vector\/VectorSupport$VectorMask\")    \\\n-  template(jdk_internal_vm_vector_VectorShuffle,      \"jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle\") \\\n-  template(jdk_internal_vm_vector_VectorPayloadMF,    \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF\")    \\\n+  template(jdk_internal_vm_vector_VectorSupport,       \"jdk\/internal\/vm\/vector\/VectorSupport\")                     \\\n+  template(jdk_internal_vm_vector_VectorPayload,       \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload\")       \\\n+  template(jdk_internal_vm_vector_Vector,              \"jdk\/internal\/vm\/vector\/VectorSupport$Vector\")              \\\n+  template(jdk_internal_vm_vector_VectorMask,          \"jdk\/internal\/vm\/vector\/VectorSupport$VectorMask\")          \\\n+  template(jdk_internal_vm_vector_VectorShuffle,       \"jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle\")       \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF,     \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF\")     \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF8Z,   \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8Z\")   \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF16Z,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16Z\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF32Z,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32Z\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64Z,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64Z\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128Z, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128Z\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256Z, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256Z\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512Z, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512Z\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF8B,   \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8B\")   \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF16B,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16B\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF32B,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32B\")  \\\n@@ -121,4 +131,4 @@\n-  template(payload_name,                               \"payload\")                                 \\\n-  template(mfield_name,                                \"mfield\")                                  \\\n-  template(ETYPE_name,                                 \"ETYPE\")                                   \\\n-  template(VLENGTH_name,                               \"VLENGTH\")                                 \\\n+  template(payload_name,                               \"payload\")                                                  \\\n+  template(mfield_name,                                \"mfield\")                                                   \\\n+  template(ETYPE_name,                                 \"ETYPE\")                                                    \\\n+  template(VLENGTH_name,                               \"VLENGTH\")                                                  \\\n@@ -296,0 +306,10 @@\n+  template(vector_VectorPayloadMF8Z_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8Z;\")   \\\n+  template(vector_VectorPayloadMF16Z_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16Z;\")  \\\n+  template(vector_VectorPayloadMF32Z_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32Z;\")  \\\n+  template(vector_VectorPayloadMF64Z_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64Z;\")  \\\n+  template(vector_VectorPayloadMF128Z_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128Z;\") \\\n+  template(vector_VectorPayloadMF256Z_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256Z;\") \\\n+  template(vector_VectorPayloadMF512Z_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512Z;\") \\\n+  template(vector_VectorPayloadMF8B_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8B;\")   \\\n+  template(vector_VectorPayloadMF16B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16B;\")  \\\n+  template(vector_VectorPayloadMF32B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32B;\")  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,7 +90,9 @@\n-  InlineTypeNode* vt = in(1)->isa_InlineType();\n-  if (vt != NULL && phase->type(vt)->filter_speculative(_type) != Type::TOP) {\n-    Node* cast = clone();\n-    cast->set_req(1, vt->get_oop());\n-    vt = vt->clone()->as_InlineType();\n-    vt->set_oop(phase->transform(cast));\n-    return vt;\n+  if (in(1)->is_InlineType() && !in(1)->is_VectorBox()) {\n+    InlineTypeNode* vt = in(1)->as_InlineType();\n+    if (phase->type(vt)->filter_speculative(_type) != Type::TOP) {\n+      Node* cast = clone();\n+      cast->set_req(1, vt->get_oop());\n+      vt = vt->clone()->as_InlineType();\n+      vt->set_oop(phase->transform(cast));\n+      return vt;\n+    }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -919,1 +919,1 @@\n-  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector = false);\n+  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -428,1 +428,1 @@\n-      if (base->is_Con() && !is_array && !mismatched) {\n+      if (base->is_Con() && !is_array && !mismatched && ft->bundle_size() == 1) {\n@@ -443,6 +443,0 @@\n-        BasicType bt = con_type->basic_type();\n-        int vec_len = field->secondary_fields_count();\n-        if (field->is_multifield_base() &&\n-          Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n-          value = kit->gvn().transform(VectorNode::scalar2vector(value, vec_len, Type::get_const_type(field->type()), false));\n-        }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2321,1 +2321,3 @@\n-      assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n+      if (alloc != NULL) {\n+        assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n+      }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"prims\/vectorSupport.hpp\"\n@@ -36,16 +35,0 @@\n-static bool is_vector(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_Vector_klass());\n-}\n-\n-static bool is_vector_payload_mf(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayloadMF_klass());\n-}\n-\n-static bool is_vector_mask(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-}\n-\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n@@ -248,69 +231,0 @@\n-\n-  ciInstanceKlass* iklass = vec_box->box_type()->instance_klass();\n-  \/\/ Multi-field based vectors are InlineTypeNodes and are already\n-  \/\/ scalarized by process_inline_types.\n-  if (is_vector(iklass)) {\n-    return;\n-  }\n-\n-  \/\/ Process debug uses at safepoints\n-  Unique_Node_List safepoints(C->comp_arena());\n-\n-  Unique_Node_List worklist(C->comp_arena());\n-  worklist.push(vec_box);\n-  while (worklist.size() > 0) {\n-    Node* n = worklist.pop();\n-    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-      Node* use = n->fast_out(i);\n-      if (use->is_SafePoint()) {\n-        SafePointNode* sfpt = use->as_SafePoint();\n-        if (!sfpt->is_Call() || !sfpt->as_Call()->has_non_debug_use(n)) {\n-          safepoints.push(sfpt);\n-        }\n-      } else if (use->is_ConstraintCast()) {\n-        worklist.push(use); \/\/ reversed version of Node::uncast()\n-      }\n-    }\n-  }\n-\n-  int n_fields = iklass->nof_nonstatic_fields();\n-  assert(n_fields == 1, \"sanity\");\n-\n-  \/\/ If a mask is feeding into safepoint[s], then its value should be\n-  \/\/ packed into a boolean\/byte vector first, this will simplify the\n-  \/\/ re-materialization logic for both predicated and non-predicated\n-  \/\/ targets.\n-  bool is_mask = is_vector_mask(iklass);\n-  if (is_mask && vec_value->Opcode() != Op_VectorStoreMask) {\n-    const TypeVect* vt = vec_value->bottom_type()->is_vect();\n-    BasicType bt = vt->element_basic_type();\n-    vec_value = gvn.transform(VectorStoreMaskNode::make(gvn, vec_value, bt, vt->length()));\n-  }\n-\n-  while (safepoints.size() > 0) {\n-    SafePointNode* sfpt = safepoints.pop()->as_SafePoint();\n-\n-    uint first_ind = (sfpt->req() - sfpt->jvms()->scloff());\n-    Node* sobj = new SafePointScalarObjectNode(vec_box->box_type(),\n-#ifdef ASSERT\n-                                               vec_box,\n-#endif \/\/ ASSERT\n-                                               first_ind, n_fields);\n-    sobj->init_req(0, C->root());\n-    sfpt->add_req(vec_value);\n-\n-    sobj = gvn.transform(sobj);\n-\n-    JVMState *jvms = sfpt->jvms();\n-\n-    jvms->set_endoff(sfpt->req());\n-    \/\/ Now make a pass over the debug information replacing any references\n-    \/\/ to the allocated object with vector value.\n-    for (uint i = jvms->debug_start(); i < jvms->debug_end(); i++) {\n-      Node* debug = sfpt->in(i);\n-      if (debug != NULL && debug->uncast(\/*keep_deps*\/false) == vec_box) {\n-        sfpt->set_req(i, sobj);\n-      }\n-    }\n-    C->record_for_igvn(sfpt);\n-  }\n@@ -323,1 +237,1 @@\n-    Node* result = expand_vbox_node_helper(vbox, vect, vec_box->box_type(), vec_box->vec_type());\n+    Node* result = expand_vbox_node_helper(vec_box, vbox, vect, vec_box->box_type(), vec_box->vec_type());\n@@ -330,1 +244,2 @@\n-Node* PhaseVector::expand_vbox_node_helper(Node* vbox,\n+Node* PhaseVector::expand_vbox_node_helper(VectorBoxNode* vec_box,\n+                                           Node* vbox,\n@@ -338,1 +253,1 @@\n-      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect->in(i), box_type, vect_type);\n+      Node* new_box = expand_vbox_node_helper(vec_box, vbox->in(i), vect->in(i), box_type, vect_type);\n@@ -353,1 +268,1 @@\n-      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect, box_type, vect_type);\n+      Node* new_box = expand_vbox_node_helper(vec_box, vbox->in(i), vect, box_type, vect_type);\n@@ -360,1 +275,1 @@\n-    return expand_vbox_alloc_node(vbox_alloc, vect, box_type, vect_type);\n+    return expand_vbox_alloc_node(vec_box, vbox_alloc, box_type, vect_type);\n@@ -368,4 +283,4 @@\n-Node* PhaseVector::expand_vbox_alloc_node_vector(VectorBoxAllocateNode* vbox_alloc,\n-                                                 Node* value,\n-                                                 const TypeInstPtr* box_type,\n-                                                 const TypeVect* vect_type) {\n+Node* PhaseVector::expand_vbox_alloc_node(VectorBoxNode* vec_box,\n+                                          VectorBoxAllocateNode* vbox_alloc,\n+                                          const TypeInstPtr* box_type,\n+                                          const TypeVect* vect_type) {\n@@ -374,7 +289,0 @@\n-  PhaseGVN& gvn = kit.gvn();\n-\n-  ciInlineKlass* box_klass = static_cast<ciInlineKlass*>(box_type->inline_klass());\n-\n-  BasicType bt = vect_type->element_basic_type();\n-  int num_elem = vect_type->length();\n-  int elem_size = type2aelembytes(bt);\n@@ -382,0 +290,1 @@\n+  ciInlineKlass* vk = static_cast<ciInlineKlass*>(box_type->inline_klass());\n@@ -385,22 +294,1 @@\n-\n-  assert(is_vector(box_klass), \"\");\n-  ciField* payload_field = box_klass->declared_nonstatic_field_at(0);\n-  int offset = payload_field->offset();\n-  if (!payload_field->is_flattened()) {\n-    ciInlineKlass* payload_klass = static_cast<ciInlineKlass*>(payload_field->type());\n-    assert(is_vector_payload_mf(payload_klass), \"\");\n-    ciField* mutifield = payload_klass->declared_nonstatic_field_at(0);\n-    offset += mutifield->offset();\n-  }\n-\n-  Node* buffer_start_adr = kit.basic_plus_adr(buffer_mem, offset);\n-  const TypePtr* buffer_adr_type = buffer_start_adr->bottom_type()->is_ptr();\n-  Node* buffer_mem_start = kit.memory(buffer_start_adr);\n-  Node* vstore = gvn.transform(StoreVectorNode::make(0,\n-                                                     kit.control(),\n-                                                     buffer_mem_start,\n-                                                     buffer_start_adr,\n-                                                     buffer_adr_type,\n-                                                     value,\n-                                                     num_elem));\n-  kit.set_memory(vstore, buffer_adr_type);\n+  vec_box->store(&kit, buffer_mem, buffer_mem, vk);\n@@ -412,1 +300,0 @@\n-\n@@ -416,119 +303,1 @@\n-\/\/ FIXME: To be removed when mask and shuffle use multi-field backed storage.\n-\/\/ Since intrinsification is skipped upfront for  mask\/shuffle related operations\n-\/\/ this is anyways a dead code currently.\n-Node* PhaseVector::expand_vbox_alloc_node_mask_shuffle(VectorBoxAllocateNode* vbox_alloc,\n-                                                       Node* value,\n-                                                       const TypeInstPtr* box_type,\n-                                                       const TypeVect* vect_type) {\n-  JVMState* jvms = clone_jvms(C, vbox_alloc);\n-  GraphKit kit(jvms);\n-  PhaseGVN& gvn = kit.gvn();\n-\n-  ciInstanceKlass* box_klass = box_type->instance_klass();\n-  BasicType bt = vect_type->element_basic_type();\n-  int num_elem = vect_type->length();\n-\n-  bool is_mask = is_vector_mask(box_klass);\n-  \/\/ If boxed mask value is present in a predicate register, it must be\n-  \/\/ spilled to a vector though a VectorStoreMaskOperation before actual StoreVector\n-  \/\/ operation to vector payload field.\n-  if (is_mask && (value->bottom_type()->isa_vectmask() || bt != T_BOOLEAN)) {\n-    value = gvn.transform(VectorStoreMaskNode::make(gvn, value, bt, num_elem));\n-    \/\/ Although type of mask depends on its definition, in terms of storage everything is stored in boolean array.\n-    bt = T_BOOLEAN;\n-    assert(value->bottom_type()->is_vect()->element_basic_type() == bt,\n-           \"must be consistent with mask representation\");\n-  }\n-\n-  \/\/ Generate array allocation for the field which holds the values.\n-  const TypeKlassPtr* array_klass = TypeKlassPtr::make(ciTypeArrayKlass::make(bt));\n-  Node* arr = kit.new_array(kit.makecon(array_klass), kit.intcon(num_elem), 1);\n-\n-  \/\/ Store the vector value into the array.\n-  \/\/ (The store should be captured by InitializeNode and turned into initialized store later.)\n-  Node* arr_adr = kit.array_element_address(arr, kit.intcon(0), bt);\n-  const TypePtr* arr_adr_type = arr_adr->bottom_type()->is_ptr();\n-  Node* arr_mem = kit.memory(arr_adr);\n-  Node* vstore = gvn.transform(StoreVectorNode::make(0,\n-                                                     kit.control(),\n-                                                     arr_mem,\n-                                                     arr_adr,\n-                                                     arr_adr_type,\n-                                                     value,\n-                                                     num_elem));\n-  kit.set_memory(vstore, arr_adr_type);\n-\n-  C->set_max_vector_size(MAX2(C->max_vector_size(), vect_type->length_in_bytes()));\n-\n-  \/\/ Generate the allocate for the Vector object.\n-  const TypeKlassPtr* klass_type = box_type->as_klass_type();\n-  Node* klass_node = kit.makecon(klass_type);\n-  Node* vec_obj = kit.new_instance(klass_node);\n-\n-  \/\/ Store the allocated array into object.\n-  ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbols::payload_name(),\n-                                                                                     ciSymbols::object_signature(),\n-                                                                                     false);\n-  assert(field != NULL, \"\");\n-  Node* vec_field = kit.basic_plus_adr(vec_obj, field->offset_in_bytes());\n-  const TypePtr* vec_adr_type = vec_field->bottom_type()->is_ptr();\n-\n-  \/\/ The store should be captured by InitializeNode and turned into initialized store later.\n-  Node* field_store = gvn.transform(kit.access_store_at(vec_obj,\n-                                                        vec_field,\n-                                                        vec_adr_type,\n-                                                        arr,\n-                                                        TypeOopPtr::make_from_klass(field->type()->as_klass()),\n-                                                        T_OBJECT,\n-                                                        IN_HEAP));\n-  kit.set_memory(field_store, vec_adr_type);\n-\n-  kit.replace_call(vbox_alloc, vec_obj, true);\n-  C->remove_macro_node(vbox_alloc);\n-\n-  return vec_obj;\n-}\n-\n-Node* PhaseVector::expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,\n-                                          Node* value,\n-                                          const TypeInstPtr* box_type,\n-                                          const TypeVect* vect_type) {\n-  ciInstanceKlass* box_klass = box_type->instance_klass();\n-  if (is_vector(box_klass)) {\n-    return expand_vbox_alloc_node_vector(vbox_alloc, value, box_type, vect_type);\n-  } else {\n-    return expand_vbox_alloc_node_mask_shuffle(vbox_alloc, value, box_type, vect_type);\n-  }\n-}\n-\n-Node* PhaseVector::get_loaded_payload(VectorUnboxNode* vec_unbox) {\n-   Node* obj = vec_unbox->obj();\n-   while(obj->is_InlineType()) {\n-      obj = obj->as_InlineType()->field_value(0);\n-   }\n-   if (obj->bottom_type()->isa_vect()) {\n-     return obj;\n-   }\n-   return NULL;\n-}\n-\n-void PhaseVector::expand_vunbox_node_vector(VectorUnboxNode* vec_unbox) {\n-  if (vec_unbox->outcnt() > 0) {\n-    GraphKit kit;\n-    PhaseGVN& gvn = kit.gvn();\n-\n-    Node* vec_val_load = get_loaded_payload(vec_unbox);\n-    assert (vec_val_load != NULL, \"\");\n-\n-    C->set_max_vector_size(MAX2(C->max_vector_size(), vec_val_load->bottom_type()->is_vect()->length_in_bytes()));\n-    gvn.hash_delete(vec_unbox);\n-    vec_unbox->disconnect_inputs(C);\n-    C->gvn_replace_by(vec_unbox, vec_val_load);\n-  }\n-  C->remove_macro_node(vec_unbox);\n-}\n-\n-\/\/ FIXME: To be removed when mask and shuffle use multi-field backed storage.\n-\/\/ Since intrinsification is skipped upfront for mask\/shuffle related operations\n-\/\/ this is anyways a dead code currently.\n-void PhaseVector::expand_vunbox_node_mask_shuffle(VectorUnboxNode* vec_unbox) {\n+void PhaseVector::expand_vunbox_node(VectorUnboxNode* vec_unbox) {\n@@ -539,32 +308,3 @@\n-    Node* obj = vec_unbox->obj();\n-    const TypeInstPtr* tinst = gvn.type(obj)->isa_instptr();\n-    ciInstanceKlass* from_kls = tinst->instance_klass();\n-    const TypeVect* vt = vec_unbox->bottom_type()->is_vect();\n-    BasicType bt = vt->element_basic_type();\n-    BasicType masktype = bt;\n-\n-    if (is_vector_mask(from_kls)) {\n-      bt = T_BOOLEAN;\n-    } else if (is_vector_shuffle(from_kls)) {\n-      bt = T_BYTE;\n-    }\n-\n-    ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbols::payload_name(),\n-                                                                                       ciSymbols::object_signature(),\n-                                                                                       false);\n-    assert(field != NULL, \"\");\n-    int offset = field->offset_in_bytes();\n-    Node* vec_adr = kit.basic_plus_adr(obj, offset);\n-\n-    Node* mem = vec_unbox->mem();\n-    Node* ctrl = vec_unbox->in(0);\n-    Node* vec_field_ld;\n-    {\n-      DecoratorSet decorators = MO_UNORDERED | IN_HEAP;\n-      C2AccessValuePtr addr(vec_adr, vec_adr->bottom_type()->is_ptr());\n-      MergeMemNode* local_mem = MergeMemNode::make(mem);\n-      gvn.record_for_igvn(local_mem);\n-      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-      C2OptAccess access(gvn, ctrl, local_mem, decorators, T_OBJECT, obj, addr);\n-      const Type* type = TypeOopPtr::make_from_klass(field->type()->as_klass());\n-      vec_field_ld = bs->load_at(access, type);\n+    Node* node = vec_unbox->obj();\n+    while(node->is_InlineType()) {\n+      node = node->as_InlineType()->field_value(0);\n@@ -573,25 +313,2 @@\n-    \/\/ For proper aliasing, attach concrete payload type.\n-    ciKlass* payload_klass = ciTypeArrayKlass::make(bt);\n-    const Type* payload_type = TypeAryPtr::make_from_klass(payload_klass)->cast_to_ptr_type(TypePtr::NotNull);\n-    vec_field_ld = gvn.transform(new CastPPNode(vec_field_ld, payload_type));\n-\n-    Node* adr = kit.array_element_address(vec_field_ld, gvn.intcon(0), bt);\n-    const TypePtr* adr_type = adr->bottom_type()->is_ptr();\n-    int num_elem = vt->length();\n-    Node* vec_val_load = LoadVectorNode::make(0,\n-                                              ctrl,\n-                                              mem,\n-                                              adr,\n-                                              adr_type,\n-                                              num_elem,\n-                                              bt);\n-    vec_val_load = gvn.transform(vec_val_load);\n-\n-    C->set_max_vector_size(MAX2(C->max_vector_size(), vt->length_in_bytes()));\n-\n-    if (is_vector_mask(from_kls)) {\n-      vec_val_load = gvn.transform(new VectorLoadMaskNode(vec_val_load, TypeVect::makemask(masktype, num_elem)));\n-    } else if (is_vector_shuffle(from_kls) && !vec_unbox->is_shuffle_to_vector()) {\n-      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n-      vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n-    }\n+    assert(node->bottom_type()->isa_vect() != NULL, \"not a vector\");\n+    assert(Type::cmp(vec_unbox->bottom_type(), node->bottom_type()) == 0, \"type is not matched\");\n@@ -599,0 +316,1 @@\n+    C->set_max_vector_size(MAX2(C->max_vector_size(), vec_unbox->bottom_type()->is_vect()->length_in_bytes()));\n@@ -601,18 +319,1 @@\n-    C->gvn_replace_by(vec_unbox, vec_val_load);\n-  }\n-  C->remove_macro_node(vec_unbox);\n-}\n-\n-void PhaseVector::expand_vunbox_node(VectorUnboxNode* vec_unbox) {\n-  if (vec_unbox->outcnt() > 0) {\n-    GraphKit kit;\n-    PhaseGVN& gvn = kit.gvn();\n-    Node* obj = vec_unbox->obj();\n-    const TypeInstPtr* tinst = gvn.type(obj)->isa_instptr();\n-    ciInstanceKlass* from_kls = tinst->instance_klass();\n-\n-    if (is_vector(from_kls)) {\n-      return expand_vunbox_node_vector(vec_unbox);\n-    } else {\n-      return expand_vunbox_node_mask_shuffle(vec_unbox);\n-    }\n+    C->gvn_replace_by(vec_unbox, node);\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":21,"deletions":320,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,2 @@\n-  Node* expand_vbox_node_helper(Node* vbox_alloc,\n+  Node* expand_vbox_node_helper(VectorBoxNode* vec_box,\n+                                Node* vbox_alloc,\n@@ -45,2 +46,2 @@\n-  Node* expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,\n-                               Node* value,\n+  Node* expand_vbox_alloc_node(VectorBoxNode* vec_box,\n+                               VectorBoxAllocateNode* vbox_alloc,\n@@ -50,12 +51,0 @@\n-  Node* expand_vbox_alloc_node_vector(VectorBoxAllocateNode* vbox_alloc,\n-                                      Node* value,\n-                                      const TypeInstPtr* box_type,\n-                                      const TypeVect* vect_type);\n-\n-  Node* expand_vbox_alloc_node_mask_shuffle(VectorBoxAllocateNode* vbox_alloc,\n-                                            Node* value,\n-                                            const TypeInstPtr* box_type,\n-                                            const TypeVect* vect_type);\n-\n-  Node* get_loaded_payload(VectorUnboxNode* vec_unbox);\n-\n@@ -66,2 +55,0 @@\n-  void expand_vunbox_node_vector(VectorUnboxNode* vec_unbox);\n-  void expand_vunbox_node_mask_shuffle(VectorUnboxNode* vec_unbox);\n","filename":"src\/hotspot\/share\/opto\/vector.hpp","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,4 +34,0 @@\n-static bool is_vector(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_Vector_klass());\n-}\n-\n@@ -47,0 +43,4 @@\n+static bool is_vector(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayload_klass());\n+}\n+\n@@ -159,1 +159,14 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_type->instance_klass()));\n+\n+  if (is_vector_shuffle(vbox_type->instance_klass())) {\n+    assert(elem_bt == T_BYTE, \"must be consistent with shuffle representation\");\n+  }\n+\n+  \/\/ VectorMask format conversion\n+  if (is_vector_mask(vbox_type->instance_klass()) &&\n+      (vector->bottom_type()->isa_vectmask() || elem_bt != T_BOOLEAN)) {\n+    vector = gvn().transform(VectorStoreMaskNode::make(gvn(), vector, elem_bt, num_elem));\n+    elem_bt = T_BOOLEAN;\n+    assert(vector->bottom_type()->is_vect()->element_basic_type() == elem_bt,\n+           \"must be consistent with mask representation\");\n+  }\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n@@ -164,1 +177,1 @@\n-Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector) {\n+Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem) {\n@@ -173,4 +186,1 @@\n-  \/\/ TODO[valhalla] Limiting support to only vectors cases untill mask and shuffle becomes inline types.\n-  if (!is_vector(vbox_type->instance_klass())) {\n-    return NULL;\n-  }\n+\n@@ -178,2 +188,9 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_type->instance_klass()));\n-  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory(), shuffle_to_vector));\n+  BasicType unbox_bt = elem_bt;\n+  if (is_vector_mask(vbox_type->instance_klass())) {\n+    unbox_bt = T_BOOLEAN;\n+  }\n+  const TypeVect* vt = TypeVect::make(unbox_bt, num_elem);\n+  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory()));\n+  if (is_vector_mask(vbox_type->instance_klass())) {\n+    unbox = gvn().transform(new VectorLoadMaskNode(unbox, TypeVect::makemask(elem_bt, num_elem)));\n+  }\n@@ -724,1 +741,1 @@\n-  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem, true);\n+  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem);\n@@ -795,3 +812,1 @@\n-  \/\/ Unbox shuffle with true flag to indicate its load shuffle to vector\n-  \/\/ shuffle is a byte array\n-  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem, true);\n+  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem);\n@@ -864,5 +879,0 @@\n-  bool is_shuffle = is_vector_shuffle(vbox_klass);\n-  \/\/ TODO[valhalla] Preventing intrinsification for mask\/shuffle till they become inline types.\n-  if (is_mask || is_shuffle) {\n-    return false;\n-  }\n@@ -1010,5 +1020,0 @@\n-  bool is_shuffle = is_vector_shuffle(vbox_klass);\n-  \/\/ TODO[valhalla] Preventing intrinsification for mask\/shuffle till they become inline types.\n-  if (is_mask || is_shuffle) {\n-    return false;\n-  }\n@@ -1980,2 +1985,1 @@\n-  \/\/ TODO[valhalla] Preveting intrinsification untill mask becomes inline type.\n-  if (true || is_masked_op && mask == NULL) {\n+  if (is_masked_op && mask == NULL) {\n@@ -2071,1 +2075,0 @@\n-  BasicType shuffle_bt = elem_bt;\n@@ -2113,2 +2116,1 @@\n-  Node* shuffle = unbox_vector(argument(6), shbox_type, shuffle_bt, num_elem);\n-\n+  Node* shuffle = unbox_vector(argument(6), shbox_type, T_BYTE, num_elem);\n@@ -2133,0 +2135,1 @@\n+  shuffle = gvn().transform(new VectorLoadShuffleNode(shuffle, TypeVect::make(elem_bt, num_elem)));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":35,"deletions":32,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -858,4 +858,0 @@\n-  case Op_ReplicateF:\n-    return n->in(1)->bottom_type() == TypeF::ONE;\n-  case Op_ReplicateD:\n-    return n->in(1)->bottom_type() == TypeD::ONE;\n@@ -1304,0 +1300,17 @@\n+Node* VectorLoadMaskNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(1)->Opcode() == Op_VectorStoreMask) {\n+    if (Type::cmp(bottom_type(), in(1)->in(1)->bottom_type()) == 0) {\n+      \/\/ \/\/ Handled by VectorLoadMaskNode::Identity()\n+    } else {\n+      const TypeVect* out_vt = vect_type();\n+      const TypeVect* in_vt = in(1)->in(1)->bottom_type()->is_vect();\n+      if (out_vt->length() == in_vt->length() &&\n+          out_vt->length_in_bytes() == in_vt->length_in_bytes()) {\n+        const TypeVect* vmask_type = TypeVect::makemask(out_vt->element_basic_type(), out_vt->length());\n+        return new VectorMaskCastNode(in(1)->in(1), vmask_type);\n+      }\n+    }\n+  }\n+  return VectorNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -1305,1 +1318,1 @@\n-  BasicType out_bt = type()->is_vect()->element_basic_type();\n+  BasicType out_bt = vect_type()->element_basic_type();\n@@ -1310,0 +1323,5 @@\n+  \/\/ VectorLoadMask (VectorStoreMask mask) ==> mask\n+  if (in(1)->Opcode() == Op_VectorStoreMask &&\n+      Type::cmp(bottom_type(), in(1)->in(1)->bottom_type()) == 0) {\n+    return in(1)->in(1);\n+  }\n@@ -1634,49 +1652,0 @@\n-Node* VectorUnboxNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  Node* n = obj();\n-  assert(n->is_InlineType(), \"\");\n-  \/\/ Vector APIs are lazily intrinsified, during parsing compiler emits a\n-  \/\/ call to intrinsic function, since most of the APIs return an abstract vector\n-  \/\/ hence a subsequent checkcast results into a graph shape comprising of CheckPP\n-  \/\/ and CheckCastPP chain. During lazy inline expansion, call gets replaced by\n-  \/\/ a VectorBox but we still need to traverse back through chain of cast nodes\n-  \/\/ to get to the VectorBox.\n-  if (!n->is_VectorBox() &&\n-      VectorSupport::is_vector(n->as_InlineType()->inline_klass()->get_InlineKlass())) {\n-    n = n->as_InlineType()->get_oop();\n-  }\n-  n = n->uncast();\n-  if (EnableVectorReboxing && n->Opcode() == Op_VectorBox) {\n-    if (Type::cmp(bottom_type(), n->as_VectorBox()->get_vec()->bottom_type()) == 0) {\n-      \/\/ Handled by VectorUnboxNode::Identity()\n-    } else {\n-      VectorBoxNode* vbox = static_cast<VectorBoxNode*>(n);\n-      ciKlass* vbox_klass = vbox->box_type()->instance_klass();\n-      const TypeVect* in_vt = vbox->vec_type();\n-      const TypeVect* out_vt = type()->is_vect();\n-\n-      if (in_vt->length() == out_vt->length()) {\n-        Node* value = vbox->field_value(0);\n-\n-        bool is_vector_mask    = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-        bool is_vector_shuffle = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-        if (is_vector_mask) {\n-          \/\/ VectorUnbox (VectorBox vmask) ==> VectorMaskCast vmask\n-          const TypeVect* vmask_type = TypeVect::makemask(out_vt->element_basic_type(), out_vt->length());\n-          return new VectorMaskCastNode(value, vmask_type);\n-        } else if (is_vector_shuffle) {\n-          if (!is_shuffle_to_vector()) {\n-            \/\/ VectorUnbox (VectorBox vshuffle) ==> VectorLoadShuffle vshuffle\n-            return new VectorLoadShuffleNode(value, out_vt);\n-          }\n-        } else {\n-          \/\/ Vector type mismatch is only supported for masks and shuffles, but sometimes it happens in pathological cases.\n-        }\n-      } else {\n-        \/\/ Vector length mismatch.\n-        \/\/ Sometimes happen in pathological cases (e.g., when unboxing happens in effectively dead code).\n-      }\n-    }\n-  }\n-  return NULL;\n-}\n-\n@@ -1685,1 +1654,2 @@\n-  if (n->is_InlineType() && !n->is_VectorBox()) {\n+  assert(n->is_InlineType(), \"\");\n+  if (!n->is_VectorBox()) {\n@@ -1696,2 +1666,1 @@\n-  if (n->is_InlineType() &&\n-      !n->is_VectorBox() &&\n+  if (!n->is_VectorBox() &&\n@@ -1705,2 +1674,0 @@\n-    } else {\n-      \/\/ Handled by VectorUnboxNode::Ideal().\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":27,"deletions":60,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1492,0 +1492,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -1691,2 +1692,0 @@\n-\n-    Node* payload_oop = payload->is_initialized() ? default_oop(gvn, payload) : gvn.zerocon(T_PRIMITIVE_OBJECT);\n@@ -1700,1 +1699,0 @@\n-\n@@ -1735,2 +1733,0 @@\n- private:\n-  bool _shuffle_to_vector;\n@@ -1740,1 +1736,1 @@\n-  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem, bool shuffle_to_vector)\n+  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem)\n@@ -1742,1 +1738,0 @@\n-    _shuffle_to_vector = shuffle_to_vector;\n@@ -1752,2 +1747,0 @@\n-  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-  bool is_shuffle_to_vector() { return _shuffle_to_vector; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-  return klass->is_subclass_of(vmClasses::vector_Vector_klass());\n+  return klass->is_subclass_of(vmClasses::vector_VectorPayload_klass());\n@@ -88,1 +88,2 @@\n-  return VectorSupport::is_vector(klass) || VectorSupport::is_vector_payload_mf(klass);\n+  return VectorSupport::is_vector(klass) ||\n+         VectorSupport::is_vector_payload_mf(klass);\n@@ -126,20 +127,0 @@\n-\/\/ Masks require special handling: when boxed they are packed and stored in boolean\n-\/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n-\/\/ For example, Int512Mask is represented in memory as boolean[16], but\n-\/\/ occupies the whole 512-bit vector register when scalarized.\n-\/\/ During scalarization inserting a VectorStoreMask node between mask\n-\/\/ and safepoint node always ensures the existence of masks in a boolean array.\n-\n-void VectorSupport::init_payload_element(typeArrayOop arr, BasicType elem_bt, int index, address addr) {\n-  switch (elem_bt) {\n-    case T_BOOLEAN: arr->bool_at_put(index, *(jboolean*)addr); break;\n-    case T_BYTE:    arr->byte_at_put(index, *(jbyte*)addr); break;\n-    case T_SHORT:   arr->short_at_put(index, *(jshort*)addr); break;\n-    case T_INT:     arr->int_at_put(index, *(jint*)addr); break;\n-    case T_FLOAT:   arr->float_at_put(index, *(jfloat*)addr); break;\n-    case T_LONG:    arr->long_at_put(index, *(jlong*)addr); break;\n-    case T_DOUBLE:  arr->double_at_put(index, *(jdouble*)addr); break;\n-    default: fatal(\"unsupported: %s\", type2name(elem_bt));\n-  }\n-}\n-\n@@ -147,8 +128,5 @@\n-  int elem_size = type2aelembytes(elem_bt);\n-\n-  \/\/ FIXME: Existing handling is used for shuffles and mask classes, to be removed after\n-  \/\/ complete support.\n-  \/\/ On-heap vector values are represented as primitive arrays.\n-  if (is_vector_shuffle(ik) || is_vector_mask(ik)) {\n-    TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));\n-    typeArrayOop arr = tak->allocate(num_elem, CHECK_NH); \/\/ safepoint\n+  \/\/ On-heap vector values are represented as primitive class instances with a multi-field payload.\n+  InstanceKlass* payload_kls = get_vector_payload_klass(elem_bt, num_elem);\n+  assert(payload_kls->is_inline_klass(), \"\");\n+  instanceOop obj = InlineKlass::cast(payload_kls)->allocate_instance(THREAD);\n+  if (larval) obj->set_mark(obj->mark().enter_larval_state());\n@@ -156,3 +134,3 @@\n-    if (location.is_register()) {\n-      \/\/ Value was in a callee-saved register.\n-      VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n+  fieldDescriptor fd;\n+  Klass* def = payload_kls->find_field(vmSymbols::mfield_name(), vmSymbols::type_signature(elem_bt), false, &fd);\n+  assert(fd.is_multifield_base() && fd.secondary_fields_count(fd.index()) == num_elem, \"\");\n@@ -160,3 +138,2 @@\n-      for (int i = 0; i < num_elem; i++) {\n-        int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n-        int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n+  int ffo = InlineKlass::cast(payload_kls)->first_field_offset();\n+  int elem_size = type2aelembytes(elem_bt);\n@@ -164,9 +141,9 @@\n-        address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n-        init_payload_element(arr, elem_bt, i, elem_addr);\n-      }\n-    } else {\n-      \/\/ Value was directly saved on the stack.\n-      address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n-      for (int i = 0; i < num_elem; i++) {\n-        init_payload_element(arr, elem_bt, i, base_addr + i * elem_size);\n-      }\n+  if (location.is_register()) {\n+    \/\/ Value was in a callee-saved register.\n+    VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n+    int vec_size = num_elem * elem_size;\n+    for (int i = 0; i < vec_size; i++) {\n+      int vslot = i \/ VMRegImpl::stack_slot_size;\n+      int off   = i % VMRegImpl::stack_slot_size;\n+      address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n+      obj->byte_field_put(ffo + i, *(jbyte*)elem_addr);\n@@ -174,1 +151,0 @@\n-    return Handle(THREAD, arr);\n@@ -176,28 +152,4 @@\n-    \/\/ On-heap vector values are represented as primitive class instances with a multi-field payload.\n-    InstanceKlass* payload_kls = get_vector_payload_klass(elem_bt, num_elem);\n-    assert(payload_kls->is_inline_klass(), \"\");\n-    instanceOop obj = InlineKlass::cast(payload_kls)->allocate_instance(THREAD);\n-    if (larval) obj->set_mark(obj->mark().enter_larval_state());\n-\n-    fieldDescriptor fd;\n-    Klass* def = payload_kls->find_field(vmSymbols::mfield_name(), vmSymbols::type_signature(elem_bt), false, &fd);\n-    assert(fd.is_multifield_base() && fd.secondary_fields_count(fd.index()) == num_elem, \"\");\n-\n-    int ffo = InlineKlass::cast(payload_kls)->first_field_offset();\n-\n-    if (location.is_register()) {\n-      \/\/ Value was in a callee-saved register.\n-      VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n-      int vec_size = num_elem * elem_size;\n-      for (int i = 0; i < vec_size; i++) {\n-        int vslot = i \/ VMRegImpl::stack_slot_size;\n-        int off   = i % VMRegImpl::stack_slot_size;\n-        address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n-        obj->byte_field_put(ffo + i, *(jbyte*)elem_addr);\n-      }\n-    } else {\n-      \/\/ Value was directly saved on the stack.\n-      address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n-      for (int i = 0; i < elem_size * num_elem; i++) {\n-        obj->byte_field_put(ffo + i, *(jbyte*)(base_addr + i));\n-      }\n+    \/\/ Value was directly saved on the stack.\n+    address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n+    for (int i = 0; i < elem_size * num_elem; i++) {\n+      obj->byte_field_put(ffo + i, *(jbyte*)(base_addr + i));\n@@ -205,1 +157,0 @@\n-    return Handle(THREAD, obj);\n@@ -207,0 +158,1 @@\n+  return Handle(THREAD, obj);\n@@ -211,0 +163,11 @@\n+    case T_BOOLEAN:\n+      switch(num_elem) {\n+        case  1: return vmSymbols::vector_VectorPayloadMF8Z_signature();\n+        case  2: return vmSymbols::vector_VectorPayloadMF16Z_signature();\n+        case  4: return vmSymbols::vector_VectorPayloadMF32Z_signature();\n+        case  8: return vmSymbols::vector_VectorPayloadMF64Z_signature();\n+        case 16: return vmSymbols::vector_VectorPayloadMF128Z_signature();\n+        case 32: return vmSymbols::vector_VectorPayloadMF256Z_signature();\n+        case 64: return vmSymbols::vector_VectorPayloadMF512Z_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n@@ -213,0 +176,3 @@\n+        case  1: return vmSymbols::vector_VectorPayloadMF8B_signature();\n+        case  2: return vmSymbols::vector_VectorPayloadMF16B_signature();\n+        case  4: return vmSymbols::vector_VectorPayloadMF32B_signature();\n@@ -267,0 +233,11 @@\n+    case T_BOOLEAN:\n+      switch(num_elem) {\n+        case  1: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF8Z_klass));\n+        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF16Z_klass));\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF32Z_klass));\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64Z_klass));\n+        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128Z_klass));\n+        case 32: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256Z_klass));\n+        case 64: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512Z_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n@@ -269,0 +246,3 @@\n+        case  1: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF8B_klass));\n+        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF16B_klass));\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF32B_klass));\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":56,"deletions":76,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -31,1 +32,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -34,1 +34,0 @@\n-\n@@ -158,3 +157,1 @@\n-    public abstract static class VectorPayload {\n-        protected abstract Object getPayload();\n-    }\n+    public abstract static class VectorPayload { }\n@@ -164,13 +161,1 @@\n-    public static class VectorShuffle<E> extends VectorPayload {\n-        private final Object payload; \/\/ array of primitives\n-\n-        protected final Object getPayload() {\n-            return VectorSupport.maybeRebox(this).payload;\n-        }\n-        public VectorShuffle(Object payload) {\n-            this.payload = payload;\n-        }\n-    }\n-\n-    public static class VectorMask<E> extends VectorPayload {\n-        private final Object payload; \/\/ array of primitives\n+    public static abstract class VectorMask<E> extends VectorPayload { }\n@@ -178,7 +163,1 @@\n-        protected final Object getPayload() {\n-            return VectorSupport.maybeRebox(this).payload;\n-        }\n-        public VectorMask(Object payload) {\n-            this.payload = payload;\n-        }\n-    }\n+    public static abstract class VectorShuffle<E> extends VectorPayload { }\n@@ -190,2 +169,13 @@\n-        private static VectorPayloadMF newInstanceFactory(Class<?> elemType, int length) {\n-            if (elemType == byte.class) {\n+        public static VectorPayloadMF newInstanceFactory(Class<?> elemType, int length) {\n+            if (elemType == boolean.class) {\n+                switch(length) {\n+                    case  1: return new VectorPayloadMF8Z();\n+                    case  2: return new VectorPayloadMF16Z();\n+                    case  4: return new VectorPayloadMF32Z();\n+                    case  8: return new VectorPayloadMF64Z();\n+                    case 16: return new VectorPayloadMF128Z();\n+                    case 32: return new VectorPayloadMF256Z();\n+                    case 64: return new VectorPayloadMF512Z();\n+                    default: assert false : \"Unhandled vector mask size\";\n+                }\n+            } else if (elemType == byte.class) {\n@@ -193,0 +183,3 @@\n+                    case  1: return new VectorPayloadMF8B();\n+                    case  2: return new VectorPayloadMF16B();\n+                    case  4: return new VectorPayloadMF32B();\n@@ -244,5 +237,0 @@\n-        @ForceInline\n-        public static VectorPayloadMF createVectPayloadInstance(Class<?> elemType, int length) {\n-            return newInstanceFactory(elemType, length);\n-        }\n-\n@@ -321,1 +309,1 @@\n-        public int length(int elemSize) {\n+        public int length() {\n@@ -329,1 +317,1 @@\n-                return msanno[0].value() \/ elemSize;\n+                return msanno[0].value();\n@@ -347,0 +335,90 @@\n+    public primitive static class VectorPayloadMF8Z extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF8Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF16Z extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF16Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF32Z extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF32Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF64Z extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF128Z extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF256Z extends VectorPayloadMF {\n+        @MultiField(value = 32)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF512Z extends VectorPayloadMF {\n+        @MultiField(value = 64)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF8B extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF8B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF16B extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF16B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF32B extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF32B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n@@ -353,1 +431,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -362,1 +440,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -371,1 +449,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -380,1 +458,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -389,1 +467,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -398,1 +476,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -407,1 +485,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -416,1 +494,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -425,1 +503,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -434,1 +512,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -443,1 +521,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -452,1 +530,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -461,1 +539,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -470,1 +548,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -479,1 +557,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -488,1 +566,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -497,1 +575,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -506,1 +584,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -515,1 +593,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -524,1 +602,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -533,1 +611,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -542,1 +620,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -551,1 +629,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -560,1 +638,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -562,0 +640,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":138,"deletions":59,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n@@ -38,3 +40,0 @@\n-    AbstractMask(boolean[] bits) {\n-        super(bits);\n-    }\n@@ -43,1 +42,24 @@\n-    abstract boolean[] getBits();\n+    abstract VectorPayloadMF getBits();\n+\n+    static VectorPayloadMF prepare(VectorPayloadMF payload, int offset, int length) {\n+        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        long mOffset = res.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            boolean b = Unsafe.getUnsafe().getBoolean(payload, mOffset + i + offset);\n+            Unsafe.getUnsafe().putBoolean(res, mOffset + i, b);\n+        }\n+        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        return res;\n+    }\n+\n+    static VectorPayloadMF prepare(boolean val, int length) {\n+        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        long mOffset = res.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putBoolean(res, mOffset + i, val);\n+        }\n+        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        return res;\n+    }\n@@ -51,1 +73,13 @@\n-    abstract AbstractMask<E> uOp(MUnOp f);\n+    AbstractMask<E> uOp(MUnOp f) {\n+        int length = vspecies().laneCount();\n+        VectorPayloadMF bits = getBits();\n+        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        long mOffset = res.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            boolean b = Unsafe.getUnsafe().getBoolean(bits, mOffset + i);\n+            Unsafe.getUnsafe().putBoolean(res, mOffset + i, f.apply(i, b));\n+        }\n+        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        return vspecies().maskFactory(res);\n+    }\n@@ -59,1 +93,25 @@\n-    abstract AbstractMask<E> bOp(VectorMask<E> o, MBinOp f);\n+    AbstractMask<E> bOp(AbstractMask<E> m, MBinOp f) {\n+        int length = vspecies().laneCount();\n+        VectorPayloadMF bits = getBits();\n+        VectorPayloadMF mbits = m.getBits();\n+        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        long mOffset = res.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            boolean b = Unsafe.getUnsafe().getBoolean(bits, mOffset + i);\n+            boolean mb = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i);\n+            Unsafe.getUnsafe().putBoolean(res, mOffset + i, f.apply(i, b, mb));\n+        }\n+        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        return vspecies().maskFactory(res);\n+    }\n+\n+    \/\/ Store operator\n+\n+    void stOp(boolean[] arr, int idx) {\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < vspecies().laneCount(); i++) {\n+            arr[idx++] = Unsafe.getUnsafe().getBoolean(bits, mOffset + i);\n+        }\n+    }\n@@ -70,0 +128,14 @@\n+    @Override\n+    @ForceInline\n+    public <F> VectorMask<F> cast(VectorSpecies<F> dsp) {\n+        AbstractSpecies<F> species = (AbstractSpecies<F>) dsp;\n+        if (length() != species.laneCount())\n+            throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), vspecies().elementType(), vspecies().laneCount,\n+                species.maskType(), species.elementType(), vspecies().laneCount,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.getBits()).check(s));\n+    }\n+\n@@ -78,1 +150,2 @@\n-            return getBits()[i];\n+            VectorPayloadMF bits = getBits();\n+            return Unsafe.getUnsafe().getBoolean(bits, bits.multiFieldOffset() + i);\n@@ -91,2 +164,1 @@\n-            (c, idx, s) -> System.arraycopy(s.getBits(), 0, c, (int) idx, s.length()));\n-\n+            (c, idx, s) -> s.stOp(c, (int) idx));\n@@ -97,1 +169,3 @@\n-        return getBits().clone();\n+        boolean[] arr = new boolean[length()];\n+        intoArray(arr, 0);\n+        return arr;\n@@ -145,1 +219,1 @@\n-    static boolean anyTrueHelper(boolean[] bits) {\n+    boolean anyTrueHelper() {\n@@ -147,2 +221,4 @@\n-        for (boolean i : bits) {\n-            if (i) return true;\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return true;\n@@ -154,1 +230,1 @@\n-    static boolean allTrueHelper(boolean[] bits) {\n+    boolean allTrueHelper() {\n@@ -156,2 +232,4 @@\n-        for (boolean i : bits) {\n-            if (!i) return false;\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            if (!Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return false;\n@@ -163,1 +241,1 @@\n-    static int trueCountHelper(boolean[] bits) {\n+    int trueCountHelper() {\n@@ -165,2 +243,4 @@\n-        for (boolean i : bits) {\n-            if (i) c++;\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) c++;\n@@ -172,3 +252,5 @@\n-    static int firstTrueHelper(boolean[] bits) {\n-        for (int i = 0; i < bits.length; i++) {\n-            if (bits[i])  return i;\n+    int firstTrueHelper() {\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return i;\n@@ -176,1 +258,1 @@\n-        return bits.length;\n+        return length();\n@@ -180,3 +262,5 @@\n-    static int lastTrueHelper(boolean[] bits) {\n-        for (int i = bits.length-1; i >= 0; i--) {\n-            if (bits[i])  return i;\n+    int lastTrueHelper() {\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = length() - 1; i >= 0; i--) {\n+            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return i;\n@@ -188,1 +272,1 @@\n-    static long toLongHelper(boolean[] bits) {\n+    long toLongHelper() {\n@@ -191,2 +275,4 @@\n-        for (int i = 0; i < bits.length; i++) {\n-            res = bits[i] ? res | set : res;\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            res = Unsafe.getUnsafe().getBoolean(bits, mOffset + i) ? res | set : res;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":116,"deletions":30,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -30,0 +31,2 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n@@ -36,20 +39,4 @@\n-    AbstractShuffle(int length, byte[] reorder) {\n-        super(reorder);\n-        assert(length == reorder.length);\n-        assert(indexesInRange(reorder));\n-    }\n-\n-    AbstractShuffle(int length, int[] reorder) {\n-        this(length, reorder, 0);\n-    }\n-\n-    AbstractShuffle(int length, int[] reorder, int offset) {\n-        super(prepare(length, reorder, offset));\n-    }\n-\n-    AbstractShuffle(int length, IntUnaryOperator f) {\n-        super(prepare(length, f));\n-    }\n-\n-    private static byte[] prepare(int length, int[] reorder, int offset) {\n-        byte[] a = new byte[length];\n+    static VectorPayloadMF prepare(int length, int[] reorder, int offset) {\n+        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        long mf_offset = payload.multiFieldOffset();\n@@ -59,1 +46,1 @@\n-            a[i] = (byte) si;\n+            Unsafe.getUnsafe().putByte(payload, mf_offset + i * Byte.BYTES, (byte) si);\n@@ -61,1 +48,2 @@\n-        return a;\n+        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        return payload;\n@@ -64,3 +52,5 @@\n-    private static byte[] prepare(int length, IntUnaryOperator f) {\n-        byte[] a = new byte[length];\n-        for (int i = 0; i < a.length; i++) {\n+    static VectorPayloadMF prepare(int length, IntUnaryOperator f) {\n+        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        long offset = payload.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n@@ -69,1 +59,1 @@\n-            a[i] = (byte) si;\n+            Unsafe.getUnsafe().putByte(payload, offset + i * Byte.BYTES, (byte) si);\n@@ -71,1 +61,2 @@\n-        return a;\n+        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        return payload;\n@@ -74,3 +65,2 @@\n-    byte[] reorder() {\n-        return (byte[])getPayload();\n-    }\n+    \/*package-private*\/\n+    abstract VectorPayloadMF reorder();\n@@ -90,2 +80,3 @@\n-        byte[] reorder = reorder();\n-        int vlen = reorder.length;\n+        VectorPayloadMF reorder = reorder();\n+        int vlen = reorder.length();\n+        long mf_offset = reorder.multiFieldOffset();\n@@ -93,1 +84,1 @@\n-            int sourceIndex = reorder[i];\n+            int sourceIndex = Unsafe.getUnsafe().getByte(reorder, mf_offset + i * Byte.BYTES);\n@@ -102,2 +93,2 @@\n-        byte[] reorder = reorder();\n-        int[] a = new int[reorder.length];\n+        VectorPayloadMF reorder = reorder();\n+        int[] a = new int[reorder.length()];\n@@ -129,2 +120,3 @@\n-            byte[] reorder = reorder();\n-            throw checkIndexFailed(reorder[vecmask.firstTrue()], length());\n+            VectorPayloadMF reorder = reorder();\n+            long offset = reorder.multiFieldOffset();\n+            throw checkIndexFailed(Unsafe.getUnsafe().getByte(reorder, offset + vecmask.firstTrue() * Byte.BYTES), length());\n@@ -141,1 +133,1 @@\n-            byte[] reorder = reorder();\n+            VectorPayloadMF reorder = reorder();\n@@ -148,3 +140,5 @@\n-    public final VectorShuffle<E> wrapAndRebuild(byte[] oldReorder) {\n-        int length = oldReorder.length;\n-        byte[] reorder = new byte[length];\n+    public final VectorShuffle<E> wrapAndRebuild(VectorPayloadMF oldReorder) {\n+        int length = oldReorder.length();\n+        VectorPayloadMF reorder = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        long offset = oldReorder.multiFieldOffset();\n+        reorder = Unsafe.getUnsafe().makePrivateBuffer(reorder);\n@@ -152,1 +146,1 @@\n-            int si = oldReorder[i];\n+            int si = Unsafe.getUnsafe().getByte(oldReorder, offset + i * Byte.BYTES);\n@@ -161,1 +155,1 @@\n-            reorder[i] = (byte) si;\n+            Unsafe.getUnsafe().putByte(reorder, offset + i * Byte.BYTES, (byte) si);\n@@ -163,0 +157,1 @@\n+        reorder = Unsafe.getUnsafe().finishPrivateBuffer(reorder);\n@@ -224,3 +219,5 @@\n-    static boolean indexesInRange(byte[] reorder) {\n-        int length = reorder.length;\n-        for (byte si : reorder) {\n+    static boolean indexesInRange(VectorPayloadMF reorder) {\n+        int length = reorder.length();\n+        long offset = reorder.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            byte si = Unsafe.getUnsafe().getByte(reorder, offset + i * Byte.BYTES);\n@@ -232,1 +229,1 @@\n-                                  java.util.Arrays.toString(reorder));\n+                            reorder.toString());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":45,"deletions":48,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -37,0 +38,1 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n@@ -311,9 +313,0 @@\n-    AbstractVector<E> dummyVector() {\n-        \/\/ This JITs to a constant value:\n-        AbstractVector<E> dummy = dummyVector;\n-        if (dummy != null)  return dummy;\n-        \/\/ The rest of this computation is probably not JIT-ted.\n-        return makeDummyVector();\n-    }\n-    @ForceInline\n-    \/*package-private*\/\n@@ -328,9 +321,0 @@\n-    @ForceInline\n-    private AbstractVector<E> makeDummyVector() {\n-        Object za = Array.newInstance(elementType(), laneCount);\n-        return dummyVector = vectorFactory.apply(za);\n-        \/\/ This is the only use of vectorFactory.\n-        \/\/ All other factory requests are routed\n-        \/\/ through the dummy vector.\n-    }\n-\n@@ -376,1 +360,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstance(elementType(), laneCount);\n+            za = VectorPayloadMF.newInstanceFactory(elementType(), laneCount);\n@@ -394,2 +378,2 @@\n-    AbstractMask<E> maskFactory(boolean[] bits) {\n-        return dummyVectorMF().maskFromArray(bits);\n+    AbstractMask<E> maskFactory(VectorPayloadMF payload) {\n+        return dummyVectorMF().maskFromPayload(payload);\n@@ -530,3 +514,5 @@\n-        boolean[] res = new boolean[laneCount];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i);\n+        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(boolean.class, laneCount);\n+        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        long mOffset = payload.multiFieldOffset();\n+        for (int i = 0; i < laneCount; i++) {\n+            Unsafe.getUnsafe().putBoolean(payload, mOffset + i, f.apply(i));\n@@ -534,1 +520,2 @@\n-        return dummyVectorMF().maskFromArray(res);\n+        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        return maskFactory(payload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":13,"deletions":26,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n@@ -73,0 +74,3 @@\n+    \/*package-private*\/\n+    abstract VectorPayloadMF vec();\n+\n@@ -186,2 +190,1 @@\n-\n-    abstract AbstractMask<E> maskFromArray(boolean[] bits);\n+    abstract AbstractMask<E> maskFromPayload(VectorPayloadMF payload);\n@@ -194,1 +197,1 @@\n-    abstract AbstractShuffle<E> shuffleFromBytes(byte[] reorder);\n+    abstract AbstractShuffle<E> shuffleFromBytes(VectorPayloadMF reorder);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF128B)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF128B) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 16));\n-    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(16, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.newInstanceFactory(byte.class, 16));\n+    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(16, (byte[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Byte128Mask maskFromArray(boolean[] bits) {\n-        return new Byte128Mask(bits);\n+    Byte128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Byte128Mask(payload);\n@@ -169,1 +157,1 @@\n-    Byte128Shuffle shuffleFromBytes(byte[] reorder) { return new Byte128Shuffle(reorder); }\n+    Byte128Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Byte128Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Byte128Vector vectorFactory(byte[] vec) {\n-        return new Byte128Vector(vec);\n-    }\n-\n@@ -558,1 +539,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -593,1 +574,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -604,1 +585,1 @@\n-    static final class Byte128Mask extends AbstractMask<Byte> {\n+    static final value class Byte128Mask extends AbstractMask<Byte> {\n@@ -608,3 +589,1 @@\n-        Byte128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF128Z payload;\n@@ -612,2 +591,2 @@\n-        Byte128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Byte128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128Z) payload;\n@@ -616,10 +595,2 @@\n-        Byte128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Byte128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -628,4 +599,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Byte128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -644,4 +613,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -649,18 +614,2 @@\n-        Byte128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Byte128Mask(res);\n-        }\n-\n-        @Override\n-        Byte128Mask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Byte128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Byte128Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -676,27 +625,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -722,1 +644,1 @@\n-            return (Byte128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Byte128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -735,3 +657,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte128Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -745,3 +667,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte128Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -755,3 +677,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte128Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -766,1 +688,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Byte128Mask) m).trueCountHelper());\n@@ -773,1 +695,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte128Mask) m).firstTrueHelper());\n@@ -780,1 +702,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte128Mask) m).lastTrueHelper());\n@@ -790,1 +712,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Byte128Mask) m).toLongHelper());\n@@ -800,1 +722,1 @@\n-                                         (m, __) -> anyTrueHelper(((Byte128Mask)m).getBits()));\n+                                         (m, __) -> ((Byte128Mask) m).anyTrueHelper());\n@@ -808,1 +730,1 @@\n-                                         (m, __) -> allTrueHelper(((Byte128Mask)m).getBits()));\n+                                         (m, __) -> ((Byte128Mask) m).allTrueHelper());\n@@ -825,1 +747,1 @@\n-    static final class Byte128Shuffle extends AbstractShuffle<Byte> {\n+    static final value class Byte128Shuffle extends AbstractShuffle<Byte> {\n@@ -829,2 +751,6 @@\n-        Byte128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF128B payload;\n+\n+        Byte128Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF128B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -834,1 +760,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -838,1 +764,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -842,1 +768,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -879,6 +811,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -886,0 +821,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF256B)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF256B) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 32));\n-    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(32, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.newInstanceFactory(byte.class, 32));\n+    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(32, (byte[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Byte256Mask maskFromArray(boolean[] bits) {\n-        return new Byte256Mask(bits);\n+    Byte256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Byte256Mask(payload);\n@@ -169,1 +157,1 @@\n-    Byte256Shuffle shuffleFromBytes(byte[] reorder) { return new Byte256Shuffle(reorder); }\n+    Byte256Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Byte256Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Byte256Vector vectorFactory(byte[] vec) {\n-        return new Byte256Vector(vec);\n-    }\n-\n@@ -574,1 +555,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -625,1 +606,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -636,1 +617,1 @@\n-    static final class Byte256Mask extends AbstractMask<Byte> {\n+    static final value class Byte256Mask extends AbstractMask<Byte> {\n@@ -640,3 +621,1 @@\n-        Byte256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF256Z payload;\n@@ -644,2 +623,2 @@\n-        Byte256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Byte256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF256Z) payload;\n@@ -648,10 +627,2 @@\n-        Byte256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Byte256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -660,4 +631,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Byte256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -676,4 +645,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -681,18 +646,2 @@\n-        Byte256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Byte256Mask(res);\n-        }\n-\n-        @Override\n-        Byte256Mask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Byte256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Byte256Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -708,27 +657,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -754,1 +676,1 @@\n-            return (Byte256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Byte256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -767,3 +689,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte256Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -777,3 +699,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte256Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -787,3 +709,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte256Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -798,1 +720,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Byte256Mask) m).trueCountHelper());\n@@ -805,1 +727,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte256Mask) m).firstTrueHelper());\n@@ -812,1 +734,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte256Mask) m).lastTrueHelper());\n@@ -822,1 +744,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Byte256Mask) m).toLongHelper());\n@@ -832,1 +754,1 @@\n-                                         (m, __) -> anyTrueHelper(((Byte256Mask)m).getBits()));\n+                                         (m, __) -> ((Byte256Mask) m).anyTrueHelper());\n@@ -840,1 +762,1 @@\n-                                         (m, __) -> allTrueHelper(((Byte256Mask)m).getBits()));\n+                                         (m, __) -> ((Byte256Mask) m).allTrueHelper());\n@@ -857,1 +779,1 @@\n-    static final class Byte256Shuffle extends AbstractShuffle<Byte> {\n+    static final value class Byte256Shuffle extends AbstractShuffle<Byte> {\n@@ -861,2 +783,6 @@\n-        Byte256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF256B payload;\n+\n+        Byte256Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF256B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -866,1 +792,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -870,1 +796,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -874,1 +800,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -911,6 +843,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -918,0 +853,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF512B)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF512B) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 64));\n-    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(64, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.newInstanceFactory(byte.class, 64));\n+    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(64, (byte[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Byte512Mask maskFromArray(boolean[] bits) {\n-        return new Byte512Mask(bits);\n+    Byte512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Byte512Mask(payload);\n@@ -169,1 +157,1 @@\n-    Byte512Shuffle shuffleFromBytes(byte[] reorder) { return new Byte512Shuffle(reorder); }\n+    Byte512Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Byte512Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Byte512Vector vectorFactory(byte[] vec) {\n-        return new Byte512Vector(vec);\n-    }\n-\n@@ -606,1 +587,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -689,1 +670,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -700,1 +681,1 @@\n-    static final class Byte512Mask extends AbstractMask<Byte> {\n+    static final value class Byte512Mask extends AbstractMask<Byte> {\n@@ -704,3 +685,1 @@\n-        Byte512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF512Z payload;\n@@ -708,2 +687,2 @@\n-        Byte512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Byte512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF512Z) payload;\n@@ -712,10 +691,2 @@\n-        Byte512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Byte512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -724,4 +695,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Byte512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -740,4 +709,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -745,18 +710,2 @@\n-        Byte512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Byte512Mask(res);\n-        }\n-\n-        @Override\n-        Byte512Mask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Byte512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Byte512Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -772,27 +721,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -818,1 +740,1 @@\n-            return (Byte512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Byte512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -831,3 +753,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte512Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -841,3 +763,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte512Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -851,3 +773,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte512Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -862,1 +784,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Byte512Mask) m).trueCountHelper());\n@@ -869,1 +791,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte512Mask) m).firstTrueHelper());\n@@ -876,1 +798,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte512Mask) m).lastTrueHelper());\n@@ -886,1 +808,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Byte512Mask) m).toLongHelper());\n@@ -896,1 +818,1 @@\n-                                         (m, __) -> anyTrueHelper(((Byte512Mask)m).getBits()));\n+                                         (m, __) -> ((Byte512Mask) m).anyTrueHelper());\n@@ -904,1 +826,1 @@\n-                                         (m, __) -> allTrueHelper(((Byte512Mask)m).getBits()));\n+                                         (m, __) -> ((Byte512Mask) m).allTrueHelper());\n@@ -921,1 +843,1 @@\n-    static final class Byte512Shuffle extends AbstractShuffle<Byte> {\n+    static final value class Byte512Shuffle extends AbstractShuffle<Byte> {\n@@ -925,2 +847,6 @@\n-        Byte512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF512B payload;\n+\n+        Byte512Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF512B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -930,1 +856,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -934,1 +860,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -938,1 +864,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -975,6 +907,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -982,0 +917,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF64B)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF64B) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 8));\n-    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(8, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.newInstanceFactory(byte.class, 8));\n+    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(8, (byte[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Byte64Mask maskFromArray(boolean[] bits) {\n-        return new Byte64Mask(bits);\n+    Byte64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Byte64Mask(payload);\n@@ -169,1 +157,1 @@\n-    Byte64Shuffle shuffleFromBytes(byte[] reorder) { return new Byte64Shuffle(reorder); }\n+    Byte64Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Byte64Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Byte64Vector vectorFactory(byte[] vec) {\n-        return new Byte64Vector(vec);\n-    }\n-\n@@ -550,1 +531,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -577,1 +558,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -588,1 +569,1 @@\n-    static final class Byte64Mask extends AbstractMask<Byte> {\n+    static final value class Byte64Mask extends AbstractMask<Byte> {\n@@ -592,3 +573,1 @@\n-        Byte64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -596,2 +575,2 @@\n-        Byte64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Byte64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -600,10 +579,2 @@\n-        Byte64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Byte64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -612,4 +583,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Byte64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -628,4 +597,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -633,18 +598,2 @@\n-        Byte64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Byte64Mask(res);\n-        }\n-\n-        @Override\n-        Byte64Mask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Byte64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Byte64Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -660,27 +609,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -706,1 +628,1 @@\n-            return (Byte64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Byte64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -719,3 +641,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte64Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -729,3 +651,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte64Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -739,3 +661,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte64Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -750,1 +672,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Byte64Mask) m).trueCountHelper());\n@@ -757,1 +679,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte64Mask) m).firstTrueHelper());\n@@ -764,1 +686,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte64Mask) m).lastTrueHelper());\n@@ -774,1 +696,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Byte64Mask) m).toLongHelper());\n@@ -784,1 +706,1 @@\n-                                         (m, __) -> anyTrueHelper(((Byte64Mask)m).getBits()));\n+                                         (m, __) -> ((Byte64Mask) m).anyTrueHelper());\n@@ -792,1 +714,1 @@\n-                                         (m, __) -> allTrueHelper(((Byte64Mask)m).getBits()));\n+                                         (m, __) -> ((Byte64Mask) m).allTrueHelper());\n@@ -809,1 +731,1 @@\n-    static final class Byte64Shuffle extends AbstractShuffle<Byte> {\n+    static final value class Byte64Shuffle extends AbstractShuffle<Byte> {\n@@ -813,2 +735,6 @@\n-        Byte64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Byte64Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF64B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -818,1 +744,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -822,1 +748,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -826,1 +752,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -863,6 +795,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -870,0 +805,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,5 +96,0 @@\n-    \/*package-private*\/\n-    abstract byte[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -105,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -108,2 +103,0 @@\n-    abstract ByteVector vectorFactory(byte[] vec);\n-\n@@ -119,2 +112,2 @@\n-    AbstractMask<Byte> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Byte> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -144,1 +137,2 @@\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -146,1 +140,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -167,1 +161,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -169,1 +163,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -172,2 +166,2 @@\n-            byte v = Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES);\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(i, v));\n+            byte v = Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(i, v));\n@@ -190,2 +184,2 @@\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n@@ -193,1 +187,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -196,2 +191,3 @@\n-            byte v = Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES);\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, mbits[i] ? f.apply(i, v): v);\n+            byte v = Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, v);\n@@ -218,2 +214,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ByteVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o).vec();\n@@ -221,1 +217,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -224,3 +220,3 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n-            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(i, v1, v2));\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(i, v1, v2));\n@@ -245,3 +241,3 @@\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ByteVector)o).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o).vec();\n@@ -249,1 +245,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -252,3 +249,4 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n-            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            byte v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, v);\n@@ -277,3 +275,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ByteVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((ByteVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o1).vec();\n+        VectorPayloadMF vec3 = ((ByteVector)o2).vec();\n@@ -281,1 +279,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -284,4 +282,4 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n-            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n-            byte v3 = Unsafe.getUnsafe().getByte(vec3, start_offset + i * Byte.BYTES);\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(i, v1, v2, v3));\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            byte v3 = Unsafe.getUnsafe().getByte(vec3, vOffset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(i, v1, v2, v3));\n@@ -308,4 +306,4 @@\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ByteVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((ByteVector)o2).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o1).vec();\n+        VectorPayloadMF vec3 = ((ByteVector)o2).vec();\n@@ -313,1 +311,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -316,4 +315,5 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n-            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n-            byte v3 = Unsafe.getUnsafe().getByte(vec3, start_offset + i * Byte.BYTES);\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            byte v3 = Unsafe.getUnsafe().getByte(vec3, vOffset + i * Byte.BYTES);\n+            byte v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, v);\n@@ -337,3 +337,4 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -342,2 +343,2 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            byte v1 = Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -351,2 +352,2 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -355,1 +356,1 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES);\n+            byte v1 = Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES);\n@@ -375,1 +376,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -377,1 +378,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -379,1 +380,1 @@\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -393,1 +394,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -395,2 +396,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -398,2 +400,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -419,1 +421,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -421,1 +423,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -423,1 +425,1 @@\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -437,1 +439,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -439,2 +441,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -442,2 +445,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -463,2 +466,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -467,1 +470,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES));\n@@ -477,3 +480,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -482,2 +486,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES));\n@@ -498,2 +502,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -502,1 +506,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES));\n@@ -512,3 +516,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -517,2 +522,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES));\n@@ -540,2 +545,0 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ByteVector)o).vec_mf();\n@@ -543,2 +546,6 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -546,3 +553,3 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n-            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -550,1 +557,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -4344,1 +4352,2 @@\n-            boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -4346,1 +4355,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":111,"deletions":102,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF128D)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF128D) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 2));\n-    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(2, (double [])(VSPECIES.iotaArray())));\n+    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.newInstanceFactory(double.class, 2));\n+    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(2, (double[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Double128Mask maskFromArray(boolean[] bits) {\n-        return new Double128Mask(bits);\n+    Double128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Double128Mask(payload);\n@@ -169,1 +157,1 @@\n-    Double128Shuffle shuffleFromBytes(byte[] reorder) { return new Double128Shuffle(reorder); }\n+    Double128Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Double128Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Double128Vector vectorFactory(double[] vec) {\n-        return new Double128Vector(vec);\n-    }\n-\n@@ -533,1 +514,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -554,1 +535,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -565,1 +546,1 @@\n-    static final class Double128Mask extends AbstractMask<Double> {\n+    static final value class Double128Mask extends AbstractMask<Double> {\n@@ -569,3 +550,1 @@\n-        Double128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF16Z payload;\n@@ -573,2 +552,2 @@\n-        Double128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Double128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16Z) payload;\n@@ -577,10 +556,2 @@\n-        Double128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Double128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -589,4 +560,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Double128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -605,4 +574,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -610,18 +575,2 @@\n-        Double128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Double128Mask(res);\n-        }\n-\n-        @Override\n-        Double128Mask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Double128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Double128Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -637,27 +586,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -683,1 +605,1 @@\n-            return (Double128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Double128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -696,3 +618,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double128Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -706,3 +628,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double128Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -716,3 +638,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double128Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -727,1 +649,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Double128Mask) m).trueCountHelper());\n@@ -734,1 +656,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double128Mask) m).firstTrueHelper());\n@@ -741,1 +663,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double128Mask) m).lastTrueHelper());\n@@ -751,1 +673,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Double128Mask) m).toLongHelper());\n@@ -761,1 +683,1 @@\n-                                         (m, __) -> anyTrueHelper(((Double128Mask)m).getBits()));\n+                                         (m, __) -> ((Double128Mask) m).anyTrueHelper());\n@@ -769,1 +691,1 @@\n-                                         (m, __) -> allTrueHelper(((Double128Mask)m).getBits()));\n+                                         (m, __) -> ((Double128Mask) m).allTrueHelper());\n@@ -786,1 +708,1 @@\n-    static final class Double128Shuffle extends AbstractShuffle<Double> {\n+    static final value class Double128Shuffle extends AbstractShuffle<Double> {\n@@ -790,2 +712,6 @@\n-        Double128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF16B payload;\n+\n+        Double128Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF16B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -795,1 +721,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -799,1 +725,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -803,1 +729,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -840,6 +772,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -847,0 +782,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF256D)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF256D) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 4));\n-    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(4, (double [])(VSPECIES.iotaArray())));\n+    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.newInstanceFactory(double.class, 4));\n+    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(4, (double[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Double256Mask maskFromArray(boolean[] bits) {\n-        return new Double256Mask(bits);\n+    Double256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Double256Mask(payload);\n@@ -169,1 +157,1 @@\n-    Double256Shuffle shuffleFromBytes(byte[] reorder) { return new Double256Shuffle(reorder); }\n+    Double256Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Double256Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Double256Vector vectorFactory(double[] vec) {\n-        return new Double256Vector(vec);\n-    }\n-\n@@ -535,1 +516,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -558,1 +539,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -569,1 +550,1 @@\n-    static final class Double256Mask extends AbstractMask<Double> {\n+    static final value class Double256Mask extends AbstractMask<Double> {\n@@ -573,3 +554,1 @@\n-        Double256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -577,2 +556,2 @@\n-        Double256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Double256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -581,10 +560,2 @@\n-        Double256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Double256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -593,4 +564,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Double256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -609,4 +578,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -614,18 +579,2 @@\n-        Double256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Double256Mask(res);\n-        }\n-\n-        @Override\n-        Double256Mask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Double256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Double256Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -641,27 +590,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -687,1 +609,1 @@\n-            return (Double256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Double256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -700,3 +622,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double256Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -710,3 +632,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double256Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -720,3 +642,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double256Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -731,1 +653,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Double256Mask) m).trueCountHelper());\n@@ -738,1 +660,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double256Mask) m).firstTrueHelper());\n@@ -745,1 +667,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double256Mask) m).lastTrueHelper());\n@@ -755,1 +677,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Double256Mask) m).toLongHelper());\n@@ -765,1 +687,1 @@\n-                                         (m, __) -> anyTrueHelper(((Double256Mask)m).getBits()));\n+                                         (m, __) -> ((Double256Mask) m).anyTrueHelper());\n@@ -773,1 +695,1 @@\n-                                         (m, __) -> allTrueHelper(((Double256Mask)m).getBits()));\n+                                         (m, __) -> ((Double256Mask) m).allTrueHelper());\n@@ -790,1 +712,1 @@\n-    static final class Double256Shuffle extends AbstractShuffle<Double> {\n+    static final value class Double256Shuffle extends AbstractShuffle<Double> {\n@@ -794,2 +716,6 @@\n-        Double256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Double256Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF32B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -799,1 +725,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -803,1 +729,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -807,1 +733,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -844,6 +776,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -851,0 +786,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF512D)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF512D) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 8));\n-    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(8, (double [])(VSPECIES.iotaArray())));\n+    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.newInstanceFactory(double.class, 8));\n+    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(8, (double[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Double512Mask maskFromArray(boolean[] bits) {\n-        return new Double512Mask(bits);\n+    Double512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Double512Mask(payload);\n@@ -169,1 +157,1 @@\n-    Double512Shuffle shuffleFromBytes(byte[] reorder) { return new Double512Shuffle(reorder); }\n+    Double512Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Double512Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Double512Vector vectorFactory(double[] vec) {\n-        return new Double512Vector(vec);\n-    }\n-\n@@ -539,1 +520,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -566,1 +547,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -577,1 +558,1 @@\n-    static final class Double512Mask extends AbstractMask<Double> {\n+    static final value class Double512Mask extends AbstractMask<Double> {\n@@ -581,3 +562,1 @@\n-        Double512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -585,2 +564,2 @@\n-        Double512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Double512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -589,10 +568,2 @@\n-        Double512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Double512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -601,4 +572,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Double512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -617,4 +586,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -622,18 +587,2 @@\n-        Double512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Double512Mask(res);\n-        }\n-\n-        @Override\n-        Double512Mask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Double512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Double512Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -649,27 +598,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -695,1 +617,1 @@\n-            return (Double512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Double512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -708,3 +630,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double512Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -718,3 +640,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double512Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -728,3 +650,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double512Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -739,1 +661,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Double512Mask) m).trueCountHelper());\n@@ -746,1 +668,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double512Mask) m).firstTrueHelper());\n@@ -753,1 +675,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double512Mask) m).lastTrueHelper());\n@@ -763,1 +685,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Double512Mask) m).toLongHelper());\n@@ -773,1 +695,1 @@\n-                                         (m, __) -> anyTrueHelper(((Double512Mask)m).getBits()));\n+                                         (m, __) -> ((Double512Mask) m).anyTrueHelper());\n@@ -781,1 +703,1 @@\n-                                         (m, __) -> allTrueHelper(((Double512Mask)m).getBits()));\n+                                         (m, __) -> ((Double512Mask) m).allTrueHelper());\n@@ -798,1 +720,1 @@\n-    static final class Double512Shuffle extends AbstractShuffle<Double> {\n+    static final value class Double512Shuffle extends AbstractShuffle<Double> {\n@@ -802,2 +724,6 @@\n-        Double512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Double512Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF64B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -807,1 +733,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -811,1 +737,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -815,1 +741,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -852,6 +784,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -859,0 +794,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF64D)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF64D) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 1));\n-    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(1, (double [])(VSPECIES.iotaArray())));\n+    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.newInstanceFactory(double.class, 1));\n+    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(1, (double[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Double64Mask maskFromArray(boolean[] bits) {\n-        return new Double64Mask(bits);\n+    Double64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Double64Mask(payload);\n@@ -169,1 +157,1 @@\n-    Double64Shuffle shuffleFromBytes(byte[] reorder) { return new Double64Shuffle(reorder); }\n+    Double64Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Double64Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Double64Vector vectorFactory(double[] vec) {\n-        return new Double64Vector(vec);\n-    }\n-\n@@ -532,1 +513,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -552,1 +533,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -563,1 +544,1 @@\n-    static final class Double64Mask extends AbstractMask<Double> {\n+    static final value class Double64Mask extends AbstractMask<Double> {\n@@ -567,3 +548,1 @@\n-        Double64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF8Z payload;\n@@ -571,2 +550,2 @@\n-        Double64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Double64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF8Z) payload;\n@@ -575,10 +554,2 @@\n-        Double64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Double64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -587,4 +558,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Double64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -603,4 +572,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -608,18 +573,2 @@\n-        Double64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Double64Mask(res);\n-        }\n-\n-        @Override\n-        Double64Mask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Double64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Double64Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -635,27 +584,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -681,1 +603,1 @@\n-            return (Double64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Double64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -694,3 +616,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double64Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -704,3 +626,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double64Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -714,3 +636,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double64Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -725,1 +647,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Double64Mask) m).trueCountHelper());\n@@ -732,1 +654,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double64Mask) m).firstTrueHelper());\n@@ -739,1 +661,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double64Mask) m).lastTrueHelper());\n@@ -749,1 +671,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Double64Mask) m).toLongHelper());\n@@ -759,1 +681,1 @@\n-                                         (m, __) -> anyTrueHelper(((Double64Mask)m).getBits()));\n+                                         (m, __) -> ((Double64Mask) m).anyTrueHelper());\n@@ -767,1 +689,1 @@\n-                                         (m, __) -> allTrueHelper(((Double64Mask)m).getBits()));\n+                                         (m, __) -> ((Double64Mask) m).allTrueHelper());\n@@ -784,1 +706,1 @@\n-    static final class Double64Shuffle extends AbstractShuffle<Double> {\n+    static final value class Double64Shuffle extends AbstractShuffle<Double> {\n@@ -788,2 +710,6 @@\n-        Double64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF8B payload;\n+\n+        Double64Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF8B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -793,1 +719,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -797,1 +723,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -801,1 +727,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -838,6 +770,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -845,0 +780,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,5 +96,0 @@\n-    \/*package-private*\/\n-    abstract double[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -105,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -108,2 +103,0 @@\n-    abstract DoubleVector vectorFactory(double[] vec);\n-\n@@ -119,2 +112,2 @@\n-    AbstractMask<Double> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Double> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -144,1 +137,2 @@\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -146,1 +140,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -167,1 +161,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -169,1 +163,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -172,2 +166,2 @@\n-            double v = Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES);\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(i, v));\n+            double v = Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(i, v));\n@@ -190,2 +184,2 @@\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n@@ -193,1 +187,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -196,2 +191,3 @@\n-            double v = Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES);\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, mbits[i] ? f.apply(i, v): v);\n+            double v = Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, v);\n@@ -218,2 +214,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((DoubleVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o).vec();\n@@ -221,1 +217,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -224,3 +220,3 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n-            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(i, v1, v2));\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(i, v1, v2));\n@@ -245,3 +241,3 @@\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((DoubleVector)o).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o).vec();\n@@ -249,1 +245,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -252,3 +249,4 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n-            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            double v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, v);\n@@ -277,3 +275,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((DoubleVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((DoubleVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o1).vec();\n+        VectorPayloadMF vec3 = ((DoubleVector)o2).vec();\n@@ -281,1 +279,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -284,4 +282,4 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n-            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n-            double v3 = Unsafe.getUnsafe().getDouble(vec3, start_offset + i * Double.BYTES);\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(i, v1, v2, v3));\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            double v3 = Unsafe.getUnsafe().getDouble(vec3, vOffset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(i, v1, v2, v3));\n@@ -308,4 +306,4 @@\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((DoubleVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((DoubleVector)o2).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o1).vec();\n+        VectorPayloadMF vec3 = ((DoubleVector)o2).vec();\n@@ -313,1 +311,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -316,4 +315,5 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n-            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n-            double v3 = Unsafe.getUnsafe().getDouble(vec3, start_offset + i * Double.BYTES);\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            double v3 = Unsafe.getUnsafe().getDouble(vec3, vOffset + i * Double.BYTES);\n+            double v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, v);\n@@ -337,3 +337,4 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -342,2 +343,2 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            double v1 = Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -351,2 +352,2 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -355,1 +356,1 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES);\n+            double v1 = Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES);\n@@ -375,1 +376,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -377,1 +378,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -379,1 +380,1 @@\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -393,1 +394,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -395,2 +396,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -398,2 +400,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -419,1 +421,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -421,1 +423,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -423,1 +425,1 @@\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -437,1 +439,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -439,2 +441,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -442,2 +445,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -463,2 +466,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -467,1 +470,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES));\n@@ -477,3 +480,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -482,2 +486,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES));\n@@ -498,2 +502,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -502,1 +506,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES));\n@@ -512,3 +516,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -517,2 +522,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES));\n@@ -540,2 +545,0 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((DoubleVector)o).vec_mf();\n@@ -543,2 +546,6 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -546,3 +553,3 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n-            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -550,1 +557,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -3948,1 +3956,2 @@\n-            boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -3950,1 +3959,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":111,"deletions":102,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF128F)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF128F) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 4));\n-    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(4, (float [])(VSPECIES.iotaArray())));\n+    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.newInstanceFactory(float.class, 4));\n+    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(4, (float[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Float128Mask maskFromArray(boolean[] bits) {\n-        return new Float128Mask(bits);\n+    Float128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Float128Mask(payload);\n@@ -169,1 +157,1 @@\n-    Float128Shuffle shuffleFromBytes(byte[] reorder) { return new Float128Shuffle(reorder); }\n+    Float128Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Float128Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Float128Vector vectorFactory(float[] vec) {\n-        return new Float128Vector(vec);\n-    }\n-\n@@ -535,1 +516,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -558,1 +539,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -569,1 +550,1 @@\n-    static final class Float128Mask extends AbstractMask<Float> {\n+    static final value class Float128Mask extends AbstractMask<Float> {\n@@ -573,3 +554,1 @@\n-        Float128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -577,2 +556,2 @@\n-        Float128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Float128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -581,10 +560,2 @@\n-        Float128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Float128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -593,4 +564,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Float128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -609,4 +578,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -614,18 +579,2 @@\n-        Float128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Float128Mask(res);\n-        }\n-\n-        @Override\n-        Float128Mask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Float128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Float128Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -641,27 +590,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -687,1 +609,1 @@\n-            return (Float128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Float128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -700,3 +622,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float128Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -710,3 +632,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float128Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -720,3 +642,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float128Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -731,1 +653,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Float128Mask) m).trueCountHelper());\n@@ -738,1 +660,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float128Mask) m).firstTrueHelper());\n@@ -745,1 +667,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float128Mask) m).lastTrueHelper());\n@@ -755,1 +677,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Float128Mask) m).toLongHelper());\n@@ -765,1 +687,1 @@\n-                                         (m, __) -> anyTrueHelper(((Float128Mask)m).getBits()));\n+                                         (m, __) -> ((Float128Mask) m).anyTrueHelper());\n@@ -773,1 +695,1 @@\n-                                         (m, __) -> allTrueHelper(((Float128Mask)m).getBits()));\n+                                         (m, __) -> ((Float128Mask) m).allTrueHelper());\n@@ -790,1 +712,1 @@\n-    static final class Float128Shuffle extends AbstractShuffle<Float> {\n+    static final value class Float128Shuffle extends AbstractShuffle<Float> {\n@@ -794,2 +716,6 @@\n-        Float128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Float128Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF32B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -799,1 +725,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -803,1 +729,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -807,1 +733,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -844,6 +776,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -851,0 +786,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF256F)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF256F) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 8));\n-    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(8, (float [])(VSPECIES.iotaArray())));\n+    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.newInstanceFactory(float.class, 8));\n+    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(8, (float[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Float256Mask maskFromArray(boolean[] bits) {\n-        return new Float256Mask(bits);\n+    Float256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Float256Mask(payload);\n@@ -169,1 +157,1 @@\n-    Float256Shuffle shuffleFromBytes(byte[] reorder) { return new Float256Shuffle(reorder); }\n+    Float256Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Float256Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Float256Vector vectorFactory(float[] vec) {\n-        return new Float256Vector(vec);\n-    }\n-\n@@ -539,1 +520,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -566,1 +547,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -577,1 +558,1 @@\n-    static final class Float256Mask extends AbstractMask<Float> {\n+    static final value class Float256Mask extends AbstractMask<Float> {\n@@ -581,3 +562,1 @@\n-        Float256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -585,2 +564,2 @@\n-        Float256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Float256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -589,10 +568,2 @@\n-        Float256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Float256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -601,4 +572,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Float256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -617,4 +586,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -622,18 +587,2 @@\n-        Float256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Float256Mask(res);\n-        }\n-\n-        @Override\n-        Float256Mask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Float256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Float256Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -649,27 +598,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -695,1 +617,1 @@\n-            return (Float256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Float256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -708,3 +630,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float256Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -718,3 +640,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float256Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -728,3 +650,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float256Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -739,1 +661,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Float256Mask) m).trueCountHelper());\n@@ -746,1 +668,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float256Mask) m).firstTrueHelper());\n@@ -753,1 +675,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float256Mask) m).lastTrueHelper());\n@@ -763,1 +685,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Float256Mask) m).toLongHelper());\n@@ -773,1 +695,1 @@\n-                                         (m, __) -> anyTrueHelper(((Float256Mask)m).getBits()));\n+                                         (m, __) -> ((Float256Mask) m).anyTrueHelper());\n@@ -781,1 +703,1 @@\n-                                         (m, __) -> allTrueHelper(((Float256Mask)m).getBits()));\n+                                         (m, __) -> ((Float256Mask) m).allTrueHelper());\n@@ -798,1 +720,1 @@\n-    static final class Float256Shuffle extends AbstractShuffle<Float> {\n+    static final value class Float256Shuffle extends AbstractShuffle<Float> {\n@@ -802,2 +724,6 @@\n-        Float256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Float256Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF64B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -807,1 +733,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -811,1 +737,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -815,1 +741,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -852,6 +784,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -859,0 +794,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF512F)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF512F) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 16));\n-    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(16, (float [])(VSPECIES.iotaArray())));\n+    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.newInstanceFactory(float.class, 16));\n+    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(16, (float[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Float512Mask maskFromArray(boolean[] bits) {\n-        return new Float512Mask(bits);\n+    Float512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Float512Mask(payload);\n@@ -169,1 +157,1 @@\n-    Float512Shuffle shuffleFromBytes(byte[] reorder) { return new Float512Shuffle(reorder); }\n+    Float512Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Float512Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Float512Vector vectorFactory(float[] vec) {\n-        return new Float512Vector(vec);\n-    }\n-\n@@ -547,1 +528,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -582,1 +563,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -593,1 +574,1 @@\n-    static final class Float512Mask extends AbstractMask<Float> {\n+    static final value class Float512Mask extends AbstractMask<Float> {\n@@ -597,3 +578,1 @@\n-        Float512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF128Z payload;\n@@ -601,2 +580,2 @@\n-        Float512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Float512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128Z) payload;\n@@ -605,10 +584,2 @@\n-        Float512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Float512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -617,4 +588,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Float512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -633,4 +602,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -638,18 +603,2 @@\n-        Float512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Float512Mask(res);\n-        }\n-\n-        @Override\n-        Float512Mask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Float512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Float512Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -665,27 +614,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -711,1 +633,1 @@\n-            return (Float512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Float512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -724,3 +646,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float512Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -734,3 +656,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float512Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -744,3 +666,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float512Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -755,1 +677,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Float512Mask) m).trueCountHelper());\n@@ -762,1 +684,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float512Mask) m).firstTrueHelper());\n@@ -769,1 +691,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float512Mask) m).lastTrueHelper());\n@@ -779,1 +701,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Float512Mask) m).toLongHelper());\n@@ -789,1 +711,1 @@\n-                                         (m, __) -> anyTrueHelper(((Float512Mask)m).getBits()));\n+                                         (m, __) -> ((Float512Mask) m).anyTrueHelper());\n@@ -797,1 +719,1 @@\n-                                         (m, __) -> allTrueHelper(((Float512Mask)m).getBits()));\n+                                         (m, __) -> ((Float512Mask) m).allTrueHelper());\n@@ -814,1 +736,1 @@\n-    static final class Float512Shuffle extends AbstractShuffle<Float> {\n+    static final value class Float512Shuffle extends AbstractShuffle<Float> {\n@@ -818,2 +740,6 @@\n-        Float512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF128B payload;\n+\n+        Float512Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF128B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -823,1 +749,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -827,1 +753,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -831,1 +757,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -868,6 +800,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -875,0 +810,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF64F)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF64F) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 2));\n-    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(2, (float [])(VSPECIES.iotaArray())));\n+    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.newInstanceFactory(float.class, 2));\n+    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(2, (float[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Float64Mask maskFromArray(boolean[] bits) {\n-        return new Float64Mask(bits);\n+    Float64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Float64Mask(payload);\n@@ -169,1 +157,1 @@\n-    Float64Shuffle shuffleFromBytes(byte[] reorder) { return new Float64Shuffle(reorder); }\n+    Float64Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Float64Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Float64Vector vectorFactory(float[] vec) {\n-        return new Float64Vector(vec);\n-    }\n-\n@@ -533,1 +514,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -554,1 +535,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -565,1 +546,1 @@\n-    static final class Float64Mask extends AbstractMask<Float> {\n+    static final value class Float64Mask extends AbstractMask<Float> {\n@@ -569,3 +550,1 @@\n-        Float64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF16Z payload;\n@@ -573,2 +552,2 @@\n-        Float64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Float64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16Z) payload;\n@@ -577,10 +556,2 @@\n-        Float64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Float64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -589,4 +560,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Float64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -605,4 +574,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -610,18 +575,2 @@\n-        Float64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Float64Mask(res);\n-        }\n-\n-        @Override\n-        Float64Mask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Float64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Float64Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -637,27 +586,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -683,1 +605,1 @@\n-            return (Float64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Float64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -696,3 +618,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float64Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -706,3 +628,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float64Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -716,3 +638,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float64Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -727,1 +649,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Float64Mask) m).trueCountHelper());\n@@ -734,1 +656,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float64Mask) m).firstTrueHelper());\n@@ -741,1 +663,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float64Mask) m).lastTrueHelper());\n@@ -751,1 +673,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Float64Mask) m).toLongHelper());\n@@ -761,1 +683,1 @@\n-                                         (m, __) -> anyTrueHelper(((Float64Mask)m).getBits()));\n+                                         (m, __) -> ((Float64Mask) m).anyTrueHelper());\n@@ -769,1 +691,1 @@\n-                                         (m, __) -> allTrueHelper(((Float64Mask)m).getBits()));\n+                                         (m, __) -> ((Float64Mask) m).allTrueHelper());\n@@ -786,1 +708,1 @@\n-    static final class Float64Shuffle extends AbstractShuffle<Float> {\n+    static final value class Float64Shuffle extends AbstractShuffle<Float> {\n@@ -790,2 +712,6 @@\n-        Float64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF16B payload;\n+\n+        Float64Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF16B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -795,1 +721,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -799,1 +725,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -803,1 +729,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -840,6 +772,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -847,0 +782,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,5 +96,0 @@\n-    \/*package-private*\/\n-    abstract float[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -105,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -108,2 +103,0 @@\n-    abstract FloatVector vectorFactory(float[] vec);\n-\n@@ -119,2 +112,2 @@\n-    AbstractMask<Float> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Float> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -144,1 +137,2 @@\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -146,1 +140,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -167,1 +161,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -169,1 +163,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -172,2 +166,2 @@\n-            float v = Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES);\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(i, v));\n+            float v = Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(i, v));\n@@ -190,2 +184,2 @@\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n@@ -193,1 +187,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -196,2 +191,3 @@\n-            float v = Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES);\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, mbits[i] ? f.apply(i, v): v);\n+            float v = Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, v);\n@@ -218,2 +214,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((FloatVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o).vec();\n@@ -221,1 +217,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -224,3 +220,3 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n-            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(i, v1, v2));\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(i, v1, v2));\n@@ -245,3 +241,3 @@\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((FloatVector)o).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o).vec();\n@@ -249,1 +245,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -252,3 +249,4 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n-            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            float v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, v);\n@@ -277,3 +275,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((FloatVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((FloatVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o1).vec();\n+        VectorPayloadMF vec3 = ((FloatVector)o2).vec();\n@@ -281,1 +279,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -284,4 +282,4 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n-            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n-            float v3 = Unsafe.getUnsafe().getFloat(vec3, start_offset + i * Float.BYTES);\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(i, v1, v2, v3));\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            float v3 = Unsafe.getUnsafe().getFloat(vec3, vOffset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(i, v1, v2, v3));\n@@ -308,4 +306,4 @@\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((FloatVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((FloatVector)o2).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o1).vec();\n+        VectorPayloadMF vec3 = ((FloatVector)o2).vec();\n@@ -313,1 +311,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -316,4 +315,5 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n-            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n-            float v3 = Unsafe.getUnsafe().getFloat(vec3, start_offset + i * Float.BYTES);\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            float v3 = Unsafe.getUnsafe().getFloat(vec3, vOffset + i * Float.BYTES);\n+            float v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, v);\n@@ -337,3 +337,4 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -342,2 +343,2 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            float v1 = Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -351,2 +352,2 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -355,1 +356,1 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES);\n+            float v1 = Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES);\n@@ -375,1 +376,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -377,1 +378,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -379,1 +380,1 @@\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -393,1 +394,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -395,2 +396,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -398,2 +400,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -419,1 +421,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -421,1 +423,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -423,1 +425,1 @@\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -437,1 +439,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -439,2 +441,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -442,2 +445,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -463,2 +466,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -467,1 +470,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES));\n@@ -477,3 +480,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -482,2 +486,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES));\n@@ -498,2 +502,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -502,1 +506,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES));\n@@ -512,3 +516,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -517,2 +522,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES));\n@@ -540,2 +545,0 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((FloatVector)o).vec_mf();\n@@ -543,2 +546,6 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -546,3 +553,3 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n-            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -550,1 +557,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -3889,1 +3897,2 @@\n-            boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -3891,1 +3900,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":111,"deletions":102,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF128I)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF128I) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 4));\n-    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(4, (int [])(VSPECIES.iotaArray())));\n+    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.newInstanceFactory(int.class, 4));\n+    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(4, (int[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Int128Mask maskFromArray(boolean[] bits) {\n-        return new Int128Mask(bits);\n+    Int128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Int128Mask(payload);\n@@ -169,1 +157,1 @@\n-    Int128Shuffle shuffleFromBytes(byte[] reorder) { return new Int128Shuffle(reorder); }\n+    Int128Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Int128Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Int128Vector vectorFactory(int[] vec) {\n-        return new Int128Vector(vec);\n-    }\n-\n@@ -546,1 +527,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -569,1 +550,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -580,1 +561,1 @@\n-    static final class Int128Mask extends AbstractMask<Integer> {\n+    static final value class Int128Mask extends AbstractMask<Integer> {\n@@ -584,3 +565,1 @@\n-        Int128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -588,2 +567,2 @@\n-        Int128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Int128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -592,10 +571,2 @@\n-        Int128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Int128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -604,4 +575,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Int128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -620,4 +589,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -625,18 +590,2 @@\n-        Int128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Int128Mask(res);\n-        }\n-\n-        @Override\n-        Int128Mask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Int128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Int128Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -652,27 +601,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -698,1 +620,1 @@\n-            return (Int128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Int128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -711,3 +633,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int128Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -721,3 +643,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int128Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -731,3 +653,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int128Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -742,1 +664,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Int128Mask) m).trueCountHelper());\n@@ -749,1 +671,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int128Mask) m).firstTrueHelper());\n@@ -756,1 +678,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int128Mask) m).lastTrueHelper());\n@@ -766,1 +688,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Int128Mask) m).toLongHelper());\n@@ -776,1 +698,1 @@\n-                                         (m, __) -> anyTrueHelper(((Int128Mask)m).getBits()));\n+                                         (m, __) -> ((Int128Mask) m).anyTrueHelper());\n@@ -784,1 +706,1 @@\n-                                         (m, __) -> allTrueHelper(((Int128Mask)m).getBits()));\n+                                         (m, __) -> ((Int128Mask) m).allTrueHelper());\n@@ -801,1 +723,1 @@\n-    static final class Int128Shuffle extends AbstractShuffle<Integer> {\n+    static final value class Int128Shuffle extends AbstractShuffle<Integer> {\n@@ -805,2 +727,6 @@\n-        Int128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Int128Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF32B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -810,1 +736,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -814,1 +740,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -818,1 +744,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -855,6 +787,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -862,0 +797,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF256I)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF256I) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 8));\n-    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(8, (int [])(VSPECIES.iotaArray())));\n+    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.newInstanceFactory(int.class, 8));\n+    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(8, (int[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Int256Mask maskFromArray(boolean[] bits) {\n-        return new Int256Mask(bits);\n+    Int256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Int256Mask(payload);\n@@ -169,1 +157,1 @@\n-    Int256Shuffle shuffleFromBytes(byte[] reorder) { return new Int256Shuffle(reorder); }\n+    Int256Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Int256Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Int256Vector vectorFactory(int[] vec) {\n-        return new Int256Vector(vec);\n-    }\n-\n@@ -550,1 +531,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -577,1 +558,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -588,1 +569,1 @@\n-    static final class Int256Mask extends AbstractMask<Integer> {\n+    static final value class Int256Mask extends AbstractMask<Integer> {\n@@ -592,3 +573,1 @@\n-        Int256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -596,2 +575,2 @@\n-        Int256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Int256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -600,10 +579,2 @@\n-        Int256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Int256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -612,4 +583,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Int256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -628,4 +597,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -633,18 +598,2 @@\n-        Int256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Int256Mask(res);\n-        }\n-\n-        @Override\n-        Int256Mask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Int256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Int256Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -660,27 +609,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -706,1 +628,1 @@\n-            return (Int256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Int256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -719,3 +641,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int256Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -729,3 +651,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int256Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -739,3 +661,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int256Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -750,1 +672,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Int256Mask) m).trueCountHelper());\n@@ -757,1 +679,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int256Mask) m).firstTrueHelper());\n@@ -764,1 +686,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int256Mask) m).lastTrueHelper());\n@@ -774,1 +696,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Int256Mask) m).toLongHelper());\n@@ -784,1 +706,1 @@\n-                                         (m, __) -> anyTrueHelper(((Int256Mask)m).getBits()));\n+                                         (m, __) -> ((Int256Mask) m).anyTrueHelper());\n@@ -792,1 +714,1 @@\n-                                         (m, __) -> allTrueHelper(((Int256Mask)m).getBits()));\n+                                         (m, __) -> ((Int256Mask) m).allTrueHelper());\n@@ -809,1 +731,1 @@\n-    static final class Int256Shuffle extends AbstractShuffle<Integer> {\n+    static final value class Int256Shuffle extends AbstractShuffle<Integer> {\n@@ -813,2 +735,6 @@\n-        Int256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Int256Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF64B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -818,1 +744,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -822,1 +748,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -826,1 +752,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -863,6 +795,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -870,0 +805,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF512I)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF512I) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 16));\n-    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(16, (int [])(VSPECIES.iotaArray())));\n+    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.newInstanceFactory(int.class, 16));\n+    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(16, (int[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Int512Mask maskFromArray(boolean[] bits) {\n-        return new Int512Mask(bits);\n+    Int512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Int512Mask(payload);\n@@ -169,1 +157,1 @@\n-    Int512Shuffle shuffleFromBytes(byte[] reorder) { return new Int512Shuffle(reorder); }\n+    Int512Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Int512Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Int512Vector vectorFactory(int[] vec) {\n-        return new Int512Vector(vec);\n-    }\n-\n@@ -558,1 +539,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -593,1 +574,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -604,1 +585,1 @@\n-    static final class Int512Mask extends AbstractMask<Integer> {\n+    static final value class Int512Mask extends AbstractMask<Integer> {\n@@ -608,3 +589,1 @@\n-        Int512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF128Z payload;\n@@ -612,2 +591,2 @@\n-        Int512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Int512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128Z) payload;\n@@ -616,10 +595,2 @@\n-        Int512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Int512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -628,4 +599,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Int512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -644,4 +613,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -649,18 +614,2 @@\n-        Int512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Int512Mask(res);\n-        }\n-\n-        @Override\n-        Int512Mask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Int512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Int512Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -676,27 +625,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -722,1 +644,1 @@\n-            return (Int512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Int512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -735,3 +657,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int512Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -745,3 +667,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int512Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -755,3 +677,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int512Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -766,1 +688,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Int512Mask) m).trueCountHelper());\n@@ -773,1 +695,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int512Mask) m).firstTrueHelper());\n@@ -780,1 +702,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int512Mask) m).lastTrueHelper());\n@@ -790,1 +712,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Int512Mask) m).toLongHelper());\n@@ -800,1 +722,1 @@\n-                                         (m, __) -> anyTrueHelper(((Int512Mask)m).getBits()));\n+                                         (m, __) -> ((Int512Mask) m).anyTrueHelper());\n@@ -808,1 +730,1 @@\n-                                         (m, __) -> allTrueHelper(((Int512Mask)m).getBits()));\n+                                         (m, __) -> ((Int512Mask) m).allTrueHelper());\n@@ -825,1 +747,1 @@\n-    static final class Int512Shuffle extends AbstractShuffle<Integer> {\n+    static final value class Int512Shuffle extends AbstractShuffle<Integer> {\n@@ -829,2 +751,6 @@\n-        Int512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF128B payload;\n+\n+        Int512Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF128B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -834,1 +760,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -838,1 +764,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -842,1 +768,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -879,6 +811,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -886,0 +821,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF64I)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF64I) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 2));\n-    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(2, (int [])(VSPECIES.iotaArray())));\n+    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.newInstanceFactory(int.class, 2));\n+    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(2, (int[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Int64Mask maskFromArray(boolean[] bits) {\n-        return new Int64Mask(bits);\n+    Int64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Int64Mask(payload);\n@@ -169,1 +157,1 @@\n-    Int64Shuffle shuffleFromBytes(byte[] reorder) { return new Int64Shuffle(reorder); }\n+    Int64Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Int64Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Int64Vector vectorFactory(int[] vec) {\n-        return new Int64Vector(vec);\n-    }\n-\n@@ -544,1 +525,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -565,1 +546,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -576,1 +557,1 @@\n-    static final class Int64Mask extends AbstractMask<Integer> {\n+    static final value class Int64Mask extends AbstractMask<Integer> {\n@@ -580,3 +561,1 @@\n-        Int64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF16Z payload;\n@@ -584,2 +563,2 @@\n-        Int64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Int64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16Z) payload;\n@@ -588,10 +567,2 @@\n-        Int64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Int64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -600,4 +571,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Int64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -616,4 +585,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -621,18 +586,2 @@\n-        Int64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Int64Mask(res);\n-        }\n-\n-        @Override\n-        Int64Mask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Int64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Int64Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -648,27 +597,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -694,1 +616,1 @@\n-            return (Int64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Int64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -707,3 +629,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int64Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -717,3 +639,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int64Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -727,3 +649,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int64Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -738,1 +660,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Int64Mask) m).trueCountHelper());\n@@ -745,1 +667,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int64Mask) m).firstTrueHelper());\n@@ -752,1 +674,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int64Mask) m).lastTrueHelper());\n@@ -762,1 +684,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Int64Mask) m).toLongHelper());\n@@ -772,1 +694,1 @@\n-                                         (m, __) -> anyTrueHelper(((Int64Mask)m).getBits()));\n+                                         (m, __) -> ((Int64Mask) m).anyTrueHelper());\n@@ -780,1 +702,1 @@\n-                                         (m, __) -> allTrueHelper(((Int64Mask)m).getBits()));\n+                                         (m, __) -> ((Int64Mask) m).allTrueHelper());\n@@ -797,1 +719,1 @@\n-    static final class Int64Shuffle extends AbstractShuffle<Integer> {\n+    static final value class Int64Shuffle extends AbstractShuffle<Integer> {\n@@ -801,2 +723,6 @@\n-        Int64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF16B payload;\n+\n+        Int64Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF16B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -806,1 +732,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -810,1 +736,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -814,1 +740,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -851,6 +783,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -858,0 +793,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,5 +96,0 @@\n-    \/*package-private*\/\n-    abstract int[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -105,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -108,2 +103,0 @@\n-    abstract IntVector vectorFactory(int[] vec);\n-\n@@ -119,2 +112,2 @@\n-    AbstractMask<Integer> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Integer> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -144,1 +137,2 @@\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -146,1 +140,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -167,1 +161,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -169,1 +163,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -172,2 +166,2 @@\n-            int v = Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES);\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v));\n+            int v = Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(i, v));\n@@ -190,2 +184,2 @@\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n@@ -193,1 +187,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -196,2 +191,3 @@\n-            int v = Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES);\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v): v);\n+            int v = Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, v);\n@@ -218,2 +214,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((IntVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((IntVector)o).vec();\n@@ -221,1 +217,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -224,3 +220,3 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n-            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2));\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(i, v1, v2));\n@@ -245,3 +241,3 @@\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((IntVector)o).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((IntVector)o).vec();\n@@ -249,1 +245,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -252,3 +249,4 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n-            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            int v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, v);\n@@ -277,3 +275,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((IntVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((IntVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((IntVector)o1).vec();\n+        VectorPayloadMF vec3 = ((IntVector)o2).vec();\n@@ -281,1 +279,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -284,4 +282,4 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n-            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n-            int v3 = Unsafe.getUnsafe().getInt(vec3, start_offset + i * Integer.BYTES);\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2, v3));\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            int v3 = Unsafe.getUnsafe().getInt(vec3, vOffset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(i, v1, v2, v3));\n@@ -308,4 +306,4 @@\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((IntVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((IntVector)o2).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((IntVector)o1).vec();\n+        VectorPayloadMF vec3 = ((IntVector)o2).vec();\n@@ -313,1 +311,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -316,4 +315,5 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n-            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n-            int v3 = Unsafe.getUnsafe().getInt(vec3, start_offset + i * Integer.BYTES);\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            int v3 = Unsafe.getUnsafe().getInt(vec3, vOffset + i * Integer.BYTES);\n+            int v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, v);\n@@ -337,3 +337,4 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -342,2 +343,2 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            int v1 = Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -351,2 +352,2 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -355,1 +356,1 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES);\n+            int v1 = Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES);\n@@ -375,1 +376,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -377,1 +378,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -379,1 +380,1 @@\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -393,1 +394,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -395,2 +396,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -398,2 +400,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -419,1 +421,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -421,1 +423,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -423,1 +425,1 @@\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -437,1 +439,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -439,2 +441,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -442,2 +445,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -463,2 +466,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -467,1 +470,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES));\n@@ -477,3 +480,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -482,2 +486,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES));\n@@ -498,2 +502,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -502,1 +506,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES));\n@@ -512,3 +516,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -517,2 +522,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES));\n@@ -540,2 +545,0 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((IntVector)o).vec_mf();\n@@ -543,2 +546,6 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((IntVector)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -546,3 +553,3 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n-            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -550,1 +557,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -4057,1 +4065,2 @@\n-            boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -4059,1 +4068,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":111,"deletions":102,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF128L)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF128L) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 2));\n-    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(2, (long [])(VSPECIES.iotaArray())));\n+    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.newInstanceFactory(long.class, 2));\n+    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(2, (long[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -143,2 +131,2 @@\n-    Long128Mask maskFromArray(boolean[] bits) {\n-        return new Long128Mask(bits);\n+    Long128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Long128Mask(payload);\n@@ -164,1 +152,1 @@\n-    Long128Shuffle shuffleFromBytes(byte[] reorder) { return new Long128Shuffle(reorder); }\n+    Long128Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Long128Shuffle(reorder); }\n@@ -174,7 +162,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Long128Vector vectorFactory(long[] vec) {\n-        return new Long128Vector(vec);\n-    }\n-\n@@ -534,1 +515,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -555,1 +536,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -566,1 +547,1 @@\n-    static final class Long128Mask extends AbstractMask<Long> {\n+    static final value class Long128Mask extends AbstractMask<Long> {\n@@ -570,3 +551,1 @@\n-        Long128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF16Z payload;\n@@ -574,2 +553,2 @@\n-        Long128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Long128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16Z) payload;\n@@ -578,10 +557,2 @@\n-        Long128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Long128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -590,4 +561,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Long128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -606,4 +575,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -611,18 +576,2 @@\n-        Long128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Long128Mask(res);\n-        }\n-\n-        @Override\n-        Long128Mask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Long128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Long128Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -638,27 +587,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -684,1 +606,1 @@\n-            return (Long128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Long128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -697,3 +619,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long128Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -707,3 +629,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long128Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -717,3 +639,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long128Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -728,1 +650,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Long128Mask) m).trueCountHelper());\n@@ -735,1 +657,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long128Mask) m).firstTrueHelper());\n@@ -742,1 +664,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long128Mask) m).lastTrueHelper());\n@@ -752,1 +674,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Long128Mask) m).toLongHelper());\n@@ -762,1 +684,1 @@\n-                                         (m, __) -> anyTrueHelper(((Long128Mask)m).getBits()));\n+                                         (m, __) -> ((Long128Mask) m).anyTrueHelper());\n@@ -770,1 +692,1 @@\n-                                         (m, __) -> allTrueHelper(((Long128Mask)m).getBits()));\n+                                         (m, __) -> ((Long128Mask) m).allTrueHelper());\n@@ -787,1 +709,1 @@\n-    static final class Long128Shuffle extends AbstractShuffle<Long> {\n+    static final value class Long128Shuffle extends AbstractShuffle<Long> {\n@@ -791,2 +713,6 @@\n-        Long128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF16B payload;\n+\n+        Long128Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF16B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -796,1 +722,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -800,1 +726,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -804,1 +730,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -841,6 +773,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -848,0 +783,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF256L)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF256L) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 4));\n-    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(4, (long [])(VSPECIES.iotaArray())));\n+    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.newInstanceFactory(long.class, 4));\n+    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(4, (long[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -143,2 +131,2 @@\n-    Long256Mask maskFromArray(boolean[] bits) {\n-        return new Long256Mask(bits);\n+    Long256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Long256Mask(payload);\n@@ -164,1 +152,1 @@\n-    Long256Shuffle shuffleFromBytes(byte[] reorder) { return new Long256Shuffle(reorder); }\n+    Long256Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Long256Shuffle(reorder); }\n@@ -174,7 +162,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Long256Vector vectorFactory(long[] vec) {\n-        return new Long256Vector(vec);\n-    }\n-\n@@ -536,1 +517,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -559,1 +540,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -570,1 +551,1 @@\n-    static final class Long256Mask extends AbstractMask<Long> {\n+    static final value class Long256Mask extends AbstractMask<Long> {\n@@ -574,3 +555,1 @@\n-        Long256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -578,2 +557,2 @@\n-        Long256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Long256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -582,10 +561,2 @@\n-        Long256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Long256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -594,4 +565,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Long256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -610,4 +579,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -615,18 +580,2 @@\n-        Long256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Long256Mask(res);\n-        }\n-\n-        @Override\n-        Long256Mask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Long256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Long256Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -642,27 +591,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -688,1 +610,1 @@\n-            return (Long256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Long256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -701,3 +623,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long256Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -711,3 +633,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long256Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -721,3 +643,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long256Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -732,1 +654,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Long256Mask) m).trueCountHelper());\n@@ -739,1 +661,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long256Mask) m).firstTrueHelper());\n@@ -746,1 +668,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long256Mask) m).lastTrueHelper());\n@@ -756,1 +678,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Long256Mask) m).toLongHelper());\n@@ -766,1 +688,1 @@\n-                                         (m, __) -> anyTrueHelper(((Long256Mask)m).getBits()));\n+                                         (m, __) -> ((Long256Mask) m).anyTrueHelper());\n@@ -774,1 +696,1 @@\n-                                         (m, __) -> allTrueHelper(((Long256Mask)m).getBits()));\n+                                         (m, __) -> ((Long256Mask) m).allTrueHelper());\n@@ -791,1 +713,1 @@\n-    static final class Long256Shuffle extends AbstractShuffle<Long> {\n+    static final value class Long256Shuffle extends AbstractShuffle<Long> {\n@@ -795,2 +717,6 @@\n-        Long256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Long256Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF32B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -800,1 +726,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -804,1 +730,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -808,1 +734,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -845,6 +777,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -852,0 +787,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF512L)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF512L) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 8));\n-    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(8, (long [])(VSPECIES.iotaArray())));\n+    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.newInstanceFactory(long.class, 8));\n+    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(8, (long[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -143,2 +131,2 @@\n-    Long512Mask maskFromArray(boolean[] bits) {\n-        return new Long512Mask(bits);\n+    Long512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Long512Mask(payload);\n@@ -164,1 +152,1 @@\n-    Long512Shuffle shuffleFromBytes(byte[] reorder) { return new Long512Shuffle(reorder); }\n+    Long512Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Long512Shuffle(reorder); }\n@@ -174,7 +162,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Long512Vector vectorFactory(long[] vec) {\n-        return new Long512Vector(vec);\n-    }\n-\n@@ -540,1 +521,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -567,1 +548,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -578,1 +559,1 @@\n-    static final class Long512Mask extends AbstractMask<Long> {\n+    static final value class Long512Mask extends AbstractMask<Long> {\n@@ -582,3 +563,1 @@\n-        Long512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -586,2 +565,2 @@\n-        Long512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Long512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -590,10 +569,2 @@\n-        Long512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Long512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -602,4 +573,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Long512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -618,4 +587,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -623,18 +588,2 @@\n-        Long512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Long512Mask(res);\n-        }\n-\n-        @Override\n-        Long512Mask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Long512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Long512Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -650,27 +599,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -696,1 +618,1 @@\n-            return (Long512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Long512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -709,3 +631,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long512Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -719,3 +641,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long512Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -729,3 +651,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long512Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -740,1 +662,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Long512Mask) m).trueCountHelper());\n@@ -747,1 +669,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long512Mask) m).firstTrueHelper());\n@@ -754,1 +676,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long512Mask) m).lastTrueHelper());\n@@ -764,1 +686,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Long512Mask) m).toLongHelper());\n@@ -774,1 +696,1 @@\n-                                         (m, __) -> anyTrueHelper(((Long512Mask)m).getBits()));\n+                                         (m, __) -> ((Long512Mask) m).anyTrueHelper());\n@@ -782,1 +704,1 @@\n-                                         (m, __) -> allTrueHelper(((Long512Mask)m).getBits()));\n+                                         (m, __) -> ((Long512Mask) m).allTrueHelper());\n@@ -799,1 +721,1 @@\n-    static final class Long512Shuffle extends AbstractShuffle<Long> {\n+    static final value class Long512Shuffle extends AbstractShuffle<Long> {\n@@ -803,2 +725,6 @@\n-        Long512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Long512Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF64B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -808,1 +734,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -812,1 +738,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -816,1 +742,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -853,6 +785,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -860,0 +795,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF64L)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF64L) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 1));\n-    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(1, (long [])(VSPECIES.iotaArray())));\n+    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.newInstanceFactory(long.class, 1));\n+    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(1, (long[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -143,2 +131,2 @@\n-    Long64Mask maskFromArray(boolean[] bits) {\n-        return new Long64Mask(bits);\n+    Long64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Long64Mask(payload);\n@@ -164,1 +152,1 @@\n-    Long64Shuffle shuffleFromBytes(byte[] reorder) { return new Long64Shuffle(reorder); }\n+    Long64Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Long64Shuffle(reorder); }\n@@ -174,7 +162,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Long64Vector vectorFactory(long[] vec) {\n-        return new Long64Vector(vec);\n-    }\n-\n@@ -533,1 +514,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -553,1 +534,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -564,1 +545,1 @@\n-    static final class Long64Mask extends AbstractMask<Long> {\n+    static final value class Long64Mask extends AbstractMask<Long> {\n@@ -568,3 +549,1 @@\n-        Long64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF8Z payload;\n@@ -572,2 +551,2 @@\n-        Long64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Long64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF8Z) payload;\n@@ -576,10 +555,2 @@\n-        Long64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Long64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -588,4 +559,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Long64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -604,4 +573,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -609,18 +574,2 @@\n-        Long64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Long64Mask(res);\n-        }\n-\n-        @Override\n-        Long64Mask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Long64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Long64Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -636,27 +585,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -682,1 +604,1 @@\n-            return (Long64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Long64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -695,3 +617,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long64Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -705,3 +627,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long64Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -715,3 +637,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long64Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -726,1 +648,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Long64Mask) m).trueCountHelper());\n@@ -733,1 +655,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long64Mask) m).firstTrueHelper());\n@@ -740,1 +662,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long64Mask) m).lastTrueHelper());\n@@ -750,1 +672,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Long64Mask) m).toLongHelper());\n@@ -760,1 +682,1 @@\n-                                         (m, __) -> anyTrueHelper(((Long64Mask)m).getBits()));\n+                                         (m, __) -> ((Long64Mask) m).anyTrueHelper());\n@@ -768,1 +690,1 @@\n-                                         (m, __) -> allTrueHelper(((Long64Mask)m).getBits()));\n+                                         (m, __) -> ((Long64Mask) m).allTrueHelper());\n@@ -785,1 +707,1 @@\n-    static final class Long64Shuffle extends AbstractShuffle<Long> {\n+    static final value class Long64Shuffle extends AbstractShuffle<Long> {\n@@ -789,2 +711,6 @@\n-        Long64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF8B payload;\n+\n+        Long64Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF8B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -794,1 +720,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -798,1 +724,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -802,1 +728,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -839,6 +771,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -846,0 +781,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,5 +96,0 @@\n-    \/*package-private*\/\n-    abstract long[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -105,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -108,2 +103,0 @@\n-    abstract LongVector vectorFactory(long[] vec);\n-\n@@ -119,2 +112,2 @@\n-    AbstractMask<Long> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Long> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -144,1 +137,2 @@\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -146,1 +140,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -167,1 +161,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -169,1 +163,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -172,2 +166,2 @@\n-            long v = Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES);\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(i, v));\n+            long v = Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(i, v));\n@@ -190,2 +184,2 @@\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n@@ -193,1 +187,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -196,2 +191,3 @@\n-            long v = Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES);\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, mbits[i] ? f.apply(i, v): v);\n+            long v = Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, v);\n@@ -218,2 +214,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((LongVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((LongVector)o).vec();\n@@ -221,1 +217,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -224,3 +220,3 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n-            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(i, v1, v2));\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(i, v1, v2));\n@@ -245,3 +241,3 @@\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((LongVector)o).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((LongVector)o).vec();\n@@ -249,1 +245,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -252,3 +249,4 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n-            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            long v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, v);\n@@ -277,3 +275,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((LongVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((LongVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((LongVector)o1).vec();\n+        VectorPayloadMF vec3 = ((LongVector)o2).vec();\n@@ -281,1 +279,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -284,4 +282,4 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n-            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n-            long v3 = Unsafe.getUnsafe().getLong(vec3, start_offset + i * Long.BYTES);\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(i, v1, v2, v3));\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            long v3 = Unsafe.getUnsafe().getLong(vec3, vOffset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(i, v1, v2, v3));\n@@ -308,4 +306,4 @@\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((LongVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((LongVector)o2).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((LongVector)o1).vec();\n+        VectorPayloadMF vec3 = ((LongVector)o2).vec();\n@@ -313,1 +311,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -316,4 +315,5 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n-            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n-            long v3 = Unsafe.getUnsafe().getLong(vec3, start_offset + i * Long.BYTES);\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            long v3 = Unsafe.getUnsafe().getLong(vec3, vOffset + i * Long.BYTES);\n+            long v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, v);\n@@ -337,3 +337,4 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -342,2 +343,2 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            long v1 = Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -351,2 +352,2 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -355,1 +356,1 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES);\n+            long v1 = Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES);\n@@ -375,1 +376,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -377,1 +378,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -379,1 +380,1 @@\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -393,1 +394,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -395,2 +396,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -398,2 +400,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -419,1 +421,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -421,1 +423,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -423,1 +425,1 @@\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -437,1 +439,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -439,2 +441,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -442,2 +445,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -463,2 +466,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -467,1 +470,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES));\n@@ -477,3 +480,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -482,2 +486,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES));\n@@ -498,2 +502,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -502,1 +506,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES));\n@@ -512,3 +516,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -517,2 +522,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES));\n@@ -540,2 +545,0 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((LongVector)o).vec_mf();\n@@ -543,2 +546,6 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((LongVector)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -546,3 +553,3 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n-            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -550,1 +557,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -3992,1 +4000,2 @@\n-            boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -3994,1 +4003,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":111,"deletions":102,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF128S)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF128S) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 8));\n-    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(8, (short [])(VSPECIES.iotaArray())));\n+    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.newInstanceFactory(short.class, 8));\n+    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(8, (short[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Short128Mask maskFromArray(boolean[] bits) {\n-        return new Short128Mask(bits);\n+    Short128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Short128Mask(payload);\n@@ -169,1 +157,1 @@\n-    Short128Shuffle shuffleFromBytes(byte[] reorder) { return new Short128Shuffle(reorder); }\n+    Short128Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Short128Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Short128Vector vectorFactory(short[] vec) {\n-        return new Short128Vector(vec);\n-    }\n-\n@@ -550,1 +531,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -577,1 +558,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -588,1 +569,1 @@\n-    static final class Short128Mask extends AbstractMask<Short> {\n+    static final value class Short128Mask extends AbstractMask<Short> {\n@@ -592,3 +573,1 @@\n-        Short128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -596,2 +575,2 @@\n-        Short128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Short128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -600,10 +579,2 @@\n-        Short128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Short128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -612,4 +583,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Short128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -628,4 +597,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -633,18 +598,2 @@\n-        Short128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Short128Mask(res);\n-        }\n-\n-        @Override\n-        Short128Mask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Short128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Short128Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -660,27 +609,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -706,1 +628,1 @@\n-            return (Short128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Short128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -719,3 +641,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short128Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -729,3 +651,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short128Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -739,3 +661,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short128Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -750,1 +672,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Short128Mask) m).trueCountHelper());\n@@ -757,1 +679,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short128Mask) m).firstTrueHelper());\n@@ -764,1 +686,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short128Mask) m).lastTrueHelper());\n@@ -774,1 +696,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Short128Mask) m).toLongHelper());\n@@ -784,1 +706,1 @@\n-                                         (m, __) -> anyTrueHelper(((Short128Mask)m).getBits()));\n+                                         (m, __) -> ((Short128Mask) m).anyTrueHelper());\n@@ -792,1 +714,1 @@\n-                                         (m, __) -> allTrueHelper(((Short128Mask)m).getBits()));\n+                                         (m, __) -> ((Short128Mask) m).allTrueHelper());\n@@ -809,1 +731,1 @@\n-    static final class Short128Shuffle extends AbstractShuffle<Short> {\n+    static final value class Short128Shuffle extends AbstractShuffle<Short> {\n@@ -813,2 +735,6 @@\n-        Short128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Short128Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF64B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -818,1 +744,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -822,1 +748,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -826,1 +752,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -863,6 +795,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -870,0 +805,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF256S)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF256S) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 16));\n-    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(16, (short [])(VSPECIES.iotaArray())));\n+    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.newInstanceFactory(short.class, 16));\n+    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(16, (short[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Short256Mask maskFromArray(boolean[] bits) {\n-        return new Short256Mask(bits);\n+    Short256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Short256Mask(payload);\n@@ -169,1 +157,1 @@\n-    Short256Shuffle shuffleFromBytes(byte[] reorder) { return new Short256Shuffle(reorder); }\n+    Short256Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Short256Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Short256Vector vectorFactory(short[] vec) {\n-        return new Short256Vector(vec);\n-    }\n-\n@@ -558,1 +539,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -593,1 +574,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -604,1 +585,1 @@\n-    static final class Short256Mask extends AbstractMask<Short> {\n+    static final value class Short256Mask extends AbstractMask<Short> {\n@@ -608,3 +589,1 @@\n-        Short256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF128Z payload;\n@@ -612,2 +591,2 @@\n-        Short256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Short256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128Z) payload;\n@@ -616,10 +595,2 @@\n-        Short256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Short256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -628,4 +599,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Short256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -644,4 +613,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -649,18 +614,2 @@\n-        Short256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Short256Mask(res);\n-        }\n-\n-        @Override\n-        Short256Mask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Short256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Short256Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -676,27 +625,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -722,1 +644,1 @@\n-            return (Short256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Short256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -735,3 +657,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short256Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -745,3 +667,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short256Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -755,3 +677,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short256Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -766,1 +688,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Short256Mask) m).trueCountHelper());\n@@ -773,1 +695,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short256Mask) m).firstTrueHelper());\n@@ -780,1 +702,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short256Mask) m).lastTrueHelper());\n@@ -790,1 +712,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Short256Mask) m).toLongHelper());\n@@ -800,1 +722,1 @@\n-                                         (m, __) -> anyTrueHelper(((Short256Mask)m).getBits()));\n+                                         (m, __) -> ((Short256Mask) m).anyTrueHelper());\n@@ -808,1 +730,1 @@\n-                                         (m, __) -> allTrueHelper(((Short256Mask)m).getBits()));\n+                                         (m, __) -> ((Short256Mask) m).allTrueHelper());\n@@ -825,1 +747,1 @@\n-    static final class Short256Shuffle extends AbstractShuffle<Short> {\n+    static final value class Short256Shuffle extends AbstractShuffle<Short> {\n@@ -829,2 +751,6 @@\n-        Short256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF128B payload;\n+\n+        Short256Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF128B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -834,1 +760,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -838,1 +764,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -842,1 +768,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -879,6 +811,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -886,0 +821,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF512S)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF512S) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 32));\n-    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(32, (short [])(VSPECIES.iotaArray())));\n+    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.newInstanceFactory(short.class, 32));\n+    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(32, (short[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Short512Mask maskFromArray(boolean[] bits) {\n-        return new Short512Mask(bits);\n+    Short512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Short512Mask(payload);\n@@ -169,1 +157,1 @@\n-    Short512Shuffle shuffleFromBytes(byte[] reorder) { return new Short512Shuffle(reorder); }\n+    Short512Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Short512Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Short512Vector vectorFactory(short[] vec) {\n-        return new Short512Vector(vec);\n-    }\n-\n@@ -574,1 +555,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -625,1 +606,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -636,1 +617,1 @@\n-    static final class Short512Mask extends AbstractMask<Short> {\n+    static final value class Short512Mask extends AbstractMask<Short> {\n@@ -640,3 +621,1 @@\n-        Short512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF256Z payload;\n@@ -644,2 +623,2 @@\n-        Short512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Short512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF256Z) payload;\n@@ -648,10 +627,2 @@\n-        Short512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Short512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -660,4 +631,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Short512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -676,4 +645,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -681,18 +646,2 @@\n-        Short512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Short512Mask(res);\n-        }\n-\n-        @Override\n-        Short512Mask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Short512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Short512Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -708,27 +657,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -754,1 +676,1 @@\n-            return (Short512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Short512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -767,3 +689,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short512Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -777,3 +699,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short512Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -787,3 +709,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short512Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -798,1 +720,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Short512Mask) m).trueCountHelper());\n@@ -805,1 +727,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short512Mask) m).firstTrueHelper());\n@@ -812,1 +734,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short512Mask) m).lastTrueHelper());\n@@ -822,1 +744,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Short512Mask) m).toLongHelper());\n@@ -832,1 +754,1 @@\n-                                         (m, __) -> anyTrueHelper(((Short512Mask)m).getBits()));\n+                                         (m, __) -> ((Short512Mask) m).anyTrueHelper());\n@@ -840,1 +762,1 @@\n-                                         (m, __) -> allTrueHelper(((Short512Mask)m).getBits()));\n+                                         (m, __) -> ((Short512Mask) m).allTrueHelper());\n@@ -857,1 +779,1 @@\n-    static final class Short512Shuffle extends AbstractShuffle<Short> {\n+    static final value class Short512Shuffle extends AbstractShuffle<Short> {\n@@ -861,2 +783,6 @@\n-        Short512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF256B payload;\n+\n+        Short512Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF256B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -866,1 +792,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -870,1 +796,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -874,1 +800,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -911,6 +843,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -918,0 +853,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF64S)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF64S) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 4));\n-    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(4, (short [])(VSPECIES.iotaArray())));\n+    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.newInstanceFactory(short.class, 4));\n+    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(4, (short[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -148,2 +136,2 @@\n-    Short64Mask maskFromArray(boolean[] bits) {\n-        return new Short64Mask(bits);\n+    Short64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Short64Mask(payload);\n@@ -169,1 +157,1 @@\n-    Short64Shuffle shuffleFromBytes(byte[] reorder) { return new Short64Shuffle(reorder); }\n+    Short64Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Short64Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Short64Vector vectorFactory(short[] vec) {\n-        return new Short64Vector(vec);\n-    }\n-\n@@ -546,1 +527,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -569,1 +550,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -580,1 +561,1 @@\n-    static final class Short64Mask extends AbstractMask<Short> {\n+    static final value class Short64Mask extends AbstractMask<Short> {\n@@ -584,3 +565,1 @@\n-        Short64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -588,2 +567,2 @@\n-        Short64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Short64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -592,10 +571,2 @@\n-        Short64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Short64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -604,4 +575,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Short64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -620,4 +589,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -625,18 +590,2 @@\n-        Short64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Short64Mask(res);\n-        }\n-\n-        @Override\n-        Short64Mask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Short64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Short64Mask(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -652,27 +601,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -698,1 +620,1 @@\n-            return (Short64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Short64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -711,3 +633,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short64Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -721,3 +643,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short64Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -731,3 +653,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short64Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -742,1 +664,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Short64Mask) m).trueCountHelper());\n@@ -749,1 +671,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short64Mask) m).firstTrueHelper());\n@@ -756,1 +678,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short64Mask) m).lastTrueHelper());\n@@ -766,1 +688,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Short64Mask) m).toLongHelper());\n@@ -776,1 +698,1 @@\n-                                         (m, __) -> anyTrueHelper(((Short64Mask)m).getBits()));\n+                                         (m, __) -> ((Short64Mask) m).anyTrueHelper());\n@@ -784,1 +706,1 @@\n-                                         (m, __) -> allTrueHelper(((Short64Mask)m).getBits()));\n+                                         (m, __) -> ((Short64Mask) m).allTrueHelper());\n@@ -801,1 +723,1 @@\n-    static final class Short64Shuffle extends AbstractShuffle<Short> {\n+    static final value class Short64Shuffle extends AbstractShuffle<Short> {\n@@ -805,2 +727,6 @@\n-        Short64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Short64Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF32B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -810,1 +736,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -814,1 +740,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -818,1 +744,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -855,6 +787,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -862,0 +797,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":64,"deletions":128,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,5 +96,0 @@\n-    \/*package-private*\/\n-    abstract short[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -105,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -108,2 +103,0 @@\n-    abstract ShortVector vectorFactory(short[] vec);\n-\n@@ -119,2 +112,2 @@\n-    AbstractMask<Short> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Short> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -144,1 +137,2 @@\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -146,1 +140,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -167,1 +161,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -169,1 +163,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -172,2 +166,2 @@\n-            short v = Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES);\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(i, v));\n+            short v = Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(i, v));\n@@ -190,2 +184,2 @@\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n@@ -193,1 +187,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -196,2 +191,3 @@\n-            short v = Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES);\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, mbits[i] ? f.apply(i, v): v);\n+            short v = Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, v);\n@@ -218,2 +214,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ShortVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o).vec();\n@@ -221,1 +217,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -224,3 +220,3 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n-            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(i, v1, v2));\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(i, v1, v2));\n@@ -245,3 +241,3 @@\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ShortVector)o).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o).vec();\n@@ -249,1 +245,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -252,3 +249,4 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n-            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            short v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, v);\n@@ -277,3 +275,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ShortVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((ShortVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o1).vec();\n+        VectorPayloadMF vec3 = ((ShortVector)o2).vec();\n@@ -281,1 +279,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -284,4 +282,4 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n-            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n-            short v3 = Unsafe.getUnsafe().getShort(vec3, start_offset + i * Short.BYTES);\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(i, v1, v2, v3));\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            short v3 = Unsafe.getUnsafe().getShort(vec3, vOffset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(i, v1, v2, v3));\n@@ -308,4 +306,4 @@\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ShortVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((ShortVector)o2).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o1).vec();\n+        VectorPayloadMF vec3 = ((ShortVector)o2).vec();\n@@ -313,1 +311,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -316,4 +315,5 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n-            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n-            short v3 = Unsafe.getUnsafe().getShort(vec3, start_offset + i * Short.BYTES);\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            short v3 = Unsafe.getUnsafe().getShort(vec3, vOffset + i * Short.BYTES);\n+            short v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, v);\n@@ -337,3 +337,4 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -342,2 +343,2 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            short v1 = Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -351,2 +352,2 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -355,1 +356,1 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES);\n+            short v1 = Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES);\n@@ -375,1 +376,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -377,1 +378,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -379,1 +380,1 @@\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -393,1 +394,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -395,2 +396,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -398,2 +400,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -419,1 +421,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -421,1 +423,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -423,1 +425,1 @@\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -437,1 +439,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -439,2 +441,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -442,2 +445,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -463,2 +466,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -467,1 +470,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES));\n@@ -477,3 +480,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -482,2 +486,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES));\n@@ -498,2 +502,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -502,1 +506,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES));\n@@ -512,3 +516,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -517,2 +522,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES));\n@@ -540,2 +545,0 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ShortVector)o).vec_mf();\n@@ -543,2 +546,6 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -546,3 +553,3 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n-            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -550,1 +557,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -4338,1 +4346,2 @@\n-            boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -4340,1 +4349,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":111,"deletions":102,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,1 +134,5 @@\n-    VectorMask(boolean[] bits) { super(bits); }\n+\n+    \/**\n+     * Default Constructor for abstract VectorMask.\n+     *\/\n+    public VectorMask() {}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,3 +136,4 @@\n-    VectorShuffle(byte[] reorder) {\n-        super(reorder);\n-    }\n+    \/**\n+     * Default Constructor for abstract VectorShuffle.\n+     *\/\n+    public VectorShuffle() {}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShuffle.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,5 +100,0 @@\n-    \/*package-private*\/\n-    abstract $type$[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -109,1 +104,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -112,2 +107,0 @@\n-    abstract $abstractvectortype$ vectorFactory($type$[] vec);\n-\n@@ -123,2 +116,2 @@\n-    AbstractMask<$Boxtype$> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<$Boxtype$> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -148,1 +141,2 @@\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -150,1 +144,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -171,1 +165,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -173,1 +167,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -176,2 +170,2 @@\n-            $type$ v = Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES);\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(i, v));\n+            $type$ v = Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(i, v));\n@@ -194,2 +188,2 @@\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF vec = this.vec();\n@@ -197,1 +191,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -200,2 +195,3 @@\n-            $type$ v = Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES);\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, mbits[i] ? f.apply(i, v): v);\n+            $type$ v = Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, v);\n@@ -222,2 +218,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec();\n@@ -225,1 +221,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -228,3 +224,3 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(i, v1, v2));\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(i, v1, v2));\n@@ -249,3 +245,3 @@\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec();\n@@ -253,1 +249,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -256,3 +253,4 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, v);\n@@ -281,3 +279,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = (($abstractvectortype$)o1).vec_mf();\n-        VectorPayloadMF vec3 = (($abstractvectortype$)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o1).vec();\n+        VectorPayloadMF vec3 = (($abstractvectortype$)o2).vec();\n@@ -285,1 +283,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -288,4 +286,4 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v3 = Unsafe.getUnsafe().get$Type$(vec3, start_offset + i * $Boxtype$.BYTES);\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(i, v1, v2, v3));\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v3 = Unsafe.getUnsafe().get$Type$(vec3, vOffset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(i, v1, v2, v3));\n@@ -312,4 +310,4 @@\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = (($abstractvectortype$)o1).vec_mf();\n-        VectorPayloadMF vec3 = (($abstractvectortype$)o2).vec_mf();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o1).vec();\n+        VectorPayloadMF vec3 = (($abstractvectortype$)o2).vec();\n@@ -317,1 +315,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -320,4 +319,5 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v3 = Unsafe.getUnsafe().get$Type$(vec3, start_offset + i * $Boxtype$.BYTES);\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v3 = Unsafe.getUnsafe().get$Type$(vec3, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, v);\n@@ -341,3 +341,4 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = this.vec();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -346,2 +347,2 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -355,2 +356,2 @@\n-        VectorPayloadMF vec = this.vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -359,1 +360,1 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES);\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES);\n@@ -379,1 +380,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -381,1 +382,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -383,1 +384,1 @@\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -397,1 +398,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -399,2 +400,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -402,2 +404,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -423,1 +425,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -425,1 +427,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -427,1 +429,1 @@\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -441,1 +443,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -443,2 +445,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -446,2 +449,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -467,2 +470,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -471,1 +474,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES));\n@@ -481,3 +484,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -486,2 +490,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES));\n@@ -502,2 +506,2 @@\n-        VectorPayloadMF vec = vec_mf();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        long vOffset = this.multiFieldOffset();\n@@ -506,1 +510,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES));\n@@ -516,3 +520,4 @@\n-        VectorPayloadMF vec = vec_mf();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF vec = vec();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -521,2 +526,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES));\n@@ -544,2 +549,0 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec_mf();\n@@ -547,2 +550,6 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec();\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -550,3 +557,3 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -554,1 +561,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -5630,1 +5638,2 @@\n-            boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -5632,1 +5641,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":111,"deletions":102,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF$bits$$Boxinitials$)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF$bits$$Boxinitials$) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -75,2 +72,2 @@\n-    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.createVectPayloadInstance($type$.class, $numLanes$));\n-    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($numLanes$, ($type$ [])(VSPECIES.iotaArray())));\n+    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.newInstanceFactory($type$.class, $numLanes$));\n+    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($numLanes$, ($type$[])(VSPECIES.iotaArray())));\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    $type$[] vec() {\n-        return ($type$[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -150,2 +138,2 @@\n-    $masktype$ maskFromArray(boolean[] bits) {\n-        return new $masktype$(bits);\n+    $masktype$ maskFromPayload(VectorPayloadMF payload) {\n+        return new $masktype$(payload);\n@@ -171,1 +159,1 @@\n-    $shuffletype$ shuffleFromBytes(byte[] reorder) { return new $shuffletype$(reorder); }\n+    $shuffletype$ shuffleFromBytes(VectorPayloadMF reorder) { return new $shuffletype$(reorder); }\n@@ -181,7 +169,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    $vectortype$ vectorFactory($type$[] vec) {\n-        return new $vectortype$(vec);\n-    }\n-\n@@ -582,1 +563,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -632,1 +613,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -737,1 +718,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -839,1 +820,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -851,1 +832,1 @@\n-    static final class $masktype$ extends AbstractMask<$Boxtype$> {\n+    static final value class $masktype$ extends AbstractMask<$Boxtype$> {\n@@ -855,3 +836,1 @@\n-        $masktype$(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF$vectorsizeinbytes$Z payload;\n@@ -859,2 +838,2 @@\n-        $masktype$(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        $masktype$(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$Z) payload;\n@@ -863,10 +842,2 @@\n-        $masktype$(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        $masktype$(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -875,4 +846,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        $masktype$(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -891,4 +860,0 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n@@ -896,18 +861,2 @@\n-        $masktype$ uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new $masktype$(res);\n-        }\n-\n-        @Override\n-        $masktype$ bOp(VectorMask<$Boxtype$> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = (($masktype$)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new $masktype$(res);\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -923,27 +872,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -969,1 +891,1 @@\n-            return ($masktype$)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return ($masktype$) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -982,3 +904,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null,\n+                                          $bitstype$.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> ($masktype$) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -992,3 +914,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null,\n+                                          $bitstype$.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> ($masktype$) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -1002,3 +924,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null,\n+                                          $bitstype$.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> ($masktype$) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -1013,1 +935,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> (($masktype$) m).trueCountHelper());\n@@ -1020,1 +942,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> (($masktype$) m).firstTrueHelper());\n@@ -1027,1 +949,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> (($masktype$) m).lastTrueHelper());\n@@ -1037,1 +959,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> (($masktype$) m).toLongHelper());\n@@ -1047,1 +969,1 @@\n-                                         (m, __) -> anyTrueHelper((($masktype$)m).getBits()));\n+                                         (m, __) -> (($masktype$) m).anyTrueHelper());\n@@ -1055,1 +977,1 @@\n-                                         (m, __) -> allTrueHelper((($masktype$)m).getBits()));\n+                                         (m, __) -> (($masktype$) m).allTrueHelper());\n@@ -1070,3 +992,5 @@\n-        static boolean[] maskLowerHalf() {\n-            boolean[] a = new boolean[VLENGTH];\n-            int len = a.length >> 1;\n+        static VectorPayloadMF maskLowerHalf() {\n+            VectorPayloadMF newObj = VectorPayloadMF.newInstanceFactory(boolean.class, VLENGTH);\n+            newObj = Unsafe.getUnsafe().makePrivateBuffer(newObj);\n+            long mf_offset = newObj.multiFieldOffset();\n+            int len = VLENGTH >> 1;\n@@ -1074,1 +998,1 @@\n-                a[i] = true;\n+                Unsafe.getUnsafe().putBoolean(newObj, mf_offset + i, true);\n@@ -1076,1 +1000,2 @@\n-            return a;\n+            newObj = Unsafe.getUnsafe().finishPrivateBuffer(newObj);\n+            return newObj;\n@@ -1087,1 +1012,1 @@\n-    static final class $shuffletype$ extends AbstractShuffle<$Boxtype$> {\n+    static final value class $shuffletype$ extends AbstractShuffle<$Boxtype$> {\n@@ -1091,2 +1016,6 @@\n-        $shuffletype$(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF$vectorsizeinbytes$B payload;\n+\n+        $shuffletype$(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -1096,1 +1025,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -1100,1 +1029,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -1104,1 +1033,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -1141,6 +1076,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -1148,0 +1086,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":74,"deletions":135,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,1 @@\n+    vectorsizeinbytes=$((bits \/ sizeInBytes))\n@@ -195,1 +196,1 @@\n-    bitargs=\"$args -Dbits=$bits -DBITS=$BITS -Dvectortype=$vectortype -DnumLanes=$numLanes  -Dmasktype=$masktype -Dshuffletype=$shuffletype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dvectorindextype=$vectorindextype -Dshape=$shape -DShape=$Shape\"\n+    bitargs=\"$args -Dbits=$bits -DBITS=$BITS -Dvectortype=$vectortype -DnumLanes=$numLanes  -Dmasktype=$masktype -Dshuffletype=$shuffletype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dvectorindextype=$vectorindextype -Dshape=$shape -DShape=$Shape -Dvectorsizeinbytes=$vectorsizeinbytes\"\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/gen-src.sh","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}