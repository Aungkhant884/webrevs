{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4895,4 +4895,1 @@\n-    if (strstr(inner_class, \"VectorPayloadMF64\")  ||\n-        strstr(inner_class, \"VectorPayloadMF128\") ||\n-        strstr(inner_class, \"VectorPayloadMF256\") ||\n-        strstr(inner_class, \"VectorPayloadMF512\")) {\n+    if (strstr(inner_class, \"VectorPayloadMF\")) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,0 +196,7 @@\n+  do_klass(vector_VectorPayloadMF8Z_klass,              jdk_internal_vm_vector_VectorPayloadMF8Z              ) \\\n+  do_klass(vector_VectorPayloadMF16Z_klass,             jdk_internal_vm_vector_VectorPayloadMF16Z             ) \\\n+  do_klass(vector_VectorPayloadMF32Z_klass,             jdk_internal_vm_vector_VectorPayloadMF32Z             ) \\\n+  do_klass(vector_VectorPayloadMF64Z_klass,             jdk_internal_vm_vector_VectorPayloadMF64Z             ) \\\n+  do_klass(vector_VectorPayloadMF128Z_klass,            jdk_internal_vm_vector_VectorPayloadMF128Z            ) \\\n+  do_klass(vector_VectorPayloadMF256Z_klass,            jdk_internal_vm_vector_VectorPayloadMF256Z            ) \\\n+  do_klass(vector_VectorPayloadMF512Z_klass,            jdk_internal_vm_vector_VectorPayloadMF512Z            ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,6 +91,13 @@\n-  template(jdk_internal_vm_vector_VectorSupport,      \"jdk\/internal\/vm\/vector\/VectorSupport\")               \\\n-  template(jdk_internal_vm_vector_VectorPayload,      \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload\") \\\n-  template(jdk_internal_vm_vector_Vector,             \"jdk\/internal\/vm\/vector\/VectorSupport$Vector\")        \\\n-  template(jdk_internal_vm_vector_VectorMask,         \"jdk\/internal\/vm\/vector\/VectorSupport$VectorMask\")    \\\n-  template(jdk_internal_vm_vector_VectorShuffle,      \"jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle\") \\\n-  template(jdk_internal_vm_vector_VectorPayloadMF,    \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF\")    \\\n+  template(jdk_internal_vm_vector_VectorSupport,       \"jdk\/internal\/vm\/vector\/VectorSupport\")                     \\\n+  template(jdk_internal_vm_vector_VectorPayload,       \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload\")       \\\n+  template(jdk_internal_vm_vector_Vector,              \"jdk\/internal\/vm\/vector\/VectorSupport$Vector\")              \\\n+  template(jdk_internal_vm_vector_VectorMask,          \"jdk\/internal\/vm\/vector\/VectorSupport$VectorMask\")          \\\n+  template(jdk_internal_vm_vector_VectorShuffle,       \"jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle\")       \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF,     \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF\")     \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF8Z,   \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8Z\")   \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF16Z,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16Z\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF32Z,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32Z\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF64Z,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64Z\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF128Z, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128Z\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF256Z, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256Z\") \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF512Z, \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512Z\") \\\n@@ -121,4 +128,4 @@\n-  template(payload_name,                               \"payload\")                                 \\\n-  template(mfield_name,                                \"mfield\")                                  \\\n-  template(ETYPE_name,                                 \"ETYPE\")                                   \\\n-  template(VLENGTH_name,                               \"VLENGTH\")                                 \\\n+  template(payload_name,                               \"payload\")                                                  \\\n+  template(mfield_name,                                \"mfield\")                                                   \\\n+  template(ETYPE_name,                                 \"ETYPE\")                                                    \\\n+  template(VLENGTH_name,                               \"VLENGTH\")                                                  \\\n@@ -296,0 +303,7 @@\n+  template(vector_VectorPayloadMF8Z_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8Z;\")   \\\n+  template(vector_VectorPayloadMF16Z_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16Z;\")  \\\n+  template(vector_VectorPayloadMF32Z_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32Z;\")  \\\n+  template(vector_VectorPayloadMF64Z_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF64Z;\")  \\\n+  template(vector_VectorPayloadMF128Z_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF128Z;\") \\\n+  template(vector_VectorPayloadMF256Z_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF256Z;\") \\\n+  template(vector_VectorPayloadMF512Z_signature,      \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF512Z;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":25,"deletions":11,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,7 +90,9 @@\n-  InlineTypeNode* vt = in(1)->isa_InlineType();\n-  if (vt != NULL && phase->type(vt)->filter_speculative(_type) != Type::TOP) {\n-    Node* cast = clone();\n-    cast->set_req(1, vt->get_oop());\n-    vt = vt->clone()->as_InlineType();\n-    vt->set_oop(phase->transform(cast));\n-    return vt;\n+  if (in(1)->is_InlineType() && !in(1)->is_VectorBox()) {\n+    InlineTypeNode* vt = in(1)->as_InlineType();\n+    if (phase->type(vt)->filter_speculative(_type) != Type::TOP) {\n+      Node* cast = clone();\n+      cast->set_req(1, vt->get_oop());\n+      vt = vt->clone()->as_InlineType();\n+      vt->set_oop(phase->transform(cast));\n+      return vt;\n+    }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,4 +40,0 @@\n-static bool is_vector_payload_mf(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayloadMF_klass());\n-}\n-\n@@ -252,1 +248,1 @@\n-  if (is_vector(iklass)) {\n+  if (is_vector(iklass) || is_vector_mask(iklass)) {\n@@ -323,1 +319,1 @@\n-    Node* result = expand_vbox_node_helper(vbox, vect, vec_box->box_type(), vec_box->vec_type());\n+    Node* result = expand_vbox_node_helper(vec_box, vbox, vect, vec_box->box_type(), vec_box->vec_type());\n@@ -330,1 +326,2 @@\n-Node* PhaseVector::expand_vbox_node_helper(Node* vbox,\n+Node* PhaseVector::expand_vbox_node_helper(VectorBoxNode* vec_box,\n+                                           Node* vbox,\n@@ -338,1 +335,1 @@\n-      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect->in(i), box_type, vect_type);\n+      Node* new_box = expand_vbox_node_helper(vec_box, vbox->in(i), vect->in(i), box_type, vect_type);\n@@ -353,1 +350,1 @@\n-      Node* new_box = expand_vbox_node_helper(vbox->in(i), vect, box_type, vect_type);\n+      Node* new_box = expand_vbox_node_helper(vec_box, vbox->in(i), vect, box_type, vect_type);\n@@ -360,1 +357,1 @@\n-    return expand_vbox_alloc_node(vbox_alloc, vect, box_type, vect_type);\n+    return expand_vbox_alloc_node(vec_box, vbox_alloc, vect, box_type, vect_type);\n@@ -368,2 +365,2 @@\n-Node* PhaseVector::expand_vbox_alloc_node_vector(VectorBoxAllocateNode* vbox_alloc,\n-                                                 Node* value,\n+Node* PhaseVector::expand_vbox_alloc_node_vector(VectorBoxNode* vec_box,\n+                                                 VectorBoxAllocateNode* vbox_alloc,\n@@ -374,7 +371,0 @@\n-  PhaseGVN& gvn = kit.gvn();\n-\n-  ciInlineKlass* box_klass = static_cast<ciInlineKlass*>(box_type->inline_klass());\n-\n-  BasicType bt = vect_type->element_basic_type();\n-  int num_elem = vect_type->length();\n-  int elem_size = type2aelembytes(bt);\n@@ -382,0 +372,1 @@\n+  ciInlineKlass* vk = static_cast<ciInlineKlass*>(box_type->inline_klass());\n@@ -385,22 +376,1 @@\n-\n-  assert(is_vector(box_klass), \"\");\n-  ciField* payload_field = box_klass->declared_nonstatic_field_at(0);\n-  int offset = payload_field->offset();\n-  if (!payload_field->is_flattened()) {\n-    ciInlineKlass* payload_klass = static_cast<ciInlineKlass*>(payload_field->type());\n-    assert(is_vector_payload_mf(payload_klass), \"\");\n-    ciField* mutifield = payload_klass->declared_nonstatic_field_at(0);\n-    offset += mutifield->offset();\n-  }\n-\n-  Node* buffer_start_adr = kit.basic_plus_adr(buffer_mem, offset);\n-  const TypePtr* buffer_adr_type = buffer_start_adr->bottom_type()->is_ptr();\n-  Node* buffer_mem_start = kit.memory(buffer_start_adr);\n-  Node* vstore = gvn.transform(StoreVectorNode::make(0,\n-                                                     kit.control(),\n-                                                     buffer_mem_start,\n-                                                     buffer_start_adr,\n-                                                     buffer_adr_type,\n-                                                     value,\n-                                                     num_elem));\n-  kit.set_memory(vstore, buffer_adr_type);\n+  vec_box->store(&kit, buffer_mem, buffer_mem, vk);\n@@ -412,1 +382,0 @@\n-\n@@ -419,1 +388,1 @@\n-Node* PhaseVector::expand_vbox_alloc_node_mask_shuffle(VectorBoxAllocateNode* vbox_alloc,\n+Node* PhaseVector::expand_vbox_alloc_node_shuffle(VectorBoxAllocateNode* vbox_alloc,\n@@ -492,1 +461,1 @@\n-Node* PhaseVector::expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,\n+Node* PhaseVector::expand_vbox_alloc_node(VectorBoxNode* vec_box, VectorBoxAllocateNode* vbox_alloc,\n@@ -497,2 +466,2 @@\n-  if (is_vector(box_klass)) {\n-    return expand_vbox_alloc_node_vector(vbox_alloc, value, box_type, vect_type);\n+  if (is_vector(box_klass) || is_vector_mask(box_klass)) {\n+    return expand_vbox_alloc_node_vector(vec_box, vbox_alloc, box_type, vect_type);\n@@ -500,1 +469,1 @@\n-    return expand_vbox_alloc_node_mask_shuffle(vbox_alloc, value, box_type, vect_type);\n+    return expand_vbox_alloc_node_shuffle(vbox_alloc, value, box_type, vect_type);\n@@ -504,11 +473,0 @@\n-Node* PhaseVector::get_loaded_payload(VectorUnboxNode* vec_unbox) {\n-   Node* obj = vec_unbox->obj();\n-   while(obj->is_InlineType()) {\n-      obj = obj->as_InlineType()->field_value(0);\n-   }\n-   if (obj->bottom_type()->isa_vect()) {\n-     return obj;\n-   }\n-   return NULL;\n-}\n-\n@@ -520,2 +478,5 @@\n-    Node* vec_val_load = get_loaded_payload(vec_unbox);\n-    assert (vec_val_load != NULL, \"\");\n+    Node* node = vec_unbox->obj();\n+    while(node->is_InlineType()) {\n+      node = node->as_InlineType()->field_value(0);\n+    }\n+    assert(Type::cmp(vec_unbox->bottom_type(), node->bottom_type()) == 0, \"type is not matched\");\n@@ -523,1 +484,1 @@\n-    C->set_max_vector_size(MAX2(C->max_vector_size(), vec_val_load->bottom_type()->is_vect()->length_in_bytes()));\n+    C->set_max_vector_size(MAX2(C->max_vector_size(), vec_unbox->bottom_type()->is_vect()->length_in_bytes()));\n@@ -526,1 +487,1 @@\n-    C->gvn_replace_by(vec_unbox, vec_val_load);\n+    C->gvn_replace_by(vec_unbox, node);\n@@ -534,1 +495,1 @@\n-void PhaseVector::expand_vunbox_node_mask_shuffle(VectorUnboxNode* vec_unbox) {\n+void PhaseVector::expand_vunbox_node_shuffle(VectorUnboxNode* vec_unbox) {\n@@ -614,1 +575,1 @@\n-    if (is_vector(from_kls)) {\n+    if (is_vector(from_kls) || is_vector_mask(from_kls)) {\n@@ -617,1 +578,1 @@\n-      return expand_vunbox_node_mask_shuffle(vec_unbox);\n+      return expand_vunbox_node_shuffle(vec_unbox);\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":27,"deletions":66,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,2 @@\n-  Node* expand_vbox_node_helper(Node* vbox_alloc,\n+  Node* expand_vbox_node_helper(VectorBoxNode* vec_box,\n+                                Node* vbox_alloc,\n@@ -45,1 +46,2 @@\n-  Node* expand_vbox_alloc_node(VectorBoxAllocateNode* vbox_alloc,\n+  Node* expand_vbox_alloc_node(VectorBoxNode* vec_box,\n+                               VectorBoxAllocateNode* vbox_alloc,\n@@ -50,2 +52,2 @@\n-  Node* expand_vbox_alloc_node_vector(VectorBoxAllocateNode* vbox_alloc,\n-                                      Node* value,\n+  Node* expand_vbox_alloc_node_vector(VectorBoxNode* vec_box,\n+                                      VectorBoxAllocateNode* vbox_alloc,\n@@ -55,1 +57,1 @@\n-  Node* expand_vbox_alloc_node_mask_shuffle(VectorBoxAllocateNode* vbox_alloc,\n+  Node* expand_vbox_alloc_node_shuffle(VectorBoxAllocateNode* vbox_alloc,\n@@ -60,2 +62,0 @@\n-  Node* get_loaded_payload(VectorUnboxNode* vec_unbox);\n-\n@@ -67,1 +67,1 @@\n-  void expand_vunbox_node_mask_shuffle(VectorUnboxNode* vec_unbox);\n+  void expand_vunbox_node_shuffle(VectorUnboxNode* vec_unbox);\n","filename":"src\/hotspot\/share\/opto\/vector.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-  assert(is_vector(ik), \"not a vector\");\n+  assert(is_vector(ik) || is_vector_mask(ik), \"not a vector or a vector mask\");\n@@ -159,1 +159,10 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_type->instance_klass()));\n+\n+  \/\/ VectorMask format conversion\n+  if (is_vector_mask(vbox_type->instance_klass()) &&\n+      (vector->bottom_type()->isa_vectmask() || elem_bt != T_BOOLEAN)) {\n+    vector = gvn().transform(VectorStoreMaskNode::make(gvn(), vector, elem_bt, num_elem));\n+    elem_bt = T_BOOLEAN;\n+    assert(vector->bottom_type()->is_vect()->element_basic_type() == elem_bt,\n+           \"must be consistent with mask representation\");\n+  }\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n@@ -173,2 +182,2 @@\n-  \/\/ TODO[valhalla] Limiting support to only vectors cases untill mask and shuffle becomes inline types.\n-  if (!is_vector(vbox_type->instance_klass())) {\n+  \/\/ TODO[valhalla] Limiting support to only vector and vector mask cases untill shuffle becomes inline types.\n+  if (!is_vector(vbox_type->instance_klass()) && !is_vector_mask(vbox_type->instance_klass())) {\n@@ -178,1 +187,6 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_type->instance_klass()));\n+\n+  BasicType unbox_bt = elem_bt;\n+  if (is_vector_mask(vbox_type->instance_klass())) {\n+    unbox_bt = T_BOOLEAN;\n+  }\n+  const TypeVect* vt = TypeVect::make(unbox_bt, num_elem);\n@@ -180,0 +194,3 @@\n+  if (is_vector_mask(vbox_type->instance_klass())) {\n+    unbox = gvn().transform(new VectorLoadMaskNode(unbox, TypeVect::makemask(elem_bt, num_elem)));\n+  }\n@@ -865,2 +882,2 @@\n-  \/\/ TODO[valhalla] Preventing intrinsification for mask\/shuffle till they become inline types.\n-  if (is_mask || is_shuffle) {\n+  \/\/ TODO[valhalla] Preventing intrinsification for shuffle till they become inline types.\n+  if (is_shuffle) {\n@@ -1011,2 +1028,2 @@\n-  \/\/ TODO[valhalla] Preventing intrinsification for mask\/shuffle till they become inline types.\n-  if (is_mask || is_shuffle) {\n+  \/\/ TODO[valhalla] Preventing intrinsification for shuffle till they become inline types.\n+  if (is_shuffle) {\n@@ -1980,2 +1997,1 @@\n-  \/\/ TODO[valhalla] Preveting intrinsification untill mask becomes inline type.\n-  if (true || is_masked_op && mask == NULL) {\n+  if (is_masked_op && mask == NULL) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -858,4 +858,0 @@\n-  case Op_ReplicateF:\n-    return n->in(1)->bottom_type() == TypeF::ONE;\n-  case Op_ReplicateD:\n-    return n->in(1)->bottom_type() == TypeD::ONE;\n@@ -1304,0 +1300,17 @@\n+Node* VectorLoadMaskNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(1)->Opcode() == Op_VectorStoreMask) {\n+    if (Type::cmp(bottom_type(), in(1)->in(1)->bottom_type()) == 0) {\n+      \/\/ \/\/ Handled by VectorLoadMaskNode::Identity()\n+    } else {\n+      const TypeVect* out_vt = vect_type();\n+      const TypeVect* in_vt = in(1)->in(1)->bottom_type()->is_vect();\n+      if (out_vt->length() == in_vt->length() &&\n+          out_vt->length_in_bytes() == in_vt->length_in_bytes()) {\n+        const TypeVect* vmask_type = TypeVect::makemask(out_vt->element_basic_type(), out_vt->length());\n+        return new VectorMaskCastNode(in(1)->in(1), vmask_type);\n+      }\n+    }\n+  }\n+  return VectorNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -1305,1 +1318,1 @@\n-  BasicType out_bt = type()->is_vect()->element_basic_type();\n+  BasicType out_bt = vect_type()->element_basic_type();\n@@ -1310,0 +1323,5 @@\n+  \/\/ VectorLoadMask (VectorStoreMask mask) ==> mask\n+  if (in(1)->Opcode() == Op_VectorStoreMask &&\n+      Type::cmp(bottom_type(), in(1)->in(1)->bottom_type()) == 0) {\n+    return in(1)->in(1);\n+  }\n@@ -1659,2 +1677,0 @@\n-\n-        bool is_vector_mask    = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n@@ -1662,5 +1678,1 @@\n-        if (is_vector_mask) {\n-          \/\/ VectorUnbox (VectorBox vmask) ==> VectorMaskCast vmask\n-          const TypeVect* vmask_type = TypeVect::makemask(out_vt->element_basic_type(), out_vt->length());\n-          return new VectorMaskCastNode(value, vmask_type);\n-        } else if (is_vector_shuffle) {\n+        if (is_vector_shuffle) {\n@@ -1672,1 +1684,1 @@\n-          \/\/ Vector type mismatch is only supported for masks and shuffles, but sometimes it happens in pathological cases.\n+          \/\/ Vector type mismatch is only supported for shuffles, but sometimes it happens in pathological cases.\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1492,0 +1492,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -1691,2 +1692,0 @@\n-\n-    Node* payload_oop = payload->is_initialized() ? default_oop(gvn, payload) : gvn.zerocon(T_PRIMITIVE_OBJECT);\n@@ -1700,1 +1699,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,3 @@\n-  return VectorSupport::is_vector(klass) || VectorSupport::is_vector_payload_mf(klass);\n+  return VectorSupport::is_vector(klass) ||\n+         VectorSupport::is_vector_mask(klass) ||\n+         VectorSupport::is_vector_payload_mf(klass);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -31,1 +32,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -34,1 +34,0 @@\n-\n@@ -164,0 +163,2 @@\n+    public static abstract class VectorMask<E> extends VectorPayload { }\n+\n@@ -175,11 +176,0 @@\n-    public static class VectorMask<E> extends VectorPayload {\n-        private final Object payload; \/\/ array of primitives\n-\n-        protected final Object getPayload() {\n-            return VectorSupport.maybeRebox(this).payload;\n-        }\n-        public VectorMask(Object payload) {\n-            this.payload = payload;\n-        }\n-    }\n-\n@@ -190,2 +180,13 @@\n-        private static VectorPayloadMF newInstanceFactory(Class<?> elemType, int length) {\n-            if (elemType == byte.class) {\n+        public static VectorPayloadMF newInstanceFactory(Class<?> elemType, int length) {\n+            if (elemType == boolean.class) {\n+                switch(length) {\n+                    case  1: return new VectorPayloadMF8Z();\n+                    case  2: return new VectorPayloadMF16Z();\n+                    case  4: return new VectorPayloadMF32Z();\n+                    case  8: return new VectorPayloadMF64Z();\n+                    case 16: return new VectorPayloadMF128Z();\n+                    case 32: return new VectorPayloadMF256Z();\n+                    case 64: return new VectorPayloadMF512Z();\n+                    default: assert false : \"Unhandled vector mask size\";\n+                }\n+            } else if (elemType == byte.class) {\n@@ -244,5 +245,0 @@\n-        @ForceInline\n-        public static VectorPayloadMF createVectPayloadInstance(Class<?> elemType, int length) {\n-            return newInstanceFactory(elemType, length);\n-        }\n-\n@@ -321,1 +317,1 @@\n-        public int length(int elemSize) {\n+        public int length() {\n@@ -329,1 +325,1 @@\n-                return msanno[0].value() \/ elemSize;\n+                return msanno[0].value();\n@@ -347,0 +343,63 @@\n+    public primitive static class VectorPayloadMF8Z extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF8Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF16Z extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF16Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF32Z extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF32Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF64Z extends VectorPayloadMF {\n+        @MultiField(value = 8)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF64Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF128Z extends VectorPayloadMF {\n+        @MultiField(value = 16)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF128Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF256Z extends VectorPayloadMF {\n+        @MultiField(value = 32)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF256Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF512Z extends VectorPayloadMF {\n+        @MultiField(value = 64)\n+        boolean mfield = false;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF512Z.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n@@ -353,1 +412,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -362,1 +421,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -371,1 +430,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -380,1 +439,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -389,1 +448,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -398,1 +457,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -407,1 +466,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -416,1 +475,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -425,1 +484,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -434,1 +493,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -443,1 +502,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -452,1 +511,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -461,1 +520,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -470,1 +529,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -479,1 +538,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -488,1 +547,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -497,1 +556,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -506,1 +565,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -515,1 +574,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -524,1 +583,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -533,1 +592,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -542,1 +601,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -551,1 +610,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -560,1 +619,1 @@\n-        public long multiFieldOffset() { return MFOFFSET;}\n+        public long multiFieldOffset() { return MFOFFSET; }\n@@ -562,0 +621,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":107,"deletions":47,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n@@ -38,3 +40,0 @@\n-    AbstractMask(boolean[] bits) {\n-        super(bits);\n-    }\n@@ -43,1 +42,24 @@\n-    abstract boolean[] getBits();\n+    abstract VectorPayloadMF getBits();\n+\n+    static VectorPayloadMF prepare(VectorPayloadMF payload, int offset, int length) {\n+        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        long mOffset = res.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            boolean b = Unsafe.getUnsafe().getBoolean(payload, mOffset + i + offset);\n+            Unsafe.getUnsafe().putBoolean(res, mOffset + i, b);\n+        }\n+        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        return res;\n+    }\n+\n+    static VectorPayloadMF prepare(boolean val, int length) {\n+        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        long mOffset = res.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            Unsafe.getUnsafe().putBoolean(res, mOffset + i, val);\n+        }\n+        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        return res;\n+    }\n@@ -51,1 +73,13 @@\n-    abstract AbstractMask<E> uOp(MUnOp f);\n+    AbstractMask<E> uOp(MUnOp f) {\n+        int length = vspecies().laneCount();\n+        VectorPayloadMF bits = getBits();\n+        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        long mOffset = res.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            boolean b = Unsafe.getUnsafe().getBoolean(bits, mOffset + i);\n+            Unsafe.getUnsafe().putBoolean(res, mOffset + i, f.apply(i, b));\n+        }\n+        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        return vspecies().maskFactory(res);\n+    }\n@@ -59,1 +93,25 @@\n-    abstract AbstractMask<E> bOp(VectorMask<E> o, MBinOp f);\n+    AbstractMask<E> bOp(AbstractMask<E> m, MBinOp f) {\n+        int length = vspecies().laneCount();\n+        VectorPayloadMF bits = getBits();\n+        VectorPayloadMF mbits = m.getBits();\n+        VectorPayloadMF res = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        long mOffset = res.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            boolean b = Unsafe.getUnsafe().getBoolean(bits, mOffset + i);\n+            boolean mb = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i);\n+            Unsafe.getUnsafe().putBoolean(res, mOffset + i, f.apply(i, b, mb));\n+        }\n+        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        return vspecies().maskFactory(res);\n+    }\n+\n+    \/\/ Store operator\n+\n+    void stOp(boolean[] arr, int idx) {\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < vspecies().laneCount(); i++) {\n+            arr[idx++] = Unsafe.getUnsafe().getBoolean(bits, mOffset + i);\n+        }\n+    }\n@@ -70,0 +128,14 @@\n+    @Override\n+    @ForceInline\n+    public <F> VectorMask<F> cast(VectorSpecies<F> dsp) {\n+        AbstractSpecies<F> species = (AbstractSpecies<F>) dsp;\n+        if (length() != species.laneCount())\n+            throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), vspecies().elementType(), vspecies().laneCount,\n+                species.maskType(), species.elementType(), vspecies().laneCount,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.getBits()).check(s));\n+    }\n+\n@@ -78,1 +150,2 @@\n-            return getBits()[i];\n+            VectorPayloadMF bits = getBits();\n+            return Unsafe.getUnsafe().getBoolean(bits, bits.multiFieldOffset() + i);\n@@ -91,2 +164,1 @@\n-            (c, idx, s) -> System.arraycopy(s.getBits(), 0, c, (int) idx, s.length()));\n-\n+            (c, idx, s) -> s.stOp(c, (int) idx));\n@@ -97,1 +169,3 @@\n-        return getBits().clone();\n+        boolean[] arr = new boolean[length()];\n+        intoArray(arr, 0);\n+        return arr;\n@@ -145,1 +219,1 @@\n-    static boolean anyTrueHelper(boolean[] bits) {\n+    boolean anyTrueHelper() {\n@@ -147,2 +221,4 @@\n-        for (boolean i : bits) {\n-            if (i) return true;\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return true;\n@@ -154,1 +230,1 @@\n-    static boolean allTrueHelper(boolean[] bits) {\n+    boolean allTrueHelper() {\n@@ -156,2 +232,4 @@\n-        for (boolean i : bits) {\n-            if (!i) return false;\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            if (!Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return false;\n@@ -163,1 +241,1 @@\n-    static int trueCountHelper(boolean[] bits) {\n+    int trueCountHelper() {\n@@ -165,2 +243,4 @@\n-        for (boolean i : bits) {\n-            if (i) c++;\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) c++;\n@@ -172,3 +252,5 @@\n-    static int firstTrueHelper(boolean[] bits) {\n-        for (int i = 0; i < bits.length; i++) {\n-            if (bits[i])  return i;\n+    int firstTrueHelper() {\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return i;\n@@ -176,1 +258,1 @@\n-        return bits.length;\n+        return length();\n@@ -180,3 +262,5 @@\n-    static int lastTrueHelper(boolean[] bits) {\n-        for (int i = bits.length-1; i >= 0; i--) {\n-            if (bits[i])  return i;\n+    int lastTrueHelper() {\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = length() - 1; i >= 0; i--) {\n+            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return i;\n@@ -188,1 +272,1 @@\n-    static long toLongHelper(boolean[] bits) {\n+    long toLongHelper() {\n@@ -191,2 +275,4 @@\n-        for (int i = 0; i < bits.length; i++) {\n-            res = bits[i] ? res | set : res;\n+        VectorPayloadMF bits = getBits();\n+        long mOffset = bits.multiFieldOffset();\n+        for (int i = 0; i < length(); i++) {\n+            res = Unsafe.getUnsafe().getBoolean(bits, mOffset + i) ? res | set : res;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":116,"deletions":30,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -37,0 +38,1 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n@@ -376,1 +378,1 @@\n-            za = VectorSupport.VectorPayloadMF.createVectPayloadInstance(elementType(), laneCount);\n+            za = VectorPayloadMF.newInstanceFactory(elementType(), laneCount);\n@@ -394,2 +396,2 @@\n-    AbstractMask<E> maskFactory(boolean[] bits) {\n-        return dummyVectorMF().maskFromArray(bits);\n+    AbstractMask<E> maskFactory(VectorPayloadMF payload) {\n+        return dummyVectorMF().maskFromPayload(payload);\n@@ -530,3 +532,5 @@\n-        boolean[] res = new boolean[laneCount];\n-        for (int i = 0; i < res.length; i++) {\n-            res[i] = f.apply(i);\n+        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(boolean.class, laneCount);\n+        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        long mOffset = payload.multiFieldOffset();\n+        for (int i = 0; i < laneCount; i++) {\n+            Unsafe.getUnsafe().putBoolean(payload, mOffset + i, f.apply(i));\n@@ -534,1 +538,2 @@\n-        return dummyVectorMF().maskFromArray(res);\n+        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        return maskFactory(payload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n@@ -186,2 +187,1 @@\n-\n-    abstract AbstractMask<E> maskFromArray(boolean[] bits);\n+    abstract AbstractMask<E> maskFromPayload(VectorPayloadMF payload);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 16));\n-    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(16, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte128Vector ZERO = new Byte128Vector(VectorPayloadMF.newInstanceFactory(byte.class, 16));\n+    static final Byte128Vector IOTA = new Byte128Vector(VectorPayloadMF.createVectPayloadInstanceB(16, (byte[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Byte128Mask maskFromArray(boolean[] bits) {\n-        return new Byte128Mask(bits);\n+    Byte128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Byte128Mask(payload);\n@@ -604,1 +604,1 @@\n-    static final class Byte128Mask extends AbstractMask<Byte> {\n+    static final value class Byte128Mask extends AbstractMask<Byte> {\n@@ -608,3 +608,1 @@\n-        Byte128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF128Z payload;\n@@ -612,2 +610,2 @@\n-        Byte128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Byte128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128Z) payload;\n@@ -616,10 +614,2 @@\n-        Byte128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Byte128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -628,4 +618,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Byte128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -644,12 +632,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Byte128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Byte128Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -659,8 +638,2 @@\n-        Byte128Mask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Byte128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Byte128Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -676,27 +649,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -722,1 +668,1 @@\n-            return (Byte128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Byte128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -735,3 +681,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte128Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte128Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -745,3 +691,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte128Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte128Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -755,3 +701,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte128Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte128Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -766,1 +712,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Byte128Mask) m).trueCountHelper());\n@@ -773,1 +719,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte128Mask) m).firstTrueHelper());\n@@ -780,1 +726,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte128Mask) m).lastTrueHelper());\n@@ -790,1 +736,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Byte128Mask) m).toLongHelper());\n@@ -800,1 +746,1 @@\n-                                         (m, __) -> anyTrueHelper(((Byte128Mask)m).getBits()));\n+                                         (m, __) -> ((Byte128Mask) m).anyTrueHelper());\n@@ -808,1 +754,1 @@\n-                                         (m, __) -> allTrueHelper(((Byte128Mask)m).getBits()));\n+                                         (m, __) -> ((Byte128Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 32));\n-    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(32, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte256Vector ZERO = new Byte256Vector(VectorPayloadMF.newInstanceFactory(byte.class, 32));\n+    static final Byte256Vector IOTA = new Byte256Vector(VectorPayloadMF.createVectPayloadInstanceB(32, (byte[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Byte256Mask maskFromArray(boolean[] bits) {\n-        return new Byte256Mask(bits);\n+    Byte256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Byte256Mask(payload);\n@@ -636,1 +636,1 @@\n-    static final class Byte256Mask extends AbstractMask<Byte> {\n+    static final value class Byte256Mask extends AbstractMask<Byte> {\n@@ -640,3 +640,1 @@\n-        Byte256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF256Z payload;\n@@ -644,2 +642,2 @@\n-        Byte256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Byte256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF256Z) payload;\n@@ -648,10 +646,2 @@\n-        Byte256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Byte256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -660,4 +650,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Byte256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -676,12 +664,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Byte256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Byte256Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -691,8 +670,2 @@\n-        Byte256Mask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Byte256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Byte256Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -708,27 +681,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -754,1 +700,1 @@\n-            return (Byte256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Byte256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -767,3 +713,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte256Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte256Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -777,3 +723,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte256Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte256Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -787,3 +733,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte256Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte256Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -798,1 +744,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Byte256Mask) m).trueCountHelper());\n@@ -805,1 +751,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte256Mask) m).firstTrueHelper());\n@@ -812,1 +758,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte256Mask) m).lastTrueHelper());\n@@ -822,1 +768,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Byte256Mask) m).toLongHelper());\n@@ -832,1 +778,1 @@\n-                                         (m, __) -> anyTrueHelper(((Byte256Mask)m).getBits()));\n+                                         (m, __) -> ((Byte256Mask) m).anyTrueHelper());\n@@ -840,1 +786,1 @@\n-                                         (m, __) -> allTrueHelper(((Byte256Mask)m).getBits()));\n+                                         (m, __) -> ((Byte256Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 64));\n-    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(64, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte512Vector ZERO = new Byte512Vector(VectorPayloadMF.newInstanceFactory(byte.class, 64));\n+    static final Byte512Vector IOTA = new Byte512Vector(VectorPayloadMF.createVectPayloadInstanceB(64, (byte[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Byte512Mask maskFromArray(boolean[] bits) {\n-        return new Byte512Mask(bits);\n+    Byte512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Byte512Mask(payload);\n@@ -700,1 +700,1 @@\n-    static final class Byte512Mask extends AbstractMask<Byte> {\n+    static final value class Byte512Mask extends AbstractMask<Byte> {\n@@ -704,3 +704,1 @@\n-        Byte512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF512Z payload;\n@@ -708,2 +706,2 @@\n-        Byte512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Byte512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF512Z) payload;\n@@ -712,10 +710,2 @@\n-        Byte512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Byte512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -724,4 +714,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Byte512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -740,12 +728,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Byte512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Byte512Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -755,8 +734,2 @@\n-        Byte512Mask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Byte512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Byte512Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -772,27 +745,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -818,1 +764,1 @@\n-            return (Byte512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Byte512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -831,3 +777,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte512Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte512Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -841,3 +787,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte512Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte512Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -851,3 +797,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte512Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte512Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -862,1 +808,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Byte512Mask) m).trueCountHelper());\n@@ -869,1 +815,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte512Mask) m).firstTrueHelper());\n@@ -876,1 +822,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte512Mask) m).lastTrueHelper());\n@@ -886,1 +832,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Byte512Mask) m).toLongHelper());\n@@ -896,1 +842,1 @@\n-                                         (m, __) -> anyTrueHelper(((Byte512Mask)m).getBits()));\n+                                         (m, __) -> ((Byte512Mask) m).anyTrueHelper());\n@@ -904,1 +850,1 @@\n-                                         (m, __) -> allTrueHelper(((Byte512Mask)m).getBits()));\n+                                         (m, __) -> ((Byte512Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.createVectPayloadInstance(byte.class, 8));\n-    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(8, (byte [])(VSPECIES.iotaArray())));\n+    static final Byte64Vector ZERO = new Byte64Vector(VectorPayloadMF.newInstanceFactory(byte.class, 8));\n+    static final Byte64Vector IOTA = new Byte64Vector(VectorPayloadMF.createVectPayloadInstanceB(8, (byte[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Byte64Mask maskFromArray(boolean[] bits) {\n-        return new Byte64Mask(bits);\n+    Byte64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Byte64Mask(payload);\n@@ -588,1 +588,1 @@\n-    static final class Byte64Mask extends AbstractMask<Byte> {\n+    static final value class Byte64Mask extends AbstractMask<Byte> {\n@@ -592,3 +592,1 @@\n-        Byte64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -596,2 +594,2 @@\n-        Byte64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Byte64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -600,10 +598,2 @@\n-        Byte64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Byte64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -612,4 +602,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Byte64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -628,12 +616,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Byte64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Byte64Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -643,8 +622,2 @@\n-        Byte64Mask bOp(VectorMask<Byte> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Byte64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Byte64Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -660,27 +633,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -706,1 +652,1 @@\n-            return (Byte64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Byte64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -719,3 +665,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Byte64Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte64Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -729,3 +675,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Byte64Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte64Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -739,3 +685,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null, byte.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Byte64Mask.class, null,\n+                                          byte.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Byte64Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -750,1 +696,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Byte64Mask) m).trueCountHelper());\n@@ -757,1 +703,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte64Mask) m).firstTrueHelper());\n@@ -764,1 +710,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Byte64Mask) m).lastTrueHelper());\n@@ -774,1 +720,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Byte64Mask) m).toLongHelper());\n@@ -784,1 +730,1 @@\n-                                         (m, __) -> anyTrueHelper(((Byte64Mask)m).getBits()));\n+                                         (m, __) -> ((Byte64Mask) m).anyTrueHelper());\n@@ -792,1 +738,1 @@\n-                                         (m, __) -> allTrueHelper(((Byte64Mask)m).getBits()));\n+                                         (m, __) -> ((Byte64Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,2 +119,2 @@\n-    AbstractMask<Byte> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Byte> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -144,1 +144,2 @@\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -146,1 +147,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -169,1 +170,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -172,2 +173,2 @@\n-            byte v = Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES);\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(i, v));\n+            byte v = Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(i, v));\n@@ -190,1 +191,1 @@\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n@@ -193,1 +194,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -196,2 +198,3 @@\n-            byte v = Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES);\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, mbits[i] ? f.apply(i, v): v);\n+            byte v = Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, v);\n@@ -221,1 +224,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -224,3 +227,3 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n-            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(i, v1, v2));\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(i, v1, v2));\n@@ -245,1 +248,1 @@\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n@@ -249,1 +252,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -252,3 +256,4 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n-            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            byte v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, v);\n@@ -281,1 +286,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -284,4 +289,4 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n-            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n-            byte v3 = Unsafe.getUnsafe().getByte(vec3, start_offset + i * Byte.BYTES);\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(i, v1, v2, v3));\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            byte v3 = Unsafe.getUnsafe().getByte(vec3, vOffset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(i, v1, v2, v3));\n@@ -308,1 +313,1 @@\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n@@ -313,1 +318,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -316,4 +322,5 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n-            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n-            byte v3 = Unsafe.getUnsafe().getByte(vec3, start_offset + i * Byte.BYTES);\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            byte v3 = Unsafe.getUnsafe().getByte(vec3, vOffset + i * Byte.BYTES);\n+            byte v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, v);\n@@ -338,2 +345,3 @@\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -342,2 +350,2 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            byte v1 = Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -352,1 +360,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -355,1 +363,1 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES);\n+            byte v1 = Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES);\n@@ -375,1 +383,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -377,1 +385,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -379,1 +387,1 @@\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -393,1 +401,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -395,2 +403,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -398,2 +407,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -419,1 +428,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -421,1 +430,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -423,1 +432,1 @@\n-            Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -437,1 +446,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -439,2 +448,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -442,2 +452,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putByte(tpayload, start_offset + i * Byte.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putByte(tpayload, vOffset + i * Byte.BYTES, f.apply(memory, offset, i));\n@@ -464,1 +474,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -467,1 +477,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES));\n@@ -478,2 +488,3 @@\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -482,2 +493,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES));\n@@ -499,1 +510,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -502,1 +513,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES));\n@@ -513,2 +524,3 @@\n-        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -517,2 +529,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, start_offset + i * Byte.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getByte(vec, vOffset + i * Byte.BYTES));\n@@ -540,0 +552,1 @@\n+        int length = vspecies().length();\n@@ -542,3 +555,4 @@\n-        int length = vspecies().length();\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -546,3 +560,3 @@\n-            byte v1 = Unsafe.getUnsafe().getByte(vec1, start_offset + i * Byte.BYTES);\n-            byte v2 = Unsafe.getUnsafe().getByte(vec2, start_offset + i * Byte.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            byte v1 = Unsafe.getUnsafe().getByte(vec1, vOffset + i * Byte.BYTES);\n+            byte v2 = Unsafe.getUnsafe().getByte(vec2, vOffset + i * Byte.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -550,1 +564,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -4344,1 +4359,2 @@\n-            boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Byte>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -4346,1 +4362,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":91,"deletions":75,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 2));\n-    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(2, (double [])(VSPECIES.iotaArray())));\n+    static final Double128Vector ZERO = new Double128Vector(VectorPayloadMF.newInstanceFactory(double.class, 2));\n+    static final Double128Vector IOTA = new Double128Vector(VectorPayloadMF.createVectPayloadInstanceD(2, (double[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Double128Mask maskFromArray(boolean[] bits) {\n-        return new Double128Mask(bits);\n+    Double128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Double128Mask(payload);\n@@ -565,1 +565,1 @@\n-    static final class Double128Mask extends AbstractMask<Double> {\n+    static final value class Double128Mask extends AbstractMask<Double> {\n@@ -569,3 +569,1 @@\n-        Double128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF16Z payload;\n@@ -573,2 +571,2 @@\n-        Double128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Double128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16Z) payload;\n@@ -577,10 +575,2 @@\n-        Double128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Double128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -589,4 +579,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Double128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -605,12 +593,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Double128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Double128Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -620,8 +599,2 @@\n-        Double128Mask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Double128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Double128Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -637,27 +610,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -683,1 +629,1 @@\n-            return (Double128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Double128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -696,3 +642,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double128Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -706,3 +652,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double128Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -716,3 +662,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double128Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -727,1 +673,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Double128Mask) m).trueCountHelper());\n@@ -734,1 +680,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double128Mask) m).firstTrueHelper());\n@@ -741,1 +687,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double128Mask) m).lastTrueHelper());\n@@ -751,1 +697,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Double128Mask) m).toLongHelper());\n@@ -761,1 +707,1 @@\n-                                         (m, __) -> anyTrueHelper(((Double128Mask)m).getBits()));\n+                                         (m, __) -> ((Double128Mask) m).anyTrueHelper());\n@@ -769,1 +715,1 @@\n-                                         (m, __) -> allTrueHelper(((Double128Mask)m).getBits()));\n+                                         (m, __) -> ((Double128Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 4));\n-    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(4, (double [])(VSPECIES.iotaArray())));\n+    static final Double256Vector ZERO = new Double256Vector(VectorPayloadMF.newInstanceFactory(double.class, 4));\n+    static final Double256Vector IOTA = new Double256Vector(VectorPayloadMF.createVectPayloadInstanceD(4, (double[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Double256Mask maskFromArray(boolean[] bits) {\n-        return new Double256Mask(bits);\n+    Double256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Double256Mask(payload);\n@@ -569,1 +569,1 @@\n-    static final class Double256Mask extends AbstractMask<Double> {\n+    static final value class Double256Mask extends AbstractMask<Double> {\n@@ -573,3 +573,1 @@\n-        Double256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -577,2 +575,2 @@\n-        Double256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Double256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -581,10 +579,2 @@\n-        Double256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Double256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -593,4 +583,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Double256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -609,12 +597,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Double256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Double256Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -624,8 +603,2 @@\n-        Double256Mask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Double256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Double256Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -641,27 +614,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -687,1 +633,1 @@\n-            return (Double256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Double256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -700,3 +646,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double256Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -710,3 +656,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double256Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -720,3 +666,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double256Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -731,1 +677,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Double256Mask) m).trueCountHelper());\n@@ -738,1 +684,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double256Mask) m).firstTrueHelper());\n@@ -745,1 +691,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double256Mask) m).lastTrueHelper());\n@@ -755,1 +701,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Double256Mask) m).toLongHelper());\n@@ -765,1 +711,1 @@\n-                                         (m, __) -> anyTrueHelper(((Double256Mask)m).getBits()));\n+                                         (m, __) -> ((Double256Mask) m).anyTrueHelper());\n@@ -773,1 +719,1 @@\n-                                         (m, __) -> allTrueHelper(((Double256Mask)m).getBits()));\n+                                         (m, __) -> ((Double256Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 8));\n-    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(8, (double [])(VSPECIES.iotaArray())));\n+    static final Double512Vector ZERO = new Double512Vector(VectorPayloadMF.newInstanceFactory(double.class, 8));\n+    static final Double512Vector IOTA = new Double512Vector(VectorPayloadMF.createVectPayloadInstanceD(8, (double[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Double512Mask maskFromArray(boolean[] bits) {\n-        return new Double512Mask(bits);\n+    Double512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Double512Mask(payload);\n@@ -577,1 +577,1 @@\n-    static final class Double512Mask extends AbstractMask<Double> {\n+    static final value class Double512Mask extends AbstractMask<Double> {\n@@ -581,3 +581,1 @@\n-        Double512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -585,2 +583,2 @@\n-        Double512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Double512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -589,10 +587,2 @@\n-        Double512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Double512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -601,4 +591,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Double512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -617,12 +605,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Double512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Double512Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -632,8 +611,2 @@\n-        Double512Mask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Double512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Double512Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -649,27 +622,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -695,1 +641,1 @@\n-            return (Double512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Double512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -708,3 +654,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double512Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -718,3 +664,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double512Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -728,3 +674,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double512Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -739,1 +685,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Double512Mask) m).trueCountHelper());\n@@ -746,1 +692,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double512Mask) m).firstTrueHelper());\n@@ -753,1 +699,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double512Mask) m).lastTrueHelper());\n@@ -763,1 +709,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Double512Mask) m).toLongHelper());\n@@ -773,1 +719,1 @@\n-                                         (m, __) -> anyTrueHelper(((Double512Mask)m).getBits()));\n+                                         (m, __) -> ((Double512Mask) m).anyTrueHelper());\n@@ -781,1 +727,1 @@\n-                                         (m, __) -> allTrueHelper(((Double512Mask)m).getBits()));\n+                                         (m, __) -> ((Double512Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.createVectPayloadInstance(double.class, 1));\n-    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(1, (double [])(VSPECIES.iotaArray())));\n+    static final Double64Vector ZERO = new Double64Vector(VectorPayloadMF.newInstanceFactory(double.class, 1));\n+    static final Double64Vector IOTA = new Double64Vector(VectorPayloadMF.createVectPayloadInstanceD(1, (double[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Double64Mask maskFromArray(boolean[] bits) {\n-        return new Double64Mask(bits);\n+    Double64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Double64Mask(payload);\n@@ -563,1 +563,1 @@\n-    static final class Double64Mask extends AbstractMask<Double> {\n+    static final value class Double64Mask extends AbstractMask<Double> {\n@@ -567,3 +567,1 @@\n-        Double64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF8Z payload;\n@@ -571,2 +569,2 @@\n-        Double64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Double64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF8Z) payload;\n@@ -575,10 +573,2 @@\n-        Double64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Double64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -587,4 +577,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Double64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -603,12 +591,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Double64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Double64Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -618,8 +597,2 @@\n-        Double64Mask bOp(VectorMask<Double> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Double64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Double64Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -635,27 +608,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -681,1 +627,1 @@\n-            return (Double64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Double64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -694,3 +640,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Double64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double64Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -704,3 +650,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Double64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double64Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -714,3 +660,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Double64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Double64Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -725,1 +671,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Double64Mask) m).trueCountHelper());\n@@ -732,1 +678,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double64Mask) m).firstTrueHelper());\n@@ -739,1 +685,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Double64Mask) m).lastTrueHelper());\n@@ -749,1 +695,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Double64Mask) m).toLongHelper());\n@@ -759,1 +705,1 @@\n-                                         (m, __) -> anyTrueHelper(((Double64Mask)m).getBits()));\n+                                         (m, __) -> ((Double64Mask) m).anyTrueHelper());\n@@ -767,1 +713,1 @@\n-                                         (m, __) -> allTrueHelper(((Double64Mask)m).getBits()));\n+                                         (m, __) -> ((Double64Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,2 +119,2 @@\n-    AbstractMask<Double> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Double> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -144,1 +144,2 @@\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -146,1 +147,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -169,1 +170,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -172,2 +173,2 @@\n-            double v = Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES);\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(i, v));\n+            double v = Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(i, v));\n@@ -190,1 +191,1 @@\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n@@ -193,1 +194,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -196,2 +198,3 @@\n-            double v = Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES);\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, mbits[i] ? f.apply(i, v): v);\n+            double v = Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, v);\n@@ -221,1 +224,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -224,3 +227,3 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n-            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(i, v1, v2));\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(i, v1, v2));\n@@ -245,1 +248,1 @@\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n@@ -249,1 +252,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -252,3 +256,4 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n-            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            double v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, v);\n@@ -281,1 +286,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -284,4 +289,4 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n-            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n-            double v3 = Unsafe.getUnsafe().getDouble(vec3, start_offset + i * Double.BYTES);\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(i, v1, v2, v3));\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            double v3 = Unsafe.getUnsafe().getDouble(vec3, vOffset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(i, v1, v2, v3));\n@@ -308,1 +313,1 @@\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n@@ -313,1 +318,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -316,4 +322,5 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n-            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n-            double v3 = Unsafe.getUnsafe().getDouble(vec3, start_offset + i * Double.BYTES);\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            double v3 = Unsafe.getUnsafe().getDouble(vec3, vOffset + i * Double.BYTES);\n+            double v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, v);\n@@ -338,2 +345,3 @@\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -342,2 +350,2 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            double v1 = Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -352,1 +360,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -355,1 +363,1 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES);\n+            double v1 = Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES);\n@@ -375,1 +383,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -377,1 +385,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -379,1 +387,1 @@\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -393,1 +401,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -395,2 +403,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -398,2 +407,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -419,1 +428,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -421,1 +430,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -423,1 +432,1 @@\n-            Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -437,1 +446,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -439,2 +448,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -442,2 +452,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putDouble(tpayload, start_offset + i * Double.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putDouble(tpayload, vOffset + i * Double.BYTES, f.apply(memory, offset, i));\n@@ -464,1 +474,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -467,1 +477,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES));\n@@ -478,2 +488,3 @@\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -482,2 +493,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES));\n@@ -499,1 +510,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -502,1 +513,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES));\n@@ -513,2 +524,3 @@\n-        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -517,2 +529,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, start_offset + i * Double.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getDouble(vec, vOffset + i * Double.BYTES));\n@@ -540,0 +552,1 @@\n+        int length = vspecies().length();\n@@ -542,3 +555,4 @@\n-        int length = vspecies().length();\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -546,3 +560,3 @@\n-            double v1 = Unsafe.getUnsafe().getDouble(vec1, start_offset + i * Double.BYTES);\n-            double v2 = Unsafe.getUnsafe().getDouble(vec2, start_offset + i * Double.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            double v1 = Unsafe.getUnsafe().getDouble(vec1, vOffset + i * Double.BYTES);\n+            double v2 = Unsafe.getUnsafe().getDouble(vec2, vOffset + i * Double.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -550,1 +564,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -3948,1 +3963,2 @@\n-            boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Double>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -3950,1 +3966,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":91,"deletions":75,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 4));\n-    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(4, (float [])(VSPECIES.iotaArray())));\n+    static final Float128Vector ZERO = new Float128Vector(VectorPayloadMF.newInstanceFactory(float.class, 4));\n+    static final Float128Vector IOTA = new Float128Vector(VectorPayloadMF.createVectPayloadInstanceF(4, (float[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Float128Mask maskFromArray(boolean[] bits) {\n-        return new Float128Mask(bits);\n+    Float128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Float128Mask(payload);\n@@ -569,1 +569,1 @@\n-    static final class Float128Mask extends AbstractMask<Float> {\n+    static final value class Float128Mask extends AbstractMask<Float> {\n@@ -573,3 +573,1 @@\n-        Float128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -577,2 +575,2 @@\n-        Float128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Float128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -581,10 +579,2 @@\n-        Float128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Float128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -593,4 +583,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Float128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -609,12 +597,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Float128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Float128Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -624,8 +603,2 @@\n-        Float128Mask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Float128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Float128Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -641,27 +614,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -687,1 +633,1 @@\n-            return (Float128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Float128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -700,3 +646,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float128Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -710,3 +656,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float128Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -720,3 +666,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float128Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -731,1 +677,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Float128Mask) m).trueCountHelper());\n@@ -738,1 +684,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float128Mask) m).firstTrueHelper());\n@@ -745,1 +691,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float128Mask) m).lastTrueHelper());\n@@ -755,1 +701,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Float128Mask) m).toLongHelper());\n@@ -765,1 +711,1 @@\n-                                         (m, __) -> anyTrueHelper(((Float128Mask)m).getBits()));\n+                                         (m, __) -> ((Float128Mask) m).anyTrueHelper());\n@@ -773,1 +719,1 @@\n-                                         (m, __) -> allTrueHelper(((Float128Mask)m).getBits()));\n+                                         (m, __) -> ((Float128Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 8));\n-    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(8, (float [])(VSPECIES.iotaArray())));\n+    static final Float256Vector ZERO = new Float256Vector(VectorPayloadMF.newInstanceFactory(float.class, 8));\n+    static final Float256Vector IOTA = new Float256Vector(VectorPayloadMF.createVectPayloadInstanceF(8, (float[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Float256Mask maskFromArray(boolean[] bits) {\n-        return new Float256Mask(bits);\n+    Float256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Float256Mask(payload);\n@@ -577,1 +577,1 @@\n-    static final class Float256Mask extends AbstractMask<Float> {\n+    static final value class Float256Mask extends AbstractMask<Float> {\n@@ -581,3 +581,1 @@\n-        Float256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -585,2 +583,2 @@\n-        Float256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Float256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -589,10 +587,2 @@\n-        Float256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Float256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -601,4 +591,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Float256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -617,12 +605,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Float256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Float256Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -632,8 +611,2 @@\n-        Float256Mask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Float256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Float256Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -649,27 +622,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -695,1 +641,1 @@\n-            return (Float256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Float256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -708,3 +654,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float256Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -718,3 +664,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float256Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -728,3 +674,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float256Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -739,1 +685,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Float256Mask) m).trueCountHelper());\n@@ -746,1 +692,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float256Mask) m).firstTrueHelper());\n@@ -753,1 +699,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float256Mask) m).lastTrueHelper());\n@@ -763,1 +709,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Float256Mask) m).toLongHelper());\n@@ -773,1 +719,1 @@\n-                                         (m, __) -> anyTrueHelper(((Float256Mask)m).getBits()));\n+                                         (m, __) -> ((Float256Mask) m).anyTrueHelper());\n@@ -781,1 +727,1 @@\n-                                         (m, __) -> allTrueHelper(((Float256Mask)m).getBits()));\n+                                         (m, __) -> ((Float256Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 16));\n-    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(16, (float [])(VSPECIES.iotaArray())));\n+    static final Float512Vector ZERO = new Float512Vector(VectorPayloadMF.newInstanceFactory(float.class, 16));\n+    static final Float512Vector IOTA = new Float512Vector(VectorPayloadMF.createVectPayloadInstanceF(16, (float[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Float512Mask maskFromArray(boolean[] bits) {\n-        return new Float512Mask(bits);\n+    Float512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Float512Mask(payload);\n@@ -593,1 +593,1 @@\n-    static final class Float512Mask extends AbstractMask<Float> {\n+    static final value class Float512Mask extends AbstractMask<Float> {\n@@ -597,3 +597,1 @@\n-        Float512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF128Z payload;\n@@ -601,2 +599,2 @@\n-        Float512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Float512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128Z) payload;\n@@ -605,10 +603,2 @@\n-        Float512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Float512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -617,4 +607,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Float512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -633,12 +621,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Float512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Float512Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -648,8 +627,2 @@\n-        Float512Mask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Float512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Float512Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -665,27 +638,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -711,1 +657,1 @@\n-            return (Float512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Float512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -724,3 +670,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float512Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -734,3 +680,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float512Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -744,3 +690,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float512Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -755,1 +701,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Float512Mask) m).trueCountHelper());\n@@ -762,1 +708,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float512Mask) m).firstTrueHelper());\n@@ -769,1 +715,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float512Mask) m).lastTrueHelper());\n@@ -779,1 +725,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Float512Mask) m).toLongHelper());\n@@ -789,1 +735,1 @@\n-                                         (m, __) -> anyTrueHelper(((Float512Mask)m).getBits()));\n+                                         (m, __) -> ((Float512Mask) m).anyTrueHelper());\n@@ -797,1 +743,1 @@\n-                                         (m, __) -> allTrueHelper(((Float512Mask)m).getBits()));\n+                                         (m, __) -> ((Float512Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.createVectPayloadInstance(float.class, 2));\n-    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(2, (float [])(VSPECIES.iotaArray())));\n+    static final Float64Vector ZERO = new Float64Vector(VectorPayloadMF.newInstanceFactory(float.class, 2));\n+    static final Float64Vector IOTA = new Float64Vector(VectorPayloadMF.createVectPayloadInstanceF(2, (float[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Float64Mask maskFromArray(boolean[] bits) {\n-        return new Float64Mask(bits);\n+    Float64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Float64Mask(payload);\n@@ -565,1 +565,1 @@\n-    static final class Float64Mask extends AbstractMask<Float> {\n+    static final value class Float64Mask extends AbstractMask<Float> {\n@@ -569,3 +569,1 @@\n-        Float64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF16Z payload;\n@@ -573,2 +571,2 @@\n-        Float64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Float64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16Z) payload;\n@@ -577,10 +575,2 @@\n-        Float64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Float64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -589,4 +579,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Float64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -605,12 +593,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Float64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Float64Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -620,8 +599,2 @@\n-        Float64Mask bOp(VectorMask<Float> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Float64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Float64Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -637,27 +610,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -683,1 +629,1 @@\n-            return (Float64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Float64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -696,3 +642,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Float64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float64Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -706,3 +652,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Float64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float64Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -716,3 +662,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Float64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Float64Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -727,1 +673,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Float64Mask) m).trueCountHelper());\n@@ -734,1 +680,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float64Mask) m).firstTrueHelper());\n@@ -741,1 +687,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Float64Mask) m).lastTrueHelper());\n@@ -751,1 +697,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Float64Mask) m).toLongHelper());\n@@ -761,1 +707,1 @@\n-                                         (m, __) -> anyTrueHelper(((Float64Mask)m).getBits()));\n+                                         (m, __) -> ((Float64Mask) m).anyTrueHelper());\n@@ -769,1 +715,1 @@\n-                                         (m, __) -> allTrueHelper(((Float64Mask)m).getBits()));\n+                                         (m, __) -> ((Float64Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,2 +119,2 @@\n-    AbstractMask<Float> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Float> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -144,1 +144,2 @@\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -146,1 +147,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -169,1 +170,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -172,2 +173,2 @@\n-            float v = Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES);\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(i, v));\n+            float v = Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(i, v));\n@@ -190,1 +191,1 @@\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n@@ -193,1 +194,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -196,2 +198,3 @@\n-            float v = Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES);\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, mbits[i] ? f.apply(i, v): v);\n+            float v = Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, v);\n@@ -221,1 +224,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -224,3 +227,3 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n-            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(i, v1, v2));\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(i, v1, v2));\n@@ -245,1 +248,1 @@\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n@@ -249,1 +252,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -252,3 +256,4 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n-            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            float v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, v);\n@@ -281,1 +286,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -284,4 +289,4 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n-            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n-            float v3 = Unsafe.getUnsafe().getFloat(vec3, start_offset + i * Float.BYTES);\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(i, v1, v2, v3));\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            float v3 = Unsafe.getUnsafe().getFloat(vec3, vOffset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(i, v1, v2, v3));\n@@ -308,1 +313,1 @@\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n@@ -313,1 +318,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -316,4 +322,5 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n-            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n-            float v3 = Unsafe.getUnsafe().getFloat(vec3, start_offset + i * Float.BYTES);\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            float v3 = Unsafe.getUnsafe().getFloat(vec3, vOffset + i * Float.BYTES);\n+            float v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, v);\n@@ -338,2 +345,3 @@\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -342,2 +350,2 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            float v1 = Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -352,1 +360,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -355,1 +363,1 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES);\n+            float v1 = Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES);\n@@ -375,1 +383,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -377,1 +385,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -379,1 +387,1 @@\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -393,1 +401,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -395,2 +403,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -398,2 +407,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -419,1 +428,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -421,1 +430,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -423,1 +432,1 @@\n-            Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -437,1 +446,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -439,2 +448,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -442,2 +452,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putFloat(tpayload, start_offset + i * Float.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putFloat(tpayload, vOffset + i * Float.BYTES, f.apply(memory, offset, i));\n@@ -464,1 +474,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -467,1 +477,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES));\n@@ -478,2 +488,3 @@\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -482,2 +493,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES));\n@@ -499,1 +510,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -502,1 +513,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES));\n@@ -513,2 +524,3 @@\n-        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -517,2 +529,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, start_offset + i * Float.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getFloat(vec, vOffset + i * Float.BYTES));\n@@ -540,0 +552,1 @@\n+        int length = vspecies().length();\n@@ -542,3 +555,4 @@\n-        int length = vspecies().length();\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -546,3 +560,3 @@\n-            float v1 = Unsafe.getUnsafe().getFloat(vec1, start_offset + i * Float.BYTES);\n-            float v2 = Unsafe.getUnsafe().getFloat(vec2, start_offset + i * Float.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            float v1 = Unsafe.getUnsafe().getFloat(vec1, vOffset + i * Float.BYTES);\n+            float v2 = Unsafe.getUnsafe().getFloat(vec2, vOffset + i * Float.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -550,1 +564,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -3889,1 +3904,2 @@\n-            boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Float>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -3891,1 +3907,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":91,"deletions":75,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 4));\n-    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(4, (int [])(VSPECIES.iotaArray())));\n+    static final Int128Vector ZERO = new Int128Vector(VectorPayloadMF.newInstanceFactory(int.class, 4));\n+    static final Int128Vector IOTA = new Int128Vector(VectorPayloadMF.createVectPayloadInstanceI(4, (int[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Int128Mask maskFromArray(boolean[] bits) {\n-        return new Int128Mask(bits);\n+    Int128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Int128Mask(payload);\n@@ -580,1 +580,1 @@\n-    static final class Int128Mask extends AbstractMask<Integer> {\n+    static final value class Int128Mask extends AbstractMask<Integer> {\n@@ -584,3 +584,1 @@\n-        Int128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -588,2 +586,2 @@\n-        Int128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Int128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -592,10 +590,2 @@\n-        Int128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Int128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -604,4 +594,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Int128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -620,12 +608,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Int128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Int128Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -635,8 +614,2 @@\n-        Int128Mask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Int128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Int128Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -652,27 +625,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -698,1 +644,1 @@\n-            return (Int128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Int128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -711,3 +657,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int128Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -721,3 +667,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int128Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -731,3 +677,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int128Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int128Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -742,1 +688,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Int128Mask) m).trueCountHelper());\n@@ -749,1 +695,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int128Mask) m).firstTrueHelper());\n@@ -756,1 +702,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int128Mask) m).lastTrueHelper());\n@@ -766,1 +712,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Int128Mask) m).toLongHelper());\n@@ -776,1 +722,1 @@\n-                                         (m, __) -> anyTrueHelper(((Int128Mask)m).getBits()));\n+                                         (m, __) -> ((Int128Mask) m).anyTrueHelper());\n@@ -784,1 +730,1 @@\n-                                         (m, __) -> allTrueHelper(((Int128Mask)m).getBits()));\n+                                         (m, __) -> ((Int128Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 8));\n-    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(8, (int [])(VSPECIES.iotaArray())));\n+    static final Int256Vector ZERO = new Int256Vector(VectorPayloadMF.newInstanceFactory(int.class, 8));\n+    static final Int256Vector IOTA = new Int256Vector(VectorPayloadMF.createVectPayloadInstanceI(8, (int[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Int256Mask maskFromArray(boolean[] bits) {\n-        return new Int256Mask(bits);\n+    Int256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Int256Mask(payload);\n@@ -588,1 +588,1 @@\n-    static final class Int256Mask extends AbstractMask<Integer> {\n+    static final value class Int256Mask extends AbstractMask<Integer> {\n@@ -592,3 +592,1 @@\n-        Int256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -596,2 +594,2 @@\n-        Int256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Int256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -600,10 +598,2 @@\n-        Int256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Int256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -612,4 +602,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Int256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -628,12 +616,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Int256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Int256Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -643,8 +622,2 @@\n-        Int256Mask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Int256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Int256Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -660,27 +633,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -706,1 +652,1 @@\n-            return (Int256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Int256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -719,3 +665,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int256Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -729,3 +675,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int256Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -739,3 +685,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int256Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int256Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -750,1 +696,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Int256Mask) m).trueCountHelper());\n@@ -757,1 +703,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int256Mask) m).firstTrueHelper());\n@@ -764,1 +710,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int256Mask) m).lastTrueHelper());\n@@ -774,1 +720,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Int256Mask) m).toLongHelper());\n@@ -784,1 +730,1 @@\n-                                         (m, __) -> anyTrueHelper(((Int256Mask)m).getBits()));\n+                                         (m, __) -> ((Int256Mask) m).anyTrueHelper());\n@@ -792,1 +738,1 @@\n-                                         (m, __) -> allTrueHelper(((Int256Mask)m).getBits()));\n+                                         (m, __) -> ((Int256Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 16));\n-    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(16, (int [])(VSPECIES.iotaArray())));\n+    static final Int512Vector ZERO = new Int512Vector(VectorPayloadMF.newInstanceFactory(int.class, 16));\n+    static final Int512Vector IOTA = new Int512Vector(VectorPayloadMF.createVectPayloadInstanceI(16, (int[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Int512Mask maskFromArray(boolean[] bits) {\n-        return new Int512Mask(bits);\n+    Int512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Int512Mask(payload);\n@@ -604,1 +604,1 @@\n-    static final class Int512Mask extends AbstractMask<Integer> {\n+    static final value class Int512Mask extends AbstractMask<Integer> {\n@@ -608,3 +608,1 @@\n-        Int512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF128Z payload;\n@@ -612,2 +610,2 @@\n-        Int512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Int512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128Z) payload;\n@@ -616,10 +614,2 @@\n-        Int512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Int512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -628,4 +618,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Int512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -644,12 +632,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Int512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Int512Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -659,8 +638,2 @@\n-        Int512Mask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Int512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Int512Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -676,27 +649,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -722,1 +668,1 @@\n-            return (Int512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Int512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -735,3 +681,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int512Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -745,3 +691,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int512Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -755,3 +701,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int512Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int512Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -766,1 +712,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Int512Mask) m).trueCountHelper());\n@@ -773,1 +719,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int512Mask) m).firstTrueHelper());\n@@ -780,1 +726,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int512Mask) m).lastTrueHelper());\n@@ -790,1 +736,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Int512Mask) m).toLongHelper());\n@@ -800,1 +746,1 @@\n-                                         (m, __) -> anyTrueHelper(((Int512Mask)m).getBits()));\n+                                         (m, __) -> ((Int512Mask) m).anyTrueHelper());\n@@ -808,1 +754,1 @@\n-                                         (m, __) -> allTrueHelper(((Int512Mask)m).getBits()));\n+                                         (m, __) -> ((Int512Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.createVectPayloadInstance(int.class, 2));\n-    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(2, (int [])(VSPECIES.iotaArray())));\n+    static final Int64Vector ZERO = new Int64Vector(VectorPayloadMF.newInstanceFactory(int.class, 2));\n+    static final Int64Vector IOTA = new Int64Vector(VectorPayloadMF.createVectPayloadInstanceI(2, (int[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Int64Mask maskFromArray(boolean[] bits) {\n-        return new Int64Mask(bits);\n+    Int64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Int64Mask(payload);\n@@ -576,1 +576,1 @@\n-    static final class Int64Mask extends AbstractMask<Integer> {\n+    static final value class Int64Mask extends AbstractMask<Integer> {\n@@ -580,3 +580,1 @@\n-        Int64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF16Z payload;\n@@ -584,2 +582,2 @@\n-        Int64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Int64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16Z) payload;\n@@ -588,10 +586,2 @@\n-        Int64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Int64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -600,4 +590,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Int64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -616,12 +604,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Int64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Int64Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -631,8 +610,2 @@\n-        Int64Mask bOp(VectorMask<Integer> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Int64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Int64Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -648,27 +621,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -694,1 +640,1 @@\n-            return (Int64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Int64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -707,3 +653,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Int64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int64Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -717,3 +663,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Int64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int64Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -727,3 +673,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null, int.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Int64Mask.class, null,\n+                                          int.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Int64Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -738,1 +684,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Int64Mask) m).trueCountHelper());\n@@ -745,1 +691,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int64Mask) m).firstTrueHelper());\n@@ -752,1 +698,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Int64Mask) m).lastTrueHelper());\n@@ -762,1 +708,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Int64Mask) m).toLongHelper());\n@@ -772,1 +718,1 @@\n-                                         (m, __) -> anyTrueHelper(((Int64Mask)m).getBits()));\n+                                         (m, __) -> ((Int64Mask) m).anyTrueHelper());\n@@ -780,1 +726,1 @@\n-                                         (m, __) -> allTrueHelper(((Int64Mask)m).getBits()));\n+                                         (m, __) -> ((Int64Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,2 +119,2 @@\n-    AbstractMask<Integer> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Integer> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -144,1 +144,2 @@\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -146,1 +147,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -169,1 +170,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -172,2 +173,2 @@\n-            int v = Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES);\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v));\n+            int v = Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(i, v));\n@@ -190,1 +191,1 @@\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n@@ -193,1 +194,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -196,2 +198,3 @@\n-            int v = Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES);\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v): v);\n+            int v = Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, v);\n@@ -221,1 +224,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -224,3 +227,3 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n-            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2));\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(i, v1, v2));\n@@ -245,1 +248,1 @@\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n@@ -249,1 +252,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -252,3 +256,4 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n-            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            int v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, v);\n@@ -281,1 +286,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -284,4 +289,4 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n-            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n-            int v3 = Unsafe.getUnsafe().getInt(vec3, start_offset + i * Integer.BYTES);\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(i, v1, v2, v3));\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            int v3 = Unsafe.getUnsafe().getInt(vec3, vOffset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(i, v1, v2, v3));\n@@ -308,1 +313,1 @@\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n@@ -313,1 +318,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -316,4 +322,5 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n-            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n-            int v3 = Unsafe.getUnsafe().getInt(vec3, start_offset + i * Integer.BYTES);\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            int v3 = Unsafe.getUnsafe().getInt(vec3, vOffset + i * Integer.BYTES);\n+            int v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, v);\n@@ -338,2 +345,3 @@\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -342,2 +350,2 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            int v1 = Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -352,1 +360,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -355,1 +363,1 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES);\n+            int v1 = Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES);\n@@ -375,1 +383,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -377,1 +385,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -379,1 +387,1 @@\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -393,1 +401,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -395,2 +403,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -398,2 +407,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -419,1 +428,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -421,1 +430,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -423,1 +432,1 @@\n-            Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -437,1 +446,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -439,2 +448,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -442,2 +452,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putInt(tpayload, start_offset + i * Integer.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putInt(tpayload, vOffset + i * Integer.BYTES, f.apply(memory, offset, i));\n@@ -464,1 +474,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -467,1 +477,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES));\n@@ -478,2 +488,3 @@\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -482,2 +493,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES));\n@@ -499,1 +510,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -502,1 +513,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES));\n@@ -513,2 +524,3 @@\n-        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -517,2 +529,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, start_offset + i * Integer.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getInt(vec, vOffset + i * Integer.BYTES));\n@@ -540,0 +552,1 @@\n+        int length = vspecies().length();\n@@ -542,3 +555,4 @@\n-        int length = vspecies().length();\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -546,3 +560,3 @@\n-            int v1 = Unsafe.getUnsafe().getInt(vec1, start_offset + i * Integer.BYTES);\n-            int v2 = Unsafe.getUnsafe().getInt(vec2, start_offset + i * Integer.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            int v1 = Unsafe.getUnsafe().getInt(vec1, vOffset + i * Integer.BYTES);\n+            int v2 = Unsafe.getUnsafe().getInt(vec2, vOffset + i * Integer.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -550,1 +564,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -4057,1 +4072,2 @@\n-            boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Integer>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -4059,1 +4075,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":91,"deletions":75,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 2));\n-    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(2, (long [])(VSPECIES.iotaArray())));\n+    static final Long128Vector ZERO = new Long128Vector(VectorPayloadMF.newInstanceFactory(long.class, 2));\n+    static final Long128Vector IOTA = new Long128Vector(VectorPayloadMF.createVectPayloadInstanceL(2, (long[])(VSPECIES.iotaArray())));\n@@ -143,2 +143,2 @@\n-    Long128Mask maskFromArray(boolean[] bits) {\n-        return new Long128Mask(bits);\n+    Long128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Long128Mask(payload);\n@@ -566,1 +566,1 @@\n-    static final class Long128Mask extends AbstractMask<Long> {\n+    static final value class Long128Mask extends AbstractMask<Long> {\n@@ -570,3 +570,1 @@\n-        Long128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF16Z payload;\n@@ -574,2 +572,2 @@\n-        Long128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Long128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF16Z) payload;\n@@ -578,10 +576,2 @@\n-        Long128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Long128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -590,4 +580,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Long128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -606,12 +594,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Long128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Long128Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -621,8 +600,2 @@\n-        Long128Mask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Long128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Long128Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -638,27 +611,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -684,1 +630,1 @@\n-            return (Long128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Long128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -697,3 +643,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long128Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -707,3 +653,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long128Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -717,3 +663,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long128Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long128Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -728,1 +674,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Long128Mask) m).trueCountHelper());\n@@ -735,1 +681,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long128Mask) m).firstTrueHelper());\n@@ -742,1 +688,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long128Mask) m).lastTrueHelper());\n@@ -752,1 +698,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Long128Mask) m).toLongHelper());\n@@ -762,1 +708,1 @@\n-                                         (m, __) -> anyTrueHelper(((Long128Mask)m).getBits()));\n+                                         (m, __) -> ((Long128Mask) m).anyTrueHelper());\n@@ -770,1 +716,1 @@\n-                                         (m, __) -> allTrueHelper(((Long128Mask)m).getBits()));\n+                                         (m, __) -> ((Long128Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 4));\n-    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(4, (long [])(VSPECIES.iotaArray())));\n+    static final Long256Vector ZERO = new Long256Vector(VectorPayloadMF.newInstanceFactory(long.class, 4));\n+    static final Long256Vector IOTA = new Long256Vector(VectorPayloadMF.createVectPayloadInstanceL(4, (long[])(VSPECIES.iotaArray())));\n@@ -143,2 +143,2 @@\n-    Long256Mask maskFromArray(boolean[] bits) {\n-        return new Long256Mask(bits);\n+    Long256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Long256Mask(payload);\n@@ -570,1 +570,1 @@\n-    static final class Long256Mask extends AbstractMask<Long> {\n+    static final value class Long256Mask extends AbstractMask<Long> {\n@@ -574,3 +574,1 @@\n-        Long256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -578,2 +576,2 @@\n-        Long256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Long256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -582,10 +580,2 @@\n-        Long256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Long256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -594,4 +584,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Long256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -610,12 +598,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Long256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Long256Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -625,8 +604,2 @@\n-        Long256Mask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Long256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Long256Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -642,27 +615,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -688,1 +634,1 @@\n-            return (Long256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Long256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -701,3 +647,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long256Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -711,3 +657,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long256Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -721,3 +667,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long256Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long256Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -732,1 +678,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Long256Mask) m).trueCountHelper());\n@@ -739,1 +685,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long256Mask) m).firstTrueHelper());\n@@ -746,1 +692,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long256Mask) m).lastTrueHelper());\n@@ -756,1 +702,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Long256Mask) m).toLongHelper());\n@@ -766,1 +712,1 @@\n-                                         (m, __) -> anyTrueHelper(((Long256Mask)m).getBits()));\n+                                         (m, __) -> ((Long256Mask) m).anyTrueHelper());\n@@ -774,1 +720,1 @@\n-                                         (m, __) -> allTrueHelper(((Long256Mask)m).getBits()));\n+                                         (m, __) -> ((Long256Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 8));\n-    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(8, (long [])(VSPECIES.iotaArray())));\n+    static final Long512Vector ZERO = new Long512Vector(VectorPayloadMF.newInstanceFactory(long.class, 8));\n+    static final Long512Vector IOTA = new Long512Vector(VectorPayloadMF.createVectPayloadInstanceL(8, (long[])(VSPECIES.iotaArray())));\n@@ -143,2 +143,2 @@\n-    Long512Mask maskFromArray(boolean[] bits) {\n-        return new Long512Mask(bits);\n+    Long512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Long512Mask(payload);\n@@ -578,1 +578,1 @@\n-    static final class Long512Mask extends AbstractMask<Long> {\n+    static final value class Long512Mask extends AbstractMask<Long> {\n@@ -582,3 +582,1 @@\n-        Long512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -586,2 +584,2 @@\n-        Long512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Long512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -590,10 +588,2 @@\n-        Long512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Long512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -602,4 +592,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Long512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -618,12 +606,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Long512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Long512Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -633,8 +612,2 @@\n-        Long512Mask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Long512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Long512Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -650,27 +623,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -696,1 +642,1 @@\n-            return (Long512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Long512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -709,3 +655,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long512Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -719,3 +665,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long512Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -729,3 +675,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long512Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long512Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -740,1 +686,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Long512Mask) m).trueCountHelper());\n@@ -747,1 +693,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long512Mask) m).firstTrueHelper());\n@@ -754,1 +700,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long512Mask) m).lastTrueHelper());\n@@ -764,1 +710,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Long512Mask) m).toLongHelper());\n@@ -774,1 +720,1 @@\n-                                         (m, __) -> anyTrueHelper(((Long512Mask)m).getBits()));\n+                                         (m, __) -> ((Long512Mask) m).anyTrueHelper());\n@@ -782,1 +728,1 @@\n-                                         (m, __) -> allTrueHelper(((Long512Mask)m).getBits()));\n+                                         (m, __) -> ((Long512Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.createVectPayloadInstance(long.class, 1));\n-    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(1, (long [])(VSPECIES.iotaArray())));\n+    static final Long64Vector ZERO = new Long64Vector(VectorPayloadMF.newInstanceFactory(long.class, 1));\n+    static final Long64Vector IOTA = new Long64Vector(VectorPayloadMF.createVectPayloadInstanceL(1, (long[])(VSPECIES.iotaArray())));\n@@ -143,2 +143,2 @@\n-    Long64Mask maskFromArray(boolean[] bits) {\n-        return new Long64Mask(bits);\n+    Long64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Long64Mask(payload);\n@@ -564,1 +564,1 @@\n-    static final class Long64Mask extends AbstractMask<Long> {\n+    static final value class Long64Mask extends AbstractMask<Long> {\n@@ -568,3 +568,1 @@\n-        Long64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF8Z payload;\n@@ -572,2 +570,2 @@\n-        Long64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Long64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF8Z) payload;\n@@ -576,10 +574,2 @@\n-        Long64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Long64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -588,4 +578,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Long64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -604,12 +592,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Long64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Long64Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -619,8 +598,2 @@\n-        Long64Mask bOp(VectorMask<Long> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Long64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Long64Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -636,27 +609,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -682,1 +628,1 @@\n-            return (Long64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Long64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -695,3 +641,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Long64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long64Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -705,3 +651,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Long64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long64Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -715,3 +661,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null, long.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Long64Mask.class, null,\n+                                          long.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Long64Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -726,1 +672,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Long64Mask) m).trueCountHelper());\n@@ -733,1 +679,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long64Mask) m).firstTrueHelper());\n@@ -740,1 +686,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Long64Mask) m).lastTrueHelper());\n@@ -750,1 +696,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Long64Mask) m).toLongHelper());\n@@ -760,1 +706,1 @@\n-                                         (m, __) -> anyTrueHelper(((Long64Mask)m).getBits()));\n+                                         (m, __) -> ((Long64Mask) m).anyTrueHelper());\n@@ -768,1 +714,1 @@\n-                                         (m, __) -> allTrueHelper(((Long64Mask)m).getBits()));\n+                                         (m, __) -> ((Long64Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,2 +119,2 @@\n-    AbstractMask<Long> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Long> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -144,1 +144,2 @@\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -146,1 +147,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -169,1 +170,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -172,2 +173,2 @@\n-            long v = Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES);\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(i, v));\n+            long v = Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(i, v));\n@@ -190,1 +191,1 @@\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n@@ -193,1 +194,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -196,2 +198,3 @@\n-            long v = Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES);\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, mbits[i] ? f.apply(i, v): v);\n+            long v = Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, v);\n@@ -221,1 +224,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -224,3 +227,3 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n-            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(i, v1, v2));\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(i, v1, v2));\n@@ -245,1 +248,1 @@\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n@@ -249,1 +252,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -252,3 +256,4 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n-            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            long v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, v);\n@@ -281,1 +286,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -284,4 +289,4 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n-            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n-            long v3 = Unsafe.getUnsafe().getLong(vec3, start_offset + i * Long.BYTES);\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(i, v1, v2, v3));\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            long v3 = Unsafe.getUnsafe().getLong(vec3, vOffset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(i, v1, v2, v3));\n@@ -308,1 +313,1 @@\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n@@ -313,1 +318,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -316,4 +322,5 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n-            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n-            long v3 = Unsafe.getUnsafe().getLong(vec3, start_offset + i * Long.BYTES);\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            long v3 = Unsafe.getUnsafe().getLong(vec3, vOffset + i * Long.BYTES);\n+            long v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, v);\n@@ -338,2 +345,3 @@\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -342,2 +350,2 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            long v1 = Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -352,1 +360,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -355,1 +363,1 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES);\n+            long v1 = Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES);\n@@ -375,1 +383,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -377,1 +385,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -379,1 +387,1 @@\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -393,1 +401,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -395,2 +403,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -398,2 +407,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -419,1 +428,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -421,1 +430,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -423,1 +432,1 @@\n-            Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -437,1 +446,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -439,2 +448,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -442,2 +452,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putLong(tpayload, start_offset + i * Long.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putLong(tpayload, vOffset + i * Long.BYTES, f.apply(memory, offset, i));\n@@ -464,1 +474,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -467,1 +477,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES));\n@@ -478,2 +488,3 @@\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -482,2 +493,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES));\n@@ -499,1 +510,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -502,1 +513,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES));\n@@ -513,2 +524,3 @@\n-        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -517,2 +529,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, start_offset + i * Long.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getLong(vec, vOffset + i * Long.BYTES));\n@@ -540,0 +552,1 @@\n+        int length = vspecies().length();\n@@ -542,3 +555,4 @@\n-        int length = vspecies().length();\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -546,3 +560,3 @@\n-            long v1 = Unsafe.getUnsafe().getLong(vec1, start_offset + i * Long.BYTES);\n-            long v2 = Unsafe.getUnsafe().getLong(vec2, start_offset + i * Long.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            long v1 = Unsafe.getUnsafe().getLong(vec1, vOffset + i * Long.BYTES);\n+            long v2 = Unsafe.getUnsafe().getLong(vec2, vOffset + i * Long.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -550,1 +564,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -3992,1 +4007,2 @@\n-            boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Long>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -3994,1 +4010,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":91,"deletions":75,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 8));\n-    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(8, (short [])(VSPECIES.iotaArray())));\n+    static final Short128Vector ZERO = new Short128Vector(VectorPayloadMF.newInstanceFactory(short.class, 8));\n+    static final Short128Vector IOTA = new Short128Vector(VectorPayloadMF.createVectPayloadInstanceS(8, (short[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Short128Mask maskFromArray(boolean[] bits) {\n-        return new Short128Mask(bits);\n+    Short128Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Short128Mask(payload);\n@@ -588,1 +588,1 @@\n-    static final class Short128Mask extends AbstractMask<Short> {\n+    static final value class Short128Mask extends AbstractMask<Short> {\n@@ -592,3 +592,1 @@\n-        Short128Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF64Z payload;\n@@ -596,2 +594,2 @@\n-        Short128Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Short128Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF64Z) payload;\n@@ -600,10 +598,2 @@\n-        Short128Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Short128Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -612,4 +602,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Short128Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -628,12 +616,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Short128Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Short128Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -643,8 +622,2 @@\n-        Short128Mask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Short128Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Short128Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -660,27 +633,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -706,1 +652,1 @@\n-            return (Short128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Short128Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -719,3 +665,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short128Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short128Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -729,3 +675,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short128Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short128Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -739,3 +685,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short128Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short128Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -750,1 +696,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Short128Mask) m).trueCountHelper());\n@@ -757,1 +703,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short128Mask) m).firstTrueHelper());\n@@ -764,1 +710,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short128Mask) m).lastTrueHelper());\n@@ -774,1 +720,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Short128Mask) m).toLongHelper());\n@@ -784,1 +730,1 @@\n-                                         (m, __) -> anyTrueHelper(((Short128Mask)m).getBits()));\n+                                         (m, __) -> ((Short128Mask) m).anyTrueHelper());\n@@ -792,1 +738,1 @@\n-                                         (m, __) -> allTrueHelper(((Short128Mask)m).getBits()));\n+                                         (m, __) -> ((Short128Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 16));\n-    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(16, (short [])(VSPECIES.iotaArray())));\n+    static final Short256Vector ZERO = new Short256Vector(VectorPayloadMF.newInstanceFactory(short.class, 16));\n+    static final Short256Vector IOTA = new Short256Vector(VectorPayloadMF.createVectPayloadInstanceS(16, (short[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Short256Mask maskFromArray(boolean[] bits) {\n-        return new Short256Mask(bits);\n+    Short256Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Short256Mask(payload);\n@@ -604,1 +604,1 @@\n-    static final class Short256Mask extends AbstractMask<Short> {\n+    static final value class Short256Mask extends AbstractMask<Short> {\n@@ -608,3 +608,1 @@\n-        Short256Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF128Z payload;\n@@ -612,2 +610,2 @@\n-        Short256Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Short256Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF128Z) payload;\n@@ -616,10 +614,2 @@\n-        Short256Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Short256Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -628,4 +618,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Short256Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -644,12 +632,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Short256Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Short256Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -659,8 +638,2 @@\n-        Short256Mask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Short256Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Short256Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -676,27 +649,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -722,1 +668,1 @@\n-            return (Short256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Short256Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -735,3 +681,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short256Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short256Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -745,3 +691,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short256Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short256Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -755,3 +701,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short256Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short256Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -766,1 +712,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Short256Mask) m).trueCountHelper());\n@@ -773,1 +719,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short256Mask) m).firstTrueHelper());\n@@ -780,1 +726,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short256Mask) m).lastTrueHelper());\n@@ -790,1 +736,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Short256Mask) m).toLongHelper());\n@@ -800,1 +746,1 @@\n-                                         (m, __) -> anyTrueHelper(((Short256Mask)m).getBits()));\n+                                         (m, __) -> ((Short256Mask) m).anyTrueHelper());\n@@ -808,1 +754,1 @@\n-                                         (m, __) -> allTrueHelper(((Short256Mask)m).getBits()));\n+                                         (m, __) -> ((Short256Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 32));\n-    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(32, (short [])(VSPECIES.iotaArray())));\n+    static final Short512Vector ZERO = new Short512Vector(VectorPayloadMF.newInstanceFactory(short.class, 32));\n+    static final Short512Vector IOTA = new Short512Vector(VectorPayloadMF.createVectPayloadInstanceS(32, (short[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Short512Mask maskFromArray(boolean[] bits) {\n-        return new Short512Mask(bits);\n+    Short512Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Short512Mask(payload);\n@@ -636,1 +636,1 @@\n-    static final class Short512Mask extends AbstractMask<Short> {\n+    static final value class Short512Mask extends AbstractMask<Short> {\n@@ -640,3 +640,1 @@\n-        Short512Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF256Z payload;\n@@ -644,2 +642,2 @@\n-        Short512Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Short512Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF256Z) payload;\n@@ -648,10 +646,2 @@\n-        Short512Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Short512Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -660,4 +650,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Short512Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -676,12 +664,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Short512Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Short512Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -691,8 +670,2 @@\n-        Short512Mask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Short512Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Short512Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -708,27 +681,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -754,1 +700,1 @@\n-            return (Short512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Short512Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -767,3 +713,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short512Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short512Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -777,3 +723,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short512Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short512Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -787,3 +733,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short512Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short512Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -798,1 +744,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Short512Mask) m).trueCountHelper());\n@@ -805,1 +751,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short512Mask) m).firstTrueHelper());\n@@ -812,1 +758,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short512Mask) m).lastTrueHelper());\n@@ -822,1 +768,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Short512Mask) m).toLongHelper());\n@@ -832,1 +778,1 @@\n-                                         (m, __) -> anyTrueHelper(((Short512Mask)m).getBits()));\n+                                         (m, __) -> ((Short512Mask) m).anyTrueHelper());\n@@ -840,1 +786,1 @@\n-                                         (m, __) -> allTrueHelper(((Short512Mask)m).getBits()));\n+                                         (m, __) -> ((Short512Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.createVectPayloadInstance(short.class, 4));\n-    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(4, (short [])(VSPECIES.iotaArray())));\n+    static final Short64Vector ZERO = new Short64Vector(VectorPayloadMF.newInstanceFactory(short.class, 4));\n+    static final Short64Vector IOTA = new Short64Vector(VectorPayloadMF.createVectPayloadInstanceS(4, (short[])(VSPECIES.iotaArray())));\n@@ -148,2 +148,2 @@\n-    Short64Mask maskFromArray(boolean[] bits) {\n-        return new Short64Mask(bits);\n+    Short64Mask maskFromPayload(VectorPayloadMF payload) {\n+        return new Short64Mask(payload);\n@@ -580,1 +580,1 @@\n-    static final class Short64Mask extends AbstractMask<Short> {\n+    static final value class Short64Mask extends AbstractMask<Short> {\n@@ -584,3 +584,1 @@\n-        Short64Mask(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF32Z payload;\n@@ -588,2 +586,2 @@\n-        Short64Mask(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        Short64Mask(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF32Z) payload;\n@@ -592,10 +590,2 @@\n-        Short64Mask(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        Short64Mask(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -604,4 +594,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        Short64Mask(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -620,12 +608,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        Short64Mask uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new Short64Mask(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -635,8 +614,2 @@\n-        Short64Mask bOp(VectorMask<Short> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = ((Short64Mask)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new Short64Mask(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -652,27 +625,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -698,1 +644,1 @@\n-            return (Short64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return (Short64Mask) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -711,3 +657,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Short64Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short64Mask) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -721,3 +667,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Short64Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short64Mask) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -731,3 +677,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null, short.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Short64Mask.class, null,\n+                                          short.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> (Short64Mask) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -742,1 +688,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> ((Short64Mask) m).trueCountHelper());\n@@ -749,1 +695,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short64Mask) m).firstTrueHelper());\n@@ -756,1 +702,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> ((Short64Mask) m).lastTrueHelper());\n@@ -766,1 +712,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> ((Short64Mask) m).toLongHelper());\n@@ -776,1 +722,1 @@\n-                                         (m, __) -> anyTrueHelper(((Short64Mask)m).getBits()));\n+                                         (m, __) -> ((Short64Mask) m).anyTrueHelper());\n@@ -784,1 +730,1 @@\n-                                         (m, __) -> allTrueHelper(((Short64Mask)m).getBits()));\n+                                         (m, __) -> ((Short64Mask) m).allTrueHelper());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":34,"deletions":88,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,2 +119,2 @@\n-    AbstractMask<Short> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<Short> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -144,1 +144,2 @@\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -146,1 +147,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -169,1 +170,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -172,2 +173,2 @@\n-            short v = Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES);\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(i, v));\n+            short v = Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(i, v));\n@@ -190,1 +191,1 @@\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n@@ -193,1 +194,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -196,2 +198,3 @@\n-            short v = Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES);\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, mbits[i] ? f.apply(i, v): v);\n+            short v = Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, v);\n@@ -221,1 +224,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -224,3 +227,3 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n-            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(i, v1, v2));\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(i, v1, v2));\n@@ -245,1 +248,1 @@\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n@@ -249,1 +252,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -252,3 +256,4 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n-            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            short v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, v);\n@@ -281,1 +286,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -284,4 +289,4 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n-            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n-            short v3 = Unsafe.getUnsafe().getShort(vec3, start_offset + i * Short.BYTES);\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(i, v1, v2, v3));\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            short v3 = Unsafe.getUnsafe().getShort(vec3, vOffset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(i, v1, v2, v3));\n@@ -308,1 +313,1 @@\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n@@ -313,1 +318,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -316,4 +322,5 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n-            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n-            short v3 = Unsafe.getUnsafe().getShort(vec3, start_offset + i * Short.BYTES);\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            short v3 = Unsafe.getUnsafe().getShort(vec3, vOffset + i * Short.BYTES);\n+            short v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, v);\n@@ -338,2 +345,3 @@\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -342,2 +350,2 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            short v1 = Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -352,1 +360,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -355,1 +363,1 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES);\n+            short v1 = Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES);\n@@ -375,1 +383,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -377,1 +385,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -379,1 +387,1 @@\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -393,1 +401,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -395,2 +403,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -398,2 +407,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -419,1 +428,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -421,1 +430,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -423,1 +432,1 @@\n-            Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -437,1 +446,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -439,2 +448,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -442,2 +452,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().putShort(tpayload, start_offset + i * Short.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().putShort(tpayload, vOffset + i * Short.BYTES, f.apply(memory, offset, i));\n@@ -464,1 +474,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -467,1 +477,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES));\n@@ -478,2 +488,3 @@\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -482,2 +493,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES));\n@@ -499,1 +510,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -502,1 +513,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES));\n@@ -513,2 +524,3 @@\n-        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -517,2 +529,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, start_offset + i * Short.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().getShort(vec, vOffset + i * Short.BYTES));\n@@ -540,0 +552,1 @@\n+        int length = vspecies().length();\n@@ -542,3 +555,4 @@\n-        int length = vspecies().length();\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -546,3 +560,3 @@\n-            short v1 = Unsafe.getUnsafe().getShort(vec1, start_offset + i * Short.BYTES);\n-            short v2 = Unsafe.getUnsafe().getShort(vec2, start_offset + i * Short.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            short v1 = Unsafe.getUnsafe().getShort(vec1, vOffset + i * Short.BYTES);\n+            short v2 = Unsafe.getUnsafe().getShort(vec2, vOffset + i * Short.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -550,1 +564,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -4338,1 +4353,2 @@\n-            boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<Short>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -4340,1 +4356,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":91,"deletions":75,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,1 +134,5 @@\n-    VectorMask(boolean[] bits) { super(bits); }\n+\n+    \/**\n+     * Default Constructor for abstract VectorMask.\n+     *\/\n+    public VectorMask() {}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,2 +123,2 @@\n-    AbstractMask<$Boxtype$> maskFactory(boolean[] bits) {\n-        return vspecies().maskFactory(bits);\n+    AbstractMask<$Boxtype$> maskFactory(VectorPayloadMF payload) {\n+        return vspecies().maskFactory(payload);\n@@ -148,1 +148,2 @@\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -150,1 +151,1 @@\n-            if (mbits[i]) {\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n@@ -173,1 +174,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -176,2 +177,2 @@\n-            $type$ v = Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES);\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(i, v));\n+            $type$ v = Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(i, v));\n@@ -194,1 +195,1 @@\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n@@ -197,1 +198,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -200,2 +202,3 @@\n-            $type$ v = Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES);\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, mbits[i] ? f.apply(i, v): v);\n+            $type$ v = Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v) : v;\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, v);\n@@ -225,1 +228,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -228,3 +231,3 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(i, v1, v2));\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(i, v1, v2));\n@@ -249,1 +252,1 @@\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n@@ -253,1 +256,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -256,3 +260,4 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, mbits[i] ? f.apply(i, v1, v2): v1);\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2) : v1;\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, v);\n@@ -285,1 +290,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -288,4 +293,4 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v3 = Unsafe.getUnsafe().get$Type$(vec3, start_offset + i * $Boxtype$.BYTES);\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(i, v1, v2, v3));\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v3 = Unsafe.getUnsafe().get$Type$(vec3, vOffset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(i, v1, v2, v3));\n@@ -312,1 +317,1 @@\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n@@ -317,1 +322,2 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -320,4 +326,5 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v3 = Unsafe.getUnsafe().get$Type$(vec3, start_offset + i * $Boxtype$.BYTES);\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, mbits[i] ? f.apply(i, v1, v2, v3): v1);\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v3 = Unsafe.getUnsafe().get$Type$(vec3, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v1, v2, v3) : v1;\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, v);\n@@ -342,2 +349,3 @@\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -346,2 +354,2 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES);\n-            v = mbits[i] ? f.apply(i, v, v1) : v;\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES);\n+            v = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i) ? f.apply(i, v, v1) : v;\n@@ -356,1 +364,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -359,1 +367,1 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES);\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES);\n@@ -379,1 +387,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -381,1 +389,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -383,1 +391,1 @@\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -397,1 +405,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -399,2 +407,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -402,2 +411,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -423,1 +432,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -425,1 +434,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -427,1 +436,1 @@\n-            Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n+            Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -441,1 +450,1 @@\n-            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.createVectPayloadInstance(\n+            Unsafe.getUnsafe().makePrivateBuffer(VectorPayloadMF.newInstanceFactory(\n@@ -443,2 +452,3 @@\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -446,2 +456,2 @@\n-            if (mbits[i]) {\n-                Unsafe.getUnsafe().put$Type$(tpayload, start_offset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                Unsafe.getUnsafe().put$Type$(tpayload, vOffset + i * $Boxtype$.BYTES, f.apply(memory, offset, i));\n@@ -468,1 +478,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -471,1 +481,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES));\n@@ -482,2 +492,3 @@\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -486,2 +497,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES));\n@@ -503,1 +514,1 @@\n-        long start_offset = this.multiFieldOffset();\n+        long vOffset = this.multiFieldOffset();\n@@ -506,1 +517,1 @@\n-            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES));\n+            f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES));\n@@ -517,2 +528,3 @@\n-        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n-        long start_offset = this.multiFieldOffset();\n+        VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -521,2 +533,2 @@\n-            if (mbits[i]) {\n-                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, start_offset + i * $Boxtype$.BYTES));\n+            if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n+                f.apply(memory, offset, i, Unsafe.getUnsafe().get$Type$(vec, vOffset + i * $Boxtype$.BYTES));\n@@ -544,0 +556,1 @@\n+        int length = vspecies().length();\n@@ -546,3 +559,4 @@\n-        int length = vspecies().length();\n-        long start_offset = this.multiFieldOffset();\n-        boolean[] bits = new boolean[length];\n+        VectorPayloadMF mbits = VectorPayloadMF.newInstanceFactory(boolean.class, length);\n+        mbits = Unsafe.getUnsafe().makePrivateBuffer(mbits);\n+        long vOffset = this.multiFieldOffset();\n+        long mOffset = mbits.multiFieldOffset();\n@@ -550,3 +564,3 @@\n-            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, start_offset + i * $Boxtype$.BYTES);\n-            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, start_offset + i * $Boxtype$.BYTES);\n-            bits[i] = f.apply(cond, i, v1, v2);\n+            $type$ v1 = Unsafe.getUnsafe().get$Type$(vec1, vOffset + i * $Boxtype$.BYTES);\n+            $type$ v2 = Unsafe.getUnsafe().get$Type$(vec2, vOffset + i * $Boxtype$.BYTES);\n+            Unsafe.getUnsafe().putBoolean(mbits, mOffset + i, f.apply(cond, i, v1, v2));\n@@ -554,1 +568,2 @@\n-        return maskFactory(bits);\n+        mbits = Unsafe.getUnsafe().finishPrivateBuffer(mbits);\n+        return maskFactory(mbits);\n@@ -5630,1 +5645,2 @@\n-            boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+            VectorPayloadMF mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+            long mOffset = mbits.multiFieldOffset();\n@@ -5632,1 +5648,1 @@\n-                if (mbits[i]) {\n+                if (Unsafe.getUnsafe().getBoolean(mbits, mOffset + i)) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":91,"deletions":75,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.createVectPayloadInstance($type$.class, $numLanes$));\n-    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($numLanes$, ($type$ [])(VSPECIES.iotaArray())));\n+    static final $vectortype$ ZERO = new $vectortype$(VectorPayloadMF.newInstanceFactory($type$.class, $numLanes$));\n+    static final $vectortype$ IOTA = new $vectortype$(VectorPayloadMF.createVectPayloadInstance$Boxinitials$($numLanes$, ($type$[])(VSPECIES.iotaArray())));\n@@ -150,2 +150,2 @@\n-    $masktype$ maskFromArray(boolean[] bits) {\n-        return new $masktype$(bits);\n+    $masktype$ maskFromPayload(VectorPayloadMF payload) {\n+        return new $masktype$(payload);\n@@ -851,1 +851,1 @@\n-    static final class $masktype$ extends AbstractMask<$Boxtype$> {\n+    static final value class $masktype$ extends AbstractMask<$Boxtype$> {\n@@ -855,3 +855,1 @@\n-        $masktype$(boolean[] bits) {\n-            this(bits, 0);\n-        }\n+        private final VectorPayloadMF$vectorsizeinbytes$Z payload;\n@@ -859,2 +857,2 @@\n-        $masktype$(boolean[] bits, int offset) {\n-            super(prepare(bits, offset));\n+        $masktype$(VectorPayloadMF payload) {\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$Z) payload;\n@@ -863,10 +861,2 @@\n-        $masktype$(boolean val) {\n-            super(prepare(val));\n-        }\n-\n-        private static boolean[] prepare(boolean[] bits, int offset) {\n-            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n-            for (int i = 0; i < newBits.length; i++) {\n-                newBits[i] = bits[offset + i];\n-            }\n-            return newBits;\n+        $masktype$(VectorPayloadMF payload, int offset) {\n+            this(prepare(payload, offset, VLENGTH));\n@@ -875,4 +865,2 @@\n-        private static boolean[] prepare(boolean val) {\n-            boolean[] bits = new boolean[VSPECIES.laneCount()];\n-            Arrays.fill(bits, val);\n-            return bits;\n+        $masktype$(boolean val) {\n+            this(prepare(val, VLENGTH));\n@@ -891,12 +879,3 @@\n-        boolean[] getBits() {\n-            return (boolean[])getPayload();\n-        }\n-\n-        @Override\n-        $masktype$ uOp(MUnOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i]);\n-            }\n-            return new $masktype$(res);\n+        final @Override\n+        VectorPayloadMF getBits() {\n+            return payload;\n@@ -906,8 +885,2 @@\n-        $masktype$ bOp(VectorMask<$Boxtype$> m, MBinOp f) {\n-            boolean[] res = new boolean[vspecies().laneCount()];\n-            boolean[] bits = getBits();\n-            boolean[] mbits = (($masktype$)m).getBits();\n-            for (int i = 0; i < res.length; i++) {\n-                res[i] = f.apply(i, bits[i], mbits[i]);\n-            }\n-            return new $masktype$(res);\n+        protected final Object getPayload() {\n+            return getBits();\n@@ -923,27 +896,0 @@\n-        \/**\n-         * Helper function for lane-wise mask conversions.\n-         * This function kicks in after intrinsic failure.\n-         *\/\n-        @ForceInline\n-        private final <E>\n-        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n-            if (length() != dsp.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-            boolean[] maskArray = toArray();\n-            return  dsp.maskFactory(maskArray).check(dsp);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n-\n-            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                this.getClass(), ETYPE, VLENGTH,\n-                species.maskType(), species.elementType(), VLENGTH,\n-                this, species,\n-                (m, s) -> s.maskFactory(m.toArray()).check(s));\n-        }\n-\n@@ -969,1 +915,1 @@\n-            return ($masktype$)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+            return ($masktype$) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n@@ -982,3 +928,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null,\n+                                          $bitstype$.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> ($masktype$) m1.bOp(m2, (i, a, b) -> a & b));\n@@ -992,3 +938,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null,\n+                                          $bitstype$.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> ($masktype$) m1.bOp(m2, (i, a, b) -> a | b));\n@@ -1002,3 +948,3 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n-                                          this, m, null,\n-                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null,\n+                                          $bitstype$.class, VLENGTH, this, m, null,\n+                                          (m1, m2, vm) -> ($masktype$) m1.bOp(m2, (i, a, b) -> a ^ b));\n@@ -1013,1 +959,1 @@\n-                                                      (m) -> trueCountHelper(m.getBits()));\n+                                                            (m) -> (($masktype$) m).trueCountHelper());\n@@ -1020,1 +966,1 @@\n-                                                      (m) -> firstTrueHelper(m.getBits()));\n+                                                            (m) -> (($masktype$) m).firstTrueHelper());\n@@ -1027,1 +973,1 @@\n-                                                      (m) -> lastTrueHelper(m.getBits()));\n+                                                            (m) -> (($masktype$) m).lastTrueHelper());\n@@ -1037,1 +983,1 @@\n-                                                      (m) -> toLongHelper(m.getBits()));\n+                                                      (m) -> (($masktype$) m).toLongHelper());\n@@ -1047,1 +993,1 @@\n-                                         (m, __) -> anyTrueHelper((($masktype$)m).getBits()));\n+                                         (m, __) -> (($masktype$) m).anyTrueHelper());\n@@ -1055,1 +1001,1 @@\n-                                         (m, __) -> allTrueHelper((($masktype$)m).getBits()));\n+                                         (m, __) -> (($masktype$) m).allTrueHelper());\n@@ -1070,3 +1016,5 @@\n-        static boolean[] maskLowerHalf() {\n-            boolean[] a = new boolean[VLENGTH];\n-            int len = a.length >> 1;\n+        static VectorPayloadMF maskLowerHalf() {\n+            VectorPayloadMF newObj = VectorSupport.VectorPayloadMF.newInstanceFactory(boolean.class, VLENGTH);\n+            newObj = Unsafe.getUnsafe().makePrivateBuffer(newObj);\n+            long mf_offset = newObj.multiFieldOffset();\n+            int len = VLENGTH >> 1;\n@@ -1074,1 +1022,1 @@\n-                a[i] = true;\n+                Unsafe.getUnsafe().putBoolean(newObj, mf_offset + i, true);\n@@ -1076,1 +1024,2 @@\n-            return a;\n+            newObj = Unsafe.getUnsafe().finishPrivateBuffer(newObj);\n+            return newObj;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":42,"deletions":93,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,1 @@\n+    vectorsizeinbytes=$((bits \/ sizeInBytes))\n@@ -195,1 +196,1 @@\n-    bitargs=\"$args -Dbits=$bits -DBITS=$BITS -Dvectortype=$vectortype -DnumLanes=$numLanes  -Dmasktype=$masktype -Dshuffletype=$shuffletype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dvectorindextype=$vectorindextype -Dshape=$shape -DShape=$Shape\"\n+    bitargs=\"$args -Dbits=$bits -DBITS=$BITS -Dvectortype=$vectortype -DnumLanes=$numLanes  -Dmasktype=$masktype -Dshuffletype=$shuffletype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dvectorindextype=$vectorindextype -Dshape=$shape -DShape=$Shape -Dvectorsizeinbytes=$vectorsizeinbytes\"\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/gen-src.sh","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}