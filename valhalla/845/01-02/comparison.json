{"files":[{"patch":"@@ -203,0 +203,3 @@\n+  do_klass(vector_VectorPayloadMF8B_klass,              jdk_internal_vm_vector_VectorPayloadMF8B              ) \\\n+  do_klass(vector_VectorPayloadMF16B_klass,             jdk_internal_vm_vector_VectorPayloadMF16B             ) \\\n+  do_klass(vector_VectorPayloadMF32B_klass,             jdk_internal_vm_vector_VectorPayloadMF32B             ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,0 +104,3 @@\n+  template(jdk_internal_vm_vector_VectorPayloadMF8B,   \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8B\")   \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF16B,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16B\")  \\\n+  template(jdk_internal_vm_vector_VectorPayloadMF32B,  \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32B\")  \\\n@@ -310,0 +313,3 @@\n+  template(vector_VectorPayloadMF8B_signature,        \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF8B;\")   \\\n+  template(vector_VectorPayloadMF16B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF16B;\")  \\\n+  template(vector_VectorPayloadMF32B_signature,       \"Qjdk\/internal\/vm\/vector\/VectorSupport$VectorPayloadMF32B;\")  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -919,1 +919,1 @@\n-  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector = false);\n+  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -428,1 +428,1 @@\n-      if (base->is_Con() && !is_array && !mismatched) {\n+      if (base->is_Con() && !is_array && !mismatched && ft->bundle_size() == 1) {\n@@ -443,6 +443,0 @@\n-        BasicType bt = con_type->basic_type();\n-        int vec_len = field->secondary_fields_count();\n-        if (field->is_multifield_base() &&\n-          Matcher::match_rule_supported_vector(VectorNode::replicate_opcode(bt), vec_len, bt)) {\n-          value = kit->gvn().transform(VectorNode::scalar2vector(value, vec_len, Type::get_const_type(field->type()), false));\n-        }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2321,1 +2321,3 @@\n-      assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n+      if (alloc != NULL) {\n+        assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n+      }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"prims\/vectorSupport.hpp\"\n@@ -36,12 +35,0 @@\n-static bool is_vector(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_Vector_klass());\n-}\n-\n-static bool is_vector_mask(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-}\n-\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n@@ -244,69 +231,0 @@\n-\n-  ciInstanceKlass* iklass = vec_box->box_type()->instance_klass();\n-  \/\/ Multi-field based vectors are InlineTypeNodes and are already\n-  \/\/ scalarized by process_inline_types.\n-  if (is_vector(iklass) || is_vector_mask(iklass)) {\n-    return;\n-  }\n-\n-  \/\/ Process debug uses at safepoints\n-  Unique_Node_List safepoints(C->comp_arena());\n-\n-  Unique_Node_List worklist(C->comp_arena());\n-  worklist.push(vec_box);\n-  while (worklist.size() > 0) {\n-    Node* n = worklist.pop();\n-    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-      Node* use = n->fast_out(i);\n-      if (use->is_SafePoint()) {\n-        SafePointNode* sfpt = use->as_SafePoint();\n-        if (!sfpt->is_Call() || !sfpt->as_Call()->has_non_debug_use(n)) {\n-          safepoints.push(sfpt);\n-        }\n-      } else if (use->is_ConstraintCast()) {\n-        worklist.push(use); \/\/ reversed version of Node::uncast()\n-      }\n-    }\n-  }\n-\n-  int n_fields = iklass->nof_nonstatic_fields();\n-  assert(n_fields == 1, \"sanity\");\n-\n-  \/\/ If a mask is feeding into safepoint[s], then its value should be\n-  \/\/ packed into a boolean\/byte vector first, this will simplify the\n-  \/\/ re-materialization logic for both predicated and non-predicated\n-  \/\/ targets.\n-  bool is_mask = is_vector_mask(iklass);\n-  if (is_mask && vec_value->Opcode() != Op_VectorStoreMask) {\n-    const TypeVect* vt = vec_value->bottom_type()->is_vect();\n-    BasicType bt = vt->element_basic_type();\n-    vec_value = gvn.transform(VectorStoreMaskNode::make(gvn, vec_value, bt, vt->length()));\n-  }\n-\n-  while (safepoints.size() > 0) {\n-    SafePointNode* sfpt = safepoints.pop()->as_SafePoint();\n-\n-    uint first_ind = (sfpt->req() - sfpt->jvms()->scloff());\n-    Node* sobj = new SafePointScalarObjectNode(vec_box->box_type(),\n-#ifdef ASSERT\n-                                               vec_box,\n-#endif \/\/ ASSERT\n-                                               first_ind, n_fields);\n-    sobj->init_req(0, C->root());\n-    sfpt->add_req(vec_value);\n-\n-    sobj = gvn.transform(sobj);\n-\n-    JVMState *jvms = sfpt->jvms();\n-\n-    jvms->set_endoff(sfpt->req());\n-    \/\/ Now make a pass over the debug information replacing any references\n-    \/\/ to the allocated object with vector value.\n-    for (uint i = jvms->debug_start(); i < jvms->debug_end(); i++) {\n-      Node* debug = sfpt->in(i);\n-      if (debug != NULL && debug->uncast(\/*keep_deps*\/false) == vec_box) {\n-        sfpt->set_req(i, sobj);\n-      }\n-    }\n-    C->record_for_igvn(sfpt);\n-  }\n@@ -357,1 +275,1 @@\n-    return expand_vbox_alloc_node(vec_box, vbox_alloc, vect, box_type, vect_type);\n+    return expand_vbox_alloc_node(vec_box, vbox_alloc, box_type, vect_type);\n@@ -365,4 +283,4 @@\n-Node* PhaseVector::expand_vbox_alloc_node_vector(VectorBoxNode* vec_box,\n-                                                 VectorBoxAllocateNode* vbox_alloc,\n-                                                 const TypeInstPtr* box_type,\n-                                                 const TypeVect* vect_type) {\n+Node* PhaseVector::expand_vbox_alloc_node(VectorBoxNode* vec_box,\n+                                          VectorBoxAllocateNode* vbox_alloc,\n+                                          const TypeInstPtr* box_type,\n+                                          const TypeVect* vect_type) {\n@@ -385,89 +303,1 @@\n-\/\/ FIXME: To be removed when mask and shuffle use multi-field backed storage.\n-\/\/ Since intrinsification is skipped upfront for  mask\/shuffle related operations\n-\/\/ this is anyways a dead code currently.\n-Node* PhaseVector::expand_vbox_alloc_node_shuffle(VectorBoxAllocateNode* vbox_alloc,\n-                                                       Node* value,\n-                                                       const TypeInstPtr* box_type,\n-                                                       const TypeVect* vect_type) {\n-  JVMState* jvms = clone_jvms(C, vbox_alloc);\n-  GraphKit kit(jvms);\n-  PhaseGVN& gvn = kit.gvn();\n-\n-  ciInstanceKlass* box_klass = box_type->instance_klass();\n-  BasicType bt = vect_type->element_basic_type();\n-  int num_elem = vect_type->length();\n-\n-  bool is_mask = is_vector_mask(box_klass);\n-  \/\/ If boxed mask value is present in a predicate register, it must be\n-  \/\/ spilled to a vector though a VectorStoreMaskOperation before actual StoreVector\n-  \/\/ operation to vector payload field.\n-  if (is_mask && (value->bottom_type()->isa_vectmask() || bt != T_BOOLEAN)) {\n-    value = gvn.transform(VectorStoreMaskNode::make(gvn, value, bt, num_elem));\n-    \/\/ Although type of mask depends on its definition, in terms of storage everything is stored in boolean array.\n-    bt = T_BOOLEAN;\n-    assert(value->bottom_type()->is_vect()->element_basic_type() == bt,\n-           \"must be consistent with mask representation\");\n-  }\n-\n-  \/\/ Generate array allocation for the field which holds the values.\n-  const TypeKlassPtr* array_klass = TypeKlassPtr::make(ciTypeArrayKlass::make(bt));\n-  Node* arr = kit.new_array(kit.makecon(array_klass), kit.intcon(num_elem), 1);\n-\n-  \/\/ Store the vector value into the array.\n-  \/\/ (The store should be captured by InitializeNode and turned into initialized store later.)\n-  Node* arr_adr = kit.array_element_address(arr, kit.intcon(0), bt);\n-  const TypePtr* arr_adr_type = arr_adr->bottom_type()->is_ptr();\n-  Node* arr_mem = kit.memory(arr_adr);\n-  Node* vstore = gvn.transform(StoreVectorNode::make(0,\n-                                                     kit.control(),\n-                                                     arr_mem,\n-                                                     arr_adr,\n-                                                     arr_adr_type,\n-                                                     value,\n-                                                     num_elem));\n-  kit.set_memory(vstore, arr_adr_type);\n-\n-  C->set_max_vector_size(MAX2(C->max_vector_size(), vect_type->length_in_bytes()));\n-\n-  \/\/ Generate the allocate for the Vector object.\n-  const TypeKlassPtr* klass_type = box_type->as_klass_type();\n-  Node* klass_node = kit.makecon(klass_type);\n-  Node* vec_obj = kit.new_instance(klass_node);\n-\n-  \/\/ Store the allocated array into object.\n-  ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbols::payload_name(),\n-                                                                                     ciSymbols::object_signature(),\n-                                                                                     false);\n-  assert(field != NULL, \"\");\n-  Node* vec_field = kit.basic_plus_adr(vec_obj, field->offset_in_bytes());\n-  const TypePtr* vec_adr_type = vec_field->bottom_type()->is_ptr();\n-\n-  \/\/ The store should be captured by InitializeNode and turned into initialized store later.\n-  Node* field_store = gvn.transform(kit.access_store_at(vec_obj,\n-                                                        vec_field,\n-                                                        vec_adr_type,\n-                                                        arr,\n-                                                        TypeOopPtr::make_from_klass(field->type()->as_klass()),\n-                                                        T_OBJECT,\n-                                                        IN_HEAP));\n-  kit.set_memory(field_store, vec_adr_type);\n-\n-  kit.replace_call(vbox_alloc, vec_obj, true);\n-  C->remove_macro_node(vbox_alloc);\n-\n-  return vec_obj;\n-}\n-\n-Node* PhaseVector::expand_vbox_alloc_node(VectorBoxNode* vec_box, VectorBoxAllocateNode* vbox_alloc,\n-                                          Node* value,\n-                                          const TypeInstPtr* box_type,\n-                                          const TypeVect* vect_type) {\n-  ciInstanceKlass* box_klass = box_type->instance_klass();\n-  if (is_vector(box_klass) || is_vector_mask(box_klass)) {\n-    return expand_vbox_alloc_node_vector(vec_box, vbox_alloc, box_type, vect_type);\n-  } else {\n-    return expand_vbox_alloc_node_shuffle(vbox_alloc, value, box_type, vect_type);\n-  }\n-}\n-\n-void PhaseVector::expand_vunbox_node_vector(VectorUnboxNode* vec_unbox) {\n+void PhaseVector::expand_vunbox_node(VectorUnboxNode* vec_unbox) {\n@@ -482,0 +312,2 @@\n+\n+    assert(node->bottom_type()->isa_vect() != NULL, \"not a vector\");\n@@ -492,92 +324,0 @@\n-\/\/ FIXME: To be removed when mask and shuffle use multi-field backed storage.\n-\/\/ Since intrinsification is skipped upfront for mask\/shuffle related operations\n-\/\/ this is anyways a dead code currently.\n-void PhaseVector::expand_vunbox_node_shuffle(VectorUnboxNode* vec_unbox) {\n-  if (vec_unbox->outcnt() > 0) {\n-    GraphKit kit;\n-    PhaseGVN& gvn = kit.gvn();\n-\n-    Node* obj = vec_unbox->obj();\n-    const TypeInstPtr* tinst = gvn.type(obj)->isa_instptr();\n-    ciInstanceKlass* from_kls = tinst->instance_klass();\n-    const TypeVect* vt = vec_unbox->bottom_type()->is_vect();\n-    BasicType bt = vt->element_basic_type();\n-    BasicType masktype = bt;\n-\n-    if (is_vector_mask(from_kls)) {\n-      bt = T_BOOLEAN;\n-    } else if (is_vector_shuffle(from_kls)) {\n-      bt = T_BYTE;\n-    }\n-\n-    ciField* field = ciEnv::current()->vector_VectorPayload_klass()->get_field_by_name(ciSymbols::payload_name(),\n-                                                                                       ciSymbols::object_signature(),\n-                                                                                       false);\n-    assert(field != NULL, \"\");\n-    int offset = field->offset_in_bytes();\n-    Node* vec_adr = kit.basic_plus_adr(obj, offset);\n-\n-    Node* mem = vec_unbox->mem();\n-    Node* ctrl = vec_unbox->in(0);\n-    Node* vec_field_ld;\n-    {\n-      DecoratorSet decorators = MO_UNORDERED | IN_HEAP;\n-      C2AccessValuePtr addr(vec_adr, vec_adr->bottom_type()->is_ptr());\n-      MergeMemNode* local_mem = MergeMemNode::make(mem);\n-      gvn.record_for_igvn(local_mem);\n-      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-      C2OptAccess access(gvn, ctrl, local_mem, decorators, T_OBJECT, obj, addr);\n-      const Type* type = TypeOopPtr::make_from_klass(field->type()->as_klass());\n-      vec_field_ld = bs->load_at(access, type);\n-    }\n-\n-    \/\/ For proper aliasing, attach concrete payload type.\n-    ciKlass* payload_klass = ciTypeArrayKlass::make(bt);\n-    const Type* payload_type = TypeAryPtr::make_from_klass(payload_klass)->cast_to_ptr_type(TypePtr::NotNull);\n-    vec_field_ld = gvn.transform(new CastPPNode(vec_field_ld, payload_type));\n-\n-    Node* adr = kit.array_element_address(vec_field_ld, gvn.intcon(0), bt);\n-    const TypePtr* adr_type = adr->bottom_type()->is_ptr();\n-    int num_elem = vt->length();\n-    Node* vec_val_load = LoadVectorNode::make(0,\n-                                              ctrl,\n-                                              mem,\n-                                              adr,\n-                                              adr_type,\n-                                              num_elem,\n-                                              bt);\n-    vec_val_load = gvn.transform(vec_val_load);\n-\n-    C->set_max_vector_size(MAX2(C->max_vector_size(), vt->length_in_bytes()));\n-\n-    if (is_vector_mask(from_kls)) {\n-      vec_val_load = gvn.transform(new VectorLoadMaskNode(vec_val_load, TypeVect::makemask(masktype, num_elem)));\n-    } else if (is_vector_shuffle(from_kls) && !vec_unbox->is_shuffle_to_vector()) {\n-      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n-      vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n-    }\n-\n-    gvn.hash_delete(vec_unbox);\n-    vec_unbox->disconnect_inputs(C);\n-    C->gvn_replace_by(vec_unbox, vec_val_load);\n-  }\n-  C->remove_macro_node(vec_unbox);\n-}\n-\n-void PhaseVector::expand_vunbox_node(VectorUnboxNode* vec_unbox) {\n-  if (vec_unbox->outcnt() > 0) {\n-    GraphKit kit;\n-    PhaseGVN& gvn = kit.gvn();\n-    Node* obj = vec_unbox->obj();\n-    const TypeInstPtr* tinst = gvn.type(obj)->isa_instptr();\n-    ciInstanceKlass* from_kls = tinst->instance_klass();\n-\n-    if (is_vector(from_kls) || is_vector_mask(from_kls)) {\n-      return expand_vunbox_node_vector(vec_unbox);\n-    } else {\n-      return expand_vunbox_node_shuffle(vec_unbox);\n-    }\n-  }\n-  C->remove_macro_node(vec_unbox);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":8,"deletions":268,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-                               Node* value,\n@@ -52,10 +51,0 @@\n-  Node* expand_vbox_alloc_node_vector(VectorBoxNode* vec_box,\n-                                      VectorBoxAllocateNode* vbox_alloc,\n-                                      const TypeInstPtr* box_type,\n-                                      const TypeVect* vect_type);\n-\n-  Node* expand_vbox_alloc_node_shuffle(VectorBoxAllocateNode* vbox_alloc,\n-                                            Node* value,\n-                                            const TypeInstPtr* box_type,\n-                                            const TypeVect* vect_type);\n-\n@@ -66,2 +55,0 @@\n-  void expand_vunbox_node_vector(VectorUnboxNode* vec_unbox);\n-  void expand_vunbox_node_shuffle(VectorUnboxNode* vec_unbox);\n","filename":"src\/hotspot\/share\/opto\/vector.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,4 +34,0 @@\n-static bool is_vector(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_Vector_klass());\n-}\n-\n@@ -47,0 +43,4 @@\n+static bool is_vector(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayload_klass());\n+}\n+\n@@ -51,1 +51,1 @@\n-  assert(is_vector(ik) || is_vector_mask(ik), \"not a vector or a vector mask\");\n+  assert(is_vector(ik), \"not a vector\");\n@@ -160,0 +160,4 @@\n+  if (is_vector_shuffle(vbox_type->instance_klass())) {\n+    assert(elem_bt == T_BYTE, \"must be consistent with shuffle representation\");\n+  }\n+\n@@ -173,1 +177,1 @@\n-Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector) {\n+Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem) {\n@@ -182,5 +186,0 @@\n-  \/\/ TODO[valhalla] Limiting support to only vector and vector mask cases untill shuffle becomes inline types.\n-  if (!is_vector(vbox_type->instance_klass()) && !is_vector_mask(vbox_type->instance_klass())) {\n-    return NULL;\n-  }\n-  assert(check_vbox(vbox_type), \"\");\n@@ -188,0 +187,1 @@\n+  assert(check_vbox(vbox_type), \"\");\n@@ -193,1 +193,1 @@\n-  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory(), shuffle_to_vector));\n+  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory()));\n@@ -741,1 +741,1 @@\n-  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem, true);\n+  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem);\n@@ -812,3 +812,1 @@\n-  \/\/ Unbox shuffle with true flag to indicate its load shuffle to vector\n-  \/\/ shuffle is a byte array\n-  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem, true);\n+  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem);\n@@ -881,5 +879,0 @@\n-  bool is_shuffle = is_vector_shuffle(vbox_klass);\n-  \/\/ TODO[valhalla] Preventing intrinsification for shuffle till they become inline types.\n-  if (is_shuffle) {\n-    return false;\n-  }\n@@ -1027,5 +1020,0 @@\n-  bool is_shuffle = is_vector_shuffle(vbox_klass);\n-  \/\/ TODO[valhalla] Preventing intrinsification for shuffle till they become inline types.\n-  if (is_shuffle) {\n-    return false;\n-  }\n@@ -2087,1 +2075,0 @@\n-  BasicType shuffle_bt = elem_bt;\n@@ -2129,2 +2116,1 @@\n-  Node* shuffle = unbox_vector(argument(6), shbox_type, shuffle_bt, num_elem);\n-\n+  Node* shuffle = unbox_vector(argument(6), shbox_type, T_BYTE, num_elem);\n@@ -2149,0 +2135,1 @@\n+  shuffle = gvn().transform(new VectorLoadShuffleNode(shuffle, TypeVect::make(elem_bt, num_elem)));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":16,"deletions":29,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1652,43 +1652,0 @@\n-Node* VectorUnboxNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n-  Node* n = obj();\n-  assert(n->is_InlineType(), \"\");\n-  \/\/ Vector APIs are lazily intrinsified, during parsing compiler emits a\n-  \/\/ call to intrinsic function, since most of the APIs return an abstract vector\n-  \/\/ hence a subsequent checkcast results into a graph shape comprising of CheckPP\n-  \/\/ and CheckCastPP chain. During lazy inline expansion, call gets replaced by\n-  \/\/ a VectorBox but we still need to traverse back through chain of cast nodes\n-  \/\/ to get to the VectorBox.\n-  if (!n->is_VectorBox() &&\n-      VectorSupport::is_vector(n->as_InlineType()->inline_klass()->get_InlineKlass())) {\n-    n = n->as_InlineType()->get_oop();\n-  }\n-  n = n->uncast();\n-  if (EnableVectorReboxing && n->Opcode() == Op_VectorBox) {\n-    if (Type::cmp(bottom_type(), n->as_VectorBox()->get_vec()->bottom_type()) == 0) {\n-      \/\/ Handled by VectorUnboxNode::Identity()\n-    } else {\n-      VectorBoxNode* vbox = static_cast<VectorBoxNode*>(n);\n-      ciKlass* vbox_klass = vbox->box_type()->instance_klass();\n-      const TypeVect* in_vt = vbox->vec_type();\n-      const TypeVect* out_vt = type()->is_vect();\n-\n-      if (in_vt->length() == out_vt->length()) {\n-        Node* value = vbox->field_value(0);\n-        bool is_vector_shuffle = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-        if (is_vector_shuffle) {\n-          if (!is_shuffle_to_vector()) {\n-            \/\/ VectorUnbox (VectorBox vshuffle) ==> VectorLoadShuffle vshuffle\n-            return new VectorLoadShuffleNode(value, out_vt);\n-          }\n-        } else {\n-          \/\/ Vector type mismatch is only supported for shuffles, but sometimes it happens in pathological cases.\n-        }\n-      } else {\n-        \/\/ Vector length mismatch.\n-        \/\/ Sometimes happen in pathological cases (e.g., when unboxing happens in effectively dead code).\n-      }\n-    }\n-  }\n-  return NULL;\n-}\n-\n@@ -1697,1 +1654,2 @@\n-  if (n->is_InlineType() && !n->is_VectorBox()) {\n+  assert(n->is_InlineType(), \"\");\n+  if (!n->is_VectorBox()) {\n@@ -1708,2 +1666,1 @@\n-  if (n->is_InlineType() &&\n-      !n->is_VectorBox() &&\n+  if (!n->is_VectorBox() &&\n@@ -1717,2 +1674,0 @@\n-    } else {\n-      \/\/ Handled by VectorUnboxNode::Ideal().\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":48,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1733,2 +1733,0 @@\n- private:\n-  bool _shuffle_to_vector;\n@@ -1738,1 +1736,1 @@\n-  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem, bool shuffle_to_vector)\n+  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem)\n@@ -1740,1 +1738,0 @@\n-    _shuffle_to_vector = shuffle_to_vector;\n@@ -1750,2 +1747,0 @@\n-  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n-  bool is_shuffle_to_vector() { return _shuffle_to_vector; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  return klass->is_subclass_of(vmClasses::vector_Vector_klass());\n+  return klass->is_subclass_of(vmClasses::vector_VectorPayload_klass());\n@@ -89,1 +89,0 @@\n-         VectorSupport::is_vector_mask(klass) ||\n@@ -128,20 +127,0 @@\n-\/\/ Masks require special handling: when boxed they are packed and stored in boolean\n-\/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n-\/\/ For example, Int512Mask is represented in memory as boolean[16], but\n-\/\/ occupies the whole 512-bit vector register when scalarized.\n-\/\/ During scalarization inserting a VectorStoreMask node between mask\n-\/\/ and safepoint node always ensures the existence of masks in a boolean array.\n-\n-void VectorSupport::init_payload_element(typeArrayOop arr, BasicType elem_bt, int index, address addr) {\n-  switch (elem_bt) {\n-    case T_BOOLEAN: arr->bool_at_put(index, *(jboolean*)addr); break;\n-    case T_BYTE:    arr->byte_at_put(index, *(jbyte*)addr); break;\n-    case T_SHORT:   arr->short_at_put(index, *(jshort*)addr); break;\n-    case T_INT:     arr->int_at_put(index, *(jint*)addr); break;\n-    case T_FLOAT:   arr->float_at_put(index, *(jfloat*)addr); break;\n-    case T_LONG:    arr->long_at_put(index, *(jlong*)addr); break;\n-    case T_DOUBLE:  arr->double_at_put(index, *(jdouble*)addr); break;\n-    default: fatal(\"unsupported: %s\", type2name(elem_bt));\n-  }\n-}\n-\n@@ -149,8 +128,5 @@\n-  int elem_size = type2aelembytes(elem_bt);\n-\n-  \/\/ FIXME: Existing handling is used for shuffles and mask classes, to be removed after\n-  \/\/ complete support.\n-  \/\/ On-heap vector values are represented as primitive arrays.\n-  if (is_vector_shuffle(ik) || is_vector_mask(ik)) {\n-    TypeArrayKlass* tak = TypeArrayKlass::cast(Universe::typeArrayKlassObj(elem_bt));\n-    typeArrayOop arr = tak->allocate(num_elem, CHECK_NH); \/\/ safepoint\n+  \/\/ On-heap vector values are represented as primitive class instances with a multi-field payload.\n+  InstanceKlass* payload_kls = get_vector_payload_klass(elem_bt, num_elem);\n+  assert(payload_kls->is_inline_klass(), \"\");\n+  instanceOop obj = InlineKlass::cast(payload_kls)->allocate_instance(THREAD);\n+  if (larval) obj->set_mark(obj->mark().enter_larval_state());\n@@ -158,3 +134,3 @@\n-    if (location.is_register()) {\n-      \/\/ Value was in a callee-saved register.\n-      VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n+  fieldDescriptor fd;\n+  Klass* def = payload_kls->find_field(vmSymbols::mfield_name(), vmSymbols::type_signature(elem_bt), false, &fd);\n+  assert(fd.is_multifield_base() && fd.secondary_fields_count(fd.index()) == num_elem, \"\");\n@@ -162,3 +138,2 @@\n-      for (int i = 0; i < num_elem; i++) {\n-        int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n-        int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n+  int ffo = InlineKlass::cast(payload_kls)->first_field_offset();\n+  int elem_size = type2aelembytes(elem_bt);\n@@ -166,9 +141,9 @@\n-        address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n-        init_payload_element(arr, elem_bt, i, elem_addr);\n-      }\n-    } else {\n-      \/\/ Value was directly saved on the stack.\n-      address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n-      for (int i = 0; i < num_elem; i++) {\n-        init_payload_element(arr, elem_bt, i, base_addr + i * elem_size);\n-      }\n+  if (location.is_register()) {\n+    \/\/ Value was in a callee-saved register.\n+    VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n+    int vec_size = num_elem * elem_size;\n+    for (int i = 0; i < vec_size; i++) {\n+      int vslot = i \/ VMRegImpl::stack_slot_size;\n+      int off   = i % VMRegImpl::stack_slot_size;\n+      address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n+      obj->byte_field_put(ffo + i, *(jbyte*)elem_addr);\n@@ -176,1 +151,0 @@\n-    return Handle(THREAD, arr);\n@@ -178,28 +152,4 @@\n-    \/\/ On-heap vector values are represented as primitive class instances with a multi-field payload.\n-    InstanceKlass* payload_kls = get_vector_payload_klass(elem_bt, num_elem);\n-    assert(payload_kls->is_inline_klass(), \"\");\n-    instanceOop obj = InlineKlass::cast(payload_kls)->allocate_instance(THREAD);\n-    if (larval) obj->set_mark(obj->mark().enter_larval_state());\n-\n-    fieldDescriptor fd;\n-    Klass* def = payload_kls->find_field(vmSymbols::mfield_name(), vmSymbols::type_signature(elem_bt), false, &fd);\n-    assert(fd.is_multifield_base() && fd.secondary_fields_count(fd.index()) == num_elem, \"\");\n-\n-    int ffo = InlineKlass::cast(payload_kls)->first_field_offset();\n-\n-    if (location.is_register()) {\n-      \/\/ Value was in a callee-saved register.\n-      VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n-      int vec_size = num_elem * elem_size;\n-      for (int i = 0; i < vec_size; i++) {\n-        int vslot = i \/ VMRegImpl::stack_slot_size;\n-        int off   = i % VMRegImpl::stack_slot_size;\n-        address elem_addr = reg_map->location(vreg, vslot) + off; \/\/ assumes little endian element order\n-        obj->byte_field_put(ffo + i, *(jbyte*)elem_addr);\n-      }\n-    } else {\n-      \/\/ Value was directly saved on the stack.\n-      address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n-      for (int i = 0; i < elem_size * num_elem; i++) {\n-        obj->byte_field_put(ffo + i, *(jbyte*)(base_addr + i));\n-      }\n+    \/\/ Value was directly saved on the stack.\n+    address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n+    for (int i = 0; i < elem_size * num_elem; i++) {\n+      obj->byte_field_put(ffo + i, *(jbyte*)(base_addr + i));\n@@ -207,1 +157,0 @@\n-    return Handle(THREAD, obj);\n@@ -209,0 +158,1 @@\n+  return Handle(THREAD, obj);\n@@ -213,0 +163,11 @@\n+    case T_BOOLEAN:\n+      switch(num_elem) {\n+        case  1: return vmSymbols::vector_VectorPayloadMF8Z_signature();\n+        case  2: return vmSymbols::vector_VectorPayloadMF16Z_signature();\n+        case  4: return vmSymbols::vector_VectorPayloadMF32Z_signature();\n+        case  8: return vmSymbols::vector_VectorPayloadMF64Z_signature();\n+        case 16: return vmSymbols::vector_VectorPayloadMF128Z_signature();\n+        case 32: return vmSymbols::vector_VectorPayloadMF256Z_signature();\n+        case 64: return vmSymbols::vector_VectorPayloadMF512Z_signature();\n+        default: ShouldNotReachHere();\n+      } break;\n@@ -215,0 +176,3 @@\n+        case  1: return vmSymbols::vector_VectorPayloadMF8B_signature();\n+        case  2: return vmSymbols::vector_VectorPayloadMF16B_signature();\n+        case  4: return vmSymbols::vector_VectorPayloadMF32B_signature();\n@@ -269,0 +233,11 @@\n+    case T_BOOLEAN:\n+      switch(num_elem) {\n+        case  1: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF8Z_klass));\n+        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF16Z_klass));\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF32Z_klass));\n+        case  8: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF64Z_klass));\n+        case 16: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF128Z_klass));\n+        case 32: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF256Z_klass));\n+        case 64: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF512Z_klass));\n+        default: ShouldNotReachHere();\n+      } break;\n@@ -271,0 +246,3 @@\n+        case  1: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF8B_klass));\n+        case  2: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF16B_klass));\n+        case  4: return vmClasses::klass_at(VM_CLASS_ID(vector_VectorPayloadMF32B_klass));\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":53,"deletions":75,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -157,3 +157,1 @@\n-    public abstract static class VectorPayload {\n-        protected abstract Object getPayload();\n-    }\n+    public abstract static class VectorPayload { }\n@@ -165,10 +163,1 @@\n-    public static class VectorShuffle<E> extends VectorPayload {\n-        private final Object payload; \/\/ array of primitives\n-\n-        protected final Object getPayload() {\n-            return VectorSupport.maybeRebox(this).payload;\n-        }\n-        public VectorShuffle(Object payload) {\n-            this.payload = payload;\n-        }\n-    }\n+    public static abstract class VectorShuffle<E> extends VectorPayload { }\n@@ -194,0 +183,3 @@\n+                    case  1: return new VectorPayloadMF8B();\n+                    case  2: return new VectorPayloadMF16B();\n+                    case  4: return new VectorPayloadMF32B();\n@@ -406,0 +398,27 @@\n+    public primitive static class VectorPayloadMF8B extends VectorPayloadMF {\n+        @MultiField(value = 1)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF8B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF16B extends VectorPayloadMF {\n+        @MultiField(value = 2)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF16B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n+    public primitive static class VectorPayloadMF32B extends VectorPayloadMF {\n+        @MultiField(value = 4)\n+        byte mfield = 0;\n+        static long MFOFFSET = multiFieldOffset(VectorPayloadMF32B.class);\n+\n+        @Override\n+        public long multiFieldOffset() { return MFOFFSET; }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -30,0 +31,2 @@\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n@@ -36,20 +39,4 @@\n-    AbstractShuffle(int length, byte[] reorder) {\n-        super(reorder);\n-        assert(length == reorder.length);\n-        assert(indexesInRange(reorder));\n-    }\n-\n-    AbstractShuffle(int length, int[] reorder) {\n-        this(length, reorder, 0);\n-    }\n-\n-    AbstractShuffle(int length, int[] reorder, int offset) {\n-        super(prepare(length, reorder, offset));\n-    }\n-\n-    AbstractShuffle(int length, IntUnaryOperator f) {\n-        super(prepare(length, f));\n-    }\n-\n-    private static byte[] prepare(int length, int[] reorder, int offset) {\n-        byte[] a = new byte[length];\n+    static VectorPayloadMF prepare(int length, int[] reorder, int offset) {\n+        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        long mf_offset = payload.multiFieldOffset();\n@@ -59,1 +46,1 @@\n-            a[i] = (byte) si;\n+            Unsafe.getUnsafe().putByte(payload, mf_offset + i * Byte.BYTES, (byte) si);\n@@ -61,1 +48,2 @@\n-        return a;\n+        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        return payload;\n@@ -64,3 +52,5 @@\n-    private static byte[] prepare(int length, IntUnaryOperator f) {\n-        byte[] a = new byte[length];\n-        for (int i = 0; i < a.length; i++) {\n+    static VectorPayloadMF prepare(int length, IntUnaryOperator f) {\n+        VectorPayloadMF payload = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        long offset = payload.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n@@ -69,1 +59,1 @@\n-            a[i] = (byte) si;\n+            Unsafe.getUnsafe().putByte(payload, offset + i * Byte.BYTES, (byte) si);\n@@ -71,1 +61,2 @@\n-        return a;\n+        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        return payload;\n@@ -74,3 +65,2 @@\n-    byte[] reorder() {\n-        return (byte[])getPayload();\n-    }\n+    \/*package-private*\/\n+    abstract VectorPayloadMF reorder();\n@@ -90,2 +80,3 @@\n-        byte[] reorder = reorder();\n-        int vlen = reorder.length;\n+        VectorPayloadMF reorder = reorder();\n+        int vlen = reorder.length();\n+        long mf_offset = reorder.multiFieldOffset();\n@@ -93,1 +84,1 @@\n-            int sourceIndex = reorder[i];\n+            int sourceIndex = Unsafe.getUnsafe().getByte(reorder, mf_offset + i * Byte.BYTES);\n@@ -102,2 +93,2 @@\n-        byte[] reorder = reorder();\n-        int[] a = new int[reorder.length];\n+        VectorPayloadMF reorder = reorder();\n+        int[] a = new int[reorder.length()];\n@@ -129,2 +120,3 @@\n-            byte[] reorder = reorder();\n-            throw checkIndexFailed(reorder[vecmask.firstTrue()], length());\n+            VectorPayloadMF reorder = reorder();\n+            long offset = reorder.multiFieldOffset();\n+            throw checkIndexFailed(Unsafe.getUnsafe().getByte(reorder, offset + vecmask.firstTrue() * Byte.BYTES), length());\n@@ -141,1 +133,1 @@\n-            byte[] reorder = reorder();\n+            VectorPayloadMF reorder = reorder();\n@@ -148,3 +140,5 @@\n-    public final VectorShuffle<E> wrapAndRebuild(byte[] oldReorder) {\n-        int length = oldReorder.length;\n-        byte[] reorder = new byte[length];\n+    public final VectorShuffle<E> wrapAndRebuild(VectorPayloadMF oldReorder) {\n+        int length = oldReorder.length();\n+        VectorPayloadMF reorder = VectorPayloadMF.newInstanceFactory(byte.class, length);\n+        long offset = oldReorder.multiFieldOffset();\n+        reorder = Unsafe.getUnsafe().makePrivateBuffer(reorder);\n@@ -152,1 +146,1 @@\n-            int si = oldReorder[i];\n+            int si = Unsafe.getUnsafe().getByte(oldReorder, offset + i * Byte.BYTES);\n@@ -161,1 +155,1 @@\n-            reorder[i] = (byte) si;\n+            Unsafe.getUnsafe().putByte(reorder, offset + i * Byte.BYTES, (byte) si);\n@@ -163,0 +157,1 @@\n+        reorder = Unsafe.getUnsafe().finishPrivateBuffer(reorder);\n@@ -224,3 +219,5 @@\n-    static boolean indexesInRange(byte[] reorder) {\n-        int length = reorder.length;\n-        for (byte si : reorder) {\n+    static boolean indexesInRange(VectorPayloadMF reorder) {\n+        int length = reorder.length();\n+        long offset = reorder.multiFieldOffset();\n+        for (int i = 0; i < length; i++) {\n+            byte si = Unsafe.getUnsafe().getByte(reorder, offset + i * Byte.BYTES);\n@@ -232,1 +229,1 @@\n-                                  java.util.Arrays.toString(reorder));\n+                            reorder.toString());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":45,"deletions":48,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -313,9 +313,0 @@\n-    AbstractVector<E> dummyVector() {\n-        \/\/ This JITs to a constant value:\n-        AbstractVector<E> dummy = dummyVector;\n-        if (dummy != null)  return dummy;\n-        \/\/ The rest of this computation is probably not JIT-ted.\n-        return makeDummyVector();\n-    }\n-    @ForceInline\n-    \/*package-private*\/\n@@ -330,9 +321,0 @@\n-    @ForceInline\n-    private AbstractVector<E> makeDummyVector() {\n-        Object za = Array.newInstance(elementType(), laneCount);\n-        return dummyVector = vectorFactory.apply(za);\n-        \/\/ This is the only use of vectorFactory.\n-        \/\/ All other factory requests are routed\n-        \/\/ through the dummy vector.\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -74,0 +74,3 @@\n+    \/*package-private*\/\n+    abstract VectorPayloadMF vec();\n+\n@@ -194,1 +197,1 @@\n-    abstract AbstractShuffle<E> shuffleFromBytes(byte[] reorder);\n+    abstract AbstractShuffle<E> shuffleFromBytes(VectorPayloadMF reorder);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF128B)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF128B) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Byte128Shuffle shuffleFromBytes(byte[] reorder) { return new Byte128Shuffle(reorder); }\n+    Byte128Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Byte128Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Byte128Vector vectorFactory(byte[] vec) {\n-        return new Byte128Vector(vec);\n-    }\n-\n@@ -558,1 +539,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -593,1 +574,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -632,5 +613,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -638,2 +614,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -771,1 +747,1 @@\n-    static final class Byte128Shuffle extends AbstractShuffle<Byte> {\n+    static final value class Byte128Shuffle extends AbstractShuffle<Byte> {\n@@ -775,2 +751,6 @@\n-        Byte128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF128B payload;\n+\n+        Byte128Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF128B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -780,1 +760,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -784,1 +764,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -788,1 +768,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -825,6 +811,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -832,0 +821,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF256B)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF256B) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Byte256Shuffle shuffleFromBytes(byte[] reorder) { return new Byte256Shuffle(reorder); }\n+    Byte256Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Byte256Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Byte256Vector vectorFactory(byte[] vec) {\n-        return new Byte256Vector(vec);\n-    }\n-\n@@ -574,1 +555,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -625,1 +606,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -664,5 +645,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -670,2 +646,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -803,1 +779,1 @@\n-    static final class Byte256Shuffle extends AbstractShuffle<Byte> {\n+    static final value class Byte256Shuffle extends AbstractShuffle<Byte> {\n@@ -807,2 +783,6 @@\n-        Byte256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF256B payload;\n+\n+        Byte256Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF256B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -812,1 +792,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -816,1 +796,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -820,1 +800,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -857,6 +843,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -864,0 +853,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF512B)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF512B) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Byte512Shuffle shuffleFromBytes(byte[] reorder) { return new Byte512Shuffle(reorder); }\n+    Byte512Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Byte512Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Byte512Vector vectorFactory(byte[] vec) {\n-        return new Byte512Vector(vec);\n-    }\n-\n@@ -606,1 +587,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -689,1 +670,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -728,5 +709,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -734,2 +710,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -867,1 +843,1 @@\n-    static final class Byte512Shuffle extends AbstractShuffle<Byte> {\n+    static final value class Byte512Shuffle extends AbstractShuffle<Byte> {\n@@ -871,2 +847,6 @@\n-        Byte512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF512B payload;\n+\n+        Byte512Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF512B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -876,1 +856,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -880,1 +860,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -884,1 +864,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -921,6 +907,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -928,0 +917,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF64B)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF64B) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    byte[] vec() {\n-        return (byte[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Byte64Shuffle shuffleFromBytes(byte[] reorder) { return new Byte64Shuffle(reorder); }\n+    Byte64Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Byte64Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Byte64Vector vectorFactory(byte[] vec) {\n-        return new Byte64Vector(vec);\n-    }\n-\n@@ -550,1 +531,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -577,1 +558,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -616,5 +597,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -622,2 +598,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -755,1 +731,1 @@\n-    static final class Byte64Shuffle extends AbstractShuffle<Byte> {\n+    static final value class Byte64Shuffle extends AbstractShuffle<Byte> {\n@@ -759,2 +735,6 @@\n-        Byte64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Byte64Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF64B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -764,1 +744,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -768,1 +748,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -772,1 +752,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -809,6 +795,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -816,0 +805,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -96,5 +96,0 @@\n-    \/*package-private*\/\n-    abstract byte[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -105,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -108,2 +103,0 @@\n-    abstract ByteVector vectorFactory(byte[] vec);\n-\n@@ -168,1 +161,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -192,1 +185,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -221,2 +214,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ByteVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o).vec();\n@@ -249,2 +242,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ByteVector)o).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o).vec();\n@@ -282,3 +275,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ByteVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((ByteVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o1).vec();\n+        VectorPayloadMF vec3 = ((ByteVector)o2).vec();\n@@ -314,3 +307,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ByteVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((ByteVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o1).vec();\n+        VectorPayloadMF vec3 = ((ByteVector)o2).vec();\n@@ -344,1 +337,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -359,1 +352,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -473,1 +466,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -487,1 +480,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -509,1 +502,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -523,1 +516,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -553,2 +546,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ByteVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((ByteVector)o).vec();\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF128D)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF128D) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Double128Shuffle shuffleFromBytes(byte[] reorder) { return new Double128Shuffle(reorder); }\n+    Double128Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Double128Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Double128Vector vectorFactory(double[] vec) {\n-        return new Double128Vector(vec);\n-    }\n-\n@@ -533,1 +514,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -554,1 +535,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -593,5 +574,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -599,2 +575,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -732,1 +708,1 @@\n-    static final class Double128Shuffle extends AbstractShuffle<Double> {\n+    static final value class Double128Shuffle extends AbstractShuffle<Double> {\n@@ -736,2 +712,6 @@\n-        Double128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF16B payload;\n+\n+        Double128Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF16B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -741,1 +721,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -745,1 +725,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -749,1 +729,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -786,6 +772,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -793,0 +782,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF256D)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF256D) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Double256Shuffle shuffleFromBytes(byte[] reorder) { return new Double256Shuffle(reorder); }\n+    Double256Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Double256Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Double256Vector vectorFactory(double[] vec) {\n-        return new Double256Vector(vec);\n-    }\n-\n@@ -535,1 +516,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -558,1 +539,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -597,5 +578,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -603,2 +579,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -736,1 +712,1 @@\n-    static final class Double256Shuffle extends AbstractShuffle<Double> {\n+    static final value class Double256Shuffle extends AbstractShuffle<Double> {\n@@ -740,2 +716,6 @@\n-        Double256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Double256Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF32B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -745,1 +725,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -749,1 +729,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -753,1 +733,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -790,6 +776,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -797,0 +786,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF512D)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF512D) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Double512Shuffle shuffleFromBytes(byte[] reorder) { return new Double512Shuffle(reorder); }\n+    Double512Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Double512Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Double512Vector vectorFactory(double[] vec) {\n-        return new Double512Vector(vec);\n-    }\n-\n@@ -539,1 +520,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -566,1 +547,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -605,5 +586,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -611,2 +587,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -744,1 +720,1 @@\n-    static final class Double512Shuffle extends AbstractShuffle<Double> {\n+    static final value class Double512Shuffle extends AbstractShuffle<Double> {\n@@ -748,2 +724,6 @@\n-        Double512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Double512Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF64B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -753,1 +733,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -757,1 +737,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -761,1 +741,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -798,6 +784,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -805,0 +794,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF64D)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF64D) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    double[] vec() {\n-        return (double[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Double64Shuffle shuffleFromBytes(byte[] reorder) { return new Double64Shuffle(reorder); }\n+    Double64Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Double64Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Double64Vector vectorFactory(double[] vec) {\n-        return new Double64Vector(vec);\n-    }\n-\n@@ -532,1 +513,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -552,1 +533,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -591,5 +572,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -597,2 +573,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -730,1 +706,1 @@\n-    static final class Double64Shuffle extends AbstractShuffle<Double> {\n+    static final value class Double64Shuffle extends AbstractShuffle<Double> {\n@@ -734,2 +710,6 @@\n-        Double64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF8B payload;\n+\n+        Double64Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF8B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -739,1 +719,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -743,1 +723,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -747,1 +727,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -784,6 +770,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -791,0 +780,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -96,5 +96,0 @@\n-    \/*package-private*\/\n-    abstract double[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -105,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -108,2 +103,0 @@\n-    abstract DoubleVector vectorFactory(double[] vec);\n-\n@@ -168,1 +161,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -192,1 +185,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -221,2 +214,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((DoubleVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o).vec();\n@@ -249,2 +242,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((DoubleVector)o).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o).vec();\n@@ -282,3 +275,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((DoubleVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((DoubleVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o1).vec();\n+        VectorPayloadMF vec3 = ((DoubleVector)o2).vec();\n@@ -314,3 +307,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((DoubleVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((DoubleVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o1).vec();\n+        VectorPayloadMF vec3 = ((DoubleVector)o2).vec();\n@@ -344,1 +337,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -359,1 +352,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -473,1 +466,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -487,1 +480,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -509,1 +502,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -523,1 +516,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -553,2 +546,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((DoubleVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((DoubleVector)o).vec();\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF128F)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF128F) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Float128Shuffle shuffleFromBytes(byte[] reorder) { return new Float128Shuffle(reorder); }\n+    Float128Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Float128Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Float128Vector vectorFactory(float[] vec) {\n-        return new Float128Vector(vec);\n-    }\n-\n@@ -535,1 +516,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -558,1 +539,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -597,5 +578,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -603,2 +579,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -736,1 +712,1 @@\n-    static final class Float128Shuffle extends AbstractShuffle<Float> {\n+    static final value class Float128Shuffle extends AbstractShuffle<Float> {\n@@ -740,2 +716,6 @@\n-        Float128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Float128Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF32B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -745,1 +725,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -749,1 +729,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -753,1 +733,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -790,6 +776,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -797,0 +786,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF256F)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF256F) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Float256Shuffle shuffleFromBytes(byte[] reorder) { return new Float256Shuffle(reorder); }\n+    Float256Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Float256Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Float256Vector vectorFactory(float[] vec) {\n-        return new Float256Vector(vec);\n-    }\n-\n@@ -539,1 +520,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -566,1 +547,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -605,5 +586,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -611,2 +587,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -744,1 +720,1 @@\n-    static final class Float256Shuffle extends AbstractShuffle<Float> {\n+    static final value class Float256Shuffle extends AbstractShuffle<Float> {\n@@ -748,2 +724,6 @@\n-        Float256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Float256Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF64B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -753,1 +733,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -757,1 +737,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -761,1 +741,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -798,6 +784,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -805,0 +794,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF512F)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF512F) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Float512Shuffle shuffleFromBytes(byte[] reorder) { return new Float512Shuffle(reorder); }\n+    Float512Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Float512Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Float512Vector vectorFactory(float[] vec) {\n-        return new Float512Vector(vec);\n-    }\n-\n@@ -547,1 +528,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -582,1 +563,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -621,5 +602,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -627,2 +603,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -760,1 +736,1 @@\n-    static final class Float512Shuffle extends AbstractShuffle<Float> {\n+    static final value class Float512Shuffle extends AbstractShuffle<Float> {\n@@ -764,2 +740,6 @@\n-        Float512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF128B payload;\n+\n+        Float512Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF128B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -769,1 +749,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -773,1 +753,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -777,1 +757,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -814,6 +800,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -821,0 +810,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF64F)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF64F) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    float[] vec() {\n-        return (float[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Float64Shuffle shuffleFromBytes(byte[] reorder) { return new Float64Shuffle(reorder); }\n+    Float64Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Float64Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Float64Vector vectorFactory(float[] vec) {\n-        return new Float64Vector(vec);\n-    }\n-\n@@ -533,1 +514,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -554,1 +535,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -593,5 +574,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -599,2 +575,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -732,1 +708,1 @@\n-    static final class Float64Shuffle extends AbstractShuffle<Float> {\n+    static final value class Float64Shuffle extends AbstractShuffle<Float> {\n@@ -736,2 +712,6 @@\n-        Float64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF16B payload;\n+\n+        Float64Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF16B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -741,1 +721,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -745,1 +725,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -749,1 +729,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -786,6 +772,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -793,0 +782,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -96,5 +96,0 @@\n-    \/*package-private*\/\n-    abstract float[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -105,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -108,2 +103,0 @@\n-    abstract FloatVector vectorFactory(float[] vec);\n-\n@@ -168,1 +161,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -192,1 +185,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -221,2 +214,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((FloatVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o).vec();\n@@ -249,2 +242,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((FloatVector)o).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o).vec();\n@@ -282,3 +275,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((FloatVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((FloatVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o1).vec();\n+        VectorPayloadMF vec3 = ((FloatVector)o2).vec();\n@@ -314,3 +307,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((FloatVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((FloatVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o1).vec();\n+        VectorPayloadMF vec3 = ((FloatVector)o2).vec();\n@@ -344,1 +337,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -359,1 +352,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -473,1 +466,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -487,1 +480,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -509,1 +502,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -523,1 +516,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -553,2 +546,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((FloatVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((FloatVector)o).vec();\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF128I)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF128I) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Int128Shuffle shuffleFromBytes(byte[] reorder) { return new Int128Shuffle(reorder); }\n+    Int128Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Int128Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Int128Vector vectorFactory(int[] vec) {\n-        return new Int128Vector(vec);\n-    }\n-\n@@ -546,1 +527,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -569,1 +550,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -608,5 +589,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -614,2 +590,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -747,1 +723,1 @@\n-    static final class Int128Shuffle extends AbstractShuffle<Integer> {\n+    static final value class Int128Shuffle extends AbstractShuffle<Integer> {\n@@ -751,2 +727,6 @@\n-        Int128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Int128Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF32B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -756,1 +736,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -760,1 +740,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -764,1 +744,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -801,6 +787,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -808,0 +797,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF256I)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF256I) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Int256Shuffle shuffleFromBytes(byte[] reorder) { return new Int256Shuffle(reorder); }\n+    Int256Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Int256Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Int256Vector vectorFactory(int[] vec) {\n-        return new Int256Vector(vec);\n-    }\n-\n@@ -550,1 +531,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -577,1 +558,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -616,5 +597,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -622,2 +598,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -755,1 +731,1 @@\n-    static final class Int256Shuffle extends AbstractShuffle<Integer> {\n+    static final value class Int256Shuffle extends AbstractShuffle<Integer> {\n@@ -759,2 +735,6 @@\n-        Int256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Int256Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF64B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -764,1 +744,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -768,1 +748,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -772,1 +752,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -809,6 +795,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -816,0 +805,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF512I)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF512I) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Int512Shuffle shuffleFromBytes(byte[] reorder) { return new Int512Shuffle(reorder); }\n+    Int512Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Int512Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Int512Vector vectorFactory(int[] vec) {\n-        return new Int512Vector(vec);\n-    }\n-\n@@ -558,1 +539,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -593,1 +574,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -632,5 +613,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -638,2 +614,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -771,1 +747,1 @@\n-    static final class Int512Shuffle extends AbstractShuffle<Integer> {\n+    static final value class Int512Shuffle extends AbstractShuffle<Integer> {\n@@ -775,2 +751,6 @@\n-        Int512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF128B payload;\n+\n+        Int512Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF128B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -780,1 +760,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -784,1 +764,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -788,1 +768,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -825,6 +811,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -832,0 +821,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF64I)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF64I) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    int[] vec() {\n-        return (int[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Int64Shuffle shuffleFromBytes(byte[] reorder) { return new Int64Shuffle(reorder); }\n+    Int64Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Int64Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Int64Vector vectorFactory(int[] vec) {\n-        return new Int64Vector(vec);\n-    }\n-\n@@ -544,1 +525,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -565,1 +546,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -604,5 +585,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -610,2 +586,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -743,1 +719,1 @@\n-    static final class Int64Shuffle extends AbstractShuffle<Integer> {\n+    static final value class Int64Shuffle extends AbstractShuffle<Integer> {\n@@ -747,2 +723,6 @@\n-        Int64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF16B payload;\n+\n+        Int64Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF16B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -752,1 +732,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -756,1 +736,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -760,1 +740,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -797,6 +783,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -804,0 +793,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -96,5 +96,0 @@\n-    \/*package-private*\/\n-    abstract int[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -105,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -108,2 +103,0 @@\n-    abstract IntVector vectorFactory(int[] vec);\n-\n@@ -168,1 +161,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -192,1 +185,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -221,2 +214,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((IntVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((IntVector)o).vec();\n@@ -249,2 +242,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((IntVector)o).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((IntVector)o).vec();\n@@ -282,3 +275,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((IntVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((IntVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((IntVector)o1).vec();\n+        VectorPayloadMF vec3 = ((IntVector)o2).vec();\n@@ -314,3 +307,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((IntVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((IntVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((IntVector)o1).vec();\n+        VectorPayloadMF vec3 = ((IntVector)o2).vec();\n@@ -344,1 +337,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -359,1 +352,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -473,1 +466,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -487,1 +480,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -509,1 +502,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -523,1 +516,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -553,2 +546,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((IntVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((IntVector)o).vec();\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF128L)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF128L) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -164,1 +152,1 @@\n-    Long128Shuffle shuffleFromBytes(byte[] reorder) { return new Long128Shuffle(reorder); }\n+    Long128Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Long128Shuffle(reorder); }\n@@ -174,7 +162,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Long128Vector vectorFactory(long[] vec) {\n-        return new Long128Vector(vec);\n-    }\n-\n@@ -534,1 +515,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -555,1 +536,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -594,5 +575,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -600,2 +576,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -733,1 +709,1 @@\n-    static final class Long128Shuffle extends AbstractShuffle<Long> {\n+    static final value class Long128Shuffle extends AbstractShuffle<Long> {\n@@ -737,2 +713,6 @@\n-        Long128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF16B payload;\n+\n+        Long128Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF16B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -742,1 +722,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -746,1 +726,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -750,1 +730,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -787,6 +773,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -794,0 +783,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF256L)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF256L) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -164,1 +152,1 @@\n-    Long256Shuffle shuffleFromBytes(byte[] reorder) { return new Long256Shuffle(reorder); }\n+    Long256Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Long256Shuffle(reorder); }\n@@ -174,7 +162,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Long256Vector vectorFactory(long[] vec) {\n-        return new Long256Vector(vec);\n-    }\n-\n@@ -536,1 +517,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -559,1 +540,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -598,5 +579,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -604,2 +580,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -737,1 +713,1 @@\n-    static final class Long256Shuffle extends AbstractShuffle<Long> {\n+    static final value class Long256Shuffle extends AbstractShuffle<Long> {\n@@ -741,2 +717,6 @@\n-        Long256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Long256Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF32B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -746,1 +726,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -750,1 +730,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -754,1 +734,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -791,6 +777,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -798,0 +787,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF512L)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF512L) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -164,1 +152,1 @@\n-    Long512Shuffle shuffleFromBytes(byte[] reorder) { return new Long512Shuffle(reorder); }\n+    Long512Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Long512Shuffle(reorder); }\n@@ -174,7 +162,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Long512Vector vectorFactory(long[] vec) {\n-        return new Long512Vector(vec);\n-    }\n-\n@@ -540,1 +521,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -567,1 +548,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -606,5 +587,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -612,2 +588,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -745,1 +721,1 @@\n-    static final class Long512Shuffle extends AbstractShuffle<Long> {\n+    static final value class Long512Shuffle extends AbstractShuffle<Long> {\n@@ -749,2 +725,6 @@\n-        Long512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Long512Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF64B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -754,1 +734,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -758,1 +738,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -762,1 +742,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -799,6 +785,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -806,0 +795,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF64L)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF64L) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    long[] vec() {\n-        return (long[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -164,1 +152,1 @@\n-    Long64Shuffle shuffleFromBytes(byte[] reorder) { return new Long64Shuffle(reorder); }\n+    Long64Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Long64Shuffle(reorder); }\n@@ -174,7 +162,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Long64Vector vectorFactory(long[] vec) {\n-        return new Long64Vector(vec);\n-    }\n-\n@@ -533,1 +514,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -553,1 +534,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -592,5 +573,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -598,2 +574,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -731,1 +707,1 @@\n-    static final class Long64Shuffle extends AbstractShuffle<Long> {\n+    static final value class Long64Shuffle extends AbstractShuffle<Long> {\n@@ -735,2 +711,6 @@\n-        Long64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF8B payload;\n+\n+        Long64Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF8B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -740,1 +720,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -744,1 +724,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -748,1 +728,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -785,6 +771,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -792,0 +781,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -96,5 +96,0 @@\n-    \/*package-private*\/\n-    abstract long[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -105,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -108,2 +103,0 @@\n-    abstract LongVector vectorFactory(long[] vec);\n-\n@@ -168,1 +161,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -192,1 +185,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -221,2 +214,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((LongVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((LongVector)o).vec();\n@@ -249,2 +242,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((LongVector)o).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((LongVector)o).vec();\n@@ -282,3 +275,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((LongVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((LongVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((LongVector)o1).vec();\n+        VectorPayloadMF vec3 = ((LongVector)o2).vec();\n@@ -314,3 +307,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((LongVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((LongVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((LongVector)o1).vec();\n+        VectorPayloadMF vec3 = ((LongVector)o2).vec();\n@@ -344,1 +337,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -359,1 +352,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -473,1 +466,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -487,1 +480,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -509,1 +502,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -523,1 +516,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -553,2 +546,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((LongVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((LongVector)o).vec();\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF128S)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF128S) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Short128Shuffle shuffleFromBytes(byte[] reorder) { return new Short128Shuffle(reorder); }\n+    Short128Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Short128Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Short128Vector vectorFactory(short[] vec) {\n-        return new Short128Vector(vec);\n-    }\n-\n@@ -550,1 +531,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -577,1 +558,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -616,5 +597,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -622,2 +598,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -755,1 +731,1 @@\n-    static final class Short128Shuffle extends AbstractShuffle<Short> {\n+    static final value class Short128Shuffle extends AbstractShuffle<Short> {\n@@ -759,2 +735,6 @@\n-        Short128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF64B payload;\n+\n+        Short128Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF64B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -764,1 +744,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -768,1 +748,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -772,1 +752,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -809,6 +795,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -816,0 +805,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF256S)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF256S) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Short256Shuffle shuffleFromBytes(byte[] reorder) { return new Short256Shuffle(reorder); }\n+    Short256Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Short256Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Short256Vector vectorFactory(short[] vec) {\n-        return new Short256Vector(vec);\n-    }\n-\n@@ -558,1 +539,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -593,1 +574,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -632,5 +613,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -638,2 +614,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -771,1 +747,1 @@\n-    static final class Short256Shuffle extends AbstractShuffle<Short> {\n+    static final value class Short256Shuffle extends AbstractShuffle<Short> {\n@@ -775,2 +751,6 @@\n-        Short256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF128B payload;\n+\n+        Short256Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF128B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -780,1 +760,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -784,1 +764,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -788,1 +768,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -825,6 +811,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -832,0 +821,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF512S)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF512S) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Short512Shuffle shuffleFromBytes(byte[] reorder) { return new Short512Shuffle(reorder); }\n+    Short512Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Short512Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Short512Vector vectorFactory(short[] vec) {\n-        return new Short512Vector(vec);\n-    }\n-\n@@ -574,1 +555,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -625,1 +606,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -664,5 +645,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -670,2 +646,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -803,1 +779,1 @@\n-    static final class Short512Shuffle extends AbstractShuffle<Short> {\n+    static final value class Short512Shuffle extends AbstractShuffle<Short> {\n@@ -807,2 +783,6 @@\n-        Short512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF256B payload;\n+\n+        Short512Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF256B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -812,1 +792,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -816,1 +796,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -820,1 +800,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -857,6 +843,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -864,0 +853,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF64S)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF64S) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    short[] vec() {\n-        return (short[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -169,1 +157,1 @@\n-    Short64Shuffle shuffleFromBytes(byte[] reorder) { return new Short64Shuffle(reorder); }\n+    Short64Shuffle shuffleFromBytes(VectorPayloadMF reorder) { return new Short64Shuffle(reorder); }\n@@ -179,7 +167,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    Short64Vector vectorFactory(short[] vec) {\n-        return new Short64Vector(vec);\n-    }\n-\n@@ -546,1 +527,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -569,1 +550,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -608,5 +589,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -614,2 +590,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -747,1 +723,1 @@\n-    static final class Short64Shuffle extends AbstractShuffle<Short> {\n+    static final value class Short64Shuffle extends AbstractShuffle<Short> {\n@@ -751,2 +727,6 @@\n-        Short64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF32B payload;\n+\n+        Short64Shuffle(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF32B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -756,1 +736,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -760,1 +740,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -764,1 +744,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -801,6 +787,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -808,0 +797,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -96,5 +96,0 @@\n-    \/*package-private*\/\n-    abstract short[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -105,1 +100,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -108,2 +103,0 @@\n-    abstract ShortVector vectorFactory(short[] vec);\n-\n@@ -168,1 +161,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -192,1 +185,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -221,2 +214,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ShortVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o).vec();\n@@ -249,2 +242,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ShortVector)o).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o).vec();\n@@ -282,3 +275,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ShortVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((ShortVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o1).vec();\n+        VectorPayloadMF vec3 = ((ShortVector)o2).vec();\n@@ -314,3 +307,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ShortVector)o1).vec_mf();\n-        VectorPayloadMF vec3 = ((ShortVector)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o1).vec();\n+        VectorPayloadMF vec3 = ((ShortVector)o2).vec();\n@@ -344,1 +337,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -359,1 +352,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -473,1 +466,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -487,1 +480,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -509,1 +502,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -523,1 +516,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -553,2 +546,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = ((ShortVector)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = ((ShortVector)o).vec();\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,3 +136,4 @@\n-    VectorShuffle(byte[] reorder) {\n-        super(reorder);\n-    }\n+    \/**\n+     * Default Constructor for abstract VectorShuffle.\n+     *\/\n+    public VectorShuffle() {}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShuffle.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -100,5 +100,0 @@\n-    \/*package-private*\/\n-    abstract $type$[] vec();\n-\n-    abstract VectorPayloadMF vec_mf();\n-\n@@ -109,1 +104,1 @@\n-     * It is an error if the array is aliased elsewhere.\n+     * It is an error if the vec is aliased elsewhere.\n@@ -112,2 +107,0 @@\n-    abstract $abstractvectortype$ vectorFactory($type$[] vec);\n-\n@@ -172,1 +165,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -196,1 +189,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -225,2 +218,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec();\n@@ -253,2 +246,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec();\n@@ -286,3 +279,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = (($abstractvectortype$)o1).vec_mf();\n-        VectorPayloadMF vec3 = (($abstractvectortype$)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o1).vec();\n+        VectorPayloadMF vec3 = (($abstractvectortype$)o2).vec();\n@@ -318,3 +311,3 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = (($abstractvectortype$)o1).vec_mf();\n-        VectorPayloadMF vec3 = (($abstractvectortype$)o2).vec_mf();\n+        VectorPayloadMF vec1 = this.vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o1).vec();\n+        VectorPayloadMF vec3 = (($abstractvectortype$)o2).vec();\n@@ -348,1 +341,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = this.vec();\n@@ -363,1 +356,1 @@\n-        VectorPayloadMF vec = this.vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -477,1 +470,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -491,1 +484,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -513,1 +506,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -527,1 +520,1 @@\n-        VectorPayloadMF vec = vec_mf();\n+        VectorPayloadMF vec = vec();\n@@ -557,2 +550,2 @@\n-        VectorPayloadMF vec1 = this.vec_mf();\n-        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec_mf();\n+        VectorPayloadMF vec1 = vec();\n+        VectorPayloadMF vec2 = (($abstractvectortype$)o).vec();\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -63,5 +63,1 @@\n-        this.payload = (VectorPayloadMF$bits$$Boxinitials$)value;\n-    }\n-\n-    VectorPayloadMF vec_mf() {\n-        return payload;\n+        this.payload = (VectorPayloadMF$bits$$Boxinitials$) value;\n@@ -70,0 +66,1 @@\n+    @ForceInline\n@@ -71,2 +68,2 @@\n-    protected final Object getPayload() {\n-       return vec_mf();\n+    final VectorPayloadMF vec() {\n+        return payload;\n@@ -125,9 +122,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final @Override\n-    $type$[] vec() {\n-        return ($type$[])getPayload();\n-    }\n-\n-    \/\/ Virtualized constructors\n-\n@@ -171,1 +159,1 @@\n-    $shuffletype$ shuffleFromBytes(byte[] reorder) { return new $shuffletype$(reorder); }\n+    $shuffletype$ shuffleFromBytes(VectorPayloadMF reorder) { return new $shuffletype$(reorder); }\n@@ -181,7 +169,0 @@\n-    \/\/ Make a vector of the same species but the given elements:\n-    @ForceInline\n-    final @Override\n-    $vectortype$ vectorFactory($type$[] vec) {\n-        return new $vectortype$(vec);\n-    }\n-\n@@ -582,1 +563,1 @@\n-                         VectorPayloadMF vecpayload = vec.vec_mf();\n+                         VectorPayloadMF vecpayload = vec.vec();\n@@ -632,1 +613,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -737,1 +718,1 @@\n-                                 VectorPayloadMF vecpayload = vec.vec_mf();\n+                                 VectorPayloadMF vecpayload = vec.vec();\n@@ -839,1 +820,1 @@\n-                                    VectorPayloadMF vec = v.vec_mf();\n+                                    VectorPayloadMF vec = v.vec();\n@@ -879,5 +860,0 @@\n-        final @Override\n-        VectorPayloadMF getBits() {\n-            return payload;\n-        }\n-\n@@ -885,2 +861,2 @@\n-        protected final Object getPayload() {\n-            return getBits();\n+        final VectorPayloadMF getBits() {\n+            return payload;\n@@ -1017,1 +993,1 @@\n-            VectorPayloadMF newObj = VectorSupport.VectorPayloadMF.newInstanceFactory(boolean.class, VLENGTH);\n+            VectorPayloadMF newObj = VectorPayloadMF.newInstanceFactory(boolean.class, VLENGTH);\n@@ -1036,1 +1012,1 @@\n-    static final class $shuffletype$ extends AbstractShuffle<$Boxtype$> {\n+    static final value class $shuffletype$ extends AbstractShuffle<$Boxtype$> {\n@@ -1040,2 +1016,6 @@\n-        $shuffletype$(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        private final VectorPayloadMF$vectorsizeinbytes$B payload;\n+\n+        $shuffletype$(VectorPayloadMF reorder) {\n+            this.payload = (VectorPayloadMF$vectorsizeinbytes$B) reorder;\n+            assert(VLENGTH == reorder.length());\n+            assert(indexesInRange(reorder));\n@@ -1045,1 +1025,1 @@\n-            super(VLENGTH, reorder);\n+            this(reorder, 0);\n@@ -1049,1 +1029,1 @@\n-            super(VLENGTH, reorder, i);\n+            this(prepare(VLENGTH, reorder, i));\n@@ -1053,1 +1033,7 @@\n-            super(VLENGTH, fn);\n+            this(prepare(VLENGTH, fn));\n+        }\n+\n+        @ForceInline\n+        @Override\n+        protected final VectorPayloadMF reorder() {\n+            return payload;\n@@ -1090,6 +1076,9 @@\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            VectorPayloadMF reorder1 = reorder();\n+            VectorPayloadMF reorder2 = s.reorder();\n+            VectorPayloadMF r = VectorPayloadMF.newInstanceFactory(byte.class, VLENGTH);\n+            r = Unsafe.getUnsafe().makePrivateBuffer(r);\n+            long offset = r.multiFieldOffset();\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int ssi = Unsafe.getUnsafe().getByte(reorder2, offset + i * Byte.BYTES);\n+                int si = Unsafe.getUnsafe().getByte(reorder1, offset + ssi * Byte.BYTES);\n+                Unsafe.getUnsafe().putByte(r, offset + i * Byte.BYTES, (byte) si);\n@@ -1097,0 +1086,1 @@\n+            r = Unsafe.getUnsafe().finishPrivateBuffer(r);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":38,"deletions":48,"binary":false,"changes":86,"status":"modified"}]}