{"files":[{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -2069,1 +2070,1 @@\n-  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedIndyEntry)\n@@ -2074,0 +2075,16 @@\n+\n+void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get index out of bytecode pointer\n+  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n+  \/\/ Take shortcut if the size is a power of 2\n+  if (is_power_of_2(sizeof(ResolvedFieldEntry))) {\n+    lsl(index, index, log2i_exact(sizeof(ResolvedFieldEntry))); \/\/ Scale index by power of 2\n+  } else {\n+    mov(cache, sizeof(ResolvedFieldEntry));\n+    mul(index, index, cache); \/\/ Scale the index to be the entry index * sizeof(ResolvedFieldEntry)\n+  }\n+  \/\/ Get address of field entries array\n+  ldr(cache, Address(rcpool, ConstantPoolCache::field_entries_offset()));\n+  add(cache, cache, Array<ResolvedFieldEntry>::base_offset_in_bytes());\n+  lea(cache, Address(cache, index));\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -349,0 +349,1 @@\n+  void load_field_entry(Register cache, Register index, int bcp_offset = 1);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -1740,1 +1741,1 @@\n-  tbnz(flags, ConstantPoolCacheEntry::is_null_free_inline_type_shift, is_null_free_inline_type);\n+  tbnz(flags, ResolvedFieldEntry::is_null_free_inline_type_shift, is_null_free_inline_type);\n@@ -1745,1 +1746,1 @@\n-  tbz(flags, ConstantPoolCacheEntry::is_null_free_inline_type_shift, not_null_free_inline_type);\n+  tbz(flags, ResolvedFieldEntry::is_null_free_inline_type_shift, not_null_free_inline_type);\n@@ -1750,1 +1751,1 @@\n-  tbnz(flags, ConstantPoolCacheEntry::is_flat_shift, is_flat);\n+  tbnz(flags, ResolvedFieldEntry::is_flat_shift, is_flat);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -191,1 +192,8 @@\n-      __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);\n+      __ load_field_entry(temp_reg, bc_reg);\n+      if (byte_no == f1_byte) {\n+        __ lea(temp_reg, Address(temp_reg, in_bytes(ResolvedFieldEntry::get_code_offset())));\n+      } else {\n+        __ lea(temp_reg, Address(temp_reg, in_bytes(ResolvedFieldEntry::put_code_offset())));\n+      }\n+      \/\/ Load-acquire the bytecode to match store-release in ResolvedFieldEntry::fill_in()\n+      __ ldarb(temp_reg, temp_reg);\n@@ -2377,5 +2385,0 @@\n-  switch (code) {\n-  case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n-  case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n-  default: break;\n-  }\n@@ -2409,0 +2412,63 @@\n+void TemplateTable::resolve_cache_and_index_for_field(int byte_no,\n+                                            Register Rcache,\n+                                            Register index) {\n+  const Register temp = r19;\n+  assert_different_registers(Rcache, index, temp);\n+\n+  Label resolved;\n+\n+  Bytecodes::Code code = bytecode();\n+  switch (code) {\n+  case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n+  case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n+  default: break;\n+  }\n+\n+  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n+  __ load_field_entry(Rcache, index);\n+  if (byte_no == f1_byte) {\n+    __ lea(temp, Address(Rcache, in_bytes(ResolvedFieldEntry::get_code_offset())));\n+  } else {\n+    __ lea(temp, Address(Rcache, in_bytes(ResolvedFieldEntry::put_code_offset())));\n+  }\n+  \/\/ Load-acquire the bytecode to match store-release in ResolvedFieldEntry::fill_in()\n+  __ ldarb(temp, temp);\n+  __ subs(zr, temp, (int) code);  \/\/ have we resolved this bytecode?\n+  __ br(Assembler::EQ, resolved);\n+\n+  \/\/ resolve first time through\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ mov(temp, (int) code);\n+  __ call_VM(noreg, entry, temp);\n+\n+  \/\/ Update registers with resolved info\n+  __ load_field_entry(Rcache, index);\n+  __ bind(resolved);\n+}\n+\n+void TemplateTable::load_resolved_field_entry(Register obj,\n+                                              Register cache,\n+                                              Register tos_state,\n+                                              Register offset,\n+                                              Register flags,\n+                                              bool is_static = false) {\n+  assert_different_registers(cache, tos_state, flags, offset);\n+\n+  \/\/ Field offset\n+  __ load_sized_value(offset, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n+\n+  \/\/ Flags\n+  __ load_unsigned_byte(flags, Address(cache, in_bytes(ResolvedFieldEntry::flags_offset())));\n+\n+  \/\/ TOS state\n+  __ load_unsigned_byte(tos_state, Address(cache, in_bytes(ResolvedFieldEntry::type_offset())));\n+\n+  \/\/ Klass overwrite register\n+  if (is_static) {\n+    __ ldr(obj, Address(cache, ResolvedFieldEntry::field_holder_offset()));\n+    const int mirror_offset = in_bytes(Klass::java_mirror_offset());\n+    __ ldr(obj, Address(obj, mirror_offset));\n+    __ resolve_oop_handle(obj, r5, rscratch2);\n+  }\n+}\n+\n@@ -2560,2 +2626,1 @@\n-    __ get_cache_and_index_at_bcp(c_rarg2, c_rarg3, 1);\n-    __ lea(c_rarg2, Address(c_rarg2, in_bytes(ConstantPoolCache::base_offset())));\n+    __ load_field_entry(c_rarg2, index);\n@@ -2571,1 +2636,0 @@\n-    \/\/ c_rarg3: jvalue object on the stack\n@@ -2574,2 +2638,2 @@\n-               c_rarg1, c_rarg2, c_rarg3);\n-    __ get_cache_and_index_at_bcp(cache, index, 1);\n+               c_rarg1, c_rarg2);\n+    __ load_field_entry(cache, index);\n@@ -2589,4 +2653,3 @@\n-  const Register cache = r2;\n-  const Register index = r3;\n-  const Register obj   = r4;\n-  const Register klass = r5;\n+  const Register cache     = r2;\n+  const Register obj       = r4;\n+  const Register klass     = r5;\n@@ -2594,6 +2657,8 @@\n-  const Register off   = r19;\n-  const Register flags = r0;\n-  const Register raw_flags = r6;\n-  const Register bc    = r4; \/\/ uses same reg as obj, so don't mix them\n-\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+  const Register field_index = r23;\n+  const Register index     = r3;\n+  const Register tos_state = r3;\n+  const Register off       = r19;\n+  const Register flags     = r6;\n+  const Register bc        = r4; \/\/ uses same reg as obj, so don't mix them\n+\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -2601,1 +2666,6 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, raw_flags, is_static);\n+\n+  \/\/ Valhalla extras\n+  __ load_unsigned_short(field_index, Address(cache, in_bytes(ResolvedFieldEntry::field_index_offset())));\n+  __ ldr(klass, Address(cache, ResolvedFieldEntry::field_holder_offset()));\n+\n+  load_resolved_field_entry(obj, cache, tos_state, off, flags, is_static);\n@@ -2616,1 +2686,1 @@\n-    __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ tbz(flags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n@@ -2626,10 +2696,1 @@\n-  if (!is_static) {\n-    __ ldr(klass, Address(cache, in_bytes(ConstantPoolCache::base_offset() +\n-                                          ConstantPoolCacheEntry::f1_offset())));\n-  }\n-\n-  \/\/ x86 uses a shift and mask or wings it with a shift plus assert\n-  \/\/ the mask is not needed. aarch64 just uses bitfield extract\n-  __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift, ConstantPoolCacheEntry::tos_state_bits);\n-\n-  __ cbnz(flags, notByte);\n+  __ cbnz(tos_state, notByte);\n@@ -2651,1 +2712,1 @@\n-  __ cmp(flags, (u1)ztos);\n+  __ cmp(tos_state, (u1)ztos);\n@@ -2665,1 +2726,1 @@\n-  __ cmp(flags, (u1)atos);\n+  __ cmp(tos_state, (u1)atos);\n@@ -2680,1 +2741,1 @@\n-      __ test_field_is_null_free_inline_type(raw_flags, noreg \/*temp*\/, is_null_free_inline_type);\n+      __ test_field_is_null_free_inline_type(flags, noreg \/*temp*\/, is_null_free_inline_type);\n@@ -2690,1 +2751,0 @@\n-          __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);\n@@ -2692,1 +2752,1 @@\n-          __ ldrb(rscratch1, Address(cache, InstanceKlass::init_state_offset()));\n+          __ ldrb(rscratch1, Address(klass, InstanceKlass::init_state_offset()));\n@@ -2698,1 +2758,1 @@\n-          __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field), obj, raw_flags);\n+          __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_inline_type_field), obj, cache);\n@@ -2705,1 +2765,1 @@\n-      __ test_field_is_null_free_inline_type(raw_flags, noreg \/*temp*\/, is_inline_type);\n+      __ test_field_is_null_free_inline_type(flags, noreg \/*temp*\/, is_inline_type);\n@@ -2714,1 +2774,1 @@\n-        __ test_field_is_flat(raw_flags, noreg \/* temp *\/, is_flat);\n+        __ test_field_is_flat(flags, noreg \/* temp *\/, is_flat);\n@@ -2718,2 +2778,1 @@\n-            __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);\n-            __ get_inline_type_field_klass(klass, raw_flags, inline_klass);\n+            __ get_inline_type_field_klass(klass, field_index, inline_klass);\n@@ -2727,1 +2786,0 @@\n-          __ andw(raw_flags, raw_flags, ConstantPoolCacheEntry::field_index_mask);\n@@ -2729,1 +2787,1 @@\n-          __ read_flat_field(klass, raw_flags, off, inline_klass \/* temp *\/, r0);\n+          __ read_flat_field(klass, field_index, off, inline_klass \/* temp *\/, r0);\n@@ -2741,1 +2799,1 @@\n-  __ cmp(flags, (u1)itos);\n+  __ cmp(tos_state, (u1)itos);\n@@ -2753,1 +2811,1 @@\n-  __ cmp(flags, (u1)ctos);\n+  __ cmp(tos_state, (u1)ctos);\n@@ -2765,1 +2823,1 @@\n-  __ cmp(flags, (u1)stos);\n+  __ cmp(tos_state, (u1)stos);\n@@ -2777,1 +2835,1 @@\n-  __ cmp(flags, (u1)ltos);\n+  __ cmp(tos_state, (u1)ltos);\n@@ -2789,1 +2847,1 @@\n-  __ cmp(flags, (u1)ftos);\n+  __ cmp(tos_state, (u1)ftos);\n@@ -2802,1 +2860,1 @@\n-  __ cmp(flags, (u1)dtos);\n+  __ cmp(tos_state, (u1)dtos);\n@@ -2822,1 +2880,1 @@\n-  __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+  __ tbz(flags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n@@ -2847,2 +2905,0 @@\n-  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n-\n@@ -2858,1 +2914,1 @@\n-    __ get_cache_and_index_at_bcp(c_rarg2, rscratch1, 1);\n+    __ mov(c_rarg2, cache);\n@@ -2868,6 +2924,1 @@\n-      __ ldrw(c_rarg3, Address(c_rarg2,\n-                               in_bytes(cp_base_offset +\n-                                        ConstantPoolCacheEntry::flags_offset())));\n-      __ lsr(c_rarg3, c_rarg3,\n-             ConstantPoolCacheEntry::tos_state_shift);\n-      ConstantPoolCacheEntry::verify_tos_state_shift();\n+      __ load_unsigned_byte(c_rarg3, Address(c_rarg2, in_bytes(ResolvedFieldEntry::type_offset())));\n@@ -2884,2 +2935,0 @@\n-    \/\/ cache entry pointer\n-    __ add(c_rarg2, c_rarg2, in_bytes(cp_base_offset));\n@@ -2895,1 +2944,1 @@\n-    __ get_cache_and_index_at_bcp(cache, index, 1);\n+    __ load_field_entry(cache, index);\n@@ -2903,7 +2952,7 @@\n-  const Register cache = r2;\n-  const Register index = r3;\n-  const Register obj   = r2;\n-  const Register off   = r19;\n-  const Register flags = r0;\n-  const Register flags2 = r6;\n-  const Register bc    = r4;\n+  const Register cache     = r2;\n+  const Register index     = r3;\n+  const Register tos_state = r3;\n+  const Register obj       = r2;\n+  const Register off       = r19;\n+  const Register flags     = r6;\n+  const Register bc        = r4;\n@@ -2912,1 +2961,1 @@\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -2914,1 +2963,1 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+  load_resolved_field_entry(obj, cache, tos_state, off, flags, is_static);\n@@ -2917,2 +2966,0 @@\n-  __ mov(r5, flags);\n-\n@@ -2921,1 +2968,1 @@\n-    __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ tbz(flags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n@@ -2932,7 +2979,1 @@\n-  __ mov(flags2, flags);\n-\n-  \/\/ x86 uses a shift and mask or wings it with a shift plus assert\n-  \/\/ the mask is not needed. aarch64 just uses bitfield extract\n-  __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);\n-\n-  __ cbnz(flags, notByte);\n+  __ cbnz(tos_state, notByte);\n@@ -2956,1 +2997,1 @@\n-  __ cmp(flags, (u1)ztos);\n+  __ cmp(tos_state, (u1)ztos);\n@@ -2971,1 +3012,1 @@\n-  __ cmp(flags, (u1)atos);\n+  __ cmp(tos_state, (u1)atos);\n@@ -2989,1 +3030,1 @@\n-         __ test_field_is_not_null_free_inline_type(flags2, noreg \/* temp *\/, is_inline_type);\n+         __ test_field_is_not_null_free_inline_type(flags, noreg \/* temp *\/, is_inline_type);\n@@ -2996,1 +3037,1 @@\n-        __ test_field_is_null_free_inline_type(flags2, noreg \/*temp*\/, is_inline_type);\n+        __ test_field_is_null_free_inline_type(flags, noreg \/*temp*\/, is_inline_type);\n@@ -3009,1 +3050,1 @@\n-        __ test_field_is_flat(flags2, noreg \/*temp*\/, is_flat);\n+        __ test_field_is_flat(flags, noreg \/*temp*\/, is_flat);\n@@ -3033,1 +3074,1 @@\n-  __ cmp(flags, (u1)itos);\n+  __ cmp(tos_state, (u1)itos);\n@@ -3048,1 +3089,1 @@\n-  __ cmp(flags, (u1)ctos);\n+  __ cmp(tos_state, (u1)ctos);\n@@ -3063,1 +3104,1 @@\n-  __ cmp(flags, (u1)stos);\n+  __ cmp(tos_state, (u1)stos);\n@@ -3078,1 +3119,1 @@\n-  __ cmp(flags, (u1)ltos);\n+  __ cmp(tos_state, (u1)ltos);\n@@ -3093,1 +3134,1 @@\n-  __ cmp(flags, (u1)ftos);\n+  __ cmp(tos_state, (u1)ftos);\n@@ -3109,1 +3150,1 @@\n-  __ cmp(flags, (u1)dtos);\n+  __ cmp(tos_state, (u1)dtos);\n@@ -3134,1 +3175,1 @@\n-    __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ tbz(flags, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n@@ -3153,2 +3194,1 @@\n-void TemplateTable::jvmti_post_fast_field_mod()\n-{\n+void TemplateTable::jvmti_post_fast_field_mod() {\n@@ -3185,1 +3225,1 @@\n-    __ get_cache_entry_pointer_at_bcp(c_rarg2, r0, 1);\n+    __ load_field_entry(c_rarg2, r0);\n@@ -3221,1 +3261,5 @@\n-  __ get_cache_and_index_at_bcp(r2, r1, 1);\n+  __ load_field_entry(r2, r1);\n+  __ push(r0);\n+  \/\/ R1: field offset, R2: TOS, R3: flags\n+  load_resolved_field_entry(r2, r2, r0, r1, r3);\n+  __ pop(r0);\n@@ -3226,7 +3270,0 @@\n-  \/\/ test for volatile with r3\n-  __ ldrw(r3, Address(r2, in_bytes(base +\n-                                   ConstantPoolCacheEntry::flags_offset())));\n-\n-  \/\/ replace index with field offset from cache entry\n-  __ ldr(r1, Address(r2, in_bytes(base + ConstantPoolCacheEntry::f2_offset())));\n-\n@@ -3235,1 +3272,1 @@\n-    __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ tbz(r3, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n@@ -3300,1 +3337,1 @@\n-    __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ tbz(r3, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n@@ -3319,1 +3356,1 @@\n-    __ get_cache_entry_pointer_at_bcp(c_rarg2, rscratch2, 1);\n+    __ load_field_entry(c_rarg2, rscratch2);\n@@ -3334,1 +3371,1 @@\n-  __ get_cache_and_index_at_bcp(r2, r1, 1);\n+  __ load_field_entry(r2, r1);\n@@ -3339,4 +3376,2 @@\n-  __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n-                                  ConstantPoolCacheEntry::f2_offset())));\n-  __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n-                                   ConstantPoolCacheEntry::flags_offset())));\n+  __ load_sized_value(r1, Address(r2, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n+  __ load_unsigned_byte(r3, Address(r2, in_bytes(ResolvedFieldEntry::flags_offset())));\n@@ -3357,1 +3392,1 @@\n-    __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ tbz(r3, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n@@ -3372,3 +3407,2 @@\n-          __ andw(index, r3, ConstantPoolCacheEntry::field_index_mask);\n-          __ ldr(klass, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n-                                             ConstantPoolCacheEntry::f1_offset())));\n+          __ load_unsigned_short(index, Address(r2, in_bytes(ResolvedFieldEntry::field_index_offset())));\n+          __ ldr(klass, Address(r2, in_bytes(ResolvedFieldEntry::field_holder_offset())));\n@@ -3382,3 +3416,2 @@\n-        __ andw(index, r3, ConstantPoolCacheEntry::field_index_mask);\n-        __ ldr(klass, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n-                                           ConstantPoolCacheEntry::f1_offset())));\n+        __ load_unsigned_short(index, Address(r2, in_bytes(ResolvedFieldEntry::field_index_offset())));\n+        __ ldr(klass, Address(r2, in_bytes(ResolvedFieldEntry::field_holder_offset())));\n@@ -3420,1 +3453,1 @@\n-    __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ tbz(r3, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n@@ -3433,3 +3466,2 @@\n-  __ get_cache_and_index_at_bcp(r2, r3, 2);\n-  __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n-                                  ConstantPoolCacheEntry::f2_offset())));\n+  __ load_field_entry(r2, r3, 2);\n+  __ load_sized_value(r1, Address(r2, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n@@ -3445,3 +3477,2 @@\n-    __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n-                                     ConstantPoolCacheEntry::flags_offset())));\n-    __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ load_unsigned_byte(r3, Address(r2, in_bytes(ResolvedFieldEntry::flags_offset())));\n+    __ tbz(r3, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n@@ -3473,3 +3504,2 @@\n-    __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n-                                     ConstantPoolCacheEntry::flags_offset())));\n-    __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ load_unsigned_byte(r3, Address(r2, in_bytes(ResolvedFieldEntry::flags_offset())));\n+    __ tbz(r3, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n@@ -3877,6 +3907,0 @@\n-  resolve_cache_and_index(f2_byte, c_rarg1 \/*cache*\/, c_rarg2 \/*index*\/, sizeof(u2));\n-\n-  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n-\n-  \/\/ n.b. unlike x86 cache is now rcpool plus the indexed offset\n-  __ lea(c_rarg1, Address(c_rarg1, in_bytes(cp_base_offset)));\n@@ -3884,0 +3908,1 @@\n+  resolve_cache_and_index_for_field(f2_byte, c_rarg1 \/*cache*\/, c_rarg2 \/*index*\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":162,"deletions":137,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -490,1 +491,1 @@\n-  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedIndyEntry)\n@@ -495,0 +496,17 @@\n+void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get index out of bytecode pointer\n+  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n+  \/\/ Take shortcut if the size is a power of 2\n+  if (is_power_of_2(sizeof(ResolvedFieldEntry))) {\n+    \/\/ Scale index by power of 2\n+    sldi(index, index, log2i_exact(sizeof(ResolvedFieldEntry)));\n+  } else {\n+    \/\/ Scale the index to be the entry index * sizeof(ResolvedFieldEntry)\n+    mulli(index, index, sizeof(ResolvedFieldEntry));\n+  }\n+  \/\/ Get address of field entries array\n+  ld_ptr(cache, in_bytes(ConstantPoolCache::field_entries_offset()), R27_constPoolCache);\n+  addi(cache, cache, Array<ResolvedFieldEntry>::base_offset_in_bytes());\n+  add(cache, cache, index);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -2351,1 +2352,1 @@\n-    imull(index, index, sizeof(ResolvedIndyEntry)); \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+    imull(index, index, sizeof(ResolvedIndyEntry)); \/\/ Scale the index to be the entry index * sizeof(ResolvedIndyEntry)\n@@ -2355,0 +2356,15 @@\n+\n+void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get index out of bytecode pointer\n+  movptr(cache, Address(rbp, frame::interpreter_frame_cache_offset * wordSize));\n+  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n+\n+  movptr(cache, Address(cache, ConstantPoolCache::field_entries_offset()));\n+  \/\/ Take shortcut if the size is a power of 2\n+  if (is_power_of_2(sizeof(ResolvedFieldEntry))) {\n+    shll(index, log2i_exact(sizeof(ResolvedFieldEntry))); \/\/ Scale index by power of 2\n+  } else {\n+    imull(index, index, sizeof(ResolvedFieldEntry)); \/\/ Scale the index to be the entry index * sizeof(ResolvedFieldEntry)\n+  }\n+  lea(cache, Address(cache, index, Address::times_1, Array<ResolvedFieldEntry>::base_offset_in_bytes()));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-\n+  void load_field_entry(Register cache, Register index, int bcp_offset = 1);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -2904,1 +2905,1 @@\n-  shrl(temp_reg, ConstantPoolCacheEntry::is_null_free_inline_type_shift);\n+  shrl(temp_reg, ResolvedFieldEntry::is_null_free_inline_type_shift);\n@@ -2912,1 +2913,1 @@\n-  shrl(temp_reg, ConstantPoolCacheEntry::is_null_free_inline_type_shift);\n+  shrl(temp_reg, ResolvedFieldEntry::is_null_free_inline_type_shift);\n@@ -2920,1 +2921,1 @@\n-  shrl(temp_reg, ConstantPoolCacheEntry::is_flat_shift);\n+  shrl(temp_reg, ResolvedFieldEntry::is_flat_shift);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -202,1 +203,7 @@\n-      __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);\n+      __ load_field_entry(temp_reg, bc_reg);\n+      if (byte_no == f1_byte) {\n+        __ load_unsigned_byte(temp_reg, Address(temp_reg, in_bytes(ResolvedFieldEntry::get_code_offset())));\n+      } else {\n+        __ load_unsigned_byte(temp_reg, Address(temp_reg, in_bytes(ResolvedFieldEntry::put_code_offset())));\n+      }\n+\n@@ -2782,5 +2789,0 @@\n-  switch (code) {\n-  case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n-  case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n-  default: break;\n-  }\n@@ -2817,0 +2819,62 @@\n+void TemplateTable::resolve_cache_and_index_for_field(int byte_no,\n+                                            Register cache,\n+                                            Register index) {\n+  const Register temp = rbx;\n+  assert_different_registers(cache, index, temp);\n+\n+  Label resolved;\n+\n+  Bytecodes::Code code = bytecode();\n+  switch (code) {\n+    case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n+    case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n+    default: break;\n+  }\n+\n+  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n+  __ load_field_entry(cache, index);\n+  if (byte_no == f1_byte) {\n+    __ load_unsigned_byte(temp, Address(cache, in_bytes(ResolvedFieldEntry::get_code_offset())));\n+  } else {\n+    __ load_unsigned_byte(temp, Address(cache, in_bytes(ResolvedFieldEntry::put_code_offset())));\n+  }\n+  __ cmpl(temp, code);  \/\/ have we resolved this bytecode?\n+  __ jcc(Assembler::equal, resolved);\n+\n+  \/\/ resolve first time through\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ movl(temp, code);\n+  __ call_VM(noreg, entry, temp);\n+  \/\/ Update registers with resolved info\n+  __ load_field_entry(cache, index);\n+\n+  __ bind(resolved);\n+}\n+\n+void TemplateTable::load_resolved_field_entry(Register obj,\n+                                              Register cache,\n+                                              Register tos_state,\n+                                              Register offset,\n+                                              Register flags,\n+                                              bool is_static = false) {\n+  assert_different_registers(cache, tos_state, flags, offset);\n+\n+  \/\/ Field offset\n+  __ load_sized_value(offset, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n+\n+  \/\/ Flags\n+  __ load_unsigned_byte(flags, Address(cache, in_bytes(ResolvedFieldEntry::flags_offset())));\n+\n+  \/\/ TOS state\n+  __ load_unsigned_byte(tos_state, Address(cache, in_bytes(ResolvedFieldEntry::type_offset())));\n+\n+  \/\/ Klass overwrite register\n+  if (is_static) {\n+    __ movptr(obj, Address(cache, ResolvedFieldEntry::field_holder_offset()));\n+    const int mirror_offset = in_bytes(Klass::java_mirror_offset());\n+    __ movptr(obj, Address(obj, mirror_offset));\n+    __ resolve_oop_handle(obj, rscratch2);\n+  }\n+\n+}\n+\n@@ -2964,3 +3028,1 @@\n-    __ addptr(cache, in_bytes(ConstantPoolCache::base_offset()));\n-    __ shll(index, LogBytesPerWord);\n-    __ addptr(cache, index);\n+    __ load_field_entry(cache, index);\n@@ -2977,2 +3039,3 @@\n-               rax, cache);\n-    __ get_cache_and_index_at_bcp(cache, index, 1);\n+              rax, cache);\n+\n+    __ load_field_entry(cache, index);\n@@ -2992,0 +3055,1 @@\n+  const Register obj   = LP64_ONLY(r9) NOT_LP64(rcx);\n@@ -2994,2 +3058,2 @@\n-  const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n-  const Register flags = rax;\n+  const Register tos_state   = rax;\n+  const Register flags = rdx;\n@@ -2998,2 +3062,1 @@\n-  const Register flags2 = rdx;\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -3002,1 +3065,1 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+  load_resolved_field_entry(obj, cache, tos_state, off, flags, is_static);\n@@ -3008,9 +3071,0 @@\n-  if (!is_static) {\n-    __ movptr(rcx, Address(cache, index, Address::times_ptr,\n-                           in_bytes(ConstantPoolCache::base_offset() +\n-                                    ConstantPoolCacheEntry::f1_offset())));\n-  }\n-\n-  __ movl(flags2, flags);\n-\n-  __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);\n@@ -3019,3 +3073,1 @@\n-\n-  __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);\n-\n+  __ testl(tos_state, tos_state);\n@@ -3023,0 +3075,1 @@\n+\n@@ -3034,2 +3087,1 @@\n-\n-  __ cmpl(flags, ztos);\n+  __ cmpl(tos_state, ztos);\n@@ -3049,1 +3101,1 @@\n-  __ cmpl(flags, atos);\n+  __ cmpl(tos_state, atos);\n@@ -3065,1 +3117,1 @@\n-      __ test_field_is_null_free_inline_type(flags2, rscratch1, is_null_free_inline_type);\n+      __ test_field_is_null_free_inline_type(flags, rscratch1, is_null_free_inline_type);\n@@ -3076,1 +3128,0 @@\n-          __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n@@ -3087,1 +3138,1 @@\n-                obj, flags2);\n+                obj, cache);\n@@ -3096,1 +3147,1 @@\n-      __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+      __ test_field_is_null_free_inline_type(flags, rscratch1, is_inline_type);\n@@ -3106,1 +3157,1 @@\n-        __ test_field_is_flat(flags2, rscratch1, is_flat);\n+      __ test_field_is_flat(flags, rscratch1, is_flat);\n@@ -3108,1 +3159,0 @@\n-          __ movptr(rax, rcx);  \/\/ small dance required to preserve the klass_holder somewhere\n@@ -3110,1 +3160,0 @@\n-          __ push(rax);\n@@ -3112,1 +3161,0 @@\n-          __ pop(rcx);\n@@ -3115,2 +3163,3 @@\n-            __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n-            __ get_inline_type_field_klass(rcx, flags2, rbx);\n+            __ load_unsigned_short(flags, Address(cache, in_bytes(ResolvedFieldEntry::field_index_offset())));\n+            __ movptr(rcx, Address(cache, ResolvedFieldEntry::field_holder_offset()));\n+            __ get_inline_type_field_klass(rcx, flags, rbx);\n@@ -3123,2 +3172,0 @@\n-        \/\/ field is flat\n-          __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);\n@@ -3126,1 +3173,3 @@\n-          __ read_flat_field(rcx, flags2, rbx, rax);\n+          __ load_unsigned_short(flags, Address(cache, in_bytes(ResolvedFieldEntry::field_index_offset())));\n+          __ movptr(rcx, Address(cache, ResolvedFieldEntry::field_holder_offset()));\n+          __ read_flat_field(rcx, flags, rbx, rax);\n@@ -3141,1 +3190,1 @@\n-  __ cmpl(flags, itos);\n+  __ cmpl(tos_state, itos);\n@@ -3153,1 +3202,1 @@\n-  __ cmpl(flags, ctos);\n+  __ cmpl(tos_state, ctos);\n@@ -3165,1 +3214,1 @@\n-  __ cmpl(flags, stos);\n+  __ cmpl(tos_state, stos);\n@@ -3177,1 +3226,1 @@\n-  __ cmpl(flags, ltos);\n+  __ cmpl(tos_state, ltos);\n@@ -3189,1 +3238,1 @@\n-  __ cmpl(flags, ftos);\n+  __ cmpl(tos_state, ftos);\n@@ -3204,1 +3253,1 @@\n-  __ cmpl(flags, dtos);\n+  __ cmpl(tos_state, dtos);\n@@ -3247,0 +3296,1 @@\n+  __ load_field_entry(cache, index);\n@@ -3248,6 +3298,0 @@\n-  Register cpentry = rbx;\n-\n-  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n-\n-  __ lea(cpentry, Address(cache, index, Address::times_ptr,\n-                         in_bytes(cp_base_offset)));\n@@ -3255,1 +3299,1 @@\n-  __ call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), cpentry, rax);\n+  __ call_VM(rbx, CAST_FROM_FN_PTR(address, InterpreterRuntime::withfield), cache, rax);\n@@ -3266,7 +3310,4 @@\n-\n-  const Register robj = LP64_ONLY(c_rarg2)   NOT_LP64(rax);\n-  const Register RBX  = LP64_ONLY(c_rarg1)   NOT_LP64(rbx);\n-  const Register RCX  = LP64_ONLY(c_rarg3)   NOT_LP64(rcx);\n-  const Register RDX  = LP64_ONLY(rscratch1) NOT_LP64(rdx);\n-\n-  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n+  \/\/ Cache is rcx and index is rdx\n+  const Register entry = LP64_ONLY(c_rarg2) NOT_LP64(rax); \/\/ ResolvedFieldEntry\n+  const Register obj = LP64_ONLY(c_rarg1) NOT_LP64(rbx);   \/\/ Object pointer\n+  const Register value = LP64_ONLY(c_rarg3) NOT_LP64(rcx); \/\/ JValue object\n@@ -3278,1 +3319,1 @@\n-    assert_different_registers(cache, index, rax);\n+    assert_different_registers(cache, obj, rax);\n@@ -3283,2 +3324,1 @@\n-    __ get_cache_and_index_at_bcp(robj, RDX, 1);\n-\n+    __ mov(entry, cache);\n@@ -3288,1 +3328,1 @@\n-      __ xorl(RBX, RBX);\n+      __ xorl(obj, obj);\n@@ -3298,9 +3338,1 @@\n-      __ movl(RCX, Address(robj, RDX,\n-                           Address::times_ptr,\n-                           in_bytes(cp_base_offset +\n-                                     ConstantPoolCacheEntry::flags_offset())));\n-      NOT_LP64(__ mov(rbx, rsp));\n-      __ shrl(RCX, ConstantPoolCacheEntry::tos_state_shift);\n-\n-      \/\/ Make sure we don't need to mask rcx after the above shift\n-      ConstantPoolCacheEntry::verify_tos_state_shift();\n+      __ load_unsigned_byte(value, Address(entry, in_bytes(ResolvedFieldEntry::type_offset())));\n@@ -3308,2 +3340,2 @@\n-      __ movptr(c_rarg1, at_tos_p1());  \/\/ initially assume a one word jvalue\n-      __ cmpl(c_rarg3, ltos);\n+      __ movptr(obj, at_tos_p1());  \/\/ initially assume a one word jvalue\n+      __ cmpl(value, ltos);\n@@ -3311,2 +3343,2 @@\n-                 c_rarg1, at_tos_p2()); \/\/ ltos (two word jvalue)\n-      __ cmpl(c_rarg3, dtos);\n+                 obj, at_tos_p2()); \/\/ ltos (two word jvalue)\n+      __ cmpl(value, dtos);\n@@ -3314,1 +3346,1 @@\n-                 c_rarg1, at_tos_p2()); \/\/ dtos (two word jvalue)\n+                 obj, at_tos_p2()); \/\/ dtos (two word jvalue)\n@@ -3316,1 +3348,2 @@\n-      __ cmpl(rcx, ltos);\n+      __ mov(obj, rsp);\n+      __ cmpl(value, ltos);\n@@ -3318,1 +3351,1 @@\n-      __ cmpl(rcx, dtos);\n+      __ cmpl(value, dtos);\n@@ -3320,1 +3353,1 @@\n-      __ addptr(rbx, Interpreter::expr_offset_in_bytes(1)); \/\/ one word jvalue (not ltos, dtos)\n+      __ addptr(obj, Interpreter::expr_offset_in_bytes(1)); \/\/ one word jvalue (not ltos, dtos)\n@@ -3324,1 +3357,1 @@\n-      __ addptr(rbx, Interpreter::expr_offset_in_bytes(2)); \/\/ two words jvalue\n+      __ addptr(obj, Interpreter::expr_offset_in_bytes(2)); \/\/ two words jvalue\n@@ -3328,1 +3361,1 @@\n-      __ movptr(rbx, Address(rbx, 0));\n+      __ movptr(obj, Address(obj, 0));\n@@ -3331,4 +3364,1 @@\n-    \/\/ cache entry pointer\n-    __ addptr(robj, in_bytes(cp_base_offset));\n-    __ shll(RDX, LogBytesPerWord);\n-    __ addptr(robj, RDX);\n+\n@@ -3336,4 +3366,4 @@\n-    __ mov(RCX, rsp);\n-    \/\/ c_rarg1: object pointer set up above (null if static)\n-    \/\/ c_rarg2: cache entry pointer\n-    \/\/ c_rarg3: jvalue object on the stack\n+    __ mov(value, rsp);\n+    \/\/ obj: object pointer set up above (null if static)\n+    \/\/ cache: field entry pointer\n+    \/\/ value: jvalue object on the stack\n@@ -3341,4 +3371,5 @@\n-               CAST_FROM_FN_PTR(address,\n-                                InterpreterRuntime::post_field_modification),\n-               RBX, robj, RCX);\n-    __ get_cache_and_index_at_bcp(cache, index, 1);\n+              CAST_FROM_FN_PTR(address,\n+                              InterpreterRuntime::post_field_modification),\n+              obj, entry, value);\n+    \/\/ Reload field entry\n+    __ load_field_entry(cache, index);\n@@ -3352,0 +3383,1 @@\n+  const Register obj = rcx;\n@@ -3354,1 +3386,1 @@\n-  const Register obj   = rcx;\n+  const Register tos_state   = rdx;\n@@ -3356,2 +3388,1 @@\n-  const Register flags = rax;\n-  const Register flags2 = rdx;\n+  const Register flags = r9;\n@@ -3359,1 +3390,1 @@\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -3361,1 +3392,1 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+  load_resolved_field_entry(obj, cache, tos_state, off, flags, is_static);\n@@ -3368,3 +3399,0 @@\n-  __ movl(rdx, flags);\n-  __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);\n-  __ andl(rdx, 0x1);\n@@ -3373,2 +3401,3 @@\n-  __ testl(rdx, rdx);\n-  __ movl(flags2, flags);\n+  __ movl(rscratch1, flags);\n+  __ andl(rscratch1, (1 << ResolvedFieldEntry::is_volatile_shift));\n+  __ testl(rscratch1, rscratch1);\n@@ -3377,1 +3406,1 @@\n-  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);\n+  putfield_or_static_helper(byte_no, is_static, rc, obj, off, tos_state, flags);\n@@ -3383,1 +3412,1 @@\n-  putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags, flags2);\n+  putfield_or_static_helper(byte_no, is_static, rc, obj, off, tos_state, flags);\n@@ -3389,1 +3418,1 @@\n-                                              Register obj, Register off, Register flags, Register flags2) {\n+                                              Register obj, Register off, Register tos_state, Register flags) {\n@@ -3401,4 +3430,2 @@\n-  __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);\n-\n-  assert(btos == 0, \"change code, btos != 0\");\n-  __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);\n+  \/\/ Test TOS state\n+  __ testl(tos_state, tos_state);\n@@ -3419,1 +3446,1 @@\n-  __ cmpl(flags, ztos);\n+  __ cmpl(tos_state, ztos);\n@@ -3434,1 +3461,1 @@\n-  __ cmpl(flags, atos);\n+  __ cmpl(tos_state, atos);\n@@ -3452,1 +3479,1 @@\n-        __ test_field_is_not_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+        __ test_field_is_not_null_free_inline_type(flags, rscratch1, is_inline_type);\n@@ -3459,1 +3486,1 @@\n-        __ test_field_is_null_free_inline_type(flags2, rscratch1, is_inline_type);\n+        __ test_field_is_null_free_inline_type(flags, rscratch1, is_inline_type);\n@@ -3472,1 +3499,1 @@\n-        __ test_field_is_flat(flags2, rscratch1, is_flat);\n+        __ test_field_is_flat(flags, rscratch1, is_flat);\n@@ -3496,1 +3523,1 @@\n-  __ cmpl(flags, itos);\n+  __ cmpl(tos_state, itos);\n@@ -3511,1 +3538,1 @@\n-  __ cmpl(flags, ctos);\n+  __ cmpl(tos_state, ctos);\n@@ -3526,1 +3553,1 @@\n-  __ cmpl(flags, stos);\n+  __ cmpl(tos_state, stos);\n@@ -3541,1 +3568,1 @@\n-  __ cmpl(flags, ltos);\n+  __ cmpl(tos_state, ltos);\n@@ -3559,1 +3586,1 @@\n-  __ cmpl(flags, ftos);\n+  __ cmpl(tos_state, ftos);\n@@ -3576,1 +3603,1 @@\n-  __ cmpl(flags, dtos);\n+  __ cmpl(tos_state, dtos);\n@@ -3647,2 +3674,2 @@\n-    LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rax, 1));\n-    NOT_LP64(__ get_cache_entry_pointer_at_bcp(rax, rdx, 1));\n+    LP64_ONLY(__ load_field_entry(c_rarg2, rax));\n+    NOT_LP64(__ load_field_entry(rax, rdx));\n@@ -3676,19 +3703,1 @@\n-  ByteSize base = ConstantPoolCache::base_offset();\n-\n-  jvmti_post_fast_field_mod();\n-\n-  \/\/ access constant pool cache\n-  __ get_cache_and_index_at_bcp(rcx, rbx, 1);\n-\n-  \/\/ test for volatile with rdx but rdx is tos register for lputfield.\n-  __ movl(rdx, Address(rcx, rbx, Address::times_ptr,\n-                       in_bytes(base +\n-                                ConstantPoolCacheEntry::flags_offset())));\n-\n-  \/\/ replace index with field offset from cache entry\n-  __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,\n-                         in_bytes(base + ConstantPoolCacheEntry::f2_offset())));\n-\n-  \/\/ [jk] not needed currently\n-  \/\/ volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |\n-  \/\/                                              Assembler::StoreStore));\n+  Register cache = rcx;\n@@ -3697,5 +3706,9 @@\n-  if (bytecode() == Bytecodes::_fast_qputfield) {\n-    __ movl(rscratch2, rdx);  \/\/ saving flags for is_flat test\n-  }\n-  __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);\n-  __ andl(rdx, 0x1);\n+  jvmti_post_fast_field_mod();\n+\n+  __ push(rax);\n+  __ load_field_entry(rcx, rax);\n+  load_resolved_field_entry(noreg, cache, rax, rbx, rdx);\n+  \/\/ RBX: field offset, RCX: RAX: TOS, RDX: flags\n+  __ movl(rscratch2, rdx);  \/\/ saving flags for is_flat test\n+  __ andl(rscratch2, (1 << ResolvedFieldEntry::is_volatile_shift));\n+  __ pop(rax);\n@@ -3711,1 +3724,1 @@\n-  __ testl(rdx, rdx);\n+  __ testl(rscratch2, rscratch2);\n@@ -3714,3 +3727,0 @@\n-  if (bytecode() == Bytecodes::_fast_qputfield) {\n-    __ movl(rdx, rscratch2);  \/\/ restoring flags for is_flat test\n-  }\n@@ -3723,3 +3733,0 @@\n-  if (bytecode() == Bytecodes::_fast_qputfield) {\n-    __ movl(rdx, rscratch2);  \/\/ restoring flags for is_flat test\n-  }\n@@ -3802,2 +3809,2 @@\n-    LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rcx, 1));\n-    NOT_LP64(__ get_cache_entry_pointer_at_bcp(rcx, rdx, 1));\n+    LP64_ONLY(__ load_field_entry(c_rarg2, rcx));\n+    NOT_LP64(__ load_field_entry(rcx, rdx));\n@@ -3816,12 +3823,2 @@\n-  __ get_cache_and_index_at_bcp(rcx, rbx, 1);\n-  \/\/ replace index with field offset from cache entry\n-  \/\/ [jk] not needed currently\n-  \/\/ __ movl(rdx, Address(rcx, rbx, Address::times_8,\n-  \/\/                      in_bytes(ConstantPoolCache::base_offset() +\n-  \/\/                               ConstantPoolCacheEntry::flags_offset())));\n-  \/\/ __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);\n-  \/\/ __ andl(rdx, 0x1);\n-  \/\/\n-  __ movptr(rdx, Address(rcx, rbx, Address::times_ptr,\n-                         in_bytes(ConstantPoolCache::base_offset() +\n-                                  ConstantPoolCacheEntry::f2_offset())));\n+  __ load_field_entry(rcx, rbx);\n+  __ load_sized_value(rdx, Address(rcx, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n@@ -3839,3 +3836,1 @@\n-      __ movptr(rscratch1, Address(rcx, rbx, Address::times_ptr,\n-                                   in_bytes(ConstantPoolCache::base_offset() +\n-                                            ConstantPoolCacheEntry::flags_offset())));\n+      __ load_unsigned_byte(rscratch1, Address(rcx, in_bytes(ResolvedFieldEntry::flags_offset())));\n@@ -3847,7 +3842,2 @@\n-          __ movl(rdx, Address(rcx, rbx, Address::times_ptr,\n-                             in_bytes(ConstantPoolCache::base_offset() +\n-                                      ConstantPoolCacheEntry::flags_offset())));\n-          __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);\n-          __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,\n-                                       in_bytes(ConstantPoolCache::base_offset() +\n-                                                ConstantPoolCacheEntry::f1_offset())));\n+          __ load_unsigned_short(rdx, Address(rcx, in_bytes(ResolvedFieldEntry::field_index_offset())));\n+          __ movptr(rcx, Address(rcx, ResolvedFieldEntry::field_holder_offset()));\n@@ -3862,7 +3852,2 @@\n-        __ movl(rdx, Address(rcx, rbx, Address::times_ptr,\n-                           in_bytes(ConstantPoolCache::base_offset() +\n-                                    ConstantPoolCacheEntry::flags_offset())));\n-        __ andl(rdx, ConstantPoolCacheEntry::field_index_mask);\n-        __ movptr(rcx, Address(rcx, rbx, Address::times_ptr,\n-                                     in_bytes(ConstantPoolCache::base_offset() +\n-                                              ConstantPoolCacheEntry::f1_offset())));\n+        __ load_unsigned_short(rdx, Address(rcx, in_bytes(ResolvedFieldEntry::field_index_offset())));\n+        __ movptr(rcx, Address(rcx, ResolvedFieldEntry::field_holder_offset()));\n@@ -3921,5 +3906,3 @@\n-  __ get_cache_and_index_at_bcp(rcx, rdx, 2);\n-  __ movptr(rbx,\n-            Address(rcx, rdx, Address::times_ptr,\n-                    in_bytes(ConstantPoolCache::base_offset() +\n-                             ConstantPoolCacheEntry::f2_offset())));\n+  __ load_field_entry(rcx, rdx, 2);\n+  __ load_sized_value(rbx, Address(rcx, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":179,"deletions":196,"binary":false,"changes":375,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-                                        Register obj, Register off, Register flags, Register flags2);\n+                                        Register obj, Register off, Register tos_state, Register flags);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1014,2 +1014,2 @@\n-      int index = stream()->get_constant_pool_index();\n-      BasicType type = stream()->get_basic_type_for_constant_at(index);\n+      int cp_index = stream()->get_constant_pool_index();\n+      BasicType type = stream()->get_basic_type_for_constant_at(cp_index);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1010,2 +1010,2 @@\n-  \/\/ generic\n-  HASHING4(LoadIndexed, delayed() == nullptr && !should_profile(), type()->tag(), array()->subst(), index()->subst(), vt())\n+  \/\/ generic;\n+  HASHING4(LoadIndexed, delayed() == nullptr && !should_profile(), elt_type(), array()->subst(), index()->subst(), vt())\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"cds\/dynamicArchive.hpp\"\n@@ -92,1 +93,0 @@\n-bool MetaspaceShared::_has_error_classes;\n@@ -508,0 +508,3 @@\n+  \/\/ Initialize random for updating the hash of symbols\n+  os::init_random(0x12345678);\n+\n@@ -548,2 +551,0 @@\n-\n-  MetaspaceShared::exit_after_static_dump();\n@@ -666,4 +667,7 @@\n-  } else {\n-    \/\/ On success, the VM_PopulateDumpSharedSpace op should have\n-    \/\/ exited the VM.\n-    ShouldNotReachHere();\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  \/\/ Restore the java loaders that were cleared at dump time\n+  if (use_full_module_graph()) {\n+    HeapShared::restore_loader_data();\n+  }\n+#endif\n@@ -736,1 +740,0 @@\n-  _has_error_classes = false;\n@@ -799,1 +802,1 @@\n-  if (ik->is_loaded() && !ik->is_linked() && ik->can_be_verified_at_dumptime() &&\n+  if (!ik->is_shared() && ik->is_loaded() && !ik->is_linked() && ik->can_be_verified_at_dumptime() &&\n@@ -819,1 +822,0 @@\n-      _has_error_classes = true;\n@@ -878,0 +880,8 @@\n+bool MetaspaceShared::is_shared_static(void* p) {\n+  if (is_in_shared_metaspace(p) && !is_shared_dynamic(p)) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -901,8 +911,0 @@\n-\/\/ We have finished dumping the static archive. At this point, there may be pending VM\n-\/\/ operations. We have changed some global states (such as vmClasses::_klasses) that\n-\/\/ may cause these VM operations to fail. For safety, forget these operations and\n-\/\/ exit the VM directly.\n-void MetaspaceShared::exit_after_static_dump() {\n-  os::_exit(0);\n-}\n-\n@@ -1474,2 +1476,2 @@\n-    SymbolTable::serialize_shared_table_header(&rc, false);\n-    SystemDictionaryShared::serialize_dictionary_headers(&rc, false);\n+    ArchiveBuilder::serialize_dynamic_archivable_items(&rc);\n+    DynamicArchive::setup_array_klasses();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -281,1 +281,1 @@\n-constantTag ciBytecodeStream::get_constant_pool_tag(int index) const {\n+constantTag ciBytecodeStream::get_constant_pool_tag(int cp_index) const {\n@@ -283,1 +283,1 @@\n-  return _method->get_Method()->constants()->constant_tag_at(index);\n+  return _method->get_Method()->constants()->constant_tag_at(cp_index);\n@@ -297,1 +297,1 @@\n-BasicType ciBytecodeStream::get_basic_type_for_constant_at(int index) const {\n+BasicType ciBytecodeStream::get_basic_type_for_constant_at(int cp_index) const {\n@@ -299,1 +299,1 @@\n-  return _method->get_Method()->constants()->basic_type_for_constant_at(index);\n+  return _method->get_Method()->constants()->basic_type_for_constant_at(cp_index);\n@@ -313,1 +313,1 @@\n-  return get_index_u2_cpcache();\n+  return get_index_u2();\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-  BasicType   get_basic_type_for_constant_at(int index) const;\n+  BasicType   get_basic_type_for_constant_at(int cp_index) const;\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -807,2 +807,2 @@\n-    int index = str->get_constant_pool_index();\n-    BasicType basic_type = str->get_basic_type_for_constant_at(index);\n+    int cp_index = str->get_constant_pool_index();\n+    BasicType basic_type = str->get_basic_type_for_constant_at(cp_index);\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-TypeOrigin TypeOrigin::local(u2 index, StackMapFrame* frame) {\n+TypeOrigin TypeOrigin::local(int index, StackMapFrame* frame) {\n@@ -353,1 +353,1 @@\n-TypeOrigin TypeOrigin::stack(u2 index, StackMapFrame* frame) {\n+TypeOrigin TypeOrigin::stack(int index, StackMapFrame* frame) {\n@@ -358,1 +358,1 @@\n-TypeOrigin TypeOrigin::sm_local(u2 index, StackMapFrame* frame) {\n+TypeOrigin TypeOrigin::sm_local(int index, StackMapFrame* frame) {\n@@ -363,1 +363,1 @@\n-TypeOrigin TypeOrigin::sm_stack(u2 index, StackMapFrame* frame) {\n+TypeOrigin TypeOrigin::sm_stack(int index, StackMapFrame* frame) {\n@@ -368,1 +368,1 @@\n-TypeOrigin TypeOrigin::bad_index(u2 index) {\n+TypeOrigin TypeOrigin::bad_index(int index) {\n@@ -371,1 +371,1 @@\n-TypeOrigin TypeOrigin::cp(u2 index, VerificationType vt) {\n+TypeOrigin TypeOrigin::cp(int index, VerificationType vt) {\n@@ -721,2 +721,2 @@\n-  int32_t max_stack = m->verifier_max_stack();\n-  int32_t max_locals = m->max_locals();\n+  u2 max_stack = m->verifier_max_stack();\n+  u2 max_locals = m->max_locals();\n@@ -734,1 +734,1 @@\n-  int32_t stackmap_index = 0; \/\/ index to the stackmap array\n+  u2 stackmap_index = 0; \/\/ index to the stackmap array\n@@ -781,1 +781,1 @@\n-    u2 bci = bcs.bci();\n+    int bci = bcs.bci();\n@@ -800,1 +800,0 @@\n-      u2 index;\n@@ -902,2 +901,2 @@\n-        case Bytecodes::_iload_3 :\n-          index = opcode - Bytecodes::_iload_0;\n+        case Bytecodes::_iload_3 : {\n+          int index = opcode - Bytecodes::_iload_0;\n@@ -906,0 +905,1 @@\n+          }\n@@ -912,2 +912,2 @@\n-        case Bytecodes::_lload_3 :\n-          index = opcode - Bytecodes::_lload_0;\n+        case Bytecodes::_lload_3 : {\n+          int index = opcode - Bytecodes::_lload_0;\n@@ -916,0 +916,1 @@\n+          }\n@@ -922,2 +923,2 @@\n-        case Bytecodes::_fload_3 :\n-          index = opcode - Bytecodes::_fload_0;\n+        case Bytecodes::_fload_3 : {\n+          int index = opcode - Bytecodes::_fload_0;\n@@ -926,0 +927,1 @@\n+          }\n@@ -932,2 +934,2 @@\n-        case Bytecodes::_dload_3 :\n-          index = opcode - Bytecodes::_dload_0;\n+        case Bytecodes::_dload_3 : {\n+          int index = opcode - Bytecodes::_dload_0;\n@@ -936,0 +938,1 @@\n+          }\n@@ -942,2 +945,2 @@\n-        case Bytecodes::_aload_3 :\n-          index = opcode - Bytecodes::_aload_0;\n+        case Bytecodes::_aload_3 : {\n+          int index = opcode - Bytecodes::_aload_0;\n@@ -946,0 +949,1 @@\n+          }\n@@ -1073,2 +1077,2 @@\n-        case Bytecodes::_istore_3 :\n-          index = opcode - Bytecodes::_istore_0;\n+        case Bytecodes::_istore_3 : {\n+          int index = opcode - Bytecodes::_istore_0;\n@@ -1077,0 +1081,1 @@\n+          }\n@@ -1083,2 +1088,2 @@\n-        case Bytecodes::_lstore_3 :\n-          index = opcode - Bytecodes::_lstore_0;\n+        case Bytecodes::_lstore_3 : {\n+          int index = opcode - Bytecodes::_lstore_0;\n@@ -1087,0 +1092,1 @@\n+          }\n@@ -1093,2 +1099,2 @@\n-        case Bytecodes::_fstore_3 :\n-          index = opcode - Bytecodes::_fstore_0;\n+        case Bytecodes::_fstore_3 : {\n+          int index = opcode - Bytecodes::_fstore_0;\n@@ -1097,0 +1103,1 @@\n+          }\n@@ -1103,2 +1110,2 @@\n-        case Bytecodes::_dstore_3 :\n-          index = opcode - Bytecodes::_dstore_0;\n+        case Bytecodes::_dstore_3 : {\n+          int index = opcode - Bytecodes::_dstore_0;\n@@ -1107,0 +1114,1 @@\n+          }\n@@ -1113,2 +1121,2 @@\n-        case Bytecodes::_astore_3 :\n-          index = opcode - Bytecodes::_astore_0;\n+        case Bytecodes::_astore_3 : {\n+          int index = opcode - Bytecodes::_astore_0;\n@@ -1117,0 +1125,1 @@\n+          }\n@@ -1734,1 +1743,1 @@\n-          index = bcs.get_index_u2();\n+          u2 index = bcs.get_index_u2();\n@@ -1744,1 +1753,1 @@\n-          type = VerificationType::uninitialized_type(bci);\n+          type = VerificationType::uninitialized_type(checked_cast<u2>(bci));\n@@ -1756,1 +1765,1 @@\n-          index = bcs.get_index_u2();\n+          u2 index = bcs.get_index_u2();\n@@ -1793,1 +1802,1 @@\n-          index = bcs.get_index_u2();\n+          u2 index = bcs.get_index_u2();\n@@ -1802,1 +1811,1 @@\n-          index = bcs.get_index_u2();\n+          u2 index = bcs.get_index_u2();\n@@ -1817,1 +1826,1 @@\n-          index = bcs.get_index_u2();\n+          u2 index = bcs.get_index_u2();\n@@ -1926,1 +1935,1 @@\n-    int catch_type_index = exhandlers.catch_type_index(i);\n+    u2 catch_type_index = exhandlers.catch_type_index(i);\n@@ -1979,1 +1988,1 @@\n-u2 ClassVerifier::verify_stackmap_table(u2 stackmap_index, u2 bci,\n+u2 ClassVerifier::verify_stackmap_table(u2 stackmap_index, int bci,\n@@ -1984,1 +1993,1 @@\n-    u2 this_offset = stackmap_table->get_offset(stackmap_index);\n+    int this_offset = stackmap_table->get_offset(stackmap_index);\n@@ -2019,1 +2028,1 @@\n-void ClassVerifier::verify_exception_handler_targets(u2 bci, bool this_uninit,\n+void ClassVerifier::verify_exception_handler_targets(int bci, bool this_uninit,\n@@ -2058,1 +2067,1 @@\n-    u2 bci, const constantPoolHandle& cp, int index, TRAPS) {\n+    int bci, const constantPoolHandle& cp, u2 index, TRAPS) {\n@@ -2069,1 +2078,1 @@\n-    u2 bci, int index, const constantPoolHandle& cp, unsigned int types, TRAPS) {\n+    int bci, u2 index, const constantPoolHandle& cp, unsigned int types, TRAPS) {\n@@ -2089,1 +2098,1 @@\n-    u2 bci, int index, const constantPoolHandle& cp, TRAPS) {\n+    int bci, u2 index, const constantPoolHandle& cp, TRAPS) {\n@@ -2187,1 +2196,1 @@\n-    const constantPoolHandle& cp, u2 bci, TRAPS) {\n+    const constantPoolHandle& cp, int bci, TRAPS) {\n@@ -2391,1 +2400,1 @@\n-  u2 bci = bcs->bci();\n+  int bci = bcs->bci();\n@@ -2521,1 +2530,1 @@\n-  u4 code_length = method()->code_size();\n+  int code_length = method()->code_size();\n@@ -2523,1 +2532,1 @@\n-  u4 target;\n+\n@@ -2540,1 +2549,1 @@\n-      if ((bci_stack->is_empty()) || ((u4)bcs.end_bci() == code_length))\n+      if ((bci_stack->is_empty()) || (bcs.end_bci() == code_length))\n@@ -2546,1 +2555,1 @@\n-    u4 bci = bcs.bci();\n+    int bci = bcs.bci();\n@@ -2568,2 +2577,2 @@\n-      case Bytecodes::_ifnonnull:\n-        target = bcs.dest();\n+      case Bytecodes::_ifnonnull: {\n+        int target = bcs.dest();\n@@ -2599,0 +2608,1 @@\n+        }\n@@ -2601,2 +2611,2 @@\n-      case Bytecodes::_goto_w:\n-        target = (opcode == Bytecodes::_goto ? bcs.dest() : bcs.dest_w());\n+      case Bytecodes::_goto_w: {\n+        int target = (opcode == Bytecodes::_goto ? bcs.dest() : bcs.dest_w());\n@@ -2623,0 +2633,1 @@\n+        }\n@@ -2637,1 +2648,1 @@\n-          u4 default_offset = Bytes::get_Java_u4(aligned_bcp) + bci;\n+          int default_offset = Bytes::get_Java_u4(aligned_bcp) + bci;\n@@ -2659,1 +2670,1 @@\n-            u4 target = bci + (jint)Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);\n+            int target = bci + (jint)Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);\n@@ -2702,1 +2713,1 @@\n-  u2 bci = bcs->bci();\n+  int bci = bcs->bci();\n@@ -2907,1 +2918,1 @@\n-  u2 bci = bcs->bci();\n+  int bci = bcs->bci();\n@@ -3059,1 +3070,1 @@\n-    u2 index, u2 bci, TRAPS) {\n+    u2 index, int bci, TRAPS) {\n@@ -3074,1 +3085,1 @@\n-    u2 bci, u2 index, const constantPoolHandle& cp,\n+    int bci, u2 index, const constantPoolHandle& cp,\n@@ -3115,1 +3126,1 @@\n-void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {\n+void ClassVerifier::verify_iload(int index, StackMapFrame* current_frame, TRAPS) {\n@@ -3122,1 +3133,1 @@\n-void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {\n+void ClassVerifier::verify_lload(int index, StackMapFrame* current_frame, TRAPS) {\n@@ -3131,1 +3142,1 @@\n-void ClassVerifier::verify_fload(u2 index, StackMapFrame* current_frame, TRAPS) {\n+void ClassVerifier::verify_fload(int index, StackMapFrame* current_frame, TRAPS) {\n@@ -3138,1 +3149,1 @@\n-void ClassVerifier::verify_dload(u2 index, StackMapFrame* current_frame, TRAPS) {\n+void ClassVerifier::verify_dload(int index, StackMapFrame* current_frame, TRAPS) {\n@@ -3147,1 +3158,1 @@\n-void ClassVerifier::verify_aload(u2 index, StackMapFrame* current_frame, TRAPS) {\n+void ClassVerifier::verify_aload(int index, StackMapFrame* current_frame, TRAPS) {\n@@ -3153,1 +3164,1 @@\n-void ClassVerifier::verify_istore(u2 index, StackMapFrame* current_frame, TRAPS) {\n+void ClassVerifier::verify_istore(int index, StackMapFrame* current_frame, TRAPS) {\n@@ -3160,1 +3171,1 @@\n-void ClassVerifier::verify_lstore(u2 index, StackMapFrame* current_frame, TRAPS) {\n+void ClassVerifier::verify_lstore(int index, StackMapFrame* current_frame, TRAPS) {\n@@ -3169,1 +3180,1 @@\n-void ClassVerifier::verify_fstore(u2 index, StackMapFrame* current_frame, TRAPS) {\n+void ClassVerifier::verify_fstore(int index, StackMapFrame* current_frame, TRAPS) {\n@@ -3175,1 +3186,1 @@\n-void ClassVerifier::verify_dstore(u2 index, StackMapFrame* current_frame, TRAPS) {\n+void ClassVerifier::verify_dstore(int index, StackMapFrame* current_frame, TRAPS) {\n@@ -3184,1 +3195,1 @@\n-void ClassVerifier::verify_astore(u2 index, StackMapFrame* current_frame, TRAPS) {\n+void ClassVerifier::verify_astore(int index, StackMapFrame* current_frame, TRAPS) {\n@@ -3190,1 +3201,1 @@\n-void ClassVerifier::verify_iinc(u2 index, StackMapFrame* current_frame, TRAPS) {\n+void ClassVerifier::verify_iinc(int index, StackMapFrame* current_frame, TRAPS) {\n@@ -3197,1 +3208,1 @@\n-    VerificationType return_type, VerificationType type, u2 bci,\n+    VerificationType return_type, VerificationType type, int bci,\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":83,"deletions":72,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-  u2 _index;              \/\/ local, stack, or constant pool index\n+  int _index;              \/\/ local, stack, or constant pool index\n@@ -115,1 +115,1 @@\n-      Origin origin, u2 index, StackMapFrame* frame, VerificationType type)\n+      Origin origin, int index, StackMapFrame* frame, VerificationType type)\n@@ -122,5 +122,5 @@\n-  static TypeOrigin local(u2 index, StackMapFrame* frame);\n-  static TypeOrigin stack(u2 index, StackMapFrame* frame);\n-  static TypeOrigin sm_local(u2 index, StackMapFrame* frame);\n-  static TypeOrigin sm_stack(u2 index, StackMapFrame* frame);\n-  static TypeOrigin cp(u2 index, VerificationType vt);\n+  static TypeOrigin local(int index, StackMapFrame* frame);\n+  static TypeOrigin stack(int index, StackMapFrame* frame);\n+  static TypeOrigin sm_local(int index, StackMapFrame* frame);\n+  static TypeOrigin sm_stack(int index, StackMapFrame* frame);\n+  static TypeOrigin cp(int index, VerificationType vt);\n@@ -128,1 +128,1 @@\n-  static TypeOrigin bad_index(u2 index);\n+  static TypeOrigin bad_index(int index);\n@@ -137,1 +137,1 @@\n-  u2 index() const { return _index; }\n+  int index() const { return _index; }\n@@ -178,1 +178,1 @@\n-  static ErrorContext bad_code(u2 bci) {\n+  static ErrorContext bad_code(int bci) {\n@@ -181,1 +181,1 @@\n-  static ErrorContext bad_type(u2 bci, TypeOrigin type) {\n+  static ErrorContext bad_type(int bci, TypeOrigin type) {\n@@ -184,1 +184,1 @@\n-  static ErrorContext bad_type(u2 bci, TypeOrigin type, TypeOrigin exp) {\n+  static ErrorContext bad_type(int bci, TypeOrigin type, TypeOrigin exp) {\n@@ -187,1 +187,1 @@\n-  static ErrorContext bad_flags(u2 bci, StackMapFrame* frame) {\n+  static ErrorContext bad_flags(int bci, StackMapFrame* frame) {\n@@ -190,1 +190,1 @@\n-  static ErrorContext bad_flags(u2 bci, StackMapFrame* cur, StackMapFrame* sm) {\n+  static ErrorContext bad_flags(int bci, StackMapFrame* cur, StackMapFrame* sm) {\n@@ -194,1 +194,1 @@\n-  static ErrorContext bad_cp_index(u2 bci, u2 index) {\n+  static ErrorContext bad_cp_index(int bci, int index) {\n@@ -197,1 +197,1 @@\n-  static ErrorContext bad_local_index(u2 bci, u2 index) {\n+  static ErrorContext bad_local_index(int bci, int index) {\n@@ -201,1 +201,1 @@\n-      u2 bci, StackMapFrame* frame0, StackMapFrame* frame1) {\n+      int bci, StackMapFrame* frame0, StackMapFrame* frame1) {\n@@ -206,1 +206,1 @@\n-      u2 bci, StackMapFrame* frame0, StackMapFrame* frame1) {\n+      int bci, StackMapFrame* frame0, StackMapFrame* frame1) {\n@@ -210,1 +210,1 @@\n-  static ErrorContext stack_overflow(u2 bci, StackMapFrame* frame) {\n+  static ErrorContext stack_overflow(int bci, StackMapFrame* frame) {\n@@ -213,1 +213,1 @@\n-  static ErrorContext stack_underflow(u2 bci, StackMapFrame* frame) {\n+  static ErrorContext stack_underflow(int bci, StackMapFrame* frame) {\n@@ -216,1 +216,1 @@\n-  static ErrorContext missing_stackmap(u2 bci) {\n+  static ErrorContext missing_stackmap(int bci) {\n@@ -222,1 +222,1 @@\n-  static ErrorContext bad_inline_type(u2 bci, TypeOrigin type, TypeOrigin exp) {\n+  static ErrorContext bad_inline_type(int bci, TypeOrigin type, TypeOrigin exp) {\n@@ -311,2 +311,2 @@\n-  void verify_cp_index(u2 bci, const constantPoolHandle& cp, int index, TRAPS);\n-  void verify_cp_type(u2 bci, int index, const constantPoolHandle& cp,\n+  void verify_cp_index(int bci, const constantPoolHandle& cp, u2 index, TRAPS);\n+  void verify_cp_type(int bci, u2 index, const constantPoolHandle& cp,\n@@ -314,1 +314,1 @@\n-  void verify_cp_class_type(u2 bci, int index, const constantPoolHandle& cp, TRAPS);\n+  void verify_cp_class_type(int bci, u2 index, const constantPoolHandle& cp, TRAPS);\n@@ -317,1 +317,1 @@\n-    u2 stackmap_index, u2 bci, StackMapFrame* current_frame,\n+    u2 stackmap_index, int bci, StackMapFrame* current_frame,\n@@ -321,1 +321,1 @@\n-    u2 bci, bool this_uninit, StackMapFrame* current_frame,\n+    int bci, bool this_uninit, StackMapFrame* current_frame,\n@@ -326,1 +326,1 @@\n-    const constantPoolHandle& cp, u2 bci, TRAPS);\n+    const constantPoolHandle& cp, int bci, TRAPS);\n@@ -358,2 +358,2 @@\n-  VerificationType get_newarray_type(u2 index, u2 bci, TRAPS);\n-  void verify_anewarray(u2 bci, u2 index, const constantPoolHandle& cp,\n+  VerificationType get_newarray_type(u2 index, int bci, TRAPS);\n+  void verify_anewarray(int bci, u2 index, const constantPoolHandle& cp,\n@@ -362,1 +362,1 @@\n-      VerificationType return_type, VerificationType type, u2 offset,\n+      VerificationType return_type, VerificationType type, int bci,\n@@ -365,11 +365,11 @@\n-  void verify_iload (u2 index, StackMapFrame* current_frame, TRAPS);\n-  void verify_lload (u2 index, StackMapFrame* current_frame, TRAPS);\n-  void verify_fload (u2 index, StackMapFrame* current_frame, TRAPS);\n-  void verify_dload (u2 index, StackMapFrame* current_frame, TRAPS);\n-  void verify_aload (u2 index, StackMapFrame* current_frame, TRAPS);\n-  void verify_istore(u2 index, StackMapFrame* current_frame, TRAPS);\n-  void verify_lstore(u2 index, StackMapFrame* current_frame, TRAPS);\n-  void verify_fstore(u2 index, StackMapFrame* current_frame, TRAPS);\n-  void verify_dstore(u2 index, StackMapFrame* current_frame, TRAPS);\n-  void verify_astore(u2 index, StackMapFrame* current_frame, TRAPS);\n-  void verify_iinc  (u2 index, StackMapFrame* current_frame, TRAPS);\n+  void verify_iload (int index, StackMapFrame* current_frame, TRAPS);\n+  void verify_lload (int index, StackMapFrame* current_frame, TRAPS);\n+  void verify_fload (int index, StackMapFrame* current_frame, TRAPS);\n+  void verify_dload (int index, StackMapFrame* current_frame, TRAPS);\n+  void verify_aload (int index, StackMapFrame* current_frame, TRAPS);\n+  void verify_istore(int index, StackMapFrame* current_frame, TRAPS);\n+  void verify_lstore(int index, StackMapFrame* current_frame, TRAPS);\n+  void verify_fstore(int index, StackMapFrame* current_frame, TRAPS);\n+  void verify_dstore(int index, StackMapFrame* current_frame, TRAPS);\n+  void verify_astore(int index, StackMapFrame* current_frame, TRAPS);\n+  void verify_iinc  (int index, StackMapFrame* current_frame, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":42,"deletions":42,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/tribool.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-  jint selector = sv_selector->get_int();\n+  jint selector = sv_selector->get_jint();\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  int get_index_u1(Bytecodes::Code bc) const {\n+  u1 get_index_u1(Bytecodes::Code bc) const {\n@@ -76,1 +76,1 @@\n-    return *(jubyte*)addr_at(1);\n+    return *(u1*)addr_at(1);\n@@ -78,1 +78,1 @@\n-  int get_index_u2(Bytecodes::Code bc, bool is_wide = false) const {\n+  u2 get_index_u2(Bytecodes::Code bc, bool is_wide = false) const {\n@@ -89,1 +89,1 @@\n-    return *(jubyte*)addr_at(1) + ConstantPool::CPCACHE_INDEX_TAG;\n+    return *(u1*)addr_at(1) + ConstantPool::CPCACHE_INDEX_TAG;\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -505,2 +506,2 @@\n-          int cpcache_index = get_native_index_u2();\n-          cp_index = cpcache()->entry_at(cpcache_index)->constant_pool_index();\n+          int field_index = get_native_index_u2();\n+          cp_index = cpcache()->resolved_field_entry_at(field_index)->constant_pool_index();\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -971,1 +971,1 @@\n-      int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);\n+      int cp_index = Bytes::get_native_u2(code_base + pos);\n@@ -986,1 +986,1 @@\n-      int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);\n+      int cp_index = Bytes::get_native_u2(code_base + pos);\n@@ -1138,1 +1138,1 @@\n-        int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);\n+        int cp_index = Bytes::get_native_u2(code_base + pos);\n@@ -1338,1 +1338,1 @@\n-      int cp_index = Bytes::get_native_u2(code_base + pos) + ConstantPool::CPCACHE_INDEX_TAG;\n+      int cp_index = Bytes::get_native_u2(code_base + pos);\n@@ -1349,1 +1349,1 @@\n-      int cp_index = Bytes::get_native_u2(code_base + pos) + ConstantPool::CPCACHE_INDEX_TAG;\n+      int cp_index = Bytes::get_native_u2(code_base + pos);\n@@ -1426,1 +1426,1 @@\n-        int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);\n+        int cp_index = Bytes::get_native_u2(code_base + pos);\n@@ -1435,1 +1435,1 @@\n-        int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);\n+        int cp_index = Bytes::get_native_u2(code_base + pos);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -428,0 +429,3 @@\n+  static bool        is_field_code  (Code code)    {\n+    return (_getstatic <= java_code(code) && java_code(code) <= _putfield) || (EnableValhalla && java_code(code) == _withfield);\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-#include \"oops\/constantPool.hpp\"\n+#include \"oops\/constantPool.inline.hpp\"\n@@ -159,2 +159,2 @@\n-  int index = wide ? last_frame.get_index_u2(Bytecodes::_ldc_w) : last_frame.get_index_u1(Bytecodes::_ldc);\n-  constantTag tag = pool->tag_at(index);\n+  int cp_index = wide ? last_frame.get_index_u2(Bytecodes::_ldc_w) : last_frame.get_index_u1(Bytecodes::_ldc);\n+  constantTag tag = pool->tag_at(cp_index);\n@@ -163,1 +163,1 @@\n-  Klass* klass = pool->klass_at(index, CHECK);\n+  Klass* klass = pool->klass_at(cp_index, CHECK);\n@@ -274,1 +274,1 @@\n-JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* current, ConstantPoolCacheEntry* cpe, uintptr_t ptr))\n+JRT_ENTRY(int, InterpreterRuntime::withfield(JavaThread* current, ResolvedFieldEntry* entry, uintptr_t ptr))\n@@ -276,1 +276,1 @@\n-  int recv_offset = type2size[as_BasicType(cpe->flag_state())];\n+  int recv_offset = type2size[as_BasicType((TosState)entry->tos_state())];\n@@ -279,1 +279,1 @@\n-  int offset = cpe->f2_as_offset();\n+  int offset = entry->field_offset();\n@@ -288,1 +288,1 @@\n-  if (cpe->flag_state() == atos) {\n+  if (entry->tos_state() == atos) {\n@@ -298,1 +298,1 @@\n-  switch(cpe->flag_state()) {\n+  switch(entry->tos_state()) {\n@@ -324,1 +324,1 @@\n-      if (!cpe->is_flat() && old_value_h()->obj_field(offset) == ref_h()) can_skip = true;\n+      if (!entry->is_flat() && old_value_h()->obj_field(offset) == ref_h()) can_skip = true;\n@@ -337,1 +337,1 @@\n-  switch(cpe->flag_state()) {\n+  switch(entry->tos_state()) {\n@@ -364,2 +364,2 @@\n-        if (cpe->is_null_free_inline_type())  {\n-          if (!cpe->is_flat()) {\n+        if (entry->is_null_free_inline_type())  {\n+          if (!entry->is_flat()) {\n@@ -371,1 +371,1 @@\n-            int field_index = cpe->field_index();\n+            int field_index = entry->field_index();\n@@ -387,1 +387,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_inline_type_field(JavaThread* current, oopDesc* mirror, int index))\n+JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_inline_type_field(JavaThread* current, oopDesc* mirror, ResolvedFieldEntry* entry))\n@@ -400,1 +400,3 @@\n-  InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));\n+  InstanceKlass* klass = entry->field_holder();\n+  u2 index = entry->field_index();\n+  assert(klass == java_lang_Class::as_Klass(mirror), \"Not the field holder klass\");\n@@ -922,0 +924,1 @@\n+  int field_index = last_frame.get_index_u2(bytecode);\n@@ -925,1 +928,1 @@\n-    LinkResolver::resolve_field_access(info, pool, last_frame.get_index_u2_cpcache(bytecode),\n+    LinkResolver::resolve_field_access(info, pool, field_index,\n@@ -930,2 +933,2 @@\n-  ConstantPoolCacheEntry* cp_cache_entry = last_frame.cache_entry();\n-  if (cp_cache_entry->is_resolved(bytecode)) return;\n+  if (pool->resolved_field_entry_at(field_index)->is_resolved(bytecode)) return;\n+\n@@ -977,12 +980,4 @@\n-  cp_cache_entry->set_field(\n-    get_code,\n-    put_code,\n-    info.field_holder(),\n-    info.index(),\n-    info.offset(),\n-    state,\n-    info.access_flags().is_final(),\n-    info.access_flags().is_volatile(),\n-    info.is_flat(),\n-    info.is_null_free_inline_type()\n-  );\n+  ResolvedFieldEntry* entry = pool->resolved_field_entry_at(field_index);\n+  entry->set_flags(info.access_flags().is_final(), info.access_flags().is_volatile(),\n+                   info.is_flat(), info.is_null_free_inline_type());\n+  entry->fill_in(info.field_holder(), info.offset(), (u2)info.index(), (u1)state, (u1)get_code, (u1)put_code);\n@@ -1432,1 +1427,1 @@\n-                                                      ConstantPoolCacheEntry *cp_entry))\n+                                                      ResolvedFieldEntry *entry))\n@@ -1436,2 +1431,2 @@\n-  InstanceKlass* ik = InstanceKlass::cast(cp_entry->f1_as_klass());\n-  int index = cp_entry->field_index();\n+  InstanceKlass* ik = entry->field_holder();\n+  int index = entry->field_index();\n@@ -1441,1 +1436,1 @@\n-  bool is_flat = cp_entry->is_flat();\n+  bool is_flat = entry->is_flat();\n@@ -1449,2 +1444,2 @@\n-  InstanceKlass* cp_entry_f1 = InstanceKlass::cast(cp_entry->f1_as_klass());\n-  jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry->f2_as_index(), is_static, is_flat);\n+  InstanceKlass* field_holder = entry->field_holder(); \/\/ HERE\n+  jfieldID fid = jfieldIDWorkaround::to_jfieldID(field_holder, entry->field_offset(), is_static, is_flat);\n@@ -1452,1 +1447,1 @@\n-  JvmtiExport::post_field_access(current, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);\n+  JvmtiExport::post_field_access(current, last_frame.method(), last_frame.bcp(), field_holder, h_obj, fid);\n@@ -1456,1 +1451,1 @@\n-                                                            ConstantPoolCacheEntry *cp_entry, jvalue *value))\n+                                                            ResolvedFieldEntry *entry, jvalue *value))\n@@ -1458,1 +1453,1 @@\n-  Klass* k = cp_entry->f1_as_klass();\n+  InstanceKlass* ik = entry->field_holder();\n@@ -1461,2 +1456,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  int index = cp_entry->field_index();\n+  int index = entry->field_index();\n@@ -1468,1 +1462,1 @@\n-  switch(cp_entry->flag_state()) {\n+  switch((TosState)entry->tos_state()) {\n@@ -1483,1 +1477,1 @@\n-  if (cp_entry->flag_state() == atos && ik->field_is_null_free_inline_type(index)) {\n+  if (entry->tos_state() == atos && ik->field_is_null_free_inline_type(index)) {\n@@ -1488,1 +1482,1 @@\n-  bool is_flat = cp_entry->is_flat();\n+  bool is_flat = entry->is_flat();\n@@ -1491,1 +1485,1 @@\n-  jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry->f2_as_index(), is_static, is_flat);\n+  jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, entry->field_offset(), is_static, is_flat);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":40,"deletions":46,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,2 +65,2 @@\n-  static int     withfield     (JavaThread* current, ConstantPoolCacheEntry* cpe, uintptr_t ptr);\n-  static void    uninitialized_static_inline_type_field(JavaThread* current, oopDesc* mirror, int offset);\n+  static int     withfield     (JavaThread* current, ResolvedFieldEntry* entry, uintptr_t ptr);\n+  static void    uninitialized_static_inline_type_field(JavaThread* current, oopDesc* mirror, ResolvedFieldEntry* entry);\n@@ -134,1 +134,1 @@\n-    ConstantPoolCacheEntry *cp_entry);\n+    ResolvedFieldEntry* entry);\n@@ -136,1 +136,1 @@\n-    ConstantPoolCacheEntry *cp_entry, jvalue *value);\n+    ResolvedFieldEntry* entry, jvalue *value);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -52,3 +53,7 @@\n-      case JVM_CONSTANT_InterfaceMethodref:\n-      case JVM_CONSTANT_Fieldref          : \/\/ fall through\n-      case JVM_CONSTANT_Methodref         : \/\/ fall through\n+      case JVM_CONSTANT_Fieldref          :\n+        _cp_map.at_put(i, _field_entry_index);\n+        _field_entry_index++;\n+        _initialized_field_entries.push(ResolvedFieldEntry((u2)i));\n+        break;\n+      case JVM_CONSTANT_InterfaceMethodref: \/\/ fall through\n+      case JVM_CONSTANT_Methodref         :\n@@ -103,1 +108,1 @@\n-                                  _invokedynamic_references_map, _initialized_indy_entries, CHECK);\n+                                  _invokedynamic_references_map, _initialized_indy_entries, _initialized_field_entries, CHECK);\n@@ -178,0 +183,13 @@\n+void Rewriter::rewrite_field_reference(address bcp, int offset, bool reverse) {\n+  address p = bcp + offset;\n+  if (!reverse) {\n+    int cp_index = Bytes::get_Java_u2(p);\n+    int field_entry_index = _cp_map.at(cp_index);\n+    Bytes::put_native_u2(p, field_entry_index);\n+  } else {\n+    int field_entry_index = Bytes::get_native_u2(p);\n+    int pool_index = _initialized_field_entries.at(field_entry_index).constant_pool_index();\n+    Bytes::put_Java_u2(p, pool_index);\n+  }\n+}\n+\n@@ -448,1 +466,3 @@\n-      case Bytecodes::_withfield     : \/\/ fall through but may require more checks for correctness\n+      case Bytecodes::_withfield      : \/\/ fall through but may require more checks for correctness\n+        rewrite_field_reference(bcp, prefix_length+1, reverse);\n+        break;\n@@ -564,1 +584,2 @@\n-    _invokedynamic_index(0)\n+    _invokedynamic_index(0),\n+    _field_entry_index(0)\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -269,0 +269,3 @@\n+  static void resolve_cache_and_index_for_field(int byte_no,\n+                                                Register cache,\n+                                                Register index);\n@@ -270,0 +273,6 @@\n+  static void load_resolved_field_entry(Register obj,\n+                                        Register cache,\n+                                        Register tos_state,\n+                                        Register off,\n+                                        Register flags,\n+                                        bool is_static);\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -399,1 +399,2 @@\n-    case REGISTER_OOP: {\n+    case REGISTER_OOP:\n+    case REGISTER_VECTOR: {\n@@ -425,0 +426,2 @@\n+        } else if (type == T_OBJECT && tag == REGISTER_VECTOR) {\n+          locationType = Location::vector;\n@@ -437,1 +440,2 @@\n-    case STACK_SLOT_OOP: {\n+    case STACK_SLOT_OOP:\n+    case STACK_SLOT_VECTOR: {\n@@ -444,1 +448,1 @@\n-        locationType = tag == STACK_SLOT_NARROW_OOP ? Location::narrowoop : Location::oop;\n+        locationType = tag == STACK_SLOT_VECTOR ? Location::vector : tag == STACK_SLOT_NARROW_OOP ? Location::narrowoop : Location::oop;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -700,1 +700,1 @@\n-C2V_VMENTRY_NULL(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+C2V_VMENTRY_NULL(jobject, lookupConstantInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint cp_index, bool resolve))\n@@ -702,2 +702,11 @@\n-  oop obj = cp->resolve_possibly_cached_constant_at(index, CHECK_NULL);\n-  constantTag tag = cp->tag_at(index);\n+  oop obj;\n+  if (!resolve) {\n+    bool found_it;\n+    obj = cp->find_cached_constant_at(cp_index, found_it, CHECK_NULL);\n+    if (!found_it) {\n+      return nullptr;\n+    }\n+  } else {\n+    obj = cp->resolve_possibly_cached_constant_at(cp_index, CHECK_NULL);\n+  }\n+  constantTag tag = cp->tag_at(cp_index);\n@@ -708,1 +717,1 @@\n-    BasicType bt = Signature::basic_type(cp->uncached_signature_ref_at(index));\n+    BasicType bt = Signature::basic_type(cp->uncached_signature_ref_at(cp_index));\n@@ -1581,3 +1590,3 @@\n-C2V_VMENTRY_0(int, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n-  if (!ConstantPool::is_invokedynamic_index(index)) {\n-    JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"not an invokedynamic index %d\", index));\n+C2V_VMENTRY_0(int, decodeIndyIndexToCPIndex, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint encoded_indy_index, jboolean resolve))\n+  if (!ConstantPool::is_invokedynamic_index(encoded_indy_index)) {\n+    JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"not an encoded indy index %d\", encoded_indy_index));\n@@ -1588,3 +1597,5 @@\n-  LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK_0);\n-  int indy_index = cp->decode_invokedynamic_index(index);\n-  cp->cache()->set_dynamic_call(callInfo, indy_index);\n+  int indy_index = cp->decode_invokedynamic_index(encoded_indy_index);\n+  if (resolve) {\n+    LinkResolver::resolve_invoke(callInfo, Handle(), cp, encoded_indy_index, Bytecodes::_invokedynamic, CHECK_0);\n+    cp->cache()->set_dynamic_call(callInfo, indy_index);\n+  }\n@@ -3111,0 +3122,1 @@\n+  {CC \"lookupConstantInPool\",                         CC \"(\" HS_CONSTANT_POOL2 \"IZ)\" JAVACONSTANT,                                          FN_PTR(lookupConstantInPool)},\n@@ -3114,1 +3126,0 @@\n-  {CC \"resolvePossiblyCachedConstantInPool\",          CC \"(\" HS_CONSTANT_POOL2 \"I)\" JAVACONSTANT,                                           FN_PTR(resolvePossiblyCachedConstantInPool)},\n@@ -3117,1 +3128,1 @@\n-  {CC \"resolveInvokeDynamicInPool\",                   CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(resolveInvokeDynamicInPool)},\n+  {CC \"decodeIndyIndexToCPIndex\",                     CC \"(\" HS_CONSTANT_POOL2 \"IZ)I\",                                                      FN_PTR(decodeIndyIndexToCPIndex)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -533,0 +533,1 @@\n+  declare_constant(CodeInstaller::REGISTER_VECTOR)                        \\\n@@ -536,0 +537,1 @@\n+  declare_constant(CodeInstaller::STACK_SLOT_VECTOR)                      \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  LOG_TAG(array) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/metaspaceShared.hpp\"\n@@ -101,0 +102,1 @@\n+  log_array_class_load(this);\n@@ -155,2 +157,1 @@\n-  Klass* k = array_klass(n+dimension(), CHECK_NULL);\n-  ArrayKlass* ak = ArrayKlass::cast(k);\n+  ArrayKlass* ak = array_klass(n + dimension(), CHECK_NULL);\n@@ -192,1 +193,1 @@\n-    ArrayKlass *ak = ArrayKlass::cast(higher_dimension());\n+    ArrayKlass *ak = higher_dimension();\n@@ -200,1 +201,1 @@\n-    ArrayKlass *ak = ArrayKlass::cast(higher_dimension());\n+    ArrayKlass *ak = higher_dimension();\n@@ -211,1 +212,2 @@\n-    ArrayKlass *ak = ArrayKlass::cast(higher_dimension());\n+    ArrayKlass *ak = higher_dimension();\n+    log_array_class_load(ak);\n@@ -220,1 +222,1 @@\n-    ArrayKlass* ak = ArrayKlass::cast(higher_dimension());\n+    ArrayKlass* ak = higher_dimension();\n@@ -227,0 +229,15 @@\n+void ArrayKlass::log_array_class_load(Klass* k) {\n+  LogTarget(Debug, class, load, array) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ResourceMark rm;\n+    ls.print(\"%s\", k->name()->as_klass_external_name());\n+    if (MetaspaceShared::is_shared_dynamic((void*)k)) {\n+      ls.print(\" source: shared objects file (top)\");\n+    } else if (MetaspaceShared::is_shared_static((void*)k)) {\n+      ls.print(\" source: shared objects file\");\n+    }\n+    ls.cr();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+class ObjArrayKlass;\n@@ -41,2 +42,2 @@\n-  Klass* volatile _higher_dimension;  \/\/ Refers the (n+1)'th-dimensional array (if present).\n-  Klass* volatile _lower_dimension;   \/\/ Refers the (n-1)'th-dimensional array (if present).\n+  ObjArrayKlass* volatile _higher_dimension;  \/\/ Refers the (n+1)'th-dimensional array (if present).\n+  ArrayKlass* volatile    _lower_dimension;   \/\/ Refers the (n-1)'th-dimensional array (if present).\n@@ -80,4 +81,4 @@\n-  Klass* higher_dimension() const     { return _higher_dimension; }\n-  inline Klass* higher_dimension_acquire() const; \/\/ load with acquire semantics\n-  void set_higher_dimension(Klass* k) { _higher_dimension = k; }\n-  inline void release_set_higher_dimension(Klass* k); \/\/ store with release semantics\n+  ObjArrayKlass* higher_dimension() const     { return _higher_dimension; }\n+  inline ObjArrayKlass* higher_dimension_acquire() const; \/\/ load with acquire semantics\n+  void set_higher_dimension(ObjArrayKlass* k) { _higher_dimension = k; }\n+  inline void release_set_higher_dimension(ObjArrayKlass* k); \/\/ store with release semantics\n@@ -85,2 +86,2 @@\n-  Klass* lower_dimension() const      { return _lower_dimension; }\n-  void set_lower_dimension(Klass* k)  { _lower_dimension = k; }\n+  ArrayKlass* lower_dimension() const      { return _lower_dimension; }\n+  void set_lower_dimension(ArrayKlass* k)  { _lower_dimension = k; }\n@@ -148,0 +149,1 @@\n+  void log_array_class_load(Klass* k);\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -220,0 +220,6 @@\n+\n+    \/\/ Create a \"scratch\" copy of the resolved references array to archive\n+    if (DumpSharedSpaces) {\n+      objArrayOop scratch_references = oopFactory::new_objArray(vmClasses::Object_klass(), map_length, CHECK);\n+      HeapShared::add_scratch_resolved_references(this, scratch_references);\n+    }\n@@ -291,0 +297,2 @@\n+    ConstantPool* orig_pool = ArchiveBuilder::current()->get_source_addr(this);\n+    objArrayOop scratch_rr = HeapShared::scratch_resolved_references(orig_pool);\n@@ -296,1 +304,1 @@\n-      rr->obj_at_put(i, nullptr);\n+      scratch_rr->obj_at_put(i, nullptr);\n@@ -302,1 +310,1 @@\n-            rr->obj_at_put(i, obj);\n+            scratch_rr->obj_at_put(i, obj);\n@@ -307,0 +315,1 @@\n+    return scratch_rr;\n@@ -387,2 +396,2 @@\n-  for (int index = 1; index < length(); index++) { \/\/ Index 0 is unused\n-    switch (tag_at(index).value()) {\n+  for (int cp_index = 1; cp_index < length(); cp_index++) { \/\/ cp_index 0 is unused\n+    switch (tag_at(cp_index).value()) {\n@@ -391,2 +400,2 @@\n-        jbyte qdesc_bit = tag_at(index).is_Qdescriptor_klass() ? (jbyte) JVM_CONSTANT_QDescBit : 0;\n-        tag_at_put(index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n+        jbyte qdesc_bit = tag_at(cp_index).is_Qdescriptor_klass() ? (jbyte) JVM_CONSTANT_QDescBit : 0;\n+        tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);\n@@ -396,1 +405,1 @@\n-      tag_at_put(index, JVM_CONSTANT_MethodHandle);\n+      tag_at_put(cp_index, JVM_CONSTANT_MethodHandle);\n@@ -399,1 +408,1 @@\n-      tag_at_put(index, JVM_CONSTANT_MethodType);\n+      tag_at_put(cp_index, JVM_CONSTANT_MethodType);\n@@ -402,1 +411,1 @@\n-      tag_at_put(index, JVM_CONSTANT_Dynamic);\n+      tag_at_put(cp_index, JVM_CONSTANT_Dynamic);\n@@ -405,1 +414,1 @@\n-      archived = maybe_archive_resolved_klass_at(index);\n+      archived = maybe_archive_resolved_klass_at(cp_index);\n@@ -462,1 +471,1 @@\n-void ConstantPool::string_at_put(int which, int obj_index, oop str) {\n+void ConstantPool::string_at_put(int obj_index, oop str) {\n@@ -502,1 +511,1 @@\n-Klass* ConstantPool::klass_at_impl(const constantPoolHandle& this_cp, int which,\n+Klass* ConstantPool::klass_at_impl(const constantPoolHandle& this_cp, int cp_index,\n@@ -509,1 +518,1 @@\n-  CPKlassSlot kslot = this_cp->klass_slot_at(which);\n+  CPKlassSlot kslot = this_cp->klass_slot_at(cp_index);\n@@ -516,1 +525,1 @@\n-  if (this_cp->tag_at(which).is_klass()) {\n+  if (this_cp->tag_at(cp_index).is_klass()) {\n@@ -524,1 +533,1 @@\n-  if (this_cp->tag_at(which).is_unresolved_klass_in_error()) {\n+  if (this_cp->tag_at(cp_index).is_unresolved_klass_in_error()) {\n@@ -533,1 +542,1 @@\n-    throw_resolution_error(this_cp, which, CHECK_NULL);\n+    throw_resolution_error(this_cp, cp_index, CHECK_NULL);\n@@ -585,1 +594,1 @@\n-    if (this_cp->tag_at(which).is_Qdescriptor_klass()) {\n+    if (this_cp->tag_at(cp_index).is_Qdescriptor_klass()) {\n@@ -588,1 +597,1 @@\n-    save_and_throw_exception(this_cp, which, constantTag(tag), CHECK_NULL);\n+    save_and_throw_exception(this_cp, cp_index, constantTag(tag), CHECK_NULL);\n@@ -608,1 +617,1 @@\n-  if (this_cp->tag_at(which).is_Qdescriptor_klass()) {\n+  if (this_cp->tag_at(cp_index).is_Qdescriptor_klass()) {\n@@ -613,1 +622,1 @@\n-  jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp->tag_addr_at(which),\n+  jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp->tag_addr_at(cp_index),\n@@ -621,1 +630,1 @@\n-    throw_resolution_error(this_cp, which, CHECK_NULL);\n+    throw_resolution_error(this_cp, cp_index, CHECK_NULL);\n@@ -732,2 +741,2 @@\n-      \/\/ TODO: handle resolved field entries with new structure\n-      \/\/ i = ....\n+    case Bytecodes::_withfield:\n+      return resolved_field_entry_at(index)->constant_pool_index();\n@@ -784,1 +793,0 @@\n-\n@@ -803,2 +811,2 @@\n-u2 ConstantPool::name_ref_index_at(int which_nt) {\n-  jint ref_index = name_and_type_at(which_nt);\n+u2 ConstantPool::name_ref_index_at(int cp_index) {\n+  jint ref_index = name_and_type_at(cp_index);\n@@ -809,2 +817,2 @@\n-u2 ConstantPool::signature_ref_index_at(int which_nt) {\n-  jint ref_index = name_and_type_at(which_nt);\n+u2 ConstantPool::signature_ref_index_at(int cp_index) {\n+  jint ref_index = name_and_type_at(cp_index);\n@@ -819,2 +827,2 @@\n-Symbol* ConstantPool::klass_name_at(int which) const {\n-  return symbol_at(klass_slot_at(which).name_index());\n+Symbol* ConstantPool::klass_name_at(int cp_index) const {\n+  return symbol_at(klass_slot_at(cp_index).name_index());\n@@ -828,2 +836,2 @@\n-Symbol* ConstantPool::uncached_klass_ref_at_noresolve(int which) {\n-  jint ref_index = uncached_klass_ref_index_at(which);\n+Symbol* ConstantPool::uncached_klass_ref_at_noresolve(int cp_index) {\n+  jint ref_index = uncached_klass_ref_index_at(cp_index);\n@@ -833,2 +841,2 @@\n-char* ConstantPool::string_at_noresolve(int which) {\n-  return unresolved_string_at(which)->as_C_string();\n+char* ConstantPool::string_at_noresolve(int cp_index) {\n+  return unresolved_string_at(cp_index)->as_C_string();\n@@ -837,2 +845,2 @@\n-BasicType ConstantPool::basic_type_for_signature_at(int which) const {\n-  return Signature::basic_type(symbol_at(which));\n+BasicType ConstantPool::basic_type_for_signature_at(int cp_index) const {\n+  return Signature::basic_type(symbol_at(cp_index));\n@@ -931,1 +939,1 @@\n-void ConstantPool::save_and_throw_exception(const constantPoolHandle& this_cp, int which,\n+void ConstantPool::save_and_throw_exception(const constantPoolHandle& this_cp, int cp_index,\n@@ -942,2 +950,2 @@\n-  } else if (this_cp->tag_at(which).value() != error_tag) {\n-    add_resolution_error(this_cp, which, tag, PENDING_EXCEPTION);\n+  } else if (this_cp->tag_at(cp_index).value() != error_tag) {\n+    add_resolution_error(this_cp, cp_index, tag, PENDING_EXCEPTION);\n@@ -950,1 +958,1 @@\n-    jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp->tag_addr_at(which),\n+    jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp->tag_addr_at(cp_index),\n@@ -955,1 +963,1 @@\n-      assert(this_cp->tag_at(which).is_klass(), \"Wrong tag value\");\n+      assert(this_cp->tag_at(cp_index).is_klass(), \"Wrong tag value\");\n@@ -961,1 +969,1 @@\n-    throw_resolution_error(this_cp, which, CHECK);\n+    throw_resolution_error(this_cp, cp_index, CHECK);\n@@ -965,2 +973,2 @@\n-constantTag ConstantPool::constant_tag_at(int which) {\n-  constantTag tag = tag_at(which);\n+constantTag ConstantPool::constant_tag_at(int cp_index) {\n+  constantTag tag = tag_at(cp_index);\n@@ -968,1 +976,1 @@\n-    BasicType bt = basic_type_for_constant_at(which);\n+    BasicType bt = basic_type_for_constant_at(cp_index);\n@@ -974,2 +982,2 @@\n-BasicType ConstantPool::basic_type_for_constant_at(int which) {\n-  constantTag tag = tag_at(which);\n+BasicType ConstantPool::basic_type_for_constant_at(int cp_index) {\n+  constantTag tag = tag_at(cp_index);\n@@ -979,1 +987,1 @@\n-    Symbol* constant_type = uncached_signature_ref_at(which);\n+    Symbol* constant_type = uncached_signature_ref_at(cp_index);\n@@ -989,1 +997,1 @@\n-                                           int index, int cache_index,\n+                                           int cp_index, int cache_index,\n@@ -998,2 +1006,2 @@\n-    assert(index > 0, \"valid index\");\n-    cache_index = this_cp->cp_to_object_index(index);\n+    assert(cp_index > 0, \"valid constant pool index\");\n+    cache_index = this_cp->cp_to_object_index(cp_index);\n@@ -1002,1 +1010,1 @@\n-  assert(index == _no_index_sentinel || index >= 0, \"\");\n+  assert(cp_index == _no_index_sentinel || cp_index >= 0, \"\");\n@@ -1008,1 +1016,1 @@\n-        DEBUG_ONLY(int temp_index = (index >= 0 ? index : this_cp->object_to_cp_index(cache_index)));\n+        DEBUG_ONLY(int temp_index = (cp_index >= 0 ? cp_index : this_cp->object_to_cp_index(cache_index)));\n@@ -1016,1 +1024,1 @@\n-    index = this_cp->object_to_cp_index(cache_index);\n+    cp_index = this_cp->object_to_cp_index(cache_index);\n@@ -1021,1 +1029,1 @@\n-  constantTag tag = this_cp->tag_at(index);\n+  constantTag tag = this_cp->tag_at(cp_index);\n@@ -1028,1 +1036,1 @@\n-      CPKlassSlot kslot = this_cp->klass_slot_at(index);\n+      CPKlassSlot kslot = this_cp->klass_slot_at(cp_index);\n@@ -1058,1 +1066,1 @@\n-      Klass* resolved = klass_at_impl(this_cp, index, CHECK_NULL);\n+      Klass* resolved = klass_at_impl(this_cp, cp_index, CHECK_NULL);\n@@ -1069,1 +1077,1 @@\n-      BootstrapInfo bootstrap_specifier(this_cp, index);\n+      BootstrapInfo bootstrap_specifier(this_cp, cp_index);\n@@ -1087,1 +1095,1 @@\n-        save_and_throw_exception(this_cp, index, tag, CHECK_NULL);\n+        save_and_throw_exception(this_cp, cp_index, tag, CHECK_NULL);\n@@ -1121,1 +1129,1 @@\n-    result_oop = string_at_impl(this_cp, index, cache_index, CHECK_NULL);\n+    result_oop = string_at_impl(this_cp, cp_index, cache_index, CHECK_NULL);\n@@ -1126,5 +1134,5 @@\n-      int ref_kind                 = this_cp->method_handle_ref_kind_at(index);\n-      int callee_index             = this_cp->method_handle_klass_index_at(index);\n-      Symbol*  name =      this_cp->method_handle_name_ref_at(index);\n-      Symbol*  signature = this_cp->method_handle_signature_ref_at(index);\n-      constantTag m_tag  = this_cp->tag_at(this_cp->method_handle_index_at(index));\n+      int ref_kind                 = this_cp->method_handle_ref_kind_at(cp_index);\n+      int callee_index             = this_cp->method_handle_klass_index_at(cp_index);\n+      Symbol*  name =      this_cp->method_handle_name_ref_at(cp_index);\n+      Symbol*  signature = this_cp->method_handle_signature_ref_at(cp_index);\n+      constantTag m_tag  = this_cp->tag_at(this_cp->method_handle_index_at(cp_index));\n@@ -1133,1 +1141,1 @@\n-                              ref_kind, index, this_cp->method_handle_index_at(index),\n+                              ref_kind, cp_index, this_cp->method_handle_index_at(cp_index),\n@@ -1139,1 +1147,1 @@\n-        save_and_throw_exception(this_cp, index, tag, CHECK_NULL);\n+        save_and_throw_exception(this_cp, cp_index, tag, CHECK_NULL);\n@@ -1153,1 +1161,1 @@\n-                 index,\n+                 cp_index,\n@@ -1157,1 +1165,1 @@\n-        save_and_throw_exception(this_cp, index, tag, CHECK_NULL);\n+        save_and_throw_exception(this_cp, cp_index, tag, CHECK_NULL);\n@@ -1166,1 +1174,1 @@\n-        save_and_throw_exception(this_cp, index, tag, CHECK_NULL);\n+        save_and_throw_exception(this_cp, cp_index, tag, CHECK_NULL);\n@@ -1174,1 +1182,1 @@\n-      Symbol*  signature = this_cp->method_type_signature_at(index);\n+      Symbol*  signature = this_cp->method_type_signature_at(cp_index);\n@@ -1177,1 +1185,1 @@\n-                              index, this_cp->method_type_index_at(index),\n+                              cp_index, this_cp->method_type_index_at(cp_index),\n@@ -1185,1 +1193,1 @@\n-        save_and_throw_exception(this_cp, index, tag, CHECK_NULL);\n+        save_and_throw_exception(this_cp, cp_index, tag, CHECK_NULL);\n@@ -1192,1 +1200,1 @@\n-    prim_value.i = this_cp->int_at(index);\n+    prim_value.i = this_cp->int_at(cp_index);\n@@ -1198,1 +1206,1 @@\n-    prim_value.f = this_cp->float_at(index);\n+    prim_value.f = this_cp->float_at(cp_index);\n@@ -1204,1 +1212,1 @@\n-    prim_value.j = this_cp->long_at(index);\n+    prim_value.j = this_cp->long_at(cp_index);\n@@ -1210,1 +1218,1 @@\n-    prim_value.d = this_cp->double_at(index);\n+    prim_value.d = this_cp->double_at(cp_index);\n@@ -1218,1 +1226,1 @@\n-    throw_resolution_error(this_cp, index, CHECK_NULL);\n+    throw_resolution_error(this_cp, cp_index, CHECK_NULL);\n@@ -1222,1 +1230,1 @@\n-    fatal(\"unexpected constant tag at CP %p[%d\/%d] = %d\", this_cp(), index, cache_index, tag.value());\n+    fatal(\"unexpected constant tag at CP %p[%d\/%d] = %d\", this_cp(), cp_index, cache_index, tag.value());\n@@ -1248,2 +1256,2 @@\n-oop ConstantPool::uncached_string_at(int which, TRAPS) {\n-  Symbol* sym = unresolved_string_at(which);\n+oop ConstantPool::uncached_string_at(int cp_index, TRAPS) {\n+  Symbol* sym = unresolved_string_at(cp_index);\n@@ -1255,1 +1263,1 @@\n-void ConstantPool::copy_bootstrap_arguments_at_impl(const constantPoolHandle& this_cp, int index,\n+void ConstantPool::copy_bootstrap_arguments_at_impl(const constantPoolHandle& this_cp, int cp_index,\n@@ -1261,2 +1269,2 @@\n-  \/\/ checks: index in range [0..this_cp->length),\n-  \/\/ tag at index, start..end in range [0..this_cp->bootstrap_argument_count],\n+  \/\/ checks: cp_index in range [0..this_cp->length),\n+  \/\/ tag at cp_index, start..end in range [0..this_cp->bootstrap_argument_count],\n@@ -1264,3 +1272,3 @@\n-  if ((0 >= index    || index >= this_cp->length())  ||\n-      !(this_cp->tag_at(index).is_invoke_dynamic()    ||\n-        this_cp->tag_at(index).is_dynamic_constant()) ||\n+  if ((0 >= cp_index    || cp_index >= this_cp->length())  ||\n+      !(this_cp->tag_at(cp_index).is_invoke_dynamic()    ||\n+        this_cp->tag_at(cp_index).is_dynamic_constant()) ||\n@@ -1268,1 +1276,1 @@\n-      (end_arg > this_cp->bootstrap_argument_count_at(index)) ||\n+      (end_arg > this_cp->bootstrap_argument_count_at(cp_index)) ||\n@@ -1279,1 +1287,1 @@\n-    int arg_index = this_cp->bootstrap_argument_index_at(index, i);\n+    int arg_index = this_cp->bootstrap_argument_index_at(cp_index, i);\n@@ -1292,1 +1300,1 @@\n-oop ConstantPool::string_at_impl(const constantPoolHandle& this_cp, int which, int obj_index, TRAPS) {\n+oop ConstantPool::string_at_impl(const constantPoolHandle& this_cp, int cp_index, int obj_index, TRAPS) {\n@@ -1297,1 +1305,1 @@\n-  Symbol* sym = this_cp->unresolved_string_at(which);\n+  Symbol* sym = this_cp->unresolved_string_at(cp_index);\n@@ -1299,1 +1307,1 @@\n-  this_cp->string_at_put(which, obj_index, str);\n+  this_cp->string_at_put(obj_index, str);\n@@ -1305,1 +1313,1 @@\n-bool ConstantPool::klass_name_at_matches(const InstanceKlass* k, int which) {\n+bool ConstantPool::klass_name_at_matches(const InstanceKlass* k, int cp_index) {\n@@ -1307,1 +1315,1 @@\n-  Symbol* cp_name = klass_name_at(which);\n+  Symbol* cp_name = klass_name_at(cp_index);\n@@ -1665,1 +1673,1 @@\n-  int dest_i = to_i;  \/\/ leave original alone for debug purposes\n+  int dest_cpi = to_i;  \/\/ leave original alone for debug purposes\n@@ -1667,2 +1675,2 @@\n-  for (int src_i = start_i; src_i <= end_i; \/* see loop bottom *\/ ) {\n-    copy_entry_to(from_cp, src_i, to_cp, dest_i);\n+  for (int src_cpi = start_i; src_cpi <= end_i; \/* see loop bottom *\/ ) {\n+    copy_entry_to(from_cp, src_cpi, to_cp, dest_cpi);\n@@ -1670,1 +1678,1 @@\n-    switch (from_cp->tag_at(src_i).value()) {\n+    switch (from_cp->tag_at(src_cpi).value()) {\n@@ -1674,2 +1682,2 @@\n-      src_i += 2;\n-      dest_i += 2;\n+      src_cpi += 2;\n+      dest_cpi += 2;\n@@ -1680,2 +1688,2 @@\n-      src_i++;\n-      dest_i++;\n+      src_cpi++;\n+      dest_cpi++;\n@@ -1893,1 +1901,1 @@\n-const char* ConstantPool::printable_name_at(int which) {\n+const char* ConstantPool::printable_name_at(int cp_index) {\n@@ -1895,1 +1903,1 @@\n-  constantTag tag = tag_at(which);\n+  constantTag tag = tag_at(cp_index);\n@@ -1898,1 +1906,1 @@\n-    return string_at_noresolve(which);\n+    return string_at_noresolve(cp_index);\n@@ -1900,1 +1908,1 @@\n-    return klass_name_at(which)->as_C_string();\n+    return klass_name_at(cp_index)->as_C_string();\n@@ -1902,1 +1910,1 @@\n-    return symbol_at(which)->as_C_string();\n+    return symbol_at(cp_index)->as_C_string();\n@@ -2381,1 +2389,1 @@\n-void ConstantPool::print_entry_on(const int index, outputStream* st) {\n+void ConstantPool::print_entry_on(const int cp_index, outputStream* st) {\n@@ -2383,2 +2391,2 @@\n-  st->print(\" - %3d : \", index);\n-  tag_at(index).print_on(st);\n+  st->print(\" - %3d : \", cp_index);\n+  tag_at(cp_index).print_on(st);\n@@ -2386,1 +2394,1 @@\n-  switch (tag_at(index).value()) {\n+  switch (tag_at(cp_index).value()) {\n@@ -2388,1 +2396,1 @@\n-      { Klass* k = klass_at(index, CATCH);\n+      { Klass* k = klass_at(cp_index, CATCH);\n@@ -2397,2 +2405,2 @@\n-      st->print(\"klass_index=%d\", uncached_klass_ref_index_at(index));\n-      st->print(\" name_and_type_index=%d\", uncached_name_and_type_ref_index_at(index));\n+      st->print(\"klass_index=%d\", uncached_klass_ref_index_at(cp_index));\n+      st->print(\" name_and_type_index=%d\", uncached_name_and_type_ref_index_at(cp_index));\n@@ -2401,1 +2409,1 @@\n-      unresolved_string_at(index)->print_value_on(st);\n+      unresolved_string_at(cp_index)->print_value_on(st);\n@@ -2404,1 +2412,1 @@\n-      st->print(\"%d\", int_at(index));\n+      st->print(\"%d\", int_at(cp_index));\n@@ -2407,1 +2415,1 @@\n-      st->print(\"%f\", float_at(index));\n+      st->print(\"%f\", float_at(cp_index));\n@@ -2410,1 +2418,1 @@\n-      st->print_jlong(long_at(index));\n+      st->print_jlong(long_at(cp_index));\n@@ -2413,1 +2421,1 @@\n-      st->print(\"%lf\", double_at(index));\n+      st->print(\"%lf\", double_at(cp_index));\n@@ -2416,2 +2424,2 @@\n-      st->print(\"name_index=%d\", name_ref_index_at(index));\n-      st->print(\" signature_index=%d\", signature_ref_index_at(index));\n+      st->print(\"name_index=%d\", name_ref_index_at(cp_index));\n+      st->print(\" signature_index=%d\", signature_ref_index_at(cp_index));\n@@ -2420,1 +2428,1 @@\n-      symbol_at(index)->print_value_on(st);\n+      symbol_at(cp_index)->print_value_on(st);\n@@ -2423,1 +2431,1 @@\n-        int name_index = *int_at_addr(index);\n+        int name_index = *int_at_addr(cp_index);\n@@ -2430,1 +2438,1 @@\n-        CPKlassSlot kslot = klass_slot_at(index);\n+        CPKlassSlot kslot = klass_slot_at(cp_index);\n@@ -2439,2 +2447,2 @@\n-      st->print(\"ref_kind=%d\", method_handle_ref_kind_at(index));\n-      st->print(\" ref_index=%d\", method_handle_index_at(index));\n+      st->print(\"ref_kind=%d\", method_handle_ref_kind_at(cp_index));\n+      st->print(\" ref_index=%d\", method_handle_index_at(cp_index));\n@@ -2444,1 +2452,1 @@\n-      st->print(\"signature_index=%d\", method_type_index_at(index));\n+      st->print(\"signature_index=%d\", method_type_index_at(cp_index));\n@@ -2449,3 +2457,3 @@\n-        st->print(\"bootstrap_method_index=%d\", bootstrap_method_ref_index_at(index));\n-        st->print(\" type_index=%d\", bootstrap_name_and_type_ref_index_at(index));\n-        int argc = bootstrap_argument_count_at(index);\n+        st->print(\"bootstrap_method_index=%d\", bootstrap_method_ref_index_at(cp_index));\n+        st->print(\" type_index=%d\", bootstrap_name_and_type_ref_index_at(cp_index));\n+        int argc = bootstrap_argument_count_at(cp_index);\n@@ -2454,1 +2462,1 @@\n-            int arg = bootstrap_argument_index_at(index, arg_i);\n+            int arg = bootstrap_argument_index_at(cp_index, arg_i);\n@@ -2463,3 +2471,3 @@\n-        st->print(\"bootstrap_method_index=%d\", bootstrap_method_ref_index_at(index));\n-        st->print(\" name_and_type_index=%d\", bootstrap_name_and_type_ref_index_at(index));\n-        int argc = bootstrap_argument_count_at(index);\n+        st->print(\"bootstrap_method_index=%d\", bootstrap_method_ref_index_at(cp_index));\n+        st->print(\" name_and_type_index=%d\", bootstrap_name_and_type_ref_index_at(cp_index));\n+        int argc = bootstrap_argument_count_at(cp_index);\n@@ -2468,1 +2476,1 @@\n-            int arg = bootstrap_argument_index_at(index, arg_i);\n+            int arg = bootstrap_argument_index_at(cp_index, arg_i);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":143,"deletions":135,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -125,3 +125,3 @@\n-  void set_tags(Array<u1>* tags)               { _tags = tags; }\n-  void tag_at_put(int which, jbyte t)          { tags()->at_put(which, t); }\n-  void release_tag_at_put(int which, jbyte t)  { tags()->release_at_put(which, t); }\n+  void set_tags(Array<u1>* tags)                 { _tags = tags; }\n+  void tag_at_put(int cp_index, jbyte t)         { tags()->at_put(cp_index, t); }\n+  void release_tag_at_put(int cp_index, jbyte t) { tags()->release_at_put(cp_index, t); }\n@@ -129,1 +129,1 @@\n-  u1* tag_addr_at(int which) const             { return tags()->adr_at(which); }\n+  u1* tag_addr_at(int cp_index) const            { return tags()->adr_at(cp_index); }\n@@ -139,3 +139,3 @@\n-  intptr_t* obj_at_addr(int which) const {\n-    assert(is_within_bounds(which), \"index out of bounds\");\n-    return (intptr_t*) &base()[which];\n+  intptr_t* obj_at_addr(int cp_index) const {\n+    assert(is_within_bounds(cp_index), \"index out of bounds\");\n+    return (intptr_t*) &base()[cp_index];\n@@ -144,3 +144,3 @@\n-  jint* int_at_addr(int which) const {\n-    assert(is_within_bounds(which), \"index out of bounds\");\n-    return (jint*) &base()[which];\n+  jint* int_at_addr(int cp_index) const {\n+    assert(is_within_bounds(cp_index), \"index out of bounds\");\n+    return (jint*) &base()[cp_index];\n@@ -149,3 +149,3 @@\n-  jlong* long_at_addr(int which) const {\n-    assert(is_within_bounds(which), \"index out of bounds\");\n-    return (jlong*) &base()[which];\n+  jlong* long_at_addr(int cp_index) const {\n+    assert(is_within_bounds(cp_index), \"index out of bounds\");\n+    return (jlong*) &base()[cp_index];\n@@ -154,3 +154,3 @@\n-  jfloat* float_at_addr(int which) const {\n-    assert(is_within_bounds(which), \"index out of bounds\");\n-    return (jfloat*) &base()[which];\n+  jfloat* float_at_addr(int cp_index) const {\n+    assert(is_within_bounds(cp_index), \"index out of bounds\");\n+    return (jfloat*) &base()[cp_index];\n@@ -159,3 +159,3 @@\n-  jdouble* double_at_addr(int which) const {\n-    assert(is_within_bounds(which), \"index out of bounds\");\n-    return (jdouble*) &base()[which];\n+  jdouble* double_at_addr(int cp_index) const {\n+    assert(is_within_bounds(cp_index), \"index out of bounds\");\n+    return (jdouble*) &base()[cp_index];\n@@ -273,3 +273,3 @@\n-  void klass_index_at_put(int which, int name_index) {\n-    tag_at_put(which, JVM_CONSTANT_ClassIndex);\n-    *int_at_addr(which) = name_index;\n+  void klass_index_at_put(int cp_index, int name_index) {\n+    tag_at_put(cp_index, JVM_CONSTANT_ClassIndex);\n+    *int_at_addr(cp_index) = name_index;\n@@ -281,2 +281,2 @@\n-  void unresolved_qdescriptor_at_put(int which, int name_index, int resolved_klass_index) {\n-      release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass | (jbyte) JVM_CONSTANT_QDescBit);\n+  void unresolved_qdescriptor_at_put(int cp_index, int name_index, int resolved_klass_index) {\n+      release_tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass | (jbyte) JVM_CONSTANT_QDescBit);\n@@ -286,1 +286,1 @@\n-      *int_at_addr(which) =\n+      *int_at_addr(cp_index) =\n@@ -290,2 +290,2 @@\n-  void unresolved_klass_at_put(int which, int name_index, int resolved_klass_index) {\n-    release_tag_at_put(which, JVM_CONSTANT_UnresolvedClass);\n+  void unresolved_klass_at_put(int cp_index, int name_index, int resolved_klass_index) {\n+    release_tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass);\n@@ -295,1 +295,1 @@\n-    *int_at_addr(which) =\n+    *int_at_addr(cp_index) =\n@@ -299,3 +299,3 @@\n-  void method_handle_index_at_put(int which, int ref_kind, int ref_index) {\n-    tag_at_put(which, JVM_CONSTANT_MethodHandle);\n-    *int_at_addr(which) = ((jint) ref_index<<16) | ref_kind;\n+  void method_handle_index_at_put(int cp_index, int ref_kind, int ref_index) {\n+    tag_at_put(cp_index, JVM_CONSTANT_MethodHandle);\n+    *int_at_addr(cp_index) = ((jint) ref_index<<16) | ref_kind;\n@@ -304,3 +304,3 @@\n-  void method_type_index_at_put(int which, int ref_index) {\n-    tag_at_put(which, JVM_CONSTANT_MethodType);\n-    *int_at_addr(which) = ref_index;\n+  void method_type_index_at_put(int cp_index, int ref_index) {\n+    tag_at_put(cp_index, JVM_CONSTANT_MethodType);\n+    *int_at_addr(cp_index) = ref_index;\n@@ -309,3 +309,3 @@\n-  void dynamic_constant_at_put(int which, int bsms_attribute_index, int name_and_type_index) {\n-    tag_at_put(which, JVM_CONSTANT_Dynamic);\n-    *int_at_addr(which) = ((jint) name_and_type_index<<16) | bsms_attribute_index;\n+  void dynamic_constant_at_put(int cp_index, int bsms_attribute_index, int name_and_type_index) {\n+    tag_at_put(cp_index, JVM_CONSTANT_Dynamic);\n+    *int_at_addr(cp_index) = ((jint) name_and_type_index<<16) | bsms_attribute_index;\n@@ -314,3 +314,3 @@\n-  void invoke_dynamic_at_put(int which, int bsms_attribute_index, int name_and_type_index) {\n-    tag_at_put(which, JVM_CONSTANT_InvokeDynamic);\n-    *int_at_addr(which) = ((jint) name_and_type_index<<16) | bsms_attribute_index;\n+  void invoke_dynamic_at_put(int cp_index, int bsms_attribute_index, int name_and_type_index) {\n+    tag_at_put(cp_index, JVM_CONSTANT_InvokeDynamic);\n+    *int_at_addr(cp_index) = ((jint) name_and_type_index<<16) | bsms_attribute_index;\n@@ -319,1 +319,1 @@\n-  void unresolved_string_at_put(int which, Symbol* s) {\n+  void unresolved_string_at_put(int cp_index, Symbol* s) {\n@@ -324,2 +324,2 @@\n-    tag_at_put(which, JVM_CONSTANT_String);\n-    *symbol_at_addr(which) = s;\n+    tag_at_put(cp_index, JVM_CONSTANT_String);\n+    *symbol_at_addr(cp_index) = s;\n@@ -328,3 +328,3 @@\n-  void int_at_put(int which, jint i) {\n-    tag_at_put(which, JVM_CONSTANT_Integer);\n-    *int_at_addr(which) = i;\n+  void int_at_put(int cp_index, jint i) {\n+    tag_at_put(cp_index, JVM_CONSTANT_Integer);\n+    *int_at_addr(cp_index) = i;\n@@ -333,2 +333,2 @@\n-  void long_at_put(int which, jlong l) {\n-    tag_at_put(which, JVM_CONSTANT_Long);\n+  void long_at_put(int cp_index, jlong l) {\n+    tag_at_put(cp_index, JVM_CONSTANT_Long);\n@@ -336,1 +336,1 @@\n-    Bytes::put_native_u8((address)long_at_addr(which), *((u8*) &l));\n+    Bytes::put_native_u8((address)long_at_addr(cp_index), *((u8*) &l));\n@@ -339,3 +339,3 @@\n-  void float_at_put(int which, jfloat f) {\n-    tag_at_put(which, JVM_CONSTANT_Float);\n-    *float_at_addr(which) = f;\n+  void float_at_put(int cp_index, jfloat f) {\n+    tag_at_put(cp_index, JVM_CONSTANT_Float);\n+    *float_at_addr(cp_index) = f;\n@@ -344,2 +344,2 @@\n-  void double_at_put(int which, jdouble d) {\n-    tag_at_put(which, JVM_CONSTANT_Double);\n+  void double_at_put(int cp_index, jdouble d) {\n+    tag_at_put(cp_index, JVM_CONSTANT_Double);\n@@ -348,1 +348,1 @@\n-    Bytes::put_native_u8((address) double_at_addr(which), *((u8*) &d));\n+    Bytes::put_native_u8((address) double_at_addr(cp_index), *((u8*) &d));\n@@ -351,3 +351,3 @@\n-  Symbol** symbol_at_addr(int which) const {\n-    assert(is_within_bounds(which), \"index out of bounds\");\n-    return (Symbol**) &base()[which];\n+  Symbol** symbol_at_addr(int cp_index) const {\n+    assert(is_within_bounds(cp_index), \"index out of bounds\");\n+    return (Symbol**) &base()[cp_index];\n@@ -356,1 +356,1 @@\n-  void symbol_at_put(int which, Symbol* s) {\n+  void symbol_at_put(int cp_index, Symbol* s) {\n@@ -358,2 +358,2 @@\n-    tag_at_put(which, JVM_CONSTANT_Utf8);\n-    *symbol_at_addr(which) = s;\n+    tag_at_put(cp_index, JVM_CONSTANT_Utf8);\n+    *symbol_at_addr(cp_index) = s;\n@@ -362,1 +362,1 @@\n-  void string_at_put(int which, int obj_index, oop str);\n+  void string_at_put(int obj_index, oop str);\n@@ -365,3 +365,3 @@\n-  void string_index_at_put(int which, int string_index) {\n-    tag_at_put(which, JVM_CONSTANT_StringIndex);\n-    *int_at_addr(which) = string_index;\n+  void string_index_at_put(int cp_index, int string_index) {\n+    tag_at_put(cp_index, JVM_CONSTANT_StringIndex);\n+    *int_at_addr(cp_index) = string_index;\n@@ -370,3 +370,3 @@\n-  void field_at_put(int which, int class_index, int name_and_type_index) {\n-    tag_at_put(which, JVM_CONSTANT_Fieldref);\n-    *int_at_addr(which) = ((jint) name_and_type_index<<16) | class_index;\n+  void field_at_put(int cp_index, int class_index, int name_and_type_index) {\n+    tag_at_put(cp_index, JVM_CONSTANT_Fieldref);\n+    *int_at_addr(cp_index) = ((jint) name_and_type_index<<16) | class_index;\n@@ -375,3 +375,3 @@\n-  void method_at_put(int which, int class_index, int name_and_type_index) {\n-    tag_at_put(which, JVM_CONSTANT_Methodref);\n-    *int_at_addr(which) = ((jint) name_and_type_index<<16) | class_index;\n+  void method_at_put(int cp_index, int class_index, int name_and_type_index) {\n+    tag_at_put(cp_index, JVM_CONSTANT_Methodref);\n+    *int_at_addr(cp_index) = ((jint) name_and_type_index<<16) | class_index;\n@@ -380,3 +380,3 @@\n-  void interface_method_at_put(int which, int class_index, int name_and_type_index) {\n-    tag_at_put(which, JVM_CONSTANT_InterfaceMethodref);\n-    *int_at_addr(which) = ((jint) name_and_type_index<<16) | class_index;  \/\/ Not so nice\n+  void interface_method_at_put(int cp_index, int class_index, int name_and_type_index) {\n+    tag_at_put(cp_index, JVM_CONSTANT_InterfaceMethodref);\n+    *int_at_addr(cp_index) = ((jint) name_and_type_index<<16) | class_index;  \/\/ Not so nice\n@@ -385,3 +385,3 @@\n-  void name_and_type_at_put(int which, int name_index, int signature_index) {\n-    tag_at_put(which, JVM_CONSTANT_NameAndType);\n-    *int_at_addr(which) = ((jint) signature_index<<16) | name_index;  \/\/ Not so nice\n+  void name_and_type_at_put(int cp_index, int name_index, int signature_index) {\n+    tag_at_put(cp_index, JVM_CONSTANT_NameAndType);\n+    *int_at_addr(cp_index) = ((jint) signature_index<<16) | name_index;  \/\/ Not so nice\n@@ -392,1 +392,1 @@\n-  constantTag tag_at(int which) const { return (constantTag)tags()->at_acquire(which); }\n+  constantTag tag_at(int cp_index) const { return (constantTag)tags()->at_acquire(cp_index); }\n@@ -396,1 +396,1 @@\n-  Klass* klass_at(int which, TRAPS) {\n+  Klass* klass_at(int cp_index, TRAPS) {\n@@ -398,1 +398,1 @@\n-    return klass_at_impl(h_this, which, THREAD);\n+    return klass_at_impl(h_this, cp_index, THREAD);\n@@ -401,2 +401,2 @@\n-  CPKlassSlot klass_slot_at(int which) const {\n-    assert(tag_at(which).is_unresolved_klass() || tag_at(which).is_klass(),\n+  CPKlassSlot klass_slot_at(int cp_index) const {\n+    assert(tag_at(cp_index).is_unresolved_klass() || tag_at(cp_index).is_klass(),\n@@ -404,1 +404,1 @@\n-    int value = *int_at_addr(which);\n+    int value = *int_at_addr(cp_index);\n@@ -410,3 +410,3 @@\n-  Symbol* klass_name_at(int which) const;  \/\/ Returns the name, w\/o resolving.\n-  int klass_name_index_at(int which) const {\n-    return klass_slot_at(which).name_index();\n+  Symbol* klass_name_at(int cp_index) const;  \/\/ Returns the name, w\/o resolving.\n+  int klass_name_index_at(int cp_index) const {\n+    return klass_slot_at(cp_index).name_index();\n@@ -415,1 +415,1 @@\n-  Klass* resolved_klass_at(int which) const;  \/\/ Used by Compiler\n+  Klass* resolved_klass_at(int cp_index) const;  \/\/ Used by Compiler\n@@ -418,2 +418,2 @@\n-  Symbol* klass_at_noresolve(int which) { return klass_name_at(which); }\n-  void temp_unresolved_klass_at_put(int which, int name_index) {\n+  Symbol* klass_at_noresolve(int cp_index) { return klass_name_at(cp_index); }\n+  void temp_unresolved_klass_at_put(int cp_index, int name_index) {\n@@ -422,1 +422,1 @@\n-    unresolved_klass_at_put(which, name_index, CPKlassSlot::_temp_resolved_klass_index);\n+    unresolved_klass_at_put(cp_index, name_index, CPKlassSlot::_temp_resolved_klass_index);\n@@ -425,3 +425,3 @@\n-  jint int_at(int which) {\n-    assert(tag_at(which).is_int(), \"Corrupted constant pool\");\n-    return *int_at_addr(which);\n+  jint int_at(int cp_index) {\n+    assert(tag_at(cp_index).is_int(), \"Corrupted constant pool\");\n+    return *int_at_addr(cp_index);\n@@ -430,4 +430,4 @@\n-  jlong long_at(int which) {\n-    assert(tag_at(which).is_long(), \"Corrupted constant pool\");\n-    \/\/ return *long_at_addr(which);\n-    u8 tmp = Bytes::get_native_u8((address)&base()[which]);\n+  jlong long_at(int cp_index) {\n+    assert(tag_at(cp_index).is_long(), \"Corrupted constant pool\");\n+    \/\/ return *long_at_addr(cp_index);\n+    u8 tmp = Bytes::get_native_u8((address)&base()[cp_index]);\n@@ -437,3 +437,3 @@\n-  jfloat float_at(int which) {\n-    assert(tag_at(which).is_float(), \"Corrupted constant pool\");\n-    return *float_at_addr(which);\n+  jfloat float_at(int cp_index) {\n+    assert(tag_at(cp_index).is_float(), \"Corrupted constant pool\");\n+    return *float_at_addr(cp_index);\n@@ -442,3 +442,3 @@\n-  jdouble double_at(int which) {\n-    assert(tag_at(which).is_double(), \"Corrupted constant pool\");\n-    u8 tmp = Bytes::get_native_u8((address)&base()[which]);\n+  jdouble double_at(int cp_index) {\n+    assert(tag_at(cp_index).is_double(), \"Corrupted constant pool\");\n+    u8 tmp = Bytes::get_native_u8((address)&base()[cp_index]);\n@@ -448,3 +448,3 @@\n-  Symbol* symbol_at(int which) const {\n-    assert(tag_at(which).is_utf8(), \"Corrupted constant pool\");\n-    return *symbol_at_addr(which);\n+  Symbol* symbol_at(int cp_index) const {\n+    assert(tag_at(cp_index).is_utf8(), \"Corrupted constant pool\");\n+    return *symbol_at_addr(cp_index);\n@@ -453,1 +453,1 @@\n-  oop string_at(int which, int obj_index, TRAPS) {\n+  oop string_at(int cp_index, int obj_index, TRAPS) {\n@@ -455,1 +455,1 @@\n-    return string_at_impl(h_this, which, obj_index, THREAD);\n+    return string_at_impl(h_this, cp_index, obj_index, THREAD);\n@@ -457,3 +457,3 @@\n-  oop string_at(int which, TRAPS) {\n-    int obj_index = cp_to_object_index(which);\n-    return string_at(which, obj_index, THREAD);\n+  oop string_at(int cp_index, TRAPS) {\n+    int obj_index = cp_to_object_index(cp_index);\n+    return string_at(cp_index, obj_index, THREAD);\n@@ -463,1 +463,1 @@\n-  oop uncached_string_at(int which, TRAPS);\n+  oop uncached_string_at(int cp_index, TRAPS);\n@@ -467,2 +467,2 @@\n-  oop resolved_string_at(int which) {\n-    assert(tag_at(which).is_string(), \"Corrupted constant pool\");\n+  oop resolved_string_at(int cp_index) {\n+    assert(tag_at(cp_index).is_string(), \"Corrupted constant pool\");\n@@ -472,1 +472,1 @@\n-    int obj_index = cp_to_object_index(which);\n+    int obj_index = cp_to_object_index(cp_index);\n@@ -476,3 +476,3 @@\n-  Symbol* unresolved_string_at(int which) {\n-    assert(tag_at(which).is_string(), \"Corrupted constant pool\");\n-    return *symbol_at_addr(which);\n+  Symbol* unresolved_string_at(int cp_index) {\n+    assert(tag_at(cp_index).is_string(), \"Corrupted constant pool\");\n+    return *symbol_at_addr(cp_index);\n@@ -485,1 +485,1 @@\n-  char* string_at_noresolve(int which);\n+  char* string_at_noresolve(int cp_index);\n@@ -487,3 +487,3 @@\n-  jint name_and_type_at(int which) {\n-    assert(tag_at(which).is_name_and_type(), \"Corrupted constant pool\");\n-    return *int_at_addr(which);\n+  jint name_and_type_at(int cp_index) {\n+    assert(tag_at(cp_index).is_name_and_type(), \"Corrupted constant pool\");\n+    return *int_at_addr(cp_index);\n@@ -492,4 +492,4 @@\n-  int method_handle_ref_kind_at(int which) {\n-    assert(tag_at(which).is_method_handle() ||\n-           tag_at(which).is_method_handle_in_error(), \"Corrupted constant pool\");\n-    return extract_low_short_from_int(*int_at_addr(which));  \/\/ mask out unwanted ref_index bits\n+  int method_handle_ref_kind_at(int cp_index) {\n+    assert(tag_at(cp_index).is_method_handle() ||\n+           tag_at(cp_index).is_method_handle_in_error(), \"Corrupted constant pool\");\n+    return extract_low_short_from_int(*int_at_addr(cp_index));  \/\/ mask out unwanted ref_index bits\n@@ -497,4 +497,4 @@\n-  int method_handle_index_at(int which) {\n-    assert(tag_at(which).is_method_handle() ||\n-           tag_at(which).is_method_handle_in_error(), \"Corrupted constant pool\");\n-    return extract_high_short_from_int(*int_at_addr(which));  \/\/ shift out unwanted ref_kind bits\n+  int method_handle_index_at(int cp_index) {\n+    assert(tag_at(cp_index).is_method_handle() ||\n+           tag_at(cp_index).is_method_handle_in_error(), \"Corrupted constant pool\");\n+    return extract_high_short_from_int(*int_at_addr(cp_index));  \/\/ shift out unwanted ref_kind bits\n@@ -502,4 +502,4 @@\n-  int method_type_index_at(int which) {\n-    assert(tag_at(which).is_method_type() ||\n-           tag_at(which).is_method_type_in_error(), \"Corrupted constant pool\");\n-    return *int_at_addr(which);\n+  int method_type_index_at(int cp_index) {\n+    assert(tag_at(cp_index).is_method_type() ||\n+           tag_at(cp_index).is_method_type_in_error(), \"Corrupted constant pool\");\n+    return *int_at_addr(cp_index);\n@@ -509,2 +509,2 @@\n-  Symbol* method_handle_name_ref_at(int which) {\n-    int member = method_handle_index_at(which);\n+  Symbol* method_handle_name_ref_at(int cp_index) {\n+    int member = method_handle_index_at(cp_index);\n@@ -513,2 +513,2 @@\n-  Symbol* method_handle_signature_ref_at(int which) {\n-    int member = method_handle_index_at(which);\n+  Symbol* method_handle_signature_ref_at(int cp_index) {\n+    int member = method_handle_index_at(cp_index);\n@@ -517,2 +517,2 @@\n-  u2 method_handle_klass_index_at(int which) {\n-    int member = method_handle_index_at(which);\n+  u2 method_handle_klass_index_at(int cp_index) {\n+    int member = method_handle_index_at(cp_index);\n@@ -521,2 +521,2 @@\n-  Symbol* method_type_signature_at(int which) {\n-    int sym = method_type_index_at(which);\n+  Symbol* method_type_signature_at(int cp_index) {\n+    int sym = method_type_index_at(cp_index);\n@@ -526,3 +526,3 @@\n-  u2 bootstrap_name_and_type_ref_index_at(int which) {\n-    assert(tag_at(which).has_bootstrap(), \"Corrupted constant pool\");\n-    return extract_high_short_from_int(*int_at_addr(which));\n+  u2 bootstrap_name_and_type_ref_index_at(int cp_index) {\n+    assert(tag_at(cp_index).has_bootstrap(), \"Corrupted constant pool\");\n+    return extract_high_short_from_int(*int_at_addr(cp_index));\n@@ -530,3 +530,3 @@\n-  u2 bootstrap_methods_attribute_index(int which) {\n-    assert(tag_at(which).has_bootstrap(), \"Corrupted constant pool\");\n-    return extract_low_short_from_int(*int_at_addr(which));\n+  u2 bootstrap_methods_attribute_index(int cp_index) {\n+    assert(tag_at(cp_index).has_bootstrap(), \"Corrupted constant pool\");\n+    return extract_low_short_from_int(*int_at_addr(cp_index));\n@@ -534,2 +534,2 @@\n-  int bootstrap_operand_base(int which) {\n-    int bsms_attribute_index = bootstrap_methods_attribute_index(which);\n+  int bootstrap_operand_base(int cp_index) {\n+    int bsms_attribute_index = bootstrap_methods_attribute_index(cp_index);\n@@ -575,2 +575,2 @@\n-  int bootstrap_operand_limit(int which) {\n-    int bsms_attribute_index = bootstrap_methods_attribute_index(which);\n+  int bootstrap_operand_limit(int cp_index) {\n+    int bsms_attribute_index = bootstrap_methods_attribute_index(cp_index);\n@@ -630,3 +630,3 @@\n-  u2 bootstrap_method_ref_index_at(int which) {\n-    assert(tag_at(which).has_bootstrap(), \"Corrupted constant pool\");\n-    int op_base = bootstrap_operand_base(which);\n+  u2 bootstrap_method_ref_index_at(int cp_index) {\n+    assert(tag_at(cp_index).has_bootstrap(), \"Corrupted constant pool\");\n+    int op_base = bootstrap_operand_base(cp_index);\n@@ -635,3 +635,3 @@\n-  u2 bootstrap_argument_count_at(int which) {\n-    assert(tag_at(which).has_bootstrap(), \"Corrupted constant pool\");\n-    int op_base = bootstrap_operand_base(which);\n+  u2 bootstrap_argument_count_at(int cp_index) {\n+    assert(tag_at(cp_index).has_bootstrap(), \"Corrupted constant pool\");\n+    int op_base = bootstrap_operand_base(cp_index);\n@@ -640,1 +640,1 @@\n-               int next_offset = bootstrap_operand_limit(which));\n+               int next_offset = bootstrap_operand_limit(cp_index));\n@@ -644,2 +644,2 @@\n-  u2 bootstrap_argument_index_at(int which, int j) {\n-    int op_base = bootstrap_operand_base(which);\n+  u2 bootstrap_argument_index_at(int cp_index, int j) {\n+    int op_base = bootstrap_operand_base(cp_index);\n@@ -688,2 +688,2 @@\n-  u2 name_ref_index_at(int which_nt);            \/\/ ==  low-order jshort of name_and_type_at(which_nt)\n-  u2 signature_ref_index_at(int which_nt);       \/\/ == high-order jshort of name_and_type_at(which_nt)\n+  u2 name_ref_index_at(int cp_index);            \/\/ ==  low-order jshort of name_and_type_at(cp_index)\n+  u2 signature_ref_index_at(int cp_index);       \/\/ == high-order jshort of name_and_type_at(cp_index)\n@@ -691,1 +691,1 @@\n-  BasicType basic_type_for_signature_at(int which) const;\n+  BasicType basic_type_for_signature_at(int cp_index) const;\n@@ -713,1 +713,1 @@\n-  constantTag constant_tag_at(int which);\n+  constantTag constant_tag_at(int cp_index);\n@@ -715,1 +715,1 @@\n-  BasicType basic_type_for_constant_at(int which);\n+  BasicType basic_type_for_constant_at(int cp_index);\n@@ -718,1 +718,1 @@\n-  oop resolve_constant_at(int index, TRAPS) {\n+  oop resolve_constant_at(int cp_index, TRAPS) {\n@@ -720,1 +720,1 @@\n-    return resolve_constant_at_impl(h_this, index, _no_index_sentinel, nullptr, THREAD);\n+    return resolve_constant_at_impl(h_this, cp_index, _no_index_sentinel, nullptr, THREAD);\n@@ -728,1 +728,1 @@\n-  oop resolve_possibly_cached_constant_at(int pool_index, TRAPS) {\n+  oop resolve_possibly_cached_constant_at(int cp_index, TRAPS) {\n@@ -730,1 +730,1 @@\n-    return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, nullptr, THREAD);\n+    return resolve_constant_at_impl(h_this, cp_index, _possible_index_sentinel, nullptr, THREAD);\n@@ -733,1 +733,1 @@\n-  oop find_cached_constant_at(int pool_index, bool& found_it, TRAPS) {\n+  oop find_cached_constant_at(int cp_index, bool& found_it, TRAPS) {\n@@ -735,1 +735,1 @@\n-    return resolve_constant_at_impl(h_this, pool_index, _possible_index_sentinel, &found_it, THREAD);\n+    return resolve_constant_at_impl(h_this, cp_index, _possible_index_sentinel, &found_it, THREAD);\n@@ -738,1 +738,1 @@\n-  void copy_bootstrap_arguments_at(int index,\n+  void copy_bootstrap_arguments_at(int cp_index,\n@@ -743,1 +743,1 @@\n-    copy_bootstrap_arguments_at_impl(h_this, index, start_arg, end_arg,\n+    copy_bootstrap_arguments_at_impl(h_this, cp_index, start_arg, end_arg,\n@@ -748,1 +748,1 @@\n-  bool klass_name_at_matches(const InstanceKlass* k, int which);\n+  bool klass_name_at_matches(const InstanceKlass* k, int cp_index);\n@@ -803,1 +803,1 @@\n-  const char* printable_name_at(int which) PRODUCT_RETURN0;\n+  const char* printable_name_at(int cp_index) PRODUCT_RETURN0;\n@@ -825,3 +825,3 @@\n-  jint klass_index_at(int which) {\n-    assert(tag_at(which).is_klass_index(), \"Corrupted constant pool\");\n-    return *int_at_addr(which);\n+  jint klass_index_at(int cp_index) {\n+    assert(tag_at(cp_index).is_klass_index(), \"Corrupted constant pool\");\n+    return *int_at_addr(cp_index);\n@@ -830,3 +830,3 @@\n-  jint string_index_at(int which) {\n-    assert(tag_at(which).is_string_index(), \"Corrupted constant pool\");\n-    return *int_at_addr(which);\n+  jint string_index_at(int cp_index) {\n+    assert(tag_at(cp_index).is_string_index(), \"Corrupted constant pool\");\n+    return *int_at_addr(cp_index);\n@@ -840,2 +840,2 @@\n-  static Klass* klass_at_impl(const constantPoolHandle& this_cp, int which, TRAPS);\n-  static oop string_at_impl(const constantPoolHandle& this_cp, int which, int obj_index, TRAPS);\n+  static Klass* klass_at_impl(const constantPoolHandle& this_cp, int cp_index, TRAPS);\n+  static oop string_at_impl(const constantPoolHandle& this_cp, int cp_index, int obj_index, TRAPS);\n@@ -848,1 +848,1 @@\n-  static oop resolve_constant_at_impl(const constantPoolHandle& this_cp, int index, int cache_index,\n+  static oop resolve_constant_at_impl(const constantPoolHandle& this_cp, int cp_index, int cache_index,\n@@ -850,1 +850,1 @@\n-  static void copy_bootstrap_arguments_at_impl(const constantPoolHandle& this_cp, int index,\n+  static void copy_bootstrap_arguments_at_impl(const constantPoolHandle& this_cp, int cp_index,\n@@ -856,1 +856,1 @@\n-  static void save_and_throw_exception(const constantPoolHandle& this_cp, int which, constantTag tag, TRAPS);\n+  static void save_and_throw_exception(const constantPoolHandle& this_cp, int cp_index, constantTag tag, TRAPS);\n@@ -864,1 +864,1 @@\n-  void copy_cp_to(int start_i, int end_i, const constantPoolHandle& to_cp, int to_i, TRAPS) {\n+  void copy_cp_to(int start_cpi, int end_cpi, const constantPoolHandle& to_cp, int to_cpi, TRAPS) {\n@@ -866,1 +866,1 @@\n-    copy_cp_to_impl(h_this, start_i, end_i, to_cp, to_i, THREAD);\n+    copy_cp_to_impl(h_this, start_cpi, end_cpi, to_cp, to_cpi, THREAD);\n@@ -868,2 +868,2 @@\n-  static void copy_cp_to_impl(const constantPoolHandle& from_cp, int start_i, int end_i, const constantPoolHandle& to_cp, int to_i, TRAPS);\n-  static void copy_entry_to(const constantPoolHandle& from_cp, int from_i, const constantPoolHandle& to_cp, int to_i);\n+  static void copy_cp_to_impl(const constantPoolHandle& from_cp, int start_cpi, int end_cpi, const constantPoolHandle& to_cp, int to_cpi, TRAPS);\n+  static void copy_entry_to(const constantPoolHandle& from_cp, int from_cpi, const constantPoolHandle& to_cp, int to_cpi);\n@@ -931,0 +931,4 @@\n+  \/\/ ResolvedFieldEntry getters\n+  inline ResolvedFieldEntry* resolved_field_entry_at(int field_index);\n+  inline int resolved_field_entries_length() const;\n+\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":195,"deletions":191,"binary":false,"changes":386,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -649,0 +650,13 @@\n+template <class T>\n+static Array<T>* initialize_resolved_entries_array(ClassLoaderData* loader_data, GrowableArray<T> entries, TRAPS) {\n+  Array<T>* resolved_entries;\n+  if (entries.length() != 0) {\n+    resolved_entries = MetadataFactory::new_array<T>(loader_data, entries.length(), CHECK_NULL);\n+    for (int i = 0; i < entries.length(); i++) {\n+      resolved_entries->at_put(i, entries.at(i));\n+    }\n+    return resolved_entries;\n+  }\n+  return nullptr;\n+}\n+\n@@ -653,0 +667,1 @@\n+                                     const GrowableArray<ResolvedFieldEntry> field_entries,\n@@ -658,10 +673,3 @@\n-  \/\/ Initialize ResolvedIndyEntry array with available data\n-  Array<ResolvedIndyEntry>* resolved_indy_entries;\n-  if (indy_entries.length()) {\n-    resolved_indy_entries = MetadataFactory::new_array<ResolvedIndyEntry>(loader_data, indy_entries.length(), CHECK_NULL);\n-    for (int i = 0; i < indy_entries.length(); i++) {\n-      resolved_indy_entries->at_put(i, indy_entries.at(i));\n-    }\n-  } else {\n-    resolved_indy_entries = nullptr;\n-  }\n+  \/\/ Initialize resolved entry arrays with available data\n+  Array<ResolvedFieldEntry>* resolved_field_entries = initialize_resolved_entries_array(loader_data, field_entries, CHECK_NULL);\n+  Array<ResolvedIndyEntry>* resolved_indy_entries = initialize_resolved_entries_array(loader_data, indy_entries, CHECK_NULL);\n@@ -670,1 +678,1 @@\n-              ConstantPoolCache(length, index_map, invokedynamic_map, resolved_indy_entries);\n+              ConstantPoolCache(length, index_map, invokedynamic_map, resolved_indy_entries, resolved_field_entries);\n@@ -723,0 +731,5 @@\n+  if (_resolved_field_entries != nullptr) {\n+    for (int i = 0; i < _resolved_field_entries->length(); i++) {\n+      resolved_field_entry_at(i)->remove_unshareable_info();\n+    }\n+  }\n@@ -736,1 +749,1 @@\n-    if (_resolved_indy_entries)\n+    if (_resolved_indy_entries) {\n@@ -738,0 +751,6 @@\n+      _resolved_indy_entries = nullptr;\n+    }\n+    if (_resolved_field_entries) {\n+      MetadataFactory::free_array<ResolvedFieldEntry>(data, _resolved_field_entries);\n+      _resolved_field_entries = nullptr;\n+    }\n@@ -839,0 +858,3 @@\n+  if (_resolved_field_entries != nullptr) {\n+    it->push(&_resolved_field_entries, MetaspaceClosure::_writable);\n+  }\n@@ -933,8 +955,2 @@\n-  for (int i = 0; i < resolved_indy_entries_length(); i++) {\n-    ResolvedIndyEntry* indy_entry = resolved_indy_entry_at(i);\n-    indy_entry->print_on(st);\n-    if (indy_entry->has_appendix()) {\n-      st->print(\"  appendix: \");\n-      constant_pool()->resolved_reference_from_indy(i)->print_on(st);\n-    }\n-  }\n+  print_resolved_field_entries(st);\n+  print_resolved_indy_entries(st);\n@@ -951,3 +967,14 @@\n-void ConstantPoolCache::print_resolved_indy_entries(outputStream* st)   const {\n-  for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n-    _resolved_indy_entries->at(i).print_on(st);\n+void ConstantPoolCache::print_resolved_field_entries(outputStream* st) const {\n+  for (int field_index = 0; field_index < resolved_field_entries_length(); field_index++) {\n+    resolved_field_entry_at(field_index)->print_on(st);\n+  }\n+}\n+\n+void ConstantPoolCache::print_resolved_indy_entries(outputStream* st) const {\n+  for (int indy_index = 0; indy_index < resolved_indy_entries_length(); indy_index++) {\n+    ResolvedIndyEntry* indy_entry = resolved_indy_entry_at(indy_index);\n+    indy_entry->print_on(st);\n+    if (indy_entry->has_appendix()) {\n+      st->print(\"  appendix: \");\n+      constant_pool()->resolved_reference_from_indy(indy_index)->print_on(st);\n+    }\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":50,"deletions":23,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+class ResolvedFieldEntry;\n@@ -419,1 +420,2 @@\n-  Array<ResolvedIndyEntry>* _resolved_indy_entries;\n+  Array<ResolvedIndyEntry>*  _resolved_indy_entries;\n+  Array<ResolvedFieldEntry>* _resolved_field_entries;\n@@ -430,1 +432,2 @@\n-                    Array<ResolvedIndyEntry>* indy_info);\n+                    Array<ResolvedIndyEntry>* indy_info,\n+                    Array<ResolvedFieldEntry>* field_entries);\n@@ -440,0 +443,1 @@\n+                                     const GrowableArray<ResolvedFieldEntry> field_entries,\n@@ -455,0 +459,5 @@\n+  Array<ResolvedFieldEntry>* resolved_field_entries()          { return _resolved_field_entries; }\n+  inline ResolvedFieldEntry* resolved_field_entry_at(int field_index) const;\n+  inline int resolved_field_entries_length() const;\n+  void print_resolved_field_entries(outputStream* st) const;\n+\n@@ -461,2 +470,3 @@\n-  static ByteSize resolved_references_offset()   { return byte_offset_of(ConstantPoolCache, _resolved_references); }\n-  static ByteSize invokedynamic_entries_offset() { return byte_offset_of(ConstantPoolCache, _resolved_indy_entries); }\n+  static ByteSize resolved_references_offset()     { return byte_offset_of(ConstantPoolCache, _resolved_references);    }\n+  static ByteSize invokedynamic_entries_offset()   { return byte_offset_of(ConstantPoolCache, _resolved_indy_entries);  }\n+  static ByteSize field_entries_offset()           { return byte_offset_of(ConstantPoolCache, _resolved_field_entries); }\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -345,1 +345,1 @@\n-Klass* FlatArrayKlass::array_klass(int n, TRAPS) {\n+ArrayKlass* FlatArrayKlass::array_klass(int n, TRAPS) {\n@@ -362,2 +362,1 @@\n-        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, false, true, CHECK_NULL);\n-        ObjArrayKlass* ak = ObjArrayKlass::cast(k);\n+        ObjArrayKlass* ak = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, false, true, CHECK_NULL);\n@@ -377,1 +376,1 @@\n-Klass* FlatArrayKlass::array_klass_or_null(int n) {\n+ArrayKlass* FlatArrayKlass::array_klass_or_null(int n) {\n@@ -392,1 +391,1 @@\n-Klass* FlatArrayKlass::array_klass(TRAPS) {\n+ArrayKlass* FlatArrayKlass::array_klass(TRAPS) {\n@@ -396,1 +395,1 @@\n-Klass* FlatArrayKlass::array_klass_or_null() {\n+ArrayKlass* FlatArrayKlass::array_klass_or_null() {\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-  virtual Klass* array_klass(int n, TRAPS);\n-  virtual Klass* array_klass_or_null(int n);\n+  virtual ArrayKlass* array_klass(int n, TRAPS);\n+  virtual ArrayKlass* array_klass_or_null(int n);\n@@ -55,2 +55,2 @@\n-  virtual Klass* array_klass(TRAPS);\n-  virtual Klass* array_klass_or_null();\n+  virtual ArrayKlass* array_klass(TRAPS);\n+  virtual ArrayKlass* array_klass_or_null();\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1389,1 +1389,1 @@\n-    case Bytecodes::_withfield:        do_withfield(itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n+    case Bytecodes::_withfield:        do_withfield(itr->get_index_u2(), itr->bci(), itr->code()); break;\n@@ -1604,4 +1604,12 @@\n-    case Bytecodes::_getstatic:         do_field(true,  true,  itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n-    case Bytecodes::_putstatic:         do_field(false, true,  itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n-    case Bytecodes::_getfield:          do_field(true,  false, itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n-    case Bytecodes::_putfield:          do_field(false, false, itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n+    case Bytecodes::_getstatic:\n+      do_field(true,  true,  itr->get_index_u2(), itr->bci(), itr->code());\n+      break;\n+    case Bytecodes::_putstatic:\n+      do_field(false,  true,  itr->get_index_u2(), itr->bci(), itr->code());\n+      break;\n+    case Bytecodes::_getfield:\n+      do_field(true,  false,  itr->get_index_u2(), itr->bci(), itr->code());\n+      break;\n+    case Bytecodes::_putfield:\n+      do_field(false,  false,  itr->get_index_u2(), itr->bci(), itr->code());\n+      break;\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1617,1 +1617,1 @@\n-  Klass* ak = array_klass(n, CHECK_NULL);\n+  ArrayKlass* ak = array_klass(n, CHECK_NULL);\n@@ -1681,1 +1681,1 @@\n-Klass* InstanceKlass::array_klass(int n, TRAPS) {\n+ArrayKlass* InstanceKlass::array_klass(int n, TRAPS) {\n@@ -1704,1 +1704,1 @@\n-Klass* InstanceKlass::array_klass_or_null(int n) {\n+ArrayKlass* InstanceKlass::array_klass_or_null(int n) {\n@@ -1714,1 +1714,1 @@\n-Klass* InstanceKlass::array_klass(TRAPS) {\n+ArrayKlass* InstanceKlass::array_klass(TRAPS) {\n@@ -1718,1 +1718,1 @@\n-Klass* InstanceKlass::array_klass_or_null() {\n+ArrayKlass* InstanceKlass::array_klass_or_null() {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -404,0 +404,1 @@\n+  void set_array_klasses(ArrayKlass* k) { _array_klasses = k; }\n@@ -1156,2 +1157,2 @@\n-  virtual Klass* array_klass(int n, TRAPS);\n-  virtual Klass* array_klass_or_null(int n);\n+  virtual ArrayKlass* array_klass(int n, TRAPS);\n+  virtual ArrayKlass* array_klass_or_null(int n);\n@@ -1160,2 +1161,2 @@\n-  virtual Klass* array_klass(TRAPS);\n-  virtual Klass* array_klass_or_null();\n+  virtual ArrayKlass* array_klass(TRAPS);\n+  virtual ArrayKlass* array_klass_or_null();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-  virtual Klass* array_klass(int rank, TRAPS) = 0;\n+  virtual ArrayKlass* array_klass(int rank, TRAPS) = 0;\n@@ -567,1 +567,1 @@\n-  virtual Klass* array_klass(TRAPS) = 0;\n+  virtual ArrayKlass* array_klass(TRAPS) = 0;\n@@ -570,2 +570,2 @@\n-  virtual Klass* array_klass_or_null(int rank) = 0;\n-  virtual Klass* array_klass_or_null() = 0;\n+  virtual ArrayKlass* array_klass_or_null(int rank) = 0;\n+  virtual ArrayKlass* array_klass_or_null() = 0;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-  Klass* ld_klass = lower_dimension();\n+  ArrayKlass* ld_klass = lower_dimension();\n@@ -222,2 +222,1 @@\n-      ArrayKlass* ak = ArrayKlass::cast(ld_klass);\n-      oop sub_array = ak->multi_allocate(rank-1, &sizes[1], CHECK_NULL);\n+      oop sub_array = ld_klass->multi_allocate(rank-1, &sizes[1], CHECK_NULL);\n@@ -352,1 +351,2 @@\n-Klass* ObjArrayKlass::array_klass(int n, TRAPS) {\n+ArrayKlass* ObjArrayKlass::array_klass(int n, TRAPS) {\n+\n@@ -369,1 +369,1 @@\n-        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this,\n+        ObjArrayKlass* ak = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this,\n@@ -371,1 +371,0 @@\n-        ObjArrayKlass* ak = ObjArrayKlass::cast(k);\n@@ -380,1 +379,1 @@\n-  ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());\n+  ObjArrayKlass *ak = higher_dimension();\n@@ -385,1 +384,1 @@\n-Klass* ObjArrayKlass::array_klass_or_null(int n) {\n+ArrayKlass* ObjArrayKlass::array_klass_or_null(int n) {\n@@ -396,1 +395,1 @@\n-  ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());\n+  ObjArrayKlass *ak = higher_dimension();\n@@ -400,1 +399,1 @@\n-Klass* ObjArrayKlass::array_klass(TRAPS) {\n+ArrayKlass* ObjArrayKlass::array_klass(TRAPS) {\n@@ -404,1 +403,1 @@\n-Klass* ObjArrayKlass::array_klass_or_null() {\n+ArrayKlass* ObjArrayKlass::array_klass_or_null() {\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -92,2 +92,2 @@\n-  virtual Klass* array_klass(int n, TRAPS);\n-  virtual Klass* array_klass_or_null(int n);\n+  virtual ArrayKlass* array_klass(int n, TRAPS);\n+  virtual ArrayKlass* array_klass_or_null(int n);\n@@ -96,2 +96,2 @@\n-  virtual Klass* array_klass(TRAPS);\n-  virtual Klass* array_klass_or_null();\n+  virtual ArrayKlass* array_klass(TRAPS);\n+  virtual ArrayKlass* array_klass_or_null();\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"resolvedFieldEntry.hpp\"\n+\n+void ResolvedFieldEntry::print_on(outputStream* st) const {\n+  st->print_cr(\"Field Entry:\");\n+\n+  if (field_holder() != nullptr) {\n+    st->print_cr(\" - Holder: \" INTPTR_FORMAT \" %s\", p2i(field_holder()), field_holder()->external_name());\n+  } else {\n+    st->print_cr(\"- Holder: null\");\n+  }\n+  st->print_cr(\" - Offset: %d\", field_offset());\n+  st->print_cr(\" - Field Index: %d\", field_index());\n+  st->print_cr(\" - CP Index: %d\", constant_pool_index());\n+  st->print_cr(\" - TOS: %s\", type2name(as_BasicType((TosState)tos_state())));\n+  st->print_cr(\" - Is Final: %d\", is_final());\n+  st->print_cr(\" - Is Volatile: %d\", is_volatile());\n+  st->print_cr(\" - Is Flat: %d\", is_flat());\n+  st->print_cr(\" - Is Null Free Inline Type: %d\", is_null_free_inline_type());\n+  st->print_cr(\" - Get Bytecode: %s\", Bytecodes::name((Bytecodes::Code)get_code()));\n+  st->print_cr(\" - Put Bytecode: %s\", Bytecodes::name((Bytecodes::Code)put_code()));\n+}\n+\n+void ResolvedFieldEntry::remove_unshareable_info() {\n+  u2 saved_cpool_index = _cpool_index;\n+  memset(this, 0, sizeof(*this));\n+  _cpool_index = saved_cpool_index;\n+}\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_RESOLVEDFIELDENTRY_HPP\n+#define SHARE_OOPS_RESOLVEDFIELDENTRY_HPP\n+\n+#include \"interpreter\/bytecodes.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/sizes.hpp\"\n+\n+\/\/ ResolvedFieldEntry contains the resolution information for field related bytecodes like\n+\/\/ like getfield, putfield, getstatic, and putstatic. A member of this class can be initialized\n+\/\/ with the constant pool index associated with the bytecode before any resolution is done, where\n+\/\/ \"resolution\" refers to populating the getcode and putcode fields and other relevant information.\n+\/\/ The field's type (TOS), offset, holder klass, and index within that class can all be acquired\n+\/\/ together and are used to populate this structure. These entries are contained\n+\/\/ within the ConstantPoolCache and are accessed with indices added to the invokedynamic bytecode after\n+\/\/ rewriting.\n+\n+\/\/ Field bytecodes start with a constant pool index as their operate, which is then rewritten to\n+\/\/ a \"field index\", which is an index into the array of ResolvedFieldEntry.\n+\n+\/\/class InstanceKlass;\n+class ResolvedFieldEntry {\n+  friend class VMStructs;\n+\n+  InstanceKlass* _field_holder; \/\/ Field holder klass\n+  int _field_offset;            \/\/ Field offset in bytes\n+  u2 _field_index;              \/\/ Index into field information in holder InstanceKlass\n+  u2 _cpool_index;              \/\/ Constant pool index\n+  u1 _tos_state;                      \/\/ TOS state\n+  u1 _flags;                    \/\/ Flags: [0000|is_null_free_inline_type|is_flat|is_final|is_volatile]\n+  u1 _get_code, _put_code;      \/\/ Get and Put bytecodes of the field\n+\n+public:\n+  ResolvedFieldEntry(u2 cpi) :\n+    _field_holder(nullptr),\n+    _field_offset(0),\n+    _field_index(0),\n+    _cpool_index(cpi),\n+    _tos_state(0),\n+    _flags(0),\n+    _get_code(0),\n+    _put_code(0) {}\n+  ResolvedFieldEntry() :\n+    ResolvedFieldEntry(0) {}\n+\n+  \/\/ Bit shift to get flags\n+  \/\/ Note: Only two flags exists at the moment but more could be added\n+  enum {\n+      is_volatile_shift     = 0,\n+      is_final_shift        = 1, \/\/ unused\n+      is_flat_shift         = 2,\n+      is_null_free_inline_type_shift = 3,\n+  };\n+\n+  \/\/ Getters\n+  InstanceKlass* field_holder() const { return _field_holder; }\n+  int field_offset()            const { return _field_offset; }\n+  u2 field_index()              const { return _field_index;  }\n+  u2 constant_pool_index()      const { return _cpool_index;  }\n+  u1 tos_state()                const { return _tos_state;    }\n+  u1 get_code()                 const { return Atomic::load_acquire(&_get_code);      }\n+  u1 put_code()                 const { return Atomic::load_acquire(&_put_code);      }\n+  bool is_final()               const { return (_flags & (1 << is_final_shift))    != 0; }\n+  bool is_volatile ()           const { return (_flags & (1 << is_volatile_shift)) != 0; }\n+  bool is_flat()                const { return (_flags & (1 << is_flat_shift))     != 0; }\n+  bool is_null_free_inline_type() const { return (_flags & (1 << is_null_free_inline_type_shift)) != 0; }\n+  bool is_resolved(Bytecodes::Code code) const {\n+    switch(code) {\n+    case Bytecodes::_getstatic:\n+    case Bytecodes::_getfield:\n+      return (get_code() == code);\n+    case Bytecodes::_putstatic:\n+    case Bytecodes::_putfield:\n+    case Bytecodes::_withfield:\n+      return (put_code() == code);\n+    default:\n+      ShouldNotReachHere();\n+      return false;\n+    }\n+  }\n+\n+  \/\/ Printing\n+  void print_on(outputStream* st) const;\n+\n+  void set_flags(bool is_final, bool is_volatile, bool is_flat, bool is_null_free_inline_type) {\n+    u1 new_flags = (static_cast<u1>(is_final) << static_cast<u1>(is_final_shift)) | static_cast<u1>(is_volatile) |\n+      (static_cast<u1>(is_flat) << static_cast<u1>(is_flat_shift)) |\n+      (static_cast<u1>(is_null_free_inline_type) << static_cast<u1>(is_null_free_inline_type_shift));\n+    _flags = new_flags;\n+  }\n+\n+  inline void set_bytecode(u1* code, u1 new_code) {\n+  #ifdef ASSERT\n+    \/\/ Read once.\n+    volatile Bytecodes::Code c = (Bytecodes::Code)*code;\n+    assert(c == 0 || c == new_code || new_code == 0, \"update must be consistent\");\n+  #endif\n+    Atomic::release_store(code, new_code);\n+  }\n+\n+  \/\/ Populate the strucutre with resolution information\n+  void fill_in(InstanceKlass* klass, intx offset, int index, int tos_state, u1 b1, u1 b2) {\n+    _field_holder = klass;\n+    _field_offset = offset;\n+    _field_index = index;\n+    _tos_state = tos_state;\n+\n+    \/\/ These must be set after the other fields\n+    set_bytecode(&_get_code, b1);\n+    set_bytecode(&_put_code, b2);\n+  }\n+\n+  \/\/ CDS\n+  void remove_unshareable_info();\n+\n+  \/\/ Offsets\n+  static ByteSize field_holder_offset() { return byte_offset_of(ResolvedFieldEntry, _field_holder); }\n+  static ByteSize field_offset_offset() { return byte_offset_of(ResolvedFieldEntry, _field_offset); }\n+  static ByteSize field_index_offset()  { return byte_offset_of(ResolvedFieldEntry, _field_index);  }\n+  static ByteSize get_code_offset()     { return byte_offset_of(ResolvedFieldEntry, _get_code);     }\n+  static ByteSize put_code_offset()     { return byte_offset_of(ResolvedFieldEntry, _put_code);     }\n+  static ByteSize type_offset()         { return byte_offset_of(ResolvedFieldEntry, _tos_state);    }\n+  static ByteSize flags_offset()        { return byte_offset_of(ResolvedFieldEntry, _flags);        }\n+\n+};\n+\n+#endif \/\/SHARE_OOPS_RESOLVEDFIELDENTRY_HPP\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -173,1 +173,1 @@\n-Klass* TypeArrayKlass::array_klass(int n, TRAPS) {\n+ArrayKlass* TypeArrayKlass::array_klass(int n, TRAPS) {\n@@ -200,1 +200,1 @@\n-  ObjArrayKlass* h_ak = ObjArrayKlass::cast(higher_dimension());\n+  ObjArrayKlass* h_ak = higher_dimension();\n@@ -206,1 +206,1 @@\n-Klass* TypeArrayKlass::array_klass_or_null(int n) {\n+ArrayKlass* TypeArrayKlass::array_klass_or_null(int n) {\n@@ -217,1 +217,1 @@\n-  ObjArrayKlass* h_ak = ObjArrayKlass::cast(higher_dimension());\n+  ObjArrayKlass* h_ak = higher_dimension();\n@@ -221,1 +221,1 @@\n-Klass* TypeArrayKlass::array_klass(TRAPS) {\n+ArrayKlass* TypeArrayKlass::array_klass(TRAPS) {\n@@ -225,1 +225,1 @@\n-Klass* TypeArrayKlass::array_klass_or_null() {\n+ArrayKlass* TypeArrayKlass::array_klass_or_null() {\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  bool do_reduce_allocation_merges = ReduceAllocationMerges;\n+  bool do_reduce_allocation_merges = ReduceAllocationMerges && EliminateAllocations;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2815,1 +2815,1 @@\n-        igvn.set_delay_transform(false);\n+        if (failing()) return;\n@@ -2817,0 +2817,1 @@\n+        igvn.set_delay_transform(false);\n@@ -4855,1 +4856,4 @@\n-    _compile(nullptr), _log(nullptr), _phase_name(name), _dolog(CITimeVerbose)\n+    _compile(Compile::current()),\n+    _log(nullptr),\n+    _phase_name(name),\n+    _dolog(CITimeVerbose)\n@@ -4857,0 +4861,1 @@\n+  assert(_compile != nullptr, \"sanity check\");\n@@ -4858,1 +4863,0 @@\n-    _compile = Compile::current();\n@@ -4876,1 +4880,1 @@\n-    Compile::current()->print_missing_nodes();\n+    _compile->print_missing_nodes();\n@@ -5420,1 +5424,10 @@\n-          assert(in_hash, \"node should be in igvn hash table\");\n+#ifdef ASSERT\n+          if (!in_hash) {\n+            tty->print_cr(\"current graph:\");\n+            n->dump_bfs(MaxNodeLimit, nullptr, \"S$\");\n+            tty->cr();\n+            tty->print_cr(\"erroneous node:\");\n+            n->dump();\n+            assert(false, \"node should be in igvn hash table\");\n+          }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  _nodes(C->comp_arena(), ReduceAllocationMerges ? C->unique()*1.10 : C->unique(), C->unique(), nullptr),\n+  _nodes(C->comp_arena(), C->do_reduce_allocation_merges() ? C->unique()*1.10 : C->unique(), C->unique(), nullptr),\n@@ -412,1 +412,1 @@\n-  if (ReduceAllocationMerges && reducible_merges.size() > 0) {\n+  if (reducible_merges.size() > 0) {\n@@ -516,2 +516,3 @@\n-  \/\/ method we might have disabled the compilation and be retrying\n-  \/\/ with RAM disabled.\n+  \/\/ method we might have disabled the compilation and be retrying with RAM\n+  \/\/ disabled.\n+  \/\/ If EliminateAllocations is False, there is no point in reducing merges.\n@@ -736,1 +737,6 @@\n-      assert(false, \"Unexpected use of reducible Phi.\");\n+#ifdef ASSERT\n+      ophi->dump(-3);\n+      assert(false, \"Unexpected user of reducible Phi %d -> %d:%s\", ophi->_idx, use->_idx, use->Name());\n+#endif\n+      _compile->record_failure(C2Compiler::retry_no_reduce_allocation_merges());\n+      return;\n@@ -746,1 +752,1 @@\n-  Unique_Node_List ideal_nodes;\n+  if (!C->do_reduce_allocation_merges()) return;\n@@ -748,0 +754,1 @@\n+  Unique_Node_List ideal_nodes;\n@@ -2344,1 +2351,1 @@\n-        if (ReduceAllocationMerges && use_n->is_Phi() && can_reduce_phi(use_n->as_Phi())) {\n+        if (use_n->is_Phi() && can_reduce_phi(use_n->as_Phi())) {\n@@ -3972,0 +3979,14 @@\n+#ifdef ASSERT\n+  \/\/ At this point reducible Phis shouldn't have AddP users anymore; only SafePoints.\n+  for (uint i = 0; i < reducible_merges.size(); i++) {\n+    Node* phi = reducible_merges.at(i);\n+    for (DUIterator_Fast jmax, j = phi->fast_outs(jmax); j < jmax; j++) {\n+      Node* use = phi->fast_out(j);\n+      if (!use->is_SafePoint()) {\n+        phi->dump(-3);\n+        assert(false, \"Unexpected user of reducible Phi -> %s\", use->Name());\n+      }\n+    }\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1873,1 +1873,1 @@\n-                if (prev != nullptr) {\n+                if (prev != nullptr && get_ctrl(prev) == x_ctrl) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1030,1 +1030,7 @@\n-      case Bytecodes::_withfield       :  \/\/ fall through\n+      case Bytecodes::_withfield       : {\/\/ fall through\n+        int field_index = Bytes::get_native_u2(bcp+1);\n+        u2 pool_index = mh->constants()->resolved_field_entry_at(field_index)->constant_pool_index();\n+        assert(pool_index < mh->constants()->length(), \"sanity check\");\n+        Bytes::put_Java_u2((address)(p+1), pool_index);     \/\/ java byte ordering\n+        break;\n+      }\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1985,0 +1985,18 @@\n+WB_ENTRY(jint, WB_getFieldEntriesLength(JNIEnv* env, jobject wb, jclass klass))\n+  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  ConstantPool* cp = ik->constants();\n+  if (cp->cache() == nullptr) {\n+    return -1;\n+  }\n+  return cp->resolved_field_entries_length();\n+WB_END\n+\n+WB_ENTRY(jint, WB_getFieldCPIndex(JNIEnv* env, jobject wb, jclass klass, jint index))\n+  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  ConstantPool* cp = ik->constants();\n+  if (cp->cache() == NULL) {\n+      return -1;\n+  }\n+  return cp->resolved_field_entry_at(index)->constant_pool_index();\n+WB_END\n+\n@@ -2885,0 +2903,2 @@\n+  {CC\"getFieldEntriesLength0\", CC\"(Ljava\/lang\/Class;)I\",  (void*)&WB_getFieldEntriesLength},\n+  {CC\"getFieldCPIndex0\",    CC\"(Ljava\/lang\/Class;I)I\", (void*)&WB_getFieldCPIndex},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4142,1 +4142,1 @@\n-#ifdef COMPILER2\n+#if COMPILER2_OR_JVMCI\n@@ -4163,1 +4163,1 @@\n-#endif \/\/ COMPILER2\n+#endif \/\/ COMPILER2_OR_JVMCI\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1220,6 +1220,6 @@\n-       case T_INT:     return IntegerBoxCache::singleton(THREAD)->lookup_raw(value->get_int(), cache_init_error);\n-       case T_CHAR:    return CharacterBoxCache::singleton(THREAD)->lookup_raw(value->get_int(), cache_init_error);\n-       case T_SHORT:   return ShortBoxCache::singleton(THREAD)->lookup_raw(value->get_int(), cache_init_error);\n-       case T_BYTE:    return ByteBoxCache::singleton(THREAD)->lookup_raw(value->get_int(), cache_init_error);\n-       case T_BOOLEAN: return BooleanBoxCache::singleton(THREAD)->lookup_raw(value->get_int(), cache_init_error);\n-       case T_LONG:    return LongBoxCache::singleton(THREAD)->lookup_raw(value->get_int(), cache_init_error);\n+       case T_INT:     return IntegerBoxCache::singleton(THREAD)->lookup_raw(value->get_intptr(), cache_init_error);\n+       case T_CHAR:    return CharacterBoxCache::singleton(THREAD)->lookup_raw(value->get_intptr(), cache_init_error);\n+       case T_SHORT:   return ShortBoxCache::singleton(THREAD)->lookup_raw(value->get_intptr(), cache_init_error);\n+       case T_BYTE:    return ByteBoxCache::singleton(THREAD)->lookup_raw(value->get_intptr(), cache_init_error);\n+       case T_BOOLEAN: return BooleanBoxCache::singleton(THREAD)->lookup_raw(value->get_intptr(), cache_init_error);\n+       case T_LONG:    return LongBoxCache::singleton(THREAD)->lookup_raw(value->get_intptr(), cache_init_error);\n@@ -1249,2 +1249,1 @@\n-      intptr_t init_value = StackValue::create_stack_value(fr, reg_map, sv->is_init())->get_int();\n-      jint is_init = (jint)*((jint*)&init_value);\n+      jint is_init = StackValue::create_stack_value(fr, reg_map, sv->is_init())->get_jint();\n@@ -1279,1 +1278,1 @@\n-#ifdef COMPILER2\n+#if COMPILER2_OR_JVMCI\n@@ -1287,1 +1286,1 @@\n-#endif \/\/ COMPILER2\n+#endif \/\/ COMPILER2_OR_JVMCI\n@@ -1376,1 +1375,1 @@\n-static void byte_array_put(typeArrayOop obj, intptr_t val, int index, int byte_count) {\n+static void byte_array_put(typeArrayOop obj, StackValue* value, int index, int byte_count) {\n@@ -1379,1 +1378,1 @@\n-      obj->byte_at_put(index, (jbyte) *((jint *) &val));\n+      obj->byte_at_put(index, (jbyte) value->get_jint());\n@@ -1382,1 +1381,1 @@\n-      *((jshort *) check_alignment_get_addr(obj, index, 2)) = (jshort) *((jint *) &val);\n+      *((jshort *) check_alignment_get_addr(obj, index, 2)) = (jshort) value->get_jint();\n@@ -1385,1 +1384,1 @@\n-      *((jint *) check_alignment_get_addr(obj, index, 4)) = (jint) *((jint *) &val);\n+      *((jint *) check_alignment_get_addr(obj, index, 4)) = value->get_jint();\n@@ -1388,1 +1387,1 @@\n-      *((jlong *) check_alignment_get_addr(obj, index, 8)) = (jlong) *((jlong *) &val);\n+      *((jlong *) check_alignment_get_addr(obj, index, 8)) = (jlong) value->get_intptr();\n@@ -1400,1 +1399,0 @@\n-  intptr_t val;\n@@ -1410,1 +1408,1 @@\n-      jlong res = (jlong)low->get_int();\n+      jlong res = (jlong)low->get_intptr();\n@@ -1412,1 +1410,1 @@\n-      jlong res = jlong_from((jint)value->get_int(), (jint)low->get_int());\n+      jlong res = jlong_from(value->get_jint(), low->get_jint());\n@@ -1418,1 +1416,0 @@\n-    \/\/ Have to cast to INT (32 bits) pointer to avoid little\/big-endian problem.\n@@ -1439,1 +1436,1 @@\n-        jlong res = (jlong)low->get_int();\n+        jlong res = (jlong)low->get_intptr();\n@@ -1441,1 +1438,1 @@\n-        jlong res = jlong_from((jint)value->get_int(), (jint)low->get_int());\n+        jlong res = jlong_from(value->get_jint(), low->get_jint());\n@@ -1443,2 +1440,2 @@\n-        obj->int_at_put(index, (jint)*((jint*)&res));\n-        obj->int_at_put(++index, (jint)*(((jint*)&res) + 1));\n+        obj->int_at_put(index, *(jint*)&res);\n+        obj->int_at_put(++index, *((jint*)&res + 1));\n@@ -1446,2 +1443,1 @@\n-        val = value->get_int();\n-        obj->int_at_put(index, (jint)*((jint*)&val));\n+        obj->int_at_put(index, value->get_jint());\n@@ -1454,2 +1450,1 @@\n-      val = value->get_int();\n-      obj->short_at_put(index, (jshort)*((jint*)&val));\n+      obj->short_at_put(index, (jshort)value->get_jint());\n@@ -1460,2 +1455,1 @@\n-      val = value->get_int();\n-      obj->char_at_put(index, (jchar)*((jint*)&val));\n+      obj->char_at_put(index, (jchar)value->get_jint());\n@@ -1466,2 +1460,1 @@\n-      \/\/ The value we get is erased as a regular int. We will need to find its actual byte count 'by hand'.\n-      val = value->get_int();\n+      \/\/ The value we get is erased as a regular int. We will need to find its actual byte count 'by hand'.\n@@ -1470,1 +1463,1 @@\n-      byte_array_put(obj, val, index, byte_count);\n+      byte_array_put(obj, value, index, byte_count);\n@@ -1477,1 +1470,1 @@\n-      obj->byte_at_put(index, (jbyte)*((jint*)&val));\n+      obj->byte_at_put(index, (jbyte)value->get_jint());\n@@ -1484,2 +1477,1 @@\n-      val = value->get_int();\n-      obj->bool_at_put(index, (jboolean)*((jint*)&val));\n+      obj->bool_at_put(index, (jboolean)value->get_jint());\n@@ -1557,1 +1549,0 @@\n-    intptr_t val;\n@@ -1567,1 +1558,0 @@\n-      \/\/ Have to cast to INT (32 bits) pointer to avoid little\/big-endian problem.\n@@ -1591,2 +1581,1 @@\n-          val = value->get_int();\n-          obj->int_field_put(offset, (jint)*((jint*)&val));\n+          obj->int_field_put(offset, value->get_jint());\n@@ -1602,1 +1591,1 @@\n-        jlong res = (jlong)low->get_int();\n+        jlong res = (jlong)low->get_intptr();\n@@ -1604,1 +1593,1 @@\n-        jlong res = jlong_from((jint)value->get_int(), (jint)low->get_int());\n+        jlong res = jlong_from(value->get_jint(), low->get_jint());\n@@ -1612,2 +1601,1 @@\n-        val = value->get_int();\n-        obj->short_field_put(offset, (jshort)*((jint*)&val));\n+        obj->short_field_put(offset, (jshort)value->get_jint());\n@@ -1618,2 +1606,1 @@\n-        val = value->get_int();\n-        obj->char_field_put(offset, (jchar)*((jint*)&val));\n+        obj->char_field_put(offset, (jchar)value->get_jint());\n@@ -1624,2 +1611,1 @@\n-        val = value->get_int();\n-        obj->byte_field_put(offset, (jbyte)*((jint*)&val));\n+        obj->byte_field_put(offset, (jbyte)value->get_jint());\n@@ -1630,2 +1616,1 @@\n-        val = value->get_int();\n-        obj->bool_field_put(offset, (jboolean)*((jint*)&val));\n+        obj->bool_field_put(offset, (jboolean)value->get_jint());\n@@ -1680,1 +1665,1 @@\n-#ifdef COMPILER2\n+#if COMPILER2_OR_JVMCI\n@@ -1700,1 +1685,1 @@\n-#endif \/* !COMPILER2 *\/\n+#endif \/* !COMPILER2_OR_JVMCI *\/\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":36,"deletions":51,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -253,2 +253,1 @@\n-      intptr_t is_init_value = StackValue::create_stack_value(fr, reg_map, ov->is_init())->get_int();\n-      jint is_init = (jint)*((jint*)&is_init_value);\n+      jint is_init = StackValue::create_stack_value(fr, reg_map, ov->is_init())->get_jint();\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -210,2 +211,2 @@\n-  volatile_nonstatic_field(ArrayKlass,         _higher_dimension,                             Klass*)                                \\\n-  volatile_nonstatic_field(ArrayKlass,         _lower_dimension,                              Klass*)                                \\\n+  volatile_nonstatic_field(ArrayKlass,         _higher_dimension,                             ObjArrayKlass*)                        \\\n+  volatile_nonstatic_field(ArrayKlass,         _lower_dimension,                              ArrayKlass*)                           \\\n@@ -228,0 +229,2 @@\n+  nonstatic_field(ConstantPoolCache,           _resolved_field_entries,                       Array<ResolvedFieldEntry>*)            \\\n+  nonstatic_field(ResolvedFieldEntry,          _cpool_index,                                  u2)                                    \\\n@@ -484,0 +487,2 @@\n+  nonstatic_field(Array<ResolvedFieldEntry>,   _length,                                       int)                                   \\\n+  nonstatic_field(Array<ResolvedFieldEntry>,   _data[0],                                      ResolvedFieldEntry)                    \\\n@@ -967,8 +972,9 @@\n-  nonstatic_field(Array<int>,                         _length,                                int)                                   \\\n-  unchecked_nonstatic_field(Array<int>,               _data,                                  sizeof(int))                           \\\n-  unchecked_nonstatic_field(Array<u1>,                _data,                                  sizeof(u1))                            \\\n-  unchecked_nonstatic_field(Array<u2>,                _data,                                  sizeof(u2))                            \\\n-  unchecked_nonstatic_field(Array<Method*>,           _data,                                  sizeof(Method*))                       \\\n-  unchecked_nonstatic_field(Array<Klass*>,            _data,                                  sizeof(Klass*))                        \\\n-  unchecked_nonstatic_field(Array<ResolvedIndyEntry>, _data,                                  sizeof(ResolvedIndyEntry))             \\\n-  unchecked_nonstatic_field(Array<Array<u1>*>,        _data,                                  sizeof(Array<u1>*))                    \\\n+  nonstatic_field(Array<int>,                          _length,                               int)                                   \\\n+  unchecked_nonstatic_field(Array<int>,                _data,                                 sizeof(int))                           \\\n+  unchecked_nonstatic_field(Array<u1>,                 _data,                                 sizeof(u1))                            \\\n+  unchecked_nonstatic_field(Array<u2>,                 _data,                                 sizeof(u2))                            \\\n+  unchecked_nonstatic_field(Array<Method*>,            _data,                                 sizeof(Method*))                       \\\n+  unchecked_nonstatic_field(Array<Klass*>,             _data,                                 sizeof(Klass*))                        \\\n+  unchecked_nonstatic_field(Array<ResolvedFieldEntry>, _data,                                 sizeof(ResolvedFieldEntry))            \\\n+  unchecked_nonstatic_field(Array<ResolvedIndyEntry>,  _data,                                 sizeof(ResolvedIndyEntry))             \\\n+  unchecked_nonstatic_field(Array<Array<u1>*>,         _data,                                 sizeof(Array<u1>*))                    \\\n@@ -1907,0 +1913,1 @@\n+            declare_type(Array<ResolvedFieldEntry>, MetaspaceObj)         \\\n@@ -1925,0 +1932,1 @@\n+  declare_toplevel_type(ResolvedFieldEntry)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.Supplier;\n@@ -37,0 +38,1 @@\n+import java.util.Map;\n@@ -46,1 +48,2 @@\n-import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ReferencedKeySet;\n+import jdk.internal.util.ReferenceKey;\n@@ -231,1 +234,7 @@\n-    static final ConcurrentWeakInternSet<MethodType> internTable = new ConcurrentWeakInternSet<>();\n+    static final ReferencedKeySet<MethodType> internTable =\n+        ReferencedKeySet.create(false, true, new Supplier<>() {\n+            @Override\n+            public Map<ReferenceKey<MethodType>, ReferenceKey<MethodType>> get() {\n+                return new ConcurrentHashMap<>(512);\n+            }\n+        });\n@@ -409,1 +418,1 @@\n-        return internTable.add(mt);\n+        return internTable.intern(mt);\n@@ -887,4 +896,0 @@\n-    \/\/ This implementation may also return true if x is a WeakEntry containing\n-    \/\/ a method type that is equal to this. This is an internal implementation\n-    \/\/ detail to allow for faster method type lookups.\n-    \/\/ See ConcurrentWeakInternSet.WeakEntry#equals(Object)\n@@ -899,4 +904,0 @@\n-        if (x instanceof ConcurrentWeakInternSet.WeakEntry<?> e\n-                && e.get() instanceof MethodType mt) {\n-            return equals(mt);\n-        }\n@@ -1401,108 +1402,0 @@\n-\n-    \/**\n-     * Simple implementation of weak concurrent intern set.\n-     *\n-     * @param <T> interned type\n-     *\/\n-    private static class ConcurrentWeakInternSet<T> {\n-\n-        private final ConcurrentMap<WeakEntry<T>, WeakEntry<T>> map;\n-        private final ReferenceQueue<T> stale;\n-\n-        public ConcurrentWeakInternSet() {\n-            this.map = new ConcurrentHashMap<>(512);\n-            this.stale = SharedSecrets.getJavaLangRefAccess().newNativeReferenceQueue();\n-        }\n-\n-        \/**\n-         * Get the existing interned element.\n-         * This method returns null if no element is interned.\n-         *\n-         * @param elem element to look up\n-         * @return the interned element\n-         *\/\n-        public T get(T elem) {\n-            if (elem == null) throw new NullPointerException();\n-            expungeStaleElements();\n-\n-            WeakEntry<T> value = map.get(elem);\n-            if (value != null) {\n-                T res = value.get();\n-                if (res != null) {\n-                    return res;\n-                }\n-            }\n-            return null;\n-        }\n-\n-        \/**\n-         * Interns the element.\n-         * Always returns non-null element, matching the one in the intern set.\n-         * Under the race against another add(), it can return <i>different<\/i>\n-         * element, if another thread beats us to interning it.\n-         *\n-         * @param elem element to add\n-         * @return element that was actually added\n-         *\/\n-        public T add(T elem) {\n-            if (elem == null) throw new NullPointerException();\n-\n-            \/\/ Playing double race here, and so spinloop is required.\n-            \/\/ First race is with two concurrent updaters.\n-            \/\/ Second race is with GC purging weak ref under our feet.\n-            \/\/ Hopefully, we almost always end up with a single pass.\n-            T interned;\n-            WeakEntry<T> e = new WeakEntry<>(elem, stale);\n-            do {\n-                expungeStaleElements();\n-                WeakEntry<T> exist = map.putIfAbsent(e, e);\n-                interned = (exist == null) ? elem : exist.get();\n-            } while (interned == null);\n-            return interned;\n-        }\n-\n-        private void expungeStaleElements() {\n-            Reference<? extends T> reference;\n-            while ((reference = stale.poll()) != null) {\n-                map.remove(reference);\n-            }\n-        }\n-\n-        private static class WeakEntry<T> extends WeakReference<T> {\n-\n-            public final int hashcode;\n-\n-            public WeakEntry(T key, ReferenceQueue<T> queue) {\n-                super(key, queue);\n-                hashcode = key.hashCode();\n-            }\n-\n-            \/**\n-             * This implementation returns {@code true} if {@code obj} is another\n-             * {@code WeakEntry} whose referent is equal to this referent, or\n-             * if {@code obj} is equal to the referent of this. This allows\n-             * lookups to be made without wrapping in a {@code WeakEntry}.\n-             *\n-             * @param obj the object to compare\n-             * @return true if {@code obj} is equal to this or the referent of this\n-             * @see MethodType#equals(Object)\n-             * @see Object#equals(Object)\n-             *\/\n-            @Override\n-            public boolean equals(Object obj) {\n-                Object mine = get();\n-                if (obj instanceof WeakEntry<?> we) {\n-                    Object that = we.get();\n-                    return (that == null || mine == null) ? (this == obj) : mine.equals(that);\n-                }\n-                return (mine == null) ? (obj == null) : mine.equals(obj);\n-            }\n-\n-            @Override\n-            public int hashCode() {\n-                return hashcode;\n-            }\n-\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":12,"deletions":119,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -849,0 +849,1 @@\n+        tree.processor = translate(tree.processor, erasure(tree.processor.type));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -105,2 +105,0 @@\n-runtime\/os\/TestTrimNative.java#trimNative 8312525 linux-all\n-runtime\/os\/TestTrimNative.java#trimNativeLowInterval 8312525 linux-all\n@@ -111,0 +109,1 @@\n+runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java 8313315 linux-ppc64le\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -509,3 +509,4 @@\n-sun\/management\/jdp\/JdpDefaultsTest.java                         8241865 linux-aarch64,macosx-all\n-sun\/management\/jdp\/JdpJmxRemoteDynamicPortTest.java             8241865 macosx-all\n-sun\/management\/jdp\/JdpSpecificAddressTest.java                  8241865 macosx-all\n+sun\/management\/jdp\/JdpDefaultsTest.java                         8241865,8308807 linux-aarch64,macosx-all,aix-ppc64\n+sun\/management\/jdp\/JdpJmxRemoteDynamicPortTest.java             8241865,8308807 macosx-all,aix-ppc64\n+sun\/management\/jdp\/JdpSpecificAddressTest.java                  8241865,8308807 macosx-all,aix-ppc64\n+sun\/management\/jdp\/JdpOffTest.java                              8308807 aix-ppc64\n@@ -531,2 +532,2 @@\n-java\/net\/MulticastSocket\/NoLoopbackPackets.java                 7122846 macosx-all\n-java\/net\/MulticastSocket\/SetLoopbackMode.java                   7122846 macosx-all\n+java\/net\/MulticastSocket\/NoLoopbackPackets.java                 7122846,8308807 macosx-all,aix-ppc64\n+java\/net\/MulticastSocket\/SetLoopbackMode.java                   7122846,8308807 macosx-all,aix-ppc64\n@@ -534,1 +535,1 @@\n-java\/net\/MulticastSocket\/Test.java                              7145658 macosx-all\n+java\/net\/MulticastSocket\/Test.java                              7145658,8308807 macosx-all,aix-ppc64\n@@ -538,0 +539,3 @@\n+java\/net\/MulticastSocket\/B6427403.java                          8308807 aix-ppc64\n+java\/net\/MulticastSocket\/SetOutgoingIf.java                     8308807 aix-ppc64\n+\n@@ -550,0 +554,2 @@\n+java\/nio\/channels\/DatagramChannel\/AfterDisconnect.java          8308807 aix-ppc64\n+\n@@ -606,2 +612,0 @@\n-sun\/security\/pkcs11\/Cipher\/TestKATForGCM.java                   8240611 linux-x64,macosx-x64\n-\n@@ -769,0 +773,6 @@\n+############################################################################\n+\n+# jdk_foreign\n+\n+java\/foreign\/TestByteBuffer.java 8309475 aix-ppc64\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -168,0 +168,12 @@\n+  private native int getFieldEntriesLength0(Class<?> aClass);\n+  public         int getFieldEntriesLength(Class<?> aClass) {\n+    Objects.requireNonNull(aClass);\n+    return getFieldEntriesLength0(aClass);\n+  }\n+\n+  private native int getFieldCPIndex0(Class<?> aClass, int index);\n+  public         int getFieldCPIndex(Class<?> aClass, int index) {\n+    Objects.requireNonNull(aClass);\n+    return getFieldCPIndex0(aClass, index);\n+  }\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}