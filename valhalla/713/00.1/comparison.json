{"files":[{"patch":"@@ -163,0 +163,4 @@\n+    \/** Flag bit 21 is available. (used earlier to tag compiler-generated abstract methods that implement\n+     *  an interface method (Miranda methods)).\n+     *\/\n+\n@@ -422,0 +426,10 @@\n+    \/**\n+     * Flag to indicate that the type variables is universal\n+     *\/\n+    public static final long UNIVERSAL = 1L<<61; \/\/ TypeVariableSymbols\n+\n+    \/\/ Encodings for extended flags stored using attributes\n+    \/**\n+     * Flag to indicate that the primitive class is reference default.\n+     *\/\n+    public static final int ACC_REF_DEFAULT = 1;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1944,0 +1944,12 @@\n+        \/** if this type variable is universal then it could also have a link to a pure reference\n+         *  type variable, it is important to know that a universal type variable and its\n+         *  corresponding referenceTypeVar share the same tsym. So if it is needed to double check if\n+         *  a type variable is universal or not, we need to check its type not the type of its tsym\n+         *\/\n+        public TypeVar projection = null;\n+\n+        protected boolean isReferenceProjection = false;\n+\n+        \/\/ redundant for now but helpful for debug reasons\n+        private boolean isUniversal;\n+\n@@ -1945,0 +1957,4 @@\n+            this(name, owner, lower, false);\n+        }\n+\n+        public TypeVar(Name name, Symbol owner, Type lower, boolean isUniversal) {\n@@ -1947,1 +1963,1 @@\n-            tsym = new TypeVariableSymbol(0, name, this, owner);\n+            tsym = new TypeVariableSymbol(isUniversal ? UNIVERSAL : 0, name, this, owner);\n@@ -1950,0 +1966,4 @@\n+            this.isUniversal = isUniversal;\n+            if (isUniversal && !isReferenceProjection) {\n+                referenceProjection();\n+            }\n@@ -1958,0 +1978,5 @@\n+            this(tsym, bound, lower, metadata, false);\n+        }\n+\n+        public TypeVar(TypeSymbol tsym, Type bound, Type lower,\n+                       TypeMetadata metadata, boolean isReferenceProjection) {\n@@ -1962,0 +1987,5 @@\n+            this.isReferenceProjection = isReferenceProjection;\n+            this.isUniversal = (tsym.flags_field & UNIVERSAL) != 0;\n+            if (isUniversal && !isReferenceProjection) {\n+                referenceProjection();\n+            }\n@@ -1966,1 +1996,1 @@\n-            return new TypeVar(tsym, getUpperBound(), lower, md) {\n+            return new TypeVar(tsym, getUpperBound(), lower, md, isReferenceProjection) {\n@@ -1990,1 +2020,5 @@\n-        public void setUpperBound(Type bound) { this._bound = bound; }\n+        public void setUpperBound(Type bound) {\n+            this._bound = bound;\n+            if (projection != null)\n+                projection.setUpperBound(bound);\n+        }\n@@ -2022,0 +2056,20 @@\n+\n+        @Override\n+        public TypeVar referenceProjection() {\n+            if (projection == null) {\n+                projection = new TypeVar(tsym, _bound, lower, metadata, true);\n+            }\n+            return projection;\n+        }\n+\n+        public boolean isUniversal() {\n+            return ((tsym.flags_field & UNIVERSAL) != 0);\n+        }\n+\n+        public boolean isReferenceProjection() {\n+            return isReferenceProjection;\n+        }\n+\n+        public boolean isValueProjection() {\n+            return isUniversal() && !isReferenceProjection();\n+        }\n@@ -2041,0 +2095,1 @@\n+            this.isReferenceProjection = wildcard.bound != null ? wildcard.bound.isReferenceProjection : false;\n@@ -2051,0 +2106,1 @@\n+            this.isReferenceProjection = wildcard.bound != null ? wildcard.bound.isReferenceProjection : false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":59,"deletions":3,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -97,0 +98,1 @@\n+    final boolean allowUniversalTVars;\n@@ -127,0 +129,1 @@\n+        Preview preview = Preview.instance(context);\n@@ -128,0 +131,1 @@\n+        allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -608,6 +612,35 @@\n-        boolean tValue = t.isPrimitiveClass();\n-        boolean sValue = s.isPrimitiveClass();\n-        if (tValue != sValue) {\n-            return tValue ?\n-                    isSubtype(t.referenceProjection(), s) :\n-                    !t.hasTag(BOT) && isSubtype(t, s.referenceProjection());\n+        if (allowUniversalTVars && ((s.hasTag(TYPEVAR)) && ((TypeVar)s).isValueProjection() &&\n+                (t.hasTag(BOT) || t.hasTag(TYPEVAR) && !((TypeVar)t).isValueProjection()))) {\n+            if (t.hasTag(BOT)) {\n+                chk.warnUniversalTVar(warn.pos(), Warnings.UniversalVariableCannotBeAssignedNull);\n+            } else {\n+                chk.warnUniversalTVar(warn.pos(), Warnings.UniversalVariableCannotBeAssignedNull2);\n+            }\n+            return true;\n+        }\n+\n+        boolean tUndet = t.hasTag(UNDETVAR);\n+        boolean sUndet = s.hasTag(UNDETVAR);\n+\n+        boolean tIsPrimitiveClass = t.isPrimitiveClass();\n+        boolean sIsPrimitiveClass = s.isPrimitiveClass();\n+\n+        \/* next experiment should be to remove all this chunk of code but that will requiere changes in other areas\n+         * like mappings when type variables are present etc\n+         *\/\n+        if (tIsPrimitiveClass != sIsPrimitiveClass) {\n+            boolean result = tIsPrimitiveClass ?\n+                    isSubtype(allowUniversalTVars && (tUndet || sUndet) ? t : t.referenceProjection(), s) :\n+                    !t.hasTag(BOT) && isSubtype(t, allowUniversalTVars && (tUndet || sUndet) ? s : s.referenceProjection());\n+            if (result && (allowUniversalTVars && !t.hasTag(BOT) &&\n+                    s.isPrimitiveClass() && !t.isPrimitiveClass())) {\n+                \/\/ let's check for an erroneous corner case: when the user defines an anonymous class of a primitive class\n+                \/\/ we don't want to issue a warning in that case\n+                boolean anonymousPrimitiveClass = !tIsPrimitiveClass ?\n+                        t.hasTag(CLASS) && supertype(t).isPrimitiveClass() :\n+                        s.hasTag(CLASS) && supertype(s).isPrimitiveClass();\n+                if (!anonymousPrimitiveClass) {\n+                    warn.warn(LintCategory.UNCHECKED);\n+                }\n+            }\n+            return result;\n@@ -618,1 +651,1 @@\n-        if (tPrimitive == sPrimitive) {\n+        if (tPrimitive == sPrimitive || tIsPrimitiveClass != sIsPrimitiveClass) {\n@@ -621,2 +654,0 @@\n-        boolean tUndet = t.hasTag(UNDETVAR);\n-        boolean sUndet = s.hasTag(UNDETVAR);\n@@ -631,2 +662,2 @@\n-            ? isSubtype(boxedClass(t).type, s)\n-            : isSubtype(unboxedType(t), s);\n+                ? isSubtype(boxedClass(t).type, s)\n+                : isSubtype(unboxedType(t), s);\n@@ -1024,0 +1055,35 @@\n+    public boolean isPrimitiveClass(Type t) {\n+        return t != null && t.isPrimitiveClass();\n+    }\n+\n+    @FunctionalInterface\n+    public interface SubtypeTestFlavor {\n+        boolean subtypeTest(Type t, Type s, Warner warn);\n+    }\n+\n+    \/\/ this relation is now named `extends` in the latest Valhalla docs\n+    public boolean isBoundedBy(Type t, Type s) {\n+        return isBoundedBy(t, s, noWarnings, (t1, s1, w1) -> isSubtype(t1, s1));\n+    }\n+\n+    public boolean isBoundedBy(Type t, Type s, SubtypeTestFlavor subtypeTestFlavor) {\n+        return isBoundedBy(t, s, noWarnings, subtypeTestFlavor);\n+    }\n+\n+    \/**\n+     * Is type t bounded by s?\n+     *\/\n+    public boolean isBoundedBy(Type t, Type s, Warner warn, SubtypeTestFlavor subtypeTestFlavor) {\n+        boolean result = subtypeTestFlavor.subtypeTest(t, s, warn);\n+        if (allowUniversalTVars && !result) {\n+            if (isPrimitiveClass(t)) {\n+                return isBoundedBy(t.referenceProjection(), s, warn, subtypeTestFlavor);\n+            } else if (t.hasTag(TYPEVAR) && ((TypeVar)t).isUniversal()) {\n+                return isBoundedBy(t.getUpperBound(), s, warn, subtypeTestFlavor);\n+            } else if (s.hasTag(TYPEVAR) && ((TypeVar)s).isUniversal()) {\n+                return isBoundedBy(t, s.getLowerBound(), warn, subtypeTestFlavor);\n+            }\n+        }\n+        return result;\n+    }\n+\n@@ -1035,3 +1101,16 @@\n-        boolean result = isSubtypeUncheckedInternal(t, s, true, warn);\n-        if (result) {\n-            checkUnsafeVarargsConversion(t, s, warn);\n+        boolean result = false;\n+        if (warn != warnStack.head) {\n+            try {\n+                warnStack = warnStack.prepend(warn);\n+                result = isSubtypeUncheckedInternal(t, s, true, warn);\n+                if (result) {\n+                    checkUnsafeVarargsConversion(t, s, warn);\n+                }\n+            } finally {\n+                warnStack = warnStack.tail;\n+            }\n+        } else {\n+            result = isSubtypeUncheckedInternal(t, s, true, warn);\n+            if (result) {\n+                checkUnsafeVarargsConversion(t, s, warn);\n+            }\n@@ -1061,0 +1140,3 @@\n+            } else if (allowUniversalTVars && t.hasTag(TYPEVAR) && s.hasTag(TYPEVAR) && t.tsym == s.tsym) {\n+                warn.warn(LintCategory.UNCHECKED);\n+                return true;\n@@ -1065,3 +1147,8 @@\n-                if (t2 != null && t2.isRaw()) {\n-                    if (isReifiable(s)) {\n-                        warn.silentWarn(LintCategory.UNCHECKED);\n+                if (t2 != null) {\n+                    if (t2.isRaw()) {\n+                        if (isReifiable(s)) {\n+                            warn.silentWarn(LintCategory.UNCHECKED);\n+                        } else {\n+                            warn.warn(LintCategory.UNCHECKED);\n+                        }\n+                        return true;\n@@ -1069,1 +1156,7 @@\n-                        warn.warn(LintCategory.UNCHECKED);\n+                        if (!isSameType(t2, s) &&\n+                                t2.isReferenceProjection() == s.isReferenceProjection() &&\n+                                structuralComparator.visit(t2, s, true)) {\n+                            warn.warn(LintCategory.UNCHECKED);\n+                            return true;\n+                        }\n+                        return false;\n@@ -1071,1 +1164,0 @@\n-                    return true;\n@@ -1076,0 +1168,136 @@\n+        \/\/ where\n+        StructuralTypeComparator structuralComparator = new StructuralTypeComparator();\n+        class StructuralTypeComparator extends TypeRelation {\n+            boolean topType = true;\n+\n+            private Set<TypePair> cache = new HashSet<>();\n+\n+            boolean visit(Type t, Type s, boolean topType) {\n+                this.topType = topType;\n+                return super.visit(t, s);\n+            }\n+\n+            @Override\n+            public Boolean visitType(Type t, Type s) {\n+                if (topType) {\n+                    return t.hasTag(s.getTag());\n+                } else {\n+                    boolean result = isSameType(t, s);\n+                    if (!result) {\n+                        result = isSameType(t.referenceProjectionOrSelf(), s.referenceProjectionOrSelf());\n+                    }\n+                    return result;\n+                }\n+            }\n+\n+            @Override\n+            public Boolean visitArrayType(ArrayType t, Type s) {\n+                if (t == s)\n+                    return true;\n+                return s.hasTag(ARRAY)\n+                        && visit(t.elemtype, elemtype(s));\n+            }\n+\n+            @Override\n+            public Boolean visitClassType(ClassType t, Type s) {\n+                if (!t.hasTag(CLASS)) return false;\n+                return t.tsym == s.tsym\n+                        && (t.tsym != s.tsym || t.referenceProjectionOrSelf().tsym == s.referenceProjectionOrSelf().tsym)\n+                        && (!s.isParameterized() || compareTypeArgsRecursive(s, t))\n+                        && visit(t.getEnclosingType(), s.getEnclosingType());\n+            }\n+\n+            @Override\n+            public Boolean visitWildcardType(WildcardType t, Type s) {\n+                return isSameWildcard(t, s)\n+                        || isCaptureOf(s, t)\n+                        || compareWildcardHelper(t, s);\n+            }\n+\n+            boolean compareWildcardHelper(WildcardType t, Type s) {\n+                \/\/ let's remove captured if any\n+                if (s.hasTag(TYPEVAR)) {\n+                    TypeVar v = (TypeVar) s;\n+                    s = v.isCaptured() ? ((CapturedType)v).wildcard : s;\n+                }\n+                if (!s.hasTag(WILDCARD) || ((WildcardType)s).kind != t.kind) return false;\n+                if (t.isExtendsBound()) {\n+                    return visit(wildUpperBound(s), wildUpperBound(t));\n+                } else {\n+                    return visit(wildLowerBound(s), wildLowerBound(t));\n+                }\n+            }\n+\n+            @Override\n+            public Boolean visitTypeVar(TypeVar t, Type s) {\n+                if (s.hasTag(TYPEVAR)) {\n+                    TypeVar other = (TypeVar)s;\n+                    if (allowUniversalTVars &&\n+                            t.isValueProjection() != other.isValueProjection() && t.tsym == other.tsym) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }\n+\n+            @Override\n+            public Boolean visitUndetVar(UndetVar t, Type s) {\n+                return isSameType(t, s);\n+            }\n+\n+            public boolean compareTypeArgsRecursive(Type t, Type s) {\n+                TypePair pair = new TypePair(t, s);\n+                if (cache.add(pair)) {\n+                    try {\n+                        return compareTypeArgs(t.getTypeArguments(), s.getTypeArguments());\n+                    } finally {\n+                        cache.remove(pair);\n+                    }\n+                } else {\n+                    return compareTypeArgs(t.getTypeArguments(),\n+                            rewriteSupers(s).getTypeArguments());\n+                }\n+            }\n+\n+            boolean compareTypeArgs(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()\n+                        && visit(ts.head, ss.head, false)) {\n+                    ts = ts.tail;\n+                    ss = ss.tail;\n+                }\n+                return ts.isEmpty() && ss.isEmpty();\n+            }\n+        }\n+\n+        Type rewriteSupers(Type t) {\n+            if (!t.isParameterized())\n+                return t;\n+            ListBuffer<Type> from = new ListBuffer<>();\n+            ListBuffer<Type> to = new ListBuffer<>();\n+            adaptSelf(t, from, to);\n+            if (from.isEmpty())\n+                return t;\n+            ListBuffer<Type> rewrite = new ListBuffer<>();\n+            boolean changed = false;\n+            for (Type orig : to.toList()) {\n+                Type s = rewriteSupers(orig);\n+                if (s.isSuperBound() && !s.isExtendsBound()) {\n+                    s = new WildcardType(syms.objectType,\n+                            BoundKind.UNBOUND,\n+                            syms.boundClass,\n+                            s.getMetadata());\n+                    changed = true;\n+                } else if (s != orig) {\n+                    s = new WildcardType(wildUpperBound(s),\n+                            BoundKind.EXTENDS,\n+                            syms.boundClass,\n+                            s.getMetadata());\n+                    changed = true;\n+                }\n+                rewrite.append(s);\n+            }\n+            if (changed)\n+                return subst(t.tsym.type, from.toList(), rewrite.toList());\n+            else\n+                return t;\n+        }\n@@ -1133,1 +1361,2 @@\n-        return isSubtype.visit(capture ? capture(t) : t, s);\n+        t = capture ? capture(t) : t;\n+        return isSubtypeRelation.visit(t, s);\n@@ -1136,1 +1365,1 @@\n-        private TypeRelation isSubtype = new TypeRelation()\n+        private TypeRelation isSubtypeRelation = new TypeRelation()\n@@ -1151,1 +1380,1 @@\n-                     return isSubtypeNoCapture(t.getUpperBound(), s);\n+                     return isSubtype(t.getUpperBound(), s, false);\n@@ -1166,1 +1395,1 @@\n-            private boolean containsTypeRecursive(Type t, Type s) {\n+            public boolean containsTypeRecursive(Type t, Type s) {\n@@ -1181,33 +1410,0 @@\n-            private Type rewriteSupers(Type t) {\n-                if (!t.isParameterized())\n-                    return t;\n-                ListBuffer<Type> from = new ListBuffer<>();\n-                ListBuffer<Type> to = new ListBuffer<>();\n-                adaptSelf(t, from, to);\n-                if (from.isEmpty())\n-                    return t;\n-                ListBuffer<Type> rewrite = new ListBuffer<>();\n-                boolean changed = false;\n-                for (Type orig : to.toList()) {\n-                    Type s = rewriteSupers(orig);\n-                    if (s.isSuperBound() && !s.isExtendsBound()) {\n-                        s = new WildcardType(syms.objectType,\n-                                             BoundKind.UNBOUND,\n-                                             syms.boundClass,\n-                                             s.getMetadata());\n-                        changed = true;\n-                    } else if (s != orig) {\n-                        s = new WildcardType(wildUpperBound(s),\n-                                             BoundKind.EXTENDS,\n-                                             syms.boundClass,\n-                                             s.getMetadata());\n-                        changed = true;\n-                    }\n-                    rewrite.append(s);\n-                }\n-                if (changed)\n-                    return subst(t.tsym.type, from.toList(), rewrite.toList());\n-                else\n-                    return t;\n-            }\n-\n@@ -1386,1 +1582,0 @@\n-\n@@ -1572,1 +1767,1 @@\n-               && containsType(ts.head, ss.head)) {\n+                && containsType(ts.head, ss.head)) {\n@@ -1613,1 +1808,1 @@\n-                else\n+                else {\n@@ -1615,0 +1810,1 @@\n+                }\n@@ -1648,2 +1844,1 @@\n-                        || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &&\n-                            (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));\n+                        || checkIfBoundedBy(t, s);\n@@ -1653,0 +1848,9 @@\n+            boolean checkIfBoundedBy(WildcardType t, Type s) {\n+                if (t.isUnbound()) return true;\n+                return (t.isExtendsBound()) ?\n+                    isBoundedBy(wildUpperBound(s), wildUpperBound(t),\n+                            (t1, s1, w) -> isSubtype(t1, s1, false)) :\n+                    isBoundedBy(wildLowerBound(t), wildLowerBound(s),\n+                            (t1, s1, w) -> isSubtype(t1, s1, false));\n+            }\n+\n@@ -1683,1 +1887,1 @@\n-               && containsTypeEquivalent(ts.head, ss.head)) {\n+                && containsTypeEquivalent(ts.head, ss.head)) {\n@@ -2082,1 +2286,1 @@\n-        return !isSubtype(t, relaxBound(s));\n+        return !isBoundedBy(t, relaxBound(s), (t1, s1, w) -> isSubtype(t1, s1));\n@@ -3409,2 +3613,17 @@\n-                return s.hasTag(METHOD)\n-                    && containsTypeEquivalent(t.argtypes, s.getParameterTypes());\n+                return s.hasTag(METHOD) &&\n+                        (compareTypesStruc(t.argtypes, s.getParameterTypes()));\n+            }\n+\n+            boolean compareTypesStruc(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()) {\n+                    boolean equivalent = containsTypeEquivalent(ts.head, ss.head);\n+                    if (equivalent ||\n+                            ts.head.hasTag(TYPEVAR) && ss.head.hasTag(TYPEVAR) &&\n+                            structuralComparator.visit(ts.head, ss.head)) {\n+                        ts = ts.tail;\n+                        ss = ss.tail;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+                return ts.isEmpty() && ss.isEmpty();\n@@ -3475,2 +3694,15 @@\n-                if (t.equalsIgnoreMetadata(from.head)) {\n-                    return to.head.withTypeVar(t);\n+                if (t.equalsIgnoreMetadata(from.head) ||\n+                    allowUniversalTVars &&\n+                    !t.isValueProjection() &&\n+                    from.head.hasTag(TYPEVAR) &&\n+                    t.equalsIgnoreMetadata(((TypeVar)from.head).referenceProjection())) {\n+                    return to.head.hasTag(TYPEVAR) && t.isReferenceProjection() && t == ((TypeVar)to.head).referenceProjection() ?\n+                            ((TypeVar)to.head).referenceProjection() :\n+                            to.head;\n+                    \/\/ experiment\n+                    \/*\n+                    * if (to.head.hasTag(TYPEVAR) && t.isReferenceProjection() && t == ((TypeVar)to.head).referenceProjection() ||\n+                        to.head.hasTag(CLASS)) {\n+                        return to.head.referenceProjection() != null ? to.head.referenceProjection() : to.head;\n+                    } else return to.head;\n+                    * *\/\n@@ -3627,1 +3859,5 @@\n-                return new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata());\n+                TypeVar newTV = new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata(), t.isReferenceProjection);\n+                if (t.projection != null) {\n+                    newTV.referenceProjection();\n+                }\n+                return newTV;\n@@ -4092,0 +4328,4 @@\n+        \/\/ lub is critical code better to go this way rather than using streams\n+        for (int i = 0; i < ts.length; i++) {\n+            ts[i] = ts[i].referenceProjectionOrSelf();\n+        }\n@@ -4235,1 +4475,1 @@\n-        else if (isSubtypeNoCapture(t, s))\n+        else if (isBoundedBy(t, s, (t1, s1, w) -> isSubtypeNoCapture(t1, s1)))\n@@ -4237,1 +4477,1 @@\n-        else if (isSubtypeNoCapture(s, t))\n+        else if (isBoundedBy(s, t, (s1, t1, w) -> isSubtypeNoCapture(s1, t1)))\n@@ -4692,1 +4932,1 @@\n-            containsType(t, s) && containsType(s, t);\n+                containsType(t, s) && containsType(s, t);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":311,"deletions":71,"binary":false,"changes":382,"status":"modified"},{"patch":"@@ -179,0 +179,1 @@\n+        allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -227,0 +228,4 @@\n+    \/** Are universal tvars allowed?\n+     *\/\n+    private final boolean allowUniversalTVars;\n+\n@@ -2616,1 +2621,2 @@\n-                if (qualifier.isValueClass() || superCallOnValueReceiver) {\n+                boolean qualifierIsUniversal = allowUniversalTVars && qualifier.hasTag(TYPEVAR) && ((TypeVar)qualifier).isUniversal();\n+                if (qualifier.isValueClass() || qualifierIsUniversal || superCallOnValueReceiver) {\n@@ -2624,1 +2630,8 @@\n-                                log.error(tree.pos(), Errors.ValueClassDoesNotSupport(name));\n+                                if (!qualifierIsUniversal) {\n+                                    log.error(tree.pos(), Errors.ValueClassDoesNotSupport(name));\n+                                } else {\n+                                    \/* probably this will be a lint warning in the future, still under discussion\n+                                     * will comment it for now\n+                                     *\/\n+                                    \/\/log.warning(tree.pos(), Warnings.MethodShouldNotBeInvokedOnUniversalTvars(name));\n+                                }\n@@ -2631,1 +2644,8 @@\n-                                log.error(tree.pos(), Errors.ValueClassDoesNotSupport(name));\n+                                if (!qualifierIsUniversal) {\n+                                    log.error(tree.pos(), Errors.ValueClassDoesNotSupport(name));\n+                                } else {\n+                                    \/* probably this will be a lint warning in the future, still under discussion\n+                                     * will comment it for now\n+                                     *\/\n+                                    \/\/log.warning(tree.pos(), Warnings.MethodShouldNotBeInvokedOnUniversalTvars(name));\n+                                }\n@@ -3017,1 +3037,3 @@\n-                    chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n+                    if (!allowUniversalTVars) {\n+                        chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n+                    }\n@@ -4524,0 +4546,8 @@\n+                if (allowUniversalTVars && name == names.ref && ((TypeVar)site).isUniversal()) {\n+                    \/* return a wrapper around the type the reference projection of this type variable\n+                     * this is needed as a type variable and its reference projection share the same\n+                     * tsym but their types are different\n+                     *\/\n+                    return new TypeVariableSymbol(site.tsym.flags(), site.tsym.name,\n+                            ((TypeVar)site).referenceProjection(), site.tsym.owner);\n+                }\n@@ -4910,1 +4940,1 @@\n-        Warner noteWarner = new Warner();\n+        Warner noteWarner = new Warner(env.tree.pos());\n@@ -5034,3 +5064,23 @@\n-\n-        \/\/ Attribute type parameters\n-        List<Type> actuals = attribTypes(tree.arguments, env);\n+        List<Type> actuals;\n+        List<JCExpression> args = tree.arguments;\n+        if (!allowUniversalTVars || args == null || args.isEmpty() || ((ClassType) clazztype.tsym.type).typarams_field.isEmpty()) {\n+            actuals = attribTypes(tree.arguments, env);\n+        } else {\n+            \/* the code below has been obtained by unfolding an invocation to `attribTypes`\n+             * with arguments `tree.arguments` and `env`. We need to do this unfolding to\n+             * take into account the \"universality\" of the declared type variables\n+             *\/\n+            List<Type> typarams_field = ((ClassType) clazztype.tsym.type).typarams_field != null ? ((ClassType) clazztype.tsym.type).typarams_field : List.nil();\n+            ListBuffer<Type> argtypes = new ListBuffer<>();\n+            for (List<JCExpression> l = args; l.nonEmpty(); l = l.tail) {\n+                env.info.primitiveClassAllowedAsTypeParam = typarams_field.head != null ? ((TypeVar)typarams_field.head).isUniversal() : false;\n+                \/* we need the new field `primitiveClassAllowedAsTypeParam` because the type attribution below:\n+                 * `attribType(l.head, env)`\n+                 * could be dealing with a wildcard for example and at some point we will need to check\n+                 * if primitives are allowed as bounds\n+                 *\/\n+                argtypes.append(chk.checkRefType(l.head.pos(), attribType(l.head, env), env.info.primitiveClassAllowedAsTypeParam));\n+                typarams_field = typarams_field.tail != null ? typarams_field.tail : typarams_field;\n+            }\n+            actuals = argtypes.toList();\n+        }\n@@ -5220,1 +5270,1 @@\n-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),\n+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, env.info.primitiveClassAllowedAsTypeParam),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":59,"deletions":9,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.Function;\n@@ -171,0 +172,1 @@\n+        allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -214,0 +216,4 @@\n+    \/** Are universal tvars allowed\n+     *\/\n+    private final boolean allowUniversalTVars;\n+\n@@ -279,0 +285,10 @@\n+    \/** Warn about operation with universal type variables.\n+     *  @param pos        Position to be used for error reporting.\n+     *  @param warnKey    A warning key.\n+     *\/\n+    public void warnUniversalTVar(DiagnosticPosition pos, Warning warnKey) {\n+        if (!lint.isSuppressed(LintCategory.UNIVERSAL)) {\n+            log.warning(LintCategory.UNIVERSAL, pos, warnKey);\n+        }\n+    }\n+\n@@ -617,3 +633,5 @@\n-            if (found.hasTag(CLASS)) {\n-                if (inferenceContext != infer.emptyContext)\n-                    checkParameterizationByPrimitiveClass(pos, found);\n+            if (!allowUniversalTVars) {\n+                if (found.hasTag(CLASS)) {\n+                    if (inferenceContext != infer.emptyContext)\n+                        checkParameterizationByPrimitiveClass(pos, found);\n+                }\n@@ -699,1 +717,1 @@\n-             return types.isSubtype(a, bound);\n+             return types.isBoundedBy(a, bound, (t, s, w) -> types.isSubtype(t, s));\n@@ -942,1 +960,3 @@\n-        parameterizationByPrimitiveClassChecker.visit(t, pos);\n+        if (!allowUniversalTVars) {\n+            parameterizationByPrimitiveClassChecker.visit(t, pos);\n+        }\n@@ -1139,1 +1159,1 @@\n-        if (varType.hasTag(CLASS)) {\n+        if (!allowUniversalTVars && varType.hasTag(CLASS)) {\n@@ -4231,0 +4251,1 @@\n+                    this.warned = true;\n@@ -4238,0 +4259,1 @@\n+                        this.warned = true;\n@@ -4240,0 +4262,4 @@\n+                case UNIVERSAL:\n+                    Check.this.warnUniversalTVar(pos(), Warnings.UniversalVariableCannotBeAssignedNull);\n+                    this.warned = true;\n+                    break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":32,"deletions":6,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+        this.allowUniversalTVars = Feature.UNIVERSAL_TVARS.allowedInSource(source);\n@@ -237,1 +238,1 @@\n-     boolean allowPrimitiveClasses;\n+    boolean allowPrimitiveClasses;\n@@ -247,0 +248,4 @@\n+    \/** Switch: are primitive classes allowed in this source level?\n+     *\/\n+    boolean allowUniversalTVars;\n+\n@@ -4752,0 +4757,6 @@\n+        boolean universal = false;\n+        if (allowUniversalTVars && token.kind == UNIVERSAL) {\n+            checkSourceLevel(Feature.UNIVERSAL_TVARS);\n+            universal = true;\n+            nextToken();\n+        }\n@@ -4762,1 +4773,3 @@\n-        return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));\n+        return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos, universal));\n+        \/\/ use the line below to make experiments setting all type variables as universal\n+        \/\/return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos, true));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1435,0 +1435,4 @@\n+# 0: symbol\n+compiler.warn.var.might.not.have.been.initialized=\\\n+    variable {0} might not have been initialized\n+\n@@ -3097,0 +3101,3 @@\n+compiler.misc.feature.universal.tvars=\\\n+    universal type variables\n+\n@@ -4029,0 +4036,15 @@\n+\n+### universal type variables\n+\n+# 0: symbol\n+compiler.err.var.not.initialized.in.default.constructor=\\\n+    variable {0} not initialized in the default constructor\n+\n+compiler.warn.universal.variable.cannot.be.assigned.null=\\\n+    universal type variables cannot be assigned null\n+\n+compiler.warn.universal.variable.cannot.be.assigned.null.2=\\\n+    probable null assigment to a universal type variable\n+\n+compiler.warn.primitive.value.conversion=\\\n+    primitive value conversion\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -217,0 +217,1 @@\n+compiler.err.value.class.must.not.implement.identity.object\n@@ -232,0 +233,2 @@\n+compiler.misc.feature.universal.tvars\n+compiler.warn.primitive.value.conversion\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}