{"files":[{"patch":"@@ -114,1 +114,2 @@\n-    public static final int ACC_SUPER    = 0x0020;\n+    public static final int ACC_IDENTITY = 0x0020;\n+    public static final int ACC_VALUE    = 0x0040;\n@@ -117,1 +118,0 @@\n-    public static final int ACC_VALUE    = 0x0100;\n@@ -120,1 +120,0 @@\n-    public static final int ACC_PERMITS_VALUE = 0x0040;\n@@ -148,2 +147,5 @@\n-    \/** Flag is set for an abstract class that meets the various needs\n-     *  that qualify it to be the super class of a value\/primitive class\n+    \/** Flag is set for a class or interface whose instances have identity\n+     * i.e. class\/interface declarations that are expressly declared with\n+     * the modifier `identity' or (b) any concrete class not declared with the\n+     * modifier `value' (c) abstract class not declared `value' but meets various\n+     * stipulations (d) older class files with ACC_SUPER bit set\n@@ -151,1 +153,1 @@\n-    public static final int PERMITS_VALUE            = 1<<19;\n+    public static final int IDENTITY_TYPE            = 1<<19;\n@@ -439,1 +441,1 @@\n-        LocalClassFlags                   = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC | ACC_PERMITS_VALUE,\n+        LocalClassFlags                   = FINAL | ABSTRACT | STRICTFP | ENUM | SYNTHETIC | ACC_IDENTITY,\n@@ -532,1 +534,6 @@\n-        PERMITS_VALUE(Flags.PERMITS_VALUE),\n+        IDENTITY_TYPE(Flags.IDENTITY_TYPE) {\n+            @Override\n+            public String toString() {\n+                return \"identity\";\n+            }\n+        },\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -248,0 +248,12 @@\n+    public boolean isValueInterface() {\n+        return false;\n+    }\n+\n+    public boolean isIdentityClass() {\n+        return false;\n+    }\n+\n+    public boolean isIdentityInterface() {\n+        return false;\n+    }\n+\n@@ -1353,0 +1365,15 @@\n+        @Override\n+        public boolean isValueInterface() {\n+            return tsym != null && tsym.isValueInterface();\n+        }\n+\n+        @Override\n+        public boolean isIdentityClass() {\n+            return !isReferenceProjection() && tsym != null && tsym.isIdentityClass();\n+        }\n+\n+        @Override\n+        public boolean isIdentityInterface() {\n+            return isInterface() && tsym.isIdentityInterface();\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -828,5 +828,9 @@\n-            \/\/ Not functional if extending either of the top interface types.\n-            Type topInterface;\n-            if ((topInterface = asSuper(origin.type, syms.identityObjectType.tsym)) != null ||\n-                    (topInterface = asSuper(origin.type, syms.valueObjectType.tsym)) != null) {\n-                throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.MayNotExtendTopInterfaceType(topInterface)));\n+            \/\/ an interface must be neither an identity interface nor a value interface to be functional.\n+            List<Type> allInterfaces = closure(origin.type);\n+            for (Type iface : allInterfaces) {\n+                if (iface.isValueInterface()) {\n+                    throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.ValueInterfaceNonfunctional));\n+                }\n+                if (iface.isIdentityInterface()) {\n+                    throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.IdentityInterfaceNonfunctional));\n+                }\n@@ -1442,2 +1446,1 @@\n-                        || sname == names.java_io_Serializable\n-                        || sname == names.java_lang_IdentityObject;\n+                        || sname == names.java_io_Serializable;\n@@ -2465,19 +2468,0 @@\n-        if (sym == syms.identityObjectType.tsym) {\n-            \/\/ IdentityObject is a super interface of every concrete identity class other than jlO\n-            if (t.tsym == syms.objectType.tsym)\n-                return null;\n-            if (t.hasTag(ARRAY))\n-                return syms.identityObjectType;\n-            if (t.hasTag(CLASS) && !t.isValueClass() && !t.isReferenceProjection() && !t.tsym.isInterface() && !t.tsym.isAbstract()) {\n-                return syms.identityObjectType;\n-            }\n-            if (implicitIdentityType(t)) {\n-                return syms.identityObjectType;\n-            } \/\/ else fall through and look for explicit coded super interface\n-        } else if (sym == syms.valueObjectType.tsym) {\n-            if (t.isValueClass() || t.isReferenceProjection())\n-                return syms.valueObjectType;\n-            if (t.hasTag(ARRAY) || t.tsym == syms.objectType.tsym)\n-                return null;\n-            \/\/ else fall through and look for explicit coded super interface\n-        }\n@@ -2545,53 +2529,0 @@\n-        \/\/ where\n-        private boolean implicitIdentityType(Type t) {\n-            \/* An abstract class can be declared to implement either IdentityObject or ValueObject;\n-             * or, if it declares a field, an instance initializer, a non-empty constructor, or\n-             * a synchronized instance method, it implicitly implements IdentityObject.\n-             *\/\n-            if (!t.tsym.isAbstract())\n-                return false;\n-\n-            for (; t != Type.noType; t = supertype(t)) {\n-\n-                if (t == null || t.tsym == null || t.tsym.kind == ERR)\n-                    return false;\n-\n-                if  (t.tsym == syms.objectType.tsym)\n-                    return false;\n-\n-                if (!t.tsym.isAbstract()) {\n-                    return !t.tsym.isPrimitiveClass();\n-                }\n-\n-                if ((t.tsym.flags() & HASINITBLOCK) != 0) {\n-                    return true;\n-                }\n-\n-                \/\/ No instance fields and no arged constructors both mean inner classes cannot be primitive class supers.\n-                Type encl = t.getEnclosingType();\n-                if (encl != null && encl.hasTag(CLASS)) {\n-                    return true;\n-                }\n-                for (Symbol s : t.tsym.members().getSymbols(NON_RECURSIVE)) {\n-                    switch (s.kind) {\n-                        case VAR:\n-                            if ((s.flags() & STATIC) == 0) {\n-                                return true;\n-                            }\n-                            break;\n-                        case MTH:\n-                            if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n-                                return true;\n-                            } else if (s.isConstructor()) {\n-                                MethodSymbol m = (MethodSymbol)s;\n-                                if (m.getParameters().size() > 0 || (m.flags() & EMPTYNOARGCONSTR) == 0) {\n-                                    return true;\n-                                }\n-                            }\n-                            break;\n-                    }\n-                }\n-            }\n-            return false;\n-        }\n-\n@@ -4522,1 +4453,1 @@\n-                        syms.cloneableType, syms.identityObjectType), true);\n+                        syms.cloneableType), true);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":11,"deletions":80,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -183,1 +182,1 @@\n-        tolerateObjectInstantiation = options.isSet(\"tolerateObjectInstantiation\");\n+\n@@ -239,6 +238,0 @@\n-    \/**\n-     * Switch: warn about use of new Object() ? By default, Yes;\n-     * but not if -XDtolerateObjectInstantiation is in effect\n-     *\/\n-    boolean tolerateObjectInstantiation;\n-\n@@ -2811,3 +2804,0 @@\n-            if (!tolerateObjectInstantiation && clazztype.tsym == syms.objectType.tsym && cdef == null && !tree.classDeclRemoved()) {\n-                log.note(tree.pos(), Notes.CantInstantiateObjectDirectly);\n-            }\n@@ -2870,1 +2860,1 @@\n-                (clazztype.tsym.flags() & (ABSTRACT | INTERFACE)) != 0 && clazztype.tsym != syms.objectType.tsym) { \/\/ tolerate abstract Object\n+                (clazztype.tsym.flags() & (ABSTRACT | INTERFACE)) != 0) {\n@@ -5594,1 +5584,1 @@\n-                if ((c.flags() & (VALUE_CLASS | ABSTRACT)) == VALUE_CLASS) { \/\/ for non-intersection, concrete primitive\/value classes.\n+                if (c.isValueClass()) {\n@@ -5596,4 +5586,1 @@\n-                    JCClassDecl classDecl = (JCClassDecl) env.tree;\n-                    if (classDecl.extending != null) {\n-                        chk.checkSuperConstraintsOfValueClass(env.tree.pos(), c);\n-                    }\n+                    chk.checkConstraintsOfValueClass(env.tree.pos(), c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -112,7 +111,0 @@\n-    \/**\n-     * Switch: warn about use of new Object() ? By default, Yes;\n-     * but not if -XDtolerateObjectInstantiation is in effect\n-     *\/\n-    boolean tolerateObjectInstantiation;\n-\n-\n@@ -155,1 +147,0 @@\n-        tolerateObjectInstantiation = options.isSet(\"tolerateObjectInstantiation\");\n@@ -778,2 +769,2 @@\n-    void checkSuperConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n-        for(Type st = types.supertype(c.type); st != Type.noType; st = types.supertype(st)) {\n+    void checkConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n+        for (Type st : types.closure(c.type)) {\n@@ -781,3 +772,3 @@\n-                return;\n-            if  (st.tsym == syms.objectType.tsym)\n-                return;\n+                continue;\n+            if  (st.tsym == syms.objectType.tsym || st.tsym == syms.recordType.tsym || st.isInterface())\n+                continue;\n@@ -785,4 +776,4 @@\n-                log.error(pos, Errors.ConcreteSupertypeForValueClass(c, st));\n-            }\n-            if ((st.tsym.flags() & PERMITS_VALUE) != 0) {\n-                return;\n+                if (c != st.tsym) {\n+                    log.error(pos, Errors.ConcreteSupertypeForValueClass(c, st));\n+                }\n+                continue;\n@@ -790,1 +781,2 @@\n-            \/\/ We have an unsuitable abstract super class, find out why exactly and complain\n+            \/\/ dealing with an abstract value or value super class below.\n+            Fragment fragment = c.isAbstract() && c.isValueClass() && c == st.tsym ? Fragments.AbstractValueClass(c) : Fragments.SuperclassOfValueClass(c, st);\n@@ -792,1 +784,1 @@\n-                log.error(pos, Errors.SuperClassDeclaresInitBlock(c, st));\n+                log.error(pos, Errors.SuperClassDeclaresInitBlock(fragment));\n@@ -798,1 +790,1 @@\n-                log.error(pos, Errors.SuperClassCannotBeInner(c, st));\n+                log.error(pos, Errors.SuperClassCannotBeInner(fragment));\n@@ -804,1 +796,1 @@\n-                        log.error(pos, Errors.SuperFieldNotAllowed(s, c, st));\n+                        log.error(pos, Errors.SuperFieldNotAllowed(s, fragment));\n@@ -808,1 +800,1 @@\n-                    if ((s.flags() & SYNCHRONIZED) != 0) {\n+                    if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n@@ -813,5 +805,9 @@\n-                            log.error(pos, Errors.SuperConstructorCannotTakeArguments(m, c, st));\n-                        } else {\n-                            if ((m.flags() & EMPTYNOARGCONSTR) == 0) {\n-                                log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, c, st));\n-                            }\n+                            log.error(pos, Errors.SuperConstructorCannotTakeArguments(m, fragment));\n+                        } else if (m.getTypeParameters().size() > 0) {\n+                            log.error(pos, Errors.SuperConstructorCannotBeGeneric(m, fragment));\n+                        } else if (m.type.getThrownTypes().size() > 0) {\n+                            log.error(pos, Errors.SuperConstructorCannotThrow(m, fragment));\n+                        } else if (protection(m.flags()) > protection(m.owner.flags())) {\n+                            log.error(pos, Errors.SuperConstructorAccessRestricted(m, fragment));\n+                        } else if ((m.flags() & EMPTYNOARGCONSTR) == 0) {\n+                                log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, fragment));\n@@ -831,6 +827,1 @@\n-            \/* Tolerate an encounter with abstract Object, we will mutate the constructor reference\n-               to an invocation of java.util.Objects.newIdentity downstream.\n-            *\/\n-            if (!tolerateObjectInstantiation && t.tsym == syms.objectType.tsym)\n-                log.note(expr.pos(), Notes.CantInstantiateObjectDirectly);\n-            if ((t.tsym.flags() & (ABSTRACT | INTERFACE)) != 0 && t.tsym != syms.objectType.tsym) {\n+            if ((t.tsym.flags() & (ABSTRACT | INTERFACE)) != 0) {\n@@ -898,1 +889,1 @@\n-    \/** Check that type is an identity type, i.e. not a primitive type\n+    \/** Check that type is an identity type, i.e. not a primitive\/value type\n@@ -907,1 +898,1 @@\n-        if (t.isPrimitive() || t.isValueClass() || t.isReferenceProjection())\n+        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface() || t.isReferenceProjection())\n@@ -912,6 +903,0 @@\n-        \/* Not appropriate to check\n-         *     if (types.asSuper(t, syms.identityObjectType.tsym) != null)\n-         * since jlO, interface types and abstract types may fail that check\n-         * at compile time.\n-         *\/\n-\n@@ -1500,2 +1485,2 @@\n-            \/\/ value classes are implicitly final\n-            if ((flags & VALUE_CLASS) != 0)\n+            \/\/ concrete value classes are implicitly final\n+            if ((flags & (ABSTRACT | INTERFACE | VALUE_CLASS)) == VALUE_CLASS)\n@@ -1504,2 +1489,2 @@\n-            \/\/ ACC_PERMITS_VALUE a legal class flag, but not a legal class modifier\n-            mask &= ~ACC_PERMITS_VALUE;\n+            \/\/ TYPs can't be declared synchronized\n+            mask &= ~SYNCHRONIZED;\n@@ -1534,1 +1519,5 @@\n-                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS | VALUE_CLASS)\n+                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS)\n+                 &&\n+                 checkDisjoint(pos, flags,\n+                        IDENTITY_TYPE,\n+                        PRIMITIVE_CLASS | VALUE_CLASS)\n@@ -2800,8 +2789,17 @@\n-        boolean implementsIdentityObject = types.asSuper(c.referenceProjectionOrSelf(), syms.identityObjectType.tsym) != null;\n-        boolean implementsValueObject = types.asSuper(c.referenceProjectionOrSelf(), syms.valueObjectType.tsym) != null;\n-        if (c.isValueClass() && implementsIdentityObject) {\n-            log.error(pos, Errors.ValueClassMustNotImplementIdentityObject(c));\n-        } else if (implementsValueObject && !c.isValueClass() && !c.isReferenceProjection() && !c.tsym.isInterface() && !c.tsym.isAbstract()) {\n-            log.error(pos, Errors.IdentityClassMustNotImplementValueObject(c));\n-        } else if (implementsValueObject && implementsIdentityObject) {\n-            log.error(pos, Errors.MutuallyIncompatibleSuperInterfaces(c));\n+        boolean cIsValue = (c.tsym.flags() & VALUE_CLASS) != 0;\n+        boolean cHasIdentity = (c.tsym.flags() & IDENTITY_TYPE) != 0;\n+        Type identitySuper = null, valueSuper = null;\n+        for (Type t : types.closure(c)) {\n+            if (t != c) {\n+                if ((t.tsym.flags() & IDENTITY_TYPE) != 0)\n+                    identitySuper = t;\n+                else if ((t.tsym.flags() & VALUE_CLASS) != 0)\n+                    valueSuper = t;\n+                if (cIsValue &&  identitySuper != null) {\n+                    log.error(pos, Errors.ValueTypeHasIdentitySuperType(c, identitySuper));\n+                } else if (cHasIdentity &&  valueSuper != null) {\n+                    log.error(pos, Errors.IdentityTypeHasValueSuperType(c, valueSuper));\n+                } else if (identitySuper != null && valueSuper != null) {\n+                    log.error(pos, Errors.MutuallyIncompatibleSupers(c, identitySuper, valueSuper));\n+                }\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":53,"deletions":55,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2794,1 +2794,1 @@\n-        if ((isPrimitiveModifier() && allowPrimitiveClasses) || isValueModifier() && allowValueClasses) {\n+        if ((isPrimitiveModifier() && allowPrimitiveClasses) || (isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n@@ -3342,0 +3342,4 @@\n+                if (isIdentityModifier()) {\n+                    flag = Flags.IDENTITY_TYPE;\n+                    break;\n+                }\n@@ -3617,0 +3621,7 @@\n+        if (name == names.identity) {\n+            if (allowPrimitiveClasses) {\n+                return Source.JDK18;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n@@ -4519,2 +4530,2 @@\n-                case IDENTIFIER: \/\/ primitive record R || primitive primitive || primitive value || new primitive Comparable() {}\n-                    if (next.name() == names.record || next.name() == names.primitive\n+                case IDENTIFIER: \/\/ primitive record R || primitive primitive || primitive identity || primitive value || new primitive Comparable() {}\n+                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n@@ -4545,2 +4556,2 @@\n-                case IDENTIFIER: \/\/ value record R || value value || value primitive || new value Comparable() {} ??\n-                    if (next.name() == names.record || next.name() == names.value\n+                case IDENTIFIER: \/\/ value record R || value value || value identity || value primitive || new value Comparable() {} ??\n+                    if (next.name() == names.record || next.name() == names.value || next.name() == names.identity\n@@ -4559,0 +4570,26 @@\n+    protected boolean isIdentityModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.identity) {\n+            boolean isIdentityModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n+                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n+                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n+                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n+                case CLASS: case INTERFACE: case ENUM:\n+                    isIdentityModifier = true;\n+                    break;\n+                case IDENTIFIER: \/\/ identity record R || identity primitive || || identity identity || identity value || new identity Comparable() {}\n+                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n+                            || next.name() == names.value || (mode & EXPR) != 0)\n+                        isIdentityModifier = true;\n+                    break;\n+            }\n+            if (isIdentityModifier) {\n+                checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -266,3 +266,5 @@\n-# 0: type\n-compiler.misc.may.not.extend.top.interface.type=\\\n-    since it extends {0}\n+compiler.misc.value.interface.nonfunctional=\\\n+    since it is a value interface\n+\n+compiler.misc.identity.interface.nonfunctional=\\\n+    since it is an identity interface\n@@ -3957,3 +3959,3 @@\n-# 0: type\n-compiler.err.value.class.must.not.implement.identity.object=\\\n-    The value class {0} attempts to implement the incompatible interface IdentityObject\n+# 0: type, 1: type\n+compiler.err.value.type.has.identity.super.type=\\\n+    The identity type {1} cannot be a supertype of the value type {0}\n@@ -3961,3 +3963,3 @@\n-# 0: type\n-compiler.err.identity.class.must.not.implement.value.object=\\\n-    The identity class {0} attempts to implement the incompatible interface ValueObject\n+# 0: type, 1: type\n+compiler.err.identity.type.has.value.super.type=\\\n+    The value type {1} cannot be a supertype of the identity type {0}\n@@ -3965,3 +3967,3 @@\n-# 0: type\n-compiler.err.mutually.incompatible.super.interfaces=\\\n-    The type {0} attempts to implement the mutually incompatible interfaces ValueObject and IdentityObject\n+# 0: type, 1: type, 2: type\n+compiler.err.mutually.incompatible.supers=\\\n+    The type {0} has mutually incompatible supertypes: the identity type {1} and the value type {2}\n@@ -3977,1 +3979,1 @@\n-# 0: symbol, 1: symbol, 2: type\n+# 0: symbol, 1: message segment\n@@ -3979,1 +3981,1 @@\n-    The super class {2} of the value class {1} defines a constructor {0} that takes arguments. This is disallowed\n+    {1} defines a constructor {0} that takes arguments. This is disallowed\n@@ -3981,1 +3983,13 @@\n-# 0: symbol, 1: symbol, 2: type\n+# 0: symbol, 1: message segment\n+compiler.err.super.constructor.cannot.be.generic=\\\n+    {1} defines a generic constructor {0}. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.super.constructor.cannot.throw=\\\n+    {1} defines a constructor {0} that throws an exception. This is disallowed\n+\n+# 0: symbol, 1: message segment\n+compiler.err.super.constructor.access.restricted=\\\n+    {1} defines a constructor {0} with a weaker access privilege than the declaring class. This is disallowed\n+\n+# 0: symbol, 1: message segment\n@@ -3983,1 +3997,1 @@\n-    The super class {2} of the value class {1} defines an instance field {0}. This is disallowed\n+    {1} defines an instance field {0}. This is disallowed\n@@ -3985,1 +3999,1 @@\n-# 0: symbol, 1: symbol, 2: type\n+# 0: symbol, 1: message segment\n@@ -3987,1 +4001,1 @@\n-    The super class {2} of the value class {1} defines a nonempty no-arg constructor {0}. This is disallowed\n+    {1} defines a nonempty no-arg constructor {0}. This is disallowed\n@@ -3989,1 +4003,1 @@\n-# 0: symbol, 1: type\n+# 0: message segment\n@@ -3991,1 +4005,1 @@\n-    The super class {1} of the value class {0} declares one or more non-empty instance initializer blocks. This is disallowed.\n+    {0} declares one or more non-empty instance initializer blocks. This is disallowed.\n@@ -3993,1 +4007,1 @@\n-# 0: symbol, 1: type\n+# 0: message segment\n@@ -3995,1 +4009,9 @@\n-    The super class {1} of the value class {0} is an inner class. This is disallowed.\n+    {0} is an inner class. This is disallowed.\n+\n+# 0: symbol, 1: type\n+compiler.misc.superclass.of.value.class=\\\n+    The super class {1} of the value class {0}\n+\n+# 0: symbol\n+compiler.misc.abstract.value.class=\\\n+    The abstract value class {0}\n@@ -4010,3 +4032,0 @@\n-compiler.note.cant.instantiate.object.directly=\\\n-    Object cannot be instantiated directly; a subclass of Object will be instantiated instead, by invoking java.util.Objects.newIdentity()\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":44,"deletions":25,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -222,0 +222,3 @@\n+compiler.err.super.constructor.access.restricted\n+compiler.err.super.constructor.cannot.be.generic\n+compiler.err.super.constructor.cannot.throw\n@@ -228,0 +231,2 @@\n+compiler.misc.abstract.value.class\n+compiler.misc.superclass.of.value.class\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}