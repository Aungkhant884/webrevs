{"files":[{"patch":"@@ -1854,0 +1854,6 @@\n+      if (field->has_restricted_type()) {\n+        CheckCast* c = new CheckCast(field->type()->as_klass(), val, copy_state_before(), field->type()->as_inline_klass() != NULL);\n+        append_split(c);\n+        c->set_incompatible_class_change_check();\n+        c->set_direct_compare(field->type()->as_instance_klass()->is_final());\n+      }\n@@ -2021,0 +2027,6 @@\n+      if (field->has_restricted_type()) {\n+        CheckCast* c = new CheckCast(field->type()->as_klass(), val, copy_state_before(), field->type()->as_inline_klass() != NULL);\n+        append_split(c);\n+        c->set_incompatible_class_change_check();\n+        c->set_direct_compare(field->type()->as_instance_klass()->is_final());\n+      }\n@@ -2078,0 +2090,7 @@\n+  if (field_modify->has_restricted_type()) {\n+      CheckCast* c = new CheckCast(field_modify->type()->as_klass(), val, copy_state_before(), field_modify->type()->as_inline_klass() != NULL);\n+      append_split(c);\n+      c->set_incompatible_class_change_check();\n+      c->set_direct_compare(field_modify->type()->as_instance_klass()->is_final());\n+    }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1025,0 +1025,2 @@\n+  bool deoptimize_for_flattened_field = false;\n+  bool deoptimize_for_restricted_type = false;\n@@ -1041,1 +1043,20 @@\n-    assert(!result.is_inlined(), \"Can not patch access to flattened field\");\n+\n+    \/\/ With type restrictions, it possible that at compilation time,\n+    \/\/ the holder was unloaded, and C1 didn't know that the field\n+    \/\/ would be flattened, so the generated code is incorrect for a\n+    \/\/ flattened field. The  nmethod has to be deoptimized so that\n+    \/\/ the code can be regnerated correctly.\n+\n+    deoptimize_for_flattened_field = result.is_inlined();\n+\n+    \/\/ Another case caused by type restrictions: if the holder was\n+    \/\/ unloaded at compilation time, C1 didn't know that the field\n+    \/\/ could have type restrictions, and when the field has such\n+    \/\/ restrictions, it means additional checks have to be performed\n+    \/\/ to ensure the value being written satisfies those restrictions.\n+    \/\/ The nmethod has to be deoptimized so that the code can be\n+    \/\/ regenerated with the additional checks.\n+\n+    if ((code == Bytecodes::_putfield || code == Bytecodes::_putstatic) && result.has_restricted_type()) {\n+      deoptimize_for_restricted_type = true;\n+    }\n@@ -1154,1 +1175,2 @@\n-  if (deoptimize_for_volatile || deoptimize_for_atomic) {\n+  if (deoptimize_for_volatile || deoptimize_for_atomic || deoptimize_for_flattened_field ||\n+      deoptimize_for_restricted_type) {\n@@ -1165,0 +1187,6 @@\n+      if (deoptimize_for_flattened_field) {\n+        tty->print_cr(\"Deoptimizing for patching flattened field reference\");\n+      }\n+      if (deoptimize_for_restricted_type) {\n+        tty->print_cr(\"Deoptimizing for patching field with type restriction\");\n+      }\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -71,1 +71,2 @@\n-  _is_flattened(false), _known_to_link_with_put(NULL), _known_to_link_with_get(NULL) {\n+  _descriptor_signature(NULL), _is_flattened(false),\n+  _known_to_link_with_put(NULL), _known_to_link_with_get(NULL) {\n@@ -103,2 +104,0 @@\n-  _name = (ciSymbol*)ciEnv::current(THREAD)->get_symbol(name);\n-\n@@ -198,0 +197,3 @@\n+  if (fd->has_restricted_type()) {\n+    _descriptor_signature = env->get_symbol(fd->descriptor_signature());\n+  }\n@@ -237,0 +239,1 @@\n+  _descriptor_signature = field->_descriptor_signature;\n@@ -280,0 +283,1 @@\n+  ASSERT_IN_VM;\n@@ -287,0 +291,10 @@\n+  if (fd->has_restricted_type()) {\n+    _descriptor_signature = ciEnv::current(CompilerThread::current())->get_symbol(fd->descriptor_signature());\n+    _signature = ciEnv::current(CompilerThread::current())->get_symbol(fd->signature());\n+    \/\/ Only InstanceKlass should have fields\n+    assert(field_holder->is_instance_klass(), \"Sanity check\");\n+    InstanceKlass* field_holder_ik = InstanceKlass::cast(field_holder);\n+    \/\/ resetting the type because field's type has been switched from its descriptor signature\n+    \/\/ to its restricted type. The type will be set lazely wjen invoking the method type().\n+    _type = NULL;\n+  }\n@@ -289,1 +303,0 @@\n-  Klass* k = _holder->get_Klass();\n@@ -298,1 +311,1 @@\n-      if (k == SystemDictionary::System_klass()) {\n+      if (field_holder == SystemDictionary::System_klass()) {\n@@ -317,1 +330,1 @@\n-    if (k == SystemDictionary::CallSite_klass() &&\n+    if (field_holder == SystemDictionary::CallSite_klass() &&\n@@ -466,0 +479,5 @@\n+  tty->print(\" has_restricted_type=%s\", bool_to_str(_descriptor_signature != NULL));\n+  if (_descriptor_signature != NULL) {\n+    tty->print(\"descriptor signature=\");\n+    _descriptor_signature->print_symbol();\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  ciSymbol*        _descriptor_signature;\n@@ -103,0 +104,3 @@\n+  \/\/ What alternate signature can be used for this field in signature (must have a restricted type)\n+  ciSymbol* descriptor_signature() const { return _descriptor_signature; }\n+\n@@ -180,0 +184,1 @@\n+  bool has_restricted_type     () const { return _holder->is_loaded() && _descriptor_signature != NULL; }\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1674,1 +1674,1 @@\n-  _restricted_field_info = new GrowableArray<u2>(total_fields);\n+  _descriptor_signature_info = new GrowableArray<u2>(total_fields);\n@@ -1786,0 +1786,17 @@\n+    \/\/ RestrictedField:\n+    \/\/ The current model for restricted field is that such a field has a descriptor signature used\n+    \/\/ as the normal signature for this field (for instance in field access bytecodes) but it also\n+    \/\/ has a restricted type that will be used internally by the VM as the real type of the field.\n+    \/\/ Current constrains are that the restricted type must be an inline type and the descriptor\n+    \/\/ type must be a super type of the restricted type.\n+    \/\/ The code below verifies that the restricted type is an inline type. The property that the\n+    \/\/ descriptor type is a super type of the restricted type is verified just after the pre-loading\n+    \/\/ of the restricted type (inline type field preloading)\n+    if (has_restricted_type && cp->basic_type_for_signature_at(restricted_type_index) != T_INLINE_TYPE) {\n+      \/\/ Probably not the right error to throw\n+      THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                err_msg(\"Field %s.%s has a RestricteField attribute but its restricted type is not an inline type\",\n+                _class_name->as_C_string(),\n+                _cp->symbol_at(restricted_type_index)->as_C_string()));\n+    }\n+\n@@ -1800,1 +1817,1 @@\n-    _restricted_field_info->append(erased_type_index);\n+    _descriptor_signature_info->append(erased_type_index);\n@@ -1852,1 +1869,1 @@\n-      _restricted_field_info->append(0);\n+      _descriptor_signature_info->append(0);\n@@ -1867,1 +1884,1 @@\n-    _restricted_field_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)));\n+    _descriptor_signature_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)));\n@@ -1884,1 +1901,1 @@\n-    _restricted_field_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)));\n+    _descriptor_signature_info->append((u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)));\n@@ -5916,1 +5933,1 @@\n-    u2* rfi = ik->fields_erased_type();\n+    u2* rfi = ik->fields_descriptor_type();\n@@ -5918,1 +5935,1 @@\n-      rfi[i] = _restricted_field_info->at(i);\n+      rfi[i] = _descriptor_signature_info->at(i);\n@@ -6120,1 +6137,1 @@\n-  _restricted_field_info(NULL),\n+  _descriptor_signature_info(NULL),\n@@ -6754,0 +6771,14 @@\n+      if (fs.has_restricted_type()) {\n+        \/\/ descriptor type supposed to be a super type of the restricted type, so after the pre-loading\n+        \/\/ of the restricted type above, the descriptor type should be loaded at this point\n+        Symbol* descriptor_name = _cp->symbol_at(_descriptor_signature_info->at(fs.index()));\n+        Klass* desc_klass = SystemDictionary::resolve_or_null(descriptor_name,\n+                                                   Handle(THREAD, _loader_data->class_loader()),\n+                                                   _protection_domain, CHECK);\n+        if (desc_klass == NULL || !klass->is_subtype_of(desc_klass)) {\n+          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                    err_msg(\"Restricted type %s should be a subtype of the descriptor type %s, but it is not\",\n+                    fs.signature()->as_C_string(),\n+                    descriptor_name->as_C_string()));\n+        }\n+      }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":39,"deletions":8,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  GrowableArray<u2>* _restricted_field_info;\n+  GrowableArray<u2>* _descriptor_signature_info;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -981,1 +981,1 @@\n-  if (PrintFieldLayout) {\n+  if (PrintFieldLayout || (PrintInlineLayout && _has_flattening_information)) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -342,0 +342,11 @@\n+    oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);\n+    if (voop == NULL) {\n+      THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);\n+    }\n+    if (vklass->field_has_restricted_type(field_index)) {\n+      Klass* value_klass = voop->klass();\n+      Klass* field_klass = vklass->get_inline_type_field_klass(field_index);\n+      if (!value_klass->is_subtype_of(field_klass)) {\n+        THROW_(vmSymbols::java_lang_IncompatibleClassChangeError(), return_offset);\n+      }\n+    }\n@@ -343,2 +354,1 @@\n-      oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);\n-      assert(vt_oop != NULL && oopDesc::is_oop(vt_oop) && vt_oop->is_inline_type(),\"argument must be an inline type\");\n+      assert(voop != NULL && oopDesc::is_oop(voop) && voop->is_inline_type(),\"argument must be an inline type\");\n@@ -346,2 +356,2 @@\n-      assert(vt_oop != NULL && field_vk == vt_oop->klass(), \"Must match\");\n-      field_vk->write_inlined_field(new_value_h(), offset, vt_oop, CHECK_(return_offset));\n+      assert(voop != NULL && field_vk == voop->klass(), \"Must match\");\n+      field_vk->write_inlined_field(new_value_h(), offset, voop, CHECK_(return_offset));\n@@ -349,1 +359,0 @@\n-      oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);\n@@ -543,0 +552,6 @@\n+  if (value == NULL) {\n+    if (field_klass->is_inline_klass()) {\n+      THROW(vmSymbols::java_lang_NullPointerException());\n+    }\n+    return;\n+  }\n@@ -545,1 +560,3 @@\n-  assert(value_klass->is_subtype_of(field_klass), \"Just checking\");\n+  if (!value_klass->is_subtype_of(field_klass)) {\n+    THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n+  };\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  Symbol* secondary_signature() const {\n+  Symbol* descriptor_signature() const {\n@@ -127,1 +127,1 @@\n-    int sig_index = field_holder()->fields_erased_type()[index()];\n+    int sig_index = field_holder()->fields_descriptor_type()[index()];\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -521,0 +521,4 @@\n+  if (parser.has_restricted_fields()) {\n+    ik->set_has_restricted_fields(); \/\/ required to get the size right when calling size()\n+  }\n+\n@@ -1664,1 +1668,2 @@\n-      Symbol* f_sig  = fs.signature();\n+      Symbol* f_sig = NULL;\n+      f_sig  = fs.signature();\n@@ -1670,2 +1675,2 @@\n-        Symbol* f_sig2 = fs.secondary_signature();\n-        if (f_name == name && f_sig2 == sig) {\n+        f_sig = fs.descriptor_signature();\n+        if (f_sig == sig) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -482,1 +482,1 @@\n-    return (_misc_flags & _misc_has_injected_identityObject);\n+    return (_misc_flags & _misc_has_injected_identityObject) != 0;\n@@ -490,1 +490,1 @@\n-    return (_misc_flags & _misc_has_restricted_fields);\n+    return (_misc_flags & _misc_has_restricted_fields) != 0;\n@@ -561,0 +561,1 @@\n+  bool    field_has_restricted_type(int index) const { return field(index)->has_restricted_type(); }\n@@ -1221,1 +1222,1 @@\n-           (has_restricted_fields ? java_fields * (int)sizeof(u2)\/wordSize : 0));\n+           (has_restricted_fields ? (align_up(java_fields * (int)sizeof(u2), wordSize)\/wordSize) : 0));\n@@ -1291,1 +1292,1 @@\n-  u2* fields_erased_type();\n+  u2* fields_descriptor_type();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-inline u2* InstanceKlass::fields_erased_type() {\n+inline u2* InstanceKlass::fields_descriptor_type() {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,7 @@\n+Symbol* fieldDescriptor::descriptor_signature() const {\n+  if (!has_restricted_type()) {\n+    return NULL;  \/\/ or the real signature could be returned\n+  }\n+  return _cp->symbol_at(field_holder()->fields_descriptor_type()[_index]);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  Symbol* descriptor_signature()  const;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.typerestrictions;\n+\n+import jdk.test.lib.Asserts;\n+\n+\n+\/*\n+ * @test\n+ * @summary Testing accessing flattened field from class with no knowledge of the type restriction\n+ * @library \/test\/lib\n+ * @compile  -XDflattenWithTypeRestrictions SimpleTest.java IncompleteKnowledgeTest.java\n+ * @run main\/othervm -Xverify:none -Xcomp runtime.valhalla.typerestrictions.IncompleteKnowledgeTest\n+ *\/\n+public class IncompleteKnowledgeTest {\n+    public static void main(String[] args) {\n+\n+        double x = 0.0D;\n+        for (int i = 0; i < 100; i++) {\n+            SimpleTest st = new SimpleTest();\n+            x = st.p.x;\n+        }\n+        System.out.println(x);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/IncompleteKnowledgeTest.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.typerestrictions;\n+\n+import java.lang.invoke.RestrictedType;\n+\n+class PointBox {\n+\n+    @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+    static public Point.ref p84;\n+\n+    @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+    static public Object p71;\n+\n+    static inline class Point {\n+        public double x;\n+        public double y;\n+\n+        public Point(double x, double y) { this.x = x; this.y = y; }\n+    }\n+\n+    static inline class Rec {\n+        @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+        public Point.ref p37;\n+\n+        @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+        public Object p23;\n+\n+        public Rec() { this.p37 = new Point(0.0, 0.0); this.p23 = new Point(0.0, 0.0);}\n+\n+        Rec setp37(Point.ref p) {\n+            Rec r = Rec.default;\n+            r = __WithField(r.p37, p);\n+            r = __WithField(r.p23, this.p23);\n+            return r;\n+        }\n+\n+        Rec setp23(Object o) {\n+            Rec r = Rec.default;\n+            r = __WithField(r.p37, this.p37);\n+            r = __WithField(r.p23, o);\n+            return r;\n+        }\n+    }\n+\n+    @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+    public Point.ref p368;\n+\n+    @RestrictedType(\"Qruntime\/valhalla\/typerestrictions\/PointBox$Point;\")\n+    public Object p397;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/PointBox.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.typerestrictions;\n+\n+\n+\/*\n+ * @test RestrictedTypeAnnotationTest\n+ * @summary check that code can operate on a field with a restricted type only known by the JVM\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @compile -XDallowWithFieldOperator RestrictedTypeAnnotationTest.java PointBox.java\n+ * @run main\/othervm -XX:+TieredCompilation -XX:TieredStopAtLevel=1 -XX:CompileThreshold=100 runtime.valhalla.typerestrictions.RestrictedTypeAnnotationTest\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.*;\n+\n+public class RestrictedTypeAnnotationTest {\n+    static final int ITERATIONS = 500;\n+    static final Unsafe U = Unsafe.getUnsafe();\n+    static double d;\n+\n+    public static void main(String[] args) {\n+        PointBox pb = new PointBox();\n+        Class<?> c = PointBox.class;\n+        Field p368 = null;\n+        try {\n+            p368 = c.getDeclaredField(\"p368\");\n+        } catch (NoSuchFieldException e) {\n+            e.printStackTrace();\n+            return;\n+        }\n+        Asserts.assertTrue(U.isFlattened(p368), \"field PointBox.p369 should be flattened\");\n+        Class<?> testClass = RestrictedTypeAnnotationTest.class;\n+        Method[] methods = testClass.getDeclaredMethods();\n+        for (Method m : methods) {\n+            if (Modifier.isStatic(m.getModifiers()) &&\n+                m.getName().startsWith(\"test\") &&\n+                m.getParameterCount() == 0) {\n+                    System.out.println(\"Invoking \" + m.getName());\n+                    try {\n+                        m.invoke(null);\n+                    } catch(Throwable t) {\n+                        t.printStackTrace();\n+                        return;\n+                    }\n+                }\n+        }\n+    }\n+\n+\n+    \/\/ Reading field x from flattened field p368 without knowing p368 is flattened (getfield)\n+    static void test1() {\n+        PointBox pb = new PointBox();\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            d = pb.p368.x;\n+        }\n+    }\n+\n+    \/\/ Writting to field p368 without knowning p368 is flattened (putfield)\n+    static void test2() {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            PointBox pb = new PointBox();\n+            PointBox.Point p = new PointBox.Point(2.0, 3.0);\n+            pb.p368 = p;\n+            Asserts.assertEquals(pb.p368, p);\n+        }\n+    }\n+\n+    static PointBox.Point.ref spoint = new PointBox.Point(1.0, 2.0);\n+\n+    \/\/ Trying to write null to field p368 without knowing it is null-free (putfield)\n+    static void test3() {\n+        spoint = null;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            PointBox pb = new PointBox();\n+            Exception e = null;\n+            try {\n+                pb.p368 = spoint;\n+            } catch(NullPointerException npe) {\n+                e = npe;\n+            }\n+            if (e == null) {\n+                throw new RuntimeException(\"Missing NPE\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Trying to write a value from the wrong type (pufield)\n+    static void test4() {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            PointBox pb = new PointBox();\n+            Error e = null;\n+            try {\n+                pb.p397 = new String(\"hello\");\n+            } catch(IncompatibleClassChangeError icce) {\n+                e = icce;\n+            }\n+            if (e == null) {\n+                throw new RuntimeException(\"Missing ICCE\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Writting to field p368 without knowning p368 is flattened (withfield)\n+    static void test5() {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            PointBox.Rec rec = new PointBox.Rec();\n+            PointBox.Point p = new PointBox.Point(2.0, 3.0);\n+            rec = rec.setp37(p);\n+            Asserts.assertEquals(rec.p37, p);\n+        }\n+    }\n+\n+    \/\/ Trying to write null to field p368 without knowing it is null-free (withfield)\n+    static void test6() {\n+        spoint = null;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            PointBox.Rec rec = new PointBox.Rec();\n+            Exception e = null;\n+            try {\n+                rec.setp37(spoint);\n+            } catch(NullPointerException npe) {\n+                e = npe;\n+            }\n+            if (e == null) {\n+                throw new RuntimeException(\"Missing NPE\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Trying to write a value from the wrong type (withield)\n+    static void test7() {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            PointBox.Rec rec = new PointBox.Rec();\n+            Error e = null;\n+            try {\n+                rec.setp23(new String(\"hello\"));\n+            } catch(IncompatibleClassChangeError icce) {\n+                e = icce;\n+            }\n+            if (e == null) {\n+                throw new RuntimeException(\"Missing ICCE\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Trying to write null to field p368 without knowing it is null-free (putstatic)\n+    static void test8() {\n+        spoint = null;\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            Exception e = null;\n+            try {\n+                PointBox.p84 = spoint;\n+            } catch(NullPointerException npe) {\n+                e = npe;\n+            }\n+            if (e == null) {\n+                throw new RuntimeException(\"Missing NPE\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Trying to write a value from the wrong type (putstatic)\n+    static void test9() {\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            Error e = null;\n+            try {\n+                PointBox.p71 = new String(\"hello\");\n+            } catch(IncompatibleClassChangeError icce) {\n+                e = icce;\n+            }\n+            if (e == null) {\n+                throw new RuntimeException(\"Missing ICCE\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/TypeRestrictions\/RestrictedTypeAnnotationTest.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"}]}