{"files":[{"patch":"@@ -2137,1 +2137,1 @@\n-        \/\/ Static field is initialized, we don need to perform a null check.\n+        \/\/ Static field is initialized, we don't need to perform a null check.\n@@ -2141,4 +2141,0 @@\n-    LabelObj* L_end = new LabelObj();\n-    __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(NULL));\n-    __ branch(lir_cond_notEqual, L_end->label());\n-    set_in_conditional_code(true);\n@@ -2146,3 +2142,13 @@\n-    Constant* default_value = new Constant(new InstanceConstant(inline_klass->default_instance()));\n-    if (default_value->is_pinned()) {\n-      __ move(LIR_OprFact::value_type(default_value->type()), result);\n+    if (inline_klass->is_initialized()) {\n+      LabelObj* L_end = new LabelObj();\n+      __ cmp(lir_cond_notEqual, result, LIR_OprFact::oopConst(NULL));\n+      __ branch(lir_cond_notEqual, L_end->label());\n+      set_in_conditional_code(true);\n+      Constant* default_value = new Constant(new InstanceConstant(inline_klass->default_instance()));\n+      if (default_value->is_pinned()) {\n+        __ move(LIR_OprFact::value_type(default_value->type()), result);\n+      } else {\n+        __ move(load_constant(default_value), result);\n+      }\n+      __ branch_destination(L_end->label());\n+      set_in_conditional_code(false);\n@@ -2150,1 +2156,3 @@\n-      __ move(load_constant(default_value), result);\n+      __ cmp(lir_cond_equal, result, LIR_OprFact::oopConst(NULL));\n+      __ branch(lir_cond_equal, new DeoptimizeStub(info, Deoptimization::Reason_uninitialized,\n+                                                         Deoptimization::Action_make_not_entrant));\n@@ -2152,2 +2160,0 @@\n-    __ branch_destination(L_end->label());\n-    set_in_conditional_code(false);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -791,2 +791,4 @@\n-    ciType* mh_rt = inline_cg()->method()->return_type();\n-    if (is_mh_late_inline() && mh_rt->is_inlinetype() && mh_rt->as_inline_klass()->can_be_returned_as_fields()) {\n+    ciMethod* inline_method = inline_cg()->method();\n+    ciType* return_type = inline_method->return_type();\n+    if (is_mh_late_inline() && inline_method->signature()->returns_null_free_inline_type() &&\n+        return_type->as_inline_klass()->can_be_returned_as_fields()) {\n@@ -801,1 +803,1 @@\n-        Node* klass_node = arg_kit.makecon(TypeKlassPtr::make(mh_rt->as_inline_klass()));\n+        Node* klass_node = arg_kit.makecon(TypeKlassPtr::make(return_type->as_inline_klass()));\n@@ -831,2 +833,2 @@\n-      C->set_has_loops(C->has_loops() || inline_cg()->method()->has_loops());\n-      C->env()->notice_inlined_method(inline_cg()->method());\n+      C->set_has_loops(C->has_loops() || inline_method->has_loops());\n+      C->env()->notice_inlined_method(inline_method);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1953,6 +1953,6 @@\n-      \/\/ Update the cast input and let ConstraintCastNode::Ideal push it through the InlineTypePtrNode\n-      Node* cast = casts.pop();\n-      phase->hash_delete(cast);\n-      cast->set_req(1, n);\n-      n = phase->transform(cast);\n-      assert(n->is_InlineTypePtr(), \"Failed to push cast through InlineTypePtr\");\n+      \/\/ Push the cast(s) through the InlineTypePtrNode\n+      Node* cast = casts.pop()->clone();\n+      cast->set_req(1, n->as_InlineTypePtr()->get_oop());\n+      n = n->clone();\n+      n->as_InlineTypePtr()->set_oop(phase->transform(cast));\n+      n = phase->transform(n);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -613,1 +613,1 @@\n-  Node* oop = vk->is_empty() ? default_oop(gvn, vk) : gvn.zerocon(T_INLINE_TYPE);\n+  Node* oop = (vk->is_empty() && vk->is_initialized()) ? default_oop(gvn, vk) : gvn.zerocon(T_INLINE_TYPE);\n@@ -626,1 +626,2 @@\n-  InlineTypeNode* vt = new InlineTypeNode(vk, default_oop(gvn, vk));\n+  Node* oop = vk->is_initialized() ? default_oop(gvn, vk) : gvn.zerocon(T_INLINE_TYPE);\n+  InlineTypeNode* vt = new InlineTypeNode(vk, oop);\n@@ -836,1 +837,1 @@\n-  if (field_count() == 0) {\n+  if (field_count() == 0 && vk->is_initialized()) {\n@@ -984,1 +985,2 @@\n-  if (is_default(phase) && (!oop->is_Con() || phase->type(oop)->is_zero_type())) {\n+  if (is_default(phase) && inline_klass()->is_initialized() &&\n+      (!oop->is_Con() || phase->type(oop)->is_zero_type())) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1222,0 +1222,1 @@\n+    @Warmup(10000)\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,2 @@\n+            \/\/ Don't run with DeoptimizeALot until JDK-8239003 is fixed\n+            scenario.addFlags(\"-XX:-DeoptimizeALot\");\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}