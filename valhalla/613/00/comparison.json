{"files":[{"patch":"@@ -619,1 +619,1 @@\n-        if (allowUniversalTVars && (s.isPrimitiveClass() && !t.isPrimitiveClass())) {\n+        if (allowUniversalTVars && !t.hasTag(BOT) && s.isPrimitiveClass() && !t.isPrimitiveClass()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-                class C<__universal T extends Reader> { T x = null; \/* ok *\/ }\n+                class C<__universal T extends Reader> { T x = null; }\n@@ -106,1 +106,1 @@\n-                class C<T extends Reader> { T x = null; \/* ok *\/ }\n+                class C<T extends Reader> { T x = null; }\n@@ -112,1 +112,1 @@\n-                class C<__universal T extends Reader> { T.ref x = null; \/* ok *\/ }\n+                class C<__universal T extends Reader> { T.ref x = null; }\n@@ -138,5 +138,4 @@\n-                        \/* this invocation will provoke a subtype checking, basically a check testing if:\n-                         * `Box<Point> <: Box<? extends Shape>`, this should stress the new `isBoundedBy` relation,\n-                         * in particular it should check if `Point` is bounded by `Shape`, which is true as\n-                         * `Point.ref` isBoundedBy Shape\n-                         *\/\n+                        \/\/ this invocation will provoke a subtype checking, basically a check testing if:\n+                        \/\/ `Box<Point> <: Box<? extends Shape>`, this should stress the new `isBoundedBy` relation,\n+                        \/\/ in particular it should check if `Point` is bounded by `Shape`, which is true as\n+                        \/\/ `Point.ref` isBoundedBy Shape\n@@ -204,1 +203,1 @@\n-                    void set(T arg) { x = arg; \/* ok *\/ }\n+                    void set(T arg) { x = arg; }\n@@ -287,4 +286,0 @@\n-        \/*\n-        assertOKWithWarning(\"compiler.warn.method.should.not.be.invoked.on.universal.tvars\",\n-                \"\"\"\n-                primitive class Point {}\n@@ -292,8 +287,11 @@\n-                class Test<__universal T> {\n-                    void m(T t) throws Throwable {\n-                        t.wait();\n-                    }\n-                }\n-                \"\"\"\n-        );\n-        *\/\n+        \/\/assertOKWithWarning(\"compiler.warn.method.should.not.be.invoked.on.universal.tvars\",\n+        \/\/        \"\"\"\n+        \/\/        primitive class Point {}\n+\n+        \/\/        class Test<__universal T> {\n+        \/\/            void m(T t) throws Throwable {\n+        \/\/                t.wait();\n+        \/\/            }\n+        \/\/        }\n+        \/\/        \"\"\"\n+        \/\/);\n@@ -437,21 +435,68 @@\n-        \/* this one should generate unchecked warning\n-        interface MyList<__universal E> {}\n-\n-        class MyArrays {\n-            @SafeVarargs\n-            @SuppressWarnings(\"varargs\")\n-            public static <__universal T> MyList<T> asList(T... a) {\n-                return null;\n-            }\n-        }\n-\n-        class Test<__universal T> {\n-            MyList<T.ref> newList() {\n-                return MyArrays.asList(null, null);\n-            }\n-\n-            void foo() {\n-                MyList<T> list = newList(); \/\/ unchecked warning\n-            }\n-        }\n-        *\/\n+        \/\/ this one should generate unchecked warning\n+        \/\/interface MyList<__universal E> {}\n+\n+        \/\/class MyArrays {\n+        \/\/    @SafeVarargs\n+        \/\/    @SuppressWarnings(\"varargs\")\n+        \/\/    public static <__universal T> MyList<T> asList(T... a) {\n+        \/\/        return null;\n+        \/\/    }\n+        \/\/}\n+\n+        \/\/class Test<__universal T> {\n+        \/\/    MyList<T.ref> newList() {\n+        \/\/        return MyArrays.asList(null, null);\n+        \/\/    }\n+\n+        \/\/    void foo() {\n+        \/\/        MyList<T> list = newList(); \/\/ unchecked warning\n+        \/\/    }\n+        \/\/}\n+    }\n+\n+    public void testNegCompilationTests() {\n+        setCompileOptions(EMPTY_OPTIONS);\n+        \/\/ should fail unexpected type, reference expected type variable `T` is not universal\n+        assertFail(\"compiler.err.type.found.req\",\n+                \"\"\"\n+                primitive class Point {}\n+\n+                class C<T> {\n+                    C<Point> cp;\n+                }\n+                \"\"\"\n+        );\n+    }\n+\n+    public void testWildcards() {\n+        setCompileOptions(EMPTY_OPTIONS);\n+        assertFail(\"compiler.err.prob.found.req\",\n+                \"\"\"\n+                primitive class Point {}\n+\n+                class MyList<__universal T> {\n+                    void add(T e) {}\n+                }\n+\n+                class Test {\n+                    void m(MyList<? super Point> ls) {\n+                        ls.add(null);\n+                    }\n+                }\n+                \"\"\"\n+        );\n+\n+        \/\/ primitive classes don't have subtypes\n+        assertFail(\"compiler.err.not.within.bounds\",\n+                \"\"\"\n+                primitive class Point {}\n+\n+                class MyList<__universal T> {}\n+\n+                class Test {\n+                    void m() {\n+                        MyList<? extends Point> ls = null;\n+                    }\n+                }\n+                \"\"\"\n+        );\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/universal-type-variables\/UniversalTVarsCompilationTests.java","additions":87,"deletions":42,"binary":false,"changes":129,"status":"modified"}]}