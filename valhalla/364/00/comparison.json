{"files":[{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.annotation;\n+\n+\/** Annotation used to define bind to a class parameter\n+ *\/\n+@Target(ElementType.METHOD)\n+public @interface LinkageClass {\n+    \/** Indicates the value the class parameter will be specialized with\n+     * @return the value the class parameter will be specialized with\n+     *\/\n+    String value();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/annotation\/LinkageClass.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.annotation;\n+\n+\/** Annotation used to define bind to a method parameter\n+ *\/\n+@Target(ElementType.METHOD)\n+public @interface LinkageMethod {\n+    \/** Indicates the value the method parameter will be specialized with\n+     * @return the value the method parameter will be specialized with\n+     *\/\n+    String value();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/annotation\/LinkageMethod.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.annotation;\n+\n+\/** Enumerated class specifying the kind of the parameter for the {@code Parametric} annotation\n+ *\/\n+public enum ParamKind {\n+    \/** class parameter\n+     *\/\n+    CLASS,\n+    \/** method only parameters\n+     *\/\n+    METHOD_ONLY,\n+    \/** method and class parameters\n+     *\/\n+    METHOD_AND_CLASS;\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/annotation\/ParamKind.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.annotation;\n+\n+\/** Annotates elements that are to be parameterized\n+ *\/\n+@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR})\n+public @interface Parametric {\n+    \/**\n+     * the id\n+     * @return the id\n+     *\/\n+    String id();\n+\n+    \/**\n+     * the kind\n+     * @return the kind\n+     *\/\n+    ParamKind kind() default ParamKind.CLASS;\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/annotation\/Parametric.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -69,1 +69,0 @@\n-import com.sun.tools.javac.util.Options;\n@@ -228,0 +227,3 @@\n+    public final Type parametricType;\n+    public final Type linkageClassType;\n+    public final Type linkageMethodType;\n@@ -604,0 +606,3 @@\n+        parametricType = enterClass(\"java.lang.annotation.Parametric\");\n+        linkageClassType = enterClass(\"java.lang.annotation.LinkageClass\");\n+        linkageMethodType = enterClass(\"java.lang.annotation.LinkageMethod\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+    public final static int CONSTANT_Parameter = 21;\n+    public final static int CONSTANT_Linkage = 22;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1280,0 +1280,11 @@\n+            new AttributeReader(names.Parametric, V61, CLASS_OR_MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind);\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    \/\/ just read the info, nothing to do for now\n+                    nextChar();\n+                    nextChar();\n+                }\n+            },\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -111,0 +111,2 @@\n+    private boolean supportParametricVM;\n+\n@@ -195,0 +197,2 @@\n+\n+        supportParametricVM = options.isSet(\"supportParametricVM\");\n@@ -376,0 +380,4 @@\n+        if (supportParametricVM && sym.attribute(syms.parametricType.tsym) != null) {\n+            writeParametricAttribute(sym);\n+            acount++;\n+        }\n@@ -865,0 +873,20 @@\n+    int writeParametricAttribute(Symbol sym) {\n+        int alenIdx = writeAttr(names.Parametric);\n+        int kind = 1; \/\/ the default\n+        Attribute.Compound c = sym.attribute(syms.parametricType.tsym);\n+        Attribute value = c.member(names.kind);\n+        if (value != null && value instanceof Attribute.Enum) {\n+            Name kindName = ((Attribute.Enum)value).value.name;\n+            kind = switch (kindName.toString()) {\n+                case \"CLASS\" -> 1;\n+                case \"METHOD_ONLY\" -> 2;\n+                case \"METHOD_AND_CLASS\" -> 3;\n+                default -> throw new AssertionError(\"unexpected kind\");\n+            };\n+        }\n+        databuf.appendChar(poolWriter.putParameter(kind));\n+        databuf.appendChar(0);\n+        endAttr(alenIdx);\n+        return 1;\n+    }\n+\n@@ -1713,0 +1741,5 @@\n+        if (supportParametricVM && c.attribute(syms.parametricType.tsym) != null) {\n+            writeParametricAttribute(c);\n+            acount++;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -220,0 +220,1 @@\n+        this.poolWriter.currentMethSymbol = meth;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-        poolWriter = new PoolWriter(types, names);\n+        poolWriter = new PoolWriter(types, names, syms, log, options.isSet(\"supportParametricVM\"));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.Symbol;\n@@ -224,0 +225,53 @@\n+\n+    \/**\n+     * A pool constant implementation describing a parameter pool entry.\n+     *\/\n+    final class Parameter implements PoolConstant {\n+\n+        final int kind;\n+\n+        Parameter(int kind) {\n+            this.kind = kind;\n+        }\n+\n+        @Override\n+        public int poolTag() {\n+            return ClassFile.CONSTANT_Parameter;\n+        }\n+\n+        @Override\n+        public Object poolKey(Types types) {\n+            return Integer.valueOf(kind);\n+        }\n+    }\n+\n+    \/**\n+     * A pool constant implementation describing a linkage pool entry.\n+     *\/\n+    final class Linkage implements PoolConstant {\n+\n+        final Object parameter;\n+        \/\/ could be symbol or type\n+        final Object reference;\n+        final boolean isClassReference;\n+\n+        Linkage(Object parameter, Object reference, boolean isClassReference) {\n+            this.parameter = parameter;\n+            this.reference = reference;\n+            this.isClassReference = isClassReference;\n+        }\n+\n+        @Override\n+        public int poolTag() {\n+            return ClassFile.CONSTANT_Linkage;\n+        }\n+\n+        @Override\n+        public Object poolKey(Types types) {\n+            return new Pair<>(parameter, reference);\n+        }\n+\n+        public boolean hasClassReference() {\n+            return isClassReference;\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolConstant.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import com.sun.tools.javac.jvm.PoolConstant.Parameter;\n+import com.sun.tools.javac.jvm.PoolConstant.Linkage;\n@@ -39,1 +41,0 @@\n-import java.util.Arrays;\n@@ -50,0 +51,1 @@\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Linkage;\n@@ -57,0 +59,1 @@\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Parameter;\n@@ -100,0 +103,2 @@\n+    private static final BitSet parameterCP = new BitSet();\n+    private static final BitSet linkageCP = new BitSet();\n@@ -108,0 +113,2 @@\n+        parameterCP.set(CONSTANT_Parameter);\n+        linkageCP.set(CONSTANT_Linkage);\n@@ -180,0 +187,14 @@\n+    \/**\n+     * Get a parameter from the pool at given index.\n+     *\/\n+    Parameter getParameter(int index) {\n+        return pool.readIfNeeded(index, parameterCP);\n+    }\n+\n+    \/**\n+     * Get a linkage from the pool at given index.\n+     *\/\n+    Linkage getLinkage(int index) {\n+        return pool.readIfNeeded(index, linkageCP);\n+    }\n+\n@@ -238,0 +259,6 @@\n+            case CONSTANT_Parameter: {\n+                int kind = poolbuf.getByte(offset);\n+                \/\/ ignore the bsm entry for now\n+                poolbuf.getChar(offset + 1);\n+                return new Parameter(kind);\n+            }\n@@ -274,0 +301,1 @@\n+                case CONSTANT_Parameter:\n@@ -284,0 +312,1 @@\n+                case CONSTANT_Linkage:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolReader.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.Attribute;\n@@ -35,0 +36,1 @@\n+import com.sun.tools.javac.code.Symtab;\n@@ -40,0 +42,1 @@\n+import com.sun.tools.javac.jvm.PoolConstant.Linkage;\n@@ -45,0 +48,2 @@\n+import com.sun.tools.javac.jvm.PoolConstant.Parameter;\n+import com.sun.tools.javac.util.Assert;\n@@ -47,0 +52,1 @@\n+import com.sun.tools.javac.util.Log;\n@@ -54,0 +60,1 @@\n+import java.util.HashSet;\n@@ -57,0 +64,1 @@\n+import java.util.Set;\n@@ -88,0 +96,6 @@\n+    private final Symtab syms;\n+\n+    private final Log log;\n+\n+    private final boolean supportParametricVM;\n+\n@@ -100,1 +114,4 @@\n-    public PoolWriter(Types types, Names names) {\n+    \/\/ current symbol for which the code is being generated\n+    Symbol.MethodSymbol currentMethSymbol;\n+\n+    public PoolWriter(Types types, Names names, Symtab syms, Log log, boolean supportParametricVM) {\n@@ -103,0 +120,2 @@\n+        this.syms = syms;\n+        this.log = log;\n@@ -105,0 +124,1 @@\n+        this.supportParametricVM = supportParametricVM;\n@@ -111,1 +131,11 @@\n-        return putClass(csym.type);\n+        Attribute.Compound parametricAnno = csym.attribute(syms.parametricType.tsym);\n+        if (supportParametricVM &&\n+                parametricAnno != null &&\n+                enclMethodHasLinkageAnno() &&\n+                !referencesBeingLinked.contains(csym)) {\n+            int linkageIndex = generateLinkage(types.erasure(csym.type), parametricAnno);\n+            if (linkageIndex > 0) {\n+                return linkageIndex;\n+            }\n+        }\n+        return pool.writeIfNeeded(types.erasure(csym.type));\n@@ -119,0 +149,10 @@\n+        Attribute.Compound parametricAnno = t.tsym.attribute(syms.parametricType.tsym);\n+        if (supportParametricVM &&\n+                parametricAnno != null &&\n+                enclMethodHasLinkageAnno() &&\n+                !referencesBeingLinked.contains(t)) {\n+            int linkageIndex = generateLinkage(t, parametricAnno);\n+            if (linkageIndex > 0) {\n+                return linkageIndex;\n+            }\n+        }\n@@ -127,0 +167,1 @@\n+        \/\/ still need to check here if linkage is necessary\n@@ -130,0 +171,2 @@\n+    Set<Object> referencesBeingLinked = new HashSet<>();\n+\n@@ -134,0 +177,10 @@\n+        Attribute.Compound parametricAnno = s.attribute(syms.parametricType.tsym);\n+        if (supportParametricVM &&\n+                parametricAnno != null &&\n+                enclMethodHasLinkageAnno() &&\n+                !referencesBeingLinked.contains(s)) {\n+            int linkageIndex = generateLinkage(s, parametricAnno);\n+            if (linkageIndex > 0) {\n+                return linkageIndex;\n+            }\n+        }\n@@ -137,0 +190,71 @@\n+    \/\/ where\n+        boolean enclMethodHasLinkageAnno() {\n+            return currentMethSymbol != null && (currentMethSymbol.attribute(syms.linkageMethodType.tsym) != null ||\n+                    currentMethSymbol.attribute(syms.linkageClassType.tsym) != null);\n+        }\n+\n+        \/* this method will try to generate a Linkage that will eventually be written into the constant pool\n+         * if it can't find all the needed information it will bail out, and return -1, to inform the caller\n+         * to generate the corresponding legacy entry. If successful it will return the index of the corresponding\n+         * Linkage_info constant in the constant pool\n+         *\/\n+        int generateLinkage(Object s, Attribute.Compound parametricAnno) {\n+            \/\/ the referred element is parametric\n+            if (!supportParametricVM) return -1;\n+            Name kindName = names.CLASS;\n+            Attribute value = parametricAnno.member(names.kind);\n+            if (value != null && value instanceof Attribute.Enum) {\n+                kindName = ((Attribute.Enum)value).value.name;\n+            }\n+\n+            \/\/ let's find out if the enclosing method has any linkage annotations\n+            String linkageMethodValueStr = null;\n+            Attribute.Compound linkageMethodAnno = currentMethSymbol.attribute(syms.linkageMethodType.tsym);\n+            if (linkageMethodAnno != null) {\n+                Attribute linkageMethodValue = linkageMethodAnno.member(names.value);\n+                if (linkageMethodValue != null && linkageMethodValue instanceof Attribute.Constant) {\n+                    linkageMethodValueStr = linkageMethodValue.getValue().toString();\n+                }\n+                if (linkageMethodValueStr == null) {\n+                    log.printRawLines(\"LinkageMethod annotation without value\");\n+                    return -1;\n+                }\n+            }\n+            String linkageClassValueStr = null;\n+            Attribute.Compound linkageClassAnno = currentMethSymbol.attribute(syms.linkageClassType.tsym);\n+            if (linkageClassAnno != null) {\n+                Attribute linkageClassValue = linkageClassAnno.member(names.value);\n+                if (linkageClassValue != null && linkageClassValue instanceof Attribute.Constant) {\n+                    linkageClassValueStr = linkageClassValue.getValue().toString();\n+                }\n+                if (linkageClassValueStr == null) {\n+                    log.printRawLines(\"LinkageClass annotation without value\");\n+                    return -1;\n+                }\n+            }\n+            if (kindName == names.METHOD_ONLY) {\n+                if (linkageMethodValueStr == null) {\n+                    \/\/ bail out\n+                    return -1;\n+                }\n+                referencesBeingLinked.add(s);\n+                return pool.writeIfNeeded(new Linkage(linkageMethodValueStr, s, false));\n+            } else if (kindName == names.CLASS) {\n+                if (linkageClassValueStr == null) {\n+                    \/\/ bail out\n+                    return -1;\n+                }\n+                referencesBeingLinked.add(s);\n+                return pool.writeIfNeeded(new Linkage(linkageClassValueStr, s, s instanceof Type));\n+            } else if (kindName == names.METHOD_AND_CLASS) {\n+                if (linkageMethodValueStr == null) {\n+                    \/\/ bail out\n+                    return -1;\n+                }\n+                referencesBeingLinked.add(s);\n+                return pool.writeIfNeeded(new Linkage(linkageMethodValueStr, s, s instanceof Type));\n+            }\n+            log.printRawLines(\"could not generate Linkage_info constant\");\n+            return -1;\n+        }\n+\n@@ -215,0 +339,7 @@\n+    \/**\n+     * Puts a parameter into the pool and returns its index.\n+     *\/\n+    int putParameter(int kind) {\n+        return pool.writeIfNeeded(new Parameter(kind));\n+    }\n+\n@@ -383,0 +514,3 @@\n+                    if (referencesBeingLinked.contains(c)) {\n+                        referencesBeingLinked.remove(c);\n+                    }\n@@ -404,0 +538,3 @@\n+                    if (referencesBeingLinked.contains(c)) {\n+                        referencesBeingLinked.remove(c);\n+                    }\n@@ -478,0 +615,18 @@\n+                case ClassFile.CONSTANT_Parameter: {\n+                    Parameter p = (Parameter) c;\n+                    poolbuf.appendByte(tag);\n+                    poolbuf.appendByte(p.kind);\n+                    poolbuf.appendChar(0);\n+                    break;\n+                }\n+                case ClassFile.CONSTANT_Linkage: {\n+                    Linkage l = (Linkage) c;\n+                    poolbuf.appendByte(tag);\n+                    poolbuf.appendChar(putConstant(l.parameter));\n+                    if (l.hasClassReference()) {\n+                        poolbuf.appendChar(putClass((Type)l.reference));\n+                    } else {\n+                        poolbuf.appendChar(putMember((Symbol)l.reference));\n+                    }\n+                    break;\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":157,"deletions":2,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+    public final Name Parametric;\n@@ -229,0 +230,6 @@\n+    \/\/ valhalla\n+    \/\/ Parametric annotation\n+    public final Name kind;\n+    public final Name METHOD_ONLY;\n+    public final Name METHOD_AND_CLASS;\n+\n@@ -355,0 +362,1 @@\n+        Parametric = fromString(\"Parametric\");\n@@ -408,0 +416,5 @@\n+\n+        \/\/ valhalla\n+        kind = fromString(\"kind\");\n+        METHOD_ONLY = fromString(\"METHOD_ONLY\");\n+        METHOD_AND_CLASS = fromString(\"METHOD_AND_CLASS\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    public static final String Parametric               = \"Parametric\";\n@@ -139,0 +140,1 @@\n+            standardAttributes.put(Parametric, Parametric_attribute.class);\n@@ -206,0 +208,1 @@\n+        R visitParametric(Parametric_attribute attr, P p);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Attribute.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Parameter_info;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Linkage_info;\n@@ -431,0 +433,28 @@\n+    @Override\n+    public CPInfo visitParameter(CONSTANT_Parameter_info info, Map<Object, Object> translations) {\n+        CONSTANT_Parameter_info info2 = (CONSTANT_Parameter_info) translations.get(info);\n+        if (info2 == null) {\n+            ConstantPool cp2 = translate(info.cp, translations);\n+            if (cp2 == info.cp)\n+                info2 = info;\n+            else\n+                info2 = new CONSTANT_Parameter_info(cp2, info.parameter_kind, info.bootstrap_method_attr_index);\n+            translations.put(info, info2);\n+        }\n+        return info;\n+    }\n+\n+    @Override\n+    public CPInfo visitLinkage(CONSTANT_Linkage_info info, Map<Object, Object> translations) {\n+        CONSTANT_Linkage_info info2 = (CONSTANT_Linkage_info) translations.get(info);\n+        if (info2 == null) {\n+            ConstantPool cp2 = translate(info.cp, translations);\n+            if (cp2 == info.cp)\n+                info2 = info;\n+            else\n+                info2 = new CONSTANT_Linkage_info(cp2, info.parameter_index, info.reference_index);\n+            translations.put(info, info2);\n+        }\n+        return info;\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassTranslator.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -352,0 +352,14 @@\n+\n+        @Override\n+        public Integer visitParameter(CONSTANT_Parameter_info info, ClassOutputStream out) {\n+            out.writeByte(info.parameter_kind.tag);\n+            out.writeShort(info.bootstrap_method_attr_index);\n+            return 1;\n+        }\n+\n+        @Override\n+        public Integer visitLinkage(CONSTANT_Linkage_info info, ClassOutputStream out) {\n+            out.writeShort(info.parameter_index);\n+            out.writeShort(info.reference_index);\n+            return 1;\n+        }\n@@ -656,0 +670,7 @@\n+        @Override\n+        public Void visitParametric(Parametric_attribute attr, ClassOutputStream out) {\n+            out.writeShort(attr.parameter_index);\n+            out.writeShort(attr.type_index);\n+            return null;\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -123,0 +123,2 @@\n+    public static final int CONSTANT_Parameter = 21;\n+    public static final int CONSTANT_Linkage = 22;\n@@ -167,0 +169,25 @@\n+    public static enum ParamKind {\n+        CLASS(1),\n+        METHOD_ONLY(2),\n+        METHOD_AND_CLASS(3);\n+\n+        public final int tag;\n+\n+        ParamKind(int tag) {\n+            this.tag = tag;\n+        }\n+\n+        static ParamKind getParamKind(int tag) {\n+            switch(tag) {\n+                case 1:\n+                    return CLASS;\n+                case 2:\n+                    return METHOD_ONLY;\n+                case 3:\n+                    return METHOD_AND_CLASS;\n+                default:\n+                    return null;\n+            }\n+        }\n+    }\n+\n@@ -243,0 +270,8 @@\n+            case CONSTANT_Parameter:\n+                pool[i] = new CONSTANT_Parameter_info(this, cr);\n+                break;\n+\n+            case CONSTANT_Linkage:\n+                pool[i] = new CONSTANT_Linkage_info(this, cr);\n+                break;\n+\n@@ -320,0 +355,8 @@\n+    public CONSTANT_Parameter_info getParameterInfo(int index) throws InvalidIndex, UnexpectedEntry {\n+        return ((CONSTANT_Parameter_info) get(index, CONSTANT_Parameter));\n+    }\n+\n+    public CONSTANT_Linkage_info getLinkageInfo(int index) throws InvalidIndex, UnexpectedEntry {\n+        return ((CONSTANT_Linkage_info) get(index, CONSTANT_Linkage));\n+    }\n+\n@@ -370,0 +413,2 @@\n+        R visitParameter(CONSTANT_Parameter_info info, P p);\n+        R visitLinkage(CONSTANT_Linkage_info info, P p);\n@@ -424,1 +469,12 @@\n-            return cp.getClassInfo(class_index).getName();\n+            CPInfo info = cp.get(class_index);\n+            if (info.getTag() == CONSTANT_Class) {\n+                return cp.getClassInfo(class_index).getName();\n+            } else if (info.getTag() == CONSTANT_Linkage) {\n+                CONSTANT_Linkage_info linkage_info = (CONSTANT_Linkage_info) info;\n+                CPInfo info2 = cp.get(linkage_info.reference_index);\n+                if (info2.getTag() == CONSTANT_Class) {\n+                    return cp.getClassInfo(linkage_info.reference_index).getName();\n+                }\n+            }\n+            \/\/ we shouldn't get here\n+            throw new AssertionError(\"unexpected entry at \" + class_index);\n@@ -1052,0 +1108,84 @@\n+    public static class CONSTANT_Parameter_info extends CPInfo {\n+        CONSTANT_Parameter_info(ConstantPool cp, ClassReader cr) throws IOException {\n+            super(cp);\n+            parameter_kind = ParamKind.getParamKind(cr.readUnsignedByte());\n+            bootstrap_method_attr_index = cr.readUnsignedShort();\n+        }\n+\n+        public CONSTANT_Parameter_info(ConstantPool cp, ParamKind parameter_kind, int bootstrap_method_attr_index) {\n+            super(cp);\n+            this.parameter_kind = parameter_kind;\n+            this.bootstrap_method_attr_index = bootstrap_method_attr_index;\n+        }\n+\n+        public int getTag() {\n+            return CONSTANT_Parameter;\n+        }\n+\n+        public int byteLength() {\n+            return 4;\n+        }\n+\n+        public ParamKind getKind() {\n+            return parameter_kind;\n+        }\n+\n+        public int getBSM() {\n+            return bootstrap_method_attr_index;\n+        }\n+\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitParameter(this, data);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"CONSTANT_Parameter_info[parameter_kind: \" + parameter_kind + \", bootstrap_method_attr_index: \" + bootstrap_method_attr_index + \"]\";\n+        }\n+\n+        public final ParamKind parameter_kind;\n+        public final int bootstrap_method_attr_index;\n+    }\n+\n+    public static class CONSTANT_Linkage_info extends CPInfo {\n+        CONSTANT_Linkage_info(ConstantPool cp, ClassReader cr) throws IOException {\n+            super(cp);\n+            parameter_index = cr.readUnsignedShort();\n+            reference_index = cr.readUnsignedShort();\n+        }\n+\n+        public CONSTANT_Linkage_info(ConstantPool cp, int parameter_index, int reference_index) {\n+            super(cp);\n+            this.parameter_index = parameter_index;\n+            this.reference_index = reference_index;\n+        }\n+\n+        public int getTag() {\n+            return CONSTANT_Linkage;\n+        }\n+\n+        public int byteLength() {\n+            return 4;\n+        }\n+\n+        public int getParameterIndex() {\n+            return parameter_index;\n+        }\n+\n+        public int getReferenceIndex() {\n+            return reference_index;\n+        }\n+\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitLinkage(this, data);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"CONSTANT_Linkage_info[parameter_index: \" + parameter_index + \", reference_index: \" + reference_index + \"]\";\n+        }\n+\n+        public final int parameter_index;\n+        public final int reference_index;\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ConstantPool.java","additions":141,"deletions":1,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -716,0 +716,8 @@\n+            public Void visitParameter(CONSTANT_Parameter_info info, Void p) {\n+                return null;\n+            }\n+\n+            public Void visitLinkage(CONSTANT_Linkage_info info, Void p) {\n+                return null;\n+            }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Dependencies.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.classfile;\n+\n+import java.io.IOException;\n+import com.sun.tools.classfile.Attribute.Visitor;\n+\n+\/**\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class Parametric_attribute extends Attribute {\n+    Parametric_attribute(ClassReader cr, int name_index, int length) throws IOException {\n+        super(name_index, length);\n+        parameter_index = cr.readUnsignedShort();\n+        type_index = cr.readUnsignedShort();\n+    }\n+\n+    public Parametric_attribute(int name_index, int parameter_index, int type_index) {\n+        super(name_index, 2);\n+        this.parameter_index = parameter_index;\n+        this.type_index = type_index;\n+    }\n+\n+    @Override\n+    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+        return visitor.visitParametric(this, data);\n+    }\n+\n+    public final int parameter_index;\n+    public final int type_index;\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Parametric_attribute.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -203,0 +203,4 @@\n+\n+        public Boolean visitParameter(CONSTANT_Parameter_info info, ConstantPool cpool) { return false; }\n+\n+        public Boolean visitLinkage(CONSTANT_Linkage_info info, ConstantPool cpool) { return false; }\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ReferenceFinder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import com.sun.tools.classfile.Parametric_attribute;\n@@ -900,0 +901,6 @@\n+    @Override\n+    public Void visitParametric(Parametric_attribute attr, Void ignore) {\n+        println(\"Parametric: #\" + attr.parameter_index + \":\" + attr.type_index);\n+        return null;\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -173,0 +173,14 @@\n+            public Integer visitParameter(CONSTANT_Parameter_info info, Void p) {\n+                print(info.parameter_kind + \":\" + info.bootstrap_method_attr_index);\n+                tab();\n+                println(\"\/\/ \" + stringValue(info));\n+                return 1;\n+            }\n+\n+            public Integer visitLinkage(CONSTANT_Linkage_info info, Void p) {\n+                print(\"#\" + info.parameter_index + \":#\" + info.reference_index);\n+                tab();\n+                println(\"\/\/ \" + stringValue(info));\n+                return 1;\n+            }\n+\n@@ -260,0 +274,4 @@\n+            case CONSTANT_Parameter:\n+                return \"Parameter\";\n+            case CONSTANT_Linkage:\n+                return \"Linkage\";\n@@ -478,0 +496,14 @@\n+        public String visitParameter(CONSTANT_Parameter_info info, Void p) {\n+            return info.parameter_kind + \":\" + info.bootstrap_method_attr_index;\n+        }\n+\n+        public String visitLinkage(CONSTANT_Linkage_info info, Void p) {\n+            try {\n+                ClassFile classFile = classWriter.getClassFile();\n+                return stringValue(classFile.constant_pool.get(info.parameter_index)) + \":\" +\n+                        stringValue(classFile.constant_pool.get(info.reference_index));\n+            } catch (ConstantPoolException e) {\n+                return report(e);\n+            }\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ConstantWriter.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -123,0 +123,10 @@\n+\n+    @Override\n+    public Void visitParameter(ConstantPool.CONSTANT_Parameter_info info, CPEntries p) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLinkage(ConstantPool.CONSTANT_Linkage_info info, CPEntries p) {\n+        return null;\n+    }\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/scan\/CPSelector.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}