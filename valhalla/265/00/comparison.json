{"files":[{"patch":"@@ -167,1 +167,1 @@\n-  int esize = upper_log2(vk->raw_value_byte_size());\n+  int esize = upper_log2(vk->get_exact_size_in_bytes());\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,38 +90,0 @@\n-int InlineKlass::raw_value_byte_size() {\n-  int heapOopAlignedSize = nonstatic_field_size() << LogBytesPerHeapOop;\n-  \/\/ If bigger than 64 bits or needs oop alignment, then use jlong aligned\n-  \/\/ which for values should be jlong aligned, asserts in raw_field_copy otherwise\n-  if (heapOopAlignedSize >= longSize || contains_oops()) {\n-    return heapOopAlignedSize;\n-  }\n-  \/\/ Small primitives...\n-  \/\/ If a few small basic type fields, return the actual size, i.e.\n-  \/\/ 1 byte = 1\n-  \/\/ 2 byte = 2\n-  \/\/ 3 byte = 4, because pow2 needed for element stores\n-  int first_offset = first_field_offset();\n-  int last_offset  = 0; \/\/ find the last offset, add basic type size\n-  int last_tsz     = 0;\n-  for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n-    if (fs.access_flags().is_static()) {\n-      continue;\n-    } else if (fs.offset() > last_offset) {\n-      BasicType type = Signature::basic_type(fs.signature());\n-      if (is_java_primitive(type)) {\n-        last_tsz = type2aelembytes(type);\n-      } else if (type == T_INLINE_TYPE) {\n-        \/\/ Not just primitives. Layout aligns embedded value, so use jlong aligned it is\n-        return heapOopAlignedSize;\n-      } else {\n-        guarantee(0, \"Unknown type %d\", type);\n-      }\n-      assert(last_tsz != 0, \"Invariant\");\n-      last_offset = fs.offset();\n-    }\n-  }\n-  \/\/ Assumes VT with no fields are meaningless and illegal\n-  last_offset += last_tsz;\n-  assert(last_offset > first_offset && last_tsz, \"Invariant\");\n-  return 1 << upper_log2(last_offset - first_offset);\n-}\n-\n@@ -186,1 +148,1 @@\n-  int elem_bytes = raw_value_byte_size();\n+  int elem_bytes = get_exact_size_in_bytes();\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":1,"deletions":39,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -185,3 +185,0 @@\n-  \/\/ minimum number of bytes occupied by nonstatic fields, HeapWord aligned or pow2\n-  int raw_value_byte_size();\n-\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,4 @@\n- * @run main\/othervm -Xint -XX:FlatArrayElementMaxSize=-1\n+ * @run main\/othervm -Xint -XX:FlatArrayElementMaxSize=-1 -XX:+UseCompressedOops\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                    -XX:+WhiteBoxAPI InlineTypeDensity\n+ * @run main\/othervm -Xint -XX:FlatArrayElementMaxSize=-1 -XX:-UseCompressedOops\n@@ -232,0 +235,54 @@\n+    static inline class MyByte  { byte  v = 0; }\n+    static inline class MyShort { short v = 0; }\n+    static inline class MyInt   { int   v = 0; }\n+    static inline class MyLong  { long  v = 0; }\n+\n+    void assertArraySameSize(Object a, Object b, int nofElements) {\n+        long aSize = WHITE_BOX.getObjectSize(a);\n+        long bSize = WHITE_BOX.getObjectSize(b);\n+        Asserts.assertEquals(aSize, bSize,\n+            a + \"(\" + aSize + \" bytes) not equivalent size \" +\n+            b + \"(\" + bSize + \" bytes)\" +\n+            (nofElements >= 0 ? \" (array of \" + nofElements + \" elements)\" : \"\"));\n+    }\n+\n+    void testByteArraySizesSame(int[] testSizes) {\n+        for (int testSize : testSizes) {\n+            byte[] ba = new byte[testSize];\n+            MyByte[] mba = new MyByte[testSize];\n+            assertArraySameSize(ba, mba, testSize);\n+        }\n+    }\n+\n+    void testShortArraySizesSame(int[] testSizes) {\n+        for (int testSize : testSizes) {\n+            short[] sa = new short[testSize];\n+            MyShort[] msa = new MyShort[testSize];\n+            assertArraySameSize(sa, msa, testSize);\n+        }\n+    }\n+\n+    void testIntArraySizesSame(int[] testSizes) {\n+        for (int testSize : testSizes) {\n+            int[] ia = new int[testSize];\n+            MyInt[] mia = new MyInt[testSize];\n+            assertArraySameSize(ia, mia, testSize);\n+        }\n+    }\n+\n+    void testLongArraySizesSame(int[] testSizes) {\n+        for (int testSize : testSizes) {\n+            long[] la = new long[testSize];\n+            MyLong[] mla = new MyLong[testSize];\n+            assertArraySameSize(la, mla, testSize);\n+        }\n+    }\n+\n+    public void testPrimitiveArraySizesSame() {\n+        int[] testSizes = new int[] { 0, 1, 2, 3, 4, 7, 10, 257 };\n+        testByteArraySizesSame(testSizes);\n+        testShortArraySizesSame(testSizes);\n+        testIntArraySizesSame(testSizes);\n+        testLongArraySizesSame(testSizes);\n+    }\n+\n@@ -234,0 +291,1 @@\n+        testPrimitiveArraySizesSame();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeDensity.java","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"}]}