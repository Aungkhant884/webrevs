{"files":[{"patch":"@@ -1672,17 +1672,5 @@\n-        if (divisor < 0L) { \/\/ signed comparison\n-            \/\/ Answer must be 0 or 1 depending on relative magnitude\n-            \/\/ of dividend and divisor.\n-            return (compareUnsigned(dividend, divisor)) < 0 ? 0L :1L;\n-        }\n-\n-        if (dividend > 0) \/\/  Both inputs non-negative\n-            return dividend\/divisor;\n-        else {\n-            \/*\n-             * For simple code, leveraging BigInteger.  Longer and faster\n-             * code written directly in terms of operations on longs is\n-             * possible; see \"Hacker's Delight\" for divide and remainder\n-             * algorithms.\n-             *\/\n-            return toUnsignedBigInteger(dividend).\n-                divide(toUnsignedBigInteger(divisor)).longValue();\n+        \/* See Hacker's Delight (2nd ed), section 9.3 *\/\n+        if (divisor >= 0) {\n+            final long q = (dividend >>> 1) \/ divisor << 1;\n+            final long r = dividend - q * divisor;\n+            return q + ((r | ~(r - divisor)) >>> (Long.SIZE - 1));\n@@ -1690,0 +1678,1 @@\n+        return (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1);\n@@ -1705,8 +1694,16 @@\n-        if (dividend > 0 && divisor > 0) { \/\/ signed comparisons\n-            return dividend % divisor;\n-        } else {\n-            if (compareUnsigned(dividend, divisor) < 0) \/\/ Avoid explicit check for 0 divisor\n-                return dividend;\n-            else\n-                return toUnsignedBigInteger(dividend).\n-                    remainder(toUnsignedBigInteger(divisor)).longValue();\n+        \/* See Hacker's Delight (2nd ed), section 9.3 *\/\n+        if (divisor >= 0) {\n+            final long q = (dividend >>> 1) \/ divisor << 1;\n+            final long r = dividend - q * divisor;\n+            \/*\n+             * Here, 0 <= r < 2 * divisor\n+             * (1) When 0 <= r < divisor, the remainder is simply r.\n+             * (2) Otherwise the remainder is r - divisor.\n+             *\n+             * In case (1), r - divisor < 0. Applying ~ produces a long with\n+             * sign bit 0, so >> produces 0. The returned value is thus r.\n+             *\n+             * In case (2), a similar reasoning shows that >> produces -1,\n+             * so the returned value is r - divisor.\n+             *\/\n+            return r - ((~(r - divisor) >> (Long.SIZE - 1)) & divisor);\n@@ -1714,0 +1711,10 @@\n+        \/*\n+         * (1) When dividend >= 0, the remainder is dividend.\n+         * (2) Otherwise\n+         *      (2.1) When dividend < divisor, the remainder is dividend.\n+         *      (2.2) Otherwise the remainder is dividend - divisor\n+         *\n+         * A reasoning similar to the above shows that the returned value\n+         * is as expected.\n+         *\/\n+        return dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":32,"deletions":25,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n- * @author  unascribed\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Runtime.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -311,2 +311,0 @@\n-            } else if ((v.flags() & MATCH_BINDING) != 0) {\n-                log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));\n@@ -2044,1 +2042,4 @@\n-            return types.lub(condTypes.stream().map(t -> t.baseType()).collect(List.collector()));\n+            return types.lub(condTypes.stream()\n+                        .map(t -> t.baseType())\n+                        .filter(t -> !t.hasTag(BOT))\n+                        .collect(List.collector()));\n@@ -2126,0 +2127,20 @@\n+\n+                @Override\n+                public void visitClassDef(JCClassDecl that) {\n+                    if (that.sym != null) {\n+                        \/\/ Method preFlow shouldn't visit class definitions\n+                        \/\/ that have not been entered and attributed.\n+                        \/\/ See JDK-8254557 and JDK-8203277 for more details.\n+                        super.visitClassDef(that);\n+                    }\n+                }\n+\n+                @Override\n+                public void visitLambda(JCLambda that) {\n+                    if (that.type != null) {\n+                        \/\/ Method preFlow shouldn't visit lambda expressions\n+                        \/\/ that have not been entered and attributed.\n+                        \/\/ See JDK-8254557 and JDK-8203277 for more details.\n+                        super.visitLambda(that);\n+                    }\n+                }\n@@ -3928,0 +3949,4 @@\n+            if (types.isSubtype(exprtype, clazztype) &&\n+                !exprtype.isErroneous() && !clazztype.isErroneous()) {\n+                log.error(tree.pos(), Errors.InstanceofPatternNoSubtype(clazztype, exprtype));\n+            }\n@@ -3929,1 +3954,1 @@\n-            typeTree = pattern.vartype;\n+            typeTree = pattern.var.vartype;\n@@ -3931,1 +3956,1 @@\n-                clazztype = chk.checkClassOrArrayType(pattern.vartype.pos(), clazztype);\n+                clazztype = chk.checkClassOrArrayType(pattern.var.vartype.pos(), clazztype);\n@@ -3957,1 +3982,3 @@\n-                log.error(typeTree.pos(), Errors.IllegalGenericTypeForInstof);\n+                log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                          Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n+                allowReifiableTypesInInstanceof = true;\n@@ -3970,6 +3997,8 @@\n-        tree.type = attribTree(tree.vartype, env, varInfo);\n-        VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype.type, env.info.scope.owner);\n-        if (chk.checkUnique(tree.pos(), v, env.info.scope)) {\n-            chk.checkTransparentVar(tree.pos(), v, env.info.scope);\n-        }\n-        annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());\n+        tree.type = tree.var.type = attribTree(tree.var.vartype, env, varInfo);\n+        BindingSymbol v = new BindingSymbol(tree.var.name, tree.var.vartype.type, env.info.scope.owner);\n+        v.pos = tree.pos;\n+        tree.var.sym = v;\n+        if (chk.checkUnique(tree.var.pos(), v, env.info.scope)) {\n+            chk.checkTransparentVar(tree.var.pos(), v, env.info.scope);\n+        }\n+        annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var.pos());\n@@ -3978,1 +4007,1 @@\n-        matchBindings = new MatchBindings(List.of(tree.symbol), List.nil());\n+        matchBindings = new MatchBindings(List.of(v), List.nil());\n@@ -5728,3 +5757,3 @@\n-            if (that.symbol == null) {\n-                that.symbol = new BindingSymbol(that.name, that.type, syms.noSymbol);\n-                that.symbol.adr = 0;\n+            if (that.var.sym == null) {\n+                that.var.sym = new BindingSymbol(that.var.name, that.var.type, syms.noSymbol);\n+                that.var.sym.adr = 0;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -548,4 +548,0 @@\n-# 0: symbol\n-compiler.err.pattern.binding.may.not.be.assigned=\\\n-    pattern binding {0} may not be assigned\n-\n@@ -623,3 +619,0 @@\n-compiler.err.illegal.generic.type.for.instof=\\\n-    illegal generic type for instanceof\n-\n@@ -1386,3 +1379,0 @@\n-compiler.err.unsupported.cross.fp.lit=\\\n-    hexadecimal floating-point literals are not supported on this VM\n-\n@@ -1424,0 +1414,4 @@\n+# 0: type, 1: type\n+compiler.err.instanceof.pattern.no.subtype=\\\n+    pattern type {0} is a subtype of expression type {1}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"}]}