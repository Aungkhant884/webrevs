{"files":[{"patch":"@@ -368,2 +368,2 @@\n-          -i hs_err*\n-          -i replay*\n+          -i *\/hs_err*.log\n+          -i *\/replay*.log\n@@ -685,2 +685,2 @@\n-          -i hs_err*\n-          -i replay*\n+          -i *\/hs_err*.log\n+          -i *\/replay*.log\n@@ -967,2 +967,2 @@\n-          -i hs_err*\n-          -i replay*\n+          -i *\/hs_err*.log\n+          -i *\/replay*.log\n","filename":".github\/workflows\/submit.yml","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -254,0 +254,2 @@\n+            \"--disable-jvm-feature-aot\",\n+            \"--disable-jvm-feature-graal\",\n@@ -407,1 +409,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"graphviz\", \"pandoc\", \"graalunit_lib\"],\n+            dependencies: [\"devkit\", \"gtest\", \"graphviz\", \"pandoc\"],\n@@ -409,1 +411,1 @@\n-                \"--with-zlib=system\",\n+                \"--with-zlib=system\", \"--disable-dtrace\",\n@@ -426,1 +428,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"pandoc\", \"graalunit_lib\"],\n+            dependencies: [\"devkit\", \"gtest\", \"pandoc\"],\n@@ -437,1 +439,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"pandoc\", \"graalunit_lib\"],\n+            dependencies: [\"devkit\", \"gtest\", \"pandoc\"],\n@@ -457,2 +459,0 @@\n-\t\t\"--disable-jvm-feature-graal\",\n-\t\t\"--disable-jvm-feature-aot\",\n@@ -690,1 +690,1 @@\n-            configure_args: [\n+            configure_args: concat(\n@@ -692,0 +692,1 @@\n+                versionArgs(input, common),\n@@ -694,1 +695,1 @@\n-            ],\n+            ),\n@@ -1154,9 +1155,0 @@\n-        graalunit_lib: {\n-            organization: common.organization,\n-            ext: \"zip\",\n-            revision: \"619_Apr_12_2018\",\n-            module: \"graalunit-lib\",\n-            configure_args: \"--with-graalunit-lib=\" + input.get(\"graalunit_lib\", \"install_path\"),\n-            environment_name: \"GRAALUNIT_LIB\"\n-        },\n-\n","filename":"make\/conf\/jib-profiles.js","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -666,5 +666,6 @@\n-#define DESCRIBE_FP_OFFSET(name)                                        \\\n-  {                                                                     \\\n-    uintptr_t *p = (uintptr_t *)fp;                                     \\\n-    printf(\"0x%016lx 0x%016lx %s\\n\", (uintptr_t)(p + frame::name##_offset), \\\n-           p[frame::name##_offset], #name);                             \\\n+#define DESCRIBE_FP_OFFSET(name)                     \\\n+  {                                                  \\\n+    uintptr_t *p = (uintptr_t *)fp;                  \\\n+    printf(INTPTR_FORMAT \" \" INTPTR_FORMAT \" %s\\n\",  \\\n+           (uintptr_t)(p + frame::name##_offset),    \\\n+           p[frame::name##_offset], #name);          \\\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1879,1 +1879,1 @@\n-    const unsigned mask = size_in_bytes - 1;\n+    const uint64_t mask = size_in_bytes - 1;\n@@ -2943,1 +2943,1 @@\n-  const int sz = prev_ldst->size_in_bytes();\n+  const size_t sz = prev_ldst->size_in_bytes();\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1768,1 +1768,1 @@\n-    __ bang_stack_with_offset(StackOverflow::stack_shadow_zone_size());\n+    __ bang_stack_with_offset(checked_cast<int>(StackOverflow::stack_shadow_zone_size()));\n@@ -2717,1 +2717,1 @@\n-  __ mov(rscratch1, (address)0xDEADDEAD);        \/\/ Make a recognizable pattern\n+  __ mov(rscratch1, (uint64_t)0xDEADDEAD);        \/\/ Make a recognizable pattern\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1323,1 +1323,1 @@\n-  void verify_oop_array (size_t size, Register a, Register count, Register temp) {\n+  void verify_oop_array (int size, Register a, Register count, Register temp) {\n@@ -1330,1 +1330,1 @@\n-    if (size == (size_t)wordSize) {\n+    if (size == wordSize) {\n@@ -1361,1 +1361,1 @@\n-  address generate_disjoint_copy(size_t size, bool aligned, bool is_oop, address *entry,\n+  address generate_disjoint_copy(int size, bool aligned, bool is_oop, address *entry,\n@@ -1427,1 +1427,1 @@\n-  address generate_conjoint_copy(size_t size, bool aligned, bool is_oop, address nooverlap_target,\n+  address generate_conjoint_copy(int size, bool aligned, bool is_oop, address nooverlap_target,\n@@ -1678,1 +1678,1 @@\n-    const size_t size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+    const int size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n@@ -1696,1 +1696,1 @@\n-    const size_t size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+    const int size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1130,1 +1130,1 @@\n-    const int n_shadow_pages = StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size();\n+    const int n_shadow_pages = (int)(StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-#ifdef _LP64\n@@ -87,0 +86,1 @@\n+#ifdef _LP64\n@@ -89,0 +89,9 @@\n+#else\n+  const Register tmp1 = rcx;\n+  const Register tmp2 = rdx;\n+  __ push(tmp1);\n+  __ push(tmp2);\n+\n+  __ lea(tmp1, safepoint_pc);\n+  __ get_thread(tmp2);\n+  __ movptr(Address(tmp2, JavaThread::saved_exception_pc_offset()), tmp1);\n@@ -90,0 +99,3 @@\n+  __ pop(tmp2);\n+  __ pop(tmp1);\n+#endif \/* _LP64 *\/\n@@ -92,0 +104,1 @@\n+\n@@ -94,3 +107,0 @@\n-#else\n-  ShouldNotReachHere();\n-#endif \/* _LP64 *\/\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -559,3 +559,1 @@\n-  code_stub->set_safepoint_offset(__ offset());\n-  __ relocate(relocInfo::poll_return_type);\n-  __ safepoint_poll(*code_stub->entry(), r15_thread, true \/* at_return *\/, true \/* in_nmethod *\/);\n+  const Register thread = r15_thread;\n@@ -563,6 +561,2 @@\n-  const Register poll_addr = rbx;\n-  assert(FrameMap::is_caller_save_register(poll_addr), \"will overwrite\");\n-  __ get_thread(poll_addr);\n-  __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));\n-  __ relocate(relocInfo::poll_return_type);\n-  __ testl(rax, Address(poll_addr, 0));\n+  const Register thread = rbx;\n+  __ get_thread(thread);\n@@ -570,0 +564,3 @@\n+  code_stub->set_safepoint_offset(__ offset());\n+  __ relocate(relocInfo::poll_return_type);\n+  __ safepoint_poll(*code_stub->entry(), thread, true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n@@ -47,2 +46,0 @@\n-address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;\n-\n@@ -274,1 +271,1 @@\n-void ShenandoahBarrierSetAssembler::load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address src) {\n+void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address src, ShenandoahBarrierSet::AccessKind kind) {\n@@ -277,1 +274,1 @@\n-  Label done;\n+  Label heap_stable, not_cset;\n@@ -279,0 +276,3 @@\n+  __ block_comment(\"load_reference_barrier { \");\n+\n+  \/\/ Check if GC is active\n@@ -292,33 +292,16 @@\n-  __ jccb(Assembler::zero, done);\n-\n-  \/\/ Use rsi for src address\n-  const Register src_addr = rsi;\n-  \/\/ Setup address parameter first, if it does not clobber oop in dst\n-  bool need_addr_setup = (src_addr != dst);\n-\n-  if (need_addr_setup) {\n-    __ push(src_addr);\n-    __ lea(src_addr, src);\n-\n-    if (dst != rax) {\n-      \/\/ Move obj into rax and save rax\n-      __ push(rax);\n-      __ movptr(rax, dst);\n-    }\n-  } else {\n-    \/\/ dst == rsi\n-    __ push(rax);\n-    __ movptr(rax, dst);\n-\n-    \/\/ we can clobber it, since it is outgoing register\n-    __ lea(src_addr, src);\n-  }\n-\n-  save_xmm_registers(masm);\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_lrb())));\n-  restore_xmm_registers(masm);\n-\n-  if (need_addr_setup) {\n-    if (dst != rax) {\n-      __ movptr(dst, rax);\n-      __ pop(rax);\n+  __ jcc(Assembler::zero, heap_stable);\n+\n+  Register tmp1 = noreg, tmp2 = noreg;\n+  if (kind == ShenandoahBarrierSet::AccessKind::NORMAL) {\n+    \/\/ Test for object in cset\n+    \/\/ Allocate temporary registers\n+    for (int i = 0; i < 8; i++) {\n+      Register r = as_Register(i);\n+      if (r != rsp && r != rbp && r != dst && r != src.base() && r != src.index()) {\n+        if (tmp1 == noreg) {\n+          tmp1 = r;\n+        } else {\n+          tmp2 = r;\n+          break;\n+        }\n+      }\n@@ -326,4 +309,22 @@\n-    __ pop(src_addr);\n-  } else {\n-    __ movptr(dst, rax);\n-    __ pop(rax);\n+    assert(tmp1 != noreg, \"tmp1 allocated\");\n+    assert(tmp2 != noreg, \"tmp2 allocated\");\n+    assert_different_registers(tmp1, tmp2, src.base(), src.index());\n+    assert_different_registers(tmp1, tmp2, dst);\n+\n+    __ push(tmp1);\n+    __ push(tmp2);\n+\n+    \/\/ Optimized cset-test\n+    __ movptr(tmp1, dst);\n+    __ shrptr(tmp1, ShenandoahHeapRegion::region_size_bytes_shift_jint());\n+    __ movptr(tmp2, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());\n+    __ movbool(tmp1, Address(tmp1, tmp2, Address::times_1));\n+    __ testbool(tmp1);\n+    __ jcc(Assembler::zero, not_cset);\n+  }\n+\n+  uint num_saved_regs = 4 + (dst != rax ? 1 : 0) LP64_ONLY(+4);\n+  __ subptr(rsp, num_saved_regs * wordSize);\n+  uint slot = num_saved_regs;\n+  if (dst != rax) {\n+    __ movptr(Address(rsp, (--slot) * wordSize), rax);\n@@ -331,5 +332,10 @@\n-\n-  __ bind(done);\n-\n-#ifndef _LP64\n-    __ pop(thread);\n+  __ movptr(Address(rsp, (--slot) * wordSize), rcx);\n+  __ movptr(Address(rsp, (--slot) * wordSize), rdx);\n+  __ movptr(Address(rsp, (--slot) * wordSize), rdi);\n+  __ movptr(Address(rsp, (--slot) * wordSize), rsi);\n+#ifdef _LP64\n+  __ movptr(Address(rsp, (--slot) * wordSize), r8);\n+  __ movptr(Address(rsp, (--slot) * wordSize), r9);\n+  __ movptr(Address(rsp, (--slot) * wordSize), r10);\n+  __ movptr(Address(rsp, (--slot) * wordSize), r11);\n+  \/\/ r12-r15 are callee saved in all calling conventions\n@@ -337,18 +343,1 @@\n-}\n-\n-void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address src) {\n-  if (!ShenandoahLoadRefBarrier) {\n-    return;\n-  }\n-\n-  Label done;\n-  Label not_null;\n-  Label slow_path;\n-  __ block_comment(\"load_reference_barrier_native { \");\n-\n-  \/\/ null check\n-  __ testptr(dst, dst);\n-  __ jcc(Assembler::notZero, not_null);\n-  __ jmp(done);\n-  __ bind(not_null);\n-\n+  assert(slot == 0, \"must use all slots\");\n@@ -356,0 +345,1 @@\n+  \/\/ Shuffle registers such that dst is in c_rarg0 and addr in c_rarg1.\n@@ -357,1 +347,1 @@\n-  Register thread = r15_thread;\n+  Register arg0 = c_rarg0, arg1 = c_rarg1;\n@@ -359,13 +349,1 @@\n-  Register thread = rcx;\n-  if (thread == dst) {\n-    thread = rbx;\n-  }\n-  __ push(thread);\n-  __ get_thread(thread);\n-#endif\n-  assert_different_registers(dst, thread);\n-\n-  Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n-  __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED);\n-#ifndef _LP64\n-  __ pop(thread);\n+  Register arg0 = rdi, arg1 = rsi;\n@@ -373,6 +351,6 @@\n-  __ jccb(Assembler::notZero, slow_path);\n-  __ jmp(done);\n-  __ bind(slow_path);\n-\n-  if (dst != rax) {\n-    __ push(rax);\n+  if (dst == arg1) {\n+    __ lea(arg0, src);\n+    __ xchgptr(arg1, arg0);\n+  } else {\n+    __ lea(arg1, src);\n+    __ movptr(arg0, dst);\n@@ -380,17 +358,0 @@\n-  __ push(rcx);\n-  __ push(rdx);\n-  __ push(rdi);\n-  __ push(rsi);\n-#ifdef _LP64\n-  __ push(r8);\n-  __ push(r9);\n-  __ push(r10);\n-  __ push(r11);\n-  __ push(r12);\n-  __ push(r13);\n-  __ push(r14);\n-  __ push(r15);\n-#endif\n-\n-  assert_different_registers(dst, rsi);\n-  __ lea(rsi, src);\n@@ -399,1 +360,21 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), dst, rsi);\n+  switch (kind) {\n+    case ShenandoahBarrierSet::AccessKind::NORMAL:\n+      if (UseCompressedOops) {\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), arg0, arg1);\n+      } else {\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), arg0, arg1);\n+      }\n+      break;\n+    case ShenandoahBarrierSet::AccessKind::WEAK:\n+      if (UseCompressedOops) {\n+        __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak_narrow), arg0, arg1);\n+      } else {\n+        __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak), arg0, arg1);\n+      }\n+      break;\n+    case ShenandoahBarrierSet::AccessKind::NATIVE:\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak), arg0, arg1);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -403,8 +384,4 @@\n-  __ pop(r15);\n-  __ pop(r14);\n-  __ pop(r13);\n-  __ pop(r12);\n-  __ pop(r11);\n-  __ pop(r10);\n-  __ pop(r9);\n-  __ pop(r8);\n+  __ movptr(r11, Address(rsp, (slot++) * wordSize));\n+  __ movptr(r10, Address(rsp, (slot++) * wordSize));\n+  __ movptr(r9,  Address(rsp, (slot++) * wordSize));\n+  __ movptr(r8,  Address(rsp, (slot++) * wordSize));\n@@ -412,4 +389,4 @@\n-  __ pop(rsi);\n-  __ pop(rdi);\n-  __ pop(rdx);\n-  __ pop(rcx);\n+  __ movptr(rsi, Address(rsp, (slot++) * wordSize));\n+  __ movptr(rdi, Address(rsp, (slot++) * wordSize));\n+  __ movptr(rdx, Address(rsp, (slot++) * wordSize));\n+  __ movptr(rcx, Address(rsp, (slot++) * wordSize));\n@@ -419,1 +396,1 @@\n-    __ pop(rax);\n+    __ movptr(rax, Address(rsp, (slot++) * wordSize));\n@@ -422,2 +399,17 @@\n-  __ bind(done);\n-  __ block_comment(\"load_reference_barrier_native { \");\n+  assert(slot == num_saved_regs, \"must use all slots\");\n+  __ addptr(rsp, num_saved_regs * wordSize);\n+\n+  __ bind(not_cset);\n+\n+  if  (kind == ShenandoahBarrierSet::AccessKind::NORMAL) {\n+    __ pop(tmp2);\n+    __ pop(tmp1);\n+  }\n+\n+  __ bind(heap_stable);\n+\n+  __ block_comment(\"} load_reference_barrier\");\n+\n+#ifndef _LP64\n+    __ pop(thread);\n+#endif\n@@ -467,10 +459,0 @@\n-void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address src) {\n-  if (ShenandoahLoadRefBarrier) {\n-    Label done;\n-    __ testptr(dst, dst);\n-    __ jcc(Assembler::zero, done);\n-    load_reference_barrier_not_null(masm, dst, src);\n-    __ bind(done);\n-  }\n-}\n-\n@@ -507,1 +489,1 @@\n-      \/\/ Use tmp1 for dst if possible, as it is not used in BarrierAssembler::load_at()\n+    \/\/ Use tmp1 for dst if possible, as it is not used in BarrierAssembler::load_at()\n@@ -520,5 +502,2 @@\n-    if (ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type)) {\n-      load_reference_barrier_native(masm, dst, src);\n-    } else {\n-      load_reference_barrier(masm, dst, src);\n-    }\n+    ShenandoahBarrierSet::AccessKind kind = ShenandoahBarrierSet::access_kind(decorators, type);\n+    load_reference_barrier(masm, dst, src, kind);\n@@ -641,1 +620,2 @@\n-  assert_different_registers(oldval, newval, tmp1, tmp2);\n+  assert_different_registers(oldval, tmp1, tmp2);\n+  assert_different_registers(newval, tmp1, tmp2);\n@@ -873,4 +853,12 @@\n-  if (stub->is_native()) {\n-    __ call(RuntimeAddress(bs->load_reference_barrier_native_rt_code_blob()->code_begin()));\n-  } else {\n-    __ call(RuntimeAddress(bs->load_reference_barrier_rt_code_blob()->code_begin()));\n+  switch (stub->kind()) {\n+    case ShenandoahBarrierSet::AccessKind::NORMAL:\n+      __ call(RuntimeAddress(bs->load_reference_barrier_normal_rt_code_blob()->code_begin()));\n+      break;\n+    case ShenandoahBarrierSet::AccessKind::WEAK:\n+      __ call(RuntimeAddress(bs->load_reference_barrier_weak_rt_code_blob()->code_begin()));\n+      break;\n+    case ShenandoahBarrierSet::AccessKind::NATIVE:\n+      __ call(RuntimeAddress(bs->load_reference_barrier_native_rt_code_blob()->code_begin()));\n+      break;\n+    default:\n+      ShouldNotReachHere();\n@@ -941,1 +929,1 @@\n-void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native) {\n+void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, ShenandoahBarrierSet::AccessKind kind) {\n@@ -950,6 +938,20 @@\n-  if (is_native) {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), c_rarg0, c_rarg1);\n-  } else if (UseCompressedOops) {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), c_rarg0, c_rarg1);\n-  } else {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), c_rarg0, c_rarg1);\n+  switch (kind) {\n+    case ShenandoahBarrierSet::AccessKind::NORMAL:\n+      if (UseCompressedOops) {\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), c_rarg0, c_rarg1);\n+      } else {\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), c_rarg0, c_rarg1);\n+      }\n+      break;\n+    case ShenandoahBarrierSet::AccessKind::WEAK:\n+      if (UseCompressedOops) {\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak_narrow), c_rarg0, c_rarg1);\n+      } else {\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak), c_rarg0, c_rarg1);\n+      }\n+      break;\n+    case ShenandoahBarrierSet::AccessKind::NATIVE:\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak), c_rarg0, c_rarg1);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n@@ -960,4 +962,10 @@\n-  if (is_native) {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), rax, rbx);\n-  } else {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), rax, rbx);\n+  switch (kind) {\n+    case ShenandoahBarrierSet::AccessKind::NORMAL:\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), rax, rbx);\n+      break;\n+    case ShenandoahBarrierSet::AccessKind::WEAK:\n+    case ShenandoahBarrierSet::AccessKind::NATIVE:\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak), rax, rbx);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n@@ -975,101 +983,0 @@\n-\n-address ShenandoahBarrierSetAssembler::shenandoah_lrb() {\n-  assert(_shenandoah_lrb != NULL, \"need load reference barrier stub\");\n-  return _shenandoah_lrb;\n-}\n-\n-#define __ cgen->assembler()->\n-\n-\/*\n- *  Incoming parameters:\n- *  rax: oop\n- *  rsi: load address\n- *\/\n-address ShenandoahBarrierSetAssembler::generate_shenandoah_lrb(StubCodeGenerator* cgen) {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(cgen, \"StubRoutines\", \"shenandoah_lrb\");\n-  address start = __ pc();\n-\n-  Label slow_path;\n-\n-  \/\/ We use RDI, which also serves as argument register for slow call.\n-  \/\/ RAX always holds the src object ptr, except after the slow call,\n-  \/\/ then it holds the result. R8\/RBX is used as temporary register.\n-\n-  Register tmp1 = rdi;\n-  Register tmp2 = LP64_ONLY(r8) NOT_LP64(rbx);\n-\n-  __ push(tmp1);\n-  __ push(tmp2);\n-\n-  \/\/ Check for object being in the collection set.\n-  __ mov(tmp1, rax);\n-  __ shrptr(tmp1, ShenandoahHeapRegion::region_size_bytes_shift_jint());\n-  __ movptr(tmp2, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());\n-  __ movbool(tmp2, Address(tmp2, tmp1, Address::times_1));\n-  __ testbool(tmp2);\n-  __ jccb(Assembler::notZero, slow_path);\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-  __ ret(0);\n-\n-  __ bind(slow_path);\n-\n-  __ push(rcx);\n-  __ push(rdx);\n-  __ push(rdi);\n-#ifdef _LP64\n-  __ push(r8);\n-  __ push(r9);\n-  __ push(r10);\n-  __ push(r11);\n-  __ push(r12);\n-  __ push(r13);\n-  __ push(r14);\n-  __ push(r15);\n-#endif\n-  __ push(rbp);\n-  __ movptr(rbp, rsp);\n-  __ andptr(rsp, -StackAlignmentInBytes);\n-  __ push_FPU_state();\n-  if (UseCompressedOops) {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), rax, rsi);\n-  } else {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), rax, rsi);\n-  }\n-  __ pop_FPU_state();\n-  __ movptr(rsp, rbp);\n-  __ pop(rbp);\n-#ifdef _LP64\n-  __ pop(r15);\n-  __ pop(r14);\n-  __ pop(r13);\n-  __ pop(r12);\n-  __ pop(r11);\n-  __ pop(r10);\n-  __ pop(r9);\n-  __ pop(r8);\n-#endif\n-  __ pop(rdi);\n-  __ pop(rdx);\n-  __ pop(rcx);\n-\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-#undef __\n-\n-void ShenandoahBarrierSetAssembler::barrier_stubs_init() {\n-  if (ShenandoahLoadRefBarrier) {\n-    int stub_code_size = 4096;\n-    ResourceMark rm;\n-    BufferBlob* bb = BufferBlob::create(\"shenandoah_barrier_stubs\", stub_code_size);\n-    CodeBuffer buf(bb);\n-    StubCodeGenerator cgen(&buf);\n-    _shenandoah_lrb = generate_shenandoah_lrb(&cgen);\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":158,"deletions":251,"binary":false,"changes":409,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n+\n@@ -41,2 +43,0 @@\n-  static address _shenandoah_lrb;\n-\n@@ -59,2 +59,0 @@\n-  void load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address src);\n-\n@@ -63,4 +61,0 @@\n-  address generate_shenandoah_lrb(StubCodeGenerator* cgen);\n-\n-  static address shenandoah_lrb();\n-\n@@ -73,1 +67,1 @@\n-  void generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native);\n+  void generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, ShenandoahBarrierSet::AccessKind kind);\n@@ -76,2 +70,1 @@\n-  void load_reference_barrier(MacroAssembler* masm, Register dst, Address src);\n-  void load_reference_barrier_native(MacroAssembler* masm, Register dst, Address src);\n+  void load_reference_barrier(MacroAssembler* masm, Register dst, Address src, ShenandoahBarrierSet::AccessKind kind);\n@@ -90,2 +83,0 @@\n-  virtual void barrier_stubs_init();\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.hpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1014,0 +1014,1 @@\n+  NOT_LP64(get_thread(rthread);) \/\/ call_VM clobbered it, restore\n@@ -1016,1 +1017,0 @@\n-  NOT_LP64(get_thread(rthread);) \/\/ call_VM clobbered it, restore\n@@ -2189,1 +2189,1 @@\n-    MacroAssembler::_verify_oop(reg, \"broken oop\", file, line);\n+    MacroAssembler::_verify_oop_checked(reg, \"broken oop\", file, line);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -379,5 +379,0 @@\n-void MacroAssembler::set_word_if_not_zero(Register dst) {\n-  xorl(dst, dst);\n-  set_byte_if_not_zero(dst);\n-}\n-\n@@ -723,2 +718,6 @@\n-  mov64(rscratch1, src);\n-  movq(dst, rscratch1);\n+  if (is_simm32(src)) {\n+    movptr(dst, checked_cast<int32_t>(src));\n+  } else {\n+    mov64(rscratch1, src);\n+    movq(dst, rscratch1);\n+  }\n@@ -2914,1 +2913,0 @@\n-#ifdef _LP64\n@@ -2918,1 +2916,1 @@\n-    cmpq(Address(thread_reg, Thread::polling_word_offset()), in_nmethod ? rsp : rbp);\n+    cmpptr(in_nmethod ? rsp : rbp, Address(thread_reg, Thread::polling_word_offset()));\n@@ -2922,1 +2920,0 @@\n-#endif\n@@ -4327,1 +4324,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -643,3 +643,0 @@\n-  \/\/----\n-  void set_word_if_not_zero(Register reg); \/\/ sets reg to 1 if not zero, otherwise 0\n-\n@@ -652,0 +649,11 @@\n+  void _verify_oop_checked(Register reg, const char* s, const char* file, int line) {\n+    if (VerifyOops) {\n+      _verify_oop(reg, s, file, line);\n+    }\n+  }\n+  void _verify_oop_addr_checked(Address reg, const char* s, const char* file, int line) {\n+    if (VerifyOops) {\n+      _verify_oop_addr(reg, s, file, line);\n+    }\n+  }\n+\n@@ -656,3 +664,3 @@\n-#define verify_oop(reg) _verify_oop(reg, \"broken oop \" #reg, __FILE__, __LINE__)\n-#define verify_oop_msg(reg, msg) _verify_oop(reg, \"broken oop \" #reg \", \" #msg, __FILE__, __LINE__)\n-#define verify_oop_addr(addr) _verify_oop_addr(addr, \"broken oop addr \" #addr, __FILE__, __LINE__)\n+#define verify_oop(reg) _verify_oop_checked(reg, \"broken oop \" #reg, __FILE__, __LINE__)\n+#define verify_oop_msg(reg, msg) _verify_oop_checked(reg, \"broken oop \" #reg \", \" #msg, __FILE__, __LINE__)\n+#define verify_oop_addr(addr) _verify_oop_addr_checked(addr, \"broken oop addr \" #addr, __FILE__, __LINE__)\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -7036,1 +7036,3 @@\n-    StubRoutines::_verify_oop_subroutine_entry = generate_verify_oop();\n+    if (VerifyOops) {\n+      StubRoutines::_verify_oop_subroutine_entry = generate_verify_oop();\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -653,2 +653,3 @@\n-    st->print(\"TEST   PollPage,EAX\\t! Poll Safepoint\");\n-    st->cr(); st->print(\"\\t\");\n+    st->print(\"CMPL     rsp, poll_offset[thread]  \\n\\t\"\n+              \"JA       #safepoint_stub\\t\"\n+              \"# Safepoint: poll for GC\");\n@@ -697,1 +698,1 @@\n-    Register pollReg = as_Register(EBX_enc);\n+    Register thread = as_Register(EBX_enc);\n@@ -699,4 +700,8 @@\n-    masm.get_thread(pollReg);\n-    masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));\n-    masm.relocate(relocInfo::poll_return_type);\n-    masm.testl(rax, Address(pollReg, 0));\n+    __ get_thread(thread);\n+    Label dummy_label;\n+    Label* code_stub = &dummy_label;\n+    if (!C->output()->in_scratch_emit_size()) {\n+      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+    }\n+    __ relocate(relocInfo::poll_return_type);\n+    __ safepoint_poll(*code_stub, thread, true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -930,2 +930,2 @@\n-    st->print_cr(\"cmpq    poll_offset[r15_thread], rsp\\n\\t\"\n-                 \"ja      #safepoint_stub\\t\"\n+    st->print_cr(\"cmpq     rsp, poll_offset[r15_thread] \\n\\t\"\n+                 \"ja       #safepoint_stub\\t\"\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -338,0 +338,2 @@\n+  return data_from(data_layout);\n+}\n@@ -339,0 +341,1 @@\n+ciProfileData* ciMethodData::data_from(DataLayout* data_layout) {\n@@ -383,0 +386,10 @@\n+DataLayout* ciMethodData::next_data_layout(DataLayout* current) {\n+  int current_index = dp_to_di((address)current);\n+  int next_index = current_index + current->size_in_bytes();\n+  if (out_of_bounds(next_index)) {\n+    return NULL;\n+  }\n+  DataLayout* next = data_layout_at(next_index);\n+  return next;\n+}\n+\n@@ -420,6 +433,6 @@\n-    ciProfileData* data = data_before(bci);\n-    for ( ; is_valid(data); data = next_data(data)) {\n-      if (data->bci() == bci) {\n-        set_hint_di(dp_to_di(data->dp()));\n-        return data;\n-      } else if (data->bci() > bci) {\n+    DataLayout* data_layout = data_layout_before(bci);\n+    for ( ; is_valid(data_layout); data_layout = next_data_layout(data_layout)) {\n+      if (data_layout->bci() == bci) {\n+        set_hint_di(dp_to_di((address)data_layout));\n+        return data_from(data_layout);\n+      } else if (data_layout->bci() > bci) {\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-  \/\/ Cached hint for data_before()\n+  \/\/ Cached hint for data_layout_before()\n@@ -482,1 +482,2 @@\n-  ciProfileData* data_before(int bci) {\n+\n+  DataLayout* data_layout_before(int bci) {\n@@ -486,4 +487,4 @@\n-    int hint = hint_di();\n-    if (data_layout_at(hint)->bci() <= bci)\n-      return data_at(hint);\n-    return first_data();\n+    DataLayout* layout = data_layout_at(hint_di());\n+    if (layout->bci() <= bci)\n+      return layout;\n+    return data_layout_at(first_di());\n@@ -492,1 +493,0 @@\n-\n@@ -506,0 +506,1 @@\n+  ciProfileData* data_from(DataLayout* data_layout);\n@@ -556,0 +557,1 @@\n+  DataLayout* next_data_layout(DataLayout* current);\n@@ -557,0 +559,1 @@\n+  bool is_valid(DataLayout* current)    { return current != NULL; }\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -498,1 +498,1 @@\n-  \/\/ compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> <depth> <bci> <klass> <name> <signature> ...\n+  \/\/ compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> (<depth> <bci> <klass> <name> <signature>)*\n@@ -528,1 +528,1 @@\n-  \/\/ compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> <depth> <bci> <klass> <name> <signature> ...\n+  \/\/ compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> (<depth> <bci> <klass> <name> <signature>)*\n@@ -610,2 +610,0 @@\n-  \/\/\n-  \/\/\n@@ -623,1 +621,1 @@\n-  \/\/ ciMethodData <klass> <name> <signature> <state> <current mileage> orig <length> # # ... data <length> # # ... oops <length> # ... methods <length>\n+  \/\/ ciMethodData <klass> <name> <signature> <state> <current_mileage> orig <length> <byte>* data <length> <ptr>* oops <length> (<offset> <klass>)* methods <length> (<offset> <klass> <name> <signature>)*\n@@ -698,1 +696,1 @@\n-  \/\/ ciInstanceKlass <name> <is_linked> <is_initialized> <length> tag # # # ...\n+  \/\/ ciInstanceKlass <name> <is_linked> <is_initialized> <length> tag*\n@@ -1020,0 +1018,1 @@\n+  \/\/ JvmtiExport <field> <value>\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4048,3 +4048,10 @@\n-        } else if (_major_version >= JAVA_15_VERSION) {\n-          \/\/ Check for PermittedSubclasses tag\n-          if (tag == vmSymbols::tag_permitted_subclasses()) {\n+        } else if (_major_version >= JAVA_16_VERSION) {\n+          if (tag == vmSymbols::tag_record()) {\n+            if (parsed_record_attribute) {\n+              classfile_parse_error(\"Multiple Record attributes in class file %s\", THREAD);\n+              return;\n+            }\n+            parsed_record_attribute = true;\n+            record_attribute_start = cfs->current();\n+            record_attribute_length = attribute_length;\n+          } else if (tag == vmSymbols::tag_permitted_subclasses()) {\n@@ -4065,16 +4072,2 @@\n-            cfs->skip_u1(attribute_length, CHECK);\n-\n-          } else if (_major_version >= JAVA_16_VERSION) {\n-            if (tag == vmSymbols::tag_record()) {\n-              if (parsed_record_attribute) {\n-                classfile_parse_error(\"Multiple Record attributes in class file %s\", THREAD);\n-                return;\n-              }\n-              parsed_record_attribute = true;\n-              record_attribute_start = cfs->current();\n-              record_attribute_length = attribute_length;\n-              }\n-            cfs->skip_u1(attribute_length, CHECK);\n-          } else {\n-            \/\/ Unknown attribute\n-            cfs->skip_u1(attribute_length, CHECK);\n+          \/\/ Skip attribute_length for any attribute where major_verson >= JAVA_16_VERSION\n+          cfs->skip_u1(attribute_length, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"memory\/archiveUtils.hpp\"\n@@ -118,7 +119,0 @@\n-    \/\/ Check if the line is output TRACE_RESOLVE\n-    if (strncmp(_line, LambdaFormInvokers::lambda_form_invoker_tag(),\n-                strlen(LambdaFormInvokers::lambda_form_invoker_tag())) == 0) {\n-      LambdaFormInvokers::append(os::strdup((const char*)_line, mtInternal));\n-      continue;\n-    }\n-\n@@ -136,0 +130,1 @@\n+  _lambda_form_line = false;\n@@ -188,2 +183,2 @@\n-void ClassListParser::split_tokens_by_whitespace() {\n-  int start = 0;\n+void ClassListParser::split_tokens_by_whitespace(int offset) {\n+  int start = offset;\n@@ -206,0 +201,12 @@\n+int ClassListParser::split_at_tag_from_line() {\n+  _token = _line;\n+  char* ptr;\n+  if ((ptr = strchr(_line, ' ')) == NULL) {\n+    error(\"Too few items following the @ tag \\\"%s\\\" line #%d\", _line, _line_no);\n+    return 0;\n+  }\n+  *ptr++ = '\\0';\n+  while (*ptr == ' ' || *ptr == '\\t') ptr++;\n+  return (int)(ptr - _line);\n+}\n+\n@@ -208,4 +215,9 @@\n-  split_tokens_by_whitespace();\n-  if (strcmp(_indy_items->at(0), LAMBDA_PROXY_TAG) == 0) {\n-    if (_indy_items->length() < 3) {\n-      error(\"Line with @ tag has too few items \\\"%s\\\" line #%d\", _line, _line_no);\n+  int offset;\n+  if ((offset = split_at_tag_from_line()) == 0) {\n+    return false;\n+  }\n+\n+  if (strcmp(_token, LAMBDA_PROXY_TAG) == 0) {\n+    split_tokens_by_whitespace(offset);\n+    if (_indy_items->length() < 2) {\n+      error(\"Line with @ tag has too few items \\\"%s\\\" line #%d\", _token, _line_no);\n@@ -215,1 +227,5 @@\n-    _class_name = _indy_items->at(1);\n+    _class_name = _indy_items->at(0);\n+    return true;\n+  } else if (strcmp(_token, LAMBDA_FORM_TAG) == 0) {\n+    LambdaFormInvokers::append(os::strdup((const char*)(_line + offset), mtInternal));\n+    _lambda_form_line = true;\n@@ -218,1 +234,1 @@\n-    error(\"Invalid @ tag at the beginning of line \\\"%s\\\" line #%d\", _line, _line_no);\n+    error(\"Invalid @ tag at the beginning of line \\\"%s\\\" line #%d\", _token, _line_no);\n@@ -461,1 +477,1 @@\n-  int indy_info_offset = 2;\n+  int indy_info_offset = 1;\n@@ -586,0 +602,1 @@\n+        ArchiveUtils::check_for_oom(PENDING_EXCEPTION); \/\/ exit on OOM\n@@ -596,0 +613,2 @@\n+          } else {\n+            ArchiveUtils::check_for_oom(PENDING_EXCEPTION); \/\/ exit on OOM\n@@ -604,0 +623,3 @@\n+    if (HAS_PENDING_EXCEPTION) {\n+      ArchiveUtils::check_for_oom(PENDING_EXCEPTION); \/\/ exit on OOM\n+    }\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":38,"deletions":16,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -907,2 +907,3 @@\n-  static inline oop referent(oop ref);\n-  static inline void set_referent(oop ref, oop value);\n+  static inline oop weak_referent_no_keepalive(oop ref);\n+  static inline oop phantom_referent_no_keepalive(oop ref);\n+  static inline oop unknown_referent_no_keepalive(oop ref);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -78,0 +79,3 @@\n+    _string_klass_or_null(G1StringDedup::is_enabled()\n+                          ? SystemDictionary::String_klass()\n+                          : nullptr),\n@@ -82,0 +86,4 @@\n+  \/\/ Verify klass comparison with _string_klass_or_null is sufficient\n+  \/\/ to determine whether dedup is enabled and the object is a String.\n+  assert(SystemDictionary::String_klass()->is_final(), \"precondition\");\n+\n@@ -514,1 +522,4 @@\n-    if (G1StringDedup::is_enabled()) {\n+    \/\/ StringDedup::is_enabled() and java_lang_String::is_instance_inline\n+    \/\/ test of the obj, combined into a single comparison, using the klass\n+    \/\/ already in hand and avoiding the null check in is_instance.\n+    if (klass == _string_klass_or_null) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -314,6 +314,0 @@\n-  \/\/ Return the address \"addr\" aligned by \"alignment_in_bytes\" if such\n-  \/\/ an address is below \"end\".  Return NULL otherwise.\n-  inline static HeapWord* align_allocation_or_fail(HeapWord* addr,\n-                                                   HeapWord* end,\n-                                                   unsigned short alignment_in_bytes);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,37 +33,0 @@\n-inline HeapWord* CollectedHeap::align_allocation_or_fail(HeapWord* addr,\n-                                                         HeapWord* end,\n-                                                         unsigned short alignment_in_bytes) {\n-  if (alignment_in_bytes <= ObjectAlignmentInBytes) {\n-    return addr;\n-  }\n-\n-  assert(is_aligned(addr, HeapWordSize),\n-         \"Address \" PTR_FORMAT \" is not properly aligned.\", p2i(addr));\n-  assert(is_aligned(alignment_in_bytes, HeapWordSize),\n-         \"Alignment size %u is incorrect.\", alignment_in_bytes);\n-\n-  HeapWord* new_addr = align_up(addr, alignment_in_bytes);\n-  size_t padding = pointer_delta(new_addr, addr);\n-\n-  if (padding == 0) {\n-    return addr;\n-  }\n-\n-  if (padding < CollectedHeap::min_fill_size()) {\n-    padding += alignment_in_bytes \/ HeapWordSize;\n-    assert(padding >= CollectedHeap::min_fill_size(),\n-           \"alignment_in_bytes %u is expect to be larger \"\n-           \"than the minimum object size\", alignment_in_bytes);\n-    new_addr = addr + padding;\n-  }\n-\n-  assert(new_addr > addr, \"Unexpected arithmetic overflow \"\n-         PTR_FORMAT \" not greater than \" PTR_FORMAT, p2i(new_addr), p2i(addr));\n-  if(new_addr < end) {\n-    CollectedHeap::fill_with_object(addr, padding);\n-    return new_addr;\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.inline.hpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -308,1 +308,2 @@\n-         (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));\n+         (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak)) ||\n+         (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak_narrow));\n@@ -548,3 +549,2 @@\n-    load = new ShenandoahLoadReferenceBarrierNode(NULL,\n-                                                  load,\n-                                                  ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type));\n+    ShenandoahBarrierSet::AccessKind kind = ShenandoahBarrierSet::access_kind(decorators, type);\n+    load = new ShenandoahLoadReferenceBarrierNode(NULL, load, kind);\n@@ -647,1 +647,1 @@\n-    load_store = kit->gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, load_store, false));\n+    load_store = kit->gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, load_store, ShenandoahBarrierSet::AccessKind::NORMAL));\n@@ -715,1 +715,1 @@\n-    result = kit->gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, result, false));\n+    result = kit->gvn().transform(new ShenandoahLoadReferenceBarrierNode(NULL, result, ShenandoahBarrierSet::AccessKind::NORMAL));\n@@ -1062,0 +1062,2 @@\n+\n+    \/\/ If one input is NULL, then step over the barriers normal LRB barriers on the other input\n@@ -1063,1 +1065,2 @@\n-        (in1->Opcode() != Op_ShenandoahLoadReferenceBarrier || !((ShenandoahLoadReferenceBarrierNode*)in1)->is_native())) {\n+        !((in2->Opcode() == Op_ShenandoahLoadReferenceBarrier) &&\n+          ((ShenandoahLoadReferenceBarrierNode*)in2)->kind() != ShenandoahBarrierSet::AccessKind::NORMAL)) {\n@@ -1067,1 +1070,2 @@\n-        (in2->Opcode() != Op_ShenandoahLoadReferenceBarrier || !((ShenandoahLoadReferenceBarrierNode*)in2)->is_native())) {\n+        !((in1->Opcode() == Op_ShenandoahLoadReferenceBarrier) &&\n+          ((ShenandoahLoadReferenceBarrierNode*)in1)->kind() != ShenandoahBarrierSet::AccessKind::NORMAL)) {\n@@ -1070,0 +1074,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -958,1 +958,2 @@\n-void ShenandoahBarrierC2Support::call_lrb_stub(Node*& ctrl, Node*& val, Node* load_addr, Node*& result_mem, Node* raw_mem, bool is_native, PhaseIdealLoop* phase) {\n+void ShenandoahBarrierC2Support::call_lrb_stub(Node*& ctrl, Node*& val, Node* load_addr, Node*& result_mem, Node* raw_mem,\n+                                               ShenandoahBarrierSet::AccessKind kind, PhaseIdealLoop* phase) {\n@@ -969,7 +970,22 @@\n-  address target = LP64_ONLY(UseCompressedOops) NOT_LP64(false) ?\n-          CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow) :\n-          CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier);\n-\n-  address calladdr = is_native ? CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native)\n-                               : target;\n-  const char* name = is_native ? \"load_reference_barrier_native\" : \"load_reference_barrier\";\n+  address calladdr = NULL;\n+  const char* name = NULL;\n+  switch (kind) {\n+    case ShenandoahBarrierSet::AccessKind::NATIVE:\n+      calladdr = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak);\n+      name = \"load_reference_barrier_native\";\n+      break;\n+    case ShenandoahBarrierSet::AccessKind::WEAK:\n+      calladdr = LP64_ONLY(UseCompressedOops) NOT_LP64(false) ?\n+                 CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak_narrow) :\n+                 CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak);\n+      name = \"load_reference_barrier_weak\";\n+      break;\n+    case ShenandoahBarrierSet::AccessKind::NORMAL:\n+      calladdr = LP64_ONLY(UseCompressedOops) NOT_LP64(false) ?\n+                 CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow) :\n+                 CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier);\n+      name = \"load_reference_barrier\";\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -1338,1 +1354,1 @@\n-    if (!lrb->is_native()) {\n+    if (lrb->kind() == ShenandoahBarrierSet::AccessKind::NORMAL) {\n@@ -1389,1 +1405,1 @@\n-    call_lrb_stub(ctrl, val, addr, result_mem, raw_mem, lrb->is_native(), phase);\n+    call_lrb_stub(ctrl, val, addr, result_mem, raw_mem, lrb->kind(), phase);\n@@ -2314,1 +2330,1 @@\n-                    phi = NULL;\n+                    phi = NodeSentinel;\n@@ -2319,1 +2335,1 @@\n-            if (phi == NULL) {\n+            if (phi == NodeSentinel) {\n@@ -2328,2 +2344,5 @@\n-          assert(phi != NULL, \"\");\n-          regions.map(c->_idx, phi);\n+          if (phi != NULL) {\n+            regions.map(c->_idx, phi);\n+          } else {\n+            assert(c->unique_ctrl_out()->Opcode() == Op_Halt, \"expected memory state\");\n+          }\n@@ -2340,1 +2359,1 @@\n-        assert(m != NULL, \"expect memory state\");\n+        assert(m != NULL || c->Opcode() == Op_Halt, \"expect memory state\");\n@@ -2364,1 +2383,2 @@\n-      if (n->is_Phi() && n->_idx >= last && n->in(0) == c) {\n+      assert(n != NULL || c->unique_ctrl_out()->Opcode() == Op_Halt, \"expected memory state\");\n+      if (n != NULL && n->is_Phi() && n->_idx >= last && n->in(0) == c) {\n@@ -2373,0 +2393,1 @@\n+      assert(n != NULL || c->unique_ctrl_out()->Opcode() == Op_Halt, \"expected memory state\");\n@@ -2377,0 +2398,1 @@\n+          assert(c->unique_ctrl_out()->Opcode() != Op_Halt, \"expected memory state\");\n@@ -2878,2 +2900,2 @@\n-ShenandoahLoadReferenceBarrierNode::ShenandoahLoadReferenceBarrierNode(Node* ctrl, Node* obj, bool native)\n-: Node(ctrl, obj), _native(native) {\n+ShenandoahLoadReferenceBarrierNode::ShenandoahLoadReferenceBarrierNode(Node* ctrl, Node* obj, ShenandoahBarrierSet::AccessKind kind)\n+: Node(ctrl, obj), _kind(kind) {\n@@ -2883,2 +2905,2 @@\n-bool ShenandoahLoadReferenceBarrierNode::is_native() const {\n-  return _native;\n+ShenandoahBarrierSet::AccessKind ShenandoahLoadReferenceBarrierNode::kind() const {\n+  return _kind;\n@@ -2892,1 +2914,15 @@\n-  return Node::hash() + (_native ? 1 : 0);\n+  uint hash = Node::hash();\n+  switch (_kind) {\n+    case ShenandoahBarrierSet::AccessKind::NORMAL:\n+      hash += 0;\n+      break;\n+    case ShenandoahBarrierSet::AccessKind::WEAK:\n+      hash += 1;\n+      break;\n+    case ShenandoahBarrierSet::AccessKind::NATIVE:\n+      hash += 2;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  return hash;\n@@ -2897,1 +2933,1 @@\n-         _native == ((const ShenandoahLoadReferenceBarrierNode&)n)._native;\n+         _kind == ((const ShenandoahLoadReferenceBarrierNode&)n)._kind;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":58,"deletions":22,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -36,1 +36,11 @@\n-private:\n+public:\n+  enum class AccessKind {\n+    \/\/ Regular in-heap access on reference fields\n+    NORMAL,\n+\n+    \/\/ Off-heap reference access\n+    NATIVE,\n+\n+    \/\/ In-heap reference access on referent fields of j.l.r.Reference objects\n+    WEAK\n+  };\n@@ -38,0 +48,1 @@\n+private:\n@@ -56,1 +67,1 @@\n-  static bool use_load_reference_barrier_native(DecoratorSet decorators, BasicType type);\n+  static AccessKind access_kind(DecoratorSet decorators, BasicType type);\n@@ -90,2 +101,1 @@\n-  oop load_reference_barrier(oop obj);\n-  oop load_reference_barrier_not_null(oop obj);\n+  inline oop load_reference_barrier(oop obj);\n@@ -96,2 +106,2 @@\n-  template <class T>\n-  inline oop load_reference_barrier_native(oop obj, T* load_addr);\n+  template <DecoratorSet decorators, class T>\n+  inline oop load_reference_barrier(oop obj, T* load_addr);\n@@ -114,2 +124,0 @@\n-  oop load_reference_barrier_impl(oop obj);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -79,4 +79,19 @@\n-template <class T>\n-inline oop ShenandoahBarrierSet::load_reference_barrier_native(oop obj, T* load_addr) {\n-  if (CompressedOops::is_null(obj)) {\n-    return NULL;\n+inline oop ShenandoahBarrierSet::load_reference_barrier(oop obj) {\n+  if (!ShenandoahLoadRefBarrier) {\n+    return obj;\n+  }\n+  if (_heap->has_forwarded_objects() &&\n+      _heap->in_collection_set(obj)) { \/\/ Subsumes NULL-check\n+    assert(obj != NULL, \"cset check must have subsumed NULL-check\");\n+    oop fwd = resolve_forwarded_not_null(obj);\n+    \/\/ TODO: It should not be necessary to check evac-in-progress here.\n+    \/\/ We do it for mark-compact, which may have forwarded objects,\n+    \/\/ and objects in cset and gets here via runtime barriers.\n+    \/\/ We can probably fix this as soon as mark-compact has its own\n+    \/\/ marking phase.\n+    if (obj == fwd && _heap->is_evacuation_in_progress()) {\n+       Thread* t = Thread::current();\n+      ShenandoahEvacOOMScope oom_evac_scope(t);\n+      return _heap->evacuate_object(obj, t);\n+    }\n+    return fwd;\n@@ -84,0 +99,5 @@\n+  return obj;\n+}\n+\n+template <DecoratorSet decorators, class T>\n+inline oop ShenandoahBarrierSet::load_reference_barrier(oop obj, T* load_addr) {\n@@ -85,2 +105,4 @@\n-  ShenandoahMarkingContext* const marking_context = _heap->marking_context();\n-  if (_heap->is_concurrent_weak_root_in_progress() && !marking_context->is_marked(obj)) {\n+  \/\/ Prevent resurrection of unreachable non-strorg references.\n+  if (!HasDecorator<decorators, ON_STRONG_OOP_REF>::value && obj != NULL &&\n+      _heap->is_concurrent_weak_root_in_progress() &&\n+      !_heap->marking_context()->is_marked(obj)) {\n@@ -91,0 +113,2 @@\n+      \/\/ This path is sometimes (rarely) taken by GC threads.\n+      \/\/ See e.g.: https:\/\/bugs.openjdk.java.net\/browse\/JDK-8237874\n@@ -95,1 +119,1 @@\n-  oop fwd = load_reference_barrier_not_null(obj);\n+  oop fwd = load_reference_barrier(obj);\n@@ -131,2 +155,1 @@\n-  assert(value != NULL, \"checked before\");\n-  if (ShenandoahSATBBarrier && _heap->is_concurrent_mark_in_progress()) {\n+  if (value != NULL && ShenandoahSATBBarrier && _heap->is_concurrent_mark_in_progress()) {\n@@ -145,1 +168,0 @@\n-  assert(value != NULL, \"checked by caller\");\n@@ -155,1 +177,0 @@\n-  assert(value != NULL, \"checked by caller\");\n@@ -169,4 +190,2 @@\n-    value = bs->load_reference_barrier_native(value, addr);\n-    if (value != NULL) {\n-      bs->keep_alive_if_weak<decorators>(value);\n-    }\n+    value = bs->load_reference_barrier<decorators, T>(value, addr);\n+    bs->keep_alive_if_weak<decorators>(value);\n@@ -181,5 +200,3 @@\n-  if (value != NULL) {\n-    ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();\n-    value = bs->load_reference_barrier_not_null(value);\n-    bs->keep_alive_if_weak<decorators>(value);\n-  }\n+  ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();\n+  value = bs->load_reference_barrier<decorators, T>(value, addr);\n+  bs->keep_alive_if_weak<decorators>(value);\n@@ -192,6 +209,4 @@\n-  if (value != NULL) {\n-    ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();\n-    value = bs->load_reference_barrier_not_null(value);\n-    bs->keep_alive_if_weak(AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength<decorators>(base, offset),\n-                           value);\n-  }\n+  ShenandoahBarrierSet *const bs = ShenandoahBarrierSet::barrier_set();\n+  DecoratorSet resolved_decorators = AccessBarrierSupport::resolve_possibly_unknown_oop_ref_strength<decorators>(base, offset);\n+  value = bs->load_reference_barrier<decorators>(value, AccessInternal::oop_field_addr<decorators>(base, offset));\n+  bs->keep_alive_if_weak(resolved_decorators, value);\n@@ -205,0 +220,1 @@\n+  shenandoah_assert_not_in_cset_if(addr, value, value != NULL && !ShenandoahHeap::heap()->cancelled_gc());\n@@ -242,4 +258,2 @@\n-  if (res != NULL) {\n-    res = ShenandoahBarrierSet::barrier_set()->load_reference_barrier_not_null(res);\n-    bs->satb_enqueue(res);\n-  }\n+  res = ShenandoahBarrierSet::barrier_set()->load_reference_barrier(res);\n+  bs->satb_enqueue(res);\n@@ -270,4 +284,2 @@\n-  if (previous != NULL) {\n-    previous = ShenandoahBarrierSet::barrier_set()->load_reference_barrier_not_null(previous);\n-    bs->satb_enqueue(previous);\n-  }\n+  previous = ShenandoahBarrierSet::barrier_set()->load_reference_barrier(previous);\n+  bs->satb_enqueue(previous);\n@@ -331,1 +343,1 @@\n-      if (ENQUEUE && !ctx->is_marked(obj)) {\n+      if (ENQUEUE && !ctx->is_marked_strong(obj)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":47,"deletions":35,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -1998,0 +1998,8 @@\n+\n+  if (displacement == java_lang_Class::component_mirror_offset() && java_lang_Class::is_instance(obj()) &&\n+      !java_lang_Class::as_Klass(obj())->is_array_klass()) {\n+    \/\/ Class.componentType for non-array classes can transiently contain an int[] that's\n+    \/\/ used for locking so always return null to mimic Class.getComponentType()\n+    return JVMCIENV->get_jobject(JVMCIENV->get_JavaConstant_NULL_POINTER());\n+  }\n+\n@@ -2223,0 +2231,7 @@\n+  if (displacement == java_lang_Class::component_mirror_offset() && java_lang_Class::is_instance(xobj()) &&\n+      !java_lang_Class::as_Klass(xobj())->is_array_klass()) {\n+    \/\/ Class.componentType for non-array classes can transiently contain an int[] that's\n+    \/\/ used for locking so always return null to mimic Class.getComponentType()\n+    return JVMCIENV->get_jobject(JVMCIENV->get_JavaConstant_NULL_POINTER());\n+  }\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  NOT_PRODUCT(LOG_TAG(generate)) \\\n@@ -83,0 +84,1 @@\n+  NOT_PRODUCT(LOG_TAG(heapsampling)) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,1 +209,3 @@\n-    vm_exit(1);\n+    vm_direct_exit(-1,\n+      err_msg(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n+              SIZE_FORMAT \"M\", MaxHeapSize\/M));\n@@ -262,9 +264,0 @@\n-  if (!is_heap_object_archiving_allowed()) {\n-    log_info(cds)(\n-      \"Archived java heap is not supported as UseG1GC, \"\n-      \"UseCompressedOops and UseCompressedClassPointers are required.\"\n-      \"Current settings: UseG1GC=%s, UseCompressedOops=%s, UseCompressedClassPointers=%s.\",\n-      BOOL_TO_STR(UseG1GC), BOOL_TO_STR(UseCompressedOops),\n-      BOOL_TO_STR(UseCompressedClassPointers));\n-    return;\n-  }\n@@ -737,1 +730,1 @@\n-    vm_exit(1);\n+    vm_direct_exit(1);\n@@ -747,1 +740,1 @@\n-    vm_exit(1);\n+    vm_direct_exit(1);\n@@ -783,1 +776,1 @@\n-        vm_exit(1);\n+        vm_direct_exit(1);\n@@ -1038,1 +1031,7 @@\n-    assert(k != NULL && !HAS_PENDING_EXCEPTION, \"class must exist\");\n+    if (HAS_PENDING_EXCEPTION) {\n+      ResourceMark rm(THREAD);\n+      ArchiveUtils::check_for_oom(PENDING_EXCEPTION); \/\/ exit on OOM\n+      log_info(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),\n+                    java_lang_String::as_utf8_string(java_lang_Throwable::message(PENDING_EXCEPTION)));\n+      vm_direct_exit(-1, \"VM exits due to exception, use -Xlog:cds,exceptions=trace for detail\");\n+    }\n@@ -1055,0 +1054,1 @@\n+  assert(is_heap_object_archiving_allowed(), \"Sanity check\");\n@@ -1056,1 +1056,0 @@\n-\n@@ -1071,2 +1070,4 @@\n-  _dumped_interned_strings = new (ResourceObj::C_HEAP, mtClass)DumpedInternedStrings();\n-  init_subgraph_entry_fields(THREAD);\n+  if (is_heap_object_archiving_allowed()) {\n+    _dumped_interned_strings = new (ResourceObj::C_HEAP, mtClass)DumpedInternedStrings();\n+    init_subgraph_entry_fields(THREAD);\n+  }\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -153,0 +153,6 @@\n+template <int claim>\n+class ClaimingCLDToOopClosure : public CLDToOopClosure {\n+public:\n+  ClaimingCLDToOopClosure(OopClosure* cl) : CLDToOopClosure(cl, claim) {}\n+};\n+\n@@ -265,0 +271,9 @@\n+class CodeBlobToNMethodClosure : public CodeBlobClosure {\n+  NMethodClosure* const _nm_cl;\n+\n+ public:\n+  CodeBlobToNMethodClosure(NMethodClosure* nm_cl) : _nm_cl(nm_cl) {}\n+\n+  virtual void do_code_blob(CodeBlob* cb);\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1101,0 +1101,3 @@\n+    if (parser.lambda_form_line()) {\n+      continue;\n+    }\n@@ -1168,0 +1171,9 @@\n+  if(!HeapShared::is_heap_object_archiving_allowed()) {\n+    log_info(cds)(\n+      \"Archived java heap is not supported as UseG1GC, \"\n+      \"UseCompressedOops and UseCompressedClassPointers are required.\"\n+      \"Current settings: UseG1GC=%s, UseCompressedOops=%s, UseCompressedClassPointers=%s.\",\n+      BOOL_TO_STR(UseG1GC), BOOL_TO_STR(UseCompressedOops),\n+      BOOL_TO_STR(UseCompressedClassPointers));\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1138,0 +1138,38 @@\n+int DataLayout::cell_count() {\n+  switch (tag()) {\n+  case DataLayout::no_tag:\n+  default:\n+    ShouldNotReachHere();\n+    return 0;\n+  case DataLayout::bit_data_tag:\n+    return BitData::static_cell_count();\n+  case DataLayout::counter_data_tag:\n+    return CounterData::static_cell_count();\n+  case DataLayout::jump_data_tag:\n+    return JumpData::static_cell_count();\n+  case DataLayout::receiver_type_data_tag:\n+    return ReceiverTypeData::static_cell_count();\n+  case DataLayout::virtual_call_data_tag:\n+    return VirtualCallData::static_cell_count();\n+  case DataLayout::ret_data_tag:\n+    return RetData::static_cell_count();\n+  case DataLayout::branch_data_tag:\n+    return BranchData::static_cell_count();\n+  case DataLayout::multi_branch_data_tag:\n+    return ((new MultiBranchData(this))->cell_count());\n+  case DataLayout::arg_info_data_tag:\n+    return ((new ArgInfoData(this))->cell_count());\n+  case DataLayout::call_type_data_tag:\n+    return ((new CallTypeData(this))->cell_count());\n+  case DataLayout::virtual_call_type_data_tag:\n+    return ((new VirtualCallTypeData(this))->cell_count());\n+  case DataLayout::parameters_type_data_tag:\n+    return ((new ParametersTypeData(this))->cell_count());\n+  case DataLayout::speculative_trap_data_tag:\n+    return SpeculativeTrapData::static_cell_count();\n+  case DataLayout::array_load_store_data_tag:\n+    return ((new ArrayLoadStoreData(this))->cell_count());\n+  case DataLayout::acmp_data_tag:\n+    return ((new ACmpData(this))->cell_count());\n+  }\n+}\n@@ -1185,0 +1223,10 @@\n+DataLayout* MethodData::next_data_layout(DataLayout* current) const {\n+  int current_index = dp_to_di((address)current);\n+  int next_index = current_index + current->size_in_bytes();\n+  if (out_of_bounds(next_index)) {\n+    return NULL;\n+  }\n+  DataLayout* next = data_layout_at(next_index);\n+  return next;\n+}\n+\n@@ -1357,3 +1405,3 @@\n-  ProfileData* data = data_before(bci);\n-  ProfileData* prev = NULL;\n-  for ( ; is_valid(data); data = next_data(data)) {\n+  DataLayout* data = data_layout_before(bci);\n+  DataLayout* prev = NULL;\n+  for ( ; is_valid(data); data = next_data_layout(data)) {\n@@ -1361,3 +1409,3 @@\n-      if (data->bci() == bci)  set_hint_di(dp_to_di(data->dp()));\n-      else if (prev != NULL)   set_hint_di(dp_to_di(prev->dp()));\n-      return data->dp();\n+      if (data->bci() == bci)  set_hint_di(dp_to_di((address)data));\n+      else if (prev != NULL)   set_hint_di(dp_to_di((address)prev));\n+      return (address)data;\n@@ -1372,2 +1420,2 @@\n-  ProfileData* data = data_before(bci);\n-  for ( ; is_valid(data); data = next_data(data)) {\n+  DataLayout* data = data_layout_before(bci);\n+  for ( ; is_valid(data); data = next_data_layout(data)) {\n@@ -1375,2 +1423,2 @@\n-      set_hint_di(dp_to_di(data->dp()));\n-      return data;\n+      set_hint_di(dp_to_di((address)data));\n+      return data->data_in();\n@@ -1829,6 +1877,0 @@\n-  for (ProfileData* data = first_data();\n-       is_valid(data);\n-       data = next_data(data)) {\n-    data->clean_weak_method_links();\n-  }\n-\n@@ -1839,14 +1881,0 @@\n-\n-#ifdef ASSERT\n-void MethodData::verify_clean_weak_method_links() {\n-  ResourceMark rm;\n-  for (ProfileData* data = first_data();\n-       is_valid(data);\n-       data = next_data(data)) {\n-    data->verify_clean_weak_method_links();\n-  }\n-\n-  CleanExtraDataMethodClosure cl;\n-  verify_extra_data_clean(&cl);\n-}\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":58,"deletions":30,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -241,0 +241,7 @@\n+  int size_in_bytes() {\n+    int cells = cell_count();\n+    assert(cells >= 0, \"invalid number of cells\");\n+    return DataLayout::compute_size_in_bytes(cells);\n+  }\n+  int cell_count();\n+\n@@ -243,4 +250,0 @@\n-\n-  \/\/ Redefinition support\n-  void clean_weak_method_links();\n-  DEBUG_ONLY(void verify_clean_weak_method_links();)\n@@ -472,4 +475,0 @@\n-  \/\/ Redefinition support\n-  virtual void clean_weak_method_links() {}\n-  DEBUG_ONLY(virtual void verify_clean_weak_method_links() {})\n-\n@@ -2225,1 +2224,2 @@\n-  ProfileData* data_before(int bci) {\n+\n+  DataLayout* data_layout_before(int bci) {\n@@ -2229,4 +2229,4 @@\n-    int hint = hint_di();\n-    if (data_layout_at(hint)->bci() <= bci)\n-      return data_at(hint);\n-    return first_data();\n+    DataLayout* layout = data_layout_at(hint_di());\n+    if (layout->bci() <= bci)\n+      return layout;\n+    return data_layout_at(first_di());\n@@ -2415,0 +2415,1 @@\n+  DataLayout*  next_data_layout(DataLayout* current) const;\n@@ -2416,0 +2417,1 @@\n+  bool is_valid(DataLayout*  current) const { return current != NULL; }\n@@ -2579,1 +2581,0 @@\n-  DEBUG_ONLY(void verify_clean_weak_method_links();)\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-  if( in(1)->Opcode() == Op_SubI && phase->eqv(in(1)->in(2),in(2)) ) {\n+  if (in(1)->Opcode() == Op_SubI && in(1)->in(2) == in(2)) {\n@@ -333,2 +333,1 @@\n-  }\n-  else if( in(2)->Opcode() == Op_SubI && phase->eqv(in(2)->in(2),in(1)) ) {\n+  } else if (in(2)->Opcode() == Op_SubI && in(2)->in(2) == in(1)) {\n@@ -448,1 +447,1 @@\n-  if( in(1)->Opcode() == Op_SubL && phase->eqv(in(1)->in(2),in(2)) ) {\n+  if (in(1)->Opcode() == Op_SubL && in(1)->in(2) == in(2)) {\n@@ -450,2 +449,1 @@\n-  }\n-  else if( in(2)->Opcode() == Op_SubL && phase->eqv(in(2)->in(2),in(1)) ) {\n+  } else if (in(2)->Opcode() == Op_SubL && in(2)->in(2) == in(1)) {\n@@ -751,1 +749,1 @@\n-  if (phase->eqv(in(1), in(2))) {\n+  if (in(1) == in(2)) {\n@@ -838,1 +836,1 @@\n-  if (phase->eqv(in(1), in(2))) {\n+  if (in(1) == in(2)) {\n@@ -1093,1 +1091,1 @@\n-    if (phase->eqv(x,y) && tx != NULL &&\n+    if (x == y && tx != NULL &&\n@@ -1101,1 +1099,1 @@\n-    if (phase->eqv(x,y) && tx != NULL &&\n+    if (x == y && tx != NULL &&\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1433,2 +1433,6 @@\n-  if( phase->type(in(0)) == Type::TOP ) return Type::TOP;\n-  if( phase->eqv( in(0), this ) ) return Type::TOP; \/\/ Dead infinite loop\n+  if (phase->type(in(0)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  if (in(0) == this) {\n+    return Type::TOP; \/\/ Dead infinite loop\n+  }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -752,3 +752,1 @@\n-\n-    _is_scalar_replaceable = false;\n-    _is_non_escaping = false;\n+\n@@ -762,2 +760,0 @@\n-    _is_scalar_replaceable = false;\n-    _is_non_escaping = false;\n@@ -767,4 +763,0 @@\n-  \/\/ Result of Escape Analysis\n-  bool _is_scalar_replaceable;\n-  bool _is_non_escaping;\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-      assert(phase->eqv(phi->in(0), this), \"sanity check phi\");\n+      assert(phi->in(0) == this, \"sanity check phi\");\n@@ -387,1 +387,1 @@\n-        if (phase->eqv(m, this)) {\n+        if (m == this) {\n@@ -578,1 +578,1 @@\n-            assert( igvn->eqv(n->in(0), this), \"\" );\n+            assert(n->in(0) == this, \"\");\n@@ -629,1 +629,1 @@\n-        assert(!igvn->eqv(parent_ctrl, this), \"Close dead loop\");\n+        assert(parent_ctrl != this, \"Close dead loop\");\n@@ -651,1 +651,1 @@\n-          assert( !igvn->eqv(n, this), \"Must be removed from DefUse edges\");\n+          assert(n != this, \"Must be removed from DefUse edges\");\n@@ -664,1 +664,1 @@\n-          assert( igvn->eqv(n->in(0), this), \"Expect RegionNode to be control parent\");\n+          assert(n->in(0) == this, \"Expect RegionNode to be control parent\");\n@@ -669,1 +669,1 @@\n-          assert( !igvn->eqv(n->in(k), this), \"All uses of RegionNode should be gone\");\n+          assert(n->in(k) != this, \"All uses of RegionNode should be gone\");\n@@ -2109,1 +2109,1 @@\n-    assert(opt == NULL || phase->eqv(opt, this), \"do not elide phi\");\n+    assert(opt == NULL || opt == this, \"do not elide phi\");\n@@ -2227,1 +2227,1 @@\n-        saw_self = saw_self || phase->eqv(n->base_memory(), this);\n+        saw_self = saw_self || (n->base_memory() == this);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -508,1 +508,1 @@\n-  if( phase->eqv( in(1), in(2) ) )\n+  if (in(1) == in(2)) {\n@@ -510,0 +510,1 @@\n+  }\n@@ -613,1 +614,1 @@\n-  if( phase->eqv( in(1), in(2) ) )\n+  if (in(1) == in(2)) {\n@@ -615,0 +616,1 @@\n+  }\n@@ -688,3 +690,4 @@\n-  if( phase->eqv( in(1), in(2) ) && t1->base() == Type::FloatCon)\n-    if (!g_isnan(t1->getf()) && g_isfinite(t1->getf()) && t1->getf() != 0.0) \/\/ could be negative ZERO or NaN\n-      return TypeF::ONE;\n+  if (in(1) == in(2) && t1->base() == Type::FloatCon &&\n+      !g_isnan(t1->getf()) && g_isfinite(t1->getf()) && t1->getf() != 0.0) { \/\/ could be negative ZERO or NaN\n+    return TypeF::ONE;\n+  }\n@@ -776,3 +779,4 @@\n-  if( phase->eqv( in(1), in(2) ) && t1->base() == Type::DoubleCon)\n-    if (!g_isnan(t1->getd()) && g_isfinite(t1->getd()) && t1->getd() != 0.0) \/\/ could be negative ZERO or NaN\n-      return TypeD::ONE;\n+  if (in(1) == in(2) && t1->base() == Type::DoubleCon &&\n+      !g_isnan(t1->getd()) && g_isfinite(t1->getd()) && t1->getd() != 0.0) { \/\/ could be negative ZERO or NaN\n+    return TypeD::ONE;\n+  }\n@@ -993,1 +997,3 @@\n-  if( phase->eqv( in(1), in(2) ) ) return TypeInt::ZERO;\n+  if (in(1) == in(2)) {\n+    return TypeInt::ZERO;\n+  }\n@@ -1166,1 +1172,3 @@\n-  if( phase->eqv( in(1), in(2) ) ) return TypeLong::ZERO;\n+  if (in(1) == in(2)) {\n+    return TypeLong::ZERO;\n+  }\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -259,3 +259,0 @@\n-    if (n->is_CallStaticJava()) {\n-      n->as_CallStaticJava()->_is_non_escaping = noescape;\n-    }\n@@ -3129,5 +3126,0 @@\n-        if (alloc->is_CallStaticJava()) {\n-          \/\/ Set the scalar_replaceable flag for boxing method\n-          \/\/ so it could be eliminated if it has no uses.\n-          alloc->as_CallStaticJava()->_is_scalar_replaceable = true;\n-        }\n@@ -3182,5 +3174,0 @@\n-      if (alloc->is_CallStaticJava()) {\n-        \/\/ Set the scalar_replaceable flag for boxing method\n-        \/\/ so it could be eliminated.\n-        alloc->as_CallStaticJava()->_is_scalar_replaceable = true;\n-      }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1085,1 +1085,1 @@\n-      if (!phase->eqv(st_adr, ld_adr)) {\n+      if (st_adr != ld_adr) {\n@@ -1567,1 +1567,1 @@\n-  if (!phase->eqv(this, this->Identity(phase))) {\n+  if (this != Identity(phase)) {\n@@ -2824,1 +2824,1 @@\n-        if (prev_val != NULL && phase->eqv(prev_val, val)) {\n+        if (prev_val != NULL && prev_val == val) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,5 +90,5 @@\n-    int   op1 = mul1->Opcode();\n-    if( phase->eqv( mul1, this ) || phase->eqv( in(2), this ) ||\n-        ( ( op1 == mul_opcode() || op1 == add_opcode() ) &&\n-          ( phase->eqv( mul1->in(1), this ) || phase->eqv( mul1->in(2), this ) ||\n-            phase->eqv( mul1->in(1), mul1 ) || phase->eqv( mul1->in(2), mul1 ) ) ) )\n+    int op1 = mul1->Opcode();\n+    if ((mul1 == this) || (in(2) == this) ||\n+        ((op1 == mul_opcode() || op1 == add_opcode()) &&\n+         ((mul1->in(1) == this) || (mul1->in(2) == this) ||\n+          (mul1->in(1) == mul1) || (mul1->in(2) == mul1)))) {\n@@ -96,0 +96,1 @@\n+    }\n@@ -451,1 +452,3 @@\n-  if (phase->eqv(in(1), in(2))) return in(1);\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n@@ -573,1 +576,3 @@\n-  if (phase->eqv(in(1), in(2))) return in(1);\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -285,5 +285,0 @@\n-  \/\/ Return whether two Nodes are equivalent.\n-  \/\/ Must not be recursive, since the recursive version is built from this.\n-  \/\/ For pessimistic optimizations this is simply pointer equivalence.\n-  bool eqv(const Node* n1, const Node* n2) const { return n1 == n2; }\n-\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,2 +64,2 @@\n-  if( in(1)->Opcode() == Op_AddI ) {\n-    if( phase->eqv(in(1)->in(2),in(2)) )\n+  if (in(1)->Opcode() == Op_AddI) {\n+    if (in(1)->in(2) == in(2)) {\n@@ -67,1 +67,2 @@\n-    if (phase->eqv(in(1)->in(1),in(2)))\n+    }\n+    if (in(1)->in(1) == in(2)) {\n@@ -69,0 +70,1 @@\n+    }\n@@ -75,2 +77,1 @@\n-    if( in(1)->in(2)->Opcode() == Op_Opaque2 &&\n-        phase->eqv(in(1)->in(2)->in(1),in(2)) )\n+    if (in(1)->in(2)->Opcode() == Op_Opaque2 && in(1)->in(2)->in(1) == in(2)) {\n@@ -78,0 +79,1 @@\n+    }\n@@ -157,4 +159,4 @@\n-  if( phase->eqv( in1, this ) || phase->eqv( in2, this ) ||\n-      ( ( op1 == Op_AddI || op1 == Op_SubI ) &&\n-        ( phase->eqv( in1->in(1), this ) || phase->eqv( in1->in(2), this ) ||\n-          phase->eqv( in1->in(1), in1  ) || phase->eqv( in1->in(2), in1 ) ) ) )\n+  if ((in1 == this) || (in2 == this) ||\n+      ((op1 == Op_AddI || op1 == Op_SubI) &&\n+       ((in1->in(1) == this) || (in1->in(2) == this) ||\n+        (in1->in(1) == in1)  || (in1->in(2) == in1)))) {\n@@ -162,0 +164,1 @@\n+  }\n@@ -203,3 +206,3 @@\n-  if( ( op2 == Op_AddI || op2 == Op_SubI ) &&\n-      ( phase->eqv( in2->in(1), this ) || phase->eqv( in2->in(2), this ) ||\n-        phase->eqv( in2->in(1), in2  ) || phase->eqv( in2->in(2), in2  ) ) )\n+  if ((op2 == Op_AddI || op2 == Op_SubI) &&\n+      ((in2->in(1) == this) || (in2->in(2) == this) ||\n+       (in2->in(1) == in2)  || (in2->in(2) == in2))) {\n@@ -207,0 +210,1 @@\n+  }\n@@ -210,3 +214,3 @@\n-  if( op2 == Op_AddI &&\n-      phase->eqv( in1, in2->in(1) ) )\n-    return new SubINode( phase->intcon(0),in2->in(2));\n+  if (op2 == Op_AddI && in1 == in2->in(1)) {\n+    return new SubINode(phase->intcon(0), in2->in(2));\n+  }\n@@ -214,3 +218,3 @@\n-  if( op1 == Op_SubI &&\n-      phase->eqv( in1->in(1), in2 ) )\n-    return new SubINode( phase->intcon(0),in1->in(2));\n+  if (op1 == Op_SubI && in1->in(1) == in2) {\n+    return new SubINode(phase->intcon(0), in1->in(2));\n+  }\n@@ -218,3 +222,3 @@\n-  if( op2 == Op_AddI &&\n-      phase->eqv( in1, in2->in(2) ) )\n-    return new SubINode( phase->intcon(0),in2->in(1));\n+  if (op2 == Op_AddI && in1 == in2->in(2)) {\n+    return new SubINode(phase->intcon(0), in2->in(1));\n+  }\n@@ -299,4 +303,4 @@\n-  if( phase->eqv( in1, this ) || phase->eqv( in2, this ) ||\n-      ( ( op1 == Op_AddL || op1 == Op_SubL ) &&\n-        ( phase->eqv( in1->in(1), this ) || phase->eqv( in1->in(2), this ) ||\n-          phase->eqv( in1->in(1), in1  ) || phase->eqv( in1->in(2), in1  ) ) ) )\n+  if ((in1 == this) || (in2 == this) ||\n+      ((op1 == Op_AddL || op1 == Op_SubL) &&\n+       ((in1->in(1) == this) || (in1->in(2) == this) ||\n+        (in1->in(1) == in1)  || (in1->in(2) == in1)))) {\n@@ -304,0 +308,1 @@\n+  }\n@@ -343,3 +348,3 @@\n-  if( ( op2 == Op_AddL || op2 == Op_SubL ) &&\n-      ( phase->eqv( in2->in(1), this ) || phase->eqv( in2->in(2), this ) ||\n-        phase->eqv( in2->in(1), in2  ) || phase->eqv( in2->in(2), in2  ) ) )\n+  if ((op2 == Op_AddL || op2 == Op_SubL) &&\n+      ((in2->in(1) == this) || (in2->in(2) == this) ||\n+       (in2->in(1) == in2)  || (in2->in(2) == in2))) {\n@@ -347,0 +352,1 @@\n+  }\n@@ -350,3 +356,3 @@\n-  if( op2 == Op_AddL &&\n-      phase->eqv( in1, in2->in(1) ) )\n-    return new SubLNode( phase->makecon(TypeLong::ZERO), in2->in(2));\n+  if (op2 == Op_AddL && in1 == in2->in(1)) {\n+    return new SubLNode(phase->makecon(TypeLong::ZERO), in2->in(2));\n+  }\n@@ -354,3 +360,3 @@\n-  if( op2 == Op_AddL &&\n-      phase->eqv( in1, in2->in(2) ) )\n-    return new SubLNode( phase->makecon(TypeLong::ZERO),in2->in(1));\n+  if (op2 == Op_AddL && in1 == in2->in(2)) {\n+    return new SubLNode(phase->makecon(TypeLong::ZERO), in2->in(1));\n+  }\n@@ -424,2 +430,2 @@\n-  if( (t1->is_finite() && t2->is_finite()) ) {\n-    if( phase->eqv(in1, in2) ) return add_id();\n+  if (t1->is_finite() && t2->is_finite() && in1 == in2) {\n+    return add_id();\n@@ -448,1 +454,2 @@\n-  if( IdealizedNumerics && !phase->C->method()->is_strict() ) {\n+  if (IdealizedNumerics && !phase->C->method()->is_strict() &&\n+      in(2)->is_Add() && in(1) == in(2)->in(1)) {\n@@ -450,3 +457,1 @@\n-    if( in(2)->is_Add() &&\n-        phase->eqv(in(1),in(2)->in(1) ) )\n-      return new SubFNode( phase->makecon(TypeF::ZERO),in(2)->in(2));\n+    return new SubFNode(phase->makecon(TypeF::ZERO), in(2)->in(2));\n@@ -491,1 +496,2 @@\n-  if( IdealizedNumerics && !phase->C->method()->is_strict() ) {\n+  if (IdealizedNumerics && !phase->C->method()->is_strict() &&\n+      in(2)->is_Add() && in(1) == in(2)->in(1)) {\n@@ -493,3 +499,1 @@\n-    if( in(2)->is_Add() &&\n-        phase->eqv(in(1),in(2)->in(1) ) )\n-      return new SubDNode( phase->makecon(TypeD::ZERO),in(2)->in(2));\n+    return new SubDNode(phase->makecon(TypeD::ZERO), in(2)->in(2));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":48,"deletions":44,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -3292,12 +3292,7 @@\n-          assert(o != NULL, \"must be constant\");\n-          ciInstanceKlass* ik = o->as_instance()->java_lang_Class_klass()->as_instance_klass();\n-          BasicType basic_elem_type;\n-          if (ik->is_inlinetype() && this->offset() == ik->as_inline_klass()->default_value_offset()) {\n-            \/\/ Special hidden field that contains the oop of the default inline type\n-            basic_elem_type = T_INLINE_TYPE;\n-           _is_ptr_to_narrowoop = UseCompressedOops;\n-          } else {\n-            ciField* field = ik->get_field_by_offset(this->offset(), true);\n-            if (field != NULL) {\n-              BasicType basic_elem_type = field->layout_type();\n-              _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+          ciField* field = NULL;\n+          if (const_oop() != NULL) {\n+            ciInstanceKlass* k = const_oop()->as_instance()->java_lang_Class_klass()->as_instance_klass();\n+            if (k->is_inlinetype() && this->offset() == k->as_inline_klass()->default_value_offset()) {\n+              \/\/ Special hidden field that contains the oop of the default inline type\n+              \/\/ basic_elem_type = T_INLINE_TYPE;\n+             _is_ptr_to_narrowoop = UseCompressedOops;\n@@ -3305,2 +3300,8 @@\n-              \/\/ unsafe access\n-              _is_ptr_to_narrowoop = UseCompressedOops;\n+              field = k->get_field_by_offset(this->offset(), true);\n+              if (field != NULL) {\n+                BasicType basic_elem_type = field->layout_type();\n+                _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+              } else {\n+                \/\/ unsafe access\n+                _is_ptr_to_narrowoop = UseCompressedOops;\n+              }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/classListParser.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"classfile\/lambdaFormInvokers.hpp\"\n@@ -3513,0 +3513,18 @@\n+JVM_ENTRY(jboolean, JVM_ReferenceRefersTo(JNIEnv* env, jobject ref, jobject o))\n+  JVMWrapper(\"JVM_ReferenceRefersTo\");\n+  oop ref_oop = JNIHandles::resolve_non_null(ref);\n+  oop referent = java_lang_ref_Reference::weak_referent_no_keepalive(ref_oop);\n+  return referent == JNIHandles::resolve(o);\n+JVM_END\n+\n+\n+\/\/ java.lang.ref.PhantomReference \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\n+JVM_ENTRY(jboolean, JVM_PhantomReferenceRefersTo(JNIEnv* env, jobject ref, jobject o))\n+  JVMWrapper(\"JVM_PhantomReferenceRefersTo\");\n+  oop ref_oop = JNIHandles::resolve_non_null(ref);\n+  oop referent = java_lang_ref_Reference::phantom_referent_no_keepalive(ref_oop);\n+  return referent == JNIHandles::resolve(o);\n+JVM_END\n+\n@@ -3957,1 +3975,1 @@\n-    w.stream()->print_cr(\"%s %s\", LambdaFormInvokers::lambda_form_invoker_tag(), c_line);\n+    w.stream()->print_cr(\"%s %s\", LAMBDA_FORM_TAG, c_line);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1656,11 +1656,3 @@\n-  if (eb.barrier_active()) {\n-    if (java_thread->frames_to_pop_failed_realloc() > 0) {\n-      \/\/ VM is in the process of popping the top frame because it has scalar replaced objects which\n-      \/\/ could not be reallocated on the heap.\n-      \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n-    if (!eb.deoptimize_objects(1)) {\n-      \/\/ Reallocation of scalar replaced objects failed -> return with error\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n+  if (!eb.deoptimize_objects(1)) {\n+    \/\/ Reallocation of scalar replaced objects failed -> return with error\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -633,6 +633,3 @@\n-\/\/ Revert optimizations based on escape analysis if this is an access to a local object\n-bool VM_GetOrSetLocal::deoptimize_objects(javaVFrame* jvf) {\n-#if COMPILER2_OR_JVMCI\n-  assert(_type == T_OBJECT, \"EscapeBarrier should not be active if _type != T_OBJECT\");\n-  if (_depth < _thread->frames_to_pop_failed_realloc()) {\n-    \/\/ cannot access frame with failed reallocations\n+bool VM_GetOrSetLocal::doit_prologue() {\n+  if (!_eb.deoptimize_objects(_depth, _depth)) {\n+    \/\/ The target frame is affected by a reallocation failure.\n@@ -642,43 +639,0 @@\n-  if (can_be_deoptimized(jvf)) {\n-    compiledVFrame* cf = compiledVFrame::cast(jvf);\n-    if (cf->has_ea_local_in_scope() && !_eb.deoptimize_objects(cf->fr().id())) {\n-      \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n-      _result = JVMTI_ERROR_OUT_OF_MEMORY;\n-      return false;\n-    }\n-  }\n-\n-  \/\/ With this access the object could escape the thread changing its escape state from ArgEscape,\n-  \/\/ to GlobalEscape so we must deoptimize callers which could have optimized on the escape state.\n-  vframe* vf = jvf;\n-  do {\n-    \/\/ move to next physical frame\n-    while(!vf->is_top()) {\n-      vf = vf->sender();\n-    }\n-    vf = vf->sender();\n-\n-    if (vf != NULL && vf->is_compiled_frame()) {\n-      compiledVFrame* cvf = compiledVFrame::cast(vf);\n-      \/\/ Deoptimize objects if arg escape is being passed down the stack.\n-      \/\/ Note that deoptimizing the frame is not enough because objects need to be relocked\n-      if (cvf->arg_escape() && !_eb.deoptimize_objects(cvf->fr().id())) {\n-        \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n-        _result = JVMTI_ERROR_OUT_OF_MEMORY;\n-        return false;\n-      }\n-    }\n-  } while(vf != NULL && !vf->is_entry_frame());\n-#endif \/\/ COMPILER2_OR_JVMCI\n-  return true;\n-}\n-\n-bool VM_GetOrSetLocal::doit_prologue() {\n-  if (_eb.barrier_active()) {\n-    _jvf = get_java_vframe();\n-    NULL_CHECK(_jvf, false);\n-\n-    if (!deoptimize_objects(_jvf)) {\n-      return false;\n-    }\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":49,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1251,1 +1251,1 @@\n-  JVMFlag::Error result = JVMFlagAccess::set<T, type_enum>(flag, value, JVMFlag::INTERNAL);\n+  JVMFlag::Error result = JVMFlagAccess::set<T, type_enum>(flag, value, JVMFlagOrigin::INTERNAL);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-static bool set_bool_flag(JVMFlag* flag, bool value, JVMFlag::Flags origin) {\n+static bool set_bool_flag(JVMFlag* flag, bool value, JVMFlagOrigin origin) {\n@@ -888,1 +888,1 @@\n-static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {\n+static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n@@ -902,1 +902,1 @@\n-static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {\n+static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n@@ -955,1 +955,1 @@\n-static bool set_string_flag(JVMFlag* flag, const char* value, JVMFlag::Flags origin) {\n+static bool set_string_flag(JVMFlag* flag, const char* value, JVMFlagOrigin origin) {\n@@ -962,1 +962,1 @@\n-static bool append_to_string_flag(JVMFlag* flag, const char* new_value, JVMFlag::Flags origin) {\n+static bool append_to_string_flag(JVMFlag* flag, const char* new_value, JVMFlagOrigin origin) {\n@@ -1063,1 +1063,1 @@\n-bool Arguments::parse_argument(const char* arg, JVMFlag::Flags origin) {\n+bool Arguments::parse_argument(const char* arg, JVMFlagOrigin origin) {\n@@ -1278,1 +1278,1 @@\n-                                 JVMFlag::Flags origin) {\n+                                 JVMFlagOrigin origin) {\n@@ -1407,1 +1407,1 @@\n-        result &= process_argument(token, ignore_unrecognized, JVMFlag::CONFIG_FILE);\n+        result &= process_argument(token, ignore_unrecognized, JVMFlagOrigin::CONFIG_FILE);\n@@ -1425,1 +1425,1 @@\n-    result &= process_argument(token, ignore_unrecognized, JVMFlag::CONFIG_FILE);\n+    result &= process_argument(token, ignore_unrecognized, JVMFlagOrigin::CONFIG_FILE);\n@@ -1662,4 +1662,0 @@\n-\n-  if (SurvivorAlignmentInBytes == 0) {\n-    SurvivorAlignmentInBytes = ObjectAlignmentInBytes;\n-  }\n@@ -2305,1 +2301,1 @@\n-  jint result = parse_each_vm_init_arg(vm_options_args, &patch_mod_javabase, JVMFlag::JIMAGE_RESOURCE);\n+  jint result = parse_each_vm_init_arg(vm_options_args, &patch_mod_javabase, JVMFlagOrigin::JIMAGE_RESOURCE);\n@@ -2312,1 +2308,1 @@\n-  result = parse_each_vm_init_arg(java_tool_options_args, &patch_mod_javabase, JVMFlag::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_tool_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2318,1 +2314,1 @@\n-  result = parse_each_vm_init_arg(cmd_line_args, &patch_mod_javabase, JVMFlag::COMMAND_LINE);\n+  result = parse_each_vm_init_arg(cmd_line_args, &patch_mod_javabase, JVMFlagOrigin::COMMAND_LINE);\n@@ -2325,1 +2321,1 @@\n-  result = parse_each_vm_init_arg(java_options_args, &patch_mod_javabase, JVMFlag::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2469,1 +2465,1 @@\n-jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlag::Flags origin) {\n+jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlagOrigin origin) {\n@@ -3253,0 +3249,5 @@\n+#ifdef ZERO\n+  \/\/ Zero always runs in interpreted mode\n+  set_mode_flags(_int);\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -242,5 +242,0 @@\n-      \/\/ Make sure the deoptee frame gets processed after a potential safepoint during\n-      \/\/ object reallocation. This is necessary because (a) deoptee_thread can be\n-      \/\/ different from the current thread and (b) the deoptee frame does not need to be\n-      \/\/ the top frame.\n-      StackWatermarkSet::finish_processing(deoptee_thread, NULL \/* context *\/, StackWatermarkKind::gc);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2414,5 +2414,0 @@\n-  product(intx, SurvivorAlignmentInBytes, 0, EXPERIMENTAL,                  \\\n-           \"Default survivor space alignment in bytes\")                     \\\n-           range(8, 256)                                                    \\\n-           constraint(SurvivorAlignmentInBytesConstraintFunc,AfterErgo)     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1968,2 +1968,2 @@\n-  declare_toplevel_type(BreakpointInfo)                                   \\\n-  declare_toplevel_type(BreakpointInfo*)                                  \\\n+  JVMTI_ONLY(declare_toplevel_type(BreakpointInfo))                       \\\n+  JVMTI_ONLY(declare_toplevel_type(BreakpointInfo*))                      \\\n@@ -2606,9 +2606,9 @@\n-  declare_constant(JVMFlag::DEFAULT)                                      \\\n-  declare_constant(JVMFlag::COMMAND_LINE)                                 \\\n-  declare_constant(JVMFlag::ENVIRON_VAR)                                  \\\n-  declare_constant(JVMFlag::CONFIG_FILE)                                  \\\n-  declare_constant(JVMFlag::MANAGEMENT)                                   \\\n-  declare_constant(JVMFlag::ERGONOMIC)                                    \\\n-  declare_constant(JVMFlag::ATTACH_ON_DEMAND)                             \\\n-  declare_constant(JVMFlag::INTERNAL)                                     \\\n-  declare_constant(JVMFlag::JIMAGE_RESOURCE)                              \\\n+  declare_constant(JVMFlagOrigin::DEFAULT)                                \\\n+  declare_constant(JVMFlagOrigin::COMMAND_LINE)                           \\\n+  declare_constant(JVMFlagOrigin::ENVIRON_VAR)                            \\\n+  declare_constant(JVMFlagOrigin::CONFIG_FILE)                            \\\n+  declare_constant(JVMFlagOrigin::MANAGEMENT)                             \\\n+  declare_constant(JVMFlagOrigin::ERGONOMIC)                              \\\n+  declare_constant(JVMFlagOrigin::ATTACH_ON_DEMAND)                       \\\n+  declare_constant(JVMFlagOrigin::INTERNAL)                               \\\n+  declare_constant(JVMFlagOrigin::JIMAGE_RESOURCE)                        \\\n@@ -2616,1 +2616,1 @@\n-  declare_constant(JVMFlag::ORIG_COMMAND_LINE)\n+  declare_constant(JVMFlag::WAS_SET_ON_COMMAND_LINE)\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -114,0 +114,3 @@\n+#ifdef LINUX\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PerfMapDCmd>(full_export, true, false));\n+#endif \/\/ LINUX\n@@ -279,1 +282,1 @@\n-  int ret = WriteableFlags::set_flag(_flag.value(), val, JVMFlag::MANAGEMENT, err_msg);\n+  int ret = WriteableFlags::set_flag(_flag.value(), val, JVMFlagOrigin::MANAGEMENT, err_msg);\n@@ -304,0 +307,1 @@\n+#if INCLUDE_JVMTI\n@@ -363,0 +367,1 @@\n+#endif \/\/ INCLUDE_JVMTI\n@@ -896,0 +901,6 @@\n+#ifdef LINUX\n+void PerfMapDCmd::execute(DCmdSource source, TRAPS) {\n+  CodeCache::write_perf_map();\n+}\n+#endif \/\/ LINUX\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -606,0 +606,23 @@\n+#ifdef LINUX\n+class PerfMapDCmd : public DCmd {\n+public:\n+  PerfMapDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static const char* name() {\n+    return \"Compiler.perfmap\";\n+  }\n+  static const char* description() {\n+    return \"Write map file for Linux perf tool.\";\n+  }\n+  static const char* impact() {\n+    return \"Low\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  static int num_arguments() { return 0; }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+#endif \/\/ LINUX\n+\n@@ -627,1 +650,0 @@\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -449,0 +449,15 @@\n+\/\/ In many places we've added C-style casts to silence compiler\n+\/\/ warnings, for example when truncating a size_t to an int when we\n+\/\/ know the size_t is a small struct. Such casts are risky because\n+\/\/ they effectively disable useful compiler warnings. We can make our\n+\/\/ lives safer with this function, which ensures that any cast is\n+\/\/ reversible without loss of information. It doesn't check\n+\/\/ everything: it isn't intended to make sure that pointer types are\n+\/\/ compatible, for example.\n+template <typename T2, typename T1>\n+T2 checked_cast(T1 thing) {\n+  T2 result = static_cast<T2>(thing);\n+  assert(static_cast<T1>(result) == thing, \"must be\");\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import sun.invoke.util.VerifyAccess;\n@@ -69,1 +70,0 @@\n-    private static final String DESCR_SET_IMPL_METHOD = \"(Ljava\/lang\/invoke\/MethodHandle;)V\";\n@@ -172,2 +172,2 @@\n-        useImplMethodHandle = !implClass.getPackageName().equals(implInfo.getDeclaringClass().getPackageName())\n-                                && !Modifier.isPublic(implInfo.getModifiers());\n+        useImplMethodHandle = !Modifier.isPublic(implInfo.getModifiers()) &&\n+                              !VerifyAccess.isSamePackage(implClass, implInfo.getDeclaringClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import static java.lang.invoke.LambdaForm.BasicType.V_TYPE;\n@@ -4771,13 +4772,10 @@\n-        if (reorder.length == oldType.parameterCount()) {\n-            int limit = newType.parameterCount();\n-            boolean bad = false;\n-            for (int j = 0; j < reorder.length; j++) {\n-                int i = reorder[j];\n-                if (i < 0 || i >= limit) {\n-                    bad = true; break;\n-                }\n-                Class<?> src = newType.parameterType(i);\n-                Class<?> dst = oldType.parameterType(j);\n-                if (src != dst)\n-                    throw newIllegalArgumentException(\"parameter types do not match after reorder\",\n-                            oldType, newType);\n+        if (reorder.length != oldType.parameterCount())\n+            throw newIllegalArgumentException(\"old type parameter count and reorder array length do not match\",\n+                    oldType, Arrays.toString(reorder));\n+\n+        int limit = newType.parameterCount();\n+        for (int j = 0; j < reorder.length; j++) {\n+            int i = reorder[j];\n+            if (i < 0 || i >= limit) {\n+                throw newIllegalArgumentException(\"index is out of bounds for new type\",\n+                        i, newType);\n@@ -4785,1 +4783,5 @@\n-            if (!bad)  return true;\n+            Class<?> src = newType.parameterType(i);\n+            Class<?> dst = oldType.parameterType(j);\n+            if (src != dst)\n+                throw newIllegalArgumentException(\"parameter types do not match after reorder\",\n+                        oldType, newType);\n@@ -4787,1 +4789,1 @@\n-        throw newIllegalArgumentException(\"bad reorder array: \"+Arrays.toString(reorder));\n+        return true;\n@@ -5242,0 +5244,22 @@\n+    \/**\n+     * Drop the return value of the target handle (if any).\n+     * The returned method handle will have a {@code void} return type.\n+     *\n+     * @param target the method handle to adapt\n+     * @return a possibly adapted method handle\n+     * @throws NullPointerException if {@code target} is null\n+     * @since 16\n+     *\/\n+    public static MethodHandle dropReturn(MethodHandle target) {\n+        Objects.requireNonNull(target);\n+        MethodType oldType = target.type();\n+        Class<?> oldReturnType = oldType.returnType();\n+        if (oldReturnType == void.class)\n+            return target;\n+        MethodType newType = oldType.changeReturnType(void.class);\n+        BoundMethodHandle result = target.rebind();\n+        LambdaForm lform = result.editor().filterReturnForm(V_TYPE, true);\n+        result = result.copyWith(newType, lform);\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":39,"deletions":15,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,8 @@\n+    \/* Override the implementation of Reference.refersTo.\n+     * Phantom references are weaker than finalization, so the referent\n+     * access needs to be handled differently for garbage collectors that\n+     * do reference processing concurrently.\n+     *\/\n+    @Override\n+    native final boolean refersTo0(Object o);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -328,0 +328,8 @@\n+     * @apiNote\n+     * This method returns a strong reference to the referent. This may cause\n+     * the garbage collector to treat it as strongly reachable until some later\n+     * collection cycle.  The {@link #refersTo(Object) refersTo} method can be\n+     * used to avoid such strengthening when testing whether some object is\n+     * the referent of a reference object; that is, use {@code ref.refersTo(obj)}\n+     * rather than {@code ref.get() == obj}.\n+     *\n@@ -330,0 +338,1 @@\n+     * @see refersTo\n@@ -336,0 +345,17 @@\n+    \/**\n+     * Tests if the referent of this reference object is {@code obj}.\n+     * Using a {@code null} {@code obj} returns {@code true} if the\n+     * reference object has been cleared.\n+     *\n+     * @param  obj the object to compare with this reference object's referent\n+     * @return {@code true} if {@code obj} is the referent of this reference object\n+     * @since 16\n+     *\/\n+    public final boolean refersTo(T obj) {\n+        return refersTo0(obj);\n+    }\n+\n+    \/* Implementation of refersTo(), overridden for phantom references.\n+     *\/\n+    native boolean refersTo0(Object o);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-        jdk.incubator.jpackage;\n+        jdk.jpackage;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+import com.sun.source.doctree.DeprecatedTree;\n@@ -99,0 +100,6 @@\n+import com.sun.source.doctree.ProvidesTree;\n+import com.sun.source.doctree.ReturnTree;\n+import com.sun.source.doctree.SeeTree;\n+import com.sun.source.doctree.SerialDataTree;\n+import com.sun.source.doctree.SerialFieldTree;\n+import com.sun.source.doctree.SerialTree;\n@@ -101,0 +108,1 @@\n+import com.sun.source.doctree.ThrowsTree;\n@@ -102,0 +110,1 @@\n+import com.sun.source.doctree.UsesTree;\n@@ -948,2 +957,2 @@\n-    public List<? extends DocTree> getSerialDataTrees(ExecutableElement member) {\n-        return getBlockTags(member, SERIAL_DATA);\n+    public List<? extends SerialDataTree> getSerialDataTrees(ExecutableElement member) {\n+        return getBlockTags(member, SERIAL_DATA, SerialDataTree.class);\n@@ -2594,0 +2603,8 @@\n+    public <T extends DocTree> List<? extends T> getBlockTags(Element element, Predicate<DocTree> filter, Class<T> tClass) {\n+        return getBlockTags(element).stream()\n+                .filter(t -> t.getKind() != ERRONEOUS)\n+                .filter(filter)\n+                .map(t -> tClass.cast(t))\n+                .collect(Collectors.toList());\n+    }\n+\n@@ -2598,0 +2615,4 @@\n+    public <T extends DocTree> List<? extends T> getBlockTags(Element element, DocTree.Kind kind, Class<T> tClass) {\n+        return getBlockTags(element, t -> t.getKind() == kind, tClass);\n+    }\n+\n@@ -2783,2 +2804,2 @@\n-    public List<? extends DocTree> getDeprecatedTrees(Element element) {\n-        return getBlockTags(element, DEPRECATED);\n+    public List<? extends DeprecatedTree> getDeprecatedTrees(Element element) {\n+        return getBlockTags(element, DEPRECATED, DeprecatedTree.class);\n@@ -2787,2 +2808,2 @@\n-    public List<? extends DocTree> getProvidesTrees(Element element) {\n-        return getBlockTags(element, PROVIDES);\n+    public List<? extends ProvidesTree> getProvidesTrees(Element element) {\n+        return getBlockTags(element, PROVIDES, ProvidesTree.class);\n@@ -2791,2 +2812,2 @@\n-    public List<? extends DocTree> getSeeTrees(Element element) {\n-        return getBlockTags(element, SEE);\n+    public List<? extends SeeTree> getSeeTrees(Element element) {\n+        return getBlockTags(element, SEE, SeeTree.class);\n@@ -2795,2 +2816,2 @@\n-    public List<? extends DocTree> getSerialTrees(Element element) {\n-        return getBlockTags(element, SERIAL);\n+    public List<? extends SerialTree> getSerialTrees(Element element) {\n+        return getBlockTags(element, SERIAL, SerialTree.class);\n@@ -2799,2 +2820,2 @@\n-    public List<? extends DocTree> getSerialFieldTrees(VariableElement field) {\n-        return getBlockTags(field, DocTree.Kind.SERIAL_FIELD);\n+    public List<? extends SerialFieldTree> getSerialFieldTrees(VariableElement field) {\n+        return getBlockTags(field, DocTree.Kind.SERIAL_FIELD, SerialFieldTree.class);\n@@ -2803,2 +2824,4 @@\n-    public List<? extends DocTree> getThrowsTrees(Element element) {\n-        return getBlockTags(element, DocTree.Kind.EXCEPTION, DocTree.Kind.THROWS);\n+    public List<? extends ThrowsTree> getThrowsTrees(Element element) {\n+        return getBlockTags(element,\n+                t -> switch (t.getKind()) { case EXCEPTION, THROWS -> true; default -> false; },\n+                ThrowsTree.class);\n@@ -2816,8 +2839,3 @@\n-        List<ParamTree> out = new ArrayList<>();\n-        for (DocTree dt : getBlockTags(element, PARAM)) {\n-            ParamTree pt = (ParamTree) dt;\n-            if (pt.isTypeParameter() == isTypeParameters) {\n-                out.add(pt);\n-            }\n-        }\n-        return out;\n+        return getBlockTags(element,\n+                t -> t.getKind() == PARAM && ((ParamTree) t).isTypeParameter() == isTypeParameters,\n+                ParamTree.class);\n@@ -2826,2 +2844,2 @@\n-    public  List<? extends DocTree> getReturnTrees(Element element) {\n-        return new ArrayList<>(getBlockTags(element, RETURN));\n+    public  List<? extends ReturnTree> getReturnTrees(Element element) {\n+        return new ArrayList<>(getBlockTags(element, RETURN, ReturnTree.class));\n@@ -2830,2 +2848,2 @@\n-    public List<? extends DocTree> getUsesTrees(Element element) {\n-        return getBlockTags(element, USES);\n+    public List<? extends UsesTree> getUsesTrees(Element element) {\n+        return getBlockTags(element, USES, UsesTree.class);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":44,"deletions":26,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -702,1 +702,1 @@\n-    error = FUNC_PTR(gdata->jvmti,GetMethodDeclaringClass)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,GetMethodDeclaringClass)\n@@ -707,1 +707,1 @@\n-\/* Returns a local ref to the declaring class for a method, or NULL. *\/\n+\/* Returns the start and end locations of the specified method. *\/\n@@ -730,1 +730,1 @@\n-    error = FUNC_PTR(gdata->jvmti,GetMethodName)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,GetMethodName)\n@@ -965,10 +965,0 @@\n-jboolean\n-canSuspendResumeThreadLists(void)\n-{\n-    jvmtiError error;\n-    jvmtiCapabilities cap;\n-\n-    error = jvmtiGetCapabilities(&cap);\n-    return (error == JVMTI_ERROR_NONE && cap.can_suspend);\n-}\n-\n@@ -1022,1 +1012,1 @@\n-        error = FUNC_PTR(gdata->jvmti,RawMonitorEnter)\n+        error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorEnter)\n@@ -1041,1 +1031,1 @@\n-    error = FUNC_PTR(gdata->jvmti,RawMonitorExit)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorExit)\n@@ -1053,1 +1043,1 @@\n-    error = FUNC_PTR(gdata->jvmti,RawMonitorWait)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorWait)\n@@ -1098,1 +1088,1 @@\n-    error = FUNC_PTR(gdata->jvmti,RawMonitorWait)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorWait)\n@@ -1116,1 +1106,1 @@\n-    error = FUNC_PTR(gdata->jvmti,RawMonitorNotify)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorNotify)\n@@ -1129,1 +1119,1 @@\n-    error = FUNC_PTR(gdata->jvmti,RawMonitorNotifyAll)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorNotifyAll)\n@@ -1143,1 +1133,1 @@\n-    error = FUNC_PTR(gdata->jvmti,CreateRawMonitor)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,CreateRawMonitor)\n@@ -1156,1 +1146,1 @@\n-    error = FUNC_PTR(gdata->jvmti,DestroyRawMonitor)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,DestroyRawMonitor)\n@@ -1215,1 +1205,1 @@\n-    error = FUNC_PTR(gdata->jvmti,GetClassSignature)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,GetClassSignature)\n@@ -1787,1 +1777,1 @@\n-    error = FUNC_PTR(gdata->jvmti,Allocate)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,Allocate)\n@@ -1802,1 +1792,1 @@\n-    error = FUNC_PTR(gdata->jvmti,Deallocate)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,Deallocate)\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":14,"deletions":24,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -639,1 +639,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -652,1 +651,1 @@\n-            throw new UnsupportedOperationException(\"can't get field offset on a record (preview): \" + f);\n+            throw new UnsupportedOperationException(\"can't get field offset on a record class: \" + f);\n@@ -675,1 +674,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -688,1 +686,1 @@\n-            throw new UnsupportedOperationException(\"can't get field offset on a record (preview): \" + f);\n+            throw new UnsupportedOperationException(\"can't get field offset on a record class: \" + f);\n@@ -704,1 +702,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -717,1 +714,1 @@\n-            throw new UnsupportedOperationException(\"can't get base address on a record (preview): \" + f);\n+            throw new UnsupportedOperationException(\"can't get base address on a record class: \" + f);\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -220,1 +220,0 @@\n-  -gc\/survivorAlignment\/TestPromotionFromSurvivorToTenuredAfterMinorGC.java \\\n@@ -348,0 +347,1 @@\n+ -runtime\/cds\/appcds\/javaldr\/ExceptionDuringDumpAtObjectsInitPhase.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n- * @requires ((vm.compMode == \"Xmixed\") & vm.jvmci)\n+ * @requires ((vm.compMode == \"Xmixed\") & vm.graal.enabled)\n@@ -118,0 +118,1 @@\n+import sun.hotspot.gc.GC;\n@@ -268,0 +269,1 @@\n+        public final boolean ZGCIsSelected;\n@@ -280,0 +282,2 @@\n+            val = testCaseBaseTargetClass.getValue(testCaseBaseTargetClass.fieldByName(\"ZGCIsSelected\"));\n+            ZGCIsSelected = ((PrimitiveValue) val).booleanValue();\n@@ -745,4 +749,5 @@\n-    public static final boolean UseJVMCICompiler     = unbox(WB.getBooleanVMFlag(\"UseJVMCICompiler\"), false); \/\/ read by debugger\n-    public static final boolean DoEscapeAnalysis     = unbox(WB.getBooleanVMFlag(\"DoEscapeAnalysis\"), UseJVMCICompiler);\n-    public static final boolean EliminateAllocations = unbox(WB.getBooleanVMFlag(\"EliminateAllocations\"), UseJVMCICompiler); \/\/ read by debugger\n-    public static final boolean DeoptimizeObjectsALot   = WB.getBooleanVMFlag(\"DeoptimizeObjectsALot\");                      \/\/ read by debugger\n+    \/\/ Some of the fields are only read by the debugger\n+    public static final boolean UseJVMCICompiler = unbox(WB.getBooleanVMFlag(\"UseJVMCICompiler\"), false);\n+    public static final boolean DoEscapeAnalysis = unbox(WB.getBooleanVMFlag(\"DoEscapeAnalysis\"), UseJVMCICompiler);\n+    public static final boolean EliminateAllocations = unbox(WB.getBooleanVMFlag(\"EliminateAllocations\"), UseJVMCICompiler);\n+    public static final boolean DeoptimizeObjectsALot = WB.getBooleanVMFlag(\"DeoptimizeObjectsALot\");\n@@ -751,0 +756,1 @@\n+    public static final boolean ZGCIsSelected = GC.Z.isSelected();\n@@ -1050,1 +1056,1 @@\n-            this.array = new long[size];\n+            this.array = size > 0 ? new long[size] : null;\n@@ -1060,1 +1066,1 @@\n-        while(size > 0) {\n+        while(true) {\n@@ -1066,0 +1072,1 @@\n+                if (size == 0) break;\n@@ -2574,4 +2581,2 @@\n-        Asserts.assertTrue(coughtOom || !env.targetVMOptions.EliminateAllocations,\n-                           \"PopFrame should have triggered an OOM exception in target\");\n-        String expectedTopFrame =\n-                env.targetVMOptions.EliminateAllocations ? \"dontinline_consume_all_memory_brkpt\" : \"dontinline_testMethod\";\n+        Asserts.assertTrue(coughtOom, \"PopFrame should have triggered an OOM exception in target\");\n+        String expectedTopFrame = \"dontinline_consume_all_memory_brkpt\";\n@@ -2586,1 +2591,6 @@\n-        return super.shouldSkip() || env.targetVMOptions.DeoptimizeObjectsALot || env.targetVMOptions.UseJVMCICompiler;\n+        return super.shouldSkip() ||\n+                !env.targetVMOptions.EliminateAllocations ||\n+                \/\/ With ZGC the OOME is not always thrown as expected\n+                env.targetVMOptions.ZGCIsSelected ||\n+                env.targetVMOptions.DeoptimizeObjectsALot ||\n+                env.targetVMOptions.UseJVMCICompiler;\n@@ -2626,1 +2636,6 @@\n-        return super.shouldSkip() || DeoptimizeObjectsALot || UseJVMCICompiler;\n+        return super.shouldSkip() ||\n+                !EliminateAllocations ||\n+                \/\/ With ZGC the OOME is not always thrown as expected\n+                ZGCIsSelected ||\n+                DeoptimizeObjectsALot ||\n+                UseJVMCICompiler;\n@@ -2665,4 +2680,2 @@\n-        Asserts.assertTrue(coughtOom || !env.targetVMOptions.EliminateAllocations,\n-                           \"PopFrame should have triggered an OOM exception in target\");\n-        String expectedTopFrame =\n-                env.targetVMOptions.EliminateAllocations ? \"inlinedCallForcedToReturn\" : \"dontinline_testMethod\";\n+        Asserts.assertTrue(coughtOom, \"PopFrame should have triggered an OOM exception in target\");\n+        String expectedTopFrame = \"inlinedCallForcedToReturn\";\n@@ -2676,1 +2689,6 @@\n-        return super.shouldSkip() || env.targetVMOptions.DeoptimizeObjectsALot || env.targetVMOptions.UseJVMCICompiler;\n+        return super.shouldSkip() ||\n+                !env.targetVMOptions.EliminateAllocations ||\n+                \/\/ With ZGC the OOME is not always thrown as expected\n+                env.targetVMOptions.ZGCIsSelected ||\n+                env.targetVMOptions.DeoptimizeObjectsALot ||\n+                env.targetVMOptions.UseJVMCICompiler;\n@@ -2732,1 +2750,6 @@\n-        return super.shouldSkip() || DeoptimizeObjectsALot || UseJVMCICompiler;\n+        return super.shouldSkip() ||\n+                !EliminateAllocations ||\n+                \/\/ With ZGC the OOME is not always thrown as expected\n+                ZGCIsSelected ||\n+                DeoptimizeObjectsALot ||\n+                UseJVMCICompiler;\n@@ -2919,6 +2942,4 @@\n-        if (env.targetVMOptions.EliminateAllocations) {\n-            printStack(thread);\n-            Asserts.assertTrue(coughtOom, \"ForceEarlyReturn should have triggered an OOM exception in target\");\n-            msg(\"ForceEarlyReturn(2)\");\n-            thread.forceEarlyReturn(env.vm().mirrorOf(43));\n-        }\n+        Asserts.assertTrue(coughtOom, \"ForceEarlyReturn should have triggered an OOM exception in target\");\n+        printStack(thread);\n+        msg(\"ForceEarlyReturn(2)\");\n+        thread.forceEarlyReturn(env.vm().mirrorOf(43));\n@@ -2935,1 +2956,6 @@\n-        return super.shouldSkip() || env.targetVMOptions.DeoptimizeObjectsALot || env.targetVMOptions.UseJVMCICompiler;\n+        return super.shouldSkip() ||\n+                !env.targetVMOptions.EliminateAllocations ||\n+                \/\/ With ZGC the OOME is not always thrown as expected\n+                env.targetVMOptions.ZGCIsSelected ||\n+                env.targetVMOptions.DeoptimizeObjectsALot ||\n+                env.targetVMOptions.UseJVMCICompiler;\n@@ -2992,1 +3018,6 @@\n-        return super.shouldSkip() || DeoptimizeObjectsALot || UseJVMCICompiler;\n+        return super.shouldSkip() ||\n+                !EliminateAllocations ||\n+                \/\/ With ZGC the OOME is not always thrown as expected\n+                ZGCIsSelected ||\n+                DeoptimizeObjectsALot ||\n+                UseJVMCICompiler;\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":58,"deletions":27,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run testng\/othervm --enable-preview BasicTest\n+ * @run testng\/othervm BasicTest\n@@ -80,2 +80,1 @@\n-        compileSources(SRC_DIR, CLASSES_DIR,\n-                \"--enable-preview\", \"-source\", String.valueOf(Runtime.version().feature()));\n+        compileSources(SRC_DIR, CLASSES_DIR);\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/BasicTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}