{"files":[{"patch":"@@ -2380,1 +2380,1 @@\n-  static int adapter_encoding(BasicType in, bool is_inlinetype) {\n+  static BasicType adapter_encoding(BasicType in) {\n@@ -2385,16 +2385,3 @@\n-      case T_CHAR: {\n-        if (is_inlinetype) {\n-          \/\/ Do not widen inline type field types\n-          assert(InlineTypePassFieldsAsArgs, \"must be enabled\");\n-          return in;\n-        } else {\n-          \/\/ They are all promoted to T_INT in the calling convention\n-          return T_INT;\n-        }\n-      }\n-\n-      case T_INLINE_TYPE: {\n-        \/\/ If inline types are passed as fields, return 'in' to differentiate\n-        \/\/ between a T_INLINE_TYPE and a T_OBJECT in the signature.\n-        return InlineTypePassFieldsAsArgs ? in : adapter_encoding(T_OBJECT, false);\n-      }\n+      case T_CHAR:\n+        \/\/ They are all promoted to T_INT in the calling convention\n+        return T_INT;\n@@ -2447,1 +2434,1 @@\n-    BasicType prev_sbt = T_ILLEGAL;\n+    BasicType prev_bt = T_ILLEGAL;\n@@ -2452,1 +2439,1 @@\n-        int bt = 0;\n+        BasicType bt = T_ILLEGAL;\n@@ -2454,2 +2441,2 @@\n-          BasicType sbt = sig->at(sig_index++)._bt;\n-          if (InlineTypePassFieldsAsArgs && sbt == T_INLINE_TYPE) {\n+          bt = sig->at(sig_index++)._bt;\n+          if (bt == T_INLINE_TYPE) {\n@@ -2457,1 +2444,1 @@\n-            vt_count++;\n+            assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n@@ -2461,1 +2448,1 @@\n-              sbt = T_VOID;\n+              bt = T_VOID;\n@@ -2463,2 +2450,2 @@\n-          } else if (InlineTypePassFieldsAsArgs && sbt == T_VOID &&\n-                     prev_sbt != T_LONG && prev_sbt != T_DOUBLE) {\n+            vt_count++;\n+          } else if (bt == T_VOID && prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n@@ -2466,0 +2453,1 @@\n+            assert(InlineTypePassFieldsAsArgs, \"unexpected end of inline type\");\n@@ -2468,0 +2456,3 @@\n+          } else if (vt_count == 0) {\n+            \/\/ Widen fields that are not part of a scalarized inline type argument\n+            bt = adapter_encoding(bt);\n@@ -2469,2 +2460,1 @@\n-          bt = adapter_encoding(sbt, vt_count > 0);\n-          prev_sbt = sbt;\n+          prev_bt = bt;\n@@ -2472,2 +2462,3 @@\n-        assert((bt & _basic_type_mask) == bt, \"must fit in 4 bits\");\n-        value = (value << _basic_type_bits) | bt;\n+        int bt_val = (bt == T_ILLEGAL) ? 0 : bt;\n+        assert((bt_val & _basic_type_mask) == bt_val, \"must fit in 4 bits\");\n+        value = (value << _basic_type_bits) | bt_val;\n@@ -2871,1 +2862,1 @@\n-    if (_has_inline_recv || _args_on_stack_cc > _args_on_stack) {\n+    if (_has_inline_recv) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":21,"deletions":30,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -711,2 +711,2 @@\n-  address get_i2c_entry()                  const { return _i2c_entry; }\n-  address get_c2i_entry()                  const { return _c2i_entry; }\n+  address get_i2c_entry()                   const { return _i2c_entry; }\n+  address get_c2i_entry()                   const { return _c2i_entry; }\n@@ -715,1 +715,1 @@\n-  address get_c2i_unverified_entry()       const { return _c2i_unverified_entry; }\n+  address get_c2i_unverified_entry()        const { return _c2i_unverified_entry; }\n@@ -717,1 +717,1 @@\n-  address get_c2i_no_clinit_check_entry()  const { return _c2i_no_clinit_check_entry; }\n+  address get_c2i_no_clinit_check_entry()   const { return _c2i_no_clinit_check_entry; }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -165,2 +165,2 @@\n-        \"-XX:+VerifyOops\", \"-XX:+VerifyStack\", \"-XX:+VerifyLastFrame\", \"-XX:+VerifyBeforeGC\", \"-XX:+VerifyAfterGC\",\n-        \"-XX:+VerifyDuringGC\", \"-XX:+VerifyAdapterSharing\"};\n+        \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+VerifyOops\", \"-XX:+VerifyStack\", \"-XX:+VerifyLastFrame\",\n+        \"-XX:+VerifyBeforeGC\", \"-XX:+VerifyAfterGC\", \"-XX:+VerifyDuringGC\", \"-XX:+VerifyAdapterSharing\"};\n@@ -851,1 +851,2 @@\n-        if (!USE_COMPILER || XCOMP || TEST_C1) {\n+        if (!USE_COMPILER || XCOMP || TEST_C1 ||\n+            (STRESS_CC && !WHITE_BOX.isMethodCompilable(m, COMP_LEVEL_FULL_OPTIMIZATION, false))) {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/InlineTypeTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}