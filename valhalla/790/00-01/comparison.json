{"files":[{"patch":"@@ -1012,1 +1012,0 @@\n-    _jdk_internal_vm_annotation_MultiField,\n@@ -1019,1 +1018,0 @@\n-  jbyte _multifield_arg;\n@@ -1046,3 +1044,0 @@\n-  void set_multifield_arg(jbyte arg) { _multifield_arg = arg; }\n-  jbyte multifield_arg() const { return _multifield_arg; }\n-\n@@ -1050,1 +1045,0 @@\n-  bool is_multifield_base() const { return has_annotation(_jdk_internal_vm_annotation_MultiField); }\n@@ -1190,3 +1184,0 @@\n-    b_tag_val = 'B',\n-    b_con_off = 7,\n-    b_size = 9,\n@@ -1239,9 +1230,0 @@\n-    } else if (AnnotationCollector::_jdk_internal_vm_annotation_MultiField == id) {\n-      \/\/ TODO: change those assertion into a conditional statement to process the value\n-      assert(count == 1, \"MultiField annotation must have at least one argument\");  \/\/ Is it true?\n-      assert(member == vmSymbols::value_name(), \"Must be\");\n-      assert(b_tag_val == *(abase + tag_off), \"Must be a byte value\");\n-      int arg_index = Bytes::get_Java_u2((address)abase + b_con_off);\n-      int multifield_arg = cp->int_at(arg_index);\n-      assert(((jbyte)multifield_arg) == multifield_arg, \"Must be\");\n-      coll->set_multifield_arg(multifield_arg);\n@@ -1567,9 +1549,3 @@\n-\n-  GrowableArray<FieldInfo>* temp_fieldinfo = new GrowableArray<FieldInfo>(total_fields, mtNone);\n-  GrowableArray<u2>* temp_generic_signature = new GrowableArray<u2>(total_fields, mtNone);\n-  GrowableArray<MultiFieldInfo>* temp_multifield_info = new GrowableArray<MultiFieldInfo>(0, mtNone); \/\/ could be allocated lazily\n-  FieldInfo fi;\n-  FieldInfo* f = &fi;\n-  GrowableArray<AnnotationArray*>* fields_annotations = NULL;\n-  GrowableArray<AnnotationArray*>* fields_type_annotations = NULL;\n-\n+  u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,\n+                                              u2,\n+                                              total_fields * (FieldInfo::field_slots + 1));\n@@ -1579,0 +1555,1 @@\n+  int num_generic_signature = 0;\n@@ -1580,2 +1557,0 @@\n-  int inj_multifields = 0;\n-  int field_index = -1;\n@@ -1583,1 +1558,0 @@\n-    field_index++;\n@@ -1628,2 +1602,4 @@\n-        if (fields_annotations == NULL) {\n-          fields_annotations = new GrowableArray<AnnotationArray*>(length, mtNone);\n+        if (_fields_annotations == NULL) {\n+          _fields_annotations = MetadataFactory::new_array<AnnotationArray*>(\n+                                             _loader_data, length, NULL,\n+                                             CHECK);\n@@ -1631,2 +1607,1 @@\n-\n-        fields_annotations->at_put_grow(field_index, parsed_annotations.field_annotations(), NULL);\n+        _fields_annotations->at_put(n, parsed_annotations.field_annotations());\n@@ -1636,2 +1611,6 @@\n-        if (fields_type_annotations == NULL) {\n-          fields_type_annotations = new GrowableArray<AnnotationArray*>(length, mtNone);\n+        if (_fields_type_annotations == NULL) {\n+          _fields_type_annotations =\n+            MetadataFactory::new_array<AnnotationArray*>(_loader_data,\n+                                                         length,\n+                                                         NULL,\n+                                                         CHECK);\n@@ -1639,1 +1618,1 @@\n-        fields_type_annotations->at_put_grow(field_index, parsed_annotations.field_type_annotations(), NULL);\n+        _fields_type_annotations->at_put(n, parsed_annotations.field_type_annotations());\n@@ -1648,1 +1627,1 @@\n-        temp_generic_signature->append(generic_signature_index);\n+        fa[generic_signature_slot] = generic_signature_index;\n@@ -1650,0 +1629,1 @@\n+        num_generic_signature ++;\n@@ -1653,1 +1633,2 @@\n-    f->initialize(access_flags.as_short(),\n+    FieldInfo* const field = FieldInfo::from_field_array(fa, n);\n+    field->initialize(access_flags.as_short(),\n@@ -1657,3 +1638,0 @@\n-    int base_idx = temp_fieldinfo->append(fi);\n-    assert(base_idx == field_index, \"Must be\");\n-    FieldInfo* const field = temp_fieldinfo->adr_at(field_index);\n@@ -1672,33 +1650,0 @@\n-\n-    if (parsed_annotations.is_multifield_base() && is_java_primitive(cp->basic_type_for_signature_at(signature_index))) {\n-      field->set_multifield_base(true);\n-      char* base_name = cp->symbol_at(name_index)->as_C_string();\n-      for (int i = 1; i < parsed_annotations.multifield_arg(); i++) {\n-        field_index++;\n-        stringStream st;\n-        st.print(\"%s\", base_name);\n-        st.print(\"#\");\n-        st.print(\"%d\", i);\n-        Symbol* inj_name = SymbolTable::new_symbol(st.as_string());\n-        MultiFieldInfo mfi(inj_name, base_idx, i);\n-        int mfi_idx = temp_multifield_info->append(mfi);\n-        f->initialize(access_flags.as_short(),\n-                      mfi_idx,\n-                      signature_index,\n-                      constantvalue_index);\n-        int inj_idx = temp_fieldinfo->append(fi);\n-        assert(inj_idx == field_index, \"Must be\");\n-        FieldInfo* const field = temp_fieldinfo->adr_at(inj_idx);\n-        const BasicType type = cp->basic_type_for_signature_at(signature_index);\n-        \/\/ Update FieldAllocationCount for this kind of field\n-        fac->update(is_static, type, type == T_PRIMITIVE_OBJECT);\n-        field->set_multifield(true);\n-        if (fields_annotations != NULL && fields_annotations->at(base_idx) != NULL) {\n-          fields_annotations->at_put_grow(field_index, fields_annotations->at(base_idx));\n-        }\n-        if (fields_type_annotations != NULL && fields_type_annotations->at(base_idx) != NULL) {\n-          fields_type_annotations->at_put_grow(field_index, fields_type_annotations->at(base_idx));\n-        }\n-        inj_multifields++;\n-      }\n-    }\n@@ -1707,2 +1652,1 @@\n-  *java_fields_count_ptr = *java_fields_count_ptr + inj_multifields;\n-  int index = length + inj_multifields;\n+  int index = length;\n@@ -1717,1 +1661,1 @@\n-          const FieldInfo* const f = temp_fieldinfo->adr_at(i);\n+          const FieldInfo* const f = FieldInfo::from_field_array(fa, i);\n@@ -1726,0 +1670,1 @@\n+          \/\/ These will be removed from the field array at the end\n@@ -1731,1 +1676,2 @@\n-      f->initialize((u2)JVM_ACC_FIELD_INTERNAL,\n+      FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n+      field->initialize((u2)JVM_ACC_FIELD_INTERNAL,\n@@ -1735,3 +1681,0 @@\n-      field_index++;\n-      int inj_idx = temp_fieldinfo->append(fi);\n-      assert(inj_idx == field_index, \"Must be\");\n@@ -1748,1 +1691,2 @@\n-    f->initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,\n+    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n+    field->initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,\n@@ -1752,3 +1696,0 @@\n-    field_index++;\n-    int inj_idx = temp_fieldinfo->append(fi);\n-    assert(inj_idx == field_index, \"Must be\");\n@@ -1762,1 +1703,2 @@\n-    f->initialize(JVM_ACC_FIELD_INTERNAL,\n+    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n+    field->initialize(JVM_ACC_FIELD_INTERNAL,\n@@ -1766,3 +1708,0 @@\n-    field_index++;\n-    int inj_idx = temp_fieldinfo->append(fi);\n-    assert(inj_idx == field_index, \"Must be\");\n@@ -1779,2 +1718,0 @@\n-  assert(index == field_index + 1, \"Must be\");\n-  assert(temp_fieldinfo->length() == field_index + 1, \"Must be\");\n@@ -1784,1 +1721,1 @@\n-                                   temp_fieldinfo->length() * FieldInfo::field_slots + temp_generic_signature->length(),\n+                                   index * FieldInfo::field_slots + num_generic_signature,\n@@ -1792,5 +1729,2 @@\n-    for (i = 0; i < index; i++) {\n-      u2* adr = (u2*)temp_fieldinfo->adr_at(i);\n-      for (int j = 0; j < FieldInfo::field_slots; j++) {\n-        _fields->at_put(i * FieldInfo::field_slots + j, adr[j]);\n-      }\n+    for (; i < index * FieldInfo::field_slots; i++) {\n+      _fields->at_put(i, fa[i]);\n@@ -1798,3 +1732,3 @@\n-    i = index * FieldInfo::field_slots;\n-    for (int j = 0; j < temp_generic_signature->length(); j++) {\n-      _fields->at_put(i++, temp_generic_signature->at(j));\n+    for (int j = total_fields * FieldInfo::field_slots;\n+         j < generic_signature_slot; j++) {\n+      _fields->at_put(i++, fa[j]);\n@@ -1802,1 +1736,0 @@\n-\n@@ -1806,25 +1739,0 @@\n-  if (temp_multifield_info->length() > 0) {\n-    _multifield_info = MetadataFactory::new_array<MultiFieldInfo>(_loader_data, temp_multifield_info->length(), CHECK);\n-    for (int i = 0; i < temp_multifield_info->length(); i++) {\n-      _multifield_info->at_put(i, temp_multifield_info->at(i));\n-    }\n-  }\n-\n-  if (fields_annotations != NULL) {\n-    _fields_annotations = MetadataFactory::new_array<AnnotationArray*>(\n-                                             _loader_data, temp_fieldinfo->length(), NULL,\n-                                             CHECK);\n-    for (int i = 0; i < fields_annotations->length(); i++) {\n-      _fields_annotations->at_put(i, fields_annotations->at(i));\n-    }\n-  }\n-\n-  if (fields_type_annotations != NULL) {\n-     _fields_type_annotations = MetadataFactory::new_array<AnnotationArray*>(\n-                                             _loader_data, temp_fieldinfo->length(), NULL,\n-                                             CHECK);\n-    for (int i = 0; i < fields_type_annotations->length(); i++) {\n-      _fields_type_annotations->at_put(i, fields_type_annotations->at(i));\n-    }\n-  }\n-\n@@ -1842,1 +1750,1 @@\n-      for (AllFieldStream fs(_fields, cp, _multifield_info); !fs.done(); fs.next()) {\n+      for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n@@ -2217,5 +2125,0 @@\n-    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_MultiField_signature): {\n-      if (_location != _in_field) break;  \/\/ only allow for fields\n-      if (!privileged)            break;  \/\/ honor privileges\n-      return _jdk_internal_vm_annotation_MultiField;\n-    }\n@@ -4293,1 +4196,0 @@\n-  this_klass->set_multifield_info(_multifield_info);\n@@ -5783,1 +5685,0 @@\n-  assert(NULL == _multifield_info, \"invariant\");\n@@ -5925,1 +5826,1 @@\n-  for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n@@ -6059,1 +5960,0 @@\n-  _multifield_info(NULL),\n@@ -6145,1 +6045,0 @@\n-  _multifield_info = NULL;\n@@ -6159,4 +6058,0 @@\n-  if (_multifield_info != NULL) {\n-    MetadataFactory::free_array<MultiFieldInfo>(_loader_data, _multifield_info);\n-  }\n-\n@@ -6660,1 +6555,1 @@\n-    for (AllFieldStream fs(_fields, cp, _multifield_info); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n@@ -6683,1 +6578,1 @@\n-      _field_info, _inline_type_field_klasses, _multifield_info);\n+      _field_info, _inline_type_field_klasses);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":39,"deletions":144,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -151,1 +151,0 @@\n-  Array<MultiFieldInfo>* _multifield_info;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-  _is_reference(false),\n-  _multifield_index(-1) {\n+  _is_reference(false) {\n@@ -57,1 +56,1 @@\n-LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference, jbyte multifield_index) :\n+LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference) :\n@@ -66,3 +65,2 @@\n- _is_reference(is_reference),\n- _multifield_index(multifield_index) {\n-  assert(kind == REGULAR || kind == INLINED || kind == INHERITED || kind == MULTIFIELD,\n+ _is_reference(is_reference) {\n+  assert(kind == REGULAR || kind == INLINED || kind == INHERITED,\n@@ -87,1 +85,0 @@\n-  _multifields(NULL),\n@@ -93,1 +90,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false, -1);\n+  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false);\n@@ -103,1 +100,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true, -1);\n+  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true);\n@@ -112,1 +109,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INLINED, vk->get_exact_size_in_bytes(), vk->get_alignment(), false, -1);\n+  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INLINED, vk->get_exact_size_in_bytes(), vk->get_alignment(), false);\n@@ -121,24 +118,0 @@\n-void FieldGroup::add_multifield(AllFieldStream fs, Array<MultiFieldInfo>* multifield_info, InlineKlass* vk) {\n-  assert(fs.is_multifield() || fs.is_multifield_base(), \"Must be\");\n-  u2 base = fs.multifield_base();\n-  BasicType type = Signature::basic_type(fs.signature());\n-  MultiFieldGroup* mfg = NULL;\n-  if (_multifields != NULL) {\n-    for (int i = 0; i < _multifields->length(); i++) {\n-      if (base == _multifields->at(i)->multifield_base()) {\n-        mfg = _multifields->at(i);\n-        break;\n-      }\n-    }\n-  } else {\n-    _multifields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<MultiFieldGroup*>(8);\n-  }\n-  if (mfg == NULL) {\n-    mfg = new(ResourceObj::RESOURCE_AREA, mtInternal) MultiFieldGroup(base, fs.signature());\n-    mfg->add_field(fs, vk);\n-    _multifields->append(mfg);\n-  } else {\n-    mfg->add_field(fs, vk);\n-  }\n-}\n-\n@@ -152,16 +125,0 @@\n-  if (_multifields != NULL) {\n-    for (int i = 0; i < _multifields->length(); i++) {\n-      int size = _multifields->at(i)->fields()->at(0)->size();\n-      int alignment =  _multifields->at(i)->fields()->at(0)->alignment();\n-      int multialignment = size\/alignment;\n-      if (size % multialignment != 0) multialignment+= alignment;\n-      \/\/ Problem: at this point, multialignment can be a weird number, for instance not a power of two\n-      int multisize = multialignment * alignment * _multifields->at(i)->fields()->length();  \/\/ should be stored\n-      \/\/ True alignment should be adjusted to increase chances to be on a single cache line\n-      int multifield_group_alignment = MIN2(round_up_power_of_2(multisize), HeapWordSize);\n-      _multifields->at(i)->set_group_size(multisize);\n-      _multifields->at(i)->set_group_alignment(multifield_group_alignment);\n-      _multifields->at(i)->fields()->sort(MultiFieldGroup::compare_multifield_index);\n-    }\n-    _multifields->sort(MultiFieldGroup::compare_multifield_groups_inverted);\n-  }\n@@ -184,29 +141,1 @@\n-MultiFieldGroup::MultiFieldGroup(u2 base, Symbol* signature) :  _multifield_base(base), _signature(signature), _fields(NULL) { }\n-\n-void MultiFieldGroup::add_field(AllFieldStream fs, InlineKlass* vk) {\n-  assert(fs.is_multifield() || fs.is_multifield_base(), \"Must be\");\n-  assert(fs.multifield_base() == multifield_base(), \"multifield base mismatch\");\n-  jbyte idx = fs.multifield_index();\n-  if (_fields == NULL) {\n-    _fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(8);\n-  } else {\n-    guarantee(fs.signature() == signature(), \"multifield signature mismatch\");\n-  }\n-  BasicType type = Signature::basic_type(fs.signature());\n-  LayoutRawBlock* block = NULL;\n-  if (type == T_PRIMITIVE_OBJECT) {\n-    block = new LayoutRawBlock(fs.index(), LayoutRawBlock::MULTIFIELD, vk->get_exact_size_in_bytes(),\n-                               vk->get_alignment(), false, fs.multifield_index());\n-  } else {\n-    int size = type2aelembytes(type);\n-    block = new LayoutRawBlock(fs.index(), LayoutRawBlock::MULTIFIELD, size, size, false, fs.multifield_index());\n-  }\n-  int cursor = 0;\n-  for (; cursor < _fields->length(); cursor++) {\n-    assert(_fields->at(cursor)->multifield_index() != fs.multifield_index(), \"multifield index duplicate found\");\n-    if (_fields->at(cursor)->multifield_index() > fs.multifield_index()) break;\n-  }\n-  _fields->insert_before(cursor, block);\n-}\n-\n-FieldLayout::FieldLayout(Array<u2>* fields, ConstantPool* cp, Array<MultiFieldInfo>* multifields) :\n+FieldLayout::FieldLayout(Array<u2>* fields, ConstantPool* cp) :\n@@ -215,1 +144,0 @@\n-  _multifield_info(multifields),\n@@ -259,2 +187,1 @@\n-         && block->kind() != LayoutRawBlock::INLINED\n-         && block->kind() != LayoutRawBlock::MULTIFIELD) {\n+         && block->kind() != LayoutRawBlock::INLINED) {\n@@ -389,31 +316,0 @@\n-void FieldLayout::add_multifield(MultiFieldGroup* multifield_group, LayoutRawBlock* start) {\n-  if (start == NULL) {\n-    start = _start;\n-  }\n-  LayoutRawBlock* candidate = NULL;\n-  if (start == last_block()) {\n-    candidate = last_block();\n-  } else {\n-    candidate = last_block()->prev_block();\n-    while (candidate->kind() != LayoutRawBlock::EMPTY || !candidate->fit(multifield_group->group_size(), multifield_group->group_alignment())) {\n-      if (candidate == start) {\n-        candidate = last_block();\n-        break;\n-      }\n-      candidate = candidate->prev_block();\n-    }\n-    assert(candidate != NULL, \"Candidate must not be null\");\n-    assert(candidate->kind() == LayoutRawBlock::EMPTY, \"Candidate must be an empty block\");\n-  }\n-  if ((candidate->offset() % multifield_group->group_alignment()) != 0) {\n-    int adjustment = multifield_group->group_alignment() - (candidate->offset() % multifield_group->group_alignment());\n-    LayoutRawBlock* adj = new LayoutRawBlock(LayoutRawBlock::EMPTY, adjustment);\n-    insert(candidate, adj);\n-  }\n-  assert(candidate->fit(multifield_group->group_size(), multifield_group->group_alignment()), \"Candidate must be able to store the whole contiguous block\");\n-  for (int i = 0; i < multifield_group->fields()->length(); i++) {\n-    LayoutRawBlock* b = multifield_group->fields()->at(i);\n-    insert_field_block(candidate, b);\n-  }\n-}\n-\n@@ -439,1 +335,1 @@\n-    for (AllFieldStream fs(ik->fields(), ik->constants(), ik->multifield_info()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n@@ -448,1 +344,1 @@\n-                                   vk->get_alignment(), false, -1);\n+                                   vk->get_alignment(), false);\n@@ -453,1 +349,1 @@\n-        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false, -1);\n+        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false);\n@@ -577,1 +473,1 @@\n-                       fi->name(_multifield_info, _cp)->as_C_string(),\n+                       fi->name(_cp)->as_C_string(),\n@@ -588,1 +484,1 @@\n-                       fi->name(_multifield_info, _cp)->as_C_string(),\n+                       fi->name(_cp)->as_C_string(),\n@@ -608,1 +504,1 @@\n-        for (AllFieldStream fs(ik->fields(), ik->constants(), ik->multifield_info()); !fs.done(); fs.next()) {\n+        for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n@@ -637,10 +533,0 @@\n-    case LayoutRawBlock::MULTIFIELD:\n-      FieldInfo* fi = FieldInfo::from_field_array(_fields, b->field_index());\n-      output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n-                       b->offset(),\n-                       fi->name(_multifield_info, _cp)->as_C_string(),\n-                       fi->signature(_cp)->as_C_string(),\n-                       b->size(),\n-                       b->alignment(),\n-                       \"MULTIFIELD\");\n-      break;\n@@ -654,2 +540,1 @@\n-                                       FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses,\n-                                       Array<MultiFieldInfo>* multifields) :\n+                                       FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses) :\n@@ -662,1 +547,0 @@\n-  _multifield_info(multifields),\n@@ -664,1 +548,1 @@\n-  _contended_groups(GrowableArray<FieldGroup*>(0)),\n+  _contended_groups(GrowableArray<FieldGroup*>(8)),\n@@ -694,1 +578,1 @@\n-  _layout = new FieldLayout(_fields, _constant_pool, _multifield_info);\n+  _layout = new FieldLayout(_fields, _constant_pool);\n@@ -700,1 +584,1 @@\n-  _static_layout = new FieldLayout(_fields, _constant_pool, _multifield_info);\n+  _static_layout = new FieldLayout(_fields, _constant_pool);\n@@ -713,1 +597,1 @@\n-  for (AllFieldStream fs(_fields, _constant_pool, _multifield_info); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {\n@@ -734,55 +618,46 @@\n-    bool has_multifield_annotation = false;\n-    if (fs.is_multifield() || fs.is_multifield_base()) {\n-      group->add_multifield(fs, _multifield_info);\n-    } else {\n-      switch(type) {\n-        case T_BYTE:\n-        case T_CHAR:\n-        case T_DOUBLE:\n-        case T_FLOAT:\n-        case T_INT:\n-        case T_LONG:\n-        case T_SHORT:\n-        case T_BOOLEAN:\n-          group->add_primitive_field(fs, type);\n-          break;\n-        case T_OBJECT:\n-        case T_ARRAY:\n-          if (group != _static_fields) _nonstatic_oopmap_count++;\n-          group->add_oop_field(fs);\n-          break;\n-        case T_PRIMITIVE_OBJECT:\n-          _has_inline_type_fields = true;\n-          if (group == _static_fields) {\n-            \/\/ static fields are never inlined\n-            group->add_oop_field(fs);\n-          } else {\n-            _has_flattening_information = true;\n-            \/\/ Flattening decision to be taken here\n-            \/\/ This code assumes all verification already have been performed\n-            \/\/ (field's type has been loaded and it is an inline klass)\n-            JavaThread* THREAD = JavaThread::current();\n-            Klass* klass =  _inline_type_field_klasses->at(fs.index());\n-            assert(klass != NULL, \"Sanity check\");\n-            InlineKlass* vk = InlineKlass::cast(klass);\n-            bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                      (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-            bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n-            bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n-            if (vk->is_naturally_atomic()) {\n-              too_atomic_to_flatten = false;\n-              \/\/too_volatile_to_flatten = false; \/\/FIXME\n-              \/\/ volatile fields are currently never inlined, this could change in the future\n-            }\n-            if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n-              group->add_inlined_field(fs, vk);\n-              _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-              fs.set_inlined(true);\n-              if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-                _has_nonatomic_values = true;\n-                _atomic_field_count--;  \/\/ every other field is atomic but this one\n-              }\n-            } else {\n-              _nonstatic_oopmap_count++;\n-              group->add_oop_field(fs);\n-            }\n+    switch(type) {\n+    case T_BYTE:\n+    case T_CHAR:\n+    case T_DOUBLE:\n+    case T_FLOAT:\n+    case T_INT:\n+    case T_LONG:\n+    case T_SHORT:\n+    case T_BOOLEAN:\n+      group->add_primitive_field(fs, type);\n+      break;\n+    case T_OBJECT:\n+    case T_ARRAY:\n+      if (group != _static_fields) _nonstatic_oopmap_count++;\n+      group->add_oop_field(fs);\n+      break;\n+    case T_PRIMITIVE_OBJECT:\n+      _has_inline_type_fields = true;\n+      if (group == _static_fields) {\n+        \/\/ static fields are never inlined\n+        group->add_oop_field(fs);\n+      } else {\n+        _has_flattening_information = true;\n+        \/\/ Flattening decision to be taken here\n+        \/\/ This code assumes all verification already have been performed\n+        \/\/ (field's type has been loaded and it is an inline klass)\n+        JavaThread* THREAD = JavaThread::current();\n+        Klass* klass =  _inline_type_field_klasses->at(fs.index());\n+        assert(klass != NULL, \"Sanity check\");\n+        InlineKlass* vk = InlineKlass::cast(klass);\n+        bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                   (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+        bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+        bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n+        if (vk->is_naturally_atomic()) {\n+          too_atomic_to_flatten = false;\n+          \/\/too_volatile_to_flatten = false; \/\/FIXME\n+          \/\/ volatile fields are currently never inlined, this could change in the future\n+        }\n+        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n+          group->add_inlined_field(fs, vk);\n+          _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+          fs.set_inlined(true);\n+          if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+            _has_nonatomic_values = true;\n+            _atomic_field_count--;  \/\/ every other field is atomic but this one\n@@ -790,3 +665,4 @@\n-          break;\n-        default:\n-          fatal(\"Something wrong?\");\n+        } else {\n+          _nonstatic_oopmap_count++;\n+          group->add_oop_field(fs);\n+        }\n@@ -794,0 +670,3 @@\n+      break;\n+    default:\n+      fatal(\"Something wrong?\");\n@@ -819,1 +698,1 @@\n-  for (AllFieldStream fs(_fields, _constant_pool, _multifield_info); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {\n@@ -831,23 +710,53 @@\n-    bool has_multifield_annotation = false;\n-    if (fs.is_multifield() || fs.is_multifield_base()) {\n-      group->add_multifield(fs, _multifield_info);\n-    } else {\n-      switch(type) {\n-        case T_BYTE:\n-        case T_CHAR:\n-        case T_DOUBLE:\n-        case T_FLOAT:\n-        case T_INT:\n-        case T_LONG:\n-        case T_SHORT:\n-        case T_BOOLEAN:\n-          if (group != _static_fields) {\n-            field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n-          }\n-          group->add_primitive_field(fs, type);\n-          break;\n-        case T_OBJECT:\n-        case T_ARRAY:\n-          if (group != _static_fields) {\n-            _nonstatic_oopmap_count++;\n-            field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n+    switch(type) {\n+    case T_BYTE:\n+    case T_CHAR:\n+    case T_DOUBLE:\n+    case T_FLOAT:\n+    case T_INT:\n+    case T_LONG:\n+    case T_SHORT:\n+    case T_BOOLEAN:\n+      if (group != _static_fields) {\n+        field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n+      }\n+      group->add_primitive_field(fs, type);\n+      break;\n+    case T_OBJECT:\n+    case T_ARRAY:\n+      if (group != _static_fields) {\n+        _nonstatic_oopmap_count++;\n+        field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n+      }\n+      group->add_oop_field(fs);\n+      break;\n+    case T_PRIMITIVE_OBJECT: {\n+\/\/      fs.set_inline(true);\n+      _has_inline_type_fields = true;\n+      if (group == _static_fields) {\n+        \/\/ static fields are never inlined\n+        group->add_oop_field(fs);\n+      } else {\n+        \/\/ Flattening decision to be taken here\n+        \/\/ This code assumes all verifications have already been performed\n+        \/\/ (field's type has been loaded and it is an inline klass)\n+        JavaThread* THREAD = JavaThread::current();\n+        Klass* klass =  _inline_type_field_klasses->at(fs.index());\n+        assert(klass != NULL, \"Sanity check\");\n+        InlineKlass* vk = InlineKlass::cast(klass);\n+        bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                   (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+        bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+        bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n+        if (vk->is_naturally_atomic()) {\n+          too_atomic_to_flatten = false;\n+          \/\/too_volatile_to_flatten = false; \/\/FIXME\n+          \/\/ volatile fields are currently never inlined, this could change in the future\n+        }\n+        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n+          group->add_inlined_field(fs, vk);\n+          _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+          field_alignment = vk->get_alignment();\n+          fs.set_inlined(true);\n+          if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+            _has_nonatomic_values = true;\n+            _atomic_field_count--;  \/\/ every other field is atomic but this one\n@@ -855,0 +764,3 @@\n+        } else {\n+          _nonstatic_oopmap_count++;\n+          field_alignment = type2aelembytes(T_OBJECT);\n@@ -856,40 +768,0 @@\n-          break;\n-        case T_PRIMITIVE_OBJECT: {\n-          \/\/      fs.set_inline(true);\n-          _has_inline_type_fields = true;\n-          if (group == _static_fields) {\n-            \/\/ static fields are never inlined\n-            group->add_oop_field(fs);\n-          } else {\n-            \/\/ Flattening decision to be taken here\n-            \/\/ This code assumes all verifications have already been performed\n-            \/\/ (field's type has been loaded and it is an inline klass)\n-            JavaThread* THREAD = JavaThread::current();\n-            Klass* klass =  _inline_type_field_klasses->at(fs.index());\n-            assert(klass != NULL, \"Sanity check\");\n-            InlineKlass* vk = InlineKlass::cast(klass);\n-            bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                      (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-            bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n-            bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n-            if (vk->is_naturally_atomic()) {\n-              too_atomic_to_flatten = false;\n-              \/\/too_volatile_to_flatten = false; \/\/FIXME\n-              \/\/ volatile fields are currently never inlined, this could change in the future\n-            }\n-            if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n-              group->add_inlined_field(fs, vk);\n-              _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-              field_alignment = vk->get_alignment();\n-              fs.set_inlined(true);\n-              if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-                _has_nonatomic_values = true;\n-                _atomic_field_count--;  \/\/ every other field is atomic but this one\n-              }\n-            } else {\n-              _nonstatic_oopmap_count++;\n-              field_alignment = type2aelembytes(T_OBJECT);\n-              group->add_oop_field(fs);\n-            }\n-          }\n-          break;\n@@ -897,2 +769,0 @@\n-        default:\n-          fatal(\"Unexpected BasicType\");\n@@ -900,0 +770,1 @@\n+      break;\n@@ -901,8 +772,2 @@\n-    if (!fs.access_flags().is_static() && field_alignment > alignment) alignment = field_alignment;\n-  }\n-  _root_group->sort_by_size();\n-  if (_root_group->multifields() != NULL) {\n-    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n-      if (_root_group->multifields()->at(i)->group_alignment() > alignment) {\n-        alignment = _root_group->multifields()->at(i)->group_alignment();\n-      }\n+    default:\n+      fatal(\"Unexpected BasicType\");\n@@ -910,0 +775,1 @@\n+    if (!fs.access_flags().is_static() && field_alignment > alignment) alignment = field_alignment;\n@@ -946,5 +812,0 @@\n-  if (_root_group->multifields() != NULL) {\n-    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n-      _layout->add_multifield(_root_group->multifields()->at(i));\n-    }\n-  }\n@@ -960,6 +821,1 @@\n-      if (cg->multifields() != NULL) {\n-        for (int i = 0; i < cg->multifields()->length(); i++) {\n-          _layout->add_multifield(cg->multifields()->at(i), start);\n-        }\n-      }\n-      _layout->add(cg->big_primitive_fields(), start);\n+      _layout->add(cg->big_primitive_fields());\n@@ -977,5 +833,0 @@\n-  if (_static_fields->multifields() != NULL) {\n-    for (int i = 0; i < _static_fields->multifields()->length(); i++) {\n-      _layout->add_multifield(_static_fields->multifields()->at(i));\n-    }\n-  }\n@@ -1015,5 +866,0 @@\n-  if (_root_group->multifields() != NULL) {\n-    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n-      _layout->add_multifield(_root_group->multifields()->at(i));\n-    }\n-  }\n@@ -1033,0 +879,1 @@\n+  _exact_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":136,"deletions":289,"binary":false,"changes":425,"status":"modified"},{"patch":"@@ -61,2 +61,1 @@\n-    INHERITED,        \/\/ field(s) inherited from super classes\n-    MULTIFIELD        \/\/ fields part of a multi-field\n+    INHERITED         \/\/ field(s) inherited from super classes\n@@ -75,1 +74,0 @@\n-  jbyte _multifield_index;\n@@ -79,1 +77,1 @@\n-  LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference, jbyte multifield_index);\n+  LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference = false);\n@@ -98,1 +96,0 @@\n-  jbyte multifield_index() const { return _multifield_index; }\n@@ -126,33 +123,1 @@\n-class MultiFieldGroup : public ResourceObj {\n- private:\n-  u2 _multifield_base;\n-  Symbol* _signature;\n-  int _group_size;\n-  int _group_alignment;\n-  GrowableArray<LayoutRawBlock*>* _fields;\n-  \/\/ total size and alignment?\n-\n- public:\n-  MultiFieldGroup(u2 base, Symbol* signature);\n-\n-  u2 multifield_base() const { return _multifield_base; }\n-  Symbol* signature() const { return _signature; }\n-  int group_size() const { return _group_size; }\n-  void set_group_size(int size) { _group_size = size; }\n-  int group_alignment() const { return _group_alignment; }\n-  void set_group_alignment(int alignment) { _group_alignment = alignment; }\n-  GrowableArray<LayoutRawBlock*>* fields() const { return _fields; }\n-  void add_field(AllFieldStream fs, InlineKlass* vk);\n-    static int compare_multifield_index(LayoutRawBlock** x, LayoutRawBlock** y) {\n-     return (*x)->multifield_index() - (*y)->multifield_index();\n-  }\n-  static int compare_multifield_groups_inverted(MultiFieldGroup** x, MultiFieldGroup** y) {\n-    int diff = (*y)->group_size() - (*x)->group_size();\n-    if (diff == 0) {\n-      diff = (*y)->group_alignment() - (*x)->group_alignment();\n-    }\n-    return diff;\n-  }\n-};\n-\n-\/\/ A FieldGroup represents a set of fields that have to be allocated together,\n+\/\/ A Field group represents a set of fields that have to be allocated together,\n@@ -171,1 +136,0 @@\n-  GrowableArray<MultiFieldGroup*>* _multifields;\n@@ -184,1 +148,0 @@\n-  GrowableArray<MultiFieldGroup*>* multifields() const { return _multifields; }\n@@ -191,1 +154,0 @@\n-  void add_multifield(AllFieldStream fs, Array<MultiFieldInfo>* multifield_info, InlineKlass* vk = NULL);\n@@ -219,1 +181,0 @@\n-  Array<MultiFieldInfo>* _multifield_info;\n@@ -225,1 +186,1 @@\n-  FieldLayout(Array<u2>* fields, ConstantPool* cp, Array<MultiFieldInfo>* multifields);\n+  FieldLayout(Array<u2>* fields, ConstantPool* cp);\n@@ -247,1 +208,0 @@\n-  void add_multifield(MultiFieldGroup* multifield, LayoutRawBlock* start = NULL);\n@@ -288,1 +248,0 @@\n-  Array<MultiFieldInfo>* _multifield_info;\n@@ -307,1 +266,0 @@\n-  MultiFieldGroup* get_or_create_multifield_group(int base);\n@@ -311,2 +269,1 @@\n-      Array<u2>* fields, bool is_contended, bool is_inline_type, FieldLayoutInfo* info,\n-      Array<InlineKlass*>* inline_type_field_klasses, Array<MultiFieldInfo>* multifields);\n+      Array<u2>* fields, bool is_contended, bool is_inline_type, FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":5,"deletions":48,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1260,1 +1260,1 @@\n-    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,1 +265,0 @@\n-  template(jdk_internal_vm_annotation_MultiField_signature,                  \"Ljdk\/internal\/vm\/annotation\/MultiField;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -311,2 +311,1 @@\n-  f(RecordComponent) \\\n-  f(MultiFieldInfo)\n+  f(RecordComponent)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-  class   MultiFieldInfo;    \/\/ no C++ vtable\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-  jint int_at(int which) const {\n+  jint int_at(int which) {\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"oops\/fieldInfo.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-\n-Symbol* FieldInfo::get_multifield_name(Array<MultiFieldInfo>* multifield_info) const {\n-  assert(is_multifield(), \"Sanity check\");\n-  return multifield_info->at(secondary_index()).name();\n-}\n-\n-u2 FieldInfo::multifield_base(Array<MultiFieldInfo>* multifield_info) const {\n-  assert(is_multifield(), \"Sanity check\");\n-  return multifield_info->at(secondary_index()).base_index();\n-}\n-\n-jbyte FieldInfo::multifield_index(Array<MultiFieldInfo>* multifield_info) const {\n-  assert(is_multifield(), \"Sanity check\");\n-  return multifield_info->at(secondary_index()).multifield_index();\n-}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -33,2 +33,0 @@\n-class MultiFieldInfo;\n-\n@@ -43,1 +41,0 @@\n-  friend class FieldStreamBase;\n@@ -46,1 +43,0 @@\n-  friend class FieldLayout;\n@@ -53,6 +49,4 @@\n-#define FIELDINFO_TAG_SIZE             5\n-#define FIELDINFO_TAG_OFFSET           1 << 0\n-#define FIELDINFO_TAG_CONTENDED        1 << 1\n-#define FIELDINFO_TAG_INLINED          1 << 2\n-#define FIELDINFO_TAG_MULTIFIELD       1 << 3\n-#define FIELDINFO_TAG_MULTIFIELD_BASE  1 << 4\n+#define FIELDINFO_TAG_SIZE             3\n+#define FIELDINFO_TAG_OFFSET           (1 << 0)\n+#define FIELDINFO_TAG_CONTENDED        (1 << 1)\n+#define FIELDINFO_TAG_INLINED          (1 << 2)\n@@ -64,3 +58,3 @@\n-  \/\/    .......................................BMI00  - non-contended field\n-  \/\/    [--contention_group--].................B0I10  - contended field with contention group\n-  \/\/    [------------------offset-------------]BMI01  - real field offset\n+  \/\/    ..........................................00  - non-contended field\n+  \/\/    [--contention_group--]...................I10  - contended field with contention group\n+  \/\/    [------------------offset---------------]I01  - real field offset\n@@ -72,2 +66,0 @@\n-  \/\/ Bit M indicates the field is an injected multifield\n-  \/\/ Bit B indicates the field is a multifield base field\n@@ -92,1 +84,1 @@\n-  u2 name_index() const                          { assert(!is_multifield(), \"wrong call\"); return _shorts[name_index_offset]; }\n+  u2 name_index() const                          { return _shorts[name_index_offset];        }\n@@ -95,1 +87,0 @@\n-  u2 secondary_index() const                     { assert( is_multifield(), \"wrong call\"); return _shorts[name_index_offset]; }\n@@ -127,8 +118,0 @@\n-  bool is_multifield() const {\n-    return (_shorts[low_packed_offset] & FIELDINFO_TAG_MULTIFIELD) != 0;\n-  }\n-\n-  bool is_multifield_base() const {\n-    return (_shorts[low_packed_offset] & FIELDINFO_TAG_MULTIFIELD_BASE) != 0;\n-  }\n-\n@@ -145,6 +128,1 @@\n-  Symbol* get_multifield_name(Array<MultiFieldInfo>* multifield_info) const;\n-\n-  Symbol* name(Array<MultiFieldInfo>* multifield_info, ConstantPool* cp) const {\n-    if (is_multifield()) {\n-      return get_multifield_name(multifield_info);\n-    }\n+  Symbol* name(ConstantPool* cp) const {\n@@ -170,2 +148,0 @@\n-    bool multifield = is_multifield();\n-    bool multifield_base = is_multifield_base();\n@@ -174,2 +150,0 @@\n-    if (multifield) set_multifield(true);\n-    if (multifield_base) set_multifield_base(true);\n@@ -199,19 +173,0 @@\n-  void set_multifield(bool b) {\n-    if (b) {\n-      _shorts[low_packed_offset] |= FIELDINFO_TAG_MULTIFIELD;\n-    } else {\n-      _shorts[low_packed_offset] &= ~FIELDINFO_TAG_MULTIFIELD;\n-    }\n-  }\n-\n-  void set_multifield_base(bool b) {\n-    if (b) {\n-      _shorts[low_packed_offset] |= FIELDINFO_TAG_MULTIFIELD_BASE;\n-    } else {\n-      _shorts[low_packed_offset] &= ~FIELDINFO_TAG_MULTIFIELD_BASE;\n-    }\n-  }\n-\n-  u2 multifield_base(Array<MultiFieldInfo>* multifield_info) const;\n-  jbyte multifield_index(Array<MultiFieldInfo>* multifield_info) const;\n-\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":9,"deletions":54,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-  Array<MultiFieldInfo>* _multifield_info;\n@@ -83,1 +82,1 @@\n-  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info, int start, int limit );\n+  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants, int start, int limit);\n@@ -85,1 +84,1 @@\n-  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info);\n+  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants);\n@@ -118,5 +117,1 @@\n-    return field()->name(_multifield_info, _constants());\n-  }\n-\n-  int name_index() const {\n-    return field()->name_index();\n+    return field()->name(_constants());\n@@ -163,26 +158,0 @@\n-  bool is_multifield() const {\n-    return field()->is_multifield();\n-  }\n-\n-  bool is_multifield_base() const {\n-    return field()->is_multifield_base();\n-  }\n-\n-  u2 multifield_base() const {\n-    assert(field()->is_multifield() || field()->is_multifield_base(), \"Must be\");\n-    if (field()->is_multifield_base()) {\n-      return index();\n-    } else {\n-      return _multifield_info->at(field()->secondary_index()).base_index();\n-    }\n-  }\n-\n-  jbyte multifield_index() const {\n-    assert(field()->is_multifield() || field()->is_multifield_base(), \"Must be\");\n-    if (field()->is_multifield_base()) {\n-      return 0;\n-    } else {\n-      return _multifield_info->at(field()->secondary_index()).multifield_index();\n-    }\n-  }\n-\n@@ -204,1 +173,1 @@\n-  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fields(), k->constants(), k->multifield_info(), 0, k->java_fields_count()) {}\n+  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fields(), k->constants(), 0, k->java_fields_count()) {}\n@@ -252,1 +221,1 @@\n-  InternalFieldStream(InstanceKlass* k): FieldStreamBase(k->fields(), k->constants(), k->multifield_info(), k->java_fields_count(), 0) {}\n+  InternalFieldStream(InstanceKlass* k):      FieldStreamBase(k->fields(), k->constants(), k->java_fields_count(), 0) {}\n@@ -258,2 +227,2 @@\n-  AllFieldStream(Array<u2>* fields, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info): FieldStreamBase(fields, constants, multifield_info) {}\n-  AllFieldStream(InstanceKlass* k):      FieldStreamBase(k->fields(), k->constants(), k->multifield_info()) {}\n+  AllFieldStream(Array<u2>* fields, ConstantPool* constants): FieldStreamBase(fields, constants) {}\n+  AllFieldStream(InstanceKlass* k):      FieldStreamBase(k->fields(), k->constants()) {}\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":7,"deletions":38,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-FieldStreamBase::FieldStreamBase(Array<u2>* fields, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info, int start, int limit) : _fields(fields),\n-         _constants(constantPoolHandle(Thread::current(), constants)), _multifield_info(multifield_info), _index(start) {\n+FieldStreamBase::FieldStreamBase(Array<u2>* fields, ConstantPool* constants, int start, int limit) : _fields(fields),\n+         _constants(constantPoolHandle(Thread::current(), constants)), _index(start) {\n@@ -43,2 +43,2 @@\n-FieldStreamBase::FieldStreamBase(Array<u2>* fields, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info) : _fields(fields),\n-         _constants(constantPoolHandle(Thread::current(), constants)), _multifield_info(multifield_info), _index(0) {\n+FieldStreamBase::FieldStreamBase(Array<u2>* fields, ConstantPool* constants) : _fields(fields),\n+         _constants(constantPoolHandle(Thread::current(), constants)), _index(0) {\n@@ -49,1 +49,1 @@\n-         _constants(constantPoolHandle(Thread::current(), klass->constants())), _multifield_info(klass->multifield_info()),_index(0),\n+         _constants(constantPoolHandle(Thread::current(), klass->constants())), _index(0),\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -167,8 +167,0 @@\n-  FieldInfo* MultiFieldInfo::base_field_info(InstanceKlass* ik) {\n-    return ik->field(_base_index);\n-  }\n-\n-  void MultiFieldInfo::metaspace_pointers_do(MetaspaceClosure* it) {\n-    it->push(&_name);\n-  }\n-\n@@ -551,1 +543,0 @@\n-  _multifield_info(NULL),\n@@ -757,4 +748,0 @@\n-  if (_multifield_info != NULL && !_multifield_info->is_shared()) {\n-    MetadataFactory::free_array<MultiFieldInfo>(loader_data, _multifield_info);\n-  }\n-\n@@ -2663,3 +2650,0 @@\n-  if(_multifield_info != NULL) {\n-    it->push(&_multifield_info);\n-  }\n@@ -2716,1 +2700,1 @@\n-    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(fields(), constants()); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -135,16 +135,0 @@\n-class MultiFieldInfo : public MetaspaceObj {\n- private:\n-  Symbol* _name;\n-  u2 _base_index;\n-  jbyte _multifield_index;\n- public:\n-  MultiFieldInfo() : _name(NULL), _base_index(0), _multifield_index(-1) {}\n-  MultiFieldInfo(Symbol* name, u2 base, jbyte index) : _name(name), _base_index(base), _multifield_index(index) {}\n-  Symbol* name() const { return _name; }\n-  u2 base_index() const { return _base_index; }\n-  jbyte multifield_index() const { return _multifield_index; }\n-  FieldInfo* base_field_info(InstanceKlass* ik);\n-  void metaspace_pointers_do(MetaspaceClosure* it);\n-  MetaspaceObj::Type type() const { return MultiFieldInfoType; }\n-};\n-\n@@ -241,3 +225,0 @@\n-  \/\/ Array containing meta-data generated for multifields\n-  Array<MultiFieldInfo>* _multifield_info;\n-\n@@ -544,1 +525,0 @@\n-  friend class MultiFieldInfo;\n@@ -550,1 +530,1 @@\n-  Symbol* field_name        (int index) const { return field(index)->name(multifield_info(), constants()); }\n+  Symbol* field_name        (int index) const { return field(index)->name(constants()); }\n@@ -565,11 +545,0 @@\n-  Array<MultiFieldInfo>* multifield_info() const { return _multifield_info; }\n-\n-  MultiFieldInfo multifield_info(int i) const {\n-    guarantee(_multifield_info != NULL, \"Just checking\");\n-    return _multifield_info->at(i);\n-  }\n-  void set_multifield_info(Array<MultiFieldInfo>* array) {\n-    assert(_multifield_info == NULL, \"Must be initialized only once\");\n-    _multifield_info = array;\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -115,2 +115,1 @@\n-  \/\/ assert to be extended to allow multifield names\n-  guarantee(\/*f->name_index() != 0 &&*\/ f->signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n+  guarantee(f->name_index() != 0 && f->signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -98,3 +98,0 @@\n-  inline bool is_multifield()            const;\n-  inline u2   multifield_base()          const;\n-  inline jbyte multifield_index()        const;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  return field()->name(field_holder()->multifield_info(),  _cp());\n+  return field()->name(_cp());\n@@ -88,4 +88,0 @@\n-inline bool fieldDescriptor::is_multifield() const { return field()->is_multifield(); };\n-inline u2   fieldDescriptor::multifield_base() const { return field_holder()->multifield_info(field()->secondary_index()).base_index(); }\n-inline jbyte fieldDescriptor::multifield_index() const { return  field_holder()->multifield_info(field()->secondary_index()).multifield_index(); }\n-\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n-* Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-*\n-* This code is free software; you can redistribute it and\/or modify it\n-* under the terms of the GNU General Public License version 2 only, as\n-* published by the Free Software Foundation.  Oracle designates this\n-* particular file as subject to the \"Classpath\" exception as provided\n-* by Oracle in the LICENSE file that accompanied this code.\n-*\n-* This code is distributed in the hope that it will be useful, but WITHOUT\n-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-* version 2 for more details (a copy is included in the LICENSE file that\n-* accompanied this code).\n-*\n-* You should have received a copy of the GNU General Public License version\n-* 2 along with this work; if not, write to the Free Software Foundation,\n-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-*\n-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-* or visit www.oracle.com if you need additional information or have any\n-* questions.\n-*\/\n-\n-package jdk.internal.vm.annotation;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-\/**\n-* <p>An annotation expressing that the field has to be\n-* replicated several times and all replication must be\n-* layed out contiguously in memory. The annotation is\n-* ignored if the type of the field is not one of the\n-* eight Java basic primitive types: boolean, byte, short,\n-* char, int, long, float, double.\n-*\/\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target({ElementType.FIELD})\n-public @interface MultiField {\n-\n-   \/**\n-    * The total number of fields (initial plus replicated).\n-    * This tag is only meaningful for field level annotations.\n-    *\n-    * @return total number of fields to layout.\n-    *\/\n-   byte value() default 0;\n-}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/MultiField.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"}]}