{"files":[{"patch":"@@ -1012,0 +1012,1 @@\n+    _jdk_internal_vm_annotation_MultiField,\n@@ -1018,0 +1019,1 @@\n+  jbyte _multifield_arg;\n@@ -1044,0 +1046,3 @@\n+  void set_multifield_arg(jbyte arg) { _multifield_arg = arg; }\n+  jbyte multifield_arg() const { return _multifield_arg; }\n+\n@@ -1045,0 +1050,1 @@\n+  bool is_multifield_base() const { return has_annotation(_jdk_internal_vm_annotation_MultiField); }\n@@ -1184,0 +1190,3 @@\n+    b_tag_val = 'B',\n+    b_con_off = 7,\n+    b_size = 9,\n@@ -1230,0 +1239,9 @@\n+    } else if (AnnotationCollector::_jdk_internal_vm_annotation_MultiField == id) {\n+      \/\/ TODO: change those assertion into a conditional statement to process the value\n+      assert(count == 1, \"MultiField annotation must have at least one argument\");  \/\/ Is it true?\n+      assert(member == vmSymbols::value_name(), \"Must be\");\n+      assert(b_tag_val == *(abase + tag_off), \"Must be a byte value\");\n+      int arg_index = Bytes::get_Java_u2((address)abase + b_con_off);\n+      int multifield_arg = cp->int_at(arg_index);\n+      assert(((jbyte)multifield_arg) == multifield_arg, \"Must be\");\n+      coll->set_multifield_arg(multifield_arg);\n@@ -1549,3 +1567,9 @@\n-  u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,\n-                                              u2,\n-                                              total_fields * (FieldInfo::field_slots + 1));\n+\n+  GrowableArray<FieldInfo>* temp_fieldinfo = new GrowableArray<FieldInfo>(total_fields, mtNone);\n+  GrowableArray<u2>* temp_generic_signature = new GrowableArray<u2>(total_fields, mtNone);\n+  GrowableArray<MultiFieldInfo>* temp_multifield_info = new GrowableArray<MultiFieldInfo>(0, mtNone); \/\/ could be allocated lazily\n+  FieldInfo fi;\n+  FieldInfo* f = &fi;\n+  GrowableArray<AnnotationArray*>* fields_annotations = NULL;\n+  GrowableArray<AnnotationArray*>* fields_type_annotations = NULL;\n+\n@@ -1555,1 +1579,0 @@\n-  int num_generic_signature = 0;\n@@ -1557,0 +1580,2 @@\n+  int inj_multifields = 0;\n+  int field_index = -1;\n@@ -1558,0 +1583,1 @@\n+    field_index++;\n@@ -1602,4 +1628,2 @@\n-        if (_fields_annotations == NULL) {\n-          _fields_annotations = MetadataFactory::new_array<AnnotationArray*>(\n-                                             _loader_data, length, NULL,\n-                                             CHECK);\n+        if (fields_annotations == NULL) {\n+          fields_annotations = new GrowableArray<AnnotationArray*>(length, mtNone);\n@@ -1607,1 +1631,2 @@\n-        _fields_annotations->at_put(n, parsed_annotations.field_annotations());\n+\n+        fields_annotations->at_put_grow(field_index, parsed_annotations.field_annotations(), NULL);\n@@ -1611,6 +1636,2 @@\n-        if (_fields_type_annotations == NULL) {\n-          _fields_type_annotations =\n-            MetadataFactory::new_array<AnnotationArray*>(_loader_data,\n-                                                         length,\n-                                                         NULL,\n-                                                         CHECK);\n+        if (fields_type_annotations == NULL) {\n+          fields_type_annotations = new GrowableArray<AnnotationArray*>(length, mtNone);\n@@ -1618,1 +1639,1 @@\n-        _fields_type_annotations->at_put(n, parsed_annotations.field_type_annotations());\n+        fields_type_annotations->at_put_grow(field_index, parsed_annotations.field_type_annotations(), NULL);\n@@ -1627,1 +1648,1 @@\n-        fa[generic_signature_slot] = generic_signature_index;\n+        temp_generic_signature->append(generic_signature_index);\n@@ -1629,1 +1650,0 @@\n-        num_generic_signature ++;\n@@ -1633,2 +1653,1 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, n);\n-    field->initialize(access_flags.as_short(),\n+    f->initialize(access_flags.as_short(),\n@@ -1638,0 +1657,3 @@\n+    int base_idx = temp_fieldinfo->append(fi);\n+    assert(base_idx == field_index, \"Must be\");\n+    FieldInfo* const field = temp_fieldinfo->adr_at(field_index);\n@@ -1650,0 +1672,33 @@\n+\n+    if (parsed_annotations.is_multifield_base() && is_java_primitive(cp->basic_type_for_signature_at(signature_index))) {\n+      field->set_multifield_base(true);\n+      char* base_name = cp->symbol_at(name_index)->as_C_string();\n+      for (int i = 1; i < parsed_annotations.multifield_arg(); i++) {\n+        field_index++;\n+        stringStream st;\n+        st.print(\"%s\", base_name);\n+        st.print(\"#\");\n+        st.print(\"%d\", i);\n+        Symbol* inj_name = SymbolTable::new_symbol(st.as_string());\n+        MultiFieldInfo mfi(inj_name, base_idx, i);\n+        int mfi_idx = temp_multifield_info->append(mfi);\n+        f->initialize(access_flags.as_short(),\n+                      mfi_idx,\n+                      signature_index,\n+                      constantvalue_index);\n+        int inj_idx = temp_fieldinfo->append(fi);\n+        assert(inj_idx == field_index, \"Must be\");\n+        FieldInfo* const field = temp_fieldinfo->adr_at(inj_idx);\n+        const BasicType type = cp->basic_type_for_signature_at(signature_index);\n+        \/\/ Update FieldAllocationCount for this kind of field\n+        fac->update(is_static, type, type == T_PRIMITIVE_OBJECT);\n+        field->set_multifield(true);\n+        if (fields_annotations != NULL && fields_annotations->at(base_idx) != NULL) {\n+          fields_annotations->at_put_grow(field_index, fields_annotations->at(base_idx));\n+        }\n+        if (fields_type_annotations != NULL && fields_type_annotations->at(base_idx) != NULL) {\n+          fields_type_annotations->at_put_grow(field_index, fields_type_annotations->at(base_idx));\n+        }\n+        inj_multifields++;\n+      }\n+    }\n@@ -1652,1 +1707,2 @@\n-  int index = length;\n+  *java_fields_count_ptr = *java_fields_count_ptr + inj_multifields;\n+  int index = length + inj_multifields;\n@@ -1661,1 +1717,1 @@\n-          const FieldInfo* const f = FieldInfo::from_field_array(fa, i);\n+          const FieldInfo* const f = temp_fieldinfo->adr_at(i);\n@@ -1670,1 +1726,0 @@\n-          \/\/ These will be removed from the field array at the end\n@@ -1676,2 +1731,1 @@\n-      FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-      field->initialize((u2)JVM_ACC_FIELD_INTERNAL,\n+      f->initialize((u2)JVM_ACC_FIELD_INTERNAL,\n@@ -1681,0 +1735,3 @@\n+      field_index++;\n+      int inj_idx = temp_fieldinfo->append(fi);\n+      assert(inj_idx == field_index, \"Must be\");\n@@ -1691,2 +1748,1 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-    field->initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,\n+    f->initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,\n@@ -1696,0 +1752,3 @@\n+    field_index++;\n+    int inj_idx = temp_fieldinfo->append(fi);\n+    assert(inj_idx == field_index, \"Must be\");\n@@ -1703,2 +1762,1 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-    field->initialize(JVM_ACC_FIELD_INTERNAL,\n+    f->initialize(JVM_ACC_FIELD_INTERNAL,\n@@ -1708,0 +1766,3 @@\n+    field_index++;\n+    int inj_idx = temp_fieldinfo->append(fi);\n+    assert(inj_idx == field_index, \"Must be\");\n@@ -1718,0 +1779,2 @@\n+  assert(index == field_index + 1, \"Must be\");\n+  assert(temp_fieldinfo->length() == field_index + 1, \"Must be\");\n@@ -1721,1 +1784,1 @@\n-                                   index * FieldInfo::field_slots + num_generic_signature,\n+                                   temp_fieldinfo->length() * FieldInfo::field_slots + temp_generic_signature->length(),\n@@ -1729,2 +1792,5 @@\n-    for (; i < index * FieldInfo::field_slots; i++) {\n-      _fields->at_put(i, fa[i]);\n+    for (i = 0; i < index; i++) {\n+      u2* adr = (u2*)temp_fieldinfo->adr_at(i);\n+      for (int j = 0; j < FieldInfo::field_slots; j++) {\n+        _fields->at_put(i * FieldInfo::field_slots + j, adr[j]);\n+      }\n@@ -1732,3 +1798,3 @@\n-    for (int j = total_fields * FieldInfo::field_slots;\n-         j < generic_signature_slot; j++) {\n-      _fields->at_put(i++, fa[j]);\n+    i = index * FieldInfo::field_slots;\n+    for (int j = 0; j < temp_generic_signature->length(); j++) {\n+      _fields->at_put(i++, temp_generic_signature->at(j));\n@@ -1736,0 +1802,1 @@\n+\n@@ -1739,0 +1806,25 @@\n+  if (temp_multifield_info->length() > 0) {\n+    _multifield_info = MetadataFactory::new_array<MultiFieldInfo>(_loader_data, temp_multifield_info->length(), CHECK);\n+    for (int i = 0; i < temp_multifield_info->length(); i++) {\n+      _multifield_info->at_put(i, temp_multifield_info->at(i));\n+    }\n+  }\n+\n+  if (fields_annotations != NULL) {\n+    _fields_annotations = MetadataFactory::new_array<AnnotationArray*>(\n+                                             _loader_data, temp_fieldinfo->length(), NULL,\n+                                             CHECK);\n+    for (int i = 0; i < fields_annotations->length(); i++) {\n+      _fields_annotations->at_put(i, fields_annotations->at(i));\n+    }\n+  }\n+\n+  if (fields_type_annotations != NULL) {\n+     _fields_type_annotations = MetadataFactory::new_array<AnnotationArray*>(\n+                                             _loader_data, temp_fieldinfo->length(), NULL,\n+                                             CHECK);\n+    for (int i = 0; i < fields_type_annotations->length(); i++) {\n+      _fields_type_annotations->at_put(i, fields_type_annotations->at(i));\n+    }\n+  }\n+\n@@ -1750,1 +1842,1 @@\n-      for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n+      for (AllFieldStream fs(_fields, cp, _multifield_info); !fs.done(); fs.next()) {\n@@ -2125,0 +2217,5 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_MultiField_signature): {\n+      if (_location != _in_field) break;  \/\/ only allow for fields\n+      if (!privileged)            break;  \/\/ honor privileges\n+      return _jdk_internal_vm_annotation_MultiField;\n+    }\n@@ -4196,0 +4293,1 @@\n+  this_klass->set_multifield_info(_multifield_info);\n@@ -5685,0 +5783,1 @@\n+  assert(NULL == _multifield_info, \"invariant\");\n@@ -5826,1 +5925,1 @@\n-  for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n@@ -5960,0 +6059,1 @@\n+  _multifield_info(NULL),\n@@ -6045,0 +6145,1 @@\n+  _multifield_info = NULL;\n@@ -6058,0 +6159,4 @@\n+  if (_multifield_info != NULL) {\n+    MetadataFactory::free_array<MultiFieldInfo>(_loader_data, _multifield_info);\n+  }\n+\n@@ -6555,1 +6660,1 @@\n-    for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(_fields, cp, _multifield_info); !fs.done(); fs.next()) {\n@@ -6578,1 +6683,1 @@\n-      _field_info, _inline_type_field_klasses);\n+      _field_info, _inline_type_field_klasses, _multifield_info);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":144,"deletions":39,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+  Array<MultiFieldInfo>* _multifield_info;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-  _is_reference(false) {\n+  _is_reference(false),\n+  _multifield_index(-1) {\n@@ -56,1 +57,1 @@\n-LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference) :\n+LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference, jbyte multifield_index) :\n@@ -65,2 +66,3 @@\n- _is_reference(is_reference) {\n-  assert(kind == REGULAR || kind == INLINED || kind == INHERITED,\n+ _is_reference(is_reference),\n+ _multifield_index(multifield_index) {\n+  assert(kind == REGULAR || kind == INLINED || kind == INHERITED || kind == MULTIFIELD,\n@@ -85,0 +87,1 @@\n+  _multifields(NULL),\n@@ -90,1 +93,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false);\n+  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false, -1);\n@@ -100,1 +103,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true);\n+  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true, -1);\n@@ -109,1 +112,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INLINED, vk->get_exact_size_in_bytes(), vk->get_alignment(), false);\n+  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INLINED, vk->get_exact_size_in_bytes(), vk->get_alignment(), false, -1);\n@@ -118,0 +121,24 @@\n+void FieldGroup::add_multifield(AllFieldStream fs, Array<MultiFieldInfo>* multifield_info, InlineKlass* vk) {\n+  assert(fs.is_multifield() || fs.is_multifield_base(), \"Must be\");\n+  u2 base = fs.multifield_base();\n+  BasicType type = Signature::basic_type(fs.signature());\n+  MultiFieldGroup* mfg = NULL;\n+  if (_multifields != NULL) {\n+    for (int i = 0; i < _multifields->length(); i++) {\n+      if (base == _multifields->at(i)->multifield_base()) {\n+        mfg = _multifields->at(i);\n+        break;\n+      }\n+    }\n+  } else {\n+    _multifields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<MultiFieldGroup*>(8);\n+  }\n+  if (mfg == NULL) {\n+    mfg = new(ResourceObj::RESOURCE_AREA, mtInternal) MultiFieldGroup(base, fs.signature());\n+    mfg->add_field(fs, vk);\n+    _multifields->append(mfg);\n+  } else {\n+    mfg->add_field(fs, vk);\n+  }\n+}\n+\n@@ -125,0 +152,16 @@\n+  if (_multifields != NULL) {\n+    for (int i = 0; i < _multifields->length(); i++) {\n+      int size = _multifields->at(i)->fields()->at(0)->size();\n+      int alignment =  _multifields->at(i)->fields()->at(0)->alignment();\n+      int multialignment = size\/alignment;\n+      if (size % multialignment != 0) multialignment+= alignment;\n+      \/\/ Problem: at this point, multialignment can be a weird number, for instance not a power of two\n+      int multisize = multialignment * alignment * _multifields->at(i)->fields()->length();  \/\/ should be stored\n+      \/\/ True alignment should be adjusted to increase chances to be on a single cache line\n+      int multifield_group_alignment = MIN2(round_up_power_of_2(multisize), HeapWordSize);\n+      _multifields->at(i)->set_group_size(multisize);\n+      _multifields->at(i)->set_group_alignment(multifield_group_alignment);\n+      _multifields->at(i)->fields()->sort(MultiFieldGroup::compare_multifield_index);\n+    }\n+    _multifields->sort(MultiFieldGroup::compare_multifield_groups_inverted);\n+  }\n@@ -141,1 +184,29 @@\n-FieldLayout::FieldLayout(Array<u2>* fields, ConstantPool* cp) :\n+MultiFieldGroup::MultiFieldGroup(u2 base, Symbol* signature) :  _multifield_base(base), _signature(signature), _fields(NULL) { }\n+\n+void MultiFieldGroup::add_field(AllFieldStream fs, InlineKlass* vk) {\n+  assert(fs.is_multifield() || fs.is_multifield_base(), \"Must be\");\n+  assert(fs.multifield_base() == multifield_base(), \"multifield base mismatch\");\n+  jbyte idx = fs.multifield_index();\n+  if (_fields == NULL) {\n+    _fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray<LayoutRawBlock*>(8);\n+  } else {\n+    guarantee(fs.signature() == signature(), \"multifield signature mismatch\");\n+  }\n+  BasicType type = Signature::basic_type(fs.signature());\n+  LayoutRawBlock* block = NULL;\n+  if (type == T_PRIMITIVE_OBJECT) {\n+    block = new LayoutRawBlock(fs.index(), LayoutRawBlock::MULTIFIELD, vk->get_exact_size_in_bytes(),\n+                               vk->get_alignment(), false, fs.multifield_index());\n+  } else {\n+    int size = type2aelembytes(type);\n+    block = new LayoutRawBlock(fs.index(), LayoutRawBlock::MULTIFIELD, size, size, false, fs.multifield_index());\n+  }\n+  int cursor = 0;\n+  for (; cursor < _fields->length(); cursor++) {\n+    assert(_fields->at(cursor)->multifield_index() != fs.multifield_index(), \"multifield index duplicate found\");\n+    if (_fields->at(cursor)->multifield_index() > fs.multifield_index()) break;\n+  }\n+  _fields->insert_before(cursor, block);\n+}\n+\n+FieldLayout::FieldLayout(Array<u2>* fields, ConstantPool* cp, Array<MultiFieldInfo>* multifields) :\n@@ -144,0 +215,1 @@\n+  _multifield_info(multifields),\n@@ -187,1 +259,2 @@\n-         && block->kind() != LayoutRawBlock::INLINED) {\n+         && block->kind() != LayoutRawBlock::INLINED\n+         && block->kind() != LayoutRawBlock::MULTIFIELD) {\n@@ -316,0 +389,31 @@\n+void FieldLayout::add_multifield(MultiFieldGroup* multifield_group, LayoutRawBlock* start) {\n+  if (start == NULL) {\n+    start = _start;\n+  }\n+  LayoutRawBlock* candidate = NULL;\n+  if (start == last_block()) {\n+    candidate = last_block();\n+  } else {\n+    candidate = last_block()->prev_block();\n+    while (candidate->kind() != LayoutRawBlock::EMPTY || !candidate->fit(multifield_group->group_size(), multifield_group->group_alignment())) {\n+      if (candidate == start) {\n+        candidate = last_block();\n+        break;\n+      }\n+      candidate = candidate->prev_block();\n+    }\n+    assert(candidate != NULL, \"Candidate must not be null\");\n+    assert(candidate->kind() == LayoutRawBlock::EMPTY, \"Candidate must be an empty block\");\n+  }\n+  if ((candidate->offset() % multifield_group->group_alignment()) != 0) {\n+    int adjustment = multifield_group->group_alignment() - (candidate->offset() % multifield_group->group_alignment());\n+    LayoutRawBlock* adj = new LayoutRawBlock(LayoutRawBlock::EMPTY, adjustment);\n+    insert(candidate, adj);\n+  }\n+  assert(candidate->fit(multifield_group->group_size(), multifield_group->group_alignment()), \"Candidate must be able to store the whole contiguous block\");\n+  for (int i = 0; i < multifield_group->fields()->length(); i++) {\n+    LayoutRawBlock* b = multifield_group->fields()->at(i);\n+    insert_field_block(candidate, b);\n+  }\n+}\n+\n@@ -335,1 +439,1 @@\n-    for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik->fields(), ik->constants(), ik->multifield_info()); !fs.done(); fs.next()) {\n@@ -344,1 +448,1 @@\n-                                   vk->get_alignment(), false);\n+                                   vk->get_alignment(), false, -1);\n@@ -349,1 +453,1 @@\n-        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false);\n+        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false, -1);\n@@ -473,1 +577,1 @@\n-                       fi->name(_cp)->as_C_string(),\n+                       fi->name(_multifield_info, _cp)->as_C_string(),\n@@ -484,1 +588,1 @@\n-                       fi->name(_cp)->as_C_string(),\n+                       fi->name(_multifield_info, _cp)->as_C_string(),\n@@ -504,1 +608,1 @@\n-        for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+        for (AllFieldStream fs(ik->fields(), ik->constants(), ik->multifield_info()); !fs.done(); fs.next()) {\n@@ -533,0 +637,10 @@\n+    case LayoutRawBlock::MULTIFIELD:\n+      FieldInfo* fi = FieldInfo::from_field_array(_fields, b->field_index());\n+      output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+                       b->offset(),\n+                       fi->name(_multifield_info, _cp)->as_C_string(),\n+                       fi->signature(_cp)->as_C_string(),\n+                       b->size(),\n+                       b->alignment(),\n+                       \"MULTIFIELD\");\n+      break;\n@@ -540,1 +654,2 @@\n-                                       FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses) :\n+                                       FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses,\n+                                       Array<MultiFieldInfo>* multifields) :\n@@ -547,0 +662,1 @@\n+  _multifield_info(multifields),\n@@ -548,1 +664,1 @@\n-  _contended_groups(GrowableArray<FieldGroup*>(8)),\n+  _contended_groups(GrowableArray<FieldGroup*>(0)),\n@@ -578,1 +694,1 @@\n-  _layout = new FieldLayout(_fields, _constant_pool);\n+  _layout = new FieldLayout(_fields, _constant_pool, _multifield_info);\n@@ -584,1 +700,1 @@\n-  _static_layout = new FieldLayout(_fields, _constant_pool);\n+  _static_layout = new FieldLayout(_fields, _constant_pool, _multifield_info);\n@@ -597,1 +713,1 @@\n-  for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(_fields, _constant_pool, _multifield_info); !fs.done(); fs.next()) {\n@@ -618,49 +734,18 @@\n-    switch(type) {\n-    case T_BYTE:\n-    case T_CHAR:\n-    case T_DOUBLE:\n-    case T_FLOAT:\n-    case T_INT:\n-    case T_LONG:\n-    case T_SHORT:\n-    case T_BOOLEAN:\n-      group->add_primitive_field(fs, type);\n-      break;\n-    case T_OBJECT:\n-    case T_ARRAY:\n-      if (group != _static_fields) _nonstatic_oopmap_count++;\n-      group->add_oop_field(fs);\n-      break;\n-    case T_PRIMITIVE_OBJECT:\n-      _has_inline_type_fields = true;\n-      if (group == _static_fields) {\n-        \/\/ static fields are never inlined\n-        group->add_oop_field(fs);\n-      } else {\n-        _has_flattening_information = true;\n-        \/\/ Flattening decision to be taken here\n-        \/\/ This code assumes all verification already have been performed\n-        \/\/ (field's type has been loaded and it is an inline klass)\n-        JavaThread* THREAD = JavaThread::current();\n-        Klass* klass =  _inline_type_field_klasses->at(fs.index());\n-        assert(klass != NULL, \"Sanity check\");\n-        InlineKlass* vk = InlineKlass::cast(klass);\n-        bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                   (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-        bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n-        bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n-        if (vk->is_naturally_atomic()) {\n-          too_atomic_to_flatten = false;\n-          \/\/too_volatile_to_flatten = false; \/\/FIXME\n-          \/\/ volatile fields are currently never inlined, this could change in the future\n-        }\n-        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n-          group->add_inlined_field(fs, vk);\n-          _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-          fs.set_inlined(true);\n-          if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-            _has_nonatomic_values = true;\n-            _atomic_field_count--;  \/\/ every other field is atomic but this one\n-          }\n-        } else {\n-          _nonstatic_oopmap_count++;\n+    bool has_multifield_annotation = false;\n+    if (fs.is_multifield() || fs.is_multifield_base()) {\n+      group->add_multifield(fs, _multifield_info);\n+    } else {\n+      switch(type) {\n+        case T_BYTE:\n+        case T_CHAR:\n+        case T_DOUBLE:\n+        case T_FLOAT:\n+        case T_INT:\n+        case T_LONG:\n+        case T_SHORT:\n+        case T_BOOLEAN:\n+          group->add_primitive_field(fs, type);\n+          break;\n+        case T_OBJECT:\n+        case T_ARRAY:\n+          if (group != _static_fields) _nonstatic_oopmap_count++;\n@@ -668,1 +753,40 @@\n-        }\n+          break;\n+        case T_PRIMITIVE_OBJECT:\n+          _has_inline_type_fields = true;\n+          if (group == _static_fields) {\n+            \/\/ static fields are never inlined\n+            group->add_oop_field(fs);\n+          } else {\n+            _has_flattening_information = true;\n+            \/\/ Flattening decision to be taken here\n+            \/\/ This code assumes all verification already have been performed\n+            \/\/ (field's type has been loaded and it is an inline klass)\n+            JavaThread* THREAD = JavaThread::current();\n+            Klass* klass =  _inline_type_field_klasses->at(fs.index());\n+            assert(klass != NULL, \"Sanity check\");\n+            InlineKlass* vk = InlineKlass::cast(klass);\n+            bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                      (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+            bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+            bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n+            if (vk->is_naturally_atomic()) {\n+              too_atomic_to_flatten = false;\n+              \/\/too_volatile_to_flatten = false; \/\/FIXME\n+              \/\/ volatile fields are currently never inlined, this could change in the future\n+            }\n+            if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n+              group->add_inlined_field(fs, vk);\n+              _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+              fs.set_inlined(true);\n+              if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+                _has_nonatomic_values = true;\n+                _atomic_field_count--;  \/\/ every other field is atomic but this one\n+              }\n+            } else {\n+              _nonstatic_oopmap_count++;\n+              group->add_oop_field(fs);\n+            }\n+          }\n+          break;\n+        default:\n+          fatal(\"Something wrong?\");\n@@ -670,3 +794,0 @@\n-      break;\n-    default:\n-      fatal(\"Something wrong?\");\n@@ -698,1 +819,1 @@\n-  for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(_fields, _constant_pool, _multifield_info); !fs.done(); fs.next()) {\n@@ -710,53 +831,23 @@\n-    switch(type) {\n-    case T_BYTE:\n-    case T_CHAR:\n-    case T_DOUBLE:\n-    case T_FLOAT:\n-    case T_INT:\n-    case T_LONG:\n-    case T_SHORT:\n-    case T_BOOLEAN:\n-      if (group != _static_fields) {\n-        field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n-      }\n-      group->add_primitive_field(fs, type);\n-      break;\n-    case T_OBJECT:\n-    case T_ARRAY:\n-      if (group != _static_fields) {\n-        _nonstatic_oopmap_count++;\n-        field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n-      }\n-      group->add_oop_field(fs);\n-      break;\n-    case T_PRIMITIVE_OBJECT: {\n-\/\/      fs.set_inline(true);\n-      _has_inline_type_fields = true;\n-      if (group == _static_fields) {\n-        \/\/ static fields are never inlined\n-        group->add_oop_field(fs);\n-      } else {\n-        \/\/ Flattening decision to be taken here\n-        \/\/ This code assumes all verifications have already been performed\n-        \/\/ (field's type has been loaded and it is an inline klass)\n-        JavaThread* THREAD = JavaThread::current();\n-        Klass* klass =  _inline_type_field_klasses->at(fs.index());\n-        assert(klass != NULL, \"Sanity check\");\n-        InlineKlass* vk = InlineKlass::cast(klass);\n-        bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                   (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-        bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n-        bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n-        if (vk->is_naturally_atomic()) {\n-          too_atomic_to_flatten = false;\n-          \/\/too_volatile_to_flatten = false; \/\/FIXME\n-          \/\/ volatile fields are currently never inlined, this could change in the future\n-        }\n-        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n-          group->add_inlined_field(fs, vk);\n-          _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-          field_alignment = vk->get_alignment();\n-          fs.set_inlined(true);\n-          if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-            _has_nonatomic_values = true;\n-            _atomic_field_count--;  \/\/ every other field is atomic but this one\n+    bool has_multifield_annotation = false;\n+    if (fs.is_multifield() || fs.is_multifield_base()) {\n+      group->add_multifield(fs, _multifield_info);\n+    } else {\n+      switch(type) {\n+        case T_BYTE:\n+        case T_CHAR:\n+        case T_DOUBLE:\n+        case T_FLOAT:\n+        case T_INT:\n+        case T_LONG:\n+        case T_SHORT:\n+        case T_BOOLEAN:\n+          if (group != _static_fields) {\n+            field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n+          }\n+          group->add_primitive_field(fs, type);\n+          break;\n+        case T_OBJECT:\n+        case T_ARRAY:\n+          if (group != _static_fields) {\n+            _nonstatic_oopmap_count++;\n+            field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n@@ -764,3 +855,0 @@\n-        } else {\n-          _nonstatic_oopmap_count++;\n-          field_alignment = type2aelembytes(T_OBJECT);\n@@ -768,0 +856,40 @@\n+          break;\n+        case T_PRIMITIVE_OBJECT: {\n+          \/\/      fs.set_inline(true);\n+          _has_inline_type_fields = true;\n+          if (group == _static_fields) {\n+            \/\/ static fields are never inlined\n+            group->add_oop_field(fs);\n+          } else {\n+            \/\/ Flattening decision to be taken here\n+            \/\/ This code assumes all verifications have already been performed\n+            \/\/ (field's type has been loaded and it is an inline klass)\n+            JavaThread* THREAD = JavaThread::current();\n+            Klass* klass =  _inline_type_field_klasses->at(fs.index());\n+            assert(klass != NULL, \"Sanity check\");\n+            InlineKlass* vk = InlineKlass::cast(klass);\n+            bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                      (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+            bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+            bool too_volatile_to_flatten = fs.access_flags().is_volatile();\n+            if (vk->is_naturally_atomic()) {\n+              too_atomic_to_flatten = false;\n+              \/\/too_volatile_to_flatten = false; \/\/FIXME\n+              \/\/ volatile fields are currently never inlined, this could change in the future\n+            }\n+            if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fs.access_flags().is_final()) {\n+              group->add_inlined_field(fs, vk);\n+              _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+              field_alignment = vk->get_alignment();\n+              fs.set_inlined(true);\n+              if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+                _has_nonatomic_values = true;\n+                _atomic_field_count--;  \/\/ every other field is atomic but this one\n+              }\n+            } else {\n+              _nonstatic_oopmap_count++;\n+              field_alignment = type2aelembytes(T_OBJECT);\n+              group->add_oop_field(fs);\n+            }\n+          }\n+          break;\n@@ -769,0 +897,2 @@\n+        default:\n+          fatal(\"Unexpected BasicType\");\n@@ -770,4 +900,0 @@\n-      break;\n-    }\n-    default:\n-      fatal(\"Unexpected BasicType\");\n@@ -777,0 +903,8 @@\n+  _root_group->sort_by_size();\n+  if (_root_group->multifields() != NULL) {\n+    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n+      if (_root_group->multifields()->at(i)->group_alignment() > alignment) {\n+        alignment = _root_group->multifields()->at(i)->group_alignment();\n+      }\n+    }\n+  }\n@@ -812,0 +946,5 @@\n+  if (_root_group->multifields() != NULL) {\n+    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n+      _layout->add_multifield(_root_group->multifields()->at(i));\n+    }\n+  }\n@@ -821,1 +960,6 @@\n-      _layout->add(cg->big_primitive_fields());\n+      if (cg->multifields() != NULL) {\n+        for (int i = 0; i < cg->multifields()->length(); i++) {\n+          _layout->add_multifield(cg->multifields()->at(i), start);\n+        }\n+      }\n+      _layout->add(cg->big_primitive_fields(), start);\n@@ -833,0 +977,5 @@\n+  if (_static_fields->multifields() != NULL) {\n+    for (int i = 0; i < _static_fields->multifields()->length(); i++) {\n+      _layout->add_multifield(_static_fields->multifields()->at(i));\n+    }\n+  }\n@@ -866,0 +1015,5 @@\n+  if (_root_group->multifields() != NULL) {\n+    for (int i = 0; i < _root_group->multifields()->length(); i++) {\n+      _layout->add_multifield(_root_group->multifields()->at(i));\n+    }\n+  }\n@@ -879,1 +1033,0 @@\n-  _exact_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":289,"deletions":136,"binary":false,"changes":425,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-    INHERITED         \/\/ field(s) inherited from super classes\n+    INHERITED,        \/\/ field(s) inherited from super classes\n+    MULTIFIELD        \/\/ fields part of a multi-field\n@@ -74,0 +75,1 @@\n+  jbyte _multifield_index;\n@@ -77,1 +79,1 @@\n-  LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference = false);\n+  LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference, jbyte multifield_index);\n@@ -96,0 +98,1 @@\n+  jbyte multifield_index() const { return _multifield_index; }\n@@ -123,1 +126,33 @@\n-\/\/ A Field group represents a set of fields that have to be allocated together,\n+class MultiFieldGroup : public ResourceObj {\n+ private:\n+  u2 _multifield_base;\n+  Symbol* _signature;\n+  int _group_size;\n+  int _group_alignment;\n+  GrowableArray<LayoutRawBlock*>* _fields;\n+  \/\/ total size and alignment?\n+\n+ public:\n+  MultiFieldGroup(u2 base, Symbol* signature);\n+\n+  u2 multifield_base() const { return _multifield_base; }\n+  Symbol* signature() const { return _signature; }\n+  int group_size() const { return _group_size; }\n+  void set_group_size(int size) { _group_size = size; }\n+  int group_alignment() const { return _group_alignment; }\n+  void set_group_alignment(int alignment) { _group_alignment = alignment; }\n+  GrowableArray<LayoutRawBlock*>* fields() const { return _fields; }\n+  void add_field(AllFieldStream fs, InlineKlass* vk);\n+    static int compare_multifield_index(LayoutRawBlock** x, LayoutRawBlock** y) {\n+     return (*x)->multifield_index() - (*y)->multifield_index();\n+  }\n+  static int compare_multifield_groups_inverted(MultiFieldGroup** x, MultiFieldGroup** y) {\n+    int diff = (*y)->group_size() - (*x)->group_size();\n+    if (diff == 0) {\n+      diff = (*y)->group_alignment() - (*x)->group_alignment();\n+    }\n+    return diff;\n+  }\n+};\n+\n+\/\/ A FieldGroup represents a set of fields that have to be allocated together,\n@@ -136,0 +171,1 @@\n+  GrowableArray<MultiFieldGroup*>* _multifields;\n@@ -148,0 +184,1 @@\n+  GrowableArray<MultiFieldGroup*>* multifields() const { return _multifields; }\n@@ -154,0 +191,1 @@\n+  void add_multifield(AllFieldStream fs, Array<MultiFieldInfo>* multifield_info, InlineKlass* vk = NULL);\n@@ -181,0 +219,1 @@\n+  Array<MultiFieldInfo>* _multifield_info;\n@@ -186,1 +225,1 @@\n-  FieldLayout(Array<u2>* fields, ConstantPool* cp);\n+  FieldLayout(Array<u2>* fields, ConstantPool* cp, Array<MultiFieldInfo>* multifields);\n@@ -208,0 +247,1 @@\n+  void add_multifield(MultiFieldGroup* multifield, LayoutRawBlock* start = NULL);\n@@ -248,0 +288,1 @@\n+  Array<MultiFieldInfo>* _multifield_info;\n@@ -266,0 +307,1 @@\n+  MultiFieldGroup* get_or_create_multifield_group(int base);\n@@ -269,1 +311,2 @@\n-      Array<u2>* fields, bool is_contended, bool is_inline_type, FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses);\n+      Array<u2>* fields, bool is_contended, bool is_inline_type, FieldLayoutInfo* info,\n+      Array<InlineKlass*>* inline_type_field_klasses, Array<MultiFieldInfo>* multifields);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1260,1 +1260,1 @@\n-    for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,0 +265,1 @@\n+  template(jdk_internal_vm_annotation_MultiField_signature,                  \"Ljdk\/internal\/vm\/annotation\/MultiField;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -311,1 +311,2 @@\n-  f(RecordComponent)\n+  f(RecordComponent) \\\n+  f(MultiFieldInfo)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  class   MultiFieldInfo;    \/\/ no C++ vtable\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-  jint int_at(int which) {\n+  jint int_at(int which) const {\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/fieldInfo.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+\n+Symbol* FieldInfo::get_multifield_name(Array<MultiFieldInfo>* multifield_info) const {\n+  assert(is_multifield(), \"Sanity check\");\n+  return multifield_info->at(secondary_index()).name();\n+}\n+\n+u2 FieldInfo::multifield_base(Array<MultiFieldInfo>* multifield_info) const {\n+  assert(is_multifield(), \"Sanity check\");\n+  return multifield_info->at(secondary_index()).base_index();\n+}\n+\n+jbyte FieldInfo::multifield_index(Array<MultiFieldInfo>* multifield_info) const {\n+  assert(is_multifield(), \"Sanity check\");\n+  return multifield_info->at(secondary_index()).multifield_index();\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -33,0 +33,2 @@\n+class MultiFieldInfo;\n+\n@@ -41,0 +43,1 @@\n+  friend class FieldStreamBase;\n@@ -43,0 +46,1 @@\n+  friend class FieldLayout;\n@@ -49,4 +53,6 @@\n-#define FIELDINFO_TAG_SIZE             3\n-#define FIELDINFO_TAG_OFFSET           (1 << 0)\n-#define FIELDINFO_TAG_CONTENDED        (1 << 1)\n-#define FIELDINFO_TAG_INLINED          (1 << 2)\n+#define FIELDINFO_TAG_SIZE             5\n+#define FIELDINFO_TAG_OFFSET           1 << 0\n+#define FIELDINFO_TAG_CONTENDED        1 << 1\n+#define FIELDINFO_TAG_INLINED          1 << 2\n+#define FIELDINFO_TAG_MULTIFIELD       1 << 3\n+#define FIELDINFO_TAG_MULTIFIELD_BASE  1 << 4\n@@ -58,3 +64,3 @@\n-  \/\/    ..........................................00  - non-contended field\n-  \/\/    [--contention_group--]...................I10  - contended field with contention group\n-  \/\/    [------------------offset---------------]I01  - real field offset\n+  \/\/    .......................................BMI00  - non-contended field\n+  \/\/    [--contention_group--].................B0I10  - contended field with contention group\n+  \/\/    [------------------offset-------------]BMI01  - real field offset\n@@ -66,0 +72,2 @@\n+  \/\/ Bit M indicates the field is an injected multifield\n+  \/\/ Bit B indicates the field is a multifield base field\n@@ -84,1 +92,1 @@\n-  u2 name_index() const                          { return _shorts[name_index_offset];        }\n+  u2 name_index() const                          { assert(!is_multifield(), \"wrong call\"); return _shorts[name_index_offset]; }\n@@ -87,0 +95,1 @@\n+  u2 secondary_index() const                     { assert( is_multifield(), \"wrong call\"); return _shorts[name_index_offset]; }\n@@ -118,0 +127,8 @@\n+  bool is_multifield() const {\n+    return (_shorts[low_packed_offset] & FIELDINFO_TAG_MULTIFIELD) != 0;\n+  }\n+\n+  bool is_multifield_base() const {\n+    return (_shorts[low_packed_offset] & FIELDINFO_TAG_MULTIFIELD_BASE) != 0;\n+  }\n+\n@@ -128,1 +145,6 @@\n-  Symbol* name(ConstantPool* cp) const {\n+  Symbol* get_multifield_name(Array<MultiFieldInfo>* multifield_info) const;\n+\n+  Symbol* name(Array<MultiFieldInfo>* multifield_info, ConstantPool* cp) const {\n+    if (is_multifield()) {\n+      return get_multifield_name(multifield_info);\n+    }\n@@ -148,0 +170,2 @@\n+    bool multifield = is_multifield();\n+    bool multifield_base = is_multifield_base();\n@@ -150,0 +174,2 @@\n+    if (multifield) set_multifield(true);\n+    if (multifield_base) set_multifield_base(true);\n@@ -173,0 +199,19 @@\n+  void set_multifield(bool b) {\n+    if (b) {\n+      _shorts[low_packed_offset] |= FIELDINFO_TAG_MULTIFIELD;\n+    } else {\n+      _shorts[low_packed_offset] &= ~FIELDINFO_TAG_MULTIFIELD;\n+    }\n+  }\n+\n+  void set_multifield_base(bool b) {\n+    if (b) {\n+      _shorts[low_packed_offset] |= FIELDINFO_TAG_MULTIFIELD_BASE;\n+    } else {\n+      _shorts[low_packed_offset] &= ~FIELDINFO_TAG_MULTIFIELD_BASE;\n+    }\n+  }\n+\n+  u2 multifield_base(Array<MultiFieldInfo>* multifield_info) const;\n+  jbyte multifield_index(Array<MultiFieldInfo>* multifield_info) const;\n+\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":54,"deletions":9,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  Array<MultiFieldInfo>* _multifield_info;\n@@ -82,1 +83,1 @@\n-  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants, int start, int limit);\n+  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info, int start, int limit );\n@@ -84,1 +85,1 @@\n-  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants);\n+  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info);\n@@ -117,1 +118,5 @@\n-    return field()->name(_constants());\n+    return field()->name(_multifield_info, _constants());\n+  }\n+\n+  int name_index() const {\n+    return field()->name_index();\n@@ -158,0 +163,26 @@\n+  bool is_multifield() const {\n+    return field()->is_multifield();\n+  }\n+\n+  bool is_multifield_base() const {\n+    return field()->is_multifield_base();\n+  }\n+\n+  u2 multifield_base() const {\n+    assert(field()->is_multifield() || field()->is_multifield_base(), \"Must be\");\n+    if (field()->is_multifield_base()) {\n+      return index();\n+    } else {\n+      return _multifield_info->at(field()->secondary_index()).base_index();\n+    }\n+  }\n+\n+  jbyte multifield_index() const {\n+    assert(field()->is_multifield() || field()->is_multifield_base(), \"Must be\");\n+    if (field()->is_multifield_base()) {\n+      return 0;\n+    } else {\n+      return _multifield_info->at(field()->secondary_index()).multifield_index();\n+    }\n+  }\n+\n@@ -173,1 +204,1 @@\n-  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fields(), k->constants(), 0, k->java_fields_count()) {}\n+  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fields(), k->constants(), k->multifield_info(), 0, k->java_fields_count()) {}\n@@ -221,1 +252,1 @@\n-  InternalFieldStream(InstanceKlass* k):      FieldStreamBase(k->fields(), k->constants(), k->java_fields_count(), 0) {}\n+  InternalFieldStream(InstanceKlass* k): FieldStreamBase(k->fields(), k->constants(), k->multifield_info(), k->java_fields_count(), 0) {}\n@@ -227,2 +258,2 @@\n-  AllFieldStream(Array<u2>* fields, ConstantPool* constants): FieldStreamBase(fields, constants) {}\n-  AllFieldStream(InstanceKlass* k):      FieldStreamBase(k->fields(), k->constants()) {}\n+  AllFieldStream(Array<u2>* fields, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info): FieldStreamBase(fields, constants, multifield_info) {}\n+  AllFieldStream(InstanceKlass* k):      FieldStreamBase(k->fields(), k->constants(), k->multifield_info()) {}\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":38,"deletions":7,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-FieldStreamBase::FieldStreamBase(Array<u2>* fields, ConstantPool* constants, int start, int limit) : _fields(fields),\n-         _constants(constantPoolHandle(Thread::current(), constants)), _index(start) {\n+FieldStreamBase::FieldStreamBase(Array<u2>* fields, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info, int start, int limit) : _fields(fields),\n+         _constants(constantPoolHandle(Thread::current(), constants)), _multifield_info(multifield_info), _index(start) {\n@@ -43,2 +43,2 @@\n-FieldStreamBase::FieldStreamBase(Array<u2>* fields, ConstantPool* constants) : _fields(fields),\n-         _constants(constantPoolHandle(Thread::current(), constants)), _index(0) {\n+FieldStreamBase::FieldStreamBase(Array<u2>* fields, ConstantPool* constants, Array<MultiFieldInfo>* multifield_info) : _fields(fields),\n+         _constants(constantPoolHandle(Thread::current(), constants)), _multifield_info(multifield_info), _index(0) {\n@@ -49,1 +49,1 @@\n-         _constants(constantPoolHandle(Thread::current(), klass->constants())), _index(0),\n+         _constants(constantPoolHandle(Thread::current(), klass->constants())), _multifield_info(klass->multifield_info()),_index(0),\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -167,0 +167,8 @@\n+  FieldInfo* MultiFieldInfo::base_field_info(InstanceKlass* ik) {\n+    return ik->field(_base_index);\n+  }\n+\n+  void MultiFieldInfo::metaspace_pointers_do(MetaspaceClosure* it) {\n+    it->push(&_name);\n+  }\n+\n@@ -543,0 +551,1 @@\n+  _multifield_info(NULL),\n@@ -748,0 +757,4 @@\n+  if (_multifield_info != NULL && !_multifield_info->is_shared()) {\n+    MetadataFactory::free_array<MultiFieldInfo>(loader_data, _multifield_info);\n+  }\n+\n@@ -2650,0 +2663,3 @@\n+  if(_multifield_info != NULL) {\n+    it->push(&_multifield_info);\n+  }\n@@ -2700,1 +2716,1 @@\n-    for (AllFieldStream fs(fields(), constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -135,0 +135,16 @@\n+class MultiFieldInfo : public MetaspaceObj {\n+ private:\n+  Symbol* _name;\n+  u2 _base_index;\n+  jbyte _multifield_index;\n+ public:\n+  MultiFieldInfo() : _name(NULL), _base_index(0), _multifield_index(-1) {}\n+  MultiFieldInfo(Symbol* name, u2 base, jbyte index) : _name(name), _base_index(base), _multifield_index(index) {}\n+  Symbol* name() const { return _name; }\n+  u2 base_index() const { return _base_index; }\n+  jbyte multifield_index() const { return _multifield_index; }\n+  FieldInfo* base_field_info(InstanceKlass* ik);\n+  void metaspace_pointers_do(MetaspaceClosure* it);\n+  MetaspaceObj::Type type() const { return MultiFieldInfoType; }\n+};\n+\n@@ -225,0 +241,3 @@\n+  \/\/ Array containing meta-data generated for multifields\n+  Array<MultiFieldInfo>* _multifield_info;\n+\n@@ -525,0 +544,1 @@\n+  friend class MultiFieldInfo;\n@@ -530,1 +550,1 @@\n-  Symbol* field_name        (int index) const { return field(index)->name(constants()); }\n+  Symbol* field_name        (int index) const { return field(index)->name(multifield_info(), constants()); }\n@@ -545,0 +565,11 @@\n+  Array<MultiFieldInfo>* multifield_info() const { return _multifield_info; }\n+\n+  MultiFieldInfo multifield_info(int i) const {\n+    guarantee(_multifield_info != NULL, \"Just checking\");\n+    return _multifield_info->at(i);\n+  }\n+  void set_multifield_info(Array<MultiFieldInfo>* array) {\n+    assert(_multifield_info == NULL, \"Must be initialized only once\");\n+    _multifield_info = array;\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -115,1 +115,2 @@\n-  guarantee(f->name_index() != 0 && f->signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n+  \/\/ assert to be extended to allow multifield names\n+  guarantee(\/*f->name_index() != 0 &&*\/ f->signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -98,0 +98,3 @@\n+  inline bool is_multifield()            const;\n+  inline u2   multifield_base()          const;\n+  inline jbyte multifield_index()        const;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  return field()->name(_cp());\n+  return field()->name(field_holder()->multifield_info(),  _cp());\n@@ -88,0 +88,4 @@\n+inline bool fieldDescriptor::is_multifield() const { return field()->is_multifield(); };\n+inline u2   fieldDescriptor::multifield_base() const { return field_holder()->multifield_info(field()->secondary_index()).base_index(); }\n+inline jbyte fieldDescriptor::multifield_index() const { return  field_holder()->multifield_info(field()->secondary_index()).multifield_index(); }\n+\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+* Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.  Oracle designates this\n+* particular file as subject to the \"Classpath\" exception as provided\n+* by Oracle in the LICENSE file that accompanied this code.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\/\n+\n+package jdk.internal.vm.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+* <p>An annotation expressing that the field has to be\n+* replicated several times and all replication must be\n+* layed out contiguously in memory. The annotation is\n+* ignored if the type of the field is not one of the\n+* eight Java basic primitive types: boolean, byte, short,\n+* char, int, long, float, double.\n+*\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.FIELD})\n+public @interface MultiField {\n+\n+   \/**\n+    * The total number of fields (initial plus replicated).\n+    * This tag is only meaningful for field level annotations.\n+    *\n+    * @return total number of fields to layout.\n+    *\/\n+   byte value() default 0;\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/MultiField.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"}]}