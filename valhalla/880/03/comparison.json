{"files":[{"patch":"@@ -546,0 +546,7 @@\n+        if (isNullable()) {\n+            sb.append(\"?\");\n+        } else if (isNonNullable()) {\n+            sb.append(\"!\");\n+        } else if (isParametric()) {\n+            sb.append(\"*\");\n+        }\n@@ -780,4 +787,15 @@\n-        if (isNullUnspecified()) return t.isNullUnspecified();\n-        if (isNonNullable()) return t.isNonNullable();\n-        if (isNullable()) return t.isNullable();\n-        if (isParametric()) return t.isParametric();\n+        if (t == null) {\n+            return isNullUnspecified();\n+        }\n+        if (isNullUnspecified()) {\n+            return t.isNullUnspecified();\n+        }\n+        if (isNonNullable()) {\n+            return t.isNonNullable();\n+        }\n+        if (isNullable()) {\n+            return t.isNullable();\n+        }\n+        if (isParametric()) {\n+            return t.isParametric();\n+        }\n@@ -788,3 +806,9 @@\n-        if (isNonNullable()) return !t.isNonNullable();\n-        if (isParametric()) return t.isNonNullable() || t.isNullUnspecified();\n-        if (isNullable()) return t.isNullUnspecified();\n+        if (isNonNullable()) {\n+            return !t.isNonNullable();\n+        }\n+        if (isParametric()) {\n+            return t.isNonNullable() || t.isNullUnspecified();\n+        }\n+        if (isNullable()) {\n+            return t.isNullUnspecified();\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":31,"deletions":7,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.BiFunction;\n@@ -45,1 +46,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -53,2 +53,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Errors;\n-import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -1042,20 +1040,5 @@\n-            if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {\n-                if (((ArrayType)t).elemtype.isPrimitive()) {\n-                    return isSameType(elemtype(t), elemtype(s));\n-                } else {\n-                    \/\/ if T.ref <: S, then T[] <: S[]\n-                    Type es = elemtype(s);\n-                    Type et = elemtype(t);\n-                    if (!isSubtypeUncheckedInternal(et, es, false, warn))\n-                        return false;\n-                    return true;\n-                }\n-            } else if (isSubtype(t, s, capture, warn)) {\n-                return true;\n-            } else if (t.hasTag(TYPEVAR)) {\n-                return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);\n-            } else if (!s.isRaw()) {\n-                Type t2 = asSuper(t, s.tsym);\n-                if (t2 != null && t2.isRaw()) {\n-                    if (isReifiable(s)) {\n-                        warn.silentWarn(LintCategory.UNCHECKED);\n+            try {\n+                nullabilityComparator.setWarner(warn);\n+                if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {\n+                    if (((ArrayType)t).elemtype.isPrimitive()) {\n+                        return isSameType(elemtype(t), elemtype(s));\n@@ -1063,1 +1046,6 @@\n-                        warn.warn(LintCategory.UNCHECKED);\n+                        \/\/ if T.ref <: S, then T[] <: S[]\n+                        Type es = elemtype(s);\n+                        Type et = elemtype(t);\n+                        if (!isSubtypeUncheckedInternal(et, es, false, warn))\n+                            return false;\n+                        return true;\n@@ -1065,0 +1053,1 @@\n+                } else if (isSubtype(t, s, capture)) {\n@@ -1066,0 +1055,12 @@\n+                } else if (t.hasTag(TYPEVAR)) {\n+                    return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);\n+                } else if (!s.isRaw()) {\n+                    Type t2 = asSuper(t, s.tsym);\n+                    if (t2 != null && t2.isRaw()) {\n+                        if (isReifiable(s)) {\n+                            warn.silentWarn(LintCategory.UNCHECKED);\n+                        } else {\n+                            warn.warn(LintCategory.UNCHECKED);\n+                        }\n+                        return true;\n+                    }\n@@ -1067,0 +1068,3 @@\n+                return false;\n+            } finally {\n+                nullabilityComparator.clearWarner();\n@@ -1068,1 +1072,0 @@\n-            return false;\n@@ -1104,3 +1107,0 @@\n-        return isSubtype(t, s, capture, noWarnings);\n-    }\n-    public boolean isSubtype(Type t, Type s, boolean capture, Warner warn) {\n@@ -1108,4 +1108,1 @@\n-            Warner warner = !warnStack.isEmpty() ? warnStack.head : warn;\n-            if (warner.pos() != null && s.hasNarrowerNullabilityThan(t)) {\n-                warner.warn(LintCategory.NULL);\n-            }\n+            nullabilityComparator.reset((t1, t2) -> t1.hasNarrowerNullabilityThan(t2)).visit(s, t);\n@@ -1134,14 +1131,1 @@\n-\n-        if (warn == warnStack.head ||\n-                \/\/ if warn is noWarnings, then we should be reentering this method while computing the subtype of a,\n-                \/\/ possibly, compound type, so keep the current top of the warnStack\n-                (!warnStack.isEmpty() && warn == noWarnings)) {\n-            return isSubtype.visit(capture ? capture(t) : t, s);\n-        } else {\n-            try {\n-                warnStack = warnStack.prepend(warn);\n-                return isSubtype.visit(capture ? capture(t) : t, s);\n-            } finally {\n-                warnStack = warnStack.tail;\n-            }\n-        }\n+        return isSubtype.visit(capture ? capture(t) : t, s);\n@@ -1167,5 +1151,2 @@\n-                     \/* this method can be invoked even from the backend, and warnings can be printed again, so\n-                      * make sure that the caller really wants to warn\n-                      *\/\n-                     if (s.isNonNullable() && warnStack.head.pos() != null) {\n-                         chk.errBangTypes(warnStack.head.pos(), Errors.NonNullableCannotBeAssignedNull);\n+                     if (s.isNonNullable()) {\n+                         return false;\n@@ -1246,2 +1227,2 @@\n-                if (result && warnStack.head.pos() != null && s.hasNarrowerNullabilityThan(t)) {\n-                    warnStack.head.warn(LintCategory.NULL);\n+                if (result) {\n+                    nullabilityComparator.reset((t1, t2) -> t1.hasNarrowerNullabilityThan(t2)).visit(s, t);\n@@ -1294,1 +1275,61 @@\n-        };\n+        }\n+\n+        public NullabilityComparator nullabilityComparator = new NullabilityComparator();\n+        public class NullabilityComparator extends TypeRelation {\n+            BiFunction<Type, Type, Boolean> differentNullability;\n+            Warner warner;\n+\n+            NullabilityComparator reset(BiFunction<Type, Type, Boolean> differentNullability) {\n+                this.differentNullability = differentNullability;\n+                if (this.warner == null || this.warner == noWarnings) {\n+                    this.warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n+                }\n+                return this;\n+            }\n+\n+            public NullabilityComparator setWarner(Warner warner) {\n+                this.warner = warner;\n+                return this;\n+            }\n+\n+            public NullabilityComparator clearWarner() {\n+                this.warner = null;\n+                return this;\n+            }\n+\n+            @Override\n+            public Boolean visitType(Type t, Type s) {\n+                if (differentNullability.apply(t, s)) {\n+                    warner.warn(LintCategory.NULL);\n+                    return true;\n+                } else {\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public Boolean visitClassType(ClassType t, Type s) {\n+                if (differentNullability.apply(t, s)) {\n+                    warner.warn(LintCategory.NULL);\n+                    return true;\n+                } else {\n+                    return s != null && (!s.isParameterized() || compareTypeArgsRecursive(t, s))\n+                            && visit(t.getEnclosingType(), s.getEnclosingType());\n+                }\n+            }\n+            \/\/ where\n+            boolean compareTypeArgsRecursive(Type t, Type s) {\n+                return compareTypeArgs(t.getTypeArguments(), s.getTypeArguments());\n+            }\n+\n+            boolean compareTypeArgs(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()) {\n+                    if (visit(ts.head, ss.head)) {\n+                        return true;\n+                    }\n+                    ts = ts.tail;\n+                    ss = ss.tail;\n+                }\n+                return false;\n+            }\n+        }\n@@ -1484,3 +1525,3 @@\n-                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n-                if (equal && !s.sameNullabilityAs(t)) {\n-                    warner.warn(LintCategory.NULL);\n+                if (equal) {\n+                    nullabilityComparator.reset((t1, t2) -> !t1.sameNullabilityAs(t2))\n+                            .visit(s, t);\n@@ -4368,1 +4409,1 @@\n-            if (!isSubtype(r1.getReturnType(), erasure(r2res), false, warner))\n+            if (!isSubtype(r1.getReturnType(), erasure(r2res), false))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":99,"deletions":58,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -4403,1 +4403,1 @@\n-            chk.warnBangTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n@@ -4407,1 +4407,1 @@\n-            chk.warnBangTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-    public void warnBangTypes(DiagnosticPosition pos, Warning warnKey) {\n+    public void warnNullableTypes(DiagnosticPosition pos, Warning warnKey) {\n@@ -310,4 +310,0 @@\n-    public void errBangTypes(DiagnosticPosition pos, Error errKey) {\n-        log.error(pos, errKey);\n-    }\n-\n@@ -732,3 +728,11 @@\n-             return pos != null ?\n-                     types.isSubtype(a, bound, true, new NullnessWarner(pos)) :\n-                     types.isSubtype(a, bound, true);\n+             try {\n+                 if (pos != null) {\n+                     types.nullabilityComparator.setWarner(new NullnessWarner(pos));\n+                 }\n+                 return types.isSubtype(a, bound, true);\n+             } finally {\n+                 if (pos != null) {\n+                     types.nullabilityComparator.clearWarner();\n+                 }\n+             }\n+\n@@ -2029,1 +2033,1 @@\n-            warnBangTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness1);\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness1);\n@@ -2035,1 +2039,1 @@\n-            warnBangTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness2);\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness2);\n@@ -4463,1 +4467,1 @@\n-                    Check.this.warnBangTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n@@ -4500,1 +4504,1 @@\n-                    Check.this.warnBangTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n@@ -4522,1 +4526,1 @@\n-                    Check.this.warnBangTypes(pos(), Warnings.NarrowingNullnessConversion);\n+                    Check.this.warnNullableTypes(pos(), Warnings.NarrowingNullnessConversion);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-                                \"compiler.err.non.nullable.cannot.be.assigned.null\"),\n+                                \"compiler.err.prob.found.req\"),\n@@ -142,1 +142,27 @@\n-                                \"compiler.err.non.nullable.cannot.be.assigned.null\")\n+                                \"compiler.err.prob.found.req\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    void m() {\n+                                        Supplier<? extends T> factory = nullFactory();\n+                                    }\n+                                    Supplier<? extends T!> nullFactory() { return () -> null; }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class MyList<T> {\n+                                    void add(T! e) {}\n+                                }\n+                                class Test {\n+                                    void m(MyList<? super Point!> ls) {\n+                                        ls.add(null);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\")\n@@ -281,0 +307,121 @@\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    static value class Atom {}\n+                                    static class Box<X> {}\n+                                    void test(Box<? extends Atom!> t1, Box<Atom> t2) {\n+                                        t1 = t2;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Wrapper<T> {}\n+                                class Test<T> {\n+                                    Wrapper<T> newWrapper() { return null; }\n+                                    void m() {\n+                                        Wrapper<T!> w = newWrapper();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test {\n+                                    void plot(Function<String, String> f) {}\n+                                    void m(Function<String!, String> gradient) {\n+                                        plot(gradient);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test {\n+                                    void plot(Function<String!, String> f) {}\n+                                    void m(Function<String, String> gradient) {\n+                                        plot(gradient);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                2),  \/\/ this needs to be reviewed, the warning is printed twice, should be once only\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    void m() {\n+                                        Supplier<? extends T!> factory = nullFactory();\n+                                    }\n+                                    Supplier<? extends T> nullFactory() { return () -> null; }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Test<T> {\n+                                    Set<Map.Entry<String, T>> allEntries() { return null; }\n+                                    void m() {\n+                                        Set<Map.Entry<String, T!>> entries = allEntries();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                2),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    T field;\n+                                    void foo(Consumer<? super T!> action) {\n+                                        action.accept(field);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Test<T> {\n+                                    Set<Map.Entry<String, T!>> allEntries() { return null; }\n+                                    void m() {\n+                                        Set<Map.Entry<String, T>> entries = allEntries();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    class Box<X> {}\n+                                    @SafeVarargs\n+                                    private <Z> Z! make_box_uni(Z!... bs) {\n+                                        return bs[0];\n+                                    }\n+                                    void test(Box<String!> bref, Box<String> bval) {\n+                                        Box<? extends String!> res = make_box_uni(bref, bval);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                2),\n+\n@@ -321,1 +468,108 @@\n-                                \"\" \/* no warnings in this case *\/)\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                interface Shape {}\n+                                value class Point implements Shape {}\n+                                class Box<T> {}\n+                                class Test {\n+                                    void m(Box<Point!> lp) {\n+                                        foo(lp);\n+                                    }\n+                                    void foo(Box<? extends Shape> ls) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                interface Shape {}\n+                                value class Point implements Shape {}\n+                                class Box<T> {}\n+                                class Test {\n+                                    void m(Box<Shape!> lp) {\n+                                        foo(lp);\n+                                    }\n+                                    void foo(Box<? super Point!> ls) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class C<T> {\n+                                    T x = null;\n+                                    void m() {\n+                                        String r = new C<String>().x;\n+                                        Point p = new C<Point>().x;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class C<T> {\n+                                    T x = null;\n+                                    void m() {\n+                                        String r = new C<String>().x;\n+                                        Point p = new C<Point>().x;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class C<T> {\n+                                    T x = null;\n+                                    void set(T! arg) { x = arg; }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class MyList<T> {\n+                                    static <E> MyList<E!> of(E! e1) {\n+                                        return null;\n+                                    }\n+                                }\n+                                class Test {\n+                                    void m() {\n+                                        MyList.of(new Point!());\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class MyCollection<T> {}\n+                                class MyList<T> extends MyCollection<T!> {\n+                                    static <E> MyList<E!> of(E! e1) {\n+                                        return null;\n+                                    }\n+                                }\n+                                class Test {\n+                                    void m() {\n+                                        MyCollection<Point> mpc = MyList.of(new Point!());\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test<T> {\n+                                    T field;\n+                                    void foo(T! t) {\n+                                        field = t;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n","filename":"test\/langtools\/tools\/javac\/bang\/BangTypesCompilationTests.java","additions":257,"deletions":3,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckClassfileFlagsTest.java:15:9: compiler.err.cant.access: ValueWithInvalidFlags, (compiler.misc.bad.class.file.header: ValueWithInvalidFlags.class, (compiler.misc.bad.class.signature: \"QValueWithInvalidFlags;\"))\n+CheckClassfileFlagsTest.java:15:9: compiler.err.cant.access: ValueWithInvalidFlags, (compiler.misc.bad.class.file.header: ValueWithInvalidFlags.class, (compiler.misc.bad.signature: \"QValueWithInvalidFlags;\"))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/lworld-values\/classfile_flags\/CheckClassfileFlagsTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}