{"files":[{"patch":"@@ -546,0 +546,7 @@\n+        if (isNullable()) {\n+            sb.append(\"?\");\n+        } else if (isNonNullable()) {\n+            sb.append(\"!\");\n+        } else if (isParametric()) {\n+            sb.append(\"*\");\n+        }\n@@ -779,15 +786,0 @@\n-    public boolean sameNullabilityAs(Type t) {\n-        if (isNullUnspecified()) return t.isNullUnspecified();\n-        if (isNonNullable()) return t.isNonNullable();\n-        if (isNullable()) return t.isNullable();\n-        if (isParametric()) return t.isParametric();\n-        throw new AssertionError(\"shouldn't get here\");\n-    }\n-\n-    public boolean hasNarrowerNullabilityThan(Type t) {\n-        if (isNonNullable()) return !t.isNonNullable();\n-        if (isParametric()) return t.isNonNullable() || t.isNullUnspecified();\n-        if (isNullable()) return t.isNullUnspecified();\n-        return false;\n-    }\n-\n@@ -1126,1 +1118,3 @@\n-            return addMetadata(new ConstantValue(constValue));\n+            return isPrimitive() ?\n+                    addMetadata(new ConstantValue(constValue)) :\n+                    addMetadata(new ConstantValue(constValue)).addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.BiFunction;\n@@ -45,1 +46,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -53,2 +53,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Errors;\n-import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -1042,20 +1040,5 @@\n-            if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {\n-                if (((ArrayType)t).elemtype.isPrimitive()) {\n-                    return isSameType(elemtype(t), elemtype(s));\n-                } else {\n-                    \/\/ if T.ref <: S, then T[] <: S[]\n-                    Type es = elemtype(s);\n-                    Type et = elemtype(t);\n-                    if (!isSubtypeUncheckedInternal(et, es, false, warn))\n-                        return false;\n-                    return true;\n-                }\n-            } else if (isSubtype(t, s, capture, warn)) {\n-                return true;\n-            } else if (t.hasTag(TYPEVAR)) {\n-                return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);\n-            } else if (!s.isRaw()) {\n-                Type t2 = asSuper(t, s.tsym);\n-                if (t2 != null && t2.isRaw()) {\n-                    if (isReifiable(s)) {\n-                        warn.silentWarn(LintCategory.UNCHECKED);\n+            try {\n+                warnStack = warnStack.prepend(warn);\n+                if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {\n+                    if (((ArrayType)t).elemtype.isPrimitive()) {\n+                        return isSameType(elemtype(t), elemtype(s));\n@@ -1063,1 +1046,6 @@\n-                        warn.warn(LintCategory.UNCHECKED);\n+                        \/\/ if T.ref <: S, then T[] <: S[]\n+                        Type es = elemtype(s);\n+                        Type et = elemtype(t);\n+                        if (!isSubtypeUncheckedInternal(et, es, false, warn))\n+                            return false;\n+                        return true;\n@@ -1065,0 +1053,1 @@\n+                } else if (isSubtype(t, s, capture)) {\n@@ -1066,0 +1055,12 @@\n+                } else if (t.hasTag(TYPEVAR)) {\n+                    return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);\n+                } else if (!s.isRaw()) {\n+                    Type t2 = asSuper(t, s.tsym);\n+                    if (t2 != null && t2.isRaw()) {\n+                        if (isReifiable(s)) {\n+                            warn.silentWarn(LintCategory.UNCHECKED);\n+                        } else {\n+                            warn.warn(LintCategory.UNCHECKED);\n+                        }\n+                        return true;\n+                    }\n@@ -1067,0 +1068,3 @@\n+                return false;\n+            } finally {\n+                warnStack = warnStack.tail;\n@@ -1068,1 +1072,0 @@\n-            return false;\n@@ -1104,3 +1107,0 @@\n-        return isSubtype(t, s, capture, noWarnings);\n-    }\n-    public boolean isSubtype(Type t, Type s, boolean capture, Warner warn) {\n@@ -1108,4 +1108,1 @@\n-            Warner warner = !warnStack.isEmpty() ? warnStack.head : warn;\n-            if (warner.pos() != null && s.hasNarrowerNullabilityThan(t)) {\n-                warner.warn(LintCategory.NULL);\n-            }\n+            new NullabilityComparator((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n@@ -1134,14 +1131,1 @@\n-\n-        if (warn == warnStack.head ||\n-                \/\/ if warn is noWarnings, then we should be reentering this method while computing the subtype of a,\n-                \/\/ possibly, compound type, so keep the current top of the warnStack\n-                (!warnStack.isEmpty() && warn == noWarnings)) {\n-            return isSubtype.visit(capture ? capture(t) : t, s);\n-        } else {\n-            try {\n-                warnStack = warnStack.prepend(warn);\n-                return isSubtype.visit(capture ? capture(t) : t, s);\n-            } finally {\n-                warnStack = warnStack.tail;\n-            }\n-        }\n+        return isSubtype.visit(capture ? capture(t) : t, s);\n@@ -1167,5 +1151,2 @@\n-                     \/* this method can be invoked even from the backend, and warnings can be printed again, so\n-                      * make sure that the caller really wants to warn\n-                      *\/\n-                     if (s.isNonNullable() && warnStack.head.pos() != null) {\n-                         chk.errBangTypes(warnStack.head.pos(), Errors.NonNullableCannotBeAssignedNull);\n+                     if (s.isNonNullable()) {\n+                         return false;\n@@ -1246,2 +1227,2 @@\n-                if (result && warnStack.head.pos() != null && s.hasNarrowerNullabilityThan(t)) {\n-                    warnStack.head.warn(LintCategory.NULL);\n+                if (result) {\n+                    new NullabilityComparator((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n@@ -1294,1 +1275,47 @@\n-        };\n+        }\n+\n+        public class NullabilityComparator extends TypeRelation {\n+            BiFunction<Type, Type, Boolean> differentNullability;\n+\n+            NullabilityComparator(BiFunction<Type, Type, Boolean> differentNullability) {\n+                this.differentNullability = differentNullability;\n+            }\n+\n+            @Override\n+            public Boolean visitType(Type t, Type s) {\n+                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n+                if (differentNullability.apply(t, s)) {\n+                    warner.warn(LintCategory.NULL);\n+                    return true;\n+                } else {\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public Boolean visitClassType(ClassType t, Type s) {\n+                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n+                if (differentNullability.apply(t, s)) {\n+                    warner.warn(LintCategory.NULL);\n+                    return true;\n+                } else {\n+                    return s != null && (!s.isParameterized() || compareTypeArgsRecursive(t, s))\n+                            && visit(t.getEnclosingType(), s.getEnclosingType());\n+                }\n+            }\n+            \/\/ where\n+            boolean compareTypeArgsRecursive(Type t, Type s) {\n+                return compareTypeArgs(t.getTypeArguments(), s.getTypeArguments());\n+            }\n+\n+            boolean compareTypeArgs(List<Type> ts, List<Type> ss) {\n+                while (ts.nonEmpty() && ss.nonEmpty()) {\n+                    if (visit(ts.head, ss.head)) {\n+                        return true;\n+                    }\n+                    ts = ts.tail;\n+                    ss = ss.tail;\n+                }\n+                return false;\n+            }\n+        }\n@@ -1484,3 +1511,2 @@\n-                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n-                if (equal && !s.sameNullabilityAs(t)) {\n-                    warner.warn(LintCategory.NULL);\n+                if (equal) {\n+                    new NullabilityComparator((t1, t2) -> !hasSameNullability(t1, t2)).visit(s, t);\n@@ -2212,0 +2238,10 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"warn stack\">\n+    public void pushWarner(Warner warner) {\n+        warnStack = warnStack.prepend(warner);\n+    }\n+\n+    public void popWarner() {\n+        warnStack = warnStack.tail;\n+    }\n+    \/\/ <\/editor-fold>\n+\n@@ -4368,1 +4404,1 @@\n-            if (!isSubtype(r1.getReturnType(), erasure(r2res), false, warner))\n+            if (!isSubtype(r1.getReturnType(), erasure(r2res), false))\n@@ -5362,0 +5398,28 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"nullability methods\">\n+    \/**\n+     * Do t and s have the same nullability?\n+     *\/\n+    public boolean hasSameNullability(Type t, Type s) {\n+        if (s == null) {\n+            return t.isNullUnspecified();\n+        }\n+        if (t.isNullUnspecified()) {\n+            return s.isNullUnspecified();\n+        }\n+        if (t.isNonNullable()) {\n+            return s.isNonNullable();\n+        }\n+        throw new AssertionError(\"shouldn't get here\");\n+    }\n+\n+    \/**\n+     * Does t has narrower nullability than s?\n+     *\/\n+    public boolean hasNarrowerNullability(Type t, Type s) {\n+        if (t.isNonNullable()) {\n+            return s != null && !s.isNonNullable();\n+        }\n+        return false;\n+    }\n+    \/\/ <\/editor-fold>\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":122,"deletions":58,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -2898,0 +2898,3 @@\n+                if (owntype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                    owntype = owntype.addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL)); \/\/ constructor invocations are always null restricted\n+                }\n@@ -4403,1 +4406,1 @@\n-            chk.warnBangTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n@@ -4407,1 +4410,1 @@\n-            chk.warnBangTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.Consumer;\n@@ -83,1 +82,0 @@\n-import javax.lang.model.element.ExecutableElement;\n@@ -86,2 +84,0 @@\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.ElementFilter;\n@@ -304,1 +300,1 @@\n-    public void warnBangTypes(DiagnosticPosition pos, Warning warnKey) {\n+    public void warnNullableTypes(DiagnosticPosition pos, Warning warnKey) {\n@@ -310,4 +306,0 @@\n-    public void errBangTypes(DiagnosticPosition pos, Error errKey) {\n-        log.error(pos, errKey);\n-    }\n-\n@@ -696,1 +688,1 @@\n-                    if (!lint.isEnabled(LintCategory.NULL) || !tree.clazz.type.hasNarrowerNullabilityThan(tree.expr.type)) {\n+                    if (!lint.isEnabled(LintCategory.NULL) || !types.hasNarrowerNullability(tree.clazz.type, tree.expr.type)) {\n@@ -732,3 +724,11 @@\n-             return pos != null ?\n-                     types.isSubtype(a, bound, true, new NullnessWarner(pos)) :\n-                     types.isSubtype(a, bound, true);\n+             try {\n+                 if (pos != null) {\n+                     types.pushWarner(new NullnessWarner(pos));\n+                 }\n+                 return types.isSubtype(a, bound, true);\n+             } finally {\n+                 if (pos != null) {\n+                     types.popWarner();\n+                 }\n+             }\n+\n@@ -2029,1 +2029,1 @@\n-            warnBangTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness1);\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness1);\n@@ -2035,1 +2035,1 @@\n-            warnBangTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness2);\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness2);\n@@ -4463,1 +4463,1 @@\n-                    Check.this.warnBangTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n@@ -4500,1 +4500,1 @@\n-                    Check.this.warnBangTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n@@ -4505,0 +4505,1 @@\n+            this.warned = true;\n@@ -4522,1 +4523,1 @@\n-                    Check.this.warnBangTypes(pos(), Warnings.NarrowingNullnessConversion);\n+                    Check.this.warnNullableTypes(pos(), Warnings.NarrowingNullnessConversion);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        return \"void eqtestObject() { if (null == new @TA String()); }\";\n+        return \"void eqtestObject(String! s) { if (s == new @TA String()); }\";\n@@ -71,1 +71,1 @@\n-        return \"void eqtestObjectGeneric() { if (null == new @TA ArrayList<@TB String >()); }\";\n+        return \"void eqtestObjectGeneric(ArrayList!<String> as) { if (as == new @TA ArrayList<@TB String >()); }\";\n@@ -168,1 +168,1 @@\n-        return \"void eqtestObject() { if (null == new @RTA @RTA String()); }\";\n+        return \"void eqtestObject(String! s) { if (s == new @RTA @RTA String()); }\";\n@@ -175,1 +175,1 @@\n-        return \"void eqtestObjectGeneric() { if (null == new @RTA @RTA ArrayList<@RTB @RTB String >()); }\";\n+        return \"void eqtestObjectGeneric(ArrayList!<String> as) { if (as == new @RTA @RTA ArrayList<@RTB @RTB String >()); }\";\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/NewObjects.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-                                \"compiler.err.non.nullable.cannot.be.assigned.null\"),\n+                                \"compiler.err.prob.found.req\"),\n@@ -142,1 +142,27 @@\n-                                \"compiler.err.non.nullable.cannot.be.assigned.null\")\n+                                \"compiler.err.prob.found.req\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    void m() {\n+                                        Supplier<? extends T> factory = nullFactory();\n+                                    }\n+                                    Supplier<? extends T!> nullFactory() { return () -> null; }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class MyList<T> {\n+                                    void add(T! e) {}\n+                                }\n+                                class Test {\n+                                    void m(MyList<? super Point!> ls) {\n+                                        ls.add(null);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\")\n@@ -281,0 +307,121 @@\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    static value class Atom {}\n+                                    static class Box<X> {}\n+                                    void test(Box<? extends Atom!> t1, Box<Atom> t2) {\n+                                        t1 = t2;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Wrapper<T> {}\n+                                class Test<T> {\n+                                    Wrapper<T> newWrapper() { return null; }\n+                                    void m() {\n+                                        Wrapper<T!> w = newWrapper();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test {\n+                                    void plot(Function<String, String> f) {}\n+                                    void m(Function<String!, String> gradient) {\n+                                        plot(gradient);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test {\n+                                    void plot(Function<String!, String> f) {}\n+                                    void m(Function<String, String> gradient) {\n+                                        plot(gradient);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    void m() {\n+                                        Supplier<? extends T!> factory = nullFactory();\n+                                    }\n+                                    Supplier<? extends T> nullFactory() { return () -> null; }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Test<T> {\n+                                    Set<Map.Entry<String, T>> allEntries() { return null; }\n+                                    void m() {\n+                                        Set<Map.Entry<String, T!>> entries = allEntries();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    T field;\n+                                    void foo(Consumer<? super T!> action) {\n+                                        action.accept(field);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Test<T> {\n+                                    Set<Map.Entry<String, T!>> allEntries() { return null; }\n+                                    void m() {\n+                                        Set<Map.Entry<String, T>> entries = allEntries();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    class Box<X> {}\n+                                    @SafeVarargs\n+                                    private <Z> Z! make_box_uni(Z!... bs) {\n+                                        return bs[0];\n+                                    }\n+                                    void test(Box<String!> bref, Box<String> bval) {\n+                                        Box<? extends String!> res = make_box_uni(bref, bval);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+\n@@ -310,0 +457,20 @@\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    void m() {\n+                                        String! s = \"abc\"; \/\/ literals are always null restricted\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m() {\n+                                        Foo! f = new Foo();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n@@ -321,1 +488,162 @@\n-                                \"\" \/* no warnings in this case *\/)\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                interface Shape {}\n+                                value class Point implements Shape {}\n+                                class Box<T> {}\n+                                class Test {\n+                                    void m(Box<Point!> lp) {\n+                                        foo(lp);\n+                                    }\n+                                    void foo(Box<? extends Shape> ls) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                interface Shape {}\n+                                value class Point implements Shape {}\n+                                class Box<T> {}\n+                                class Test {\n+                                    void m(Box<Shape!> lp) {\n+                                        foo(lp);\n+                                    }\n+                                    void foo(Box<? super Point!> ls) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class C<T> {\n+                                    T x = null;\n+                                    void m() {\n+                                        String r = new C<String>().x;\n+                                        Point p = new C<Point>().x;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class C<T> {\n+                                    T x = null;\n+                                    void m() {\n+                                        String r = new C<String>().x;\n+                                        Point p = new C<Point>().x;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class C<T> {\n+                                    T x = null;\n+                                    void set(T! arg) { x = arg; }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class MyList<T> {\n+                                    static <E> MyList<E!> of(E! e1) {\n+                                        return null;\n+                                    }\n+                                }\n+                                class Test {\n+                                    void m() {\n+                                        MyList.of(new Point!());\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class MyCollection<T> {}\n+                                class MyList<T> extends MyCollection<T!> {\n+                                    static <E> MyList<E!> of(E! e1) {\n+                                        return null;\n+                                    }\n+                                }\n+                                class Test {\n+                                    void m() {\n+                                        MyCollection<Point> mpc = MyList.of(new Point!());\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test<T> {\n+                                    T field;\n+                                    void foo(T! t) {\n+                                        field = t;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.lang.invoke.*;\n+                                class Cell {\n+                                    final void reset() {\n+                                        \/* we are testing that the compiler won't infer the arguments of\n+                                         * VarHandle::setVolatile as (Cell, String!)\n+                                         *\/\n+                                        VALUE.setVolatile(this, \"\");\n+                                    }\n+                                    final void reset(String identity) {\n+                                        \/* if that were the case, see comment above, then this invocation would generate\n+                                         * a warning, VarHandle::setVolatile is a polymorphic signature method\n+                                         *\/\n+                                        VALUE.setVolatile(this, identity);\n+                                    }\n+\n+                                    private static final VarHandle VALUE;\n+                                    static {\n+                                        try {\n+                                            MethodHandles.Lookup l = MethodHandles.lookup();\n+                                            VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n+                                        } catch (ReflectiveOperationException e) {\n+                                            throw new ExceptionInInitializerError(e);\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.lang.invoke.*;\n+                                class Cell {\n+                                    final void reset() {\n+                                        VALUE.setVolatile(this, 0L);\n+                                    }\n+                                    final void reset(long identity) {\n+                                        VALUE.setVolatile(this, identity);\n+                                    }\n+\n+                                    private static final VarHandle VALUE;\n+                                    static {\n+                                        try {\n+                                            MethodHandles.Lookup l = MethodHandles.lookup();\n+                                            VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n+                                        } catch (ReflectiveOperationException e) {\n+                                            throw new ExceptionInInitializerError(e);\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n","filename":"test\/langtools\/tools\/javac\/bang\/BangTypesCompilationTests.java","additions":331,"deletions":3,"binary":false,"changes":334,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-            checkCorrectException(check::enumValue, \"java.lang.String\");\n+            checkCorrectException(check::enumValue, \"java.lang.String!\");\n","filename":"test\/langtools\/tools\/javac\/processing\/errors\/EnsureAnnotationTypeMismatchException\/Processor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckClassfileFlagsTest.java:15:9: compiler.err.cant.access: ValueWithInvalidFlags, (compiler.misc.bad.class.file.header: ValueWithInvalidFlags.class, (compiler.misc.bad.class.signature: \"QValueWithInvalidFlags;\"))\n+CheckClassfileFlagsTest.java:15:9: compiler.err.cant.access: ValueWithInvalidFlags, (compiler.misc.bad.class.file.header: ValueWithInvalidFlags.class, (compiler.misc.bad.signature: \"QValueWithInvalidFlags;\"))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/lworld-values\/classfile_flags\/CheckClassfileFlagsTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}