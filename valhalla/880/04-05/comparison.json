{"files":[{"patch":"@@ -399,1 +399,1 @@\n-            if (m.getClass() == metadataClass) {\n+            if (m.getClass().isAssignableFrom(metadataClass)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5406,0 +5406,2 @@\n+        \/\/ special case for literals, a literal is always != null\n+        boolean isLiteral = s != null && s.getMetadata(TypeMetadata.ConstantValue.class) != null;\n@@ -5410,1 +5412,1 @@\n-            return s.isNullUnspecified();\n+            return s.isNullUnspecified() && !isLiteral;\n@@ -5413,7 +5415,1 @@\n-            return s.isNonNullable();\n-        }\n-        if (t.isNullable()) {\n-            return s.isNullable();\n-        }\n-        if (t.isParametric()) {\n-            return s.isParametric();\n+            return s.isNonNullable() || isLiteral;\n@@ -5428,0 +5424,2 @@\n+        \/\/ special case for literals, a literal is always != null\n+        boolean isLiteral = s != null && s.getMetadata(TypeMetadata.ConstantValue.class) != null;\n@@ -5429,7 +5427,1 @@\n-            return !s.isNonNullable();\n-        }\n-        if (t.isParametric()) {\n-            return s.isNonNullable() || s.isNullUnspecified();\n-        }\n-        if (t.isNullable()) {\n-            return s.isNullUnspecified();\n+            return s != null && !s.isNonNullable() && !isLiteral;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2898,0 +2898,3 @@\n+                if (owntype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                    owntype = owntype.addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL)); \/\/ constructor invocations are always null restricted\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4490,1 +4490,0 @@\n-                    this.warned = true;\n@@ -4499,1 +4498,0 @@\n-                    this.warned = true;\n@@ -4503,1 +4501,0 @@\n-                    this.warned = true;\n@@ -4508,0 +4505,1 @@\n+            this.warned = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -915,1 +915,1 @@\n-            if (pts.head.isNonNullable()) {\n+            if (pts.head.isNonNullable() && l.head.type.constValue() == null) {\n@@ -1101,1 +1101,1 @@\n-                if (tree.type.isNonNullable()) {\n+                if (tree.type.isNonNullable() && tree.init.type.constValue() == null) { \/\/ don't generate null checks on literals\n@@ -2126,1 +2126,1 @@\n-        if (tree.lhs.type.isNonNullable()) {\n+        if (tree.lhs.type.isNonNullable() && tree.rhs.type.constValue() == null) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        return \"void eqtestObject() { if (null == new @TA String()); }\";\n+        return \"void eqtestObject(String! s) { if (s == new @TA String()); }\";\n@@ -71,1 +71,1 @@\n-        return \"void eqtestObjectGeneric() { if (null == new @TA ArrayList<@TB String >()); }\";\n+        return \"void eqtestObjectGeneric(ArrayList!<String> as) { if (as == new @TA ArrayList<@TB String >()); }\";\n@@ -168,1 +168,1 @@\n-        return \"void eqtestObject() { if (null == new @RTA @RTA String()); }\";\n+        return \"void eqtestObject(String! s) { if (s == new @RTA @RTA String()); }\";\n@@ -175,1 +175,1 @@\n-        return \"void eqtestObjectGeneric() { if (null == new @RTA @RTA ArrayList<@RTB @RTB String >()); }\";\n+        return \"void eqtestObjectGeneric(ArrayList!<String> as) { if (as == new @RTA @RTA ArrayList<@RTB @RTB String >()); }\";\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/NewObjects.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -457,0 +457,20 @@\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    void m() {\n+                                        String! s = \"abc\"; \/\/ literals are always null restricted\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m() {\n+                                        Foo! f = new Foo();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n@@ -575,0 +595,30 @@\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.lang.invoke.*;\n+                                class Cell {\n+                                    final void reset() {\n+                                        \/* we are testing that the compiler won't infer the arguments of\n+                                         * VarHandle::setVolatile as (Cell, String!)\n+                                         *\/\n+                                        VALUE.setVolatile(this, \"\");\n+                                    }\n+                                    final void reset(String identity) {\n+                                        \/* if that were the case, see comment above, then this invocation would generate\n+                                         * a warning, VarHandle::setVolatile is a polymorphic signature method\n+                                         *\/\n+                                        VALUE.setVolatile(this, identity);\n+                                    }\n+                                                                \n+                                    private static final VarHandle VALUE;\n+                                    static {\n+                                        try {\n+                                            MethodHandles.Lookup l = MethodHandles.lookup();\n+                                            VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n+                                        } catch (ReflectiveOperationException e) {\n+                                            throw new ExceptionInInitializerError(e);\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n","filename":"test\/langtools\/tools\/javac\/bang\/BangTypesCompilationTests.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"}]}