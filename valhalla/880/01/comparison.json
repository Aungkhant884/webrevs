{"files":[{"patch":"@@ -546,0 +546,7 @@\n+        if (isNullable()) {\n+            sb.append(\"?\");\n+        } else if (isNonNullable()) {\n+            sb.append(\"!\");\n+        } else if (isParametric()) {\n+            sb.append(\"*\");\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.BiFunction;\n@@ -45,1 +46,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -53,2 +53,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Errors;\n-import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -1042,20 +1040,5 @@\n-            if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {\n-                if (((ArrayType)t).elemtype.isPrimitive()) {\n-                    return isSameType(elemtype(t), elemtype(s));\n-                } else {\n-                    \/\/ if T.ref <: S, then T[] <: S[]\n-                    Type es = elemtype(s);\n-                    Type et = elemtype(t);\n-                    if (!isSubtypeUncheckedInternal(et, es, false, warn))\n-                        return false;\n-                    return true;\n-                }\n-            } else if (isSubtype(t, s, capture, warn)) {\n-                return true;\n-            } else if (t.hasTag(TYPEVAR)) {\n-                return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);\n-            } else if (!s.isRaw()) {\n-                Type t2 = asSuper(t, s.tsym);\n-                if (t2 != null && t2.isRaw()) {\n-                    if (isReifiable(s)) {\n-                        warn.silentWarn(LintCategory.UNCHECKED);\n+            try {\n+                nullabilityComparator.setWarner(warn);\n+                if (t.hasTag(ARRAY) && s.hasTag(ARRAY)) {\n+                    if (((ArrayType)t).elemtype.isPrimitive()) {\n+                        return isSameType(elemtype(t), elemtype(s));\n@@ -1063,1 +1046,6 @@\n-                        warn.warn(LintCategory.UNCHECKED);\n+                        \/\/ if T.ref <: S, then T[] <: S[]\n+                        Type es = elemtype(s);\n+                        Type et = elemtype(t);\n+                        if (!isSubtypeUncheckedInternal(et, es, false, warn))\n+                            return false;\n+                        return true;\n@@ -1065,0 +1053,1 @@\n+                } else if (isSubtype(t, s, capture)) {\n@@ -1066,0 +1055,12 @@\n+                } else if (t.hasTag(TYPEVAR)) {\n+                    return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);\n+                } else if (!s.isRaw()) {\n+                    Type t2 = asSuper(t, s.tsym);\n+                    if (t2 != null && t2.isRaw()) {\n+                        if (isReifiable(s)) {\n+                            warn.silentWarn(LintCategory.UNCHECKED);\n+                        } else {\n+                            warn.warn(LintCategory.UNCHECKED);\n+                        }\n+                        return true;\n+                    }\n@@ -1067,0 +1068,3 @@\n+                return false;\n+            } finally {\n+                nullabilityComparator.clearWarner();\n@@ -1068,1 +1072,0 @@\n-            return false;\n@@ -1104,3 +1107,0 @@\n-        return isSubtype(t, s, capture, noWarnings);\n-    }\n-    public boolean isSubtype(Type t, Type s, boolean capture, Warner warn) {\n@@ -1108,4 +1108,1 @@\n-            Warner warner = !warnStack.isEmpty() ? warnStack.head : warn;\n-            if (warner.pos() != null && s.hasNarrowerNullabilityThan(t)) {\n-                warner.warn(LintCategory.NULL);\n-            }\n+            nullabilityComparator.reset((t1, t2) -> t1.hasNarrowerNullabilityThan(t2)).visit(s, t);\n@@ -1134,14 +1131,1 @@\n-\n-        if (warn == warnStack.head ||\n-                \/\/ if warn is noWarnings, then we should be reentering this method while computing the subtype of a,\n-                \/\/ possibly, compound type, so keep the current top of the warnStack\n-                (!warnStack.isEmpty() && warn == noWarnings)) {\n-            return isSubtype.visit(capture ? capture(t) : t, s);\n-        } else {\n-            try {\n-                warnStack = warnStack.prepend(warn);\n-                return isSubtype.visit(capture ? capture(t) : t, s);\n-            } finally {\n-                warnStack = warnStack.tail;\n-            }\n-        }\n+        return isSubtype.visit(capture ? capture(t) : t, s);\n@@ -1167,5 +1151,2 @@\n-                     \/* this method can be invoked even from the backend, and warnings can be printed again, so\n-                      * make sure that the caller really wants to warn\n-                      *\/\n-                     if (s.isNonNullable() && warnStack.head.pos() != null) {\n-                         chk.errBangTypes(warnStack.head.pos(), Errors.NonNullableCannotBeAssignedNull);\n+                     if (s.isNonNullable()) {\n+                         return false;\n@@ -1246,2 +1227,2 @@\n-                if (result && warnStack.head.pos() != null && s.hasNarrowerNullabilityThan(t)) {\n-                    warnStack.head.warn(LintCategory.NULL);\n+                if (result) {\n+                    nullabilityComparator.reset((t1, t2) -> t1.hasNarrowerNullabilityThan(t2)).visit(s, t);\n@@ -1294,1 +1275,35 @@\n-        };\n+        }\n+\n+        public NullabilityComparator nullabilityComparator = new NullabilityComparator();\n+        public class NullabilityComparator extends TypeRelation {\n+            BiFunction<Type, Type, Boolean> differentNullability;\n+            Warner warner;\n+\n+            NullabilityComparator reset(BiFunction<Type, Type, Boolean> differentNullability) {\n+                this.differentNullability = differentNullability;\n+                if (this.warner == null || this.warner == noWarnings) {\n+                    this.warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n+                }\n+                return this;\n+            }\n+\n+            public NullabilityComparator setWarner(Warner warner) {\n+                this.warner = warner;\n+                return this;\n+            }\n+\n+            public NullabilityComparator clearWarner() {\n+                this.warner = null;\n+                return this;\n+            }\n+\n+            @Override\n+            public Boolean visitType(Type t, Type s) {\n+                if (differentNullability.apply(t, s)) {\n+                    warner.warn(LintCategory.NULL);\n+                    return false;\n+                } else {\n+                    return true;\n+                }\n+            }\n+        }\n@@ -1484,3 +1499,3 @@\n-                Warner warner = !warnStack.isEmpty() ? warnStack.head : noWarnings;\n-                if (equal && !s.sameNullabilityAs(t)) {\n-                    warner.warn(LintCategory.NULL);\n+                if (equal) {\n+                    nullabilityComparator.reset((t1, t2) -> !t1.sameNullabilityAs(t2))\n+                            .visit(s, t);\n@@ -4368,1 +4383,1 @@\n-            if (!isSubtype(r1.getReturnType(), erasure(r2res), false, warner))\n+            if (!isSubtype(r1.getReturnType(), erasure(r2res), false))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":73,"deletions":58,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -4403,1 +4403,1 @@\n-            chk.warnBangTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfNullable);\n@@ -4407,1 +4407,1 @@\n-            chk.warnBangTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n+            chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-    public void warnBangTypes(DiagnosticPosition pos, Warning warnKey) {\n+    public void warnNullableTypes(DiagnosticPosition pos, Warning warnKey) {\n@@ -310,4 +310,0 @@\n-    public void errBangTypes(DiagnosticPosition pos, Error errKey) {\n-        log.error(pos, errKey);\n-    }\n-\n@@ -732,3 +728,11 @@\n-             return pos != null ?\n-                     types.isSubtype(a, bound, true, new NullnessWarner(pos)) :\n-                     types.isSubtype(a, bound, true);\n+             try {\n+                 if (pos != null) {\n+                     types.nullabilityComparator.setWarner(new NullnessWarner(pos));\n+                 }\n+                 return types.isSubtype(a, bound, true);\n+             } finally {\n+                 if (pos != null) {\n+                     types.nullabilityComparator.clearWarner();\n+                 }\n+             }\n+\n@@ -2029,1 +2033,1 @@\n-            warnBangTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness1);\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness1);\n@@ -2035,1 +2039,1 @@\n-            warnBangTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness2);\n+            warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), Warnings.OverridesWithDifferentNullness2);\n@@ -4463,1 +4467,1 @@\n-                    Check.this.warnBangTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n@@ -4500,1 +4504,1 @@\n-                    Check.this.warnBangTypes(pos(), Warnings.UncheckedNullnessConversion);\n+                    Check.this.warnNullableTypes(pos(), Warnings.UncheckedNullnessConversion);\n@@ -4522,1 +4526,1 @@\n-                    Check.this.warnBangTypes(pos(), Warnings.NarrowingNullnessConversion);\n+                    Check.this.warnNullableTypes(pos(), Warnings.NarrowingNullnessConversion);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-                                \"compiler.err.non.nullable.cannot.be.assigned.null\"),\n+                                \"compiler.err.prob.found.req\"),\n@@ -142,1 +142,1 @@\n-                                \"compiler.err.non.nullable.cannot.be.assigned.null\")\n+                                \"compiler.err.prob.found.req\")\n","filename":"test\/langtools\/tools\/javac\/bang\/BangTypesCompilationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CheckClassfileFlagsTest.java:15:9: compiler.err.cant.access: ValueWithInvalidFlags, (compiler.misc.bad.class.file.header: ValueWithInvalidFlags.class, (compiler.misc.bad.class.signature: \"QValueWithInvalidFlags;\"))\n+CheckClassfileFlagsTest.java:15:9: compiler.err.cant.access: ValueWithInvalidFlags, (compiler.misc.bad.class.file.header: ValueWithInvalidFlags.class, (compiler.misc.bad.signature: \"QValueWithInvalidFlags;\"))\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/lworld-values\/classfile_flags\/CheckClassfileFlagsTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}