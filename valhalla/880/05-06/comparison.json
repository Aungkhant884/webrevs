{"files":[{"patch":"@@ -399,1 +399,1 @@\n-            if (m.getClass().isAssignableFrom(metadataClass)) {\n+            if (m.getClass() == metadataClass) {\n@@ -1118,1 +1118,3 @@\n-            return addMetadata(new ConstantValue(constValue));\n+            return isPrimitive() ?\n+                    addMetadata(new ConstantValue(constValue)) :\n+                    addMetadata(new ConstantValue(constValue)).addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1108,1 +1108,1 @@\n-            nullabilityComparator.reset((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n+            new NullabilityComparator((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n@@ -1228,1 +1228,1 @@\n-                    nullabilityComparator.reset((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n+                    new NullabilityComparator((t1, t2) -> hasNarrowerNullability(t1, t2)).visit(s, t);\n@@ -1277,1 +1277,0 @@\n-        public NullabilityComparator nullabilityComparator = new NullabilityComparator();\n@@ -1281,1 +1280,1 @@\n-            NullabilityComparator reset(BiFunction<Type, Type, Boolean> differentNullability) {\n+            NullabilityComparator(BiFunction<Type, Type, Boolean> differentNullability) {\n@@ -1283,1 +1282,0 @@\n-                return this;\n@@ -1514,2 +1512,1 @@\n-                    nullabilityComparator.reset((t1, t2) -> !hasSameNullability(t1, t2))\n-                            .visit(s, t);\n+                    new NullabilityComparator((t1, t2) -> !hasSameNullability(t1, t2)).visit(s, t);\n@@ -5406,2 +5403,0 @@\n-        \/\/ special case for literals, a literal is always != null\n-        boolean isLiteral = s != null && s.getMetadata(TypeMetadata.ConstantValue.class) != null;\n@@ -5412,1 +5407,1 @@\n-            return s.isNullUnspecified() && !isLiteral;\n+            return s.isNullUnspecified();\n@@ -5415,1 +5410,1 @@\n-            return s.isNonNullable() || isLiteral;\n+            return s.isNonNullable();\n@@ -5424,2 +5419,0 @@\n-        \/\/ special case for literals, a literal is always != null\n-        boolean isLiteral = s != null && s.getMetadata(TypeMetadata.ConstantValue.class) != null;\n@@ -5427,1 +5420,1 @@\n-            return s != null && !s.isNonNullable() && !isLiteral;\n+            return s != null && !s.isNonNullable();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -915,1 +915,1 @@\n-            if (pts.head.isNonNullable() && l.head.type.constValue() == null) {\n+            if (pts.head.isNonNullable()) {\n@@ -1101,1 +1101,1 @@\n-                if (tree.type.isNonNullable() && tree.init.type.constValue() == null) { \/\/ don't generate null checks on literals\n+                if (tree.type.isNonNullable()) {\n@@ -2126,1 +2126,1 @@\n-        if (tree.lhs.type.isNonNullable() && tree.rhs.type.constValue() == null) {\n+        if (tree.lhs.type.isNonNullable()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -612,1 +612,25 @@\n-                                                                \n+\n+                                    private static final VarHandle VALUE;\n+                                    static {\n+                                        try {\n+                                            MethodHandles.Lookup l = MethodHandles.lookup();\n+                                            VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n+                                        } catch (ReflectiveOperationException e) {\n+                                            throw new ExceptionInInitializerError(e);\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.lang.invoke.*;\n+                                class Cell {\n+                                    final void reset() {\n+                                        VALUE.setVolatile(this, 0L);\n+                                    }\n+                                    final void reset(long identity) {\n+                                        VALUE.setVolatile(this, identity);\n+                                    }\n+\n","filename":"test\/langtools\/tools\/javac\/bang\/BangTypesCompilationTests.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-            checkCorrectException(check::enumValue, \"java.lang.String\");\n+            checkCorrectException(check::enumValue, \"java.lang.String!\");\n","filename":"test\/langtools\/tools\/javac\/processing\/errors\/EnsureAnnotationTypeMismatchException\/Processor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}