{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,17 @@\n-ifeq ($(BUILD_CDS_ARCHIVE), true)\n+# Optimize CDS shared heap for small heap sizes, which are typically used\n+# for small cloud-based apps that have the most critical start-up requirement.\n+# The trade-off is that when larger heap sizes are used, the shared heap\n+# may need to be relocated at runtime.\n+CDS_DUMP_FLAGS = -Xmx128M -Xms128M\n+\n+# Helper function for creating the CDS archives for the JDK and JRE\n+#\n+# Param1 - VM variant (e.g., server, client, zero, ...)\n+# Param2 - _nocoops, or empty\n+define CreateCDSArchive\n+  $1_$2_DUMP_EXTRA_ARG := $(if $(filter _nocoops, $2),-XX:-UseCompressedOops,)\n+  $1_$2_DUMP_TYPE      := $(if $(filter _nocoops, $2),-NOCOOPS,)\n+\n+  # Only G1 supports dumping the shared heap, so explicitly use G1 if the JVM supports it.\n+  $1_$2_CDS_DUMP_FLAGS := $(CDS_DUMP_FLAGS) $(if $(filter g1gc, $(JVM_FEATURES_$1)),-XX:+UseG1GC)\n+\n@@ -124,2 +140,1 @@\n-    CDS_ARCHIVE := bin\/server\/classes.jsa\n-    CDS_NOCOOPS_ARCHIVE := bin\/server\/classes_nocoops.jsa\n+    $1_$2_CDS_ARCHIVE := bin\/$1\/classes$2.jsa\n@@ -127,2 +142,1 @@\n-    CDS_ARCHIVE := lib\/server\/classes.jsa\n-    CDS_NOCOOPS_ARCHIVE := lib\/server\/classes_nocoops.jsa\n+    $1_$2_CDS_ARCHIVE := lib\/$1\/classes$2.jsa\n@@ -131,8 +145,9 @@\n-  $(eval $(call SetupExecute, gen_cds_archive_jdk, \\\n-      WARN := Creating CDS archive for jdk image, \\\n-      DEPS := $(jlink_jdk), \\\n-      OUTPUT_FILE := $(JDK_IMAGE_DIR)\/$(CDS_ARCHIVE), \\\n-      SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jdk, \\\n-      COMMAND := $(FIXPATH) $(JDK_IMAGE_DIR)\/bin\/java -Xshare:dump \\\n-          -XX:SharedArchiveFile=$(JDK_IMAGE_DIR)\/$(CDS_ARCHIVE) \\\n-          -Xmx128M -Xms128M $(LOG_INFO), \\\n+  $$(eval $$(call SetupExecute, $1_$2_gen_cds_archive_jdk, \\\n+      WARN := Creating CDS$$($1_$2_DUMP_TYPE) archive for jdk image for $1, \\\n+      INFO := Using CDS flags for $1: $$($1_$2_CDS_DUMP_FLAGS), \\\n+      DEPS := $$(jlink_jdk), \\\n+      OUTPUT_FILE := $$(JDK_IMAGE_DIR)\/$$($1_$2_CDS_ARCHIVE), \\\n+      SUPPORT_DIR := $$(SUPPORT_OUTPUTDIR)\/images\/jdk, \\\n+      COMMAND := $$(FIXPATH) $$(JDK_IMAGE_DIR)\/bin\/java -Xshare:dump \\\n+          -XX:SharedArchiveFile=$$(JDK_IMAGE_DIR)\/$$($1_$2_CDS_ARCHIVE) \\\n+          -$1 $$($1_$2_DUMP_EXTRA_ARG) $$($1_$2_CDS_DUMP_FLAGS) $$(LOG_INFO), \\\n@@ -141,10 +156,11 @@\n-  JDK_TARGETS += $(gen_cds_archive_jdk)\n-\n-  $(eval $(call SetupExecute, gen_cds_archive_jre, \\\n-      WARN := Creating CDS archive for jre image, \\\n-      DEPS := $(jlink_jre), \\\n-      OUTPUT_FILE := $(JRE_IMAGE_DIR)\/$(CDS_ARCHIVE), \\\n-      SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jre, \\\n-      COMMAND := $(FIXPATH) $(JRE_IMAGE_DIR)\/bin\/java -Xshare:dump \\\n-          -XX:SharedArchiveFile=$(JRE_IMAGE_DIR)\/$(CDS_ARCHIVE) \\\n-          -Xmx128M -Xms128M $(LOG_INFO), \\\n+  JDK_TARGETS += $$($1_$2_gen_cds_archive_jdk)\n+\n+  $$(eval $$(call SetupExecute, $1_$2_gen_cds_archive_jre, \\\n+      WARN := Creating CDS$$($1_$2_DUMP_TYPE) archive for jre image for $1, \\\n+      INFO := Using CDS flags for $1: $$($1_$2_CDS_DUMP_FLAGS), \\\n+      DEPS := $$(jlink_jre), \\\n+      OUTPUT_FILE := $$(JRE_IMAGE_DIR)\/$$($1_$2_CDS_ARCHIVE), \\\n+      SUPPORT_DIR := $$(SUPPORT_OUTPUTDIR)\/images\/jre, \\\n+      COMMAND := $$(FIXPATH) $$(JRE_IMAGE_DIR)\/bin\/java -Xshare:dump \\\n+          -XX:SharedArchiveFile=$$(JRE_IMAGE_DIR)\/$$($1_$2_CDS_ARCHIVE) \\\n+          -$1 $$($1_$2_DUMP_EXTRA_ARG) $$($1_$2_CDS_DUMP_FLAGS) $$(LOG_INFO), \\\n@@ -153,1 +169,7 @@\n-  JRE_TARGETS += $(gen_cds_archive_jre)\n+  JRE_TARGETS += $$($1_$2_gen_cds_archive_jre)\n+endef\n+\n+ifeq ($(BUILD_CDS_ARCHIVE), true)\n+  $(foreach v, $(JVM_VARIANTS), \\\n+    $(eval $(call CreateCDSArchive,$v,)) \\\n+  )\n@@ -156,25 +178,3 @@\n-    $(eval $(call SetupExecute, gen_cds_nocoops_archive_jdk, \\\n-        WARN := Creating CDS-NOCOOPS archive for jdk image, \\\n-        DEPS := $(jlink_jdk), \\\n-        OUTPUT_FILE := $(JDK_IMAGE_DIR)\/$(CDS_NOCOOPS_ARCHIVE), \\\n-        SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jdk, \\\n-        COMMAND := $(FIXPATH) $(JDK_IMAGE_DIR)\/bin\/java -Xshare:dump \\\n-            -XX:SharedArchiveFile=$(JDK_IMAGE_DIR)\/$(CDS_NOCOOPS_ARCHIVE) \\\n-            -XX:-UseCompressedOops \\\n-            -Xmx128M -Xms128M $(LOG_INFO), \\\n-    ))\n-\n-    JDK_TARGETS += $(gen_cds_nocoops_archive_jdk)\n-\n-    $(eval $(call SetupExecute, gen_cds_nocoops_archive_jre, \\\n-        WARN := Creating CDS-NOCOOPS archive for jre image, \\\n-        DEPS := $(jlink_jre), \\\n-        OUTPUT_FILE := $(JRE_IMAGE_DIR)\/$(CDS_NOCOOPS_ARCHIVE), \\\n-        SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/images\/jre, \\\n-        COMMAND := $(FIXPATH) $(JRE_IMAGE_DIR)\/bin\/java -Xshare:dump \\\n-            -XX:SharedArchiveFile=$(JRE_IMAGE_DIR)\/$(CDS_NOCOOPS_ARCHIVE) \\\n-            -XX:-UseCompressedOops \\\n-            -Xmx128M -Xms128M $(LOG_INFO), \\\n-    ))\n-\n-    JRE_TARGETS += $(gen_cds_nocoops_archive_jre)\n+    $(foreach v, $(JVM_VARIANTS), \\\n+      $(eval $(call CreateCDSArchive,$v,_nocoops)) \\\n+    )\n@@ -182,1 +182,0 @@\n-\n","filename":"make\/Images.gmk","additions":50,"deletions":51,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -257,6 +257,1 @@\n-    \/\/ Extra settings for release profiles\n-    common.release_profile_base = {\n-        configure_args: [\n-            \"--enable-reproducible-build\",\n-        ],\n-    };\n+\n@@ -857,7 +852,0 @@\n-    \/\/ After creating all derived profiles, we can add the release profile base\n-    \/\/ to the main profiles\n-    common.main_profile_names.forEach(function (name) {\n-        profiles[name] = concatObjects(profiles[name],\n-            common.release_profile_base);\n-    });\n-\n@@ -958,1 +946,1 @@\n-                testedProfileTest\n+                testedProfileTest, testedProfile + \".jdk_symbols\",\n@@ -966,1 +954,2 @@\n-                \"TEST_IMAGE_DIR\": input.get(testedProfileTest, \"home_path\")\n+                \"TEST_IMAGE_DIR\": input.get(testedProfileTest, \"home_path\"),\n+                \"SYMBOLS_IMAGE_DIR\": input.get(testedProfile + \".jdk_symbols\", \"home_path\")\n@@ -1006,11 +995,0 @@\n-    \/\/ On windows we want the debug symbols available at test time\n-    if (input.build_os == \"windows\") {\n-        windowsRunTestPrebuiltExtra = {\n-            dependencies: [ testedProfile + \".jdk_symbols\" ],\n-            environment: {\n-                \"SYMBOLS_IMAGE_DIR\": input.get(testedProfile + \".jdk_symbols\", \"home_path\"),\n-            }\n-        };\n-        profiles[\"run-test-prebuilt\"] = concatObjects(profiles[\"run-test-prebuilt\"],\n-            windowsRunTestPrebuiltExtra);\n-    }\n","filename":"make\/conf\/jib-profiles.js","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -172,6 +172,7 @@\n-  # NOTE: Disable automatic opimization level and let the explicit cflag control\n-  # optimization level instead. This activates O3 on slowdebug builds, just\n-  # like the old build, but it's probably not right.\n-  JVM_OPTIMIZATION :=\n-  JVM_CFLAGS_FEATURES += -O3 -flto\n-  JVM_LDFLAGS_FEATURES += -O3 -flto -fuse-linker-plugin -fno-strict-aliasing\n+  # Set JVM_OPTIMIZATION directly so other jvm-feature flags can override it\n+  # later on if desired\n+  JVM_OPTIMIZATION := HIGHEST_JVM\n+  ifeq ($(call isCompiler, gcc), true)\n+    JVM_CFLAGS_FEATURES += -flto -fuse-linker-plugin\n+    JVM_LDFLAGS_FEATURES += -flto -fuse-linker-plugin -fno-strict-aliasing\n+  endif\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-   NO_FRAMEPOINTER_CFLAGS := -fomit-frame-pointer\n+  NO_FRAMEPOINTER_CFLAGS := -fomit-frame-pointer\n@@ -858,11 +858,11 @@\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LDFLAGS_libtest-rw := -z noexecstack\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LDFLAGS_libtest-rwx := -z execstack\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstepBreakPopReturn := -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIndyRedefineClass := -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefineClasses := -lpthread\n-    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeinvoke := -ljvm -lpthread\n-    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-gap := -ljvm -lpthread\n-    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-tls := -ljvm\n-    BUILD_TEST_exeinvoke_exeinvoke.c_OPTIMIZATION := NONE\n-    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeFPRegs := -ldl\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libAsyncGetCallTraceTest := -ldl\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LDFLAGS_libtest-rw := -z noexecstack\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LDFLAGS_libtest-rwx := -z execstack\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstepBreakPopReturn := -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIndyRedefineClass := -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefineClasses := -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeinvoke := -ljvm -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-gap := -ljvm -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-tls := -ljvm\n+  BUILD_TEST_exeinvoke_exeinvoke.c_OPTIMIZATION := NONE\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeFPRegs := -ldl\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libAsyncGetCallTraceTest := -ldl\n@@ -877,3 +877,4 @@\n-    BUILD_HOTSPOT_JTREG_EXECUTABLES_CFLAGS_exeFPRegs := -MT\n-    BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit := jvm.lib\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_CFLAGS_exeFPRegs := -MT\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit := jvm.lib\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exedaemonDestroy := jvm.lib\n@@ -881,637 +882,638 @@\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbootclssearch_agent += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsystemclssearch_agent += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprop001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprop002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libGetEnv001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetvern001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldecl002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldecl004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldecl001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libloadedclss001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libloadedclss002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libextevents001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdatadumpreq001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtimerinfo001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframecnt001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframecnt002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframecnt003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcontmon003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcontmon002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcontmon001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrtimerinfo001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetenvstor001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetenvstor002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetenvstor003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframeloc002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframeloc003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframeloc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass031 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass030 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass015 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass012 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass024 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass023 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass022 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass025 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass013 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass014 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstressRedefine += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass011 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass029 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass016 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass020 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass018 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass027 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass019 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass026 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass021 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass028 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass017 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass010 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjlocfmt002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjlocfmt001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetallstktr001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetcpool001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libextmech += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libheapref += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librefignore += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIsSyntheticIssynth001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgc += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonitor += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclsldrclss00x += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretvoid += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretlong += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretint += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretbase += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretstr += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretobj += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretfp += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetavailproc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclstat006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclstat007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclstat005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrinfo002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrinfo001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetthrdstor002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetthrdstor003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetthrdstor001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjsize001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libaddcaps001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libaddcaps002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libaddcaps003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmthd007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmthd006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmthd005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsrcfn006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsrcfn005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsrcfn004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetthrdstor001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libintrpthrd001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libintrpthrd002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libintrpthrd003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetenvstor001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetextevent001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetpotcaps001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfldw002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfldw001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libvminit001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrd001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrd002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrd003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendvthr001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdeclcls002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdeclcls003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdeclcls001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetjniftab002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetjniftab001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgeterrname002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgeterrname001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsettag001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstopthrd007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstopthrd006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgenevents001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldmdf004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldmdf003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrdlst001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrdlst002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrdlst001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrdlst002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIsMethodSyntheticIssynth001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libissynth002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonunload001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetsysprop002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetsysprop003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libMethodBind += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libOnUnload += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libStackTrace += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefineCFLH += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libAddToBootstrapClassLoaderSearch += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libDispose += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libenvironment += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnosuspendMonitorInfo += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnosuspendStackTrace += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetNullVMInit += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtimers += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libHeap += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libHotSwap += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach046Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach041Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach015Agent01 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach015Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach015Target += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach012Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach040Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach014Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach022Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach038Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach009Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsimpleAgent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach037Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach008Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach039Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach020Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach042Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent03 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent02 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent01 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach002aAgent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach021Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach050Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach002Agent00 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgettag001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnframepop001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnframepop003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnframepop002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libvmobjalloc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjwithtags001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethmod001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethmod002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmentry002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmentry001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe010 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe011 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcurthrtimerinfo001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfmodw001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfmodw002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisnative002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisnative001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liballthr001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liballthr002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjhashcode001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdyncodgen001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetnotif001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmexit001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmexit002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethloc002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethloc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbreakpoint001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetcaps001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetcaps002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclsldrclss001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclsldrclss002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmaxloc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmaxloc002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetintrf006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetintrf007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetintrf005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libexcatch001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrd002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrd001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjfree001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjfree002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldmod002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldmod001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libextfuncs001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libSetNativeMethodPrefix002Main += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libSetNativeMethodPrefix002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libSetNativeMethodPrefix001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassprep001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetvrbflag002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetvrbflag001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmcontentered001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetevntcallb001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetevntcallb002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetevntcallb003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgcfinish001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libownmoninf002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libownmoninf003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libownmoninf001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldnm003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldnm004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldnm005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf08t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf08t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf08t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf06t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf04t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi02t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi03t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi04t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi01t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libex03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t013 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t014 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t015 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t012 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t019 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t021 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t017 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t010 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t011 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t016 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t020 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t018 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp02t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp02t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp05t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp05t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp04t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp04t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp03t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp06t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp06t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp06t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp01t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp01t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp07t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp07t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc04t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc03t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc05t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma08t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma08t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma01t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma06t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma06t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma07t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma07t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma05t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma05t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma02t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma03t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t003a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t002a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t003a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t004a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t005a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t002a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t007a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t008a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t001a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t006a += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs103t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs104t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs104t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs202t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs202t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_build += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t011 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t010 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t012 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs201t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs201t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs201t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem06t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem01t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem07t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem07t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t012 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t010 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t011 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem05t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem05t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem04t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji06t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji05t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap10t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap11t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap02t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap05t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap05t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap04t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap04t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap04t003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap03t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap12t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap06t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap01t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap09t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap07t001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap07t002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadstart001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadstart003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadstart002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdealloc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libexceptionjni001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisfldsin003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisfldsin002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrgrpinfo001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrgrpinfo002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libAbort += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libCallbacks += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libNonConcreteKlassFilter += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libConcreteKlassFilter += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libHeapFilter += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmcontenter001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrbrk001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrbrk002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrbrk005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtopthrgrp002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtopthrgrp001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisarray004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisarray005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbytecodes003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbytecodes002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbytecodes001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadend001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadend002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetthrdgrpchld001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmonitorwait001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liballoc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsrcdebugex003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsrcdebugex002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsrcdebugex001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcrrawmon002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcrrawmon001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjniftab001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjniftab002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsldr003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsldr002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsldr001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcurthrcputime001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisobsolete001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libargsize001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libargsize002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclfld007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclfld006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclfld005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr008 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr009 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassload001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisintrf004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisintrf005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframepop001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframepop002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsig005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsig004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsig006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdisposeenv002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdisposeenv001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libexception001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresexhausted += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgcstart001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgcstart002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethname002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethname003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethname001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libforcegc001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libforcegc002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgettime001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonload001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonload002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonload003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrcputime002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrcputime001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmonitorwaited001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libForceEarlyReturn001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcompmethunload001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libretransform002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libretransform004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libretransform003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf007 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcompmethload001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprops001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprops002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdrrawmon003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdrrawmon004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdrrawmon001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsinglestep001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsinglestep003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsinglestep002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librelcaps001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librelcaps002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw004 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw003 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw005 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw006 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libvmdeath001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetphase001 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetphase002 += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libterminatedThread += -lpthread\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit += -ljvm\n-    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libCompleteExit += -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exedaemonDestroy := -ljvm\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbootclssearch_agent += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsystemclssearch_agent += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprop001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprop002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libGetEnv001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetvern001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldecl002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldecl004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldecl001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libloadedclss001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libloadedclss002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libextevents001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdatadumpreq001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtimerinfo001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrstat001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframecnt001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframecnt002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframecnt003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcontmon003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcontmon002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcontmon001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrtimerinfo001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetenvstor001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetenvstor002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetenvstor003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframeloc002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframeloc003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframeloc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass031 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass030 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass015 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass012 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass024 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass023 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass022 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass025 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass013 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass014 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstressRedefine += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass011 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass029 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass016 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass020 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass018 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass027 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass019 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass026 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass021 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass028 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass017 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefclass010 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjlocfmt002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjlocfmt001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetlocal004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetallstktr001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetcpool001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libextmech += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libheapref += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librefignore += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIsSyntheticIssynth001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgc += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonitor += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfollowref001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclsldrclss00x += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretvoid += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretlong += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretint += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretbase += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretstr += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretobj += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libearlyretfp += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetavailproc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclstat006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclstat007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclstat005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrinfo002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrinfo001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetthrdstor002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetthrdstor003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetthrdstor001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjsize001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libaddcaps001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libaddcaps002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libaddcaps003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmthd007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmthd006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmthd005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldacc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsrcfn006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsrcfn005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsrcfn004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetthrdstor001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libintrpthrd001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libintrpthrd002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libintrpthrd003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativemethbind001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetenvstor001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetextevent001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetpotcaps001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterobjreachobj003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfldw002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfldw001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libvminit001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrd001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrd002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrd003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendvthr001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdeclcls002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdeclcls003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdeclcls001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetjniftab002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetjniftab001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgeterrname002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgeterrname001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsettag001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstopthrd007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libstopthrd006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgenevents001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldmdf004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldmdf003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrdlst001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrdlst002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetbrk003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrdlst001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsuspendthrdlst002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libIsMethodSyntheticIssynth001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libissynth002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonunload001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetsysprop002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetsysprop003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libMethodBind += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libOnUnload += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libStackTrace += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libredefineCFLH += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libAddToBootstrapClassLoaderSearch += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libDispose += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libenvironment += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnosuspendMonitorInfo += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnosuspendStackTrace += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetNullVMInit += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtimers += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libHeap += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libHotSwap += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach046Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach041Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach015Agent01 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach015Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach015Target += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach012Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach040Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach014Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach022Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach038Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach009Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsimpleAgent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach037Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach008Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach039Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach020Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach042Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent03 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent02 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach045Agent01 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach002aAgent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach021Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach050Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libattach002Agent00 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgettag001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnframepop001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnframepop003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnframepop002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libvmobjalloc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjwithtags001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfy001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethmod001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethmod002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmentry002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmentry001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterheap001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe010 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe011 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libpopframe007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcurthrtimerinfo001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnwait001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfldw002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfmodw001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrfmodw002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisnative002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisnative001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterreachobj001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liballthr001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liballthr002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjhashcode001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdyncodgen001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetnotif001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmexit001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmexit002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethloc002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethloc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbreakpoint001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetcaps001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetcaps002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclsldrclss001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclsldrclss002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblinetab002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmaxloc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmaxloc002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassfloadhk009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetintrf006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetintrf007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetintrf005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libexcatch001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrd002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresumethrd001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjfree001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjfree002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldmod002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libfieldmod001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libextfuncs001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libSetNativeMethodPrefix002Main += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libSetNativeMethodPrefix002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libSetNativeMethodPrefix001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassprep001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetvrbflag002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetvrbflag001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmcontentered001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetevntcallb001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetevntcallb002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetevntcallb003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmnntfyall001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgcfinish001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libownmoninf002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libownmoninf003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libownmoninf001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldnm003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldnm004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetfldnm005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf08t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf08t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf08t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf06t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgf04t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi02t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi03t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi04t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi01t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbi01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libex03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t013 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t014 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t015 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t012 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t019 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t021 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t017 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t010 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t011 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t016 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t020 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t018 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcm01t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp02t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp02t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp05t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp05t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp04t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp04t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp03t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp06t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp06t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp06t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp01t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp01t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp07t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsp07t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc04t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc03t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc05t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtc01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma08t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma08t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma01t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma06t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma06t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma07t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma07t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma05t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma05t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma02t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma03t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t003a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t002a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma04t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t003a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t004a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t005a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t002a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t007a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t008a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t001a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libma10t006a += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs103t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs104t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs104t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs301t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs203t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs204t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs202t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs202t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_build += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t011 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t010 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs302t012 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs201t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs201t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libhs201t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem06t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem01t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem07t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem07t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t012 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t010 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem02t011 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem05t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem05t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libem04t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji06t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libji05t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap10t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap11t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap02t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap05t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap05t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap04t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap04t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap04t003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap03t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap12t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap06t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap01t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap09t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap07t001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libap07t002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadstart001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadstart003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadstart002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonenter001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdealloc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libexceptionjni001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisfldsin003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisfldsin002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrgrpinfo001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrgrpinfo002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libAbort += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libCallbacks += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libNonConcreteKlassFilter += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libConcreteKlassFilter += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libHeapFilter += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmcontenter001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrbrk001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrbrk002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclrbrk005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtopthrgrp002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libtopthrgrp001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisarray004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisarray005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbytecodes003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbytecodes002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libbytecodes001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadend001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthreadend002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetthrdgrpchld001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmonitorwait001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liballoc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsrcdebugex003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsrcdebugex002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsrcdebugex001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcrrawmon002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcrrawmon001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjniftab001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetjniftab002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsldr003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsldr002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsldr001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcurthrcputime001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librawmonexit003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisobsolete001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libargsize001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libargsize002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclfld007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclfld006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclfld005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr008 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr009 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetstacktr003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_liblocaltab005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libclassload001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisintrf004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libisintrf005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframepop001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libframepop002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsig005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsig004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclsig006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdisposeenv002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdisposeenv001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libexception001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libresexhausted += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgcstart001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgcstart002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libiterinstcls007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethname002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethname003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmethname001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libforcegc001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libforcegc002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgettime001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libobjmonusage007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonload001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonload002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentonload003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrcputime002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libthrcputime001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libmonitorwaited001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libForceEarlyReturn001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagentthr001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcompmethunload001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libretransform002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libretransform004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libretransform003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf007 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetclmdf005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetlocal002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libcompmethload001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprops001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetsysprops002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdrrawmon003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdrrawmon004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libdrrawmon001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsinglestep001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsinglestep003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsinglestep002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librelcaps001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_librelcaps002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw004 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw003 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw005 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw006 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libsetfmodw001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libvmdeath001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetphase001 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libgetphase002 += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libterminatedThread += -lpthread\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit += -ljvm\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libCompleteExit += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":654,"deletions":652,"binary":false,"changes":1306,"status":"modified"},{"patch":"@@ -182,4 +182,0 @@\n-  reg_def V0_L ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(4) );\n-  reg_def V0_M ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(5) );\n-  reg_def V0_N ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(6) );\n-  reg_def V0_O ( SOC, SOC, Op_RegF, 0, v0->as_VMReg()->next(7) );\n@@ -191,4 +187,0 @@\n-  reg_def V1_L ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(4) );\n-  reg_def V1_M ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(5) );\n-  reg_def V1_N ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(6) );\n-  reg_def V1_O ( SOC, SOC, Op_RegF, 1, v1->as_VMReg()->next(7) );\n@@ -200,4 +192,0 @@\n-  reg_def V2_L ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(4) );\n-  reg_def V2_M ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(5) );\n-  reg_def V2_N ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(6) );\n-  reg_def V2_O ( SOC, SOC, Op_RegF, 2, v2->as_VMReg()->next(7) );\n@@ -209,4 +197,0 @@\n-  reg_def V3_L ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(4) );\n-  reg_def V3_M ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(5) );\n-  reg_def V3_N ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(6) );\n-  reg_def V3_O ( SOC, SOC, Op_RegF, 3, v3->as_VMReg()->next(7) );\n@@ -218,4 +202,0 @@\n-  reg_def V4_L ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(4) );\n-  reg_def V4_M ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(5) );\n-  reg_def V4_N ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(6) );\n-  reg_def V4_O ( SOC, SOC, Op_RegF, 4, v4->as_VMReg()->next(7) );\n@@ -227,4 +207,0 @@\n-  reg_def V5_L ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(4) );\n-  reg_def V5_M ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(5) );\n-  reg_def V5_N ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(6) );\n-  reg_def V5_O ( SOC, SOC, Op_RegF, 5, v5->as_VMReg()->next(7) );\n@@ -236,4 +212,0 @@\n-  reg_def V6_L ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(4) );\n-  reg_def V6_M ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(5) );\n-  reg_def V6_N ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(6) );\n-  reg_def V6_O ( SOC, SOC, Op_RegF, 6, v6->as_VMReg()->next(7) );\n@@ -245,4 +217,0 @@\n-  reg_def V7_L ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(4) );\n-  reg_def V7_M ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(5) );\n-  reg_def V7_N ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(6) );\n-  reg_def V7_O ( SOC, SOC, Op_RegF, 7, v7->as_VMReg()->next(7) );\n@@ -254,4 +222,0 @@\n-  reg_def V8_L ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(4) );\n-  reg_def V8_M ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(5) );\n-  reg_def V8_N ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(6) );\n-  reg_def V8_O ( SOC, SOC, Op_RegF, 8, v8->as_VMReg()->next(7) );\n@@ -263,4 +227,0 @@\n-  reg_def V9_L ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(4) );\n-  reg_def V9_M ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(5) );\n-  reg_def V9_N ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(6) );\n-  reg_def V9_O ( SOC, SOC, Op_RegF, 9, v9->as_VMReg()->next(7) );\n@@ -272,4 +232,0 @@\n-  reg_def V10_L ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(4) );\n-  reg_def V10_M ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(5) );\n-  reg_def V10_N ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(6) );\n-  reg_def V10_O ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next(7) );\n@@ -281,4 +237,0 @@\n-  reg_def V11_L ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(4) );\n-  reg_def V11_M ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(5) );\n-  reg_def V11_N ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(6) );\n-  reg_def V11_O ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next(7) );\n@@ -290,4 +242,0 @@\n-  reg_def V12_L ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(4) );\n-  reg_def V12_M ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(5) );\n-  reg_def V12_N ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(6) );\n-  reg_def V12_O ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next(7) );\n@@ -299,4 +247,0 @@\n-  reg_def V13_L ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(4) );\n-  reg_def V13_M ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(5) );\n-  reg_def V13_N ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(6) );\n-  reg_def V13_O ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next(7) );\n@@ -308,4 +252,0 @@\n-  reg_def V14_L ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(4) );\n-  reg_def V14_M ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(5) );\n-  reg_def V14_N ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(6) );\n-  reg_def V14_O ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next(7) );\n@@ -317,4 +257,0 @@\n-  reg_def V15_L ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(4) );\n-  reg_def V15_M ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(5) );\n-  reg_def V15_N ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(6) );\n-  reg_def V15_O ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next(7) );\n@@ -326,4 +262,0 @@\n-  reg_def V16_L ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(4) );\n-  reg_def V16_M ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(5) );\n-  reg_def V16_N ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(6) );\n-  reg_def V16_O ( SOC, SOC, Op_RegF, 16, v16->as_VMReg()->next(7) );\n@@ -335,4 +267,0 @@\n-  reg_def V17_L ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(4) );\n-  reg_def V17_M ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(5) );\n-  reg_def V17_N ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(6) );\n-  reg_def V17_O ( SOC, SOC, Op_RegF, 17, v17->as_VMReg()->next(7) );\n@@ -344,4 +272,0 @@\n-  reg_def V18_L ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(4) );\n-  reg_def V18_M ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(5) );\n-  reg_def V18_N ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(6) );\n-  reg_def V18_O ( SOC, SOC, Op_RegF, 18, v18->as_VMReg()->next(7) );\n@@ -353,4 +277,0 @@\n-  reg_def V19_L ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(4) );\n-  reg_def V19_M ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(5) );\n-  reg_def V19_N ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(6) );\n-  reg_def V19_O ( SOC, SOC, Op_RegF, 19, v19->as_VMReg()->next(7) );\n@@ -362,4 +282,0 @@\n-  reg_def V20_L ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(4) );\n-  reg_def V20_M ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(5) );\n-  reg_def V20_N ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(6) );\n-  reg_def V20_O ( SOC, SOC, Op_RegF, 20, v20->as_VMReg()->next(7) );\n@@ -371,4 +287,0 @@\n-  reg_def V21_L ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(4) );\n-  reg_def V21_M ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(5) );\n-  reg_def V21_N ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(6) );\n-  reg_def V21_O ( SOC, SOC, Op_RegF, 21, v21->as_VMReg()->next(7) );\n@@ -380,4 +292,0 @@\n-  reg_def V22_L ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(4) );\n-  reg_def V22_M ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(5) );\n-  reg_def V22_N ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(6) );\n-  reg_def V22_O ( SOC, SOC, Op_RegF, 22, v22->as_VMReg()->next(7) );\n@@ -389,4 +297,0 @@\n-  reg_def V23_L ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(4) );\n-  reg_def V23_M ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(5) );\n-  reg_def V23_N ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(6) );\n-  reg_def V23_O ( SOC, SOC, Op_RegF, 23, v23->as_VMReg()->next(7) );\n@@ -398,4 +302,0 @@\n-  reg_def V24_L ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(4) );\n-  reg_def V24_M ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(5) );\n-  reg_def V24_N ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(6) );\n-  reg_def V24_O ( SOC, SOC, Op_RegF, 24, v24->as_VMReg()->next(7) );\n@@ -407,4 +307,0 @@\n-  reg_def V25_L ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(4) );\n-  reg_def V25_M ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(5) );\n-  reg_def V25_N ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(6) );\n-  reg_def V25_O ( SOC, SOC, Op_RegF, 25, v25->as_VMReg()->next(7) );\n@@ -416,4 +312,0 @@\n-  reg_def V26_L ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(4) );\n-  reg_def V26_M ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(5) );\n-  reg_def V26_N ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(6) );\n-  reg_def V26_O ( SOC, SOC, Op_RegF, 26, v26->as_VMReg()->next(7) );\n@@ -425,4 +317,0 @@\n-  reg_def V27_L ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(4) );\n-  reg_def V27_M ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(5) );\n-  reg_def V27_N ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(6) );\n-  reg_def V27_O ( SOC, SOC, Op_RegF, 27, v27->as_VMReg()->next(7) );\n@@ -434,4 +322,0 @@\n-  reg_def V28_L ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(4) );\n-  reg_def V28_M ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(5) );\n-  reg_def V28_N ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(6) );\n-  reg_def V28_O ( SOC, SOC, Op_RegF, 28, v28->as_VMReg()->next(7) );\n@@ -443,4 +327,0 @@\n-  reg_def V29_L ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(4) );\n-  reg_def V29_M ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(5) );\n-  reg_def V29_N ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(6) );\n-  reg_def V29_O ( SOC, SOC, Op_RegF, 29, v29->as_VMReg()->next(7) );\n@@ -452,4 +332,0 @@\n-  reg_def V30_L ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(4) );\n-  reg_def V30_M ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(5) );\n-  reg_def V30_N ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(6) );\n-  reg_def V30_O ( SOC, SOC, Op_RegF, 30, v30->as_VMReg()->next(7) );\n@@ -461,5 +337,0 @@\n-  reg_def V31_L ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(4) );\n-  reg_def V31_M ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(5) );\n-  reg_def V31_N ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(6) );\n-  reg_def V31_O ( SOC, SOC, Op_RegF, 31, v31->as_VMReg()->next(7) );\n-\n@@ -553,16 +424,16 @@\n-    V16, V16_H, V16_J, V16_K, V16_L, V16_M, V16_N, V16_O,\n-    V17, V17_H, V17_J, V17_K, V17_L, V17_M, V17_N, V17_O,\n-    V18, V18_H, V18_J, V18_K, V18_L, V18_M, V18_N, V18_O,\n-    V19, V19_H, V19_J, V19_K, V19_L, V19_M, V19_N, V19_O,\n-    V20, V20_H, V20_J, V20_K, V20_L, V20_M, V20_N, V20_O,\n-    V21, V21_H, V21_J, V21_K, V21_L, V21_M, V21_N, V21_O,\n-    V22, V22_H, V22_J, V22_K, V22_L, V22_M, V22_N, V22_O,\n-    V23, V23_H, V23_J, V23_K, V23_L, V23_M, V23_N, V23_O,\n-    V24, V24_H, V24_J, V24_K, V24_L, V24_M, V24_N, V24_O,\n-    V25, V25_H, V25_J, V25_K, V25_L, V25_M, V25_N, V25_O,\n-    V26, V26_H, V26_J, V26_K, V26_L, V26_M, V26_N, V26_O,\n-    V27, V27_H, V27_J, V27_K, V27_L, V27_M, V27_N, V27_O,\n-    V28, V28_H, V28_J, V28_K, V28_L, V28_M, V28_N, V28_O,\n-    V29, V29_H, V29_J, V29_K, V29_L, V29_M, V29_N, V29_O,\n-    V30, V30_H, V30_J, V30_K, V30_L, V30_M, V30_N, V30_O,\n-    V31, V31_H, V31_J, V31_K, V31_L, V31_M, V31_N, V31_O,\n+    V16, V16_H, V16_J, V16_K,\n+    V17, V17_H, V17_J, V17_K,\n+    V18, V18_H, V18_J, V18_K,\n+    V19, V19_H, V19_J, V19_K,\n+    V20, V20_H, V20_J, V20_K,\n+    V21, V21_H, V21_J, V21_K,\n+    V22, V22_H, V22_J, V22_K,\n+    V23, V23_H, V23_J, V23_K,\n+    V24, V24_H, V24_J, V24_K,\n+    V25, V25_H, V25_J, V25_K,\n+    V26, V26_H, V26_J, V26_K,\n+    V27, V27_H, V27_J, V27_K,\n+    V28, V28_H, V28_J, V28_K,\n+    V29, V29_H, V29_J, V29_K,\n+    V30, V30_H, V30_J, V30_K,\n+    V31, V31_H, V31_J, V31_K,\n@@ -571,8 +442,8 @@\n-    V0, V0_H, V0_J, V0_K, V0_L, V0_M, V0_N, V0_O,\n-    V1, V1_H, V1_J, V1_K, V1_L, V1_M, V1_N, V1_O,\n-    V2, V2_H, V2_J, V2_K, V2_L, V2_M, V2_N, V2_O,\n-    V3, V3_H, V3_J, V3_K, V3_L, V3_M, V3_N, V3_O,\n-    V4, V4_H, V4_J, V4_K, V4_L, V4_M, V4_N, V4_O,\n-    V5, V5_H, V5_J, V5_K, V5_L, V5_M, V5_N, V5_O,\n-    V6, V6_H, V6_J, V6_K, V6_L, V6_M, V6_N, V6_O,\n-    V7, V7_H, V7_J, V7_K, V7_L, V7_M, V7_N, V7_O,\n+    V0, V0_H, V0_J, V0_K,\n+    V1, V1_H, V1_J, V1_K,\n+    V2, V2_H, V2_J, V2_K,\n+    V3, V3_H, V3_J, V3_K,\n+    V4, V4_H, V4_J, V4_K,\n+    V5, V5_H, V5_J, V5_K,\n+    V6, V6_H, V6_J, V6_K,\n+    V7, V7_H, V7_J, V7_K,\n@@ -581,8 +452,8 @@\n-    V8, V8_H, V8_J, V8_K, V8_L, V8_M, V8_N, V8_O,\n-    V9, V9_H, V9_J, V9_K, V9_L, V9_M, V9_N, V9_O,\n-    V10, V10_H, V10_J, V10_K, V10_L, V10_M, V10_N, V10_O,\n-    V11, V11_H, V11_J, V11_K, V11_L, V11_M, V11_N, V11_O,\n-    V12, V12_H, V12_J, V12_K, V12_L, V12_M, V12_N, V12_O,\n-    V13, V13_H, V13_J, V13_K, V13_L, V13_M, V13_N, V13_O,\n-    V14, V14_H, V14_J, V14_K, V14_L, V14_M, V14_N, V14_O,\n-    V15, V15_H, V15_J, V15_K, V15_L, V15_M, V15_N, V15_O,\n+    V8, V8_H, V8_J, V8_K,\n+    V9, V9_H, V9_J, V9_K,\n+    V10, V10_H, V10_J, V10_K,\n+    V11, V11_H, V11_J, V11_K,\n+    V12, V12_H, V12_J, V12_K,\n+    V13, V13_H, V13_J, V13_K,\n+    V14, V14_H, V14_J, V14_K,\n+    V15, V15_H, V15_J, V15_K,\n@@ -903,32 +774,32 @@\n-    V0, V0_H, V0_J, V0_K, V0_L, V0_M, V0_N, V0_O,\n-    V1, V1_H, V1_J, V1_K, V1_L, V1_M, V1_N, V1_O,\n-    V2, V2_H, V2_J, V2_K, V2_L, V2_M, V2_N, V2_O,\n-    V3, V3_H, V3_J, V3_K, V3_L, V3_M, V3_N, V3_O,\n-    V4, V4_H, V4_J, V4_K, V4_L, V4_M, V4_N, V4_O,\n-    V5, V5_H, V5_J, V5_K, V5_L, V5_M, V5_N, V5_O,\n-    V6, V6_H, V6_J, V6_K, V6_L, V6_M, V6_N, V6_O,\n-    V7, V7_H, V7_J, V7_K, V7_L, V7_M, V7_N, V7_O,\n-    V8, V8_H, V8_J, V8_K, V8_L, V8_M, V8_N, V8_O,\n-    V9, V9_H, V9_J, V9_K, V9_L, V9_M, V9_N, V9_O,\n-    V10, V10_H, V10_J, V10_K, V10_L, V10_M, V10_N, V10_O,\n-    V11, V11_H, V11_J, V11_K, V11_L, V11_M, V11_N, V11_O,\n-    V12, V12_H, V12_J, V12_K, V12_L, V12_M, V12_N, V12_O,\n-    V13, V13_H, V13_J, V13_K, V13_L, V13_M, V13_N, V13_O,\n-    V14, V14_H, V14_J, V14_K, V14_L, V14_M, V14_N, V14_O,\n-    V15, V15_H, V15_J, V15_K, V15_L, V15_M, V15_N, V15_O,\n-    V16, V16_H, V16_J, V16_K, V16_L, V16_M, V16_N, V16_O,\n-    V17, V17_H, V17_J, V17_K, V17_L, V17_M, V17_N, V17_O,\n-    V18, V18_H, V18_J, V18_K, V18_L, V18_M, V18_N, V18_O,\n-    V19, V19_H, V19_J, V19_K, V19_L, V19_M, V19_N, V19_O,\n-    V20, V20_H, V20_J, V20_K, V20_L, V20_M, V20_N, V20_O,\n-    V21, V21_H, V21_J, V21_K, V21_L, V21_M, V21_N, V21_O,\n-    V22, V22_H, V22_J, V22_K, V22_L, V22_M, V22_N, V22_O,\n-    V23, V23_H, V23_J, V23_K, V23_L, V23_M, V23_N, V23_O,\n-    V24, V24_H, V24_J, V24_K, V24_L, V24_M, V24_N, V24_O,\n-    V25, V25_H, V25_J, V25_K, V25_L, V25_M, V25_N, V25_O,\n-    V26, V26_H, V26_J, V26_K, V26_L, V26_M, V26_N, V26_O,\n-    V27, V27_H, V27_J, V27_K, V27_L, V27_M, V27_N, V27_O,\n-    V28, V28_H, V28_J, V28_K, V28_L, V28_M, V28_N, V28_O,\n-    V29, V29_H, V29_J, V29_K, V29_L, V29_M, V29_N, V29_O,\n-    V30, V30_H, V30_J, V30_K, V30_L, V30_M, V30_N, V30_O,\n-    V31, V31_H, V31_J, V31_K, V31_L, V31_M, V31_N, V31_O,\n+    V0, V0_H, V0_J, V0_K,\n+    V1, V1_H, V1_J, V1_K,\n+    V2, V2_H, V2_J, V2_K,\n+    V3, V3_H, V3_J, V3_K,\n+    V4, V4_H, V4_J, V4_K,\n+    V5, V5_H, V5_J, V5_K,\n+    V6, V6_H, V6_J, V6_K,\n+    V7, V7_H, V7_J, V7_K,\n+    V8, V8_H, V8_J, V8_K,\n+    V9, V9_H, V9_J, V9_K,\n+    V10, V10_H, V10_J, V10_K,\n+    V11, V11_H, V11_J, V11_K,\n+    V12, V12_H, V12_J, V12_K,\n+    V13, V13_H, V13_J, V13_K,\n+    V14, V14_H, V14_J, V14_K,\n+    V15, V15_H, V15_J, V15_K,\n+    V16, V16_H, V16_J, V16_K,\n+    V17, V17_H, V17_J, V17_K,\n+    V18, V18_H, V18_J, V18_K,\n+    V19, V19_H, V19_J, V19_K,\n+    V20, V20_H, V20_J, V20_K,\n+    V21, V21_H, V21_J, V21_K,\n+    V22, V22_H, V22_J, V22_K,\n+    V23, V23_H, V23_J, V23_K,\n+    V24, V24_H, V24_J, V24_K,\n+    V25, V25_H, V25_J, V25_K,\n+    V26, V26_H, V26_J, V26_K,\n+    V27, V27_H, V27_J, V27_K,\n+    V28, V28_H, V28_J, V28_K,\n+    V29, V29_H, V29_J, V29_K,\n+    V30, V30_H, V30_J, V30_K,\n+    V31, V31_H, V31_J, V31_K,\n@@ -1317,3 +1188,0 @@\n-  \/\/ Assert that the given node is not a variable shift.\n-  bool assert_not_var_shift(const Node* n);\n-\n@@ -1734,6 +1602,0 @@\n-\/\/ Assert that the given node is not a variable shift.\n-bool assert_not_var_shift(const Node* n) {\n-  assert(!n->as_ShiftV()->is_var_shift(), \"illegal variable shift\");\n-  return true;\n-}\n-\n@@ -2036,1 +1898,1 @@\n-  int slots_of_int_registers = RegisterImpl::max_slots_per_register * RegisterImpl::number_of_registers;\n+  int slots_of_int_registers = Register::number_of_registers * Register::max_slots_per_register;\n@@ -2043,1 +1905,1 @@\n-  int slots_of_float_registers = FloatRegisterImpl::max_slots_per_register * FloatRegisterImpl::number_of_registers;\n+  int slots_of_float_registers = FloatRegister::number_of_registers * FloatRegister::max_slots_per_register;\n@@ -2048,1 +1910,1 @@\n-  int slots_of_predicate_registers = PRegisterImpl::max_slots_per_register * PRegisterImpl::number_of_registers;\n+  int slots_of_predicate_registers = PRegister::number_of_registers * PRegister::max_slots_per_register;\n@@ -2451,12 +2313,0 @@\n-    case Op_LoadVectorMasked:\n-    case Op_StoreVectorMasked:\n-    case Op_LoadVectorGatherMasked:\n-    case Op_StoreVectorScatterMasked:\n-    case Op_MaskAll:\n-    case Op_AndVMask:\n-    case Op_OrVMask:\n-    case Op_XorVMask:\n-      if (UseSVE == 0) {\n-        ret_value = false;\n-      }\n-      break;\n@@ -2468,76 +2318,0 @@\n-const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n-  if (UseSVE == 0) {\n-    \/\/ ConvD2I and ConvL2F are not profitable to be vectorized on NEON, because no direct\n-    \/\/ NEON instructions support them. But the match rule support for them is profitable for\n-    \/\/ Vector API intrinsics.\n-    if ((opcode == Op_VectorCastD2X && bt == T_INT) ||\n-        (opcode == Op_VectorCastL2X && bt == T_FLOAT)) {\n-      return false;\n-    }\n-  }\n-  return match_rule_supported_vector(opcode, vlen, bt);\n-}\n-\n-\/\/ Identify extra cases that we might want to provide match rules for vector nodes and\n-\/\/ other intrinsics guarded with vector length (vlen) and element type (bt).\n-const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {\n-  if (!match_rule_supported(opcode)) {\n-    return false;\n-  }\n-  int bit_size = vlen * type2aelembytes(bt) * 8;\n-  if (UseSVE == 0 && bit_size > 128) {\n-    return false;\n-  }\n-  if (UseSVE > 0) {\n-    return op_sve_supported(opcode, vlen, bt);\n-  } else { \/\/ NEON\n-    \/\/ Special cases\n-    switch (opcode) {\n-    case Op_VectorMaskCmp:\n-      if (vlen < 2 || bit_size < 64) {\n-        return false;\n-      }\n-      break;\n-    case Op_MulAddVS2VI:\n-      if (bit_size < 128) {\n-        return false;\n-      }\n-      break;\n-    case Op_MulVL:\n-    case Op_PopulateIndex:\n-      return false;\n-    case Op_VectorLoadShuffle:\n-    case Op_VectorRearrange:\n-      if (vlen < 4) {\n-        return false;\n-      }\n-      break;\n-    case Op_VectorMaskGen:\n-    case Op_LoadVectorGather:\n-    case Op_StoreVectorScatter:\n-    case Op_CompressV:\n-    case Op_CompressM:\n-    case Op_ExpandV:\n-    case Op_VectorLongToMask:\n-      return false;\n-    default:\n-      break;\n-    }\n-  }\n-  return vector_size_supported(bt, vlen);\n-}\n-\n-const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {\n-  \/\/ Only SVE supports masked operations.\n-  if (UseSVE == 0) {\n-    return false;\n-  }\n-  return match_rule_supported(opcode) &&\n-         masked_op_sve_supported(opcode, vlen, bt);\n-}\n-\n-const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {\n-  \/\/ Only SVE has partial vector operations\n-  return (UseSVE > 0) && partial_op_sve_needed(node, vt);\n-}\n-\n@@ -2610,1 +2384,1 @@\n-  if (UseSVE > 0 && 2 <= len && len <= 256) {\n+  if (UseSVE > 0 && 16 < len && len <= 256) {\n@@ -2624,2 +2398,8 @@\n-MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {\n-  ShouldNotReachHere(); \/\/ generic vector operands not supported\n+MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp) {\n+  assert(Matcher::is_generic_vector(generic_opnd), \"not generic\");\n+  switch (ideal_reg) {\n+    case Op_VecA: return new vecAOper();\n+    case Op_VecD: return new vecDOper();\n+    case Op_VecX: return new vecXOper();\n+  }\n+  ShouldNotReachHere();\n@@ -2630,1 +2410,0 @@\n-  ShouldNotReachHere();  \/\/ generic vector operands not supported\n@@ -2635,2 +2414,1 @@\n-  ShouldNotReachHere();  \/\/ generic vector operands not supported\n-  return false;\n+  return opnd->opcode() == VREG;\n@@ -3224,1 +3002,1 @@\n-  enc_class aarch64_enc_ldrvH(vecD dst, memory mem) %{\n+  enc_class aarch64_enc_ldrvH(vReg dst, memory mem) %{\n@@ -3230,1 +3008,1 @@\n-  enc_class aarch64_enc_ldrvS(vecD dst, memory mem) %{\n+  enc_class aarch64_enc_ldrvS(vReg dst, memory mem) %{\n@@ -3236,1 +3014,1 @@\n-  enc_class aarch64_enc_ldrvD(vecD dst, memory mem) %{\n+  enc_class aarch64_enc_ldrvD(vReg dst, memory mem) %{\n@@ -3242,1 +3020,1 @@\n-  enc_class aarch64_enc_ldrvQ(vecX dst, memory mem) %{\n+  enc_class aarch64_enc_ldrvQ(vReg dst, memory mem) %{\n@@ -3248,1 +3026,1 @@\n-  enc_class aarch64_enc_strvH(vecD src, memory mem) %{\n+  enc_class aarch64_enc_strvH(vReg src, memory mem) %{\n@@ -3254,1 +3032,1 @@\n-  enc_class aarch64_enc_strvS(vecD src, memory mem) %{\n+  enc_class aarch64_enc_strvS(vReg src, memory mem) %{\n@@ -3260,1 +3038,1 @@\n-  enc_class aarch64_enc_strvD(vecD src, memory mem) %{\n+  enc_class aarch64_enc_strvD(vReg src, memory mem) %{\n@@ -3266,1 +3044,1 @@\n-  enc_class aarch64_enc_strvQ(vecX src, memory mem) %{\n+  enc_class aarch64_enc_strvQ(vReg src, memory mem) %{\n@@ -3609,1 +3387,1 @@\n-        __ movoop(dst_reg, (jobject)con, \/*immediate*\/true);\n+        __ movoop(dst_reg, (jobject)con);\n@@ -4426,40 +4204,0 @@\n-operand immI_31()\n-%{\n-  predicate(n->get_int() == 31);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_2()\n-%{\n-  predicate(n->get_int() == 2);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_4()\n-%{\n-  predicate(n->get_int() == 4);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immI_8()\n-%{\n-  predicate(n->get_int() == 8);\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -5514,2 +5252,1 @@\n-\/\/ all vector operands, including NEON and SVE,\n-\/\/ but currently only used for SVE VecA.\n+\/\/ all vector operands, including NEON and SVE.\n@@ -5517,0 +5254,12 @@\n+%{\n+  constraint(ALLOC_IN_RC(dynamic));\n+  match(VecA);\n+  match(VecD);\n+  match(VecX);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vecA()\n@@ -5520,0 +5269,1 @@\n+\n@@ -6629,285 +6379,1 @@\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_dop_reg_reg_d(vRegD dst, vRegD src1, vRegD src2)\n-%{\n-  single_instruction;\n-  src1   : S1(read);\n-  src2   : S2(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_uop_s(vRegF dst, vRegF src)\n-%{\n-  single_instruction;\n-  src    : S1(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_uop_d(vRegD dst, vRegD src)\n-%{\n-  single_instruction;\n-  src    : S1(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_d2f(vRegF dst, vRegD src)\n-%{\n-  single_instruction;\n-  src    : S1(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_f2d(vRegD dst, vRegF src)\n-%{\n-  single_instruction;\n-  src    : S1(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_f2i(iRegINoSp dst, vRegF src)\n-%{\n-  single_instruction;\n-  src    : S1(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_f2l(iRegLNoSp dst, vRegF src)\n-%{\n-  single_instruction;\n-  src    : S1(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_i2f(vRegF dst, iRegIorL2I src)\n-%{\n-  single_instruction;\n-  src    : S1(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_l2f(vRegF dst, iRegL src)\n-%{\n-  single_instruction;\n-  src    : S1(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_d2i(iRegINoSp dst, vRegD src)\n-%{\n-  single_instruction;\n-  src    : S1(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_d2l(iRegLNoSp dst, vRegD src)\n-%{\n-  single_instruction;\n-  src    : S1(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_i2d(vRegD dst, iRegIorL2I src)\n-%{\n-  single_instruction;\n-  src    : S1(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_l2d(vRegD dst, iRegIorL2I src)\n-%{\n-  single_instruction;\n-  src    : S1(read);\n-  dst    : S5(write);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_div_s(vRegF dst, vRegF src1, vRegF src2)\n-%{\n-  single_instruction;\n-  src1   : S1(read);\n-  src2   : S2(read);\n-  dst    : S5(write);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_div_d(vRegD dst, vRegD src1, vRegD src2)\n-%{\n-  single_instruction;\n-  src1   : S1(read);\n-  src2   : S2(read);\n-  dst    : S5(write);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class fp_cond_reg_reg_s(vRegF dst, vRegF src1, vRegF src2, rFlagsReg cr)\n-%{\n-  single_instruction;\n-  cr     : S1(read);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  dst    : S3(write);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class fp_cond_reg_reg_d(vRegD dst, vRegD src1, vRegD src2, rFlagsReg cr)\n-%{\n-  single_instruction;\n-  cr     : S1(read);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  dst    : S3(write);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class fp_imm_s(vRegF dst)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class fp_imm_d(vRegD dst)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class fp_load_constant_s(vRegF dst)\n-%{\n-  single_instruction;\n-  dst    : S4(write);\n-  INS01  : ISS;\n-  NEON_FP : S4;\n-%}\n-\n-pipe_class fp_load_constant_d(vRegD dst)\n-%{\n-  single_instruction;\n-  dst    : S4(write);\n-  INS01  : ISS;\n-  NEON_FP : S4;\n-%}\n-\n-pipe_class vmul64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmul128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmla64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  dst    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vmla128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S5(write);\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  dst    : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S5;\n-%}\n-\n-pipe_class vdop64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S4(write);\n-  src1   : S2(read);\n-  src2   : S2(read);\n-  INS01  : ISS;\n-  NEON_FP : S4;\n-%}\n-\n-pipe_class vdop128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S4(write);\n-  src1   : S2(read);\n-  src2   : S2(read);\n-  INS0   : ISS;\n-  NEON_FP : S4;\n-%}\n-\n-pipe_class vlogical64(vecD dst, vecD src1, vecD src2)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src1   : S2(read);\n-  src2   : S2(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vlogical128(vecX dst, vecX src1, vecX src2)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src1   : S2(read);\n-  src2   : S2(read);\n-  INS0   : ISS;\n-  NEON_FP : S3;\n-%}\n-\n-pipe_class vshift64(vecD dst, vecD src, vecX shift)\n-%{\n-  single_instruction;\n-  dst    : S3(write);\n-  src    : S1(read);\n-  shift  : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n+  NEON_FP : S5;\n@@ -6916,1 +6382,1 @@\n-pipe_class vshift128(vecX dst, vecX src, vecX shift)\n+pipe_class fp_dop_reg_reg_d(vRegD dst, vRegD src1, vRegD src2)\n@@ -6919,5 +6385,5 @@\n-  dst    : S3(write);\n-  src    : S1(read);\n-  shift  : S1(read);\n-  INS0   : ISS;\n-  NEON_FP : S3;\n+  src1   : S1(read);\n+  src2   : S2(read);\n+  dst    : S5(write);\n+  INS01  : ISS;\n+  NEON_FP : S5;\n@@ -6926,1 +6392,1 @@\n-pipe_class vshift64_imm(vecD dst, vecD src, immI shift)\n+pipe_class fp_uop_s(vRegF dst, vRegF src)\n@@ -6929,1 +6395,1 @@\n-  dst    : S3(write);\n+  dst    : S5(write);\n@@ -6932,1 +6398,1 @@\n-  NEON_FP : S3;\n+  NEON_FP : S5;\n@@ -6935,1 +6401,1 @@\n-pipe_class vshift128_imm(vecX dst, vecX src, immI shift)\n+pipe_class fp_uop_d(vRegD dst, vRegD src)\n@@ -6938,3 +6404,3 @@\n-  dst    : S3(write);\n-  INS0   : ISS;\n-  NEON_FP : S3;\n+  dst    : S5(write);\n+  INS01  : ISS;\n+  NEON_FP : S5;\n@@ -6944,1 +6410,1 @@\n-pipe_class vdop_fp64(vecD dst, vecD src1, vecD src2)\n+pipe_class fp_d2f(vRegF dst, vRegD src)\n@@ -6947,0 +6413,1 @@\n+  src    : S1(read);\n@@ -6948,2 +6415,0 @@\n-  src1   : S1(read);\n-  src2   : S1(read);\n@@ -6954,1 +6419,1 @@\n-pipe_class vdop_fp128(vecX dst, vecX src1, vecX src2)\n+pipe_class fp_f2d(vRegD dst, vRegF src)\n@@ -6957,0 +6422,1 @@\n+  src    : S1(read);\n@@ -6958,3 +6424,1 @@\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS0   : ISS;\n+  INS01  : ISS;\n@@ -6964,1 +6428,1 @@\n-pipe_class vmuldiv_fp64(vecD dst, vecD src1, vecD src2)\n+pipe_class fp_f2i(iRegINoSp dst, vRegF src)\n@@ -6967,0 +6431,1 @@\n+  src    : S1(read);\n@@ -6968,3 +6433,1 @@\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS0   : ISS;\n+  INS01  : ISS;\n@@ -6974,1 +6437,1 @@\n-pipe_class vmuldiv_fp128(vecX dst, vecX src1, vecX src2)\n+pipe_class fp_f2l(iRegLNoSp dst, vRegF src)\n@@ -6977,0 +6440,1 @@\n+  src    : S1(read);\n@@ -6978,3 +6442,1 @@\n-  src1   : S1(read);\n-  src2   : S1(read);\n-  INS0   : ISS;\n+  INS01  : ISS;\n@@ -6984,1 +6446,1 @@\n-pipe_class vsqrt_fp128(vecX dst, vecX src)\n+pipe_class fp_i2f(vRegF dst, iRegIorL2I src)\n@@ -6987,2 +6449,2 @@\n-  dst    : S5(write);\n-  INS0   : ISS;\n+  dst    : S5(write);\n+  INS01  : ISS;\n@@ -6993,1 +6455,1 @@\n-pipe_class vunop_fp64(vecD dst, vecD src)\n+pipe_class fp_l2f(vRegF dst, iRegL src)\n@@ -6996,1 +6458,1 @@\n-  dst    : S5(write);\n+  dst    : S5(write);\n@@ -7002,1 +6464,1 @@\n-pipe_class vunop_fp128(vecX dst, vecX src)\n+pipe_class fp_d2i(iRegINoSp dst, vRegD src)\n@@ -7005,2 +6467,2 @@\n-  dst    : S5(write);\n-  INS0   : ISS;\n+  dst    : S5(write);\n+  INS01  : ISS;\n@@ -7011,1 +6473,1 @@\n-pipe_class vdup_reg_reg64(vecD dst, iRegI src)\n+pipe_class fp_d2l(iRegLNoSp dst, vRegD src)\n@@ -7014,1 +6476,1 @@\n-  dst    : S3(write);\n+  dst    : S5(write);\n@@ -7017,1 +6479,1 @@\n-  NEON_FP : S3;\n+  NEON_FP : S5;\n@@ -7020,1 +6482,1 @@\n-pipe_class vdup_reg_reg128(vecX dst, iRegI src)\n+pipe_class fp_i2d(vRegD dst, iRegIorL2I src)\n@@ -7023,1 +6485,1 @@\n-  dst    : S3(write);\n+  dst    : S5(write);\n@@ -7026,1 +6488,1 @@\n-  NEON_FP : S3;\n+  NEON_FP : S5;\n@@ -7029,1 +6491,1 @@\n-pipe_class vdup_reg_freg64(vecD dst, vRegF src)\n+pipe_class fp_l2d(vRegD dst, iRegIorL2I src)\n@@ -7032,1 +6494,1 @@\n-  dst    : S3(write);\n+  dst    : S5(write);\n@@ -7035,1 +6497,1 @@\n-  NEON_FP : S3;\n+  NEON_FP : S5;\n@@ -7038,1 +6500,1 @@\n-pipe_class vdup_reg_freg128(vecX dst, vRegF src)\n+pipe_class fp_div_s(vRegF dst, vRegF src1, vRegF src2)\n@@ -7041,4 +6503,5 @@\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n+  src1   : S1(read);\n+  src2   : S2(read);\n+  dst    : S5(write);\n+  INS0   : ISS;\n+  NEON_FP : S5;\n@@ -7047,1 +6510,1 @@\n-pipe_class vdup_reg_dreg128(vecX dst, vRegD src)\n+pipe_class fp_div_d(vRegD dst, vRegD src1, vRegD src2)\n@@ -7050,4 +6513,5 @@\n-  dst    : S3(write);\n-  src    : S1(read);\n-  INS01  : ISS;\n-  NEON_FP : S3;\n+  src1   : S1(read);\n+  src2   : S2(read);\n+  dst    : S5(write);\n+  INS0   : ISS;\n+  NEON_FP : S5;\n@@ -7056,1 +6520,1 @@\n-pipe_class vmovi_reg_imm64(vecD dst)\n+pipe_class fp_cond_reg_reg_s(vRegF dst, vRegF src1, vRegF src2, rFlagsReg cr)\n@@ -7059,0 +6523,3 @@\n+  cr     : S1(read);\n+  src1   : S1(read);\n+  src2   : S1(read);\n@@ -7064,1 +6531,1 @@\n-pipe_class vmovi_reg_imm128(vecX dst)\n+pipe_class fp_cond_reg_reg_d(vRegD dst, vRegD src1, vRegD src2, rFlagsReg cr)\n@@ -7067,0 +6534,3 @@\n+  cr     : S1(read);\n+  src1   : S1(read);\n+  src2   : S1(read);\n@@ -7068,1 +6538,1 @@\n-  INS0   : ISS;\n+  INS01  : ISS;\n@@ -7072,1 +6542,1 @@\n-pipe_class vload_reg_mem64(vecD dst, vmem8 mem)\n+pipe_class fp_imm_s(vRegF dst)\n@@ -7075,2 +6545,1 @@\n-  dst    : S5(write);\n-  mem    : ISS(read);\n+  dst    : S3(write);\n@@ -7081,1 +6550,1 @@\n-pipe_class vload_reg_mem128(vecX dst, vmem16 mem)\n+pipe_class fp_imm_d(vRegD dst)\n@@ -7084,2 +6553,1 @@\n-  dst    : S5(write);\n-  mem    : ISS(read);\n+  dst    : S3(write);\n@@ -7090,1 +6558,1 @@\n-pipe_class vstore_reg_mem64(vecD src, vmem8 mem)\n+pipe_class fp_load_constant_s(vRegF dst)\n@@ -7093,2 +6561,1 @@\n-  mem    : ISS(read);\n-  src    : S2(read);\n+  dst    : S4(write);\n@@ -7096,1 +6563,1 @@\n-  NEON_FP : S3;\n+  NEON_FP : S4;\n@@ -7099,1 +6566,1 @@\n-pipe_class vstore_reg_mem128(vecD src, vmem16 mem)\n+pipe_class fp_load_constant_d(vRegD dst)\n@@ -7102,2 +6569,1 @@\n-  mem    : ISS(read);\n-  src    : S2(read);\n+  dst    : S4(write);\n@@ -7105,1 +6571,1 @@\n-  NEON_FP : S3;\n+  NEON_FP : S4;\n@@ -9255,22 +8721,0 @@\n-instruct castVVD(vecD dst)\n-%{\n-  match(Set dst (CastVV dst));\n-\n-  size(0);\n-  format %{ \"# castVV of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_cost(0);\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n-instruct castVVX(vecX dst)\n-%{\n-  match(Set dst (CastVV dst));\n-\n-  size(0);\n-  format %{ \"# castVV of $dst\" %}\n-  ins_encode(\/* empty encoding *\/);\n-  ins_cost(0);\n-  ins_pipe(pipe_class_empty);\n-%}\n-\n@@ -9302,97 +8746,0 @@\n-\/\/ Intel and SPARC both implement Ideal Node LoadPLocked and\n-\/\/ Store{PIL}Conditional instructions using a normal load for the\n-\/\/ LoadPLocked and a CAS for the Store{PIL}Conditional.\n-\/\/\n-\/\/ The ideal code appears only to use LoadPLocked\/StorePLocked as a\n-\/\/ pair to lock object allocations from Eden space when not using\n-\/\/ TLABs.\n-\/\/\n-\/\/ There does not appear to be a Load{IL}Locked Ideal Node and the\n-\/\/ Ideal code appears to use Store{IL}Conditional as an alias for CAS\n-\/\/ and to use StoreIConditional only for 32-bit and StoreLConditional\n-\/\/ only for 64-bit.\n-\/\/\n-\/\/ We implement LoadPLocked and StorePLocked instructions using,\n-\/\/ respectively the AArch64 hw load-exclusive and store-conditional\n-\/\/ instructions. Whereas we must implement each of\n-\/\/ Store{IL}Conditional using a CAS which employs a pair of\n-\/\/ instructions comprising a load-exclusive followed by a\n-\/\/ store-conditional.\n-\n-\n-\/\/ Locked-load (linked load) of the current heap-top\n-\/\/ used when updating the eden heap top\n-\/\/ implemented using ldaxr on AArch64\n-\n-instruct loadPLocked(iRegPNoSp dst, indirect mem)\n-%{\n-  match(Set dst (LoadPLocked mem));\n-\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  format %{ \"ldaxr $dst, $mem\\t# ptr linked acquire\" %}\n-\n-  ins_encode(aarch64_enc_ldaxr(dst, mem));\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n-\/\/ Conditional-store of the updated heap-top.\n-\/\/ Used during allocation of the shared heap.\n-\/\/ Sets flag (EQ) on success.\n-\/\/ implemented using stlxr on AArch64.\n-\n-instruct storePConditional(memory8 heap_top_ptr, iRegP oldval, iRegP newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));\n-\n-  ins_cost(VOLATILE_REF_COST);\n-\n- \/\/ TODO\n- \/\/ do we need to do a store-conditional release or can we just use a\n- \/\/ plain store-conditional?\n-\n-  format %{\n-    \"stlxr rscratch1, $newval, $heap_top_ptr\\t# ptr cond release\"\n-    \"cmpw rscratch1, zr\\t# EQ on successful write\"\n-  %}\n-\n-  ins_encode(aarch64_enc_stlxr(newval, heap_top_ptr));\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct storeLConditional(indirect mem, iRegLNoSp oldval, iRegLNoSp newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StoreLConditional mem (Binary oldval newval)));\n-\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  format %{\n-    \"cmpxchg rscratch1, $mem, $oldval, $newval, $mem\\t# if $mem == $oldval then $mem <-- $newval\"\n-    \"cmpw rscratch1, zr\\t# EQ on successful write\"\n-  %}\n-\n-  ins_encode(aarch64_enc_cmpxchg_acq(mem, oldval, newval));\n-\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ storeIConditional also has acquire semantics, for no better reason\n-\/\/ than matching storeLConditional.  At the time of writing this\n-\/\/ comment storeIConditional was not used anywhere by AArch64.\n-instruct storeIConditional(indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StoreIConditional mem (Binary oldval newval)));\n-\n-  ins_cost(VOLATILE_REF_COST);\n-\n-  format %{\n-    \"cmpxchgw rscratch1, $mem, $oldval, $newval, $mem\\t# if $mem == $oldval then $mem <-- $newval\"\n-    \"cmpw rscratch1, zr\\t# EQ on successful write\"\n-  %}\n-\n-  ins_encode(aarch64_enc_cmpxchgw_acq(mem, oldval, newval));\n-\n-  ins_pipe(pipe_slow);\n-%}\n@@ -17160,0 +16507,2 @@\n+\/\/ Intrisics for String.compareTo()\n+\n@@ -17235,0 +16584,96 @@\n+\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n+\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n+\/\/ string_compare can be shared with all variants.\n+\n+instruct string_compareLL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::LL);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareLU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::LU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareUL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::UL);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareUU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::UU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -17399,0 +16844,32 @@\n+instruct stringL_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vecA ztmp1, vecA ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && ((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L);\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n+  ins_encode %{\n+    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register,\n+                               $result$$Register, $ztmp1$$FloatRegister,\n+                               $ztmp2$$FloatRegister, $pgtmp$$PRegister,\n+                               $ptmp$$PRegister, true \/* isL *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct stringU_indexof_char_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                                  iRegI_R0 result, vecA ztmp1, vecA ztmp2,\n+                                  pRegGov pgtmp, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && ((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U);\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  effect(TEMP ztmp1, TEMP ztmp2, TEMP pgtmp, TEMP ptmp, KILL cr);\n+  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result # use sve\" %}\n+  ins_encode %{\n+    __ string_indexof_char_sve($str1$$Register, $cnt1$$Register, $ch$$Register,\n+                               $result$$Register, $ztmp1$$FloatRegister,\n+                               $ztmp2$$FloatRegister, $pgtmp$$PRegister,\n+                               $ptmp$$PRegister, false \/* isL *\/);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":303,"deletions":826,"binary":false,"changes":1129,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-    __ movoop(reg, o, \/*immediate*\/true);\n+    __ movoop(reg, o);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-    CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);\n+    CodeBlob* sender_blob = CodeCache::find_blob(sender_pc);\n@@ -199,5 +199,0 @@\n-    \/\/ Could be a zombie method\n-    if (sender_blob->is_zombie() || sender_blob->is_unloaded()) {\n-      return false;\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"runtime\/synchronizer.hpp\"\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,4 +171,2 @@\n-  \/\/ when last_Java_sp is non-null but the pc fetched is junk. If we are truly\n-  \/\/ unlucky the junk value could be to a zombied method and we'll die on the\n-  \/\/ find_blob call. This is also why we can have no asserts on the validity\n-  \/\/ of the pc we find here. AsyncGetCallTrace -> pd_get_top_frame_for_signal_handler\n+  \/\/ when last_Java_sp is non-null but the pc fetched is junk.\n+  \/\/ AsyncGetCallTrace -> pd_get_top_frame_for_signal_handler\n@@ -342,3 +340,0 @@\n-  PRAGMA_DIAG_PUSH\n-  PRAGMA_NONNULL_IGNORED\n-  PRAGMA_DIAG_POP\n@@ -351,3 +346,0 @@\n-  PRAGMA_DIAG_PUSH\n-  PRAGMA_NONNULL_IGNORED\n-  PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,2 +34,1 @@\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n@@ -336,3 +335,0 @@\n-  if (tmp3 == noreg) {\n-    tmp3 = rscratch2;\n-  }\n@@ -343,2 +339,2 @@\n-    if (dst.base() != tmp1) {\n-      __ mov(tmp1, dst.base());\n+    if (dst.base() != tmp3) {\n+      __ mov(tmp3, dst.base());\n@@ -347,1 +343,1 @@\n-    __ lea(tmp1, dst);\n+    __ lea(tmp3, dst);\n@@ -352,1 +348,1 @@\n-                         tmp1 \/* obj *\/,\n+                         tmp3 \/* obj *\/,\n@@ -355,1 +351,1 @@\n-                         tmp3  \/* tmp *\/,\n+                         tmp1  \/* tmp *\/,\n@@ -361,1 +357,1 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), noreg, noreg, noreg, noreg);\n+    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), noreg, noreg, noreg, noreg);\n@@ -367,1 +363,1 @@\n-        new_val = tmp3;\n+        new_val = rscratch2;\n@@ -372,1 +368,1 @@\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp1, 0), val, noreg, noreg, noreg);\n+    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), val, noreg, noreg, noreg);\n@@ -376,1 +372,1 @@\n-                            tmp1 \/* store_adr *\/,\n+                            tmp3 \/* store_adr *\/,\n@@ -379,1 +375,1 @@\n-                            tmp2 \/* tmp *\/,\n+                            tmp1 \/* tmp *\/,\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3 = noreg);\n+                        Address dst, Register val, Register tmp1, Register tmp2, Register tmp3);\n@@ -78,0 +78,6 @@\n+  virtual bool supports_instruction_patching() {\n+    NMethodPatchingType patching_type = nmethod_patching_type();\n+    return patching_type == NMethodPatchingType::conc_instruction_and_data_patch ||\n+            patching_type == NMethodPatchingType::stw_instruction_and_data_patch;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,2 +102,2 @@\n-      __ lea(r3, dst);\n-      store_check(masm, r3, dst);\n+      __ lea(tmp3, dst);\n+      store_check(masm, tmp3, dst);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/cardTableBarrierSetAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -855,1 +855,1 @@\n-\/\/ Maybe emit a call via a trampoline.  If the code cache is small\n+\/\/ Maybe emit a call via a trampoline. If the code cache is small\n@@ -857,1 +857,1 @@\n-address MacroAssembler::trampoline_call1(Address entry, CodeBuffer* cbuf, bool check_emit_size) {\n+address MacroAssembler::trampoline_call(Address entry, CodeBuffer* cbuf) {\n@@ -863,0 +863,3 @@\n+  address target = entry.target();\n+\n+  \/\/ We might need a trampoline if branches are far.\n@@ -864,1 +867,1 @@\n-  if (!need_trampoline && entry.rspec().type() == relocInfo::runtime_call_type && !CodeCache::contains(entry.target())) {\n+  if (!need_trampoline && entry.rspec().type() == relocInfo::runtime_call_type && !CodeCache::contains(target)) {\n@@ -867,1 +870,0 @@\n-    address target = entry.target();\n@@ -878,4 +880,1 @@\n-  \/\/ We need a trampoline if branches are far.\n-    bool in_scratch_emit_size = false;\n-#ifdef COMPILER2\n-    if (check_emit_size) {\n+    if (!in_scratch_emit_size()) {\n@@ -885,11 +884,9 @@\n-      CompileTask* task = ciEnv::current()->task();\n-      in_scratch_emit_size =\n-        (task != NULL && is_c2_compile(task->comp_level()) &&\n-         Compile::current()->output()->in_scratch_emit_size());\n-    }\n-#endif\n-    if (!in_scratch_emit_size) {\n-      address stub = emit_trampoline_stub(offset(), entry.target());\n-      if (stub == NULL) {\n-        postcond(pc() == badAddress);\n-        return NULL; \/\/ CodeCache is full\n+      if (entry.rspec().type() == relocInfo::runtime_call_type) {\n+        assert(CodeBuffer::supports_shared_stubs(), \"must support shared stubs\");\n+        code()->share_trampoline_for(entry.target(), offset());\n+      } else {\n+        address stub = emit_trampoline_stub(offset(), target);\n+        if (stub == NULL) {\n+          postcond(pc() == badAddress);\n+          return NULL; \/\/ CodeCache is full\n+        }\n@@ -898,0 +895,1 @@\n+    target = pc();\n@@ -902,5 +900,2 @@\n-  if (!need_trampoline) {\n-    bl(entry.target());\n-  } else {\n-    bl(pc());\n-  }\n+  bl(target);\n+\n@@ -912,1 +907,0 @@\n-\n@@ -2370,1 +2364,1 @@\n-  regs[count++] = zr->encoding_nocheck();\n+  regs[count++] = zr->raw_encoding();\n@@ -2400,1 +2394,1 @@\n-  regs[count++] = zr->encoding_nocheck();\n+  regs[count++] = zr->raw_encoding();\n@@ -2555,1 +2549,1 @@\n-  unsigned char regs[PRegisterImpl::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_saved_registers];\n@@ -2557,1 +2551,1 @@\n-  for (int reg = 0; reg < PRegisterImpl::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n@@ -2592,1 +2586,1 @@\n-  unsigned char regs[PRegisterImpl::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_saved_registers];\n@@ -2594,1 +2588,1 @@\n-  for (int reg = 0; reg < PRegisterImpl::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n@@ -2625,1 +2619,1 @@\n-    cmpptr(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));\n+    cmpptr(rheapbase, ExternalAddress(CompressedOops::ptrs_base_addr()));\n@@ -2759,1 +2753,1 @@\n-      lea(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));\n+      lea(rheapbase, ExternalAddress(CompressedOops::ptrs_base_addr()));\n@@ -3082,2 +3076,2 @@\n-    sub(sp, sp, sve_vector_size_in_bytes * FloatRegisterImpl::number_of_registers);\n-    for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+    sub(sp, sp, sve_vector_size_in_bytes * FloatRegister::number_of_registers);\n+    for (int i = 0; i < FloatRegister::number_of_registers; i++) {\n@@ -3098,1 +3092,1 @@\n-    for (int i = 0; i < PRegisterImpl::number_of_saved_registers; i++) {\n+    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n@@ -3107,1 +3101,1 @@\n-    for (int i = PRegisterImpl::number_of_saved_registers - 1; i >= 0; i--) {\n+    for (int i = PRegister::number_of_saved_registers - 1; i >= 0; i--) {\n@@ -3113,1 +3107,1 @@\n-    for (int i = FloatRegisterImpl::number_of_registers - 1; i >= 0; i--) {\n+    for (int i = FloatRegister::number_of_registers - 1; i >= 0; i--) {\n@@ -3116,1 +3110,1 @@\n-    add(sp, sp, sve_vector_size_in_bytes * FloatRegisterImpl::number_of_registers);\n+    add(sp, sp, sve_vector_size_in_bytes * FloatRegister::number_of_registers);\n@@ -4587,2 +4581,1 @@\n-                                     Register tmp1, Register thread_tmp, Register tmp3) {\n-\n+                                     Register tmp1, Register tmp2, Register tmp3) {\n@@ -4593,1 +4586,1 @@\n-    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, thread_tmp, tmp3);\n+    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n@@ -4595,1 +4588,1 @@\n-    bs->store_at(this, decorators, type, dst, src, tmp1, thread_tmp, tmp3);\n+    bs->store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n@@ -4650,2 +4643,2 @@\n-                                    Register thread_tmp, Register tmp3, DecoratorSet decorators) {\n-  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp, tmp3);\n+                                    Register tmp2, Register tmp3, DecoratorSet decorators) {\n+  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);\n@@ -4666,5 +4659,2 @@\n-\/\/ Move an oop into a register.  immediate is true if we want\n-\/\/ immediate instructions and nmethod entry barriers are not enabled.\n-\/\/ i.e. we are not going to patch this instruction while the code is being\n-\/\/ executed by another thread.\n-void MacroAssembler::movoop(Register dst, jobject obj, bool immediate) {\n+\/\/ Move an oop into a register.\n+void MacroAssembler::movoop(Register dst, jobject obj) {\n@@ -4685,5 +4675,3 @@\n-  \/\/ nmethod entry barrier necessitate using the constant pool. They have to be\n-  \/\/ ordered with respected to oop accesses.\n-  \/\/ Using immediate literals would necessitate ISBs.\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  if ((bs->barrier_set_nmethod() != NULL && bs->barrier_set_assembler()->nmethod_patching_type() == NMethodPatchingType::conc_data_patch) || !immediate) {\n+  if (BarrierSet::barrier_set()->barrier_set_assembler()->supports_instruction_patching()) {\n+    mov(dst, Address((address)obj, rspec));\n+  } else {\n@@ -4692,2 +4680,1 @@\n-  } else\n-    mov(dst, Address((address)obj, rspec));\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":44,"deletions":57,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -672,0 +672,4 @@\n+  \/\/ Return whether code is emitted to a scratch blob.\n+  virtual bool in_scratch_emit_size() {\n+    return false;\n+  }\n@@ -888,1 +892,1 @@\n-                       Register tmp1, Register tmp_thread, Register tmp3 = noreg);\n+                       Register tmp1, Register tmp2, Register tmp3);\n@@ -905,1 +909,1 @@\n-                      Register tmp_thread = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);\n+                      Register tmp2 = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);\n@@ -1239,2 +1243,1 @@\n-  address trampoline_call(Address entry, CodeBuffer* cbuf = NULL) { return trampoline_call1(entry, cbuf, true); }\n-  address trampoline_call1(Address entry, CodeBuffer* cbuf, bool check_emit_size = true);\n+  address trampoline_call(Address entry, CodeBuffer* cbuf = NULL);\n@@ -1284,1 +1287,1 @@\n-  void movoop(Register dst, jobject obj, bool immediate = false);\n+  void movoop(Register dst, jobject obj);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -123,3 +124,3 @@\n-                rfp_off = r0_off + (RegisterImpl::number_of_registers - 2) * RegisterImpl::max_slots_per_register,\n-                return_off = rfp_off + RegisterImpl::max_slots_per_register,      \/\/ slot for return address\n-                reg_save_size = return_off + RegisterImpl::max_slots_per_register};\n+                rfp_off = r0_off + (Register::number_of_registers - 2) * Register::max_slots_per_register,\n+                return_off = rfp_off + Register::max_slots_per_register,      \/\/ slot for return address\n+                reg_save_size = return_off + Register::max_slots_per_register};\n@@ -135,1 +136,1 @@\n-  int slots_per_vect = FloatRegisterImpl::save_slots_per_register;\n+  int slots_per_vect = FloatRegister::save_slots_per_register;\n@@ -139,1 +140,1 @@\n-    slots_per_vect = FloatRegisterImpl::slots_per_neon_register;\n+    slots_per_vect = FloatRegister::slots_per_neon_register;\n@@ -149,1 +150,1 @@\n-  int r0_offset = v0_offset_in_bytes() + (slots_per_vect * FloatRegisterImpl::number_of_registers) * BytesPerInt;\n+  int r0_offset = v0_offset_in_bytes() + (slots_per_vect * FloatRegister::number_of_registers) * BytesPerInt;\n@@ -167,1 +168,1 @@\n-                    PRegisterImpl::number_of_saved_registers, 16);\n+                    PRegister::number_of_saved_registers, 16);\n@@ -195,1 +196,1 @@\n-      extra_save_slots_per_register = sve_vector_size_in_slots - FloatRegisterImpl::save_slots_per_register;\n+      extra_save_slots_per_register = sve_vector_size_in_slots - FloatRegister::save_slots_per_register;\n@@ -197,1 +198,1 @@\n-      extra_save_slots_per_register = FloatRegisterImpl::extra_save_slots_per_neon_register;\n+      extra_save_slots_per_register = FloatRegister::extra_save_slots_per_neon_register;\n@@ -201,1 +202,1 @@\n-                             FloatRegisterImpl::number_of_registers;\n+                             FloatRegister::number_of_registers;\n@@ -230,1 +231,1 @@\n-  for (int i = 0; i < RegisterImpl::number_of_registers; i++) {\n+  for (int i = 0; i < Register::number_of_registers; i++) {\n@@ -232,1 +233,1 @@\n-    if (r <= rfp && r != rscratch1 && r != rscratch2) {\n+    if (i <= rfp->encoding() && r != rscratch1 && r != rscratch2) {\n@@ -235,2 +236,2 @@\n-      int sp_offset = RegisterImpl::max_slots_per_register * i +\n-                      FloatRegisterImpl::save_slots_per_register * FloatRegisterImpl::number_of_registers;\n+      int sp_offset = Register::max_slots_per_register * i +\n+                      FloatRegister::save_slots_per_register * FloatRegister::number_of_registers;\n@@ -241,1 +242,1 @@\n-  for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+  for (int i = 0; i < FloatRegister::number_of_registers; i++) {\n@@ -246,1 +247,1 @@\n-                            (FloatRegisterImpl::slots_per_neon_register * i);\n+                            (FloatRegister::slots_per_neon_register * i);\n@@ -248,1 +249,1 @@\n-      sp_offset = FloatRegisterImpl::save_slots_per_register * i;\n+      sp_offset = FloatRegister::save_slots_per_register * i;\n@@ -254,1 +255,1 @@\n-    for (int i = 0; i < PRegisterImpl::number_of_saved_registers; i++) {\n+    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n@@ -293,2 +294,2 @@\n-\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register\n-\/\/ up to RegisterImpl::number_of_registers) are the 64-bit\n+\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.\n+\/\/ Register up to Register::number_of_registers are the 64-bit\n@@ -1340,2 +1341,1 @@\n-    __ cmp(c_rarg2, (u1)0);\n-    __ br(Assembler::NE, call_thaw);\n+    __ cbnz(c_rarg2, call_thaw);\n@@ -1344,1 +1344,1 @@\n-    __ trampoline_call1(resolve, NULL, false);\n+    __ trampoline_call(resolve);\n@@ -1366,2 +1366,1 @@\n-  __ cmp(c_rarg2, (u1)0);\n-  __ br(Assembler::NE, call_thaw);\n+  __ cbnz(c_rarg2, call_thaw);\n@@ -1370,1 +1369,1 @@\n-  __ trampoline_call1(resolve, NULL, false);\n+  __ trampoline_call(resolve);\n@@ -1761,3 +1760,3 @@\n-  bool reg_destroyed[RegisterImpl::number_of_registers];\n-  bool freg_destroyed[FloatRegisterImpl::number_of_registers];\n-  for ( int r = 0 ; r < RegisterImpl::number_of_registers ; r++ ) {\n+  bool reg_destroyed[Register::number_of_registers];\n+  bool freg_destroyed[FloatRegister::number_of_registers];\n+  for ( int r = 0 ; r < Register::number_of_registers ; r++ ) {\n@@ -1766,1 +1765,1 @@\n-  for ( int f = 0 ; f < FloatRegisterImpl::number_of_registers ; f++ ) {\n+  for ( int f = 0 ; f < FloatRegister::number_of_registers ; f++ ) {\n@@ -1847,2 +1846,1 @@\n-              JNIHandles::make_local(method->method_holder()->java_mirror()),\n-              \/*immediate*\/true);\n+              JNIHandles::make_local(method->method_holder()->java_mirror()));\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":30,"deletions":32,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -3074,2 +3074,3 @@\n-      for (FloatRegister f = v0; f < v0 + bulk_width; f++) {\n-        __ rev32(f, __ T16B, v16);\n+      for (int i = 0; i < bulk_width; i++) {\n+        FloatRegister v0_ofs = as_FloatRegister(v0->encoding() + i);\n+        __ rev32(v0_ofs, __ T16B, v16);\n@@ -3090,1 +3091,3 @@\n-        __ eor(v0 + i, __ T16B, v0 + i, v8 + i);\n+        FloatRegister v0_ofs = as_FloatRegister(v0->encoding() + i);\n+        FloatRegister v8_ofs = as_FloatRegister(v8->encoding() + i);\n+        __ eor(v0_ofs, __ T16B, v0_ofs, v8_ofs);\n@@ -3191,1 +3194,4 @@\n-      for (FloatRegister f = v0; f < v8; f++) {\n+\n+      assert(v0->encoding() < v8->encoding(), \"\");\n+      for (int i = v0->encoding(); i < v8->encoding(); i++) {\n+        FloatRegister f = as_FloatRegister(i);\n@@ -3205,1 +3211,3 @@\n-        __ eor(v0 + i, __ T16B, v0 + i, v8 + i);\n+        FloatRegister v0_ofs = as_FloatRegister(v0->encoding() + i);\n+        FloatRegister v8_ofs = as_FloatRegister(v8->encoding() + i);\n+        __ eor(v0_ofs, __ T16B, v0_ofs, v8_ofs);\n@@ -7275,1 +7283,2 @@\n-      assert(tmp1 < r19 && tmp2 < r19, \"register corruption\");\n+      assert(tmp1->encoding() < r19->encoding(), \"register corruption\");\n+      assert(tmp2->encoding() < r19->encoding(), \"register corruption\");\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -59,4 +59,0 @@\n-#ifndef PRODUCT\n-#include \"oops\/method.hpp\"\n-#endif \/\/ !PRODUCT\n-\n@@ -1126,1 +1122,1 @@\n-  bool inc_counter  = UseCompiler || CountCompiledCalls || LogTouchedMethods;\n+  bool inc_counter  = UseCompiler || CountCompiledCalls;\n@@ -1550,1 +1546,1 @@\n-  bool inc_counter  = UseCompiler || CountCompiledCalls || LogTouchedMethods;\n+  bool inc_counter  = UseCompiler || CountCompiledCalls;\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -148,1 +149,1 @@\n-  __ store_heap_oop(dst, val, r10, r1, noreg, decorators);\n+  __ store_heap_oop(dst, val, r10, r1, r3, decorators);\n@@ -1075,1 +1076,1 @@\n-  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), r0, noreg, noreg);\n+  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), r0, noreg, noreg, noreg);\n@@ -1087,1 +1088,1 @@\n-  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), r0, noreg, noreg);\n+  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), r0, noreg, noreg, noreg);\n@@ -1099,1 +1100,1 @@\n-  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), noreg \/* ftos *\/, noreg, noreg);\n+  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), noreg \/* ftos *\/, noreg, noreg, noreg);\n@@ -1111,1 +1112,1 @@\n-  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), noreg \/* dtos *\/, noreg, noreg);\n+  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), noreg \/* dtos *\/, noreg, noreg, noreg);\n@@ -1253,1 +1254,1 @@\n-  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(0)), r0, noreg, noreg);\n+  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(0)), r0, noreg, noreg, noreg);\n@@ -1266,1 +1267,1 @@\n-  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(1)), r0, noreg, noreg);\n+  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(1)), r0, noreg, noreg, noreg);\n@@ -2891,1 +2892,1 @@\n-    __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);\n+    __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg, noreg);\n@@ -2906,1 +2907,1 @@\n-    __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);\n+    __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg, noreg);\n@@ -2983,1 +2984,1 @@\n-    __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);\n+    __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg, noreg);\n@@ -2998,1 +2999,1 @@\n-    __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);\n+    __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg, noreg);\n@@ -3013,1 +3014,1 @@\n-    __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);\n+    __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg, noreg);\n@@ -3028,1 +3029,1 @@\n-    __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);\n+    __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg, noreg);\n@@ -3043,1 +3044,1 @@\n-    __ access_store_at(T_FLOAT, IN_HEAP, field, noreg \/* ftos *\/, noreg, noreg);\n+    __ access_store_at(T_FLOAT, IN_HEAP, field, noreg \/* ftos *\/, noreg, noreg, noreg);\n@@ -3060,1 +3061,1 @@\n-    __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg \/* dtos *\/, noreg, noreg);\n+    __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg \/* dtos *\/, noreg, noreg, noreg);\n@@ -3214,1 +3215,1 @@\n-    __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);\n+    __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg, noreg);\n@@ -3217,1 +3218,1 @@\n-    __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);\n+    __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg, noreg);\n@@ -3220,1 +3221,1 @@\n-    __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);\n+    __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg, noreg);\n@@ -3223,1 +3224,1 @@\n-    __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);\n+    __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg, noreg);\n@@ -3226,1 +3227,1 @@\n-    __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);\n+    __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg, noreg);\n@@ -3229,1 +3230,1 @@\n-    __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);\n+    __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg, noreg);\n@@ -3232,1 +3233,1 @@\n-    __ access_store_at(T_FLOAT, IN_HEAP, field, noreg \/* ftos *\/, noreg, noreg);\n+    __ access_store_at(T_FLOAT, IN_HEAP, field, noreg \/* ftos *\/, noreg, noreg, noreg);\n@@ -3235,1 +3236,1 @@\n-    __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg \/* dtos *\/, noreg, noreg);\n+    __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg \/* dtos *\/, noreg, noreg, noreg);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/os.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2213,1 +2213,1 @@\n-  assert(UseCompiler || LogTouchedMethods, \"incrementing must be useful\");\n+  assert(UseCompiler, \"incrementing must be useful\");\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1923,1 +1923,1 @@\n-  assert(UseCompiler || LogTouchedMethods, \"incrementing must be useful\");\n+  assert(UseCompiler, \"incrementing must be useful\");\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -642,1 +642,1 @@\n-    __ incrementl(ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt));\n+    __ incrementl(ExternalAddress((address)&Runtime1::_arraycopy_slowcase_cnt), rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-      __ push_oop(const_opr->as_jobject());\n+      __ push_oop(const_opr->as_jobject(), rscratch1);\n@@ -324,1 +324,1 @@\n-        __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), (int32_t)NULL_WORD);\n+        __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), NULL_WORD);\n@@ -445,2 +445,2 @@\n-  __ movptr(Address(thread, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);\n-  __ movptr(Address(thread, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);\n+  __ movptr(Address(thread, JavaThread::exception_oop_offset()), NULL_WORD);\n+  __ movptr(Address(thread, JavaThread::exception_pc_offset()), NULL_WORD);\n@@ -474,1 +474,1 @@\n-    __ mov_metadata(Address(rsp, sizeof(void*)), method()->constant_encoding());\n+    __ mov_metadata(Address(rsp, sizeof(void*)), method()->constant_encoding(), noreg);\n@@ -508,1 +508,1 @@\n-  __ pushptr(here.addr());\n+  __ pushptr(here.addr(), rscratch1);\n@@ -718,1 +718,1 @@\n-      __ movoop(frame_map()->address_for_slot(dest->single_stack_ix()), c->as_jobject());\n+      __ movoop(frame_map()->address_for_slot(dest->single_stack_ix()), c->as_jobject(), rscratch1);\n@@ -725,1 +725,3 @@\n-                                            lo_word_offset_in_bytes), (intptr_t)c->as_jlong_bits());\n+                                              lo_word_offset_in_bytes),\n+                (intptr_t)c->as_jlong_bits(),\n+                rscratch1);\n@@ -761,1 +763,1 @@\n-          __ movl(as_Address(addr), (int32_t)NULL_WORD);\n+          __ movl(as_Address(addr), NULL_WORD);\n@@ -774,1 +776,1 @@\n-          __ movoop(as_Address(addr, noreg), c->as_jobject());\n+          __ movoop(as_Address(addr, noreg), c->as_jobject(), rscratch1);\n@@ -787,1 +789,1 @@\n-          __ movoop(as_Address(addr), c->as_jobject());\n+          __ movoop(as_Address(addr), c->as_jobject(), noreg);\n@@ -1689,1 +1691,1 @@\n-    __ cmpptr(recv_addr, (intptr_t)NULL_WORD);\n+    __ cmpptr(recv_addr, NULL_WORD);\n@@ -1742,1 +1744,1 @@\n-    __ cmpptr(obj, (int32_t)NULL_WORD);\n+    __ cmpptr(obj, NULL_WORD);\n@@ -1816,1 +1818,1 @@\n-        __ pushklass(k->constant_encoding());\n+        __ pushklass(k->constant_encoding(), noreg);\n@@ -1889,1 +1891,1 @@\n-    __ cmpptr(value, (int32_t)NULL_WORD);\n+    __ cmpptr(value, NULL_WORD);\n@@ -1986,1 +1988,1 @@\n-    __ cmpptr(op->value()->as_register(), (int32_t)NULL_WORD);\n+    __ cmpptr(op->value()->as_register(), NULL_WORD);\n@@ -2109,1 +2111,1 @@\n-    assert(newval != NULL, \"new val must be register\");\n+    assert(newval != noreg, \"new val must be register\");\n@@ -2140,1 +2142,1 @@\n-    assert(newval != NULL, \"new val must be register\");\n+    assert(newval != noreg, \"new val must be register\");\n@@ -2603,1 +2605,2 @@\n-                     ExternalAddress((address)double_signmask_pool));\n+                     ExternalAddress((address)double_signmask_pool),\n+                     rscratch1);\n@@ -2834,1 +2837,1 @@\n-          __ cmpptr(reg1, (int32_t)0);\n+          __ cmpptr(reg1, NULL_WORD);\n@@ -2842,1 +2845,1 @@\n-          __ cmpptr(reg1, (int32_t)NULL_WORD);\n+          __ cmpptr(reg1, NULL_WORD);\n@@ -2844,1 +2847,1 @@\n-          __ cmpoop(reg1, o);\n+          __ cmpoop(reg1, o, rscratch1);\n@@ -3206,1 +3209,1 @@\n-void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {\n+void LIR_Assembler::store_parameter(jobject o, int offset_from_rsp_in_words) {\n@@ -3210,1 +3213,1 @@\n-  __ movoop (Address(rsp, offset_from_rsp_in_bytes), o);\n+  __ movoop(Address(rsp, offset_from_rsp_in_bytes), o, rscratch1);\n@@ -3214,1 +3217,1 @@\n-void LIR_Assembler::store_parameter(Metadata* m,  int offset_from_rsp_in_words) {\n+void LIR_Assembler::store_parameter(Metadata* m, int offset_from_rsp_in_words) {\n@@ -3218,1 +3221,1 @@\n-  __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m);\n+  __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m, rscratch1);\n@@ -3312,1 +3315,1 @@\n-      __ incrementl(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt));\n+      __ incrementl(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt), rscratch1);\n@@ -3321,1 +3324,1 @@\n-      __ incrementl(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt));\n+      __ incrementl(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt), rscratch1);\n@@ -3335,1 +3338,1 @@\n-      __ incrementl(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt));\n+      __ incrementl(ExternalAddress((address)&Runtime1::_generic_arraycopystub_cnt), rscratch1);\n@@ -3576,1 +3579,1 @@\n-          __ incrementl(ExternalAddress((address)&Runtime1::_arraycopy_checkcast_cnt));\n+          __ incrementl(ExternalAddress((address)&Runtime1::_arraycopy_checkcast_cnt), rscratch1);\n@@ -3586,1 +3589,1 @@\n-          __ incrementl(ExternalAddress((address)&Runtime1::_arraycopy_checkcast_attempt_cnt));\n+          __ incrementl(ExternalAddress((address)&Runtime1::_arraycopy_checkcast_attempt_cnt), rscratch1);\n@@ -3795,1 +3798,1 @@\n-          __ mov_metadata(recv_addr, known_klass->constant_encoding());\n+          __ mov_metadata(recv_addr, known_klass->constant_encoding(), rscratch1);\n@@ -4047,1 +4050,2 @@\n-               ExternalAddress((address)float_signflip_pool));\n+               ExternalAddress((address)float_signflip_pool),\n+               rscratch1);\n@@ -4064,1 +4068,2 @@\n-               ExternalAddress((address)double_signflip_pool));\n+               ExternalAddress((address)double_signflip_pool),\n+               rscratch1);\n@@ -4255,1 +4260,1 @@\n-  __ cmpptr(frame_map()->address_for_orig_pc_addr(), (int32_t)NULL_WORD);\n+  __ cmpptr(frame_map()->address_for_orig_pc_addr(), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":40,"deletions":35,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-  \/\/ When we need to use something other than rscratch1 use this\n-  \/\/ method.\n+  \/\/ When we need to use something other than rscratch1 use this method.\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -42,1 +43,0 @@\n-  const Register rklass_decode_tmp = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n@@ -58,1 +58,1 @@\n-    load_klass(hdr, obj, rklass_decode_tmp);\n+    load_klass(hdr, obj, rscratch1);\n@@ -153,1 +153,0 @@\n-  Register tmp_encode_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n@@ -161,1 +160,1 @@\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), checked_cast<int32_t>(markWord::prototype().value()));\n@@ -166,1 +165,1 @@\n-    encode_klass_not_null(t1, tmp_encode_klass);\n+    encode_klass_not_null(t1, rscratch1);\n@@ -268,1 +267,1 @@\n-  cmpptr(len, (int32_t)max_array_allocation_length);\n+  cmpptr(len, checked_cast<int32_t>(max_array_allocation_length));\n@@ -273,1 +272,1 @@\n-  movptr(arr_size, (int32_t)header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  movptr(arr_size, header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n@@ -301,1 +300,0 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch2) NOT_LP64(noreg);\n@@ -304,1 +302,1 @@\n-    load_klass(rscratch1, receiver, tmp_load_klass);\n+    load_klass(rscratch1, receiver, rscratch2);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -79,1 +80,1 @@\n-    set_last_Java_frame(thread, noreg, rbp, NULL);\n+    set_last_Java_frame(thread, noreg, rbp, NULL, rscratch1);\n@@ -83,1 +84,1 @@\n-    set_last_Java_frame(thread, noreg, rbp, the_pc);\n+    set_last_Java_frame(thread, noreg, rbp, the_pc, rscratch1);\n@@ -113,1 +114,1 @@\n-    cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+    cmpptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -323,4 +324,0 @@\n-\/\/ Register is a class, but it would be assigned numerical value.\n-\/\/ \"0\" is assigned for rax. Thus we need to ignore -Wnonnull.\n-PRAGMA_DIAG_PUSH\n-PRAGMA_NONNULL_IGNORED\n@@ -421,1 +418,0 @@\n-PRAGMA_DIAG_POP\n@@ -737,1 +733,1 @@\n-  __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), (int32_t) NULL_WORD);\n+  __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), NULL_WORD);\n@@ -893,1 +889,1 @@\n-  __ set_last_Java_frame(thread, noreg, rbp, NULL);\n+  __ set_last_Java_frame(thread, noreg, rbp, NULL, rscratch1);\n@@ -919,1 +915,1 @@\n-    __ cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -943,1 +939,1 @@\n-    __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), NULL_WORD);\n@@ -949,1 +945,1 @@\n-    __ cmpptr(Address(thread, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(thread, JavaThread::exception_pc_offset()), NULL_WORD);\n@@ -1262,2 +1258,1 @@\n-        Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-        __ load_klass(t, rax, tmp_load_klass);\n+        __ load_klass(t, rax, rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-    movptr(tmpReg, ExternalAddress((address) RTMLockingCounters::rtm_calculation_flag_addr()), tmpReg);\n+    movptr(tmpReg, ExternalAddress((address) RTMLockingCounters::rtm_calculation_flag_addr()));\n@@ -401,2 +401,1 @@\n-  \/\/ Without cast to int32_t this style of movptr will destroy r10 which is typically obj.\n-  movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));\n+  movptr(Address(boxReg, 0), checked_cast<int32_t>(markWord::unused_mark().value()));\n@@ -687,1 +686,1 @@\n-  movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));\n+  movptr(Address(boxReg, 0), checked_cast<int32_t>(markWord::unused_mark().value()));\n@@ -782,1 +781,1 @@\n-    cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   \/\/ Examine the displaced header\n+    cmpptr(Address(boxReg, 0), NULL_WORD);                            \/\/ Examine the displaced header\n@@ -872,1 +871,1 @@\n-  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);\n+  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n@@ -882,1 +881,1 @@\n-  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);\n+  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n@@ -887,1 +886,1 @@\n-  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);\n+  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n@@ -898,1 +897,1 @@\n-  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);\n+  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n@@ -961,1 +960,1 @@\n-void C2_MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, Register scr) {\n+void C2_MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src) {\n@@ -966,1 +965,1 @@\n-    andpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), scr);\n+    andpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), noreg);\n@@ -969,1 +968,1 @@\n-    xorpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), scr);\n+    xorpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), noreg);\n@@ -973,1 +972,1 @@\n-void C2_MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr) {\n+void C2_MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, int vector_len) {\n@@ -975,1 +974,1 @@\n-    vandpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), vector_len, scr);\n+    vandpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), vector_len, noreg);\n@@ -978,1 +977,1 @@\n-    vxorpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vector_len, scr);\n+    vxorpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vector_len, noreg);\n@@ -982,1 +981,1 @@\n-void C2_MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, Register scr) {\n+void C2_MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src) {\n@@ -987,1 +986,1 @@\n-    andps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), scr);\n+    andps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), noreg);\n@@ -990,1 +989,1 @@\n-    xorps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), scr);\n+    xorps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), noreg);\n@@ -994,1 +993,1 @@\n-void C2_MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr) {\n+void C2_MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, int vector_len) {\n@@ -996,1 +995,1 @@\n-    vandps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), vector_len, scr);\n+    vandps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), vector_len, noreg);\n@@ -999,1 +998,1 @@\n-    vxorps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vector_len, scr);\n+    vxorps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vector_len, noreg);\n@@ -1172,3 +1171,1 @@\n-void C2_MacroAssembler::signum_fp(int opcode, XMMRegister dst,\n-                                  XMMRegister zero, XMMRegister one,\n-                                  Register scratch) {\n+void C2_MacroAssembler::signum_fp(int opcode, XMMRegister dst, XMMRegister zero, XMMRegister one) {\n@@ -1186,1 +1183,1 @@\n-    xorps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), scratch);\n+    xorps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), noreg);\n@@ -1194,1 +1191,1 @@\n-    xorpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), scratch);\n+    xorpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), noreg);\n@@ -1453,1 +1450,1 @@\n-void C2_MacroAssembler::varshiftbw(int opcode, XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len, XMMRegister vtmp, Register scratch) {\n+void C2_MacroAssembler::varshiftbw(int opcode, XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len, XMMRegister vtmp) {\n@@ -1462,1 +1459,1 @@\n-  vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_int_to_byte_mask()), 1, scratch);\n+  vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_int_to_byte_mask()), 1, noreg);\n@@ -1468,1 +1465,1 @@\n-void C2_MacroAssembler::evarshiftb(int opcode, XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len, XMMRegister vtmp, Register scratch) {\n+void C2_MacroAssembler::evarshiftb(int opcode, XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len, XMMRegister vtmp) {\n@@ -1477,1 +1474,1 @@\n-  vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_short_to_byte_mask()), ext_vector_len, scratch);\n+  vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_short_to_byte_mask()), ext_vector_len, noreg);\n@@ -1622,2 +1619,1 @@\n-void C2_MacroAssembler::load_vector_mask(KRegister dst, XMMRegister src, XMMRegister xtmp,\n-                                         Register tmp, bool novlbwdq, int vlen_enc) {\n+void C2_MacroAssembler::load_vector_mask(KRegister dst, XMMRegister src, XMMRegister xtmp, bool novlbwdq, int vlen_enc) {\n@@ -1627,1 +1623,1 @@\n-            Assembler::eq, true, vlen_enc, tmp);\n+            Assembler::eq, true, vlen_enc, noreg);\n@@ -1637,6 +1633,6 @@\n-  case 4:  movdl(dst, src);   break;\n-  case 8:  movq(dst, src);    break;\n-  case 16: movdqu(dst, src);  break;\n-  case 32: vmovdqu(dst, src); break;\n-  case 64: evmovdquq(dst, src, Assembler::AVX_512bit); break;\n-  default: ShouldNotReachHere();\n+    case 4:  movdl(dst, src);   break;\n+    case 8:  movq(dst, src);    break;\n+    case 16: movdqu(dst, src);  break;\n+    case 32: vmovdqu(dst, src); break;\n+    case 64: evmovdqul(dst, src, Assembler::AVX_512bit); break;\n+    default: ShouldNotReachHere();\n@@ -1647,0 +1643,2 @@\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -1655,1 +1653,33 @@\n-void C2_MacroAssembler::load_iota_indices(XMMRegister dst, Register scratch, int vlen_in_bytes) {\n+void C2_MacroAssembler::load_constant_vector(BasicType bt, XMMRegister dst, InternalAddress src, int vlen) {\n+  int vlen_enc = vector_length_encoding(vlen);\n+  if (VM_Version::supports_avx()) {\n+    if (bt == T_LONG) {\n+      if (VM_Version::supports_avx2()) {\n+        vpbroadcastq(dst, src, vlen_enc);\n+      } else {\n+        vmovddup(dst, src, vlen_enc);\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      if (vlen_enc != Assembler::AVX_128bit) {\n+        vbroadcastsd(dst, src, vlen_enc, noreg);\n+      } else {\n+        vmovddup(dst, src, vlen_enc);\n+      }\n+    } else {\n+      if (VM_Version::supports_avx2() && is_integral_type(bt)) {\n+        vpbroadcastd(dst, src, vlen_enc);\n+      } else {\n+        vbroadcastss(dst, src, vlen_enc);\n+      }\n+    }\n+  } else if (VM_Version::supports_sse3()) {\n+    movddup(dst, src);\n+  } else {\n+    movq(dst, src);\n+    if (vlen == 16) {\n+      punpcklqdq(dst, dst);\n+    }\n+  }\n+}\n+\n+void C2_MacroAssembler::load_iota_indices(XMMRegister dst, int vlen_in_bytes) {\n@@ -1662,1 +1692,1 @@\n-    movdqu(dst, addr, scratch);\n+    movdqu(dst, addr, noreg);\n@@ -1664,1 +1694,1 @@\n-    vmovdqu(dst, addr, scratch);\n+    vmovdqu(dst, addr, noreg);\n@@ -1667,1 +1697,1 @@\n-    evmovdqub(dst, k0, addr, false \/*merge*\/, Assembler::AVX_512bit, scratch);\n+    evmovdqub(dst, k0, addr, false \/*merge*\/, Assembler::AVX_512bit, noreg);\n@@ -2299,1 +2329,1 @@\n-void C2_MacroAssembler::get_elem(BasicType typ, XMMRegister dst, XMMRegister src, int elemindex, Register tmp, XMMRegister vtmp) {\n+void C2_MacroAssembler::get_elem(BasicType typ, XMMRegister dst, XMMRegister src, int elemindex, XMMRegister vtmp) {\n@@ -2311,1 +2341,1 @@\n-        pshufps(dst, dst, eindex);\n+        shufps(dst, dst, eindex);\n@@ -2313,1 +2343,1 @@\n-        vpshufps(dst, src, src, eindex, Assembler::AVX_128bit);\n+        vshufps(dst, src, src, eindex, Assembler::AVX_128bit);\n@@ -2328,2 +2358,2 @@\n-      assert((vtmp != xnoreg) && (tmp != noreg), \"required.\");\n-      movdqu(vtmp, ExternalAddress(StubRoutines::x86::vector_32_bit_mask()), tmp);\n+      assert(vtmp != xnoreg, \"required.\");\n+      movdqu(vtmp, ExternalAddress(StubRoutines::x86::vector_32_bit_mask()), noreg);\n@@ -2332,2 +2362,1 @@\n-      assert((tmp != noreg), \"required.\");\n-      vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_32_bit_mask()), Assembler::AVX_128bit, tmp);\n+      vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_32_bit_mask()), Assembler::AVX_128bit, noreg);\n@@ -2362,1 +2391,3 @@\n-void C2_MacroAssembler::evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, AddressLiteral adr, int comparison, int vector_len, Register scratch) {\n+void C2_MacroAssembler::evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, AddressLiteral src2, int comparison, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src2), \"missing\");\n+\n@@ -2366,1 +2397,1 @@\n-      evpcmpb(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n+      evpcmpb(kdmask, ksmask, src1, src2, comparison, \/*signed*\/ true, vector_len, rscratch);\n@@ -2370,1 +2401,1 @@\n-      evpcmpw(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n+      evpcmpw(kdmask, ksmask, src1, src2, comparison, \/*signed*\/ true, vector_len, rscratch);\n@@ -2374,1 +2405,1 @@\n-      evpcmpd(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n+      evpcmpd(kdmask, ksmask, src1, src2, comparison, \/*signed*\/ true, vector_len, rscratch);\n@@ -2378,1 +2409,1 @@\n-      evpcmpq(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n+      evpcmpq(kdmask, ksmask, src1, src2, comparison, \/*signed*\/ true, vector_len, rscratch);\n@@ -4322,4 +4353,3 @@\n-void C2_MacroAssembler::vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                                            XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                                                            Register scratch, AddressLiteral float_sign_flip,\n-                                                            int vec_enc) {\n+void C2_MacroAssembler::vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n+                                                            XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                                            Register rscratch) {\n@@ -4327,1 +4357,1 @@\n-  vmovdqu(xtmp1, float_sign_flip, scratch, vec_enc);\n+  vmovdqu(xtmp1, float_sign_flip, vec_enc, rscratch);\n@@ -4351,4 +4381,4 @@\n-void C2_MacroAssembler::vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                                             XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                             Register scratch, AddressLiteral float_sign_flip,\n-                                                             int vec_enc) {\n+void C2_MacroAssembler::vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n+                                                             XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                             KRegister ktmp1, KRegister ktmp2,\n+                                                             Register rscratch) {\n@@ -4356,1 +4386,1 @@\n-  evmovdqul(xtmp1, k0, float_sign_flip, false, vec_enc, scratch);\n+  evmovdqul(xtmp1, k0, float_sign_flip, false, vec_enc, rscratch);\n@@ -4372,5 +4402,7 @@\n-void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(\n-                                                             XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                                             XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                             Register scratch, AddressLiteral double_sign_flip,\n-                                                             int vec_enc) {\n+void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src,\n+                                                                     AddressLiteral double_sign_flip, int vec_enc,\n+                                                                     XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                                     KRegister ktmp1, KRegister ktmp2,\n+                                                                     Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n+\n@@ -4378,1 +4410,1 @@\n-  evmovdquq(xtmp1, k0, double_sign_flip, false, vec_enc, scratch);\n+  evmovdquq(xtmp1, k0, double_sign_flip, false, vec_enc, rscratch);\n@@ -4402,4 +4434,6 @@\n-void C2_MacroAssembler::vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                                              XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                              Register scratch, AddressLiteral double_sign_flip,\n-                                                              int vec_enc) {\n+void C2_MacroAssembler::vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src,\n+                                                              AddressLiteral double_sign_flip, int vec_enc,\n+                                                              XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                              Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n+\n@@ -4407,1 +4441,1 @@\n-  evmovdqul(xtmp1, k0, double_sign_flip, false, vec_enc, scratch);\n+  evmovdqul(xtmp1, k0, double_sign_flip, false, vec_enc, rscratch);\n@@ -4433,3 +4467,4 @@\n-void C2_MacroAssembler::vector_castD2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                                            Register scratch, int vec_enc) {\n+void C2_MacroAssembler::vector_castD2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n+                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n+\n@@ -4437,1 +4472,2 @@\n-  vector_cast_double_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, double_sign_flip, vec_enc);\n+  vector_cast_double_special_cases_evex(dst, src, double_sign_flip, vec_enc,\n+                                        xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n@@ -4440,3 +4476,4 @@\n-void C2_MacroAssembler::vector_castF2I_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                                           AddressLiteral float_sign_flip, Register scratch, int vec_enc) {\n+void C2_MacroAssembler::vector_castF2I_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n+                                           XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n+\n@@ -4444,1 +4481,2 @@\n-  vector_cast_float_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, scratch, float_sign_flip, vec_enc);\n+  vector_cast_float_special_cases_avx(dst, src, float_sign_flip, vec_enc,\n+                                      xtmp1, xtmp2, xtmp3, xtmp4, rscratch);\n@@ -4447,3 +4485,4 @@\n-void C2_MacroAssembler::vector_castF2I_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n-                                            Register scratch, int vec_enc) {\n+void C2_MacroAssembler::vector_castF2I_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n+                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n+\n@@ -4451,1 +4490,2 @@\n-  vector_cast_float_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, float_sign_flip, vec_enc);\n+  vector_cast_float_special_cases_evex(dst, src, float_sign_flip, vec_enc,\n+                                       xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n@@ -4454,3 +4494,4 @@\n-void C2_MacroAssembler::vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                                            Register scratch, int vec_enc) {\n+void C2_MacroAssembler::vector_castF2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n+                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n+\n@@ -4458,1 +4499,2 @@\n-  vector_cast_float_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, double_sign_flip, vec_enc);\n+  vector_cast_float_to_long_special_cases_evex(dst, src, float_sign_flip, vec_enc,\n+                                               xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n@@ -4461,4 +4503,6 @@\n-void C2_MacroAssembler::vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                            XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                            AddressLiteral double_sign_flip, Register scratch, int vec_enc) {\n-  vector_castD2L_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, double_sign_flip, scratch, vec_enc);\n+void C2_MacroAssembler::vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n+                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n+\n+  vector_castD2L_evex(dst, src, double_sign_flip, vec_enc,\n+                      xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n@@ -4484,3 +4528,3 @@\n-void C2_MacroAssembler::vector_round_double_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                                 KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                                                 AddressLiteral new_mxcsr, Register scratch, int vec_enc) {\n+void C2_MacroAssembler::vector_round_double_evex(XMMRegister dst, XMMRegister src,\n+                                                 AddressLiteral double_sign_flip, AddressLiteral new_mxcsr, int vec_enc,\n+                                                 Register tmp, XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2) {\n@@ -4489,4 +4533,4 @@\n-  ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n-  ldmxcsr(new_mxcsr, scratch);\n-  mov64(scratch, julong_cast(0.5L));\n-  evpbroadcastq(xtmp1, scratch, vec_enc);\n+  ldmxcsr(new_mxcsr, tmp \/*rscratch*\/);\n+\n+  mov64(tmp, julong_cast(0.5L));\n+  evpbroadcastq(xtmp1, tmp, vec_enc);\n@@ -4495,2 +4539,4 @@\n-  vector_cast_double_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, double_sign_flip, vec_enc);\n-  ldmxcsr(mxcsr_std, scratch);\n+  vector_cast_double_special_cases_evex(dst, src, double_sign_flip, vec_enc,\n+                                        xtmp1, xtmp2, ktmp1, ktmp2, tmp);\n+\n+  ldmxcsr(ExternalAddress(StubRoutines::x86::addr_mxcsr_std()), tmp \/*rscratch*\/);\n@@ -4499,3 +4545,3 @@\n-void C2_MacroAssembler::vector_round_float_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                                KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n-                                                AddressLiteral new_mxcsr, Register scratch, int vec_enc) {\n+void C2_MacroAssembler::vector_round_float_evex(XMMRegister dst, XMMRegister src,\n+                                                AddressLiteral float_sign_flip, AddressLiteral new_mxcsr, int vec_enc,\n+                                                Register tmp, XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2) {\n@@ -4504,4 +4550,4 @@\n-  ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n-  ldmxcsr(new_mxcsr, scratch);\n-  movl(scratch, jint_cast(0.5));\n-  movq(xtmp1, scratch);\n+  ldmxcsr(new_mxcsr, tmp \/*rscratch*\/);\n+\n+  movl(tmp, jint_cast(0.5));\n+  movq(xtmp1, tmp);\n@@ -4511,2 +4557,4 @@\n-  vector_cast_float_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, scratch, float_sign_flip, vec_enc);\n-  ldmxcsr(mxcsr_std, scratch);\n+  vector_cast_float_special_cases_evex(dst, src, float_sign_flip, vec_enc,\n+                                       xtmp1, xtmp2, ktmp1, ktmp2, tmp);\n+\n+  ldmxcsr(ExternalAddress(StubRoutines::x86::addr_mxcsr_std()), tmp \/*rscratch*\/);\n@@ -4515,3 +4563,3 @@\n-void C2_MacroAssembler::vector_round_float_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                               XMMRegister xtmp3, XMMRegister xtmp4, AddressLiteral float_sign_flip,\n-                                               AddressLiteral new_mxcsr, Register scratch, int vec_enc) {\n+void C2_MacroAssembler::vector_round_float_avx(XMMRegister dst, XMMRegister src,\n+                                               AddressLiteral float_sign_flip, AddressLiteral new_mxcsr, int vec_enc,\n+                                               Register tmp, XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4) {\n@@ -4520,4 +4568,4 @@\n-  ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n-  ldmxcsr(new_mxcsr, scratch);\n-  movl(scratch, jint_cast(0.5));\n-  movq(xtmp1, scratch);\n+  ldmxcsr(new_mxcsr, tmp \/*rscratch*\/);\n+\n+  movl(tmp, jint_cast(0.5));\n+  movq(xtmp1, tmp);\n@@ -4527,2 +4575,4 @@\n-  vector_cast_float_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, scratch, float_sign_flip, vec_enc);\n-  ldmxcsr(mxcsr_std, scratch);\n+  vector_cast_float_special_cases_avx(dst, src, float_sign_flip, vec_enc,\n+                                      xtmp1, xtmp2, xtmp3, xtmp4, tmp);\n+\n+  ldmxcsr(ExternalAddress(StubRoutines::x86::addr_mxcsr_std()), tmp \/*rscratch*\/);\n@@ -4530,1 +4580,1 @@\n-#endif\n+#endif \/\/ _LP64\n@@ -4932,1 +4982,1 @@\n-  vmovdqu(xtmp2, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), rtmp, vec_enc);\n+  vmovdqu(xtmp2, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), vec_enc, noreg);\n@@ -5037,1 +5087,1 @@\n-    vmovdqu(xtmp1, ExternalAddress(StubRoutines::x86::vector_reverse_bit_lut()), rtmp, vec_enc);\n+    vmovdqu(xtmp1, ExternalAddress(StubRoutines::x86::vector_reverse_bit_lut()), vec_enc, noreg);\n@@ -5051,1 +5101,1 @@\n-    vector_reverse_byte(bt, dst, xtmp2, rtmp, vec_enc);\n+    vector_reverse_byte(bt, dst, xtmp2, vec_enc);\n@@ -5070,1 +5120,1 @@\n-    vmovdqu(xtmp1, ExternalAddress(StubRoutines::x86::vector_reverse_bit_lut()), rtmp, vec_enc);\n+    vmovdqu(xtmp1, ExternalAddress(StubRoutines::x86::vector_reverse_bit_lut()), vec_enc, rtmp);\n@@ -5086,1 +5136,1 @@\n-    vector_reverse_byte(bt, dst, xtmp2, rtmp, vec_enc);\n+    vector_reverse_byte(bt, dst, xtmp2, vec_enc);\n@@ -5090,2 +5140,5 @@\n-void C2_MacroAssembler::vector_reverse_bit_gfni(BasicType bt, XMMRegister dst, XMMRegister src,\n-                                                XMMRegister xtmp, AddressLiteral mask, Register rtmp, int vec_enc) {\n+void C2_MacroAssembler::vector_reverse_bit_gfni(BasicType bt, XMMRegister dst, XMMRegister src, AddressLiteral mask, int vec_enc,\n+                                                XMMRegister xtmp, Register rscratch) {\n+  assert(VM_Version::supports_gfni(), \"\");\n+  assert(rscratch != noreg || always_reachable(mask), \"missing\");\n+\n@@ -5094,2 +5147,1 @@\n-  assert(VM_Version::supports_gfni(), \"\");\n-  vpbroadcastq(xtmp, mask, vec_enc, rtmp);\n+  vpbroadcastq(xtmp, mask, vec_enc, rscratch);\n@@ -5097,1 +5149,1 @@\n-  vector_reverse_byte(bt, dst, xtmp, rtmp, vec_enc);\n+  vector_reverse_byte(bt, dst, xtmp, vec_enc);\n@@ -5140,1 +5192,1 @@\n-void C2_MacroAssembler::vector_reverse_byte(BasicType bt, XMMRegister dst, XMMRegister src, Register rtmp, int vec_enc) {\n+void C2_MacroAssembler::vector_reverse_byte(BasicType bt, XMMRegister dst, XMMRegister src, int vec_enc) {\n@@ -5153,1 +5205,1 @@\n-      vmovdqu(dst, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_long()), rtmp, vec_enc);\n+      vmovdqu(dst, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_long()), vec_enc, noreg);\n@@ -5156,1 +5208,1 @@\n-      vmovdqu(dst, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_int()), rtmp, vec_enc);\n+      vmovdqu(dst, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_int()), vec_enc, noreg);\n@@ -5160,1 +5212,1 @@\n-      vmovdqu(dst, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_short()), rtmp, vec_enc);\n+      vmovdqu(dst, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_short()), vec_enc, noreg);\n@@ -5478,0 +5530,84 @@\n+void C2_MacroAssembler::reverseI(Register dst, Register src, XMMRegister xtmp1,\n+                                 XMMRegister xtmp2, Register rtmp) {\n+  if(VM_Version::supports_gfni()) {\n+    \/\/ Galois field instruction based bit reversal based on following algorithm.\n+    \/\/ http:\/\/0x80.pl\/articles\/avx512-galois-field-for-bit-shuffling.html\n+    mov64(rtmp, 0x8040201008040201L);\n+    movq(xtmp1, src);\n+    movq(xtmp2, rtmp);\n+    gf2p8affineqb(xtmp1, xtmp2, 0);\n+    movq(dst, xtmp1);\n+  } else {\n+    \/\/ Swap even and odd numbered bits.\n+    movl(rtmp, src);\n+    andl(rtmp, 0x55555555);\n+    shll(rtmp, 1);\n+    movl(dst, src);\n+    andl(dst, 0xAAAAAAAA);\n+    shrl(dst, 1);\n+    orl(dst, rtmp);\n+\n+    \/\/ Swap LSB and MSB 2 bits of each nibble.\n+    movl(rtmp, dst);\n+    andl(rtmp, 0x33333333);\n+    shll(rtmp, 2);\n+    andl(dst, 0xCCCCCCCC);\n+    shrl(dst, 2);\n+    orl(dst, rtmp);\n+\n+    \/\/ Swap LSB and MSB 4 bits of each byte.\n+    movl(rtmp, dst);\n+    andl(rtmp, 0x0F0F0F0F);\n+    shll(rtmp, 4);\n+    andl(dst, 0xF0F0F0F0);\n+    shrl(dst, 4);\n+    orl(dst, rtmp);\n+  }\n+  bswapl(dst);\n+}\n+\n+void C2_MacroAssembler::reverseL(Register dst, Register src, XMMRegister xtmp1,\n+                                 XMMRegister xtmp2, Register rtmp1, Register rtmp2) {\n+  if(VM_Version::supports_gfni()) {\n+    \/\/ Galois field instruction based bit reversal based on following algorithm.\n+    \/\/ http:\/\/0x80.pl\/articles\/avx512-galois-field-for-bit-shuffling.html\n+    mov64(rtmp1, 0x8040201008040201L);\n+    movq(xtmp1, src);\n+    movq(xtmp2, rtmp1);\n+    gf2p8affineqb(xtmp1, xtmp2, 0);\n+    movq(dst, xtmp1);\n+  } else {\n+    \/\/ Swap even and odd numbered bits.\n+    movq(rtmp1, src);\n+    mov64(rtmp2, 0x5555555555555555L);\n+    andq(rtmp1, rtmp2);\n+    shlq(rtmp1, 1);\n+    movq(dst, src);\n+    notq(rtmp2);\n+    andq(dst, rtmp2);\n+    shrq(dst, 1);\n+    orq(dst, rtmp1);\n+\n+    \/\/ Swap LSB and MSB 2 bits of each nibble.\n+    movq(rtmp1, dst);\n+    mov64(rtmp2, 0x3333333333333333L);\n+    andq(rtmp1, rtmp2);\n+    shlq(rtmp1, 2);\n+    notq(rtmp2);\n+    andq(dst, rtmp2);\n+    shrq(dst, 2);\n+    orq(dst, rtmp1);\n+\n+    \/\/ Swap LSB and MSB 4 bits of each byte.\n+    movq(rtmp1, dst);\n+    mov64(rtmp2, 0x0F0F0F0F0F0F0F0FL);\n+    andq(rtmp1, rtmp2);\n+    shlq(rtmp1, 4);\n+    notq(rtmp2);\n+    andq(dst, rtmp2);\n+    shrq(dst, 4);\n+    orq(dst, rtmp1);\n+  }\n+  bswapq(dst);\n+}\n+\n@@ -5559,0 +5695,46 @@\n+void C2_MacroAssembler::rearrange_bytes(XMMRegister dst, XMMRegister shuffle, XMMRegister src, XMMRegister xtmp1,\n+                                        XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, KRegister ktmp,\n+                                        int vlen_enc) {\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  \/\/ Byte shuffles are inlane operations and indices are determined using\n+  \/\/ lower 4 bit of each shuffle lane, thus all shuffle indices are\n+  \/\/ normalized to index range 0-15. This makes sure that all the multiples\n+  \/\/ of an index value are placed at same relative position in 128 bit\n+  \/\/ lane i.e. elements corresponding to shuffle indices 16, 32 and 64\n+  \/\/ will be 16th element in their respective 128 bit lanes.\n+  movl(rtmp, 16);\n+  evpbroadcastb(xtmp1, rtmp, vlen_enc);\n+\n+  \/\/ Compute a mask for shuffle vector by comparing indices with expression INDEX < 16,\n+  \/\/ Broadcast first 128 bit lane across entire vector, shuffle the vector lanes using\n+  \/\/ original shuffle indices and move the shuffled lanes corresponding to true\n+  \/\/ mask to destination vector.\n+  evpcmpb(ktmp, k0, shuffle, xtmp1, Assembler::lt, true, vlen_enc);\n+  evshufi64x2(xtmp2, src, src, 0x0, vlen_enc);\n+  evpshufb(dst, ktmp, xtmp2, shuffle, false, vlen_enc);\n+\n+  \/\/ Perform above steps with lane comparison expression as INDEX >= 16 && INDEX < 32\n+  \/\/ and broadcasting second 128 bit lane.\n+  evpcmpb(ktmp, k0, shuffle,  xtmp1, Assembler::nlt, true, vlen_enc);\n+  vpsllq(xtmp2, xtmp1, 0x1, vlen_enc);\n+  evpcmpb(ktmp, ktmp, shuffle, xtmp2, Assembler::lt, true, vlen_enc);\n+  evshufi64x2(xtmp3, src, src, 0x55, vlen_enc);\n+  evpshufb(dst, ktmp, xtmp3, shuffle, true, vlen_enc);\n+\n+  \/\/ Perform above steps with lane comparison expression as INDEX >= 32 && INDEX < 48\n+  \/\/ and broadcasting third 128 bit lane.\n+  evpcmpb(ktmp, k0, shuffle,  xtmp2, Assembler::nlt, true, vlen_enc);\n+  vpaddb(xtmp1, xtmp1, xtmp2, vlen_enc);\n+  evpcmpb(ktmp, ktmp, shuffle,  xtmp1, Assembler::lt, true, vlen_enc);\n+  evshufi64x2(xtmp3, src, src, 0xAA, vlen_enc);\n+  evpshufb(dst, ktmp, xtmp3, shuffle, true, vlen_enc);\n+\n+  \/\/ Perform above steps with lane comparison expression as INDEX >= 48 && INDEX < 64\n+  \/\/ and broadcasting third 128 bit lane.\n+  evpcmpb(ktmp, k0, shuffle,  xtmp1, Assembler::nlt, true, vlen_enc);\n+  vpsllq(xtmp2, xtmp2, 0x1, vlen_enc);\n+  evpcmpb(ktmp, ktmp, shuffle,  xtmp2, Assembler::lt, true, vlen_enc);\n+  evshufi64x2(xtmp3, src, src, 0xFF, vlen_enc);\n+  evpshufb(dst, ktmp, xtmp3, shuffle, true, vlen_enc);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":320,"deletions":138,"binary":false,"changes":458,"status":"modified"},{"patch":"@@ -73,4 +73,4 @@\n-  void vabsnegd(int opcode, XMMRegister dst, XMMRegister src, Register scr);\n-  void vabsnegd(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr);\n-  void vabsnegf(int opcode, XMMRegister dst, XMMRegister src, Register scr);\n-  void vabsnegf(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr);\n+  void vabsnegd(int opcode, XMMRegister dst, XMMRegister src);\n+  void vabsnegd(int opcode, XMMRegister dst, XMMRegister src, int vector_len);\n+  void vabsnegf(int opcode, XMMRegister dst, XMMRegister src);\n+  void vabsnegf(int opcode, XMMRegister dst, XMMRegister src, int vector_len);\n@@ -93,3 +93,1 @@\n-  void signum_fp(int opcode, XMMRegister dst,\n-                 XMMRegister zero, XMMRegister one,\n-                 Register scratch);\n+  void signum_fp(int opcode, XMMRegister dst, XMMRegister zero, XMMRegister one);\n@@ -124,2 +122,2 @@\n-  void varshiftbw(int opcode, XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len, XMMRegister vtmp, Register scratch);\n-  void evarshiftb(int opcode, XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len, XMMRegister vtmp, Register scratch);\n+  void varshiftbw(int opcode, XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len, XMMRegister vtmp);\n+  void evarshiftb(int opcode, XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len, XMMRegister vtmp);\n@@ -140,1 +138,1 @@\n-  void get_elem(BasicType typ, XMMRegister dst, XMMRegister src, int elemindex, Register tmp = noreg, XMMRegister vtmp = xnoreg);\n+  void get_elem(BasicType typ, XMMRegister dst, XMMRegister src, int elemindex, XMMRegister vtmp = xnoreg);\n@@ -153,2 +151,2 @@\n-  void evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, AddressLiteral adr, int comparison, int vector_len, Register scratch = rscratch1);\n-  void evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, XMMRegister src2, int comparison, int vector_len);\n+  void evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, XMMRegister    src2, int comparison, int vector_len);\n+  void evpcmp(BasicType typ, KRegister kdmask, KRegister ksmask, XMMRegister src1, AddressLiteral src2, int comparison, int vector_len, Register rscratch = noreg);\n@@ -157,0 +155,3 @@\n+  void load_vector(XMMRegister dst, Address        src, int vlen_in_bytes);\n+  void load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch = noreg);\n+\n@@ -158,1 +159,1 @@\n-  void load_vector_mask(KRegister dst, XMMRegister src, XMMRegister xtmp, Register tmp, bool novlbwdq, int vlen_enc);\n+  void load_vector_mask(KRegister   dst, XMMRegister src, XMMRegister xtmp, bool novlbwdq, int vlen_enc);\n@@ -160,3 +161,2 @@\n-  void load_vector(XMMRegister dst, Address src, int vlen_in_bytes);\n-  void load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch = rscratch1);\n-  void load_iota_indices(XMMRegister dst, Register scratch, int vlen_in_bytes);\n+  void load_constant_vector(BasicType bt, XMMRegister dst, InternalAddress src, int vlen);\n+  void load_iota_indices(XMMRegister dst, int vlen_in_bytes);\n@@ -311,3 +311,2 @@\n-  void vector_castF2I_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                          XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                          AddressLiteral float_sign_flip, Register scratch, int vec_enc);\n+  void vector_castF2I_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n+                          XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, Register rscratch = noreg);\n@@ -315,3 +314,2 @@\n-  void vector_castF2I_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                           KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n-                           Register scratch, int vec_enc);\n+  void vector_castF2I_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n+                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n@@ -319,3 +317,2 @@\n-  void vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                           KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                           Register scratch, int vec_enc);\n+  void vector_castF2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n+                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n@@ -323,3 +320,2 @@\n-  void vector_castD2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                           KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                           Register scratch, int vec_enc);\n+  void vector_castD2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n+                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg );\n@@ -327,3 +323,2 @@\n-  void vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                           XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                           Register scratch, int vec_enc);\n+  void vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n+                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n@@ -331,2 +326,1 @@\n-  void vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n-                            BasicType from_elem_bt, BasicType to_elem_bt);\n+  void vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc, BasicType from_elem_bt, BasicType to_elem_bt);\n@@ -334,3 +328,2 @@\n-  void vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                             KRegister ktmp1, KRegister ktmp2, Register scratch, AddressLiteral double_sign_flip,\n-                                             int vec_enc);\n+  void vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n+                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg );\n@@ -338,3 +331,2 @@\n-  void vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                            KRegister ktmp1, KRegister ktmp2, Register scratch, AddressLiteral float_sign_flip,\n-                                            int vec_enc);\n+  void vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n+                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n@@ -342,4 +334,3 @@\n-  void vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                                    XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                    Register scratch, AddressLiteral double_sign_flip,\n-                                                    int vec_enc);\n+  void vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n+                                                    XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                    Register rscratch = noreg);\n@@ -347,4 +338,3 @@\n-  void vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                                           Register scratch, AddressLiteral float_sign_flip,\n-                                           int vec_enc);\n+  void vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n+                                           XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                           Register rscratch = noreg);\n@@ -353,3 +343,2 @@\n-  void vector_round_double_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                                AddressLiteral new_mxcsr, Register scratch, int vec_enc);\n+  void vector_round_double_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, AddressLiteral new_mxcsr, int vec_enc,\n+                                Register tmp, XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2);\n@@ -357,3 +346,2 @@\n-  void vector_round_float_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                               KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                               AddressLiteral new_mxcsr, Register scratch, int vec_enc);\n+  void vector_round_float_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, AddressLiteral new_mxcsr, int vec_enc,\n+                               Register tmp, XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2);\n@@ -361,4 +349,3 @@\n-  void vector_round_float_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                              XMMRegister xtmp3, XMMRegister xtmp4, AddressLiteral float_sign_flip,\n-                              AddressLiteral new_mxcsr, Register scratch, int vec_enc);\n-#endif\n+  void vector_round_float_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, AddressLiteral new_mxcsr, int vec_enc,\n+                              Register tmp, XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4);\n+#endif \/\/ _LP64\n@@ -371,0 +358,4 @@\n+  void reverseI(Register dst, Register src, XMMRegister xtmp1,\n+                XMMRegister xtmp2, Register rtmp);\n+  void reverseL(Register dst, Register src, XMMRegister xtmp1,\n+                XMMRegister xtmp2, Register rtmp1, Register rtmp2);\n@@ -385,2 +376,2 @@\n-  void vector_reverse_bit_gfni(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp,\n-                               AddressLiteral mask, Register rtmp, int vec_enc);\n+  void vector_reverse_bit_gfni(BasicType bt, XMMRegister dst, XMMRegister src, AddressLiteral mask, int vec_enc,\n+                               XMMRegister xtmp, Register rscratch = noreg);\n@@ -388,1 +379,1 @@\n-  void vector_reverse_byte(BasicType bt, XMMRegister dst, XMMRegister src, Register rtmp, int vec_enc);\n+  void vector_reverse_byte(BasicType bt, XMMRegister dst, XMMRegister src, int vec_enc);\n@@ -456,0 +447,3 @@\n+  void rearrange_bytes(XMMRegister dst, XMMRegister shuffle, XMMRegister src, XMMRegister xtmp1,\n+                       XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, KRegister ktmp, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":54,"deletions":60,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-    CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);\n+    CodeBlob* sender_blob = CodeCache::find_blob(sender_pc);\n@@ -188,5 +188,0 @@\n-    \/\/ Could be a zombie method\n-    if (sender_blob->is_zombie() || sender_blob->is_unloaded()) {\n-      return false;\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"runtime\/synchronizer.hpp\"\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,4 +159,2 @@\n-  \/\/ when last_Java_sp is non-null but the pc fetched is junk. If we are truly\n-  \/\/ unlucky the junk value could be to a zombied method and we'll die on the\n-  \/\/ find_blob call. This is also why we can have no asserts on the validity\n-  \/\/ of the pc we find here. AsyncGetCallTrace -> pd_get_top_frame_for_signal_handler\n+  \/\/ when last_Java_sp is non-null but the pc fetched is junk.\n+  \/\/ AsyncGetCallTrace -> pd_get_top_frame_for_signal_handler\n@@ -328,4 +326,0 @@\n-\/\/ Register is a class, but it would be assigned numerical value.\n-\/\/ \"0\" is assigned for rax. Thus we need to ignore -Wnonnull.\n-PRAGMA_DIAG_PUSH\n-PRAGMA_NONNULL_IGNORED\n@@ -344,1 +338,0 @@\n-PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-  __ cmpptr(pre_val, (int32_t) NULL_WORD);\n+  __ cmpptr(pre_val, NULL_WORD);\n@@ -325,1 +325,1 @@\n-  __ cmpptr(new_val, (int32_t) NULL_WORD);\n+  __ cmpptr(new_val, NULL_WORD);\n@@ -340,1 +340,1 @@\n-  __ cmpb(Address(card_addr, 0), (int)G1CardTable::g1_young_card_val());\n+  __ cmpb(Address(card_addr, 0), G1CardTable::g1_young_card_val());\n@@ -344,1 +344,1 @@\n-  __ cmpb(Address(card_addr, 0), (int)G1CardTable::dirty_card_val());\n+  __ cmpb(Address(card_addr, 0), G1CardTable::dirty_card_val());\n@@ -351,1 +351,1 @@\n-  __ movb(Address(card_addr, 0), (int)G1CardTable::dirty_card_val());\n+  __ movb(Address(card_addr, 0), G1CardTable::dirty_card_val());\n@@ -481,1 +481,1 @@\n-  __ cmpptr(pre_val_reg, (int32_t)NULL_WORD);\n+  __ cmpptr(pre_val_reg, NULL_WORD);\n@@ -495,1 +495,1 @@\n-  __ cmpptr(new_val_reg, (int32_t) NULL_WORD);\n+  __ cmpptr(new_val_reg, NULL_WORD);\n@@ -594,1 +594,1 @@\n-  __ cmpb(Address(card_addr, 0), (int)G1CardTable::g1_young_card_val());\n+  __ cmpb(Address(card_addr, 0), G1CardTable::g1_young_card_val());\n@@ -598,1 +598,1 @@\n-  __ cmpb(Address(card_addr, 0), (int)CardTable::dirty_card_val());\n+  __ cmpb(Address(card_addr, 0), CardTable::dirty_card_val());\n@@ -604,1 +604,1 @@\n-  __ movb(Address(card_addr, 0), (int)CardTable::dirty_card_val());\n+  __ movb(Address(card_addr, 0), CardTable::dirty_card_val());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-          __ movl(dst, (int32_t)NULL_WORD);\n+          __ movl(dst, NULL_WORD);\n@@ -126,1 +126,1 @@\n-          __ movslq(dst, (int32_t)NULL_WORD);\n+          __ movslq(dst, NULL_WORD);\n@@ -129,1 +129,1 @@\n-        __ movl(dst, (int32_t)NULL_WORD);\n+        __ movl(dst, NULL_WORD);\n@@ -351,6 +351,3 @@\n-#ifdef _LP64\n-  Register tmp1 = rscratch1;\n-  Register tmp2 = rscratch2;\n-#else\n-  Register tmp1 = rax;\n-  Register tmp2 = rcx;\n+  Register tmp1 = LP64_ONLY( rscratch1 ) NOT_LP64( rax );\n+  Register tmp2 = LP64_ONLY( rscratch2 ) NOT_LP64( rcx );\n+#ifndef _LP64\n@@ -359,1 +356,1 @@\n-#endif \/\/ _LP64\n+#endif \/\/ !_LP64\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    card_addr = __ as_Address(ArrayAddress(cardtable, index));\n+    card_addr = __ as_Address(ArrayAddress(cardtable, index), rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -470,4 +470,0 @@\n-\/\/ Register is a class, but it would be assigned numerical value.\n-\/\/ \"0\" is assigned for rax. Thus we need to ignore -Wnonnull.\n-PRAGMA_DIAG_PUSH\n-PRAGMA_NONNULL_IGNORED\n@@ -549,1 +545,0 @@\n-PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,2 +63,1 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  load_klass(obj, obj, tmp_load_klass);\n+  load_klass(obj, obj, rscratch1);\n@@ -270,1 +269,1 @@\n-    cmpptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+    cmpptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -302,1 +301,1 @@\n-    cmpptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+    cmpptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -353,1 +352,1 @@\n-               movptr(oop_addr, (int32_t)NULL_WORD);\n+               movptr(oop_addr, NULL_WORD);\n@@ -367,2 +366,2 @@\n-  movl(tos_addr,  (int) ilgl);\n-  movl(val_addr,  (int32_t) NULL_WORD);\n+  movl(tos_addr, ilgl);\n+  movl(val_addr, NULL_WORD);\n@@ -390,2 +389,2 @@\n-  movl(tos_addr,  (int32_t) ilgl);\n-  movptr(val_addr,  NULL_WORD);\n+  movl(tos_addr, ilgl);\n+  movptr(val_addr, NULL_WORD);\n@@ -852,1 +851,1 @@\n-    cmpptr(rcx, (int32_t)min_frame_size);\n+    cmpptr(rcx, min_frame_size);\n@@ -889,1 +888,1 @@\n-    jump(dispatch_addr);\n+    jump(dispatch_addr, noreg);\n@@ -895,1 +894,1 @@\n-    jump(dispatch_addr);\n+    jump(dispatch_addr, noreg);\n@@ -1012,1 +1011,1 @@\n-  set_last_Java_frame(rthread, noreg, rbp, (address)pc());\n+  set_last_Java_frame(rthread, noreg, rbp, (address)pc(), rscratch1);\n@@ -1131,1 +1130,1 @@\n-    cmpptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), (int32_t) NULL);\n+    cmpptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), NULL_WORD);\n@@ -1238,1 +1237,1 @@\n-    SkipIfEqual skip_if(this, &DTraceAllocProbes, 0);\n+    SkipIfEqual skip_if(this, &DTraceAllocProbes, 0, rscratch1);\n@@ -1361,1 +1360,1 @@\n-    const Register rklass_decode_tmp = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    const Register rklass_decode_tmp = rscratch1;\n@@ -1379,1 +1378,1 @@\n-    movl(swap_reg, (int32_t)1);\n+    movl(swap_reg, 1);\n@@ -1485,1 +1484,1 @@\n-    movptr(Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()), (int32_t)NULL_WORD);\n+    movptr(Address(lock_reg, BasicObjectLock::obj_offset_in_bytes()), NULL_WORD);\n@@ -1615,1 +1614,1 @@\n-    addptr(data, (int32_t) -DataLayout::counter_increment);\n+    addptr(data, -DataLayout::counter_increment);\n@@ -1619,1 +1618,1 @@\n-    addptr(data, (int32_t) DataLayout::counter_increment);\n+    addptr(data, DataLayout::counter_increment);\n@@ -1627,1 +1626,1 @@\n-    sbbptr(data, (int32_t)0);\n+    sbbptr(data, 0);\n@@ -2248,1 +2247,1 @@\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false);\n+    SkipIfEqual skip(this, &DTraceMethodProbes, false, rscratch1);\n@@ -2293,1 +2292,1 @@\n-    SkipIfEqual skip(this, &DTraceMethodProbes, false);\n+    SkipIfEqual skip(this, &DTraceMethodProbes, false, rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -179,4 +179,0 @@\n-  \/\/ These are dummies to prevent surprise implicit conversions to Register\n-  void pop(void* v); \/\/ Add unimplemented ambiguous method\n-  void push(void* v);   \/\/ Add unimplemented ambiguous method\n-\n@@ -186,1 +182,1 @@\n-    movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+    movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  __ cmpptr(Address(from(), Interpreter::local_offset_in_bytes(from_offset)), (int32_t)NULL_WORD); \/\/ do not use temp() to avoid AGI\n+  __ cmpptr(Address(from(), Interpreter::local_offset_in_bytes(from_offset)), NULL_WORD); \/\/ do not use temp() to avoid AGI\n","filename":"src\/hotspot\/cpu\/x86\/interpreterRT_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,3 +52,0 @@\n-\/\/ Warning: do not use rip relative addressing after the first counter load\n-\/\/ since that may scratch r10!\n-\n@@ -81,4 +78,3 @@\n-    \/\/ Check to see if a field access watch has been set before we\n-    \/\/ take the fast path.\n-    assert_different_registers(rscratch1, robj, rcounter); \/\/ cmp32 clobbers rscratch1!\n-    __ cmp32(ExternalAddress((address) JvmtiExport::get_field_access_count_addr()), 0);\n+    \/\/ Check to see if a field access watch has been set before we take the fast path.\n+    assert_different_registers(rscratch1, robj, rcounter);\n+    __ cmp32(ExternalAddress(JvmtiExport::get_field_access_count_addr()), 0, rscratch1);\n@@ -108,1 +104,1 @@\n-  __ cmp32 (rcounter, counter);\n+  __ cmp32 (rcounter, counter, rscratch1);\n@@ -126,1 +122,1 @@\n-  __ jump (ExternalAddress(slow_case_addr));\n+  __ jump (ExternalAddress(slow_case_addr), rscratch1);\n@@ -181,1 +177,1 @@\n-    __ cmp32(ExternalAddress((address) JvmtiExport::get_field_access_count_addr()), 0);\n+    __ cmp32(ExternalAddress(JvmtiExport::get_field_access_count_addr()), 0, rscratch1);\n@@ -200,1 +196,1 @@\n-  __ cmp32 (rcounter, counter);\n+  __ cmp32 (rcounter, counter, rscratch1);\n@@ -214,1 +210,1 @@\n-  __ jump (ExternalAddress(slow_case_addr));\n+  __ jump (ExternalAddress(slow_case_addr), rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_64.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -111,1 +111,2 @@\n-Address MacroAssembler::as_Address(ArrayAddress adr) {\n+Address MacroAssembler::as_Address(ArrayAddress adr, Register rscratch) {\n+  assert(rscratch == noreg, \"\");\n@@ -134,1 +135,2 @@\n-void MacroAssembler::cmpoop(Register src1, jobject obj) {\n+void MacroAssembler::cmpoop(Register src1, jobject obj, Register rscratch) {\n+  assert(rscratch == noreg, \"redundant\");\n@@ -170,2 +172,3 @@\n-void MacroAssembler::jump(ArrayAddress entry) {\n-  jmp(as_Address(entry));\n+void MacroAssembler::jump(ArrayAddress entry, Register rscratch) {\n+  assert(rscratch == noreg, \"not needed\");\n+  jmp(as_Address(entry, noreg));\n@@ -201,1 +204,1 @@\n-    mov_literal32(dst, (int32_t)src.target(), src.rspec());\n+  mov_literal32(dst, (int32_t)src.target(), src.rspec());\n@@ -204,1 +207,3 @@\n-void MacroAssembler::lea(Address dst, AddressLiteral adr) {\n+void MacroAssembler::lea(Address dst, AddressLiteral adr, Register rscratch) {\n+  assert(rscratch == noreg, \"not needed\");\n+\n@@ -207,1 +212,1 @@\n-  mov_literal32(dst, (int32_t) adr.target(), adr.rspec());\n+  mov_literal32(dst, (int32_t)adr.target(), adr.rspec());\n@@ -307,1 +312,2 @@\n-void MacroAssembler::movoop(Address dst, jobject obj) {\n+void MacroAssembler::movoop(Address dst, jobject obj, Register rscratch) {\n+  assert(rscratch == noreg, \"redundant\");\n@@ -315,1 +321,2 @@\n-void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {\n+void MacroAssembler::mov_metadata(Address dst, Metadata* obj, Register rscratch) {\n+  assert(rscratch == noreg, \"redundant\");\n@@ -319,3 +326,1 @@\n-void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {\n-  \/\/ scratch register is not used,\n-  \/\/ it is defined to match parameters of 64-bit version of this method.\n+void MacroAssembler::movptr(Register dst, AddressLiteral src) {\n@@ -329,2 +334,3 @@\n-void MacroAssembler::movptr(ArrayAddress dst, Register src) {\n-  movl(as_Address(dst), src);\n+void MacroAssembler::movptr(ArrayAddress dst, Register src, Register rscratch) {\n+  assert(rscratch == noreg, \"redundant\");\n+  movl(as_Address(dst, noreg), src);\n@@ -334,1 +340,1 @@\n-  movl(dst, as_Address(src));\n+  movl(dst, as_Address(src, noreg));\n@@ -337,2 +343,2 @@\n-\/\/ src should NEVER be a real pointer. Use AddressLiteral for true pointers\n-void MacroAssembler::movptr(Address dst, intptr_t src) {\n+void MacroAssembler::movptr(Address dst, intptr_t src, Register rscratch) {\n+  assert(rscratch == noreg, \"redundant\");\n@@ -342,1 +348,2 @@\n-void MacroAssembler::pushoop(jobject obj) {\n+void MacroAssembler::pushoop(jobject obj, Register rscratch) {\n+  assert(rscratch == noreg, \"redundant\");\n@@ -346,1 +353,2 @@\n-void MacroAssembler::pushklass(Metadata* obj) {\n+void MacroAssembler::pushklass(Metadata* obj, Register rscratch) {\n+  assert(rscratch == noreg, \"redundant\");\n@@ -350,1 +358,2 @@\n-void MacroAssembler::pushptr(AddressLiteral src) {\n+void MacroAssembler::pushptr(AddressLiteral src, Register rscratch) {\n+  assert(rscratch == noreg, \"redundant\");\n@@ -443,2 +452,2 @@\n-  ExternalAddress message((address)msg);\n-  pushptr(message.addr());\n+  ExternalAddress message((address)msg);\n+  pushptr(message.addr(), noreg);\n@@ -455,2 +464,2 @@\n-  ExternalAddress message((address) msg);\n-  pushptr(message.addr());\n+  ExternalAddress message((address)msg);\n+  pushptr(message.addr(), noreg);\n@@ -486,1 +495,1 @@\n-  return Address((int32_t)(intptr_t)(adr.target() - pc()), adr.target(), adr.reloc());\n+  return Address(checked_cast<int32_t>(adr.target() - pc()), adr.target(), adr.reloc());\n@@ -490,1 +499,1 @@\n-Address MacroAssembler::as_Address(ArrayAddress adr) {\n+Address MacroAssembler::as_Address(ArrayAddress adr, Register rscratch) {\n@@ -492,1 +501,1 @@\n-  lea(rscratch1, base);\n+  lea(rscratch, base);\n@@ -495,1 +504,1 @@\n-  Address array(rscratch1, index._index, index._scale, index._disp);\n+  Address array(rscratch, index._index, index._scale, index._disp);\n@@ -529,1 +538,1 @@\n-void MacroAssembler::cmp64(Register src1, AddressLiteral src2) {\n+void MacroAssembler::cmp64(Register src1, AddressLiteral src2, Register rscratch) {\n@@ -531,0 +540,1 @@\n+  assert(rscratch != noreg || always_reachable(src2), \"missing\");\n@@ -535,2 +545,2 @@\n-    lea(rscratch1, src2);\n-    Assembler::cmpq(src1, Address(rscratch1, 0));\n+    lea(rscratch, src2);\n+    Assembler::cmpq(src1, Address(rscratch, 0));\n@@ -558,1 +568,1 @@\n-  cmp64(rax, ExternalAddress((address) &min_long));\n+  cmp64(rax, ExternalAddress((address) &min_long), rdx \/*rscratch*\/);\n@@ -593,1 +603,3 @@\n-void MacroAssembler::incrementq(AddressLiteral dst) {\n+void MacroAssembler::incrementq(AddressLiteral dst, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(dst), \"missing\");\n+\n@@ -597,2 +609,2 @@\n-    lea(rscratch1, dst);\n-    incrementq(Address(rscratch1, 0));\n+    lea(rscratch, dst);\n+    incrementq(Address(rscratch, 0));\n@@ -620,2 +632,2 @@\n-void MacroAssembler::jump(ArrayAddress entry) {\n-  lea(rscratch1, entry.base());\n+void MacroAssembler::jump(ArrayAddress entry, Register rscratch) {\n+  lea(rscratch, entry.base());\n@@ -624,1 +636,1 @@\n-  dispatch._base = rscratch1;\n+  dispatch._base = rscratch;\n@@ -634,1 +646,1 @@\n-    mov_literal64(dst, (intptr_t)src.target(), src.rspec());\n+  mov_literal64(dst, (intptr_t)src.target(), src.rspec());\n@@ -637,3 +649,3 @@\n-void MacroAssembler::lea(Address dst, AddressLiteral adr) {\n-  mov_literal64(rscratch1, (intptr_t)adr.target(), adr.rspec());\n-  movptr(dst, rscratch1);\n+void MacroAssembler::lea(Address dst, AddressLiteral adr, Register rscratch) {\n+  lea(rscratch, adr);\n+  movptr(dst, rscratch);\n@@ -656,3 +668,3 @@\n-void MacroAssembler::movoop(Address dst, jobject obj) {\n-  mov_literal64(rscratch1, (intptr_t)obj, oop_Relocation::spec_for_immediate());\n-  movq(dst, rscratch1);\n+void MacroAssembler::movoop(Address dst, jobject obj, Register rscratch) {\n+  mov_literal64(rscratch, (intptr_t)obj, oop_Relocation::spec_for_immediate());\n+  movq(dst, rscratch);\n@@ -665,3 +677,3 @@\n-void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {\n-  mov_literal64(rscratch1, (intptr_t)obj, metadata_Relocation::spec_for_immediate());\n-  movq(dst, rscratch1);\n+void MacroAssembler::mov_metadata(Address dst, Metadata* obj, Register rscratch) {\n+  mov_literal64(rscratch, (intptr_t)obj, metadata_Relocation::spec_for_immediate());\n+  movq(dst, rscratch);\n@@ -670,1 +682,1 @@\n-void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {\n+void MacroAssembler::movptr(Register dst, AddressLiteral src) {\n@@ -677,2 +689,2 @@\n-      lea(scratch, src);\n-      movq(dst, Address(scratch, 0));\n+      lea(dst, src);\n+      movq(dst, Address(dst, 0));\n@@ -683,2 +695,2 @@\n-void MacroAssembler::movptr(ArrayAddress dst, Register src) {\n-  movq(as_Address(dst), src);\n+void MacroAssembler::movptr(ArrayAddress dst, Register src, Register rscratch) {\n+  movq(as_Address(dst, rscratch), src);\n@@ -688,1 +700,1 @@\n-  movq(dst, as_Address(src));\n+  movq(dst, as_Address(src, dst \/*rscratch*\/));\n@@ -692,1 +704,1 @@\n-void MacroAssembler::movptr(Address dst, intptr_t src) {\n+void MacroAssembler::movptr(Address dst, intptr_t src, Register rscratch) {\n@@ -696,2 +708,2 @@\n-    mov64(rscratch1, src);\n-    movq(dst, rscratch1);\n+    mov64(rscratch, src);\n+    movq(dst, rscratch);\n@@ -701,12 +713,3 @@\n-\/\/ These are mostly for initializing NULL\n-void MacroAssembler::movptr(Address dst, int32_t src) {\n-  movslq(dst, src);\n-}\n-\n-void MacroAssembler::movptr(Register dst, int32_t src) {\n-  mov64(dst, (intptr_t)src);\n-}\n-\n-void MacroAssembler::pushoop(jobject obj) {\n-  movoop(rscratch1, obj);\n-  push(rscratch1);\n+void MacroAssembler::pushoop(jobject obj, Register rscratch) {\n+  movoop(rscratch, obj);\n+  push(rscratch);\n@@ -715,3 +718,3 @@\n-void MacroAssembler::pushklass(Metadata* obj) {\n-  mov_metadata(rscratch1, obj);\n-  push(rscratch1);\n+void MacroAssembler::pushklass(Metadata* obj, Register rscratch) {\n+  mov_metadata(rscratch, obj);\n+  push(rscratch);\n@@ -720,2 +723,2 @@\n-void MacroAssembler::pushptr(AddressLiteral src) {\n-  lea(rscratch1, src);\n+void MacroAssembler::pushptr(AddressLiteral src, Register rscratch) {\n+  lea(rscratch, src);\n@@ -723,1 +726,1 @@\n-    push(rscratch1);\n+    push(rscratch);\n@@ -725,1 +728,1 @@\n-    pushq(Address(rscratch1, 0));\n+    pushq(Address(rscratch, 0));\n@@ -735,22 +738,3 @@\n-                                         address  last_java_pc) {\n-  vzeroupper();\n-  \/\/ determine last_java_sp register\n-  if (!last_java_sp->is_valid()) {\n-    last_java_sp = rsp;\n-  }\n-\n-  \/\/ last_java_fp is optional\n-  if (last_java_fp->is_valid()) {\n-    movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()),\n-           last_java_fp);\n-  }\n-\n-  \/\/ last_java_pc is optional\n-  if (last_java_pc != NULL) {\n-    Address java_pc(r15_thread,\n-                    JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());\n-    lea(rscratch1, InternalAddress(last_java_pc));\n-    movptr(java_pc, rscratch1);\n-  }\n-\n-  movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);\n+                                         address  last_java_pc,\n+                                         Register rscratch) {\n+  set_last_Java_frame(r15_thread, last_java_sp, last_java_fp, last_java_pc, rscratch);\n@@ -801,0 +785,1 @@\n+\n@@ -802,2 +787,2 @@\n-  lea(rax, ExternalAddress(CAST_FROM_FN_PTR(address, warning)));\n-  call(rax);\n+  call(RuntimeAddress(CAST_FROM_FN_PTR(address, warning)));\n+\n@@ -1071,1 +1056,1 @@\n-    cmpptr(Address(rbp, reg2offset_in(src.first())), (int32_t)NULL_WORD);\n+    cmpptr(Address(rbp, reg2offset_in(src.first())), NULL_WORD);\n@@ -1107,1 +1092,1 @@\n-    cmpptr(rOop, (int32_t)NULL_WORD);\n+    cmpptr(rOop, NULL_WORD);\n@@ -1135,1 +1120,3 @@\n-void MacroAssembler::addsd(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::addsd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -1139,2 +1126,2 @@\n-    lea(rscratch1, src);\n-    Assembler::addsd(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::addsd(dst, Address(rscratch, 0));\n@@ -1144,1 +1131,3 @@\n-void MacroAssembler::addss(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::addss(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -1148,2 +1137,2 @@\n-    lea(rscratch1, src);\n-    addss(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    addss(dst, Address(rscratch, 0));\n@@ -1153,1 +1142,3 @@\n-void MacroAssembler::addpd(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::addpd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -1157,2 +1148,2 @@\n-    lea(rscratch1, src);\n-    Assembler::addpd(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::addpd(dst, Address(rscratch, 0));\n@@ -1205,1 +1196,1 @@\n-void MacroAssembler::andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {\n+void MacroAssembler::andpd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n@@ -1208,0 +1199,2 @@\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -1211,2 +1204,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::andpd(dst, Address(scratch_reg, 0));\n+    lea(rscratch, src);\n+    Assembler::andpd(dst, Address(rscratch, 0));\n@@ -1216,1 +1209,1 @@\n-void MacroAssembler::andps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {\n+void MacroAssembler::andps(XMMRegister dst, AddressLiteral src, Register rscratch) {\n@@ -1219,0 +1212,2 @@\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -1222,2 +1217,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::andps(dst, Address(scratch_reg, 0));\n+    lea(rscratch, src);\n+    Assembler::andps(dst, Address(rscratch, 0));\n@@ -1236,1 +1231,3 @@\n-void MacroAssembler::atomic_incl(AddressLiteral counter_addr, Register scr) {\n+void MacroAssembler::atomic_incl(AddressLiteral counter_addr, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(counter_addr), \"missing\");\n+\n@@ -1240,2 +1237,2 @@\n-    lea(scr, counter_addr);\n-    atomic_incl(Address(scr, 0));\n+    lea(rscratch, counter_addr);\n+    atomic_incl(Address(rscratch, 0));\n@@ -1251,1 +1248,3 @@\n-void MacroAssembler::atomic_incq(AddressLiteral counter_addr, Register scr) {\n+void MacroAssembler::atomic_incq(AddressLiteral counter_addr, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(counter_addr), \"missing\");\n+\n@@ -1255,2 +1254,2 @@\n-    lea(scr, counter_addr);\n-    atomic_incq(Address(scr, 0));\n+    lea(rscratch, counter_addr);\n+    atomic_incq(Address(rscratch, 0));\n@@ -1289,4 +1288,4 @@\n-    \/\/ testing if reserved zone needs to be enabled\n-    Label no_reserved_zone_enabling;\n-    Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);\n-    NOT_LP64(get_thread(rsi);)\n+  \/\/ testing if reserved zone needs to be enabled\n+  Label no_reserved_zone_enabling;\n+  Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);\n+  NOT_LP64(get_thread(rsi);)\n@@ -1294,2 +1293,2 @@\n-    cmpptr(rsp, Address(thread, JavaThread::reserved_stack_activation_offset()));\n-    jcc(Assembler::below, no_reserved_zone_enabling);\n+  cmpptr(rsp, Address(thread, JavaThread::reserved_stack_activation_offset()));\n+  jcc(Assembler::below, no_reserved_zone_enabling);\n@@ -1297,3 +1296,3 @@\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), thread);\n-    jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n-    should_not_reach_here();\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), thread);\n+  jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+  should_not_reach_here();\n@@ -1301,1 +1300,1 @@\n-    bind(no_reserved_zone_enabling);\n+  bind(no_reserved_zone_enabling);\n@@ -1322,1 +1321,3 @@\n-void MacroAssembler::call(AddressLiteral entry) {\n+void MacroAssembler::call(AddressLiteral entry, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(entry), \"missing\");\n+\n@@ -1326,2 +1327,2 @@\n-    lea(rscratch1, entry);\n-    Assembler::call(rscratch1);\n+    lea(rscratch, entry);\n+    Assembler::call(rscratch);\n@@ -1557,1 +1558,1 @@\n-  set_last_Java_frame(java_thread, last_java_sp, rbp, NULL);\n+  set_last_Java_frame(java_thread, last_java_sp, rbp, NULL, rscratch1);\n@@ -1592,1 +1593,1 @@\n-    cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);\n+    cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -1741,1 +1742,3 @@\n-void MacroAssembler::cmp32(AddressLiteral src1, int32_t imm) {\n+void MacroAssembler::cmp32(AddressLiteral src1, int32_t imm, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src1), \"missing\");\n+\n@@ -1745,2 +1748,2 @@\n-    lea(rscratch1, src1);\n-    cmpl(Address(rscratch1, 0), imm);\n+    lea(rscratch, src1);\n+    cmpl(Address(rscratch, 0), imm);\n@@ -1750,1 +1753,1 @@\n-void MacroAssembler::cmp32(Register src1, AddressLiteral src2) {\n+void MacroAssembler::cmp32(Register src1, AddressLiteral src2, Register rscratch) {\n@@ -1752,0 +1755,2 @@\n+  assert(rscratch != noreg || always_reachable(src2), \"missing\");\n+\n@@ -1755,2 +1760,2 @@\n-    lea(rscratch1, src2);\n-    cmpl(src1, Address(rscratch1, 0));\n+    lea(rscratch, src2);\n+    cmpl(src1, Address(rscratch, 0));\n@@ -1813,1 +1818,3 @@\n-void MacroAssembler::cmp8(AddressLiteral src1, int imm) {\n+void MacroAssembler::cmp8(AddressLiteral src1, int imm, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src1), \"missing\");\n+\n@@ -1817,2 +1824,2 @@\n-    lea(rscratch1, src1);\n-    cmpb(Address(rscratch1, 0), imm);\n+    lea(rscratch, src1);\n+    cmpb(Address(rscratch, 0), imm);\n@@ -1822,1 +1829,1 @@\n-void MacroAssembler::cmpptr(Register src1, AddressLiteral src2) {\n+void MacroAssembler::cmpptr(Register src1, AddressLiteral src2, Register rscratch) {\n@@ -1824,0 +1831,2 @@\n+  assert(rscratch != noreg || always_reachable(src2), \"missing\");\n+\n@@ -1825,2 +1834,2 @@\n-    movptr(rscratch1, src2);\n-    Assembler::cmpq(src1, rscratch1);\n+    movptr(rscratch, src2);\n+    Assembler::cmpq(src1, rscratch);\n@@ -1830,2 +1839,2 @@\n-    lea(rscratch1, src2);\n-    Assembler::cmpq(src1, Address(rscratch1, 0));\n+    lea(rscratch, src2);\n+    Assembler::cmpq(src1, Address(rscratch, 0));\n@@ -1834,0 +1843,1 @@\n+  assert(rscratch == noreg, \"not needed\");\n@@ -1835,1 +1845,1 @@\n-    cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());\n+    cmp_literal32(src1, (int32_t)src2.target(), src2.rspec());\n@@ -1842,1 +1852,1 @@\n-void MacroAssembler::cmpptr(Address src1, AddressLiteral src2) {\n+void MacroAssembler::cmpptr(Address src1, AddressLiteral src2, Register rscratch) {\n@@ -1846,2 +1856,2 @@\n-  movptr(rscratch1, src2);\n-  Assembler::cmpq(src1, rscratch1);\n+  movptr(rscratch, src2);\n+  Assembler::cmpq(src1, rscratch);\n@@ -1849,1 +1859,2 @@\n-  cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());\n+  assert(rscratch == noreg, \"not needed\");\n+  cmp_literal32(src1, (int32_t)src2.target(), src2.rspec());\n@@ -1862,3 +1873,3 @@\n-void MacroAssembler::cmpoop(Register src1, jobject src2) {\n-  movoop(rscratch1, src2);\n-  cmpptr(src1, rscratch1);\n+void MacroAssembler::cmpoop(Register src1, jobject src2, Register rscratch) {\n+  movoop(rscratch, src2);\n+  cmpptr(src1, rscratch);\n@@ -1868,1 +1879,3 @@\n-void MacroAssembler::locked_cmpxchgptr(Register reg, AddressLiteral adr) {\n+void MacroAssembler::locked_cmpxchgptr(Register reg, AddressLiteral adr, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(adr), \"missing\");\n+\n@@ -1873,1 +1886,1 @@\n-    lea(rscratch1, adr);\n+    lea(rscratch, adr);\n@@ -1875,1 +1888,1 @@\n-    cmpxchgptr(reg, Address(rscratch1, 0));\n+    cmpxchgptr(reg, Address(rscratch, 0));\n@@ -1883,1 +1896,3 @@\n-void MacroAssembler::comisd(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::comisd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -1887,2 +1902,2 @@\n-    lea(rscratch1, src);\n-    Assembler::comisd(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::comisd(dst, Address(rscratch, 0));\n@@ -1892,1 +1907,3 @@\n-void MacroAssembler::comiss(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::comiss(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -1896,2 +1913,2 @@\n-    lea(rscratch1, src);\n-    Assembler::comiss(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::comiss(dst, Address(rscratch, 0));\n@@ -1902,1 +1919,3 @@\n-void MacroAssembler::cond_inc32(Condition cond, AddressLiteral counter_addr) {\n+void MacroAssembler::cond_inc32(Condition cond, AddressLiteral counter_addr, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(counter_addr), \"missing\");\n+\n@@ -1907,1 +1926,1 @@\n-  atomic_incl(counter_addr);\n+  atomic_incl(counter_addr, rscratch);\n@@ -1983,1 +2002,3 @@\n-void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -1987,2 +2008,2 @@\n-    lea(rscratch1, src);\n-    Assembler::divsd(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::divsd(dst, Address(rscratch, 0));\n@@ -1992,1 +2013,3 @@\n-void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::divss(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -1996,2 +2019,2 @@\n-    lea(rscratch1, src);\n-    Assembler::divss(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::divss(dst, Address(rscratch, 0));\n@@ -2107,1 +2130,1 @@\n-  Assembler::fldcw(as_Address(src));\n+  fldcw(as_Address(src));\n@@ -2141,1 +2164,2 @@\n-void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n@@ -2145,2 +2169,2 @@\n-    lea(rscratch1, src);\n-    Assembler::mulpd(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::mulpd(dst, Address(rscratch, 0));\n@@ -2246,1 +2270,3 @@\n-void MacroAssembler::incrementl(AddressLiteral dst) {\n+void MacroAssembler::incrementl(AddressLiteral dst, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(dst), \"missing\");\n+\n@@ -2250,2 +2276,2 @@\n-    lea(rscratch1, dst);\n-    incrementl(Address(rscratch1, 0));\n+    lea(rscratch, dst);\n+    incrementl(Address(rscratch, 0));\n@@ -2255,2 +2281,2 @@\n-void MacroAssembler::incrementl(ArrayAddress dst) {\n-  incrementl(as_Address(dst));\n+void MacroAssembler::incrementl(ArrayAddress dst, Register rscratch) {\n+  incrementl(as_Address(dst, rscratch));\n@@ -2275,1 +2301,3 @@\n-void MacroAssembler::jump(AddressLiteral dst) {\n+void MacroAssembler::jump(AddressLiteral dst, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(dst), \"missing\");\n+\n@@ -2279,2 +2307,2 @@\n-    lea(rscratch1, dst);\n-    jmp(rscratch1);\n+    lea(rscratch, dst);\n+    jmp(rscratch);\n@@ -2284,1 +2312,3 @@\n-void MacroAssembler::jump_cc(Condition cc, AddressLiteral dst) {\n+void MacroAssembler::jump_cc(Condition cc, AddressLiteral dst, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(dst), \"missing\");\n+\n@@ -2307,2 +2337,2 @@\n-    lea(rscratch1, dst);\n-    Assembler::jmp(rscratch1);\n+    lea(rscratch, dst);\n+    Assembler::jmp(rscratch);\n@@ -2313,3 +2343,2 @@\n-void MacroAssembler::fld_x(AddressLiteral src) {\n-  Assembler::fld_x(as_Address(src));\n-}\n+void MacroAssembler::ldmxcsr(AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n@@ -2317,1 +2346,0 @@\n-void MacroAssembler::ldmxcsr(AddressLiteral src, Register scratchReg) {\n@@ -2321,2 +2349,2 @@\n-    lea(scratchReg, src);\n-    Assembler::ldmxcsr(Address(scratchReg, 0));\n+    lea(rscratch, src);\n+    Assembler::ldmxcsr(Address(rscratch, 0));\n@@ -2426,1 +2454,3 @@\n-void MacroAssembler::mov32(AddressLiteral dst, Register src) {\n+void MacroAssembler::mov32(AddressLiteral dst, Register src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(dst), \"missing\");\n+\n@@ -2430,2 +2460,2 @@\n-    lea(rscratch1, dst);\n-    movl(Address(rscratch1, 0), src);\n+    lea(rscratch, dst);\n+    movl(Address(rscratch, 0), src);\n@@ -2439,2 +2469,2 @@\n-    lea(rscratch1, src);\n-    movl(dst, Address(rscratch1, 0));\n+    lea(dst, src);\n+    movl(dst, Address(dst, 0));\n@@ -2482,3 +2512,2 @@\n-void MacroAssembler::movbyte(ArrayAddress dst, int src) {\n-  movb(as_Address(dst), src);\n-}\n+void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n@@ -2486,1 +2515,0 @@\n-void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {\n@@ -2490,2 +2518,2 @@\n-    lea(rscratch1, src);\n-    movdl(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    movdl(dst, Address(rscratch, 0));\n@@ -2495,1 +2523,3 @@\n-void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::movq(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2499,2 +2529,2 @@\n-    lea(rscratch1, src);\n-    movq(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    movq(dst, Address(rscratch, 0));\n@@ -2504,1 +2534,3 @@\n-void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2512,1 +2544,1 @@\n-    lea(rscratch1, src);\n+    lea(rscratch, src);\n@@ -2514,1 +2546,1 @@\n-      movsd (dst, Address(rscratch1, 0));\n+      movsd (dst, Address(rscratch, 0));\n@@ -2516,1 +2548,1 @@\n-      movlpd(dst, Address(rscratch1, 0));\n+      movlpd(dst, Address(rscratch, 0));\n@@ -2521,1 +2553,3 @@\n-void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2525,2 +2559,2 @@\n-    lea(rscratch1, src);\n-    movss(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    movss(dst, Address(rscratch, 0));\n@@ -2547,0 +2581,4 @@\n+void MacroAssembler::movptr(Address dst, int32_t src) {\n+  LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src));\n+}\n+\n@@ -2548,2 +2586,2 @@\n-    assert(((src->encoding() < 16) || VM_Version::supports_avx512vl()),\"XMM register should be 0-15\");\n-    Assembler::movdqu(dst, src);\n+  assert(((src->encoding() < 16) || VM_Version::supports_avx512vl()),\"XMM register should be 0-15\");\n+  Assembler::movdqu(dst, src);\n@@ -2553,2 +2591,2 @@\n-    assert(((dst->encoding() < 16) || VM_Version::supports_avx512vl()),\"XMM register should be 0-15\");\n-    Assembler::movdqu(dst, src);\n+  assert(((dst->encoding() < 16) || VM_Version::supports_avx512vl()),\"XMM register should be 0-15\");\n+  Assembler::movdqu(dst, src);\n@@ -2558,2 +2596,2 @@\n-    assert(((dst->encoding() < 16  && src->encoding() < 16) || VM_Version::supports_avx512vl()),\"XMM register should be 0-15\");\n-    Assembler::movdqu(dst, src);\n+  assert(((dst->encoding() < 16  && src->encoding() < 16) || VM_Version::supports_avx512vl()),\"XMM register should be 0-15\");\n+  Assembler::movdqu(dst, src);\n@@ -2562,1 +2600,3 @@\n-void MacroAssembler::movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg) {\n+void MacroAssembler::movdqu(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2566,2 +2606,2 @@\n-    lea(scratchReg, src);\n-    movdqu(dst, Address(scratchReg, 0));\n+    lea(rscratch, src);\n+    movdqu(dst, Address(rscratch, 0));\n@@ -2572,2 +2612,2 @@\n-    assert(((src->encoding() < 16) || VM_Version::supports_avx512vl()),\"XMM register should be 0-15\");\n-    Assembler::vmovdqu(dst, src);\n+  assert(((src->encoding() < 16) || VM_Version::supports_avx512vl()),\"XMM register should be 0-15\");\n+  Assembler::vmovdqu(dst, src);\n@@ -2577,2 +2617,2 @@\n-    assert(((dst->encoding() < 16) || VM_Version::supports_avx512vl()),\"XMM register should be 0-15\");\n-    Assembler::vmovdqu(dst, src);\n+  assert(((dst->encoding() < 16) || VM_Version::supports_avx512vl()),\"XMM register should be 0-15\");\n+  Assembler::vmovdqu(dst, src);\n@@ -2582,2 +2622,2 @@\n-    assert(((dst->encoding() < 16  && src->encoding() < 16) || VM_Version::supports_avx512vl()),\"XMM register should be 0-15\");\n-    Assembler::vmovdqu(dst, src);\n+  assert(((dst->encoding() < 16  && src->encoding() < 16) || VM_Version::supports_avx512vl()),\"XMM register should be 0-15\");\n+  Assembler::vmovdqu(dst, src);\n@@ -2586,1 +2626,3 @@\n-void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg) {\n+void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2591,2 +2633,2 @@\n-    lea(scratch_reg, src);\n-    vmovdqu(dst, Address(scratch_reg, 0));\n+    lea(rscratch, src);\n+    vmovdqu(dst, Address(rscratch, 0));\n@@ -2596,1 +2638,3 @@\n-void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg, int vector_len) {\n+void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2598,1 +2642,1 @@\n-    evmovdquq(dst, src, AVX_512bit, scratch_reg);\n+    evmovdquq(dst, src, AVX_512bit, rscratch);\n@@ -2600,1 +2644,1 @@\n-    vmovdqu(dst, src, scratch_reg);\n+    vmovdqu(dst, src, rscratch);\n@@ -2602,1 +2646,1 @@\n-    movdqu(dst, src, scratch_reg);\n+    movdqu(dst, src, rscratch);\n@@ -2651,1 +2695,3 @@\n-void MacroAssembler::kmovql(KRegister dst, AddressLiteral src, Register scratch_reg) {\n+void MacroAssembler::kmovql(KRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2655,2 +2701,2 @@\n-    lea(scratch_reg, src);\n-    kmovql(dst, Address(scratch_reg, 0));\n+    lea(rscratch, src);\n+    kmovql(dst, Address(rscratch, 0));\n@@ -2660,1 +2706,3 @@\n-void MacroAssembler::kmovwl(KRegister dst, AddressLiteral src, Register scratch_reg) {\n+void MacroAssembler::kmovwl(KRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2664,2 +2712,2 @@\n-    lea(scratch_reg, src);\n-    kmovwl(dst, Address(scratch_reg, 0));\n+    lea(rscratch, src);\n+    kmovwl(dst, Address(rscratch, 0));\n@@ -2670,1 +2718,3 @@\n-                               int vector_len, Register scratch_reg) {\n+                               int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2674,2 +2724,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::evmovdqub(dst, mask, Address(scratch_reg, 0), merge, vector_len);\n+    lea(rscratch, src);\n+    Assembler::evmovdqub(dst, mask, Address(rscratch, 0), merge, vector_len);\n@@ -2680,1 +2730,3 @@\n-                               int vector_len, Register scratch_reg) {\n+                               int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2684,2 +2736,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::evmovdquw(dst, mask, Address(scratch_reg, 0), merge, vector_len);\n+    lea(rscratch, src);\n+    Assembler::evmovdquw(dst, mask, Address(rscratch, 0), merge, vector_len);\n@@ -2689,2 +2741,3 @@\n-void MacroAssembler::evmovdqul(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge,\n-                               int vector_len, Register scratch_reg) {\n+void MacroAssembler::evmovdqul(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2694,2 +2747,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::evmovdqul(dst, mask, Address(scratch_reg, 0), merge, vector_len);\n+    lea(rscratch, src);\n+    Assembler::evmovdqul(dst, mask, Address(rscratch, 0), merge, vector_len);\n@@ -2699,2 +2752,3 @@\n-void MacroAssembler::evmovdquq(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge,\n-                               int vector_len, Register scratch_reg) {\n+void MacroAssembler::evmovdquq(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2704,2 +2758,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::evmovdquq(dst, mask, Address(scratch_reg, 0), merge, vector_len);\n+    lea(rscratch, src);\n+    Assembler::evmovdquq(dst, mask, Address(rscratch, 0), merge, vector_len);\n@@ -2710,0 +2764,2 @@\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2718,1 +2774,3 @@\n-void MacroAssembler::movdqa(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::movdqa(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2722,2 +2780,2 @@\n-    lea(rscratch1, src);\n-    Assembler::movdqa(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::movdqa(dst, Address(rscratch, 0));\n@@ -2727,1 +2785,3 @@\n-void MacroAssembler::movsd(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::movsd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2731,2 +2791,2 @@\n-    lea(rscratch1, src);\n-    Assembler::movsd(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::movsd(dst, Address(rscratch, 0));\n@@ -2736,1 +2796,3 @@\n-void MacroAssembler::movss(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::movss(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2740,2 +2802,13 @@\n-    lea(rscratch1, src);\n-    Assembler::movss(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::movss(dst, Address(rscratch, 0));\n+  }\n+}\n+\n+void MacroAssembler::movddup(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::movddup(dst, as_Address(src));\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::movddup(dst, Address(rscratch, 0));\n@@ -2746,0 +2819,2 @@\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2754,1 +2829,3 @@\n-void MacroAssembler::mulsd(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::mulsd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2758,2 +2835,2 @@\n-    lea(rscratch1, src);\n-    Assembler::mulsd(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::mulsd(dst, Address(rscratch, 0));\n@@ -2763,1 +2840,3 @@\n-void MacroAssembler::mulss(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::mulss(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -2767,2 +2846,2 @@\n-    lea(rscratch1, src);\n-    Assembler::mulss(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::mulss(dst, Address(rscratch, 0));\n@@ -3148,1 +3227,2 @@\n-                                         address  last_java_pc) {\n+                                         address  last_java_pc,\n+                                         Register rscratch) {\n@@ -3159,2 +3239,0 @@\n-\n-\n@@ -3165,6 +3243,3 @@\n-\n-\n-    lea(Address(java_thread,\n-                 JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset()),\n-        InternalAddress(last_java_pc));\n-\n+    Address java_pc(java_thread,\n+                    JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());\n+    lea(java_pc, InternalAddress(last_java_pc), rscratch);\n@@ -3248,8 +3323,2 @@\n-void MacroAssembler::sqrtsd(XMMRegister dst, AddressLiteral src) {\n-  if (reachable(src)) {\n-    Assembler::sqrtsd(dst, as_Address(src));\n-  } else {\n-    lea(rscratch1, src);\n-    Assembler::sqrtsd(dst, Address(rscratch1, 0));\n-  }\n-}\n+void MacroAssembler::sqrtss(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n@@ -3257,1 +3326,0 @@\n-void MacroAssembler::sqrtss(XMMRegister dst, AddressLiteral src) {\n@@ -3261,2 +3329,2 @@\n-    lea(rscratch1, src);\n-    Assembler::sqrtss(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::sqrtss(dst, Address(rscratch, 0));\n@@ -3266,1 +3334,3 @@\n-void MacroAssembler::subsd(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::subsd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3270,2 +3340,2 @@\n-    lea(rscratch1, src);\n-    Assembler::subsd(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::subsd(dst, Address(rscratch, 0));\n@@ -3275,1 +3345,3 @@\n-void MacroAssembler::roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg) {\n+void MacroAssembler::roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3279,2 +3351,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::roundsd(dst, Address(scratch_reg, 0), rmode);\n+    lea(rscratch, src);\n+    Assembler::roundsd(dst, Address(rscratch, 0), rmode);\n@@ -3284,1 +3356,3 @@\n-void MacroAssembler::subss(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::subss(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3288,2 +3362,2 @@\n-    lea(rscratch1, src);\n-    Assembler::subss(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::subss(dst, Address(rscratch, 0));\n@@ -3293,1 +3367,3 @@\n-void MacroAssembler::ucomisd(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::ucomisd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3297,2 +3373,2 @@\n-    lea(rscratch1, src);\n-    Assembler::ucomisd(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::ucomisd(dst, Address(rscratch, 0));\n@@ -3302,1 +3378,3 @@\n-void MacroAssembler::ucomiss(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::ucomiss(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3306,2 +3384,2 @@\n-    lea(rscratch1, src);\n-    Assembler::ucomiss(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::ucomiss(dst, Address(rscratch, 0));\n@@ -3311,1 +3389,3 @@\n-void MacroAssembler::xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {\n+void MacroAssembler::xorpd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3317,2 +3397,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::xorpd(dst, Address(scratch_reg, 0));\n+    lea(rscratch, src);\n+    Assembler::xorpd(dst, Address(rscratch, 0));\n@@ -3339,1 +3419,3 @@\n-void MacroAssembler::xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {\n+void MacroAssembler::xorps(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3345,2 +3427,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::xorps(dst, Address(scratch_reg, 0));\n+    lea(rscratch, src);\n+    Assembler::xorps(dst, Address(rscratch, 0));\n@@ -3350,1 +3432,3 @@\n-void MacroAssembler::pshufb(XMMRegister dst, AddressLiteral src) {\n+void MacroAssembler::pshufb(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3357,2 +3441,2 @@\n-    lea(rscratch1, src);\n-    Assembler::pshufb(dst, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    Assembler::pshufb(dst, Address(rscratch, 0));\n@@ -3364,1 +3448,3 @@\n-void MacroAssembler::vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {\n+void MacroAssembler::vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3368,2 +3454,2 @@\n-    lea(rscratch1, src);\n-    vaddsd(dst, nds, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    vaddsd(dst, nds, Address(rscratch, 0));\n@@ -3373,1 +3459,3 @@\n-void MacroAssembler::vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {\n+void MacroAssembler::vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3377,2 +3465,2 @@\n-    lea(rscratch1, src);\n-    vaddss(dst, nds, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    vaddss(dst, nds, Address(rscratch, 0));\n@@ -3384,0 +3472,2 @@\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3394,0 +3484,2 @@\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3402,1 +3494,1 @@\n-void MacroAssembler::vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {\n+void MacroAssembler::vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len, Register rscratch) {\n@@ -3404,1 +3496,3 @@\n-  vandps(dst, nds, negate_field, vector_len);\n+  assert(rscratch != noreg || always_reachable(negate_field), \"missing\");\n+\n+  vandps(dst, nds, negate_field, vector_len, rscratch);\n@@ -3407,1 +3501,1 @@\n-void MacroAssembler::vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {\n+void MacroAssembler::vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len, Register rscratch) {\n@@ -3409,1 +3503,3 @@\n-  vandpd(dst, nds, negate_field, vector_len);\n+  assert(rscratch != noreg || always_reachable(negate_field), \"missing\");\n+\n+  vandpd(dst, nds, negate_field, vector_len, rscratch);\n@@ -3432,1 +3528,3 @@\n-void MacroAssembler::vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {\n+void MacroAssembler::vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3436,2 +3534,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::vpand(dst, nds, Address(scratch_reg, 0), vector_len);\n+    lea(rscratch, src);\n+    Assembler::vpand(dst, nds, Address(rscratch, 0), vector_len);\n@@ -3441,3 +3539,9 @@\n-void MacroAssembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {\n-  assert(((dst->encoding() < 16 && src->encoding() < 16) || VM_Version::supports_avx512vlbw()),\"XMM register should be 0-15\");\n-  Assembler::vpbroadcastw(dst, src, vector_len);\n+void MacroAssembler::vpbroadcastd(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::vpbroadcastd(dst, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::vpbroadcastd(dst, Address(rscratch, 0), vector_len);\n+  }\n@@ -3447,0 +3551,2 @@\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3456,0 +3562,2 @@\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3464,0 +3572,11 @@\n+void MacroAssembler::vbroadcastss(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::vbroadcastss(dst, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::vbroadcastss(dst, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n@@ -3474,2 +3593,3 @@\n-void MacroAssembler::evpcmpeqd(KRegister kdst, KRegister mask, XMMRegister nds,\n-                               AddressLiteral src, int vector_len, Register scratch_reg) {\n+void MacroAssembler::evpcmpeqd(KRegister kdst, KRegister mask, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3479,2 +3599,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::evpcmpeqd(kdst, mask, nds, Address(scratch_reg, 0), vector_len);\n+    lea(rscratch, src);\n+    Assembler::evpcmpeqd(kdst, mask, nds, Address(rscratch, 0), vector_len);\n@@ -3485,1 +3605,3 @@\n-                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3489,2 +3611,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::evpcmpd(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n+    lea(rscratch, src);\n+    Assembler::evpcmpd(kdst, mask, nds, Address(rscratch, 0), comparison, is_signed, vector_len);\n@@ -3495,1 +3617,3 @@\n-                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3499,2 +3623,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::evpcmpq(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n+    lea(rscratch, src);\n+    Assembler::evpcmpq(kdst, mask, nds, Address(rscratch, 0), comparison, is_signed, vector_len);\n@@ -3505,1 +3629,3 @@\n-                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3509,2 +3635,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::evpcmpb(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n+    lea(rscratch, src);\n+    Assembler::evpcmpb(kdst, mask, nds, Address(rscratch, 0), comparison, is_signed, vector_len);\n@@ -3515,1 +3641,3 @@\n-                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3519,2 +3647,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::evpcmpw(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n+    lea(rscratch, src);\n+    Assembler::evpcmpw(kdst, mask, nds, Address(rscratch, 0), comparison, is_signed, vector_len);\n@@ -3589,1 +3717,1 @@\n-void MacroAssembler::vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {\n+void MacroAssembler::vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n@@ -3591,0 +3719,2 @@\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3594,2 +3724,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::vpmulld(dst, nds, Address(scratch_reg, 0), vector_len);\n+    lea(rscratch, src);\n+    Assembler::vpmulld(dst, nds, Address(rscratch, 0), vector_len);\n@@ -3685,1 +3815,3 @@\n-void MacroAssembler::vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {\n+void MacroAssembler::vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3689,2 +3821,2 @@\n-    lea(scratch_reg, src);\n-    vandpd(dst, nds, Address(scratch_reg, 0), vector_len);\n+    lea(rscratch, src);\n+    vandpd(dst, nds, Address(rscratch, 0), vector_len);\n@@ -3694,1 +3826,3 @@\n-void MacroAssembler::vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {\n+void MacroAssembler::vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3698,2 +3832,2 @@\n-    lea(scratch_reg, src);\n-    vandps(dst, nds, Address(scratch_reg, 0), vector_len);\n+    lea(rscratch, src);\n+    vandps(dst, nds, Address(rscratch, 0), vector_len);\n@@ -3704,1 +3838,3 @@\n-                            bool merge, int vector_len, Register scratch_reg) {\n+                            bool merge, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3708,2 +3844,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::evpord(dst, mask, nds, Address(scratch_reg, 0), merge, vector_len);\n+    lea(rscratch, src);\n+    Assembler::evpord(dst, mask, nds, Address(rscratch, 0), merge, vector_len);\n@@ -3713,1 +3849,3 @@\n-void MacroAssembler::vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {\n+void MacroAssembler::vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3717,2 +3855,2 @@\n-    lea(rscratch1, src);\n-    vdivsd(dst, nds, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    vdivsd(dst, nds, Address(rscratch, 0));\n@@ -3722,1 +3860,3 @@\n-void MacroAssembler::vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {\n+void MacroAssembler::vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3726,2 +3866,2 @@\n-    lea(rscratch1, src);\n-    vdivss(dst, nds, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    vdivss(dst, nds, Address(rscratch, 0));\n@@ -3731,1 +3871,3 @@\n-void MacroAssembler::vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {\n+void MacroAssembler::vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3735,2 +3877,2 @@\n-    lea(rscratch1, src);\n-    vmulsd(dst, nds, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    vmulsd(dst, nds, Address(rscratch, 0));\n@@ -3740,1 +3882,3 @@\n-void MacroAssembler::vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {\n+void MacroAssembler::vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3744,2 +3888,2 @@\n-    lea(rscratch1, src);\n-    vmulss(dst, nds, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    vmulss(dst, nds, Address(rscratch, 0));\n@@ -3749,1 +3893,3 @@\n-void MacroAssembler::vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {\n+void MacroAssembler::vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3753,2 +3899,2 @@\n-    lea(rscratch1, src);\n-    vsubsd(dst, nds, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    vsubsd(dst, nds, Address(rscratch, 0));\n@@ -3758,1 +3904,3 @@\n-void MacroAssembler::vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {\n+void MacroAssembler::vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3762,2 +3910,2 @@\n-    lea(rscratch1, src);\n-    vsubss(dst, nds, Address(rscratch1, 0));\n+    lea(rscratch, src);\n+    vsubss(dst, nds, Address(rscratch, 0));\n@@ -3767,1 +3915,1 @@\n-void MacroAssembler::vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src) {\n+void MacroAssembler::vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch) {\n@@ -3769,1 +3917,3 @@\n-  vxorps(dst, nds, src, Assembler::AVX_128bit);\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  vxorps(dst, nds, src, Assembler::AVX_128bit, rscratch);\n@@ -3772,1 +3922,1 @@\n-void MacroAssembler::vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {\n+void MacroAssembler::vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch) {\n@@ -3774,1 +3924,3 @@\n-  vxorpd(dst, nds, src, Assembler::AVX_128bit);\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  vxorpd(dst, nds, src, Assembler::AVX_128bit, rscratch);\n@@ -3777,1 +3929,3 @@\n-void MacroAssembler::vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {\n+void MacroAssembler::vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3781,2 +3935,2 @@\n-    lea(scratch_reg, src);\n-    vxorpd(dst, nds, Address(scratch_reg, 0), vector_len);\n+    lea(rscratch, src);\n+    vxorpd(dst, nds, Address(rscratch, 0), vector_len);\n@@ -3786,1 +3940,3 @@\n-void MacroAssembler::vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {\n+void MacroAssembler::vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3790,2 +3946,2 @@\n-    lea(scratch_reg, src);\n-    vxorps(dst, nds, Address(scratch_reg, 0), vector_len);\n+    lea(rscratch, src);\n+    vxorps(dst, nds, Address(rscratch, 0), vector_len);\n@@ -3795,1 +3951,3 @@\n-void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {\n+void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3800,2 +3958,2 @@\n-      lea(scratch_reg, src);\n-      Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);\n+      lea(rscratch, src);\n+      Assembler::vpxor(dst, nds, Address(rscratch, 0), vector_len);\n@@ -3803,3 +3961,2 @@\n-  }\n-  else {\n-    MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);\n+  } else {\n+    MacroAssembler::vxorpd(dst, nds, src, vector_len, rscratch);\n@@ -3809,1 +3966,3 @@\n-void MacroAssembler::vpermd(XMMRegister dst,  XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {\n+void MacroAssembler::vpermd(XMMRegister dst,  XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n@@ -3813,2 +3972,2 @@\n-    lea(scratch_reg, src);\n-    Assembler::vpermd(dst, nds, Address(scratch_reg, 0), vector_len);\n+    lea(rscratch, src);\n+    Assembler::vpermd(dst, nds, Address(rscratch, 0), vector_len);\n@@ -3978,2 +4137,1 @@\n-    Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-    store_klass(new_obj, t2, tmp_store_klass);  \/\/ src klass reg is potentially compressed\n+    store_klass(new_obj, t2, rscratch1);  \/\/ src klass reg is potentially compressed\n@@ -4018,1 +4176,1 @@\n-  int num_xmm_registers = XMMRegisterImpl::available_xmm_registers();\n+  int num_xmm_registers = XMMRegister::available_xmm_registers();\n@@ -4059,1 +4217,1 @@\n-  gp_area_size = align_up(gp_registers.size() * RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size,\n+  gp_area_size = align_up(gp_registers.size() * Register::max_slots_per_register * VMRegImpl::stack_slot_size,\n@@ -4152,1 +4310,1 @@\n-    int register_push_size = set.size() * RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+    int register_push_size = set.size() * Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n@@ -4162,1 +4320,1 @@\n-    spill_offset += RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+    spill_offset += Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n@@ -4168,1 +4326,1 @@\n-  int gp_reg_size = RegisterImpl::max_slots_per_register * VMRegImpl::stack_slot_size;\n+  int gp_reg_size = Register::max_slots_per_register * VMRegImpl::stack_slot_size;\n@@ -4648,0 +4806,7 @@\n+  BLOCK_COMMENT(\"verify_oop {\");\n+#ifdef _LP64\n+  push(rscratch1);\n+#endif\n+  push(rax);                          \/\/ save rax\n+  push(reg);                          \/\/ pass register argument\n+\n@@ -4656,10 +4821,2 @@\n-  BLOCK_COMMENT(\"verify_oop {\");\n-#ifdef _LP64\n-  push(rscratch1);                    \/\/ save r10, trashed by movptr()\n-#endif\n-  push(rax);                          \/\/ save rax,\n-  push(reg);                          \/\/ pass register argument\n-  \/\/ avoid using pushptr, as it modifies scratch registers\n-  \/\/ and our contract is not to modify anything\n-  movptr(rax, buffer.addr());\n-  push(rax);\n+  pushptr(buffer.addr(), rscratch1);\n+\n@@ -4676,0 +4833,2 @@\n+    \/\/ Only pcmpeq has dependency breaking treatment (i.e the execution can begin without\n+    \/\/ waiting for the previous result on dst), not vpcmpeqd, so just use vpternlog\n@@ -4677,0 +4836,2 @@\n+  } else if (VM_Version::supports_avx()) {\n+    vpcmpeqd(dst, dst, dst, vector_len);\n@@ -4678,2 +4839,2 @@\n-    assert(UseAVX > 0, \"\");\n-    vpcmpeqb(dst, dst, dst, vector_len);\n+    assert(VM_Version::supports_sse2(), \"\");\n+    pcmpeqd(dst, dst);\n@@ -4711,10 +4872,1 @@\n-  \/\/ Address adjust(addr.base(), addr.index(), addr.scale(), addr.disp() + BytesPerWord);\n-  \/\/ Pass register number to verify_oop_subroutine\n-  const char* b = NULL;\n-  {\n-    ResourceMark rm;\n-    stringStream ss;\n-    ss.print(\"verify_oop_addr: %s (%s:%d)\", s, file, line);\n-    b = code_string(ss.as_string());\n-  }\n-  push(rscratch1);                    \/\/ save r10, trashed by movptr()\n+  push(rscratch1);\n@@ -4723,1 +4875,1 @@\n-  push(rax);                          \/\/ save rax,\n+  push(rax); \/\/ save rax,\n@@ -4735,0 +4887,8 @@\n+  \/\/ Pass register number to verify_oop_subroutine\n+  const char* b = NULL;\n+  {\n+    ResourceMark rm;\n+    stringStream ss;\n+    ss.print(\"verify_oop_addr: %s (%s:%d)\", s, file, line);\n+    b = code_string(ss.as_string());\n+  }\n@@ -4736,5 +4896,1 @@\n-  \/\/ pass msg argument\n-  \/\/ avoid using pushptr, as it modifies scratch registers\n-  \/\/ and our contract is not to modify anything\n-  movptr(rax, buffer.addr());\n-  push(rax);\n+  pushptr(buffer.addr(), rscratch1);\n@@ -5117,1 +5273,1 @@\n-  pushptr(msg.addr());\n+  pushptr(msg.addr(), noreg);\n@@ -5132,1 +5288,1 @@\n-void MacroAssembler::restore_cpu_control_state_after_jni() {\n+void MacroAssembler::restore_cpu_control_state_after_jni(Register rscratch) {\n@@ -5137,1 +5293,1 @@\n-      ldmxcsr(ExternalAddress(StubRoutines::x86::addr_mxcsr_std()));\n+      ldmxcsr(ExternalAddress(StubRoutines::x86::addr_mxcsr_std()), rscratch);\n@@ -5337,2 +5493,1 @@\n-    const auto src2 = ExternalAddress((address)CompressedOops::ptrs_base_addr());\n-    assert(!src2.is_lval(), \"should not be lval\");\n+    ExternalAddress src2(CompressedOops::ptrs_base_addr());\n@@ -5343,1 +5498,1 @@\n-    cmpptr(r12_heapbase, src2);\n+    cmpptr(r12_heapbase, src2, rscratch1);\n@@ -5632,1 +5787,1 @@\n-      movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));\n+      movptr(r12_heapbase, ExternalAddress(CompressedOops::ptrs_base_addr()));\n@@ -5759,2 +5914,1 @@\n-    Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-    store_klass(buffer_obj, rbx, tmp_store_klass);\n+    store_klass(buffer_obj, rbx, rscratch1);\n@@ -7989,1 +8143,1 @@\n-  movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 32));\n+  movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 32), rscratch1);\n@@ -8003,1 +8157,1 @@\n-  movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));\n+  movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16), rscratch1);\n@@ -8012,1 +8166,1 @@\n-  movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));\n+  movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16), rscratch1);\n@@ -8022,1 +8176,1 @@\n-  movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr()));\n+  movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr()), rscratch1);\n@@ -10122,1 +10276,1 @@\n-    MacroAssembler* masm, const bool* flag_addr, bool value) {\n+    MacroAssembler* masm, const bool* flag_addr, bool value, Register rscratch) {\n@@ -10124,1 +10278,1 @@\n-  _masm->cmp8(ExternalAddress((address)flag_addr), value);\n+  _masm->cmp8(ExternalAddress((address)flag_addr), value, rscratch);\n@@ -10172,0 +10326,16 @@\n+\n+void MacroAssembler::check_stack_alignment(Register sp, const char* msg, unsigned bias, Register tmp) {\n+  Label L_stack_ok;\n+  if (bias == 0) {\n+    testptr(sp, 2 * wordSize - 1);\n+  } else {\n+    \/\/ lea(tmp, Address(rsp, bias);\n+    mov(tmp, sp);\n+    addptr(tmp, bias);\n+    testptr(tmp, 2 * wordSize - 1);\n+  }\n+  jcc(Assembler::equal, L_stack_ok);\n+  block_comment(msg);\n+  stop(msg);\n+  bind(L_stack_ok);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":621,"deletions":451,"binary":false,"changes":1072,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  Address as_Address(ArrayAddress adr);\n+  Address as_Address(ArrayAddress adr, Register rscratch);\n@@ -206,1 +206,1 @@\n-  void movflt(XMMRegister dst, AddressLiteral src);\n+  void movflt(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -218,1 +218,1 @@\n-  void movdbl(XMMRegister dst, AddressLiteral src);\n+  void movdbl(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -226,2 +226,2 @@\n-  void incrementl(AddressLiteral dst);\n-  void incrementl(ArrayAddress dst);\n+  void incrementl(AddressLiteral dst, Register rscratch = noreg);\n+  void incrementl(ArrayAddress   dst, Register rscratch);\n@@ -229,1 +229,1 @@\n-  void incrementq(AddressLiteral dst);\n+  void incrementq(AddressLiteral dst, Register rscratch = noreg);\n@@ -348,1 +348,2 @@\n-                           address last_java_pc);\n+                           address  last_java_pc,\n+                           Register rscratch);\n@@ -353,1 +354,2 @@\n-                           address last_java_pc);\n+                           address  last_java_pc,\n+                           Register rscratch);\n@@ -374,1 +376,1 @@\n-  void resolve_oop_handle(Register result, Register tmp = rscratch2);\n+  void resolve_oop_handle(Register result, Register tmp);\n@@ -376,1 +378,1 @@\n-  void load_mirror(Register mirror, Register method, Register tmp = rscratch2);\n+  void load_mirror(Register mirror, Register method, Register tmp);\n@@ -722,1 +724,1 @@\n-  void restore_cpu_control_state_after_jni();\n+  void restore_cpu_control_state_after_jni(Register rscratch);\n@@ -783,2 +785,2 @@\n-    if (src.is_constant()) addptr(dst, (int) src.as_constant());\n-    else                   addptr(dst,       src.as_register());\n+    if (src.is_constant()) addptr(dst, src.as_constant());\n+    else                   addptr(dst, src.as_register());\n@@ -791,1 +793,1 @@\n-  void cmp8(AddressLiteral src1, int imm);\n+  void cmp8(AddressLiteral src1, int imm, Register rscratch = noreg);\n@@ -796,1 +798,1 @@\n-  void cmp32(AddressLiteral src1, int32_t imm);\n+  void cmp32(AddressLiteral src1, int32_t imm, Register rscratch = noreg);\n@@ -798,1 +800,1 @@\n-  void cmp32(Register src1, AddressLiteral src2);\n+  void cmp32(Register src1, AddressLiteral src2, Register rscratch = noreg);\n@@ -810,1 +812,1 @@\n-  void cmpoop(Register dst, jobject obj);\n+  void cmpoop(Register dst, jobject obj, Register rscratch);\n@@ -813,1 +815,1 @@\n-  void cmpptr(Address src1, AddressLiteral src2);\n+  void cmpptr(Address src1, AddressLiteral src2, Register rscratch);\n@@ -815,1 +817,1 @@\n-  void cmpptr(Register src1, AddressLiteral src2);\n+  void cmpptr(Register src1, AddressLiteral src2, Register rscratch = noreg);\n@@ -825,1 +827,1 @@\n-  void cmp64(Register src1, AddressLiteral src);\n+  void cmp64(Register src1, AddressLiteral src, Register rscratch = noreg);\n@@ -829,2 +831,1 @@\n-  void locked_cmpxchgptr(Register reg, AddressLiteral adr);\n-\n+  void locked_cmpxchgptr(Register reg, AddressLiteral adr, Register rscratch = noreg);\n@@ -873,1 +874,1 @@\n-  void cond_inc32(Condition cond, AddressLiteral counter_addr);\n+  void cond_inc32(Condition cond, AddressLiteral counter_addr, Register rscratch = noreg);\n@@ -876,1 +877,1 @@\n-  void atomic_incl(AddressLiteral counter_addr, Register scr = rscratch1);\n+  void atomic_incl(AddressLiteral counter_addr, Register rscratch = noreg);\n@@ -879,1 +880,1 @@\n-  void atomic_incq(AddressLiteral counter_addr, Register scr = rscratch1);\n+  void atomic_incq(AddressLiteral counter_addr, Register rscratch = noreg);\n@@ -881,1 +882,1 @@\n-  void atomic_incptr(AddressLiteral counter_addr, Register scr = rscratch1) { LP64_ONLY(atomic_incq(counter_addr, scr)) NOT_LP64(atomic_incl(counter_addr, scr)) ; }\n+  void atomic_incptr(AddressLiteral counter_addr, Register rscratch = noreg) { LP64_ONLY(atomic_incq(counter_addr, rscratch)) NOT_LP64(atomic_incl(counter_addr, rscratch)) ; }\n@@ -884,0 +885,1 @@\n+  void lea(Register dst, Address        adr) { Assembler::lea(dst, adr); }\n@@ -885,2 +887,1 @@\n-  void lea(Address dst, AddressLiteral adr);\n-  void lea(Register dst, Address adr) { Assembler::lea(dst, adr); }\n+  void lea(Address  dst, AddressLiteral adr, Register rscratch);\n@@ -893,1 +894,1 @@\n-  void testl(Register dst, AddressLiteral src);\n+  void testl(Register dst, AddressLiteral src); \/\/ requires reachable address\n@@ -916,1 +917,1 @@\n-  void call(AddressLiteral entry);\n+  void call(AddressLiteral entry, Register rscratch = rax);\n@@ -928,2 +929,3 @@\n-  void jump(AddressLiteral dst);\n-  void jump_cc(Condition cc, AddressLiteral dst);\n+  void jump(AddressLiteral dst, Register rscratch = noreg);\n+\n+  void jump_cc(Condition cc, AddressLiteral dst, Register rscratch = noreg);\n@@ -934,1 +936,1 @@\n-  void jump(ArrayAddress entry);\n+  void jump(ArrayAddress entry, Register rscratch);\n@@ -943,3 +945,3 @@\n-  void andpd(XMMRegister dst, Address src) { Assembler::andpd(dst, src); }\n-  void andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);\n-  void andpd(XMMRegister dst, XMMRegister src) { Assembler::andpd(dst, src); }\n+  void andpd(XMMRegister dst, XMMRegister    src) { Assembler::andpd(dst, src); }\n+  void andpd(XMMRegister dst, Address        src) { Assembler::andpd(dst, src); }\n+  void andpd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -947,3 +949,3 @@\n-  void andps(XMMRegister dst, XMMRegister src) { Assembler::andps(dst, src); }\n-  void andps(XMMRegister dst, Address src) { Assembler::andps(dst, src); }\n-  void andps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);\n+  void andps(XMMRegister dst, XMMRegister    src) { Assembler::andps(dst, src); }\n+  void andps(XMMRegister dst, Address        src) { Assembler::andps(dst, src); }\n+  void andps(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -951,3 +953,3 @@\n-  void comiss(XMMRegister dst, XMMRegister src) { Assembler::comiss(dst, src); }\n-  void comiss(XMMRegister dst, Address src) { Assembler::comiss(dst, src); }\n-  void comiss(XMMRegister dst, AddressLiteral src);\n+  void comiss(XMMRegister dst, XMMRegister    src) { Assembler::comiss(dst, src); }\n+  void comiss(XMMRegister dst, Address        src) { Assembler::comiss(dst, src); }\n+  void comiss(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -955,3 +957,3 @@\n-  void comisd(XMMRegister dst, XMMRegister src) { Assembler::comisd(dst, src); }\n-  void comisd(XMMRegister dst, Address src) { Assembler::comisd(dst, src); }\n-  void comisd(XMMRegister dst, AddressLiteral src);\n+  void comisd(XMMRegister dst, XMMRegister    src) { Assembler::comisd(dst, src); }\n+  void comisd(XMMRegister dst, Address        src) { Assembler::comisd(dst, src); }\n+  void comisd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -960,1 +962,1 @@\n-  void fadd_s(Address src)        { Assembler::fadd_s(src); }\n+  void fadd_s(Address        src) { Assembler::fadd_s(src); }\n@@ -963,1 +965,1 @@\n-  void fldcw(Address src) { Assembler::fldcw(src); }\n+  void fldcw(Address        src) { Assembler::fldcw(src); }\n@@ -966,2 +968,2 @@\n-  void fld_s(int index)   { Assembler::fld_s(index); }\n-  void fld_s(Address src) { Assembler::fld_s(src); }\n+  void fld_s(int index)          { Assembler::fld_s(index); }\n+  void fld_s(Address        src) { Assembler::fld_s(src); }\n@@ -970,1 +972,1 @@\n-  void fld_d(Address src) { Assembler::fld_d(src); }\n+  void fld_d(Address        src) { Assembler::fld_d(src); }\n@@ -973,3 +975,2 @@\n-  void fmul_s(Address src)        { Assembler::fmul_s(src); }\n-  void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }\n-#endif \/\/ _LP64\n+  void fld_x(Address        src) { Assembler::fld_x(src); }\n+  void fld_x(AddressLiteral src) { Assembler::fld_x(as_Address(src)); }\n@@ -977,2 +978,3 @@\n-  void fld_x(Address src) { Assembler::fld_x(src); }\n-  void fld_x(AddressLiteral src);\n+  void fmul_s(Address        src) { Assembler::fmul_s(src); }\n+  void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }\n+#endif \/\/ !_LP64\n@@ -981,1 +983,1 @@\n-  void ldmxcsr(AddressLiteral src, Register scratchReg = rscratch1);\n+  void ldmxcsr(AddressLiteral src, Register rscratch = noreg);\n@@ -1089,0 +1091,23 @@\n+ private:\n+  \/\/ Initialized in macroAssembler_x86_constants.cpp\n+  static address ONE;\n+  static address ONEHALF;\n+  static address SIGN_MASK;\n+  static address TWO_POW_55;\n+  static address TWO_POW_M55;\n+  static address SHIFTER;\n+  static address ZERO;\n+  static address NEG_ZERO;\n+  static address PI32INV;\n+  static address PI_INV_TABLE;\n+  static address Ctable;\n+  static address SC_1;\n+  static address SC_2;\n+  static address SC_3;\n+  static address SC_4;\n+  static address PI_4;\n+  static address P_1;\n+  static address P_3;\n+  static address P_2;\n+\n+ public:\n@@ -1095,1 +1120,1 @@\n-                  Register rax, Register rcx, Register rdx, Register r11);\n+                  Register rax, Register rcx, Register rdx, Register r11, Register tmp);\n@@ -1103,2 +1128,1 @@\n-                Register rax, Register rbx, Register rcx, Register rdx, Register tmp1, Register tmp2,\n-                Register tmp3, Register tmp4);\n+                Register rax, Register rbx, Register rcx, Register rdx, Register tmp1);\n@@ -1108,2 +1132,3 @@\n-                Register rax, Register rcx, Register rdx, Register tmp1,\n-                Register tmp2, Register tmp3, Register tmp4);\n+                Register rax, Register rcx, Register rdx, Register r8,\n+                Register  r9, Register r10, Register r11, Register tmp);\n+\n@@ -1112,2 +1137,3 @@\n-                Register rax, Register rcx, Register rdx, Register tmp1,\n-                Register tmp2, Register tmp3, Register tmp4);\n+                Register rax, Register rcx, Register rdx, Register r8,\n+                Register  r9, Register r10, Register r11, Register tmp);\n+\n@@ -1115,0 +1141,9 @@\n+ private:\n+  \/\/ Initialized in macroAssembler_x86_constants.cpp\n+  static address ONES;\n+  static address L_2IL0FLOATPACKET_0;\n+  static address PI4_INV;\n+  static address PI4X3;\n+  static address PI4X4;\n+\n+ public:\n@@ -1155,4 +1190,4 @@\n-  void movss(XMMRegister dst, XMMRegister src) { Assembler::movss(dst, src); }\n-  void movss(Address dst, XMMRegister src)     { Assembler::movss(dst, src); }\n-  void movss(XMMRegister dst, Address src)     { Assembler::movss(dst, src); }\n-  void movss(XMMRegister dst, AddressLiteral src);\n+  void movss(Address     dst, XMMRegister    src) { Assembler::movss(dst, src); }\n+  void movss(XMMRegister dst, XMMRegister    src) { Assembler::movss(dst, src); }\n+  void movss(XMMRegister dst, Address        src) { Assembler::movss(dst, src); }\n+  void movss(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1160,2 +1195,2 @@\n-  void movlpd(XMMRegister dst, Address src)    {Assembler::movlpd(dst, src); }\n-  void movlpd(XMMRegister dst, AddressLiteral src);\n+  void movlpd(XMMRegister dst, Address        src) {Assembler::movlpd(dst, src); }\n+  void movlpd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1165,3 +1200,3 @@\n-  void addsd(XMMRegister dst, XMMRegister src)    { Assembler::addsd(dst, src); }\n-  void addsd(XMMRegister dst, Address src)        { Assembler::addsd(dst, src); }\n-  void addsd(XMMRegister dst, AddressLiteral src);\n+  void addsd(XMMRegister dst, XMMRegister    src) { Assembler::addsd(dst, src); }\n+  void addsd(XMMRegister dst, Address        src) { Assembler::addsd(dst, src); }\n+  void addsd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1169,3 +1204,3 @@\n-  void addss(XMMRegister dst, XMMRegister src)    { Assembler::addss(dst, src); }\n-  void addss(XMMRegister dst, Address src)        { Assembler::addss(dst, src); }\n-  void addss(XMMRegister dst, AddressLiteral src);\n+  void addss(XMMRegister dst, XMMRegister    src) { Assembler::addss(dst, src); }\n+  void addss(XMMRegister dst, Address        src) { Assembler::addss(dst, src); }\n+  void addss(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1173,3 +1208,3 @@\n-  void addpd(XMMRegister dst, XMMRegister src)    { Assembler::addpd(dst, src); }\n-  void addpd(XMMRegister dst, Address src)        { Assembler::addpd(dst, src); }\n-  void addpd(XMMRegister dst, AddressLiteral src);\n+  void addpd(XMMRegister dst, XMMRegister    src) { Assembler::addpd(dst, src); }\n+  void addpd(XMMRegister dst, Address        src) { Assembler::addpd(dst, src); }\n+  void addpd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1177,3 +1212,5 @@\n-  void divsd(XMMRegister dst, XMMRegister src)    { Assembler::divsd(dst, src); }\n-  void divsd(XMMRegister dst, Address src)        { Assembler::divsd(dst, src); }\n-  void divsd(XMMRegister dst, AddressLiteral src);\n+  using Assembler::vbroadcastsd;\n+  void vbroadcastsd(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = noreg);\n+\n+  using Assembler::vbroadcastss;\n+  void vbroadcastss(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1181,3 +1218,7 @@\n-  void divss(XMMRegister dst, XMMRegister src)    { Assembler::divss(dst, src); }\n-  void divss(XMMRegister dst, Address src)        { Assembler::divss(dst, src); }\n-  void divss(XMMRegister dst, AddressLiteral src);\n+  void divsd(XMMRegister dst, XMMRegister    src) { Assembler::divsd(dst, src); }\n+  void divsd(XMMRegister dst, Address        src) { Assembler::divsd(dst, src); }\n+  void divsd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n+\n+  void divss(XMMRegister dst, XMMRegister    src) { Assembler::divss(dst, src); }\n+  void divss(XMMRegister dst, Address        src) { Assembler::divss(dst, src); }\n+  void divss(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1186,18 +1227,18 @@\n-  void movdqu(Address     dst, XMMRegister src);\n-  void movdqu(XMMRegister dst, Address src);\n-  void movdqu(XMMRegister dst, XMMRegister src);\n-  void movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg = rscratch1);\n-\n-  void kmovwl(KRegister dst, Register src) { Assembler::kmovwl(dst, src); }\n-  void kmovwl(Register dst, KRegister src) { Assembler::kmovwl(dst, src); }\n-  void kmovwl(KRegister dst, Address src) { Assembler::kmovwl(dst, src); }\n-  void kmovwl(KRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);\n-  void kmovwl(Address dst,  KRegister src) { Assembler::kmovwl(dst, src); }\n-  void kmovwl(KRegister dst, KRegister src) { Assembler::kmovwl(dst, src); }\n-\n-  void kmovql(KRegister dst, KRegister src) { Assembler::kmovql(dst, src); }\n-  void kmovql(KRegister dst, Register src) { Assembler::kmovql(dst, src); }\n-  void kmovql(Register dst, KRegister src) { Assembler::kmovql(dst, src); }\n-  void kmovql(KRegister dst, Address src) { Assembler::kmovql(dst, src); }\n-  void kmovql(Address  dst, KRegister src) { Assembler::kmovql(dst, src); }\n-  void kmovql(KRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);\n+  void movdqu(Address     dst, XMMRegister    src);\n+  void movdqu(XMMRegister dst, XMMRegister    src);\n+  void movdqu(XMMRegister dst, Address        src);\n+  void movdqu(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n+\n+  void kmovwl(Register  dst, KRegister      src) { Assembler::kmovwl(dst, src); }\n+  void kmovwl(Address   dst, KRegister      src) { Assembler::kmovwl(dst, src); }\n+  void kmovwl(KRegister dst, KRegister      src) { Assembler::kmovwl(dst, src); }\n+  void kmovwl(KRegister dst, Register       src) { Assembler::kmovwl(dst, src); }\n+  void kmovwl(KRegister dst, Address        src) { Assembler::kmovwl(dst, src); }\n+  void kmovwl(KRegister dst, AddressLiteral src, Register rscratch = noreg);\n+\n+  void kmovql(KRegister dst, KRegister      src) { Assembler::kmovql(dst, src); }\n+  void kmovql(KRegister dst, Register       src) { Assembler::kmovql(dst, src); }\n+  void kmovql(Register  dst, KRegister      src) { Assembler::kmovql(dst, src); }\n+  void kmovql(KRegister dst, Address        src) { Assembler::kmovql(dst, src); }\n+  void kmovql(Address   dst, KRegister      src) { Assembler::kmovql(dst, src); }\n+  void kmovql(KRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1213,6 +1254,2 @@\n-  \/\/ AVX Unaligned forms\n-  void vmovdqu(Address     dst, XMMRegister src);\n-  void vmovdqu(XMMRegister dst, Address src);\n-  void vmovdqu(XMMRegister dst, XMMRegister src);\n-  void vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);\n-  void vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg, int vector_len);\n+  using Assembler::movddup;\n+  void movddup(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1220,0 +1257,9 @@\n+  using Assembler::vmovddup;\n+  void vmovddup(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = noreg);\n+\n+  \/\/ AVX Unaligned forms\n+  void vmovdqu(Address     dst, XMMRegister    src);\n+  void vmovdqu(XMMRegister dst, Address        src);\n+  void vmovdqu(XMMRegister dst, XMMRegister    src);\n+  void vmovdqu(XMMRegister dst, AddressLiteral src,                 Register rscratch = noreg);\n+  void vmovdqu(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1222,2 +1268,2 @@\n-  void evmovdqu(BasicType type, KRegister kmask, Address dst, XMMRegister src,  bool merge, int vector_len);\n-  void evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, Address src, bool merge, int vector_len);\n+  void evmovdqu(BasicType type, KRegister kmask, Address     dst, XMMRegister src, bool merge, int vector_len);\n+  void evmovdqu(BasicType type, KRegister kmask, XMMRegister dst, Address     src, bool merge, int vector_len);\n@@ -1226,1 +1272,2 @@\n-  void evmovdqub(XMMRegister dst, Address src, int vector_len) { Assembler::evmovdqub(dst, src, vector_len); }\n+  void evmovdqub(XMMRegister dst, Address     src, int vector_len) { Assembler::evmovdqub(dst, src, vector_len); }\n+\n@@ -1232,3 +1279,6 @@\n-  void evmovdqub(XMMRegister dst, KRegister mask, Address src, bool merge, int vector_len) { Assembler::evmovdqub(dst, mask, src, merge, vector_len); }\n-  void evmovdqub(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len) { Assembler::evmovdqub(dst, mask, src, merge, vector_len); }\n-  void evmovdqub(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge, int vector_len, Register scratch_reg);\n+  void evmovdqub(Address     dst, KRegister mask, XMMRegister    src, bool merge, int vector_len) { Assembler::evmovdqub(dst, mask, src, merge, vector_len); }\n+  void evmovdqub(XMMRegister dst, KRegister mask, Address        src, bool merge, int vector_len) { Assembler::evmovdqub(dst, mask, src, merge, vector_len); }\n+  void evmovdqub(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge, int vector_len, Register rscratch = noreg);\n+\n+  void evmovdquw(Address     dst, XMMRegister src, int vector_len) { Assembler::evmovdquw(dst, src, vector_len); }\n+  void evmovdquw(XMMRegister dst, Address     src, int vector_len) { Assembler::evmovdquw(dst, src, vector_len); }\n@@ -1236,2 +1286,0 @@\n-  void evmovdquw(XMMRegister dst, Address src, int vector_len) { Assembler::evmovdquw(dst, src, vector_len); }\n-  void evmovdquw(Address dst, XMMRegister src, int vector_len) { Assembler::evmovdquw(dst, src, vector_len); }\n@@ -1243,3 +1291,3 @@\n-  void evmovdquw(XMMRegister dst, KRegister mask, Address src, bool merge, int vector_len) { Assembler::evmovdquw(dst, mask, src, merge, vector_len); }\n-  void evmovdquw(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len) { Assembler::evmovdquw(dst, mask, src, merge, vector_len); }\n-  void evmovdquw(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge, int vector_len, Register scratch_reg);\n+  void evmovdquw(XMMRegister dst, KRegister mask, Address        src, bool merge, int vector_len) { Assembler::evmovdquw(dst, mask, src, merge, vector_len); }\n+  void evmovdquw(Address     dst, KRegister mask, XMMRegister    src, bool merge, int vector_len) { Assembler::evmovdquw(dst, mask, src, merge, vector_len); }\n+  void evmovdquw(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge, int vector_len, Register rscratch = noreg);\n@@ -1252,2 +1300,2 @@\n-  void evmovdqul(Address dst, XMMRegister src, int vector_len) { Assembler::evmovdqul(dst, src, vector_len); }\n-  void evmovdqul(XMMRegister dst, Address src, int vector_len) { Assembler::evmovdqul(dst, src, vector_len); }\n+  void evmovdqul(Address     dst, XMMRegister src, int vector_len) { Assembler::evmovdqul(dst, src, vector_len); }\n+  void evmovdqul(XMMRegister dst, Address     src, int vector_len) { Assembler::evmovdqul(dst, src, vector_len); }\n@@ -1260,3 +1308,3 @@\n-  void evmovdqul(XMMRegister dst, KRegister mask, Address src, bool merge, int vector_len) { Assembler::evmovdqul(dst, mask, src, merge, vector_len); }\n-  void evmovdqul(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len) { Assembler::evmovdqul(dst, mask, src, merge, vector_len); }\n-  void evmovdqul(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge, int vector_len, Register scratch_reg);\n+  void evmovdqul(Address     dst, KRegister mask, XMMRegister    src, bool merge, int vector_len) { Assembler::evmovdqul(dst, mask, src, merge, vector_len); }\n+  void evmovdqul(XMMRegister dst, KRegister mask, Address        src, bool merge, int vector_len) { Assembler::evmovdqul(dst, mask, src, merge, vector_len); }\n+  void evmovdqul(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge, int vector_len, Register rscratch = noreg);\n@@ -1269,3 +1317,3 @@\n-  void evmovdquq(XMMRegister dst, Address src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }\n-  void evmovdquq(Address dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }\n-  void evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch);\n+  void evmovdquq(XMMRegister dst, Address        src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }\n+  void evmovdquq(Address     dst, XMMRegister    src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }\n+  void evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1278,3 +1326,3 @@\n-  void evmovdquq(XMMRegister dst, KRegister mask, Address src, bool merge, int vector_len) { Assembler::evmovdquq(dst, mask, src, merge, vector_len); }\n-  void evmovdquq(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len) { Assembler::evmovdquq(dst, mask, src, merge, vector_len); }\n-  void evmovdquq(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge, int vector_len, Register scratch_reg);\n+  void evmovdquq(Address     dst, KRegister mask, XMMRegister    src, bool merge, int vector_len) { Assembler::evmovdquq(dst, mask, src, merge, vector_len); }\n+  void evmovdquq(XMMRegister dst, KRegister mask, Address        src, bool merge, int vector_len) { Assembler::evmovdquq(dst, mask, src, merge, vector_len); }\n+  void evmovdquq(XMMRegister dst, KRegister mask, AddressLiteral src, bool merge, int vector_len, Register rscratch = noreg);\n@@ -1283,3 +1331,3 @@\n-  void movdqa(XMMRegister dst, Address src)       { Assembler::movdqa(dst, src); }\n-  void movdqa(XMMRegister dst, XMMRegister src)   { Assembler::movdqa(dst, src); }\n-  void movdqa(XMMRegister dst, AddressLiteral src);\n+  void movdqa(XMMRegister dst, XMMRegister    src) { Assembler::movdqa(dst, src); }\n+  void movdqa(XMMRegister dst, Address        src) { Assembler::movdqa(dst, src); }\n+  void movdqa(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1287,7 +1335,4 @@\n-  void movsd(XMMRegister dst, XMMRegister src) { Assembler::movsd(dst, src); }\n-  void movsd(Address dst, XMMRegister src)     { Assembler::movsd(dst, src); }\n-  void movsd(XMMRegister dst, Address src)     { Assembler::movsd(dst, src); }\n-  void movsd(XMMRegister dst, AddressLiteral src);\n-\n-  using Assembler::vmovddup;\n-  void vmovddup(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = rscratch1);\n+  void movsd(Address     dst, XMMRegister    src) { Assembler::movsd(dst, src); }\n+  void movsd(XMMRegister dst, XMMRegister    src) { Assembler::movsd(dst, src); }\n+  void movsd(XMMRegister dst, Address        src) { Assembler::movsd(dst, src); }\n+  void movsd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1295,3 +1340,3 @@\n-  void mulpd(XMMRegister dst, XMMRegister src)    { Assembler::mulpd(dst, src); }\n-  void mulpd(XMMRegister dst, Address src)        { Assembler::mulpd(dst, src); }\n-  void mulpd(XMMRegister dst, AddressLiteral src);\n+  void mulpd(XMMRegister dst, XMMRegister    src) { Assembler::mulpd(dst, src); }\n+  void mulpd(XMMRegister dst, Address        src) { Assembler::mulpd(dst, src); }\n+  void mulpd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1299,3 +1344,3 @@\n-  void mulsd(XMMRegister dst, XMMRegister src)    { Assembler::mulsd(dst, src); }\n-  void mulsd(XMMRegister dst, Address src)        { Assembler::mulsd(dst, src); }\n-  void mulsd(XMMRegister dst, AddressLiteral src);\n+  void mulsd(XMMRegister dst, XMMRegister    src) { Assembler::mulsd(dst, src); }\n+  void mulsd(XMMRegister dst, Address        src) { Assembler::mulsd(dst, src); }\n+  void mulsd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1303,3 +1348,3 @@\n-  void mulss(XMMRegister dst, XMMRegister src)    { Assembler::mulss(dst, src); }\n-  void mulss(XMMRegister dst, Address src)        { Assembler::mulss(dst, src); }\n-  void mulss(XMMRegister dst, AddressLiteral src);\n+  void mulss(XMMRegister dst, XMMRegister    src) { Assembler::mulss(dst, src); }\n+  void mulss(XMMRegister dst, Address        src) { Assembler::mulss(dst, src); }\n+  void mulss(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1330,3 +1375,3 @@\n-  void sqrtsd(XMMRegister dst, XMMRegister src)    { Assembler::sqrtsd(dst, src); }\n-  void sqrtsd(XMMRegister dst, Address src)        { Assembler::sqrtsd(dst, src); }\n-  void sqrtsd(XMMRegister dst, AddressLiteral src);\n+  void roundsd(XMMRegister dst, XMMRegister    src, int32_t rmode) { Assembler::roundsd(dst, src, rmode); }\n+  void roundsd(XMMRegister dst, Address        src, int32_t rmode) { Assembler::roundsd(dst, src, rmode); }\n+  void roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register rscratch = noreg);\n@@ -1334,3 +1379,3 @@\n-  void roundsd(XMMRegister dst, XMMRegister src, int32_t rmode)    { Assembler::roundsd(dst, src, rmode); }\n-  void roundsd(XMMRegister dst, Address src, int32_t rmode)        { Assembler::roundsd(dst, src, rmode); }\n-  void roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg);\n+  void sqrtss(XMMRegister dst, XMMRegister     src) { Assembler::sqrtss(dst, src); }\n+  void sqrtss(XMMRegister dst, Address         src) { Assembler::sqrtss(dst, src); }\n+  void sqrtss(XMMRegister dst, AddressLiteral  src, Register rscratch = noreg);\n@@ -1338,3 +1383,3 @@\n-  void sqrtss(XMMRegister dst, XMMRegister src)    { Assembler::sqrtss(dst, src); }\n-  void sqrtss(XMMRegister dst, Address src)        { Assembler::sqrtss(dst, src); }\n-  void sqrtss(XMMRegister dst, AddressLiteral src);\n+  void subsd(XMMRegister dst, XMMRegister    src) { Assembler::subsd(dst, src); }\n+  void subsd(XMMRegister dst, Address        src) { Assembler::subsd(dst, src); }\n+  void subsd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1342,3 +1387,3 @@\n-  void subsd(XMMRegister dst, XMMRegister src)    { Assembler::subsd(dst, src); }\n-  void subsd(XMMRegister dst, Address src)        { Assembler::subsd(dst, src); }\n-  void subsd(XMMRegister dst, AddressLiteral src);\n+  void subss(XMMRegister dst, XMMRegister    src) { Assembler::subss(dst, src); }\n+  void subss(XMMRegister dst, Address        src) { Assembler::subss(dst, src); }\n+  void subss(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1346,3 +1391,3 @@\n-  void subss(XMMRegister dst, XMMRegister src)    { Assembler::subss(dst, src); }\n-  void subss(XMMRegister dst, Address src)        { Assembler::subss(dst, src); }\n-  void subss(XMMRegister dst, AddressLiteral src);\n+  void ucomiss(XMMRegister dst, XMMRegister    src) { Assembler::ucomiss(dst, src); }\n+  void ucomiss(XMMRegister dst, Address        src) { Assembler::ucomiss(dst, src); }\n+  void ucomiss(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1350,7 +1395,3 @@\n-  void ucomiss(XMMRegister dst, XMMRegister src) { Assembler::ucomiss(dst, src); }\n-  void ucomiss(XMMRegister dst, Address src)     { Assembler::ucomiss(dst, src); }\n-  void ucomiss(XMMRegister dst, AddressLiteral src);\n-\n-  void ucomisd(XMMRegister dst, XMMRegister src) { Assembler::ucomisd(dst, src); }\n-  void ucomisd(XMMRegister dst, Address src)     { Assembler::ucomisd(dst, src); }\n-  void ucomisd(XMMRegister dst, AddressLiteral src);\n+  void ucomisd(XMMRegister dst, XMMRegister    src) { Assembler::ucomisd(dst, src); }\n+  void ucomisd(XMMRegister dst, Address        src) { Assembler::ucomisd(dst, src); }\n+  void ucomisd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1359,3 +1400,3 @@\n-  void xorpd(XMMRegister dst, XMMRegister src);\n-  void xorpd(XMMRegister dst, Address src)     { Assembler::xorpd(dst, src); }\n-  void xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);\n+  void xorpd(XMMRegister dst, XMMRegister    src);\n+  void xorpd(XMMRegister dst, Address        src) { Assembler::xorpd(dst, src); }\n+  void xorpd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1364,3 +1405,3 @@\n-  void xorps(XMMRegister dst, XMMRegister src);\n-  void xorps(XMMRegister dst, Address src)     { Assembler::xorps(dst, src); }\n-  void xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);\n+  void xorps(XMMRegister dst, XMMRegister    src);\n+  void xorps(XMMRegister dst, Address        src) { Assembler::xorps(dst, src); }\n+  void xorps(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1369,3 +1410,3 @@\n-  void pshufb(XMMRegister dst, XMMRegister src) { Assembler::pshufb(dst, src); }\n-  void pshufb(XMMRegister dst, Address src)     { Assembler::pshufb(dst, src); }\n-  void pshufb(XMMRegister dst, AddressLiteral src);\n+  void pshufb(XMMRegister dst, XMMRegister    src) { Assembler::pshufb(dst, src); }\n+  void pshufb(XMMRegister dst, Address        src) { Assembler::pshufb(dst, src); }\n+  void pshufb(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1374,3 +1415,3 @@\n-  void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddsd(dst, nds, src); }\n-  void vaddsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddsd(dst, nds, src); }\n-  void vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);\n+  void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister    src) { Assembler::vaddsd(dst, nds, src); }\n+  void vaddsd(XMMRegister dst, XMMRegister nds, Address        src) { Assembler::vaddsd(dst, nds, src); }\n+  void vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch = noreg);\n@@ -1378,3 +1419,3 @@\n-  void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddss(dst, nds, src); }\n-  void vaddss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddss(dst, nds, src); }\n-  void vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src);\n+  void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister    src) { Assembler::vaddss(dst, nds, src); }\n+  void vaddss(XMMRegister dst, XMMRegister nds, Address        src) { Assembler::vaddss(dst, nds, src); }\n+  void vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch = noreg);\n@@ -1382,2 +1423,2 @@\n-  void vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);\n-  void vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);\n+  void vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len, Register rscratch = noreg);\n+  void vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len, Register rscratch = noreg);\n@@ -1385,3 +1426,3 @@\n-  void vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n-  void vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n-  void vpaddb(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch);\n+  void vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister    src, int vector_len);\n+  void vpaddb(XMMRegister dst, XMMRegister nds, Address        src, int vector_len);\n+  void vpaddb(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1390,5 +1431,1 @@\n-  void vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n-\n-  void vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }\n-  void vpaddd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }\n-  void vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch);\n+  void vpaddw(XMMRegister dst, XMMRegister nds, Address     src, int vector_len);\n@@ -1396,3 +1433,3 @@\n-  void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }\n-  void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }\n-  void vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);\n+  void vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister    src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }\n+  void vpaddd(XMMRegister dst, XMMRegister nds, Address        src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }\n+  void vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1400,8 +1437,3 @@\n-  void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);\n-  void vpbroadcastw(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastw(dst, src, vector_len); }\n-\n-  using Assembler::vbroadcastsd;\n-  void vbroadcastsd(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = rscratch1);\n-  void vpbroadcastq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = rscratch1);\n-  void vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::vpbroadcastq(dst, src, vector_len); }\n-  void vpbroadcastq(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastq(dst, src, vector_len); }\n+  void vpand(XMMRegister dst, XMMRegister nds, XMMRegister    src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }\n+  void vpand(XMMRegister dst, XMMRegister nds, Address        src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }\n+  void vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1409,0 +1441,2 @@\n+  using Assembler::vpbroadcastd;\n+  void vpbroadcastd(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1410,0 +1444,2 @@\n+  using Assembler::vpbroadcastq;\n+  void vpbroadcastq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1414,1 +1450,1 @@\n-  void evpcmpeqd(KRegister kdst, KRegister mask, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg);\n+  void evpcmpeqd(KRegister kdst, KRegister mask, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1417,16 +1453,19 @@\n-  void evpcmpd(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src,\n-               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpd(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n-  void evpcmpd(KRegister kdst, KRegister mask, XMMRegister nds, AddressLiteral src,\n-               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n-  void evpcmpq(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src,\n-               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpq(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n-  void evpcmpq(KRegister kdst, KRegister mask, XMMRegister nds, AddressLiteral src,\n-               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n-  void evpcmpb(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src,\n-               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpb(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n-  void evpcmpb(KRegister kdst, KRegister mask, XMMRegister nds, AddressLiteral src,\n-               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n-  void evpcmpw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src,\n-               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpw(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n-  void evpcmpw(KRegister kdst, KRegister mask, XMMRegister nds, AddressLiteral src,\n-               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n+  void evpcmpd(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister    src, int comparison, bool is_signed, int vector_len) {\n+    Assembler::evpcmpd(kdst, mask, nds, src, comparison, is_signed, vector_len);\n+  }\n+  void evpcmpd(KRegister kdst, KRegister mask, XMMRegister nds, AddressLiteral src, int comparison, bool is_signed, int vector_len, Register rscratch = noreg);\n+\n+  void evpcmpq(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister    src, int comparison, bool is_signed, int vector_len) {\n+    Assembler::evpcmpq(kdst, mask, nds, src, comparison, is_signed, vector_len);\n+  }\n+  void evpcmpq(KRegister kdst, KRegister mask, XMMRegister nds, AddressLiteral src, int comparison, bool is_signed, int vector_len, Register rscratch = noreg);\n+\n+  void evpcmpb(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister    src, int comparison, bool is_signed, int vector_len) {\n+    Assembler::evpcmpb(kdst, mask, nds, src, comparison, is_signed, vector_len);\n+  }\n+  void evpcmpb(KRegister kdst, KRegister mask, XMMRegister nds, AddressLiteral src, int comparison, bool is_signed, int vector_len, Register rscratch = noreg);\n+\n+  void evpcmpw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister    src, int comparison, bool is_signed, int vector_len) {\n+    Assembler::evpcmpw(kdst, mask, nds, src, comparison, is_signed, vector_len);\n+  }\n+  void evpcmpw(KRegister kdst, KRegister mask, XMMRegister nds, AddressLiteral src, int comparison, bool is_signed, int vector_len, Register rscratch = noreg);\n@@ -1440,1 +1479,1 @@\n-  void vpmovzxbw(XMMRegister dst, Address src, int vector_len);\n+  void vpmovzxbw(XMMRegister dst, Address     src, int vector_len);\n@@ -1446,8 +1485,5 @@\n-  void vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n-  void vpmulld(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n-    Assembler::vpmulld(dst, nds, src, vector_len);\n-  };\n-  void vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-    Assembler::vpmulld(dst, nds, src, vector_len);\n-  }\n-  void vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg);\n+  void vpmullw(XMMRegister dst, XMMRegister nds, Address     src, int vector_len);\n+\n+  void vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister    src, int vector_len) { Assembler::vpmulld(dst, nds, src, vector_len); }\n+  void vpmulld(XMMRegister dst, XMMRegister nds, Address        src, int vector_len) { Assembler::vpmulld(dst, nds, src, vector_len); }\n+  void vpmulld(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1456,1 +1492,1 @@\n-  void vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpsubb(XMMRegister dst, XMMRegister nds, Address     src, int vector_len);\n@@ -1459,1 +1495,1 @@\n-  void vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void vpsubw(XMMRegister dst, XMMRegister nds, Address     src, int vector_len);\n@@ -1462,1 +1498,1 @@\n-  void vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);\n+  void vpsraw(XMMRegister dst, XMMRegister nds, int         shift, int vector_len);\n@@ -1465,1 +1501,1 @@\n-  void evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len);\n+  void evpsraq(XMMRegister dst, XMMRegister nds, int         shift, int vector_len);\n@@ -1554,3 +1590,3 @@\n-  void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandpd(dst, nds, src, vector_len); }\n-  void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandpd(dst, nds, src, vector_len); }\n-  void vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);\n+  void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister    src, int vector_len) { Assembler::vandpd(dst, nds, src, vector_len); }\n+  void vandpd(XMMRegister dst, XMMRegister nds, Address        src, int vector_len) { Assembler::vandpd(dst, nds, src, vector_len); }\n+  void vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1558,3 +1594,3 @@\n-  void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandps(dst, nds, src, vector_len); }\n-  void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandps(dst, nds, src, vector_len); }\n-  void vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);\n+  void vandps(XMMRegister dst, XMMRegister nds, XMMRegister    src, int vector_len) { Assembler::vandps(dst, nds, src, vector_len); }\n+  void vandps(XMMRegister dst, XMMRegister nds, Address        src, int vector_len) { Assembler::vandps(dst, nds, src, vector_len); }\n+  void vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1562,1 +1598,1 @@\n-  void evpord(XMMRegister dst, KRegister mask, XMMRegister nds, AddressLiteral src, bool merge, int vector_len, Register scratch_reg);\n+  void evpord(XMMRegister dst, KRegister mask, XMMRegister nds, AddressLiteral src, bool merge, int vector_len, Register rscratch = noreg);\n@@ -1564,3 +1600,3 @@\n-  void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivsd(dst, nds, src); }\n-  void vdivsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivsd(dst, nds, src); }\n-  void vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);\n+  void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister    src) { Assembler::vdivsd(dst, nds, src); }\n+  void vdivsd(XMMRegister dst, XMMRegister nds, Address        src) { Assembler::vdivsd(dst, nds, src); }\n+  void vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch = noreg);\n@@ -1568,3 +1604,3 @@\n-  void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivss(dst, nds, src); }\n-  void vdivss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivss(dst, nds, src); }\n-  void vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src);\n+  void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister    src) { Assembler::vdivss(dst, nds, src); }\n+  void vdivss(XMMRegister dst, XMMRegister nds, Address        src) { Assembler::vdivss(dst, nds, src); }\n+  void vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch = noreg);\n@@ -1572,3 +1608,3 @@\n-  void vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulsd(dst, nds, src); }\n-  void vmulsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulsd(dst, nds, src); }\n-  void vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);\n+  void vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister    src) { Assembler::vmulsd(dst, nds, src); }\n+  void vmulsd(XMMRegister dst, XMMRegister nds, Address        src) { Assembler::vmulsd(dst, nds, src); }\n+  void vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch = noreg);\n@@ -1576,3 +1612,3 @@\n-  void vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulss(dst, nds, src); }\n-  void vmulss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulss(dst, nds, src); }\n-  void vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src);\n+  void vmulss(XMMRegister dst, XMMRegister nds, XMMRegister    src) { Assembler::vmulss(dst, nds, src); }\n+  void vmulss(XMMRegister dst, XMMRegister nds, Address        src) { Assembler::vmulss(dst, nds, src); }\n+  void vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch = noreg);\n@@ -1580,3 +1616,3 @@\n-  void vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubsd(dst, nds, src); }\n-  void vsubsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubsd(dst, nds, src); }\n-  void vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);\n+  void vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister    src) { Assembler::vsubsd(dst, nds, src); }\n+  void vsubsd(XMMRegister dst, XMMRegister nds, Address        src) { Assembler::vsubsd(dst, nds, src); }\n+  void vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch = noreg);\n@@ -1584,3 +1620,3 @@\n-  void vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubss(dst, nds, src); }\n-  void vsubss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubss(dst, nds, src); }\n-  void vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src);\n+  void vsubss(XMMRegister dst, XMMRegister nds, XMMRegister    src) { Assembler::vsubss(dst, nds, src); }\n+  void vsubss(XMMRegister dst, XMMRegister nds, Address        src) { Assembler::vsubss(dst, nds, src); }\n+  void vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch = noreg);\n@@ -1588,2 +1624,2 @@\n-  void vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src);\n-  void vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src);\n+  void vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch = noreg);\n+  void vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src, Register rscratch = noreg);\n@@ -1593,3 +1629,3 @@\n-  void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }\n-  void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }\n-  void vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);\n+  void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister    src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }\n+  void vxorpd(XMMRegister dst, XMMRegister nds, Address        src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }\n+  void vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1597,3 +1633,3 @@\n-  void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }\n-  void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }\n-  void vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);\n+  void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister    src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }\n+  void vxorps(XMMRegister dst, XMMRegister nds, Address        src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }\n+  void vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1613,1 +1649,1 @@\n-  void vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);\n+  void vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1625,2 +1661,2 @@\n-  void vpermd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpermd(dst, nds, src, vector_len); }\n-  void vpermd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg);\n+  void vpermd(XMMRegister dst, XMMRegister nds, XMMRegister    src, int vector_len) { Assembler::vpermd(dst, nds, src, vector_len); }\n+  void vpermd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n@@ -1868,1 +1904,1 @@\n-  void movoop(Address dst, jobject obj);\n+  void movoop(Address  dst, jobject obj, Register rscratch);\n@@ -1871,19 +1907,11 @@\n-  void mov_metadata(Address dst, Metadata* obj);\n-\n-  void movptr(ArrayAddress dst, Register src);\n-  \/\/ can this do an lea?\n-  void movptr(Register dst, ArrayAddress src);\n-\n-  void movptr(Register dst, Address src);\n-\n-#ifdef _LP64\n-  void movptr(Register dst, AddressLiteral src, Register scratch=rscratch1);\n-#else\n-  void movptr(Register dst, AddressLiteral src, Register scratch=noreg); \/\/ Scratch reg is ignored in 32-bit\n-#endif\n-\n-  void movptr(Register dst, intptr_t src);\n-  void movptr(Register dst, Register src);\n-  void movptr(Address dst, intptr_t src);\n-\n-  void movptr(Address dst, Register src);\n+  void mov_metadata(Address  dst, Metadata* obj, Register rscratch);\n+\n+  void movptr(Register     dst, Register       src);\n+  void movptr(Register     dst, Address        src);\n+  void movptr(Register     dst, AddressLiteral src);\n+  void movptr(Register     dst, ArrayAddress   src);\n+  void movptr(Register     dst, intptr_t       src);\n+  void movptr(Address      dst, Register       src);\n+  void movptr(Address      dst, int32_t        imm);\n+  void movptr(Address      dst, intptr_t       src, Register rscratch);\n+  void movptr(ArrayAddress dst, Register       src, Register rscratch);\n@@ -1896,11 +1924,0 @@\n-#ifdef _LP64\n-  \/\/ Generally the next two are only used for moving NULL\n-  \/\/ Although there are situations in initializing the mark word where\n-  \/\/ they could be used. They are dangerous.\n-\n-  \/\/ They only exist on LP64 so that int32_t and intptr_t are not the same\n-  \/\/ and we have ambiguous declarations.\n-\n-  void movptr(Address dst, int32_t imm32);\n-  void movptr(Register dst, int32_t imm32);\n-#endif \/\/ _LP64\n@@ -1909,5 +1926,2 @@\n-  void mov32(AddressLiteral dst, Register src);\n-  void mov32(Register dst, AddressLiteral src);\n-\n-  \/\/ to avoid hiding movb\n-  void movbyte(ArrayAddress dst, int src);\n+  void mov32(Register       dst, AddressLiteral src);\n+  void mov32(AddressLiteral dst, Register        src, Register rscratch = noreg);\n@@ -1918,0 +1932,2 @@\n+  void movdl(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n+\n@@ -1919,2 +1935,1 @@\n-  void movdl(XMMRegister dst, AddressLiteral src);\n-  void movq(XMMRegister dst, AddressLiteral src);\n+  void movq(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n@@ -1923,1 +1938,1 @@\n-  void pushptr(AddressLiteral src);\n+  void pushptr(AddressLiteral src, Register rscratch);\n@@ -1928,2 +1943,2 @@\n-  void pushoop(jobject obj);\n-  void pushklass(Metadata* obj);\n+  void pushoop(jobject obj, Register rscratch);\n+  void pushklass(Metadata* obj, Register rscratch);\n@@ -2143,0 +2158,4 @@\n+  OopMap* continuation_enter_setup(int& stack_slots);\n+  void fill_continuation_entry(Register reg_cont_obj, Register reg_flags);\n+  void continuation_enter_cleanup();\n+\n@@ -2146,0 +2165,3 @@\n+\n+  void check_stack_alignment(Register sp, const char* msg, unsigned bias = 0, Register tmp = noreg);\n+\n@@ -2162,1 +2184,1 @@\n-   SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);\n+   SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value, Register rscratch);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":337,"deletions":315,"binary":false,"changes":652,"status":"modified"},{"patch":"@@ -81,2 +81,0 @@\n-  Register temp2 = noreg;\n-  LP64_ONLY(temp2 = rscratch1);  \/\/ used by MacroAssembler::cmpptr and load_klass\n@@ -88,4 +86,5 @@\n-  __ push(temp); if (temp2 != noreg)  __ push(temp2);\n-#define UNPUSH { if (temp2 != noreg)  __ pop(temp2);  __ pop(temp); }\n-  __ load_klass(temp, obj, temp2);\n-  __ cmpptr(temp, ExternalAddress((address) klass_addr));\n+#define PUSH { __ push(temp); LP64_ONLY(  __ push(rscratch1); )               }\n+#define POP  {                LP64_ONLY(  __ pop(rscratch1);  ) __ pop(temp); }\n+  PUSH;\n+  __ load_klass(temp, obj, rscratch1);\n+  __ cmpptr(temp, ExternalAddress((address) klass_addr), rscratch1);\n@@ -95,1 +94,1 @@\n-  __ cmpptr(temp, ExternalAddress((address) klass_addr));\n+  __ cmpptr(temp, ExternalAddress((address) klass_addr), rscratch1);\n@@ -97,1 +96,1 @@\n-  UNPUSH;\n+  POP;\n@@ -101,1 +100,1 @@\n-  UNPUSH;\n+  POP;\n@@ -103,0 +102,2 @@\n+#undef POP\n+#undef PUSH\n@@ -538,1 +539,1 @@\n-    const int saved_regs_count = RegisterImpl::number_of_registers;\n+    const int saved_regs_count = Register::number_of_registers;\n@@ -543,1 +544,1 @@\n-      assert(RegisterImpl::number_of_registers == 16, \"sanity\");\n+      assert(Register::number_of_registers == 16, \"sanity\");\n@@ -679,1 +680,1 @@\n-  __ movptr(Address(rsp, 0), (intptr_t) adaptername);\n+  __ movptr(Address(rsp, 0), (intptr_t) adaptername, rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::number_of_registers;\n+  int num_xmm_regs = XMMRegister::number_of_registers;\n@@ -135,1 +135,1 @@\n-  int opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n+  int opmask_state_bytes = KRegister::number_of_registers * 8;\n@@ -202,1 +202,1 @@\n-  for (int n = 0; n < FloatRegisterImpl::number_of_registers; n++) {\n+  for (int n = 0; n < FloatRegister::number_of_registers; n++) {\n@@ -238,1 +238,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -271,1 +271,1 @@\n-  for (int n = 0; n < FloatRegisterImpl::number_of_registers; n++) {\n+  for (int n = 0; n < FloatRegister::number_of_registers; n++) {\n@@ -294,1 +294,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::number_of_registers;\n+  int num_xmm_regs = XMMRegister::number_of_registers;\n@@ -307,1 +307,1 @@\n-      opmask_state_bytes = KRegisterImpl::number_of_registers * 8;\n+      opmask_state_bytes = KRegister::number_of_registers * 8;\n@@ -348,1 +348,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -415,2 +415,2 @@\n-\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register\n-\/\/ up to RegisterImpl::number_of_registers) are the 32-bit\n+\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.\n+\/\/ Register up to Register::number_of_registers are the 32-bit\n@@ -548,1 +548,1 @@\n-  __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), NULL_WORD);\n@@ -999,1 +999,1 @@\n-    __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), NULL_WORD);\n@@ -1116,1 +1116,1 @@\n-    __ cmpptr(Address(rbp, reg2offset_in(src.first())), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(rbp, reg2offset_in(src.first())), NULL_WORD);\n@@ -1138,1 +1138,1 @@\n-    __ cmpptr(rOop, (int32_t)NULL_WORD);\n+    __ cmpptr(rOop, NULL_WORD);\n@@ -1681,1 +1681,1 @@\n-  __ set_last_Java_frame(thread, rsp, noreg, (address)the_pc);\n+  __ set_last_Java_frame(thread, rsp, noreg, (address)the_pc, noreg);\n@@ -1688,1 +1688,1 @@\n-    SkipIfEqual skip_if(masm, &DTraceMethodProbes, 0);\n+    SkipIfEqual skip_if(masm, &DTraceMethodProbes, 0, noreg);\n@@ -1781,1 +1781,1 @@\n-  __ restore_cpu_control_state_after_jni();\n+  __ restore_cpu_control_state_after_jni(noreg);\n@@ -1885,1 +1885,1 @@\n-      __ cmpptr(Address(rbp, lock_slot_rbp_offset), (int32_t)NULL_WORD);\n+      __ cmpptr(Address(rbp, lock_slot_rbp_offset), NULL_WORD);\n@@ -1925,1 +1925,1 @@\n-    SkipIfEqual skip_if(masm, &DTraceMethodProbes, 0);\n+    SkipIfEqual skip_if(masm, &DTraceMethodProbes, 0, noreg);\n@@ -1956,1 +1956,1 @@\n-  __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2003,1 +2003,1 @@\n-    __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int)NULL_WORD);\n+    __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2040,1 +2040,1 @@\n-      __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n+      __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2255,1 +2255,1 @@\n-  __ set_last_Java_frame(rcx, noreg, noreg, NULL);\n+  __ set_last_Java_frame(rcx, noreg, noreg, NULL, noreg);\n@@ -2403,1 +2403,1 @@\n-  __ set_last_Java_frame(rcx, noreg, rbp, NULL);\n+  __ set_last_Java_frame(rcx, noreg, rbp, NULL, noreg);\n@@ -2500,1 +2500,1 @@\n-  __ set_last_Java_frame(rdx, noreg, noreg, NULL);\n+  __ set_last_Java_frame(rdx, noreg, noreg, NULL, noreg);\n@@ -2612,1 +2612,1 @@\n-  __ set_last_Java_frame(rdi, noreg, rbp, NULL);\n+  __ set_last_Java_frame(rdi, noreg, rbp, NULL, noreg);\n@@ -2694,1 +2694,1 @@\n-  __ set_last_Java_frame(java_thread, noreg, noreg, NULL);\n+  __ set_last_Java_frame(java_thread, noreg, noreg, NULL, noreg);\n@@ -2724,1 +2724,1 @@\n-  __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -2833,1 +2833,1 @@\n-  __ set_last_Java_frame(thread, noreg, rbp, NULL);\n+  __ set_last_Java_frame(thread, noreg, rbp, NULL, noreg);\n@@ -2852,1 +2852,1 @@\n-  __ cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -175,4 +176,0 @@\n-\/\/ Register is a class, but it would be assigned numerical value.\n-\/\/ \"0\" is assigned for rax. Thus we need to ignore -Wnonnull.\n-PRAGMA_DIAG_PUSH\n-PRAGMA_NONNULL_IGNORED\n@@ -181,1 +178,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::available_xmm_registers();\n+  int num_xmm_regs = XMMRegister::available_xmm_registers();\n@@ -231,1 +228,1 @@\n-      for(int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for(int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -248,1 +245,1 @@\n-      for(int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for(int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -369,1 +366,0 @@\n-PRAGMA_DIAG_POP\n@@ -372,1 +368,1 @@\n-  int num_xmm_regs = XMMRegisterImpl::available_xmm_registers();\n+  int num_xmm_regs = XMMRegister::available_xmm_registers();\n@@ -412,1 +408,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -429,1 +425,1 @@\n-      for (int n = 0; n < KRegisterImpl::number_of_registers; n++) {\n+      for (int n = 0; n < KRegister::number_of_registers; n++) {\n@@ -473,2 +469,2 @@\n-\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register\n-\/\/ up to RegisterImpl::number_of_registers) are the 64-bit\n+\/\/ and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.\n+\/\/ Register up to Register::number_of_registers are the 64-bit\n@@ -650,1 +646,1 @@\n-  __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), NULL_WORD);\n@@ -828,1 +824,1 @@\n-      __ set_last_Java_frame(noreg, noreg, NULL);\n+      __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n@@ -841,1 +837,1 @@\n-      __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+      __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -844,1 +840,1 @@\n-      __ movptr(Address(r15_thread, JavaThread::vm_result_offset()), (int)NULL_WORD);\n+      __ movptr(Address(r15_thread, JavaThread::vm_result_offset()), NULL_WORD);\n@@ -857,3 +853,0 @@\n-  \/\/ Interpreter::stackElementSize is the space we need. Plus 1 because\n-  \/\/ we also account for the return address location since\n-  \/\/ we store it first rather than hold it in rax across all the shuffling\n@@ -861,1 +854,4 @@\n-  int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;\n+  assert(total_args_passed >= 0, \"total_args_passed is %d\", total_args_passed);\n+  \/\/ Interpreter::stackElementSize is the space we need.\n+\n+  int extraspace = (total_args_passed * Interpreter::stackElementSize);\n@@ -864,0 +860,2 @@\n+  \/\/ This is not currently needed or enforced by the interpreter, but\n+  \/\/ we might as well conform to the ABI.\n@@ -866,4 +864,8 @@\n-  \/\/ Get return address\n-  __ pop(rax);\n-\n-  __ mov(r13, rsp);\n+  __ lea(r13, Address(rsp, wordSize));\n+\n+#ifdef ASSERT\n+  __ check_stack_alignment(r13, \"sender stack not aligned\");\n+#endif\n+  if (extraspace > 0) {\n+    \/\/ Pop the return address\n+    __ pop(rax);\n@@ -872,1 +874,1 @@\n-  __ subptr(rsp, extraspace);\n+    __ subptr(rsp, extraspace);\n@@ -874,2 +876,11 @@\n-  \/\/ Store the return address in the expected location\n-  __ movptr(Address(rsp, 0), rax);\n+    \/\/ Push the return address\n+    __ push(rax);\n+\n+    \/\/ Account for the return address location since we store it first rather\n+    \/\/ than hold it in a register across all the shuffling\n+    extraspace += wordSize;\n+  }\n+\n+#ifdef ASSERT\n+  __ check_stack_alignment(rsp, \"callee stack not aligned\", wordSize, rax);\n+#endif\n@@ -1016,3 +1027,0 @@\n-  \/\/ Pick up the return address\n-  __ movptr(rax, Address(rsp, 0));\n-\n@@ -1026,0 +1034,2 @@\n+    \/\/ Pick up the return address\n+    __ movptr(rax, Address(rsp, 0));\n@@ -1050,3 +1060,6 @@\n-  \/\/ Cut-out for having no stack args.  Since up to 2 int\/oop args are passed\n-  \/\/ in registers, we will occasionally have no stack args.\n-  int comp_words_on_stack = 0;\n+  \/\/ Pick up the return address\n+  __ pop(rax);\n+\n+  \/\/ Convert 4-byte c2 stack slots to words.\n+  int comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)>>LogBytesPerWord;\n+\n@@ -1054,8 +1067,0 @@\n-    \/\/ Sig words on the stack are greater-than VMRegImpl::stack0.  Those in\n-    \/\/ registers are below.  By subtracting stack0, we either get a negative\n-    \/\/ number (all values in registers) or the maximum stack slot accessed.\n-\n-    \/\/ Convert 4-byte c2 stack slots to words.\n-    comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)>>LogBytesPerWord;\n-    \/\/ Round up to miminum stack alignment, in wordSize\n-    comp_words_on_stack = align_up(comp_words_on_stack, 2);\n@@ -1065,1 +1070,0 @@\n-\n@@ -1217,1 +1221,1 @@\n-  __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), NULL_WORD);\n@@ -1272,1 +1276,1 @@\n-      Register flags  = rscratch1;\n+      Register flags = rscratch1;\n@@ -1536,5 +1540,0 @@\n-\/\/ defined in stubGenerator_x86_64.cpp\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots);\n-void fill_continuation_entry(MacroAssembler* masm, Register reg_cont_obj, Register reg_flags);\n-void continuation_enter_cleanup(MacroAssembler* masm);\n-\n@@ -1609,1 +1608,1 @@\n-    OopMap* map = continuation_enter_setup(masm, stack_slots);\n+    OopMap* map = __ continuation_enter_setup(stack_slots);\n@@ -1615,1 +1614,1 @@\n-    fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+    __ fill_continuation_entry(reg_cont_obj, reg_is_virtual);\n@@ -1644,1 +1643,1 @@\n-  OopMap* map = continuation_enter_setup(masm, stack_slots);\n+  OopMap* map = __ continuation_enter_setup(stack_slots);\n@@ -1651,1 +1650,1 @@\n-  fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n+  __ fill_continuation_entry(reg_cont_obj, reg_is_virtual);\n@@ -1694,1 +1693,1 @@\n-  continuation_enter_cleanup(masm);\n+  __ continuation_enter_cleanup();\n@@ -1702,1 +1701,1 @@\n-  continuation_enter_cleanup(masm);\n+  __ continuation_enter_cleanup();\n@@ -1977,1 +1976,1 @@\n-  assert_different_registers(ic_reg, receiver, rscratch1);\n+  assert_different_registers(ic_reg, receiver, rscratch1, rscratch2);\n@@ -2037,9 +2036,1 @@\n-    {\n-      Label L;\n-      __ mov(rax, rsp);\n-      __ andptr(rax, -16); \/\/ must be 16 byte boundary (see amd64 ABI)\n-      __ cmpptr(rax, rsp);\n-      __ jcc(Assembler::equal, L);\n-      __ stop(\"improperly aligned stack\");\n-      __ bind(L);\n-    }\n+  __ check_stack_alignment(rsp, \"improperly aligned stack\");\n@@ -2090,3 +2081,3 @@\n-  bool reg_destroyed[RegisterImpl::number_of_registers];\n-  bool freg_destroyed[XMMRegisterImpl::number_of_registers];\n-  for ( int r = 0 ; r < RegisterImpl::number_of_registers ; r++ ) {\n+  bool reg_destroyed[Register::number_of_registers];\n+  bool freg_destroyed[XMMRegister::number_of_registers];\n+  for ( int r = 0 ; r < Register::number_of_registers ; r++ ) {\n@@ -2095,1 +2086,1 @@\n-  for ( int f = 0 ; f < XMMRegisterImpl::number_of_registers ; f++ ) {\n+  for ( int f = 0 ; f < XMMRegister::number_of_registers ; f++ ) {\n@@ -2195,1 +2186,1 @@\n-  __ set_last_Java_frame(rsp, noreg, (address)the_pc);\n+  __ set_last_Java_frame(rsp, noreg, (address)the_pc, rscratch1);\n@@ -2202,1 +2193,1 @@\n-    SkipIfEqual skip(masm, &DTraceMethodProbes, false);\n+    SkipIfEqual skip(masm, &DTraceMethodProbes, false, rscratch1);\n@@ -2308,1 +2299,1 @@\n-  __ restore_cpu_control_state_after_jni();\n+  __ restore_cpu_control_state_after_jni(rscratch1);\n@@ -2402,1 +2393,1 @@\n-      __ cmpptr(Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size), (int32_t)NULL_WORD);\n+      __ cmpptr(Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size), NULL_WORD);\n@@ -2438,1 +2429,1 @@\n-    SkipIfEqual skip(masm, &DTraceMethodProbes, false);\n+    SkipIfEqual skip(masm, &DTraceMethodProbes, false, rscratch1);\n@@ -2463,1 +2454,1 @@\n-  __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);\n+  __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);\n@@ -2470,1 +2461,1 @@\n-  __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2507,1 +2498,1 @@\n-    __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2538,1 +2529,1 @@\n-    __ movptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n+    __ movptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2547,1 +2538,1 @@\n-      __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int)NULL_WORD);\n+      __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);\n@@ -2705,1 +2696,1 @@\n-    __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())), (int32_t)NULL_WORD);\n+    __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())), NULL_WORD);\n@@ -2712,1 +2703,1 @@\n-    __ set_last_Java_frame(noreg, noreg, NULL);\n+    __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n@@ -2717,1 +2708,1 @@\n-    __ movl(r14, (int32_t)Deoptimization::Unpack_reexecute);\n+    __ movl(r14, Deoptimization::Unpack_reexecute);\n@@ -2769,1 +2760,1 @@\n-  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), NULL_WORD);\n@@ -2794,1 +2785,1 @@\n-  __ set_last_Java_frame(noreg, noreg, NULL);\n+  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n@@ -2797,3 +2788,1 @@\n-    __ cmpptr(Address(r15_thread,\n-                    JavaThread::last_Java_fp_offset()),\n-            (int32_t)0);\n+    __ cmpptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);\n@@ -2831,2 +2820,2 @@\n-  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), (int32_t)NULL_WORD);\n-  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), NULL_WORD);\n@@ -2914,1 +2903,1 @@\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD );\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -2944,1 +2933,1 @@\n-  __ set_last_Java_frame(noreg, rbp, the_pc);\n+  __ set_last_Java_frame(noreg, rbp, the_pc, rscratch1);\n@@ -3015,1 +3004,1 @@\n-  __ set_last_Java_frame(noreg, noreg, NULL);\n+  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n@@ -3044,1 +3033,1 @@\n-            (int32_t)Deoptimization::Unpack_uncommon_trap);\n+              Deoptimization::Unpack_uncommon_trap);\n@@ -3115,1 +3104,1 @@\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD );\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -3132,1 +3121,1 @@\n-  __ set_last_Java_frame(noreg, rbp, the_pc);\n+  __ set_last_Java_frame(noreg, rbp, the_pc, rscratch1);\n@@ -3209,1 +3198,1 @@\n-  __ set_last_Java_frame(noreg, noreg, NULL);  \/\/ JavaFrameAnchor::capture_last_Java_pc() will get the pc from the return address, which we store next:\n+  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);  \/\/ JavaFrameAnchor::capture_last_Java_pc() will get the pc from the return address, which we store next:\n@@ -3237,1 +3226,1 @@\n-  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -3345,1 +3334,1 @@\n-  MacroAssembler* masm                = new MacroAssembler(&buffer);\n+  MacroAssembler* masm = new MacroAssembler(&buffer);\n@@ -3359,1 +3348,1 @@\n-  __ set_last_Java_frame(noreg, noreg, NULL);\n+  __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n@@ -3378,1 +3367,1 @@\n-  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -3401,1 +3390,1 @@\n-  __ movptr(Address(r15_thread, JavaThread::vm_result_offset()), (int)NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::vm_result_offset()), NULL_WORD);\n@@ -3755,1 +3744,1 @@\n-  __ set_last_Java_frame(noreg, noreg, the_pc);\n+  __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);\n@@ -3793,2 +3782,2 @@\n-  __ movptr(Address(r15_thread, JavaThread::exception_handler_pc_offset()), (int)NULL_WORD);\n-  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), (int)NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_handler_pc_offset()), NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_pc_offset()), NULL_WORD);\n@@ -3797,1 +3786,1 @@\n-  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), (int)NULL_WORD);\n+  __ movptr(Address(r15_thread, JavaThread::exception_oop_offset()), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":95,"deletions":106,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -87,4 +87,0 @@\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots);\n-void fill_continuation_entry(MacroAssembler* masm);\n-void continuation_enter_cleanup(MacroAssembler* masm);\n-\n@@ -97,1 +93,1 @@\n-#define inc_counter_np(counter) ((void)0)\n+#define INC_COUNTER_NP(counter, rscratch) ((void)0)\n@@ -99,3 +95,2 @@\n-  void inc_counter_np_(int& counter) {\n-    \/\/ This can destroy rscratch1 if counter is far from the code cache\n-    __ incrementl(ExternalAddress((address)&counter));\n+  void inc_counter_np(int& counter, Register rscratch) {\n+    __ incrementl(ExternalAddress((address)&counter), rscratch);\n@@ -103,1 +98,1 @@\n-#define inc_counter_np(counter) \\\n+#define INC_COUNTER_NP(counter, rscratch) \\\n@@ -105,1 +100,1 @@\n-  inc_counter_np_(counter);\n+  inc_counter_np(counter, rscratch);\n@@ -309,1 +304,1 @@\n-      __ cmp32(rax, mxcsr_std);\n+      __ cmp32(rax, mxcsr_std, rscratch1);\n@@ -311,1 +306,1 @@\n-      __ ldmxcsr(mxcsr_std);\n+      __ ldmxcsr(mxcsr_std, rscratch1);\n@@ -324,1 +319,1 @@\n-      __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+      __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -552,1 +547,1 @@\n-      __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t) NULL);\n+      __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -570,1 +565,1 @@\n-    __ movptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+    __ movptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -644,1 +639,1 @@\n-      __ cmp32(rax, mxcsr_std);\n+      __ cmp32(rax, mxcsr_std, rscratch1);\n@@ -649,1 +644,1 @@\n-      __ ldmxcsr(mxcsr_std);\n+      __ ldmxcsr(mxcsr_std, rscratch1);\n@@ -1065,1 +1060,1 @@\n-    __ incrementl(ExternalAddress((address) StubRoutines::verify_oop_count_addr()));\n+    __ incrementl(ExternalAddress((address) StubRoutines::verify_oop_count_addr()), rscratch1);\n@@ -1697,1 +1692,1 @@\n-    inc_counter_np(get_profile_ctr(shift)); \/\/ Update counter after rscratch1 is free\n+    INC_COUNTER_NP(get_profile_ctr(shift), rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -1872,1 +1867,1 @@\n-    inc_counter_np(get_profile_ctr(shift)); \/\/ Update counter after rscratch1 is free\n+    INC_COUNTER_NP(get_profile_ctr(shift), rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -1986,1 +1981,1 @@\n-    inc_counter_np(SharedRuntime::_jbyte_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n+    INC_COUNTER_NP(SharedRuntime::_jbyte_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2087,1 +2082,1 @@\n-    inc_counter_np(SharedRuntime::_jbyte_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n+    INC_COUNTER_NP(SharedRuntime::_jbyte_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2100,1 +2095,1 @@\n-    inc_counter_np(SharedRuntime::_jbyte_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n+    INC_COUNTER_NP(SharedRuntime::_jbyte_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2206,1 +2201,1 @@\n-    inc_counter_np(SharedRuntime::_jshort_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n+    INC_COUNTER_NP(SharedRuntime::_jshort_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2322,1 +2317,1 @@\n-    inc_counter_np(SharedRuntime::_jshort_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n+    INC_COUNTER_NP(SharedRuntime::_jshort_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2335,1 +2330,1 @@\n-    inc_counter_np(SharedRuntime::_jshort_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n+    INC_COUNTER_NP(SharedRuntime::_jshort_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2442,1 +2437,1 @@\n-    inc_counter_np(SharedRuntime::_jint_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n+    INC_COUNTER_NP(SharedRuntime::_jint_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2547,1 +2542,1 @@\n-    inc_counter_np(SharedRuntime::_jint_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n+    INC_COUNTER_NP(SharedRuntime::_jint_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2563,1 +2558,1 @@\n-    inc_counter_np(SharedRuntime::_jint_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n+    INC_COUNTER_NP(SharedRuntime::_jint_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2655,1 +2650,1 @@\n-      inc_counter_np(SharedRuntime::_jlong_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n+      INC_COUNTER_NP(SharedRuntime::_jlong_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2672,5 +2667,3 @@\n-    if (is_oop) {\n-      inc_counter_np(SharedRuntime::_oop_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n-    } else {\n-      inc_counter_np(SharedRuntime::_jlong_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n-    }\n+    INC_COUNTER_NP(is_oop ? SharedRuntime::_oop_array_copy_ctr :\n+                            SharedRuntime::_jlong_array_copy_ctr,\n+                   rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2757,1 +2750,1 @@\n-      inc_counter_np(SharedRuntime::_jlong_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n+      INC_COUNTER_NP(SharedRuntime::_jlong_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2773,5 +2766,3 @@\n-    if (is_oop) {\n-      inc_counter_np(SharedRuntime::_oop_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n-    } else {\n-      inc_counter_np(SharedRuntime::_jlong_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n-    }\n+    INC_COUNTER_NP(is_oop ? SharedRuntime::_oop_array_copy_ctr :\n+                            SharedRuntime::_jlong_array_copy_ctr,\n+                   rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -2997,1 +2988,1 @@\n-    inc_counter_np(SharedRuntime::_checkcast_array_copy_ctr); \/\/ Update counter after rscratch1 is free\n+    INC_COUNTER_NP(SharedRuntime::_checkcast_array_copy_ctr, rscratch1); \/\/ Update counter after rscratch1 is free\n@@ -3038,1 +3029,1 @@\n-    inc_counter_np(SharedRuntime::_unsafe_array_copy_ctr);\n+    INC_COUNTER_NP(SharedRuntime::_unsafe_array_copy_ctr, rscratch1);\n@@ -3161,1 +3152,1 @@\n-    inc_counter_np(SharedRuntime::_generic_array_copy_ctr);\n+    INC_COUNTER_NP(SharedRuntime::_generic_array_copy_ctr, rscratch1);\n@@ -3613,1 +3604,1 @@\n-  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask=NULL) {\n+  void load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n@@ -3615,1 +3606,1 @@\n-    if (xmm_shuf_mask != NULL) {\n+    if (xmm_shuf_mask != xnoreg) {\n@@ -5021,9 +5012,6 @@\n-  void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = NULL) {\n-    __ movdqu(xmmdst, Address(key, offset));\n-    if (xmm_shuf_mask != NULL) {\n-      __ pshufb(xmmdst, xmm_shuf_mask);\n-    } else {\n-      __ pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n-    }\n-    __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n-\n+void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask = xnoreg) {\n+  __ movdqu(xmmdst, Address(key, offset));\n+  if (xmm_shuf_mask != xnoreg) {\n+    __ pshufb(xmmdst, xmm_shuf_mask);\n+  } else {\n+    __ pshufb(xmmdst, ExternalAddress(StubRoutines::x86::key_shuffle_mask_addr()));\n@@ -5031,0 +5019,3 @@\n+  __ evshufi64x2(xmmdst, xmmdst, xmmdst, 0x0, Assembler::AVX_512bit);\n+\n+}\n@@ -7310,12 +7301,0 @@\n-    const XMMRegister x0  = xmm0;\n-    const XMMRegister x1  = xmm1;\n-    const XMMRegister x2  = xmm2;\n-    const XMMRegister x3  = xmm3;\n-\n-    const XMMRegister x4  = xmm4;\n-    const XMMRegister x5  = xmm5;\n-    const XMMRegister x6  = xmm6;\n-    const XMMRegister x7  = xmm7;\n-\n-    const Register tmp   = r11;\n-\n@@ -7325,1 +7304,2 @@\n-    __ fast_exp(x0, x1, x2, x3, x4, x5, x6, x7, rax, rcx, rdx, tmp);\n+    __ fast_exp(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n+                rax, rcx, rdx, r11);\n@@ -7339,13 +7319,0 @@\n-    const XMMRegister x0 = xmm0;\n-    const XMMRegister x1 = xmm1;\n-    const XMMRegister x2 = xmm2;\n-    const XMMRegister x3 = xmm3;\n-\n-    const XMMRegister x4 = xmm4;\n-    const XMMRegister x5 = xmm5;\n-    const XMMRegister x6 = xmm6;\n-    const XMMRegister x7 = xmm7;\n-\n-    const Register tmp1 = r11;\n-    const Register tmp2 = r8;\n-\n@@ -7355,1 +7322,2 @@\n-    __ fast_log(x0, x1, x2, x3, x4, x5, x6, x7, rax, rcx, rdx, tmp1, tmp2);\n+    __ fast_log(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n+                rax, rcx, rdx, r11, r8);\n@@ -7369,12 +7337,0 @@\n-    const XMMRegister x0 = xmm0;\n-    const XMMRegister x1 = xmm1;\n-    const XMMRegister x2 = xmm2;\n-    const XMMRegister x3 = xmm3;\n-\n-    const XMMRegister x4 = xmm4;\n-    const XMMRegister x5 = xmm5;\n-    const XMMRegister x6 = xmm6;\n-    const XMMRegister x7 = xmm7;\n-\n-    const Register tmp = r11;\n-\n@@ -7384,1 +7340,2 @@\n-    __ fast_log10(x0, x1, x2, x3, x4, x5, x6, x7, rax, rcx, rdx, tmp);\n+    __ fast_log10(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n+                  rax, rcx, rdx, r11, r8);\n@@ -7398,15 +7355,0 @@\n-    const XMMRegister x0 = xmm0;\n-    const XMMRegister x1 = xmm1;\n-    const XMMRegister x2 = xmm2;\n-    const XMMRegister x3 = xmm3;\n-\n-    const XMMRegister x4 = xmm4;\n-    const XMMRegister x5 = xmm5;\n-    const XMMRegister x6 = xmm6;\n-    const XMMRegister x7 = xmm7;\n-\n-    const Register tmp1 = r8;\n-    const Register tmp2 = r9;\n-    const Register tmp3 = r10;\n-    const Register tmp4 = r11;\n-\n@@ -7416,1 +7358,2 @@\n-    __ fast_pow(x0, x1, x2, x3, x4, x5, x6, x7, rax, rcx, rdx, tmp1, tmp2, tmp3, tmp4);\n+    __ fast_pow(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n+                rax, rcx, rdx, r8, r9, r10, r11);\n@@ -7430,15 +7373,0 @@\n-    const XMMRegister x0 = xmm0;\n-    const XMMRegister x1 = xmm1;\n-    const XMMRegister x2 = xmm2;\n-    const XMMRegister x3 = xmm3;\n-\n-    const XMMRegister x4 = xmm4;\n-    const XMMRegister x5 = xmm5;\n-    const XMMRegister x6 = xmm6;\n-    const XMMRegister x7 = xmm7;\n-\n-    const Register tmp1 = r8;\n-    const Register tmp2 = r9;\n-    const Register tmp3 = r10;\n-    const Register tmp4 = r11;\n-\n@@ -7452,2 +7380,2 @@\n-    __ fast_sin(x0, x1, x2, x3, x4, x5, x6, x7, rax, rbx, rcx, rdx, tmp1, tmp2, tmp3, tmp4);\n-\n+    __ fast_sin(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n+                rax, rbx, rcx, rdx, r8);\n@@ -7471,15 +7399,0 @@\n-    const XMMRegister x0 = xmm0;\n-    const XMMRegister x1 = xmm1;\n-    const XMMRegister x2 = xmm2;\n-    const XMMRegister x3 = xmm3;\n-\n-    const XMMRegister x4 = xmm4;\n-    const XMMRegister x5 = xmm5;\n-    const XMMRegister x6 = xmm6;\n-    const XMMRegister x7 = xmm7;\n-\n-    const Register tmp1 = r8;\n-    const Register tmp2 = r9;\n-    const Register tmp3 = r10;\n-    const Register tmp4 = r11;\n-\n@@ -7493,1 +7406,2 @@\n-    __ fast_cos(x0, x1, x2, x3, x4, x5, x6, x7, rax, rcx, rdx, tmp1, tmp2, tmp3, tmp4);\n+    __ fast_cos(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n+                rax, rcx, rdx, r8, r9, r10, r11, rbx);\n@@ -7512,15 +7426,0 @@\n-    const XMMRegister x0 = xmm0;\n-    const XMMRegister x1 = xmm1;\n-    const XMMRegister x2 = xmm2;\n-    const XMMRegister x3 = xmm3;\n-\n-    const XMMRegister x4 = xmm4;\n-    const XMMRegister x5 = xmm5;\n-    const XMMRegister x6 = xmm6;\n-    const XMMRegister x7 = xmm7;\n-\n-    const Register tmp1 = r8;\n-    const Register tmp2 = r9;\n-    const Register tmp3 = r10;\n-    const Register tmp4 = r11;\n-\n@@ -7534,1 +7433,2 @@\n-    __ fast_tan(x0, x1, x2, x3, x4, x5, x6, x7, rax, rcx, rdx, tmp1, tmp2, tmp3, tmp4);\n+    __ fast_tan(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7,\n+                rax, rcx, rdx, r8, r9, r10, r11, rbx);\n@@ -7576,1 +7476,1 @@\n-    __ set_last_Java_frame(rsp, rbp, the_pc);\n+    __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n@@ -7588,1 +7488,1 @@\n-    continuation_enter_cleanup(_masm);\n+    __ continuation_enter_cleanup();\n@@ -7768,1 +7668,1 @@\n-    __ set_last_Java_frame(rsp, rbp, the_pc);\n+    __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n@@ -7861,1 +7761,1 @@\n-    __ set_last_Java_frame(rsp, rbp, the_pc);\n+    __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n@@ -7888,2 +7788,1 @@\n-    __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()),\n-            (int32_t) NULL_WORD);\n+    __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -7998,1 +7897,1 @@\n-    __ set_last_Java_frame(noreg, noreg, NULL);\n+    __ set_last_Java_frame(noreg, noreg, NULL, rscratch1);\n@@ -8130,18 +8029,0 @@\n-      if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dsin) ||\n-          vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcos) ||\n-          vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtan)) {\n-        StubRoutines::x86::_ONEHALF_adr = (address)StubRoutines::x86::_ONEHALF;\n-        StubRoutines::x86::_P_2_adr = (address)StubRoutines::x86::_P_2;\n-        StubRoutines::x86::_SC_4_adr = (address)StubRoutines::x86::_SC_4;\n-        StubRoutines::x86::_Ctable_adr = (address)StubRoutines::x86::_Ctable;\n-        StubRoutines::x86::_SC_2_adr = (address)StubRoutines::x86::_SC_2;\n-        StubRoutines::x86::_SC_3_adr = (address)StubRoutines::x86::_SC_3;\n-        StubRoutines::x86::_SC_1_adr = (address)StubRoutines::x86::_SC_1;\n-        StubRoutines::x86::_PI_INV_TABLE_adr = (address)StubRoutines::x86::_PI_INV_TABLE;\n-        StubRoutines::x86::_PI_4_adr = (address)StubRoutines::x86::_PI_4;\n-        StubRoutines::x86::_PI32INV_adr = (address)StubRoutines::x86::_PI32INV;\n-        StubRoutines::x86::_SIGN_MASK_adr = (address)StubRoutines::x86::_SIGN_MASK;\n-        StubRoutines::x86::_P_1_adr = (address)StubRoutines::x86::_P_1;\n-        StubRoutines::x86::_P_3_adr = (address)StubRoutines::x86::_P_3;\n-        StubRoutines::x86::_NEG_ZERO_adr = (address)StubRoutines::x86::_NEG_ZERO;\n-      }\n@@ -8473,96 +8354,0 @@\n-#define __ masm->\n-\n-\/\/---------------------------- continuation_enter_setup ---------------------------\n-\/\/\n-\/\/ Arguments:\n-\/\/   None.\n-\/\/\n-\/\/ Results:\n-\/\/   rsp: pointer to blank ContinuationEntry\n-\/\/\n-\/\/ Kills:\n-\/\/   rax\n-\/\/\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots) {\n-  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n-  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n-  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n-\n-  stack_slots += checked_cast<int>(ContinuationEntry::size()) \/ wordSize;\n-  __ subptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n-\n-  int frame_size = (checked_cast<int>(ContinuationEntry::size()) + wordSize) \/ VMRegImpl::stack_slot_size;\n-  OopMap* map = new OopMap(frame_size, 0);\n-  ContinuationEntry::setup_oopmap(map);\n-\n-  __ movptr(rax, Address(r15_thread, JavaThread::cont_entry_offset()));\n-  __ movptr(Address(rsp, ContinuationEntry::parent_offset()), rax);\n-  __ movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rsp);\n-\n-  return map;\n-}\n-\n-\/\/---------------------------- fill_continuation_entry ---------------------------\n-\/\/\n-\/\/ Arguments:\n-\/\/   rsp: pointer to blank Continuation entry\n-\/\/   reg_cont_obj: pointer to the continuation\n-\/\/   reg_flags: flags\n-\/\/\n-\/\/ Results:\n-\/\/   rsp: pointer to filled out ContinuationEntry\n-\/\/\n-\/\/ Kills:\n-\/\/   rax\n-\/\/\n-void fill_continuation_entry(MacroAssembler* masm, Register reg_cont_obj, Register reg_flags) {\n-  assert_different_registers(rax, reg_cont_obj, reg_flags);\n-\n-  DEBUG_ONLY(__ movl(Address(rsp, ContinuationEntry::cookie_offset()), ContinuationEntry::cookie_value());)\n-\n-  __ movptr(Address(rsp, ContinuationEntry::cont_offset()), reg_cont_obj);\n-  __ movl  (Address(rsp, ContinuationEntry::flags_offset()), reg_flags);\n-  __ movptr(Address(rsp, ContinuationEntry::chunk_offset()), 0);\n-  __ movl(Address(rsp, ContinuationEntry::argsize_offset()), 0);\n-  __ movl(Address(rsp, ContinuationEntry::pin_count_offset()), 0);\n-\n-  __ movptr(rax, Address(r15_thread, JavaThread::cont_fastpath_offset()));\n-  __ movptr(Address(rsp, ContinuationEntry::parent_cont_fastpath_offset()), rax);\n-  __ movq(rax, Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-  __ movq(Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()), rax);\n-\n-  __ movptr(Address(r15_thread, JavaThread::cont_fastpath_offset()), 0);\n-  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), 0);\n-}\n-\n-\/\/---------------------------- continuation_enter_cleanup ---------------------------\n-\/\/\n-\/\/ Arguments:\n-\/\/   rsp: pointer to the ContinuationEntry\n-\/\/\n-\/\/ Results:\n-\/\/   rsp: pointer to the spilled rbp in the entry frame\n-\/\/\n-\/\/ Kills:\n-\/\/   rbx\n-\/\/\n-void continuation_enter_cleanup(MacroAssembler* masm) {\n-#ifdef ASSERT\n-  Label L_good_sp;\n-  __ cmpptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset()));\n-  __ jcc(Assembler::equal, L_good_sp);\n-  __ stop(\"Incorrect rsp at continuation_enter_cleanup\");\n-  __ bind(L_good_sp);\n-#endif\n-\n-  __ movptr(rbx, Address(rsp, ContinuationEntry::parent_cont_fastpath_offset()));\n-  __ movptr(Address(r15_thread, JavaThread::cont_fastpath_offset()), rbx);\n-  __ movq(rbx, Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), rbx);\n-\n-  __ movptr(rbx, Address(rsp, ContinuationEntry::parent_offset()));\n-  __ movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rbx);\n-  __ addptr(rsp, (int32_t)ContinuationEntry::size());\n-}\n-\n-#undef __\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":66,"deletions":281,"binary":false,"changes":347,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -262,1 +262,1 @@\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -296,1 +296,1 @@\n-    __ cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);\n+    __ cmpptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -518,1 +518,1 @@\n-  __ cmpptr(stack_limit, (int32_t)NULL_WORD);\n+  __ cmpptr(stack_limit, NULL_WORD);\n@@ -590,1 +590,1 @@\n-    __ load_mirror(rax, rbx);\n+    __ load_mirror(rax, rbx, rscratch2);\n@@ -629,1 +629,1 @@\n-  __ push((int)NULL_WORD); \/\/ leave last_sp as null\n+  __ push(NULL_WORD); \/\/ leave last_sp as null\n@@ -634,1 +634,1 @@\n-  __ load_mirror(rdx, rbx);\n+  __ load_mirror(rdx, rbx, rscratch2);\n@@ -760,1 +760,1 @@\n-  __ cmpptr(Address(thread, JavaThread::shadow_zone_safe_limit()), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(thread, JavaThread::shadow_zone_safe_limit()), NULL_WORD);\n@@ -766,1 +766,1 @@\n-  __ cmpptr(Address(thread, JavaThread::shadow_zone_growth_watermark()), (int32_t)NULL_WORD);\n+  __ cmpptr(Address(thread, JavaThread::shadow_zone_growth_watermark()), NULL_WORD);\n@@ -799,1 +799,1 @@\n-  bool inc_counter  = UseCompiler || CountCompiledCalls || LogTouchedMethods;\n+  bool inc_counter  = UseCompiler || CountCompiledCalls;\n@@ -832,1 +832,1 @@\n-  __ push((int) NULL_WORD);\n+  __ push(NULL_WORD);\n@@ -835,1 +835,1 @@\n-  __ push((int) NULL_WORD);\n+  __ push(NULL_WORD);\n@@ -1009,1 +1009,1 @@\n-    __ cmpptr(rax, unsatisfied.addr());\n+    __ cmpptr(rax, unsatisfied.addr(), rscratch1);\n@@ -1029,1 +1029,1 @@\n-   __ set_last_Java_frame(thread, noreg, rbp, __ pc());\n+   __ set_last_Java_frame(thread, noreg, rbp, __ pc(), noreg);\n@@ -1035,1 +1035,1 @@\n-   __ set_last_Java_frame(rsp, rbp, (address) __ pc());\n+   __ set_last_Java_frame(rsp, rbp, (address) __ pc(), rscratch1);\n@@ -1061,1 +1061,1 @@\n-  __ restore_cpu_control_state_after_jni();\n+  __ restore_cpu_control_state_after_jni(rscratch1);\n@@ -1084,1 +1084,1 @@\n-              float_handler.addr());\n+              float_handler.addr(), noreg);\n@@ -1087,1 +1087,1 @@\n-              double_handler.addr());\n+              double_handler.addr(), noreg);\n@@ -1165,1 +1165,1 @@\n-  __ movl(Address(t, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);\n+  __ movl(Address(t, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);\n@@ -1224,1 +1224,1 @@\n-    __ cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);\n+    __ cmpptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);\n@@ -1336,1 +1336,1 @@\n-  bool inc_counter  = UseCompiler || CountCompiledCalls || LogTouchedMethods;\n+  bool inc_counter  = UseCompiler || CountCompiledCalls;\n@@ -1381,1 +1381,1 @@\n-    __ push((int) NULL_WORD); \/\/ initialize local variables\n+    __ push(NULL_WORD); \/\/ initialize local variables\n@@ -1496,1 +1496,1 @@\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -1628,1 +1628,1 @@\n-  __ set_last_Java_frame(thread, noreg, rbp, __ pc());\n+  __ set_last_Java_frame(thread, noreg, rbp, __ pc(), noreg);\n@@ -1635,1 +1635,1 @@\n-  __ set_last_Java_frame(noreg, rbp, __ pc());\n+  __ set_last_Java_frame(noreg, rbp, __ pc(), rscratch1);\n@@ -1642,1 +1642,1 @@\n-  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), (int32_t)NULL_WORD);\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n@@ -1831,1 +1831,1 @@\n-  __ incrementl(ExternalAddress((address) &BytecodeCounter::_counter_value));\n+  __ incrementl(ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch1);\n@@ -1835,1 +1835,1 @@\n-  __ incrementl(ExternalAddress((address) &BytecodeHistogram::_counters[t->bytecode()]));\n+  __ incrementl(ExternalAddress((address) &BytecodeHistogram::_counters[t->bytecode()]), rscratch1);\n@@ -1844,1 +1844,1 @@\n-  __ mov32(ExternalAddress((address) &BytecodePairHistogram::_index), rbx);\n+  __ mov32(ExternalAddress((address) &BytecodePairHistogram::_index), rbx, rscratch1);\n@@ -1872,1 +1872,2 @@\n-           StopInterpreterAt);\n+           StopInterpreterAt,\n+           rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":31,"deletions":30,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-      __ movflt(xmm0, ExternalAddress((address) &one));\n+      __ movflt(xmm0, ExternalAddress((address) &one), rscratch1);\n@@ -297,1 +297,1 @@\n-      __ movflt(xmm0, ExternalAddress((address) &two));\n+      __ movflt(xmm0, ExternalAddress((address) &two), rscratch1);\n@@ -325,1 +325,1 @@\n-      __ movdbl(xmm0, ExternalAddress((address) &one));\n+      __ movdbl(xmm0, ExternalAddress((address) &one), rscratch1);\n@@ -452,1 +452,1 @@\n-    __ resolve_oop_handle(tmp);\n+    __ resolve_oop_handle(tmp, rscratch2);\n@@ -1156,2 +1156,1 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  __ load_klass(rdi, rdx, tmp_load_klass);\n+  __ load_klass(rdi, rdx, rscratch1);\n@@ -1164,1 +1163,1 @@\n-  __ load_klass(rbx, rax, tmp_load_klass);\n+  __ load_klass(rbx, rax, rscratch1);\n@@ -1213,1 +1212,1 @@\n-    __ load_klass(rbx, rax, tmp_load_klass);\n+    __ load_klass(rbx, rax, rscratch1);\n@@ -1253,2 +1252,1 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  __ load_klass(rcx, rdx, tmp_load_klass);\n+  __ load_klass(rcx, rdx, rscratch1);\n@@ -1625,1 +1623,1 @@\n-#else\n+#else \/\/ !_LP64\n@@ -1634,1 +1632,1 @@\n-#endif\n+#endif \/\/ _LP64\n@@ -1643,1 +1641,1 @@\n-#else\n+#else \/\/ !_LP64\n@@ -1688,1 +1686,1 @@\n-#else\n+#else \/\/ !_LP64\n@@ -1698,1 +1696,1 @@\n-#endif\n+#endif \/\/ _LP64\n@@ -1707,1 +1705,1 @@\n-#else\n+#else \/\/ !_LP64\n@@ -1736,1 +1734,1 @@\n-#endif\n+#endif \/\/ _LP64\n@@ -1770,1 +1768,1 @@\n-    __ xorps(xmm0, ExternalAddress((address) float_signflip));\n+    __ xorps(xmm0, ExternalAddress((address) float_signflip), rscratch1);\n@@ -1782,1 +1780,1 @@\n-    __ xorpd(xmm0, ExternalAddress((address) double_signflip));\n+    __ xorpd(xmm0, ExternalAddress((address) double_signflip), rscratch1);\n@@ -1903,1 +1901,1 @@\n-    __ cmp64(rax, ExternalAddress((address) &is_nan));\n+    __ cmp64(rax, ExternalAddress((address) &is_nan), rscratch1);\n@@ -1927,1 +1925,1 @@\n-    __ cmp64(rax, ExternalAddress((address) &is_nan));\n+    __ cmp64(rax, ExternalAddress((address) &is_nan), rscratch1);\n@@ -1939,1 +1937,1 @@\n-#else\n+#else \/\/ !_LP64\n@@ -2130,1 +2128,1 @@\n-#endif\n+#endif \/\/ _LP64\n@@ -2184,1 +2182,1 @@\n-#else\n+#else \/\/ !_LP64\n@@ -2693,2 +2691,1 @@\n-    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-    __ load_klass(rdi, robj, tmp_load_klass);\n+    __ load_klass(rdi, robj, rscratch1);\n@@ -2843,1 +2840,1 @@\n-    __ resolve_oop_handle(obj);\n+    __ resolve_oop_handle(obj, rscratch2);\n@@ -3977,3 +3974,6 @@\n-    LP64_ONLY(__ lea(rscratch1, table));\n-    LP64_ONLY(__ movptr(flags, Address(rscratch1, flags, Address::times_ptr)));\n-    NOT_LP64(__ movptr(flags, ArrayAddress(table, Address(noreg, flags, Address::times_ptr))));\n+#ifdef _LP64\n+    __ lea(rscratch1, table);\n+    __ movptr(flags, Address(rscratch1, flags, Address::times_ptr));\n+#else\n+    __ movptr(flags, ArrayAddress(table, Address(noreg, flags, Address::times_ptr)));\n+#endif \/\/ _LP64\n@@ -4027,2 +4027,1 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  __ load_klass(rax, recv, tmp_load_klass);\n+  __ load_klass(rax, recv, rscratch1);\n@@ -4120,2 +4119,1 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  __ load_klass(rlocals, rcx, tmp_load_klass);\n+  __ load_klass(rlocals, rcx, rscratch1);\n@@ -4144,1 +4142,1 @@\n-  __ load_klass(rdx, rcx, tmp_load_klass);\n+  __ load_klass(rdx, rcx, rscratch1);\n@@ -4446,2 +4444,1 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  __ load_klass(rbx, rdx, tmp_load_klass);\n+  __ load_klass(rbx, rdx, rscratch1);\n@@ -4519,2 +4516,1 @@\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  __ load_klass(rdx, rdx, tmp_load_klass);\n+  __ load_klass(rdx, rdx, rscratch1);\n@@ -4525,1 +4521,1 @@\n-  __ load_klass(rdx, rax, tmp_load_klass);\n+  __ load_klass(rdx, rax, rscratch1);\n@@ -4645,1 +4641,1 @@\n-    __ cmpptr(Address(rtop, BasicObjectLock::obj_offset_in_bytes()), (int32_t) NULL_WORD);\n+    __ cmpptr(Address(rtop, BasicObjectLock::obj_offset_in_bytes()), NULL_WORD);\n@@ -4783,1 +4779,1 @@\n-  __ jump(ArrayAddress(wtable, Address(noreg, rbx, Address::times_ptr)));\n+  __ jump(ArrayAddress(wtable, Address(noreg, rbx, Address::times_ptr)), rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":38,"deletions":42,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -36,1 +37,1 @@\n-#include \"runtime\/os.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n@@ -42,2 +43,0 @@\n-#include OS_HEADER_INLINE(os)\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  Register tmp_load_klass = rscratch1;\n@@ -74,1 +73,1 @@\n-    __ incrementq(ExternalAddress((address) SharedRuntime::nof_megamorphic_calls_addr()));\n+    __ incrementq(ExternalAddress(SharedRuntime::nof_megamorphic_calls_addr()), rscratch1);\n@@ -85,1 +84,1 @@\n-  __ load_klass(rax, j_rarg0, tmp_load_klass);\n+  __ load_klass(rax, j_rarg0, rscratch1);\n@@ -121,1 +120,1 @@\n-    __ cmpptr(method, (int32_t)NULL_WORD);\n+    __ cmpptr(method, NULL_WORD);\n@@ -123,1 +122,1 @@\n-    __ cmpptr(Address(method, entry_offset), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(method, entry_offset), NULL_WORD);\n@@ -169,1 +168,1 @@\n-    __ incrementq(ExternalAddress((address) SharedRuntime::nof_megamorphic_calls_addr()));\n+    __ incrementq(ExternalAddress(SharedRuntime::nof_megamorphic_calls_addr()), rscratch1);\n@@ -240,1 +239,1 @@\n-    __ cmpptr(method, (int32_t)NULL_WORD);\n+    __ cmpptr(method, NULL_WORD);\n@@ -242,1 +241,1 @@\n-    __ cmpptr(Address(method, entry_offset), (int32_t)NULL_WORD);\n+    __ cmpptr(Address(method, entry_offset), NULL_WORD);\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_64.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1346,1 +1346,1 @@\n-  __ pushptr(here.addr());\n+  __ pushptr(here.addr(), noreg);\n@@ -1395,2 +1395,0 @@\n-  static address vector_float_signflip() { return StubRoutines::x86::vector_float_sign_flip();}\n-  static address vector_double_signflip() { return StubRoutines::x86::vector_double_sign_flip();}\n@@ -1851,4 +1849,0 @@\n-      } else if (bt == T_BYTE && size_in_bits > 256 && !VM_Version::supports_avx512_vbmi())  {\n-        return false; \/\/ Implementation limitation\n-      } else if (bt == T_SHORT && size_in_bits > 256 && !VM_Version::supports_avx512bw())  {\n-        return false; \/\/ Implementation limitation\n@@ -3785,1 +3779,1 @@\n-instruct reinterpret_expand(vec dst, vec src, rRegP scratch) %{\n+instruct reinterpret_expand(vec dst, vec src) %{\n@@ -3790,2 +3784,2 @@\n-  effect(TEMP dst, TEMP scratch);\n-  format %{ \"vector_reinterpret_expand $dst,$src\\t! using $scratch as TEMP\" %}\n+  effect(TEMP dst);\n+  format %{ \"vector_reinterpret_expand $dst,$src\" %}\n@@ -3798,1 +3792,1 @@\n-      __ movdqu($dst$$XMMRegister, ExternalAddress(vector_32_bit_mask()), $scratch$$Register);\n+      __ movdqu($dst$$XMMRegister, ExternalAddress(vector_32_bit_mask()), noreg);\n@@ -3801,1 +3795,1 @@\n-      __ movdqu($dst$$XMMRegister, ExternalAddress(vector_64_bit_mask()), $scratch$$Register);\n+      __ movdqu($dst$$XMMRegister, ExternalAddress(vector_64_bit_mask()), noreg);\n@@ -3808,1 +3802,1 @@\n-instruct vreinterpret_expand4(legVec dst, vec src, rRegP scratch) %{\n+instruct vreinterpret_expand4(legVec dst, vec src) %{\n@@ -3815,2 +3809,1 @@\n-  effect(TEMP scratch);\n-  format %{ \"vector_reinterpret_expand $dst,$src\\t! using $scratch as TEMP\" %}\n+  format %{ \"vector_reinterpret_expand $dst,$src\" %}\n@@ -3818,1 +3811,1 @@\n-    __ vpand($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_32_bit_mask()), 0, $scratch$$Register);\n+    __ vpand($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_32_bit_mask()), 0, noreg);\n@@ -3886,1 +3879,1 @@\n-instruct roundD_imm(legRegD dst, immD con, immU8 rmode, rRegI scratch_reg) %{\n+instruct roundD_imm(legRegD dst, immD con, immU8 rmode) %{\n@@ -3888,1 +3881,0 @@\n-  effect(TEMP scratch_reg);\n@@ -3893,1 +3885,1 @@\n-    __ roundsd($dst$$XMMRegister, $constantaddress($con), $rmode$$constant, $scratch_reg$$Register);\n+    __ roundsd($dst$$XMMRegister, $constantaddress($con), $rmode$$constant, noreg);\n@@ -4054,1 +4046,1 @@\n-      __ movdqu($mask$$XMMRegister, ExternalAddress(vector_all_bits_set()));\n+      __ movdqu($mask$$XMMRegister, ExternalAddress(vector_all_bits_set()), noreg);\n@@ -4056,1 +4048,1 @@\n-      __ vmovdqu($mask$$XMMRegister, ExternalAddress(vector_all_bits_set()));\n+      __ vmovdqu($mask$$XMMRegister, ExternalAddress(vector_all_bits_set()), noreg);\n@@ -4077,1 +4069,1 @@\n-    __ kmovwl($ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), $tmp$$Register);\n+    __ kmovwl($ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), noreg);\n@@ -4118,1 +4110,1 @@\n-    __ kmovwl($ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), $tmp$$Register);\n+    __ kmovwl($ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), noreg);\n@@ -4146,1 +4138,2 @@\n-instruct ReplB_reg(vec dst, rRegI src) %{\n+instruct vReplB_reg(vec dst, rRegI src) %{\n+  predicate(UseAVX >= 2);\n@@ -4151,0 +4144,1 @@\n+    int vlen_enc = vector_length_encoding(this);\n@@ -4153,5 +4147,0 @@\n-      int vlen_enc = vector_length_encoding(this);\n-    } else if (VM_Version::supports_avx2()) {\n-      int vlen_enc = vector_length_encoding(this);\n-      __ movdl($dst$$XMMRegister, $src$$Register);\n-      __ vpbroadcastb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n@@ -4161,9 +4150,1 @@\n-      __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);\n-      __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n-      if (vlen >= 16) {\n-        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-        if (vlen >= 32) {\n-          assert(vlen == 32, \"sanity\");\n-          __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);\n-        }\n-      }\n+      __ vpbroadcastb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n@@ -4175,4 +4156,4 @@\n-instruct ReplB_mem(vec dst, memory mem) %{\n-  predicate(VM_Version::supports_avx2());\n-  match(Set dst (ReplicateB (LoadB mem)));\n-  format %{ \"replicateB $dst,$mem\" %}\n+instruct ReplB_reg(vec dst, rRegI src) %{\n+  predicate(UseAVX < 2);\n+  match(Set dst (ReplicateB src));\n+  format %{ \"replicateB $dst,$src\" %}\n@@ -4180,2 +4161,8 @@\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vpbroadcastb($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+    uint vlen = Matcher::vector_length(this);\n+    __ movdl($dst$$XMMRegister, $src$$Register);\n+    __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);\n+    __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n+    if (vlen >= 16) {\n+      assert(vlen == 16, \"\");\n+      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n@@ -4186,3 +4173,4 @@\n-instruct ReplB_imm(vec dst, immI con) %{\n-  match(Set dst (ReplicateB con));\n-  format %{ \"replicateB $dst,$con\" %}\n+instruct ReplB_mem(vec dst, memory mem) %{\n+  predicate(UseAVX >= 2);\n+  match(Set dst (ReplicateB (LoadB mem)));\n+  format %{ \"replicateB $dst,$mem\" %}\n@@ -4190,2 +4178,2 @@\n-    InternalAddress addr = $constantaddress(T_BYTE, vreplicate_imm(T_BYTE, $con$$constant, Matcher::vector_length(this)));\n-    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpbroadcastb($dst$$XMMRegister, $mem$$Address, vlen_enc);\n@@ -4198,1 +4186,2 @@\n-instruct ReplS_reg(vec dst, rRegI src) %{\n+instruct vReplS_reg(vec dst, rRegI src) %{\n+  predicate(UseAVX >= 2);\n@@ -4203,0 +4192,1 @@\n+    int vlen_enc = vector_length_encoding(this);\n@@ -4205,5 +4195,0 @@\n-      int vlen_enc = vector_length_encoding(this);\n-    } else if (VM_Version::supports_avx2()) {\n-      int vlen_enc = vector_length_encoding(this);\n-      __ movdl($dst$$XMMRegister, $src$$Register);\n-      __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n@@ -4213,8 +4198,1 @@\n-      __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n-      if (vlen >= 8) {\n-        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-        if (vlen >= 16) {\n-          assert(vlen == 16, \"sanity\");\n-          __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);\n-        }\n-      }\n+      __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n@@ -4226,4 +4204,4 @@\n-instruct ReplS_mem(vec dst, memory mem) %{\n-  predicate(VM_Version::supports_avx2());\n-  match(Set dst (ReplicateS (LoadS mem)));\n-  format %{ \"replicateS $dst,$mem\" %}\n+instruct ReplS_reg(vec dst, rRegI src) %{\n+  predicate(UseAVX < 2);\n+  match(Set dst (ReplicateS src));\n+  format %{ \"replicateS $dst,$src\" %}\n@@ -4231,0 +4209,1 @@\n+    uint vlen = Matcher::vector_length(this);\n@@ -4232,1 +4211,6 @@\n-    __ vpbroadcastw($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+    __ movdl($dst$$XMMRegister, $src$$Register);\n+    __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n+    if (vlen >= 8) {\n+      assert(vlen == 8, \"\");\n+      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n@@ -4237,3 +4221,4 @@\n-instruct ReplS_imm(vec dst, immI con) %{\n-  match(Set dst (ReplicateS con));\n-  format %{ \"replicateS $dst,$con\" %}\n+instruct ReplS_mem(vec dst, memory mem) %{\n+  predicate(UseAVX >= 2);\n+  match(Set dst (ReplicateS (LoadS mem)));\n+  format %{ \"replicateS $dst,$mem\" %}\n@@ -4241,2 +4226,2 @@\n-    InternalAddress addr = $constantaddress(T_SHORT, vreplicate_imm(T_SHORT, $con$$constant, Matcher::vector_length(this)));\n-    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpbroadcastw($dst$$XMMRegister, $mem$$Address, vlen_enc);\n@@ -4254,0 +4239,1 @@\n+    int vlen_enc = vector_length_encoding(this);\n@@ -4255,1 +4241,0 @@\n-      int vlen_enc = vector_length_encoding(this);\n@@ -4258,1 +4243,0 @@\n-      int vlen_enc = vector_length_encoding(this);\n@@ -4264,4 +4248,0 @@\n-      if (vlen >= 8) {\n-        assert(vlen == 8, \"sanity\");\n-        __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);\n-      }\n@@ -4277,2 +4257,6 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 4) {\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_avx2()) {\n+      __ vpbroadcastd($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+    } else if (VM_Version::supports_avx()) {\n+      __ vbroadcastss($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+    } else {\n@@ -4281,4 +4265,0 @@\n-    } else {\n-      assert(VM_Version::supports_avx2(), \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpbroadcastd($dst$$XMMRegister, $mem$$Address, vlen_enc);\n@@ -4291,0 +4271,2 @@\n+  match(Set dst (ReplicateB con));\n+  match(Set dst (ReplicateS con));\n@@ -4294,2 +4276,7 @@\n-    InternalAddress addr = $constantaddress(T_INT, vreplicate_imm(T_INT, $con$$constant, Matcher::vector_length(this)));\n-    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+    InternalAddress addr = $constantaddress(Matcher::vector_element_basic_type(this),\n+        vreplicate_imm(Matcher::vector_element_basic_type(this), $con$$constant,\n+            (VM_Version::supports_sse3() ? (VM_Version::supports_avx() ? 4 : 8) : 8) \/\n+                type2aelembytes(Matcher::vector_element_basic_type(this))));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int vlen = Matcher::vector_length_in_bytes(this);\n+    __ load_constant_vector(bt, $dst$$XMMRegister, addr, vlen);\n@@ -4307,5 +4294,2 @@\n-    uint vsize = Matcher::vector_length_in_bytes(this);\n-    if (vsize <= 16) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      int vlen_enc = vector_length_encoding(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vl()) {\n@@ -4313,0 +4297,2 @@\n+    } else {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -4319,1 +4305,1 @@\n-  predicate(UseAVX > 0 && Matcher::vector_length_in_bytes(n) >= 16);\n+  predicate(UseSSE >= 2);\n@@ -4323,1 +4309,0 @@\n-  effect(TEMP dst);\n@@ -4340,6 +4325,3 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen == 2) {\n-      __ movdq($dst$$XMMRegister, $src$$Register);\n-      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else if (vlen == 8 || VM_Version::supports_avx512vl()) { \/\/ AVX512VL for <512bit operands\n-      int vlen_enc = vector_length_encoding(this);\n+    int vlen = Matcher::vector_length(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (vlen == 8 || VM_Version::supports_avx512vl()) { \/\/ AVX512VL for <512bit operands\n@@ -4348,2 +4330,0 @@\n-      assert(vlen == 4, \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n@@ -4353,1 +4333,0 @@\n-      assert(vlen == 4, \"sanity\");\n@@ -4356,1 +4335,0 @@\n-      __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -4421,2 +4399,6 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen == 2) {\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_avx2()) {\n+      __ vpbroadcastq($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+    } else if (VM_Version::supports_sse3()) {\n+      __ movddup($dst$$XMMRegister, $mem$$Address);\n+    } else {\n@@ -4425,4 +4407,0 @@\n-    } else {\n-      assert(VM_Version::supports_avx2(), \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpbroadcastq($dst$$XMMRegister, $mem$$Address, vlen_enc);\n@@ -4439,2 +4417,3 @@\n-    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, $con$$constant, Matcher::vector_length(this)));\n-    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, $con$$constant, 1));\n+    int vlen = Matcher::vector_length_in_bytes(this);\n+    __ load_constant_vector(T_LONG, $dst$$XMMRegister, addr, vlen);\n@@ -4449,5 +4428,2 @@\n-    int vlen = Matcher::vector_length(this);\n-    if (vlen == 2) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      int vlen_enc = vector_length_encoding(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vl()) {\n@@ -4455,0 +4431,2 @@\n+    } else {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -4461,1 +4439,1 @@\n-  predicate(UseAVX > 0);\n+  predicate(UseSSE >= 2);\n@@ -4463,1 +4441,0 @@\n-  effect(TEMP dst);\n@@ -4474,1 +4451,2 @@\n-instruct ReplF_reg(vec dst, vlRegF src) %{\n+instruct vReplF_reg(vec dst, vlRegF src) %{\n+  predicate(UseAVX > 0);\n@@ -4479,0 +4457,1 @@\n+    int vlen_enc = vector_length_encoding(this);\n@@ -4480,3 +4459,2 @@\n-      __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);\n-   } else if (VM_Version::supports_avx2()) {\n-      int vlen_enc = vector_length_encoding(this);\n+      __ vpermilps($dst$$XMMRegister, $src$$XMMRegister, 0x00, Assembler::AVX_128bit);\n+    } else if (VM_Version::supports_avx2()) {\n@@ -4486,1 +4464,1 @@\n-      __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);\n+      __ vpermilps($dst$$XMMRegister, $src$$XMMRegister, 0x00, Assembler::AVX_128bit);\n@@ -4493,0 +4471,10 @@\n+instruct ReplF_reg(vec dst, vlRegF src) %{\n+  predicate(UseAVX == 0);\n+  match(Set dst (ReplicateF src));\n+  format %{ \"replicateF $dst,$src\" %}\n+  ins_encode %{\n+    __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4494,0 +4482,1 @@\n+  predicate(UseAVX > 0);\n@@ -4497,9 +4486,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 4) {\n-      __ movdl($dst$$XMMRegister, $mem$$Address);\n-      __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n-    } else {\n-      assert(VM_Version::supports_avx(), \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vbroadcastss($dst$$XMMRegister, $mem$$Address, vlen_enc);\n-    }\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vbroadcastss($dst$$XMMRegister, $mem$$Address, vlen_enc);\n@@ -4515,2 +4497,4 @@\n-    InternalAddress addr = $constantaddress(T_FLOAT, vreplicate_imm(T_FLOAT, $con$$constant, Matcher::vector_length(this)));\n-    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+    InternalAddress addr = $constantaddress(T_FLOAT, vreplicate_imm(T_FLOAT, $con$$constant,\n+        VM_Version::supports_sse3() ? (VM_Version::supports_avx() ? 1 : 2) : 2));\n+    int vlen = Matcher::vector_length_in_bytes(this);\n+    __ load_constant_vector(T_FLOAT, $dst$$XMMRegister, addr, vlen);\n@@ -4525,3 +4509,3 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 4) {\n-      __ xorps($dst$$XMMRegister, $dst$$XMMRegister);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vldq()) {\n+      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n@@ -4529,2 +4513,1 @@\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpxor($dst$$XMMRegister,$dst$$XMMRegister, $dst$$XMMRegister, vlen_enc); \/\/ 512bit vxorps requires AVX512DQ\n+      __ xorps($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -4539,1 +4522,2 @@\n-instruct ReplD_reg(vec dst, vlRegD src) %{\n+instruct vReplD_reg(vec dst, vlRegD src) %{\n+  predicate(UseSSE >= 3);\n@@ -4544,2 +4528,3 @@\n-    if (vlen == 2) {\n-      __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (vlen <= 2) {\n+      __ movddup($dst$$XMMRegister, $src$$XMMRegister);\n@@ -4547,1 +4532,0 @@\n-      int vlen_enc = vector_length_encoding(this);\n@@ -4551,1 +4535,1 @@\n-      __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);\n+      __ movddup($dst$$XMMRegister, $src$$XMMRegister);\n@@ -4558,0 +4542,10 @@\n+instruct ReplD_reg(vec dst, vlRegD src) %{\n+  predicate(UseSSE < 3);\n+  match(Set dst (ReplicateD src));\n+  format %{ \"replicateD $dst,$src\" %}\n+  ins_encode %{\n+    __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4559,0 +4553,1 @@\n+  predicate(UseSSE >= 3);\n@@ -4562,6 +4557,1 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen == 2) {\n-      __ movq($dst$$XMMRegister, $mem$$Address);\n-      __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x44);\n-    } else {\n-      assert(VM_Version::supports_avx(), \"sanity\");\n+    if (Matcher::vector_length(this) >= 4) {\n@@ -4570,0 +4560,2 @@\n+    } else {\n+      __ movddup($dst$$XMMRegister, $mem$$Address);\n@@ -4580,2 +4572,3 @@\n-    InternalAddress addr = $constantaddress(T_DOUBLE, vreplicate_imm(T_DOUBLE, $con$$constant, Matcher::vector_length(this)));\n-    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+    InternalAddress addr = $constantaddress(T_DOUBLE, vreplicate_imm(T_DOUBLE, $con$$constant, 1));\n+    int vlen = Matcher::vector_length_in_bytes(this);\n+    __ load_constant_vector(T_DOUBLE, $dst$$XMMRegister, addr, vlen);\n@@ -4590,3 +4583,3 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen == 2) {\n-      __ xorpd($dst$$XMMRegister, $dst$$XMMRegister);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vldq()) {\n+      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n@@ -4594,2 +4587,1 @@\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc); \/\/ 512bit vxorps requires AVX512DQ\n+      __ xorps($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -5656,1 +5648,1 @@\n-instruct mulB_reg(vec dst, vec src1, vec src2, vec tmp, rRegI scratch) %{\n+instruct mulB_reg(vec dst, vec src1, vec src2, vec tmp) %{\n@@ -5660,1 +5652,1 @@\n-  effect(TEMP dst, TEMP tmp, TEMP scratch);\n+  effect(TEMP dst, TEMP tmp);\n@@ -5667,1 +5659,1 @@\n-    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);\n+    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n@@ -5674,1 +5666,1 @@\n-instruct mul16B_reg(vec dst, vec src1, vec src2, vec tmp1, vec tmp2, rRegI scratch) %{\n+instruct mul16B_reg(vec dst, vec src1, vec src2, vec tmp1, vec tmp2) %{\n@@ -5677,1 +5669,1 @@\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP scratch);\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n@@ -5689,1 +5681,1 @@\n-    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);\n+    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n@@ -5697,1 +5689,1 @@\n-instruct vmul16B_reg_avx(vec dst, vec src1, vec src2, vec tmp, rRegI scratch) %{\n+instruct vmul16B_reg_avx(vec dst, vec src1, vec src2, vec tmp) %{\n@@ -5700,1 +5692,1 @@\n-  effect(TEMP dst, TEMP tmp, TEMP scratch);\n+  effect(TEMP dst, TEMP tmp);\n@@ -5707,1 +5699,1 @@\n-    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);\n+    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n@@ -5715,1 +5707,1 @@\n-instruct vmul32B_reg_avx(vec dst, vec src1, vec src2, vec tmp1, vec tmp2, rRegI scratch) %{\n+instruct vmul32B_reg_avx(vec dst, vec src1, vec src2, vec tmp1, vec tmp2) %{\n@@ -5718,1 +5710,1 @@\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP scratch);\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n@@ -5731,1 +5723,1 @@\n-    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);\n+    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n@@ -5741,1 +5733,1 @@\n-instruct vmul64B_reg_avx(vec dst, vec src1, vec src2, vec tmp1, vec tmp2, rRegI scratch) %{\n+instruct vmul64B_reg_avx(vec dst, vec src1, vec src2, vec tmp1, vec tmp2) %{\n@@ -5744,1 +5736,1 @@\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP scratch);\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n@@ -5757,1 +5749,1 @@\n-    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);\n+    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n@@ -5762,1 +5754,1 @@\n-    __ evmovdquq($tmp2$$XMMRegister, ExternalAddress(vector_byte_perm_mask()), vlen_enc, $scratch$$Register);\n+    __ evmovdquq($tmp2$$XMMRegister, ExternalAddress(vector_byte_perm_mask()), vlen_enc, noreg);\n@@ -6226,1 +6218,1 @@\n-instruct signumF_reg(regF dst, regF zero, regF one, rRegP scratch, rFlagsReg cr) %{\n+instruct signumF_reg(regF dst, regF zero, regF one, rFlagsReg cr) %{\n@@ -6228,2 +6220,2 @@\n-  effect(TEMP scratch, KILL cr);\n-  format %{ \"signumF $dst, $dst\\t! using $scratch as TEMP\" %}\n+  effect(KILL cr);\n+  format %{ \"signumF $dst, $dst\" %}\n@@ -6232,1 +6224,1 @@\n-    __ signum_fp(opcode, $dst$$XMMRegister, $zero$$XMMRegister, $one$$XMMRegister, $scratch$$Register);\n+    __ signum_fp(opcode, $dst$$XMMRegister, $zero$$XMMRegister, $one$$XMMRegister);\n@@ -6237,1 +6229,1 @@\n-instruct signumD_reg(regD dst, regD zero, regD one, rRegP scratch, rFlagsReg cr) %{\n+instruct signumD_reg(regD dst, regD zero, regD one, rFlagsReg cr) %{\n@@ -6239,2 +6231,2 @@\n-  effect(TEMP scratch, KILL cr);\n-  format %{ \"signumD $dst, $dst\\t! using $scratch as TEMP\" %}\n+  effect(KILL cr);\n+  format %{ \"signumD $dst, $dst\" %}\n@@ -6243,1 +6235,1 @@\n-    __ signum_fp(opcode, $dst$$XMMRegister, $zero$$XMMRegister, $one$$XMMRegister, $scratch$$Register);\n+    __ signum_fp(opcode, $dst$$XMMRegister, $zero$$XMMRegister, $one$$XMMRegister);\n@@ -6436,1 +6428,1 @@\n-instruct vshiftB(vec dst, vec src, vec shift, vec tmp, rRegI scratch) %{\n+instruct vshiftB(vec dst, vec src, vec shift, vec tmp) %{\n@@ -6441,1 +6433,1 @@\n-  effect(TEMP dst, USE src, USE shift, TEMP tmp, TEMP scratch);\n+  effect(TEMP dst, USE src, USE shift, TEMP tmp);\n@@ -6449,1 +6441,1 @@\n-    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);\n+    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n@@ -6456,1 +6448,1 @@\n-instruct vshift16B(vec dst, vec src, vec shift, vec tmp1, vec tmp2, rRegI scratch) %{\n+instruct vshift16B(vec dst, vec src, vec shift, vec tmp1, vec tmp2) %{\n@@ -6462,1 +6454,1 @@\n-  effect(TEMP dst, USE src, USE shift, TEMP tmp1, TEMP tmp2, TEMP scratch);\n+  effect(TEMP dst, USE src, USE shift, TEMP tmp1, TEMP tmp2);\n@@ -6473,1 +6465,1 @@\n-    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);\n+    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n@@ -6481,1 +6473,1 @@\n-instruct vshift16B_avx(vec dst, vec src, vec shift, vec tmp, rRegI scratch) %{\n+instruct vshift16B_avx(vec dst, vec src, vec shift, vec tmp) %{\n@@ -6487,1 +6479,1 @@\n-  effect(TEMP dst, TEMP tmp, TEMP scratch);\n+  effect(TEMP dst, TEMP tmp);\n@@ -6495,1 +6487,1 @@\n-    __ vpand($tmp$$XMMRegister, $tmp$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), vlen_enc, $scratch$$Register);\n+    __ vpand($tmp$$XMMRegister, $tmp$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), vlen_enc, noreg);\n@@ -6502,1 +6494,1 @@\n-instruct vshift32B_avx(vec dst, vec src, vec shift, vec tmp, rRegI scratch) %{\n+instruct vshift32B_avx(vec dst, vec src, vec shift, vec tmp) %{\n@@ -6507,1 +6499,1 @@\n-  effect(TEMP dst, TEMP tmp, TEMP scratch);\n+  effect(TEMP dst, TEMP tmp);\n@@ -6519,2 +6511,2 @@\n-    __ vpand($tmp$$XMMRegister, $tmp$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), vlen_enc, $scratch$$Register);\n-    __ vpand($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), vlen_enc, $scratch$$Register);\n+    __ vpand($tmp$$XMMRegister, $tmp$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), vlen_enc, noreg);\n+    __ vpand($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), vlen_enc, noreg);\n@@ -6527,1 +6519,1 @@\n-instruct vshift64B_avx(vec dst, vec src, vec shift, vec tmp1, vec tmp2, rRegI scratch) %{\n+instruct vshift64B_avx(vec dst, vec src, vec shift, vec tmp1, vec tmp2) %{\n@@ -6532,1 +6524,1 @@\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP scratch);\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n@@ -6544,1 +6536,1 @@\n-    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), $scratch$$Register);\n+    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n@@ -6549,1 +6541,1 @@\n-    __ evmovdquq($tmp2$$XMMRegister, ExternalAddress(vector_byte_perm_mask()), vlen_enc, $scratch$$Register);\n+    __ evmovdquq($tmp2$$XMMRegister, ExternalAddress(vector_byte_perm_mask()), vlen_enc, noreg);\n@@ -6686,1 +6678,1 @@\n-instruct vshiftL_arith_reg(vec dst, vec src, vec shift, vec tmp, rRegI scratch) %{\n+instruct vshiftL_arith_reg(vec dst, vec src, vec shift, vec tmp) %{\n@@ -6689,1 +6681,1 @@\n-  effect(TEMP dst, TEMP tmp, TEMP scratch);\n+  effect(TEMP dst, TEMP tmp);\n@@ -6697,1 +6689,1 @@\n-      __ movdqu($tmp$$XMMRegister, ExternalAddress(vector_long_sign_mask()), $scratch$$Register);\n+      __ movdqu($tmp$$XMMRegister, ExternalAddress(vector_long_sign_mask()), noreg);\n@@ -6706,1 +6698,1 @@\n-      __ vmovdqu($tmp$$XMMRegister, ExternalAddress(vector_long_sign_mask()), $scratch$$Register);\n+      __ vmovdqu($tmp$$XMMRegister, ExternalAddress(vector_long_sign_mask()), noreg);\n@@ -6728,1 +6720,1 @@\n-instruct vshift8B_var_nobw(vec dst, vec src, vec shift, vec vtmp, rRegP scratch) %{\n+instruct vshift8B_var_nobw(vec dst, vec src, vec shift, vec vtmp) %{\n@@ -6735,2 +6727,2 @@\n-  effect(TEMP dst, TEMP vtmp, TEMP scratch);\n-  format %{ \"vector_varshift_byte $dst, $src, $shift\\n\\t! using $vtmp, $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp);\n+  format %{ \"vector_varshift_byte $dst, $src, $shift\\n\\t! using $vtmp as TEMP\" %}\n@@ -6742,1 +6734,1 @@\n-    __ varshiftbw(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vlen_enc, $vtmp$$XMMRegister, $scratch$$Register);\n+    __ varshiftbw(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vlen_enc, $vtmp$$XMMRegister);\n@@ -6748,1 +6740,1 @@\n-instruct vshift16B_var_nobw(vec dst, vec src, vec shift, vec vtmp1, vec vtmp2, rRegP scratch) %{\n+instruct vshift16B_var_nobw(vec dst, vec src, vec shift, vec vtmp1, vec vtmp2) %{\n@@ -6755,2 +6747,2 @@\n-  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n-  format %{ \"vector_varshift_byte $dst, $src, $shift\\n\\t! using $vtmp1, $vtmp2 and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"vector_varshift_byte $dst, $src, $shift\\n\\t! using $vtmp1, $vtmp2 as TEMP\" %}\n@@ -6763,1 +6755,1 @@\n-    __ varshiftbw(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vlen_enc, $vtmp1$$XMMRegister, $scratch$$Register);\n+    __ varshiftbw(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vlen_enc, $vtmp1$$XMMRegister);\n@@ -6768,1 +6760,1 @@\n-    __ varshiftbw(opcode, $vtmp1$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, vlen_enc, $vtmp2$$XMMRegister, $scratch$$Register);\n+    __ varshiftbw(opcode, $vtmp1$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, vlen_enc, $vtmp2$$XMMRegister);\n@@ -6776,1 +6768,1 @@\n-instruct vshift32B_var_nobw(vec dst, vec src, vec shift, vec vtmp1, vec vtmp2, vec vtmp3, vec vtmp4, rRegP scratch) %{\n+instruct vshift32B_var_nobw(vec dst, vec src, vec shift, vec vtmp1, vec vtmp2, vec vtmp3, vec vtmp4) %{\n@@ -6783,2 +6775,2 @@\n-  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP scratch);\n-  format %{ \"vector_varshift_byte $dst, $src, $shift\\n\\t using $vtmp1, $vtmp2, $vtmp3, $vtmp4 and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4);\n+  format %{ \"vector_varshift_byte $dst, $src, $shift\\n\\t using $vtmp1, $vtmp2, $vtmp3, $vtmp4 as TEMP\" %}\n@@ -6791,1 +6783,1 @@\n-    __ varshiftbw(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vlen_enc, $vtmp1$$XMMRegister, $scratch$$Register);\n+    __ varshiftbw(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vlen_enc, $vtmp1$$XMMRegister);\n@@ -6794,1 +6786,1 @@\n-    __ varshiftbw(opcode, $vtmp1$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, vlen_enc, $vtmp2$$XMMRegister, $scratch$$Register);\n+    __ varshiftbw(opcode, $vtmp1$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, vlen_enc, $vtmp2$$XMMRegister);\n@@ -6800,1 +6792,1 @@\n-    __ varshiftbw(opcode, $vtmp3$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, vlen_enc, $vtmp4$$XMMRegister, $scratch$$Register);\n+    __ varshiftbw(opcode, $vtmp3$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, vlen_enc, $vtmp4$$XMMRegister);\n@@ -6803,1 +6795,1 @@\n-    __ varshiftbw(opcode, $vtmp1$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, vlen_enc, $vtmp2$$XMMRegister, $scratch$$Register);\n+    __ varshiftbw(opcode, $vtmp1$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, vlen_enc, $vtmp2$$XMMRegister);\n@@ -6812,1 +6804,1 @@\n-instruct vshiftB_var_evex_bw(vec dst, vec src, vec shift, vec vtmp, rRegP scratch) %{\n+instruct vshiftB_var_evex_bw(vec dst, vec src, vec shift, vec vtmp) %{\n@@ -6819,2 +6811,2 @@\n-  effect(TEMP dst, TEMP vtmp, TEMP scratch);\n-  format %{ \"vector_varshift_byte $dst, $src, $shift\\n\\t! using $vtmp, $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp);\n+  format %{ \"vector_varshift_byte $dst, $src, $shift\\n\\t! using $vtmp as TEMP\" %}\n@@ -6826,1 +6818,1 @@\n-    __ evarshiftb(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vlen_enc, $vtmp$$XMMRegister, $scratch$$Register);\n+    __ evarshiftb(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vlen_enc, $vtmp$$XMMRegister);\n@@ -6831,1 +6823,1 @@\n-instruct vshift64B_var_evex_bw(vec dst, vec src, vec shift, vec vtmp1, vec vtmp2, rRegP scratch) %{\n+instruct vshift64B_var_evex_bw(vec dst, vec src, vec shift, vec vtmp1, vec vtmp2) %{\n@@ -6838,2 +6830,2 @@\n-  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n-  format %{ \"vector_varshift_byte $dst, $src, $shift\\n\\t! using $vtmp1, $vtmp2 and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"vector_varshift_byte $dst, $src, $shift\\n\\t! using $vtmp1, $vtmp2 as TEMP\" %}\n@@ -6845,1 +6837,1 @@\n-    __ evarshiftb(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vlen_enc, $vtmp1$$XMMRegister, $scratch$$Register);\n+    __ evarshiftb(opcode, $dst$$XMMRegister, $src$$XMMRegister, $shift$$XMMRegister, vlen_enc, $vtmp1$$XMMRegister);\n@@ -6848,1 +6840,1 @@\n-    __ evarshiftb(opcode, $vtmp1$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, vlen_enc, $vtmp2$$XMMRegister, $scratch$$Register);\n+    __ evarshiftb(opcode, $vtmp1$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister, vlen_enc, $vtmp2$$XMMRegister);\n@@ -6855,1 +6847,1 @@\n-instruct vshift8S_var_nobw(vec dst, vec src, vec shift, vec vtmp, rRegP scratch) %{\n+instruct vshift8S_var_nobw(vec dst, vec src, vec shift, vec vtmp) %{\n@@ -6862,1 +6854,1 @@\n-  effect(TEMP dst, TEMP vtmp, TEMP scratch);\n+  effect(TEMP dst, TEMP vtmp);\n@@ -6873,1 +6865,1 @@\n-    __ vpand($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_int_to_short_mask()), vlen_enc, $scratch$$Register);\n+    __ vpand($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_int_to_short_mask()), vlen_enc, noreg);\n@@ -6880,1 +6872,1 @@\n-instruct vshift16S_var_nobw(vec dst, vec src, vec shift, vec vtmp1, vec vtmp2, rRegP scratch) %{\n+instruct vshift16S_var_nobw(vec dst, vec src, vec shift, vec vtmp1, vec vtmp2) %{\n@@ -6887,1 +6879,1 @@\n-  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2);\n@@ -6899,1 +6891,1 @@\n-    __ vpand($vtmp2$$XMMRegister, $vtmp2$$XMMRegister, ExternalAddress(vector_int_to_short_mask()), vlen_enc, $scratch$$Register);\n+    __ vpand($vtmp2$$XMMRegister, $vtmp2$$XMMRegister, ExternalAddress(vector_int_to_short_mask()), vlen_enc, noreg);\n@@ -6907,1 +6899,1 @@\n-    __ vpand($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_int_to_short_mask()), vlen_enc, $scratch$$Register);\n+    __ vpand($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_int_to_short_mask()), vlen_enc, noreg);\n@@ -7119,1 +7111,1 @@\n-instruct castStoX(vec dst, vec src, rRegP scratch) %{\n+instruct castStoX(vec dst, vec src) %{\n@@ -7123,2 +7115,1 @@\n-  effect(TEMP scratch);\n-  format %{ \"vector_cast_s2x $dst,$src\\t! using $scratch as TEMP\" %}\n+  format %{ \"vector_cast_s2x $dst,$src\" %}\n@@ -7129,1 +7120,1 @@\n-    __ vpand($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), 0, $scratch$$Register);\n+    __ vpand($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), 0, noreg);\n@@ -7135,1 +7126,1 @@\n-instruct vcastStoX(vec dst, vec src, vec vtmp, rRegP scratch) %{\n+instruct vcastStoX(vec dst, vec src, vec vtmp) %{\n@@ -7139,1 +7130,1 @@\n-  effect(TEMP dst, TEMP vtmp, TEMP scratch);\n+  effect(TEMP dst, TEMP vtmp);\n@@ -7141,1 +7132,1 @@\n-  format %{ \"vector_cast_s2x $dst,$src\\t! using $vtmp, $scratch as TEMP\" %}\n+  format %{ \"vector_cast_s2x $dst,$src\\t! using $vtmp as TEMP\" %}\n@@ -7146,1 +7137,1 @@\n-    __ vpand($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), vlen_enc, $scratch$$Register);\n+    __ vpand($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), vlen_enc, noreg);\n@@ -7192,1 +7183,1 @@\n-instruct castItoX(vec dst, vec src, rRegP scratch) %{\n+instruct castItoX(vec dst, vec src) %{\n@@ -7197,2 +7188,1 @@\n-  format %{ \"vector_cast_i2x $dst,$src\\t! using $scratch as TEMP\" %}\n-  effect(TEMP scratch);\n+  format %{ \"vector_cast_i2x $dst,$src\" %}\n@@ -7206,1 +7196,1 @@\n-      __ vpand($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_int_to_byte_mask()), vlen_enc, $scratch$$Register);\n+      __ vpand($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_int_to_byte_mask()), vlen_enc, noreg);\n@@ -7211,1 +7201,1 @@\n-      __ vpand($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_int_to_short_mask()), vlen_enc, $scratch$$Register);\n+      __ vpand($dst$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_int_to_short_mask()), vlen_enc, noreg);\n@@ -7218,1 +7208,1 @@\n-instruct vcastItoX(vec dst, vec src, vec vtmp, rRegP scratch) %{\n+instruct vcastItoX(vec dst, vec src, vec vtmp) %{\n@@ -7223,2 +7213,2 @@\n-  format %{ \"vector_cast_i2x $dst,$src\\t! using $vtmp and $scratch as TEMP\" %}\n-  effect(TEMP dst, TEMP vtmp, TEMP scratch);\n+  format %{ \"vector_cast_i2x $dst,$src\\t! using $vtmp as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp);\n@@ -7232,1 +7222,1 @@\n-      __ vpand($vtmp$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_int_to_byte_mask()), vlen_enc, $scratch$$Register);\n+      __ vpand($vtmp$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_int_to_byte_mask()), vlen_enc, noreg);\n@@ -7238,1 +7228,1 @@\n-      __ vpand($vtmp$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_int_to_short_mask()), vlen_enc, $scratch$$Register);\n+      __ vpand($vtmp$$XMMRegister, $src$$XMMRegister, ExternalAddress(vector_int_to_short_mask()), vlen_enc, noreg);\n@@ -7286,1 +7276,1 @@\n-instruct vcastLtoBS(vec dst, vec src, rRegP scratch) %{\n+instruct vcastLtoBS(vec dst, vec src) %{\n@@ -7290,2 +7280,1 @@\n-  effect(TEMP scratch);\n-  format %{ \"vector_cast_l2x  $dst,$src\\t! using $scratch as TEMP\" %}\n+  format %{ \"vector_cast_l2x  $dst,$src\" %}\n@@ -7301,1 +7290,1 @@\n-      __ vpand($dst$$XMMRegister, $dst$$XMMRegister, mask_addr, Assembler::AVX_128bit, $scratch$$Register);\n+      __ vpand($dst$$XMMRegister, $dst$$XMMRegister, mask_addr, Assembler::AVX_128bit, noreg);\n@@ -7307,1 +7296,1 @@\n-      __ vpand($dst$$XMMRegister, $dst$$XMMRegister, mask_addr, Assembler::AVX_128bit, $scratch$$Register);\n+      __ vpand($dst$$XMMRegister, $dst$$XMMRegister, mask_addr, Assembler::AVX_128bit, noreg);\n@@ -7389,1 +7378,1 @@\n-instruct castFtoI_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rRegP scratch, rFlagsReg cr) %{\n+instruct castFtoI_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rFlagsReg cr) %{\n@@ -7396,2 +7385,2 @@\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4, TEMP scratch, KILL cr);\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3, $xtmp4 and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4, KILL cr);\n+  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3, $xtmp4 as TEMP\" %}\n@@ -7400,3 +7389,3 @@\n-    __ vector_castF2I_avx($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n-                          $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister,\n-                          ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc);\n+    __ vector_castF2I_avx($dst$$XMMRegister, $src$$XMMRegister,\n+                          ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vlen_enc,\n+                          $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister);\n@@ -7407,1 +7396,1 @@\n-instruct castFtoI_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+instruct castFtoI_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n@@ -7412,2 +7401,2 @@\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, TEMP scratch, KILL cr);\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, KILL cr);\n+  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n@@ -7416,3 +7405,3 @@\n-    __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n-                           $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n-                           ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc);\n+    __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister,\n+                           ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vlen_enc,\n+                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n@@ -7423,1 +7412,1 @@\n-instruct castFtoX_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+instruct castFtoX_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n@@ -7429,2 +7418,2 @@\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, TEMP scratch, KILL cr);\n-  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, KILL cr);\n+  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n@@ -7435,3 +7424,3 @@\n-      __ vector_castF2L_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n-                             $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n-                             ExternalAddress(vector_double_signflip()), $scratch$$Register, vlen_enc);\n+      __ vector_castF2L_evex($dst$$XMMRegister, $src$$XMMRegister,\n+                             ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vlen_enc,\n+                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n@@ -7440,3 +7429,3 @@\n-      __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n-                             $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n-                             ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc);\n+      __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister,\n+                             ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vlen_enc,\n+                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n@@ -7465,1 +7454,1 @@\n-instruct castDtoX_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+instruct castDtoX_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n@@ -7468,2 +7457,2 @@\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, TEMP scratch, KILL cr);\n-  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, KILL cr);\n+  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n@@ -7473,3 +7462,3 @@\n-    __ vector_castD2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n-                           $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n-                           ExternalAddress(vector_double_signflip()), $scratch$$Register, vlen_enc);\n+    __ vector_castD2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister,\n+                           ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vlen_enc,\n+                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n@@ -7497,1 +7486,1 @@\n-instruct vround_float_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rRegP scratch, rFlagsReg cr) %{\n+instruct vround_float_avx(vec dst, vec src, rRegP tmp, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rFlagsReg cr) %{\n@@ -7502,2 +7491,2 @@\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4, TEMP scratch, KILL cr);\n-  format %{ \"vector_round_float $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3, $xtmp4 and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP tmp, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4, KILL cr);\n+  format %{ \"vector_round_float $dst,$src\\t! using $tmp, $xtmp1, $xtmp2, $xtmp3, $xtmp4 as TEMP\" %}\n@@ -7507,3 +7496,3 @@\n-    __ vector_round_float_avx($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n-                              $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister,\n-                              ExternalAddress(vector_float_signflip()), new_mxcsr, $scratch$$Register, vlen_enc);\n+    __ vector_round_float_avx($dst$$XMMRegister, $src$$XMMRegister,\n+                              ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), new_mxcsr, vlen_enc,\n+                              $tmp$$Register, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister);\n@@ -7514,1 +7503,1 @@\n-instruct vround_float_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+instruct vround_float_evex(vec dst, vec src, rRegP tmp, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n@@ -7519,2 +7508,2 @@\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, TEMP scratch, KILL cr);\n-  format %{ \"vector_round_float $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP tmp, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, KILL cr);\n+  format %{ \"vector_round_float $dst,$src\\t! using $tmp, $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n@@ -7524,3 +7513,3 @@\n-    __ vector_round_float_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n-                               $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n-                               ExternalAddress(vector_float_signflip()), new_mxcsr, $scratch$$Register, vlen_enc);\n+    __ vector_round_float_evex($dst$$XMMRegister, $src$$XMMRegister,\n+                               ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), new_mxcsr, vlen_enc,\n+                               $tmp$$Register, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n@@ -7531,1 +7520,1 @@\n-instruct vround_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+instruct vround_reg_evex(vec dst, vec src, rRegP tmp, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n@@ -7534,2 +7523,2 @@\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, TEMP scratch, KILL cr);\n-  format %{ \"vector_round_long $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP tmp, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2,  KILL cr);\n+  format %{ \"vector_round_long $dst,$src\\t! using $tmp, $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n@@ -7539,3 +7528,3 @@\n-    __ vector_round_double_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n-                                $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n-                                ExternalAddress(vector_double_signflip()), new_mxcsr, $scratch$$Register, vlen_enc);\n+    __ vector_round_double_evex($dst$$XMMRegister, $src$$XMMRegister,\n+                                ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), new_mxcsr, vlen_enc,\n+                                $tmp$$Register, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n@@ -7545,1 +7534,3 @@\n-#endif\n+\n+#endif \/\/ _LP64\n+\n@@ -7567,1 +7558,1 @@\n-instruct evcmpFD64(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n+instruct evcmpFD64(vec dst, vec src1, vec src2, immI8 cond, kReg ktmp) %{\n@@ -7572,2 +7563,2 @@\n-  effect(TEMP scratch, TEMP ktmp);\n-  format %{ \"vector_compare $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  effect(TEMP ktmp);\n+  format %{ \"vector_compare $dst,$src1,$src2,$cond\" %}\n@@ -7580,1 +7571,1 @@\n-      __ evmovdqul($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), false, vlen_enc, $scratch$$Register);\n+      __ evmovdqul($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), false, vlen_enc, noreg);\n@@ -7583,1 +7574,1 @@\n-      __ evmovdquq($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), false, vlen_enc, $scratch$$Register);\n+      __ evmovdquq($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), false, vlen_enc, noreg);\n@@ -7676,1 +7667,1 @@\n-instruct vcmp64(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n+instruct vcmp64(vec dst, vec src1, vec src2, immI8 cond, kReg ktmp) %{\n@@ -7681,2 +7672,2 @@\n-  effect(TEMP scratch, TEMP ktmp);\n-  format %{ \"vector_compare $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  effect(TEMP ktmp);\n+  format %{ \"vector_compare $dst,$src1,$src2,$cond\" %}\n@@ -7696,1 +7687,1 @@\n-        __ evmovdqul($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), merge, vlen_enc, $scratch$$Register);\n+        __ evmovdqul($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), merge, vlen_enc, noreg);\n@@ -7701,1 +7692,1 @@\n-        __ evmovdquq($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), merge, vlen_enc, $scratch$$Register);\n+        __ evmovdquq($dst$$XMMRegister, $ktmp$$KRegister, ExternalAddress(vector_all_bits_set()), merge, vlen_enc, noreg);\n@@ -7818,1 +7809,1 @@\n-instruct extractF(legRegF dst, legVec src, immU8 idx, rRegI tmp, legVec vtmp) %{\n+instruct extractF(legRegF dst, legVec src, immU8 idx, legVec vtmp) %{\n@@ -7821,2 +7812,2 @@\n-  effect(TEMP dst, TEMP tmp, TEMP vtmp);\n-  format %{ \"extractF $dst,$src,$idx\\t! using $tmp, $vtmp as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp);\n+  format %{ \"extractF $dst,$src,$idx\\t! using $vtmp as TEMP\" %}\n@@ -7826,1 +7817,1 @@\n-    __ get_elem(T_FLOAT, $dst$$XMMRegister, $src$$XMMRegister, $idx$$constant, $tmp$$Register, $vtmp$$XMMRegister);\n+    __ get_elem(T_FLOAT, $dst$$XMMRegister, $src$$XMMRegister, $idx$$constant, $vtmp$$XMMRegister);\n@@ -7831,1 +7822,1 @@\n-instruct vextractF(legRegF dst, legVec src, immU8 idx, rRegI tmp, legVec vtmp) %{\n+instruct vextractF(legRegF dst, legVec src, immU8 idx, legVec vtmp) %{\n@@ -7835,2 +7826,2 @@\n-  effect(TEMP tmp, TEMP vtmp);\n-  format %{ \"vextractF $dst,$src,$idx\\t! using $tmp, $vtmp as TEMP\" %}\n+  effect(TEMP vtmp);\n+  format %{ \"vextractF $dst,$src,$idx\\t! using $vtmp as TEMP\" %}\n@@ -7841,1 +7832,1 @@\n-    __ get_elem(T_FLOAT, $dst$$XMMRegister, lane_reg, $idx$$constant, $tmp$$Register);\n+    __ get_elem(T_FLOAT, $dst$$XMMRegister, lane_reg, $idx$$constant);\n@@ -7919,1 +7910,1 @@\n-instruct evblendvp64(vec dst, vec src1, vec src2, vec mask, rRegP scratch, kReg ktmp) %{\n+instruct evblendvp64(vec dst, vec src1, vec src2, vec mask, kReg ktmp) %{\n@@ -7923,2 +7914,2 @@\n-  format %{ \"vector_blend  $dst,$src1,$src2,$mask\\t! using $scratch and k2 as TEMP\" %}\n-  effect(TEMP scratch, TEMP ktmp);\n+  format %{ \"vector_blend  $dst,$src1,$src2,$mask\\t! using k2 as TEMP\" %}\n+  effect(TEMP ktmp);\n@@ -7928,1 +7919,1 @@\n-    __ evpcmp(elem_bt, $ktmp$$KRegister, k0, $mask$$XMMRegister, ExternalAddress(vector_all_bits_set()), Assembler::eq, vlen_enc, $scratch$$Register);\n+    __ evpcmp(elem_bt, $ktmp$$KRegister, k0, $mask$$XMMRegister, ExternalAddress(vector_all_bits_set()), Assembler::eq, vlen_enc, noreg);\n@@ -7935,1 +7926,1 @@\n-instruct evblendvp64_masked(vec dst, vec src1, vec src2, kReg mask, rRegP scratch) %{\n+instruct evblendvp64_masked(vec dst, vec src1, vec src2, kReg mask) %{\n@@ -7940,2 +7931,1 @@\n-  format %{ \"vector_blend  $dst,$src1,$src2,$mask\\t! using $scratch and k2 as TEMP\" %}\n-  effect(TEMP scratch);\n+  format %{ \"vector_blend  $dst,$src1,$src2,$mask\\t! using k2 as TEMP\" %}\n@@ -8017,1 +8007,1 @@\n-instruct vabsnegF(vec dst, vec src, rRegI scratch) %{\n+instruct vabsnegF(vec dst, vec src) %{\n@@ -8021,1 +8011,0 @@\n-  effect(TEMP scratch);\n@@ -8028,1 +8017,1 @@\n-      __ vabsnegf(opcode, $dst$$XMMRegister, $src$$XMMRegister, $scratch$$Register);\n+      __ vabsnegf(opcode, $dst$$XMMRegister, $src$$XMMRegister);\n@@ -8032,1 +8021,1 @@\n-      __ vabsnegf(opcode, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc, $scratch$$Register);\n+      __ vabsnegf(opcode, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n@@ -8038,1 +8027,1 @@\n-instruct vabsneg4F(vec dst, rRegI scratch) %{\n+instruct vabsneg4F(vec dst) %{\n@@ -8042,1 +8031,0 @@\n-  effect(TEMP scratch);\n@@ -8047,1 +8035,1 @@\n-    __ vabsnegf(opcode, $dst$$XMMRegister, $dst$$XMMRegister, $scratch$$Register);\n+    __ vabsnegf(opcode, $dst$$XMMRegister, $dst$$XMMRegister);\n@@ -8052,1 +8040,1 @@\n-instruct vabsnegD(vec dst, vec src, rRegI scratch) %{\n+instruct vabsnegD(vec dst, vec src) %{\n@@ -8055,1 +8043,0 @@\n-  effect(TEMP scratch);\n@@ -8062,1 +8049,1 @@\n-      __ vabsnegd(opcode, $dst$$XMMRegister, $src$$XMMRegister, $scratch$$Register);\n+      __ vabsnegd(opcode, $dst$$XMMRegister, $src$$XMMRegister);\n@@ -8065,1 +8052,1 @@\n-      __ vabsnegd(opcode, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc, $scratch$$Register);\n+      __ vabsnegd(opcode, $dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n@@ -8257,1 +8244,1 @@\n-instruct loadMask64(kReg dst, vec src, vec xtmp, rRegI tmp) %{\n+instruct loadMask64(kReg dst, vec src, vec xtmp) %{\n@@ -8260,2 +8247,2 @@\n-  effect(TEMP xtmp, TEMP tmp);\n-  format %{ \"vector_loadmask_64byte $dst, $src\\t! using $xtmp and $tmp as TEMP\" %}\n+  effect(TEMP xtmp);\n+  format %{ \"vector_loadmask_64byte $dst, $src\\t! using $xtmp as TEMP\" %}\n@@ -8264,1 +8251,1 @@\n-                        $tmp$$Register, true, Assembler::AVX_512bit);\n+                        true, Assembler::AVX_512bit);\n@@ -8277,1 +8264,1 @@\n-                        noreg, false, vlen_enc);\n+                        false, vlen_enc);\n@@ -8374,1 +8361,1 @@\n-    __ vpshufps($dst$$XMMRegister, $src$$XMMRegister, $src$$XMMRegister, 0x88, Assembler::AVX_256bit);\n+    __ vshufps($dst$$XMMRegister, $src$$XMMRegister, $src$$XMMRegister, 0x88, Assembler::AVX_256bit);\n@@ -8417,1 +8404,1 @@\n-instruct vstoreMask_evex_vectmask(vec dst, kReg mask, immI size, rRegI tmp) %{\n+instruct vstoreMask_evex_vectmask(vec dst, kReg mask, immI size) %{\n@@ -8420,1 +8407,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp);\n+  effect(TEMP_DEF dst);\n@@ -8425,1 +8412,1 @@\n-                 false, Assembler::AVX_512bit, $tmp$$Register);\n+                 false, Assembler::AVX_512bit, noreg);\n@@ -8469,1 +8456,1 @@\n-instruct loadIotaIndices(vec dst, immI_0 src, rRegP scratch) %{\n+instruct loadIotaIndices(vec dst, immI_0 src) %{\n@@ -8472,1 +8459,0 @@\n-  effect(TEMP scratch);\n@@ -8476,1 +8462,1 @@\n-     __ load_iota_indices($dst$$XMMRegister, $scratch$$Register, vlen_in_bytes);\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes);\n@@ -8482,1 +8468,1 @@\n-instruct VectorPopulateIndex(vec dst, rRegI src1, immI_1 src2, vec vtmp, rRegP scratch) %{\n+instruct VectorPopulateIndex(vec dst, rRegI src1, immI_1 src2, vec vtmp) %{\n@@ -8484,2 +8470,2 @@\n-  effect(TEMP dst, TEMP vtmp, TEMP scratch);\n-  format %{ \"vector_populate_index $dst $src1 $src2\\t! using $vtmp and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp);\n+  format %{ \"vector_populate_index $dst $src1 $src2\\t! using $vtmp as TEMP\" %}\n@@ -8492,1 +8478,1 @@\n-     __ load_iota_indices($dst$$XMMRegister, $scratch$$Register, vlen);\n+     __ load_iota_indices($dst$$XMMRegister, vlen);\n@@ -8501,1 +8487,1 @@\n-instruct VectorPopulateLIndex(vec dst, rRegL src1, immI_1 src2, vec vtmp, rRegP scratch) %{\n+instruct VectorPopulateLIndex(vec dst, rRegL src1, immI_1 src2, vec vtmp) %{\n@@ -8503,2 +8489,2 @@\n-  effect(TEMP dst, TEMP vtmp, TEMP scratch);\n-  format %{ \"vector_populate_index $dst $src1 $src2\\t! using $vtmp and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp);\n+  format %{ \"vector_populate_index $dst $src1 $src2\\t! using $vtmp as TEMP\" %}\n@@ -8511,1 +8497,1 @@\n-     __ load_iota_indices($dst$$XMMRegister, $scratch$$Register, vlen);\n+     __ load_iota_indices($dst$$XMMRegister, vlen);\n@@ -8546,1 +8532,1 @@\n-instruct rearrangeB_avx(legVec dst, legVec src, vec shuffle, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n+instruct rearrangeB_avx(legVec dst, legVec src, vec shuffle, legVec vtmp1, legVec vtmp2) %{\n@@ -8550,2 +8536,2 @@\n-  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n-  format %{ \"vector_rearrange $dst, $shuffle, $src\\t! using $vtmp1, $vtmp2, $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"vector_rearrange $dst, $shuffle, $src\\t! using $vtmp1, $vtmp2 as TEMP\" %}\n@@ -8561,1 +8547,1 @@\n-    __ vpaddb($vtmp2$$XMMRegister, $shuffle$$XMMRegister, ExternalAddress(vector_byte_shufflemask()), Assembler::AVX_256bit, $scratch$$Register);\n+    __ vpaddb($vtmp2$$XMMRegister, $shuffle$$XMMRegister, ExternalAddress(vector_byte_shufflemask()), Assembler::AVX_256bit, noreg);\n@@ -8568,1 +8554,17 @@\n-instruct rearrangeB_evex(vec dst, vec src, vec shuffle) %{\n+\n+instruct rearrangeB_evex(vec dst, vec src, vec shuffle, vec xtmp1, vec xtmp2, vec xtmp3, kReg ktmp, rRegI rtmp) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE &&\n+            Matcher::vector_length(n) > 32 && !VM_Version::supports_avx512_vbmi());\n+  match(Set dst (VectorRearrange src shuffle));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP ktmp, TEMP rtmp);\n+  format %{ \"vector_rearrange $dst, $shuffle, $src!\\t using $xtmp1, $xtmp2, $xtmp3, $rtmp and $ktmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ rearrange_bytes($dst$$XMMRegister, $shuffle$$XMMRegister, $src$$XMMRegister,\n+                       $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $xtmp3$$XMMRegister,\n+                       $rtmp$$Register, $ktmp$$KRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct rearrangeB_evex_vbmi(vec dst, vec src, vec shuffle) %{\n@@ -8582,1 +8584,1 @@\n-instruct loadShuffleS(vec dst, vec src, vec vtmp, rRegP scratch) %{\n+instruct loadShuffleS(vec dst, vec src, vec vtmp) %{\n@@ -8586,2 +8588,2 @@\n-  effect(TEMP dst, TEMP vtmp, TEMP scratch);\n-  format %{ \"vector_load_shuffle $dst, $src\\t! using $vtmp and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp);\n+  format %{ \"vector_load_shuffle $dst, $src\\t! using $vtmp as TEMP\" %}\n@@ -8604,1 +8606,1 @@\n-      __ movdqu($vtmp$$XMMRegister, ExternalAddress(vector_short_shufflemask()), $scratch$$Register);\n+      __ movdqu($vtmp$$XMMRegister, ExternalAddress(vector_short_shufflemask()), noreg);\n@@ -8618,1 +8620,1 @@\n-      __ vpaddb($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_short_shufflemask()), vlen_enc, $scratch$$Register);\n+      __ vpaddb($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_short_shufflemask()), vlen_enc, noreg);\n@@ -8636,1 +8638,1 @@\n-instruct rearrangeS_avx(legVec dst, legVec src, vec shuffle, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n+instruct rearrangeS_avx(legVec dst, legVec src, vec shuffle, legVec vtmp1, legVec vtmp2) %{\n@@ -8640,2 +8642,2 @@\n-  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n-  format %{ \"vector_rearrange $dst, $shuffle, $src\\t! using $vtmp1, $vtmp2, $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2);\n+  format %{ \"vector_rearrange $dst, $shuffle, $src\\t! using $vtmp1, $vtmp2 as TEMP\" %}\n@@ -8651,1 +8653,1 @@\n-    __ vpaddb($vtmp2$$XMMRegister, $shuffle$$XMMRegister, ExternalAddress(vector_byte_shufflemask()), Assembler::AVX_256bit, $scratch$$Register);\n+    __ vpaddb($vtmp2$$XMMRegister, $shuffle$$XMMRegister, ExternalAddress(vector_byte_shufflemask()), Assembler::AVX_256bit, noreg);\n@@ -8690,1 +8692,1 @@\n-instruct loadShuffleI(vec dst, vec src, vec vtmp, rRegP scratch) %{\n+instruct loadShuffleI(vec dst, vec src, vec vtmp) %{\n@@ -8694,2 +8696,2 @@\n-  effect(TEMP dst, TEMP vtmp, TEMP scratch);\n-  format %{ \"vector_load_shuffle $dst, $src\\t! using $vtmp and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp);\n+  format %{ \"vector_load_shuffle $dst, $src\\t! using $vtmp as TEMP\" %}\n@@ -8714,1 +8716,1 @@\n-    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_int_shufflemask()), $scratch$$Register);\n+    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_int_shufflemask()), noreg);\n@@ -8761,1 +8763,1 @@\n-instruct loadShuffleL(vec dst, vec src, vec vtmp, rRegP scratch) %{\n+instruct loadShuffleL(vec dst, vec src, vec vtmp) %{\n@@ -8765,2 +8767,2 @@\n-  effect(TEMP dst, TEMP vtmp, TEMP scratch);\n-  format %{ \"vector_load_shuffle $dst, $src\\t! using $vtmp and $scratch as TEMP\" %}\n+  effect(TEMP dst, TEMP vtmp);\n+  format %{ \"vector_load_shuffle $dst, $src\\t! using $vtmp as TEMP\" %}\n@@ -8783,1 +8785,1 @@\n-    __ vpaddd($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_long_shufflemask()), vlen_enc, $scratch$$Register);\n+    __ vpaddd($dst$$XMMRegister, $dst$$XMMRegister, ExternalAddress(vector_long_shufflemask()), vlen_enc, noreg);\n@@ -9418,1 +9420,1 @@\n-instruct vreverse_reg_gfni(vec dst, vec src, vec xtmp, rRegI rtmp) %{\n+instruct vreverse_reg_gfni(vec dst, vec src, vec xtmp) %{\n@@ -9421,2 +9423,2 @@\n-  effect(TEMP dst, TEMP xtmp, TEMP rtmp);\n-  format %{ \"vector_reverse_bit_gfni $dst, $src!\\t using $rtmp and $xtmp as TEMP\" %}\n+  effect(TEMP dst, TEMP xtmp);\n+  format %{ \"vector_reverse_bit_gfni $dst, $src!\\t using $xtmp as TEMP\" %}\n@@ -9427,2 +9429,2 @@\n-    __ vector_reverse_bit_gfni(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister,\n-                               addr, $rtmp$$Register, vec_enc);\n+    __ vector_reverse_bit_gfni(bt, $dst$$XMMRegister, $src$$XMMRegister, addr, vec_enc,\n+                               $xtmp$$XMMRegister);\n@@ -9433,1 +9435,1 @@\n-instruct vreverse_byte_reg(vec dst, vec src, rRegI rtmp) %{\n+instruct vreverse_byte_reg(vec dst, vec src) %{\n@@ -9436,2 +9438,2 @@\n-  effect(TEMP dst, TEMP rtmp);\n-  format %{ \"vector_reverse_byte $dst, $src!\\t using $rtmp as TEMP\" %}\n+  effect(TEMP dst);\n+  format %{ \"vector_reverse_byte $dst, $src\" %}\n@@ -9441,1 +9443,1 @@\n-    __ vector_reverse_byte(bt, $dst$$XMMRegister, $src$$XMMRegister, $rtmp$$Register, vec_enc);\n+    __ vector_reverse_byte(bt, $dst$$XMMRegister, $src$$XMMRegister, vec_enc);\n@@ -10120,1 +10122,1 @@\n-instruct evcmp_masked(kReg dst, vec src1, vec src2, immI8 cond, kReg mask, rRegP scratch) %{\n+instruct evcmp_masked(kReg dst, vec src1, vec src2, immI8 cond, kReg mask) %{\n@@ -10122,2 +10124,1 @@\n-  effect(TEMP scratch);\n-  format %{ \"vcmp_masked $dst, $src1, $src2, $cond, $mask\\t! using $scratch as TEMP\" %}\n+  format %{ \"vcmp_masked $dst, $src1, $src2, $cond, $mask\" %}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":395,"deletions":394,"binary":false,"changes":789,"status":"modified"},{"patch":"@@ -258,1 +258,2 @@\n-#define   HIGH_FROM_LOW(x) ((x)+2)\n+#define   HIGH_FROM_LOW(x) (as_Register((x)->encoding()+2))\n+#define   HIGH_FROM_LOW_ENC(x) ((x)+2)\n@@ -1650,1 +1651,1 @@\n-    emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -1661,1 +1662,1 @@\n-    int desthi = HIGH_FROM_LOW(destlo);\n+    int desthi = HIGH_FROM_LOW_ENC(destlo);\n@@ -1946,1 +1947,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1954,1 +1955,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1958,1 +1959,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2083,1 +2084,1 @@\n-    int reg_encoding = HIGH_FROM_LOW($ereg$$reg);  \/\/ Hi register of pair, computed from lo\n+    int reg_encoding = HIGH_FROM_LOW_ENC($ereg$$reg);  \/\/ Hi register of pair, computed from lo\n@@ -2094,2 +2095,2 @@\n-    if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }\n-    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }\n+    if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW_ENC($dst$$reg); }\n+    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW_ENC($dst$$reg); }\n@@ -2107,1 +2108,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2114,1 +2115,1 @@\n-    emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2120,2 +2121,2 @@\n-    if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }\n-    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }\n+    if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW_ENC($dst$$reg); }\n+    else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW_ENC($dst$$reg); }\n@@ -2265,1 +2266,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n@@ -2273,1 +2274,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2289,1 +2290,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2292,1 +2293,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($dst$$reg));\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2297,1 +2298,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n@@ -2300,1 +2301,1 @@\n-    emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2313,1 +2314,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2316,1 +2317,1 @@\n-    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2322,1 +2323,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n@@ -2325,1 +2326,1 @@\n-    emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2655,1 +2656,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2671,1 +2672,1 @@\n-    encode_Copy( cbuf, HIGH_FROM_LOW(dst_encoding), src_encoding );\n+    encode_Copy( cbuf, HIGH_FROM_LOW_ENC(dst_encoding), src_encoding );\n@@ -2674,1 +2675,1 @@\n-    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW(dst_encoding) );\n+    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW_ENC(dst_encoding) );\n@@ -2680,1 +2681,1 @@\n-    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));\n+    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2710,1 +2711,1 @@\n-    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));\n+    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2742,1 +2743,1 @@\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2744,1 +2745,1 @@\n-    encode_Copy( cbuf, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg) );\n+    encode_Copy( cbuf, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg) );\n@@ -2748,1 +2749,1 @@\n-    emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );\n+    emit_rm( cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n@@ -2751,1 +2752,1 @@\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2757,1 +2758,1 @@\n-    emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $tmp$$reg );\n+    emit_rm( cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $tmp$$reg );\n@@ -2765,1 +2766,1 @@\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );\n+    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2780,1 +2781,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n@@ -2784,1 +2785,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n@@ -2801,1 +2802,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n@@ -2805,1 +2806,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );\n+    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n@@ -2826,1 +2827,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg));\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2838,1 +2839,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );\n+    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2847,1 +2848,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src1$$reg) );\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src1$$reg) );\n@@ -2850,1 +2851,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src2$$reg) );\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2862,1 +2863,1 @@\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg) );\n+    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg) );\n@@ -2868,1 +2869,1 @@\n-    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2872,1 +2873,1 @@\n-    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));\n+    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -7257,55 +7258,0 @@\n-\/\/ Load-locked - same as a regular pointer load when used with compare-swap\n-instruct loadPLocked(eRegP dst, memory mem) %{\n-  match(Set dst (LoadPLocked mem));\n-\n-  ins_cost(125);\n-  format %{ \"MOV    $dst,$mem\\t# Load ptr. locked\" %}\n-  opcode(0x8B);\n-  ins_encode( OpcP, RegMem(dst,mem));\n-  ins_pipe( ialu_reg_mem );\n-%}\n-\n-\/\/ Conditional-store of the updated heap-top.\n-\/\/ Used during allocation of the shared heap.\n-\/\/ Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.\n-instruct storePConditional( memory heap_top_ptr, eAXRegP oldval, eRegP newval, eFlagsReg cr ) %{\n-  match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));\n-  \/\/ EAX is killed if there is contention, but then it's also unused.\n-  \/\/ In the common case of no contention, EAX holds the new oop address.\n-  format %{ \"CMPXCHG $heap_top_ptr,$newval\\t# If EAX==$heap_top_ptr Then store $newval into $heap_top_ptr\" %}\n-  ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval,heap_top_ptr) );\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-\/\/ Conditional-store of an int value.\n-\/\/ ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG on Intel.\n-instruct storeIConditional( memory mem, eAXRegI oldval, rRegI newval, eFlagsReg cr ) %{\n-  match(Set cr (StoreIConditional mem (Binary oldval newval)));\n-  effect(KILL oldval);\n-  format %{ \"CMPXCHG $mem,$newval\\t# If EAX==$mem Then store $newval into $mem\" %}\n-  ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval, mem) );\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n-\/\/ Conditional-store of a long value.\n-\/\/ ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG8 on Intel.\n-instruct storeLConditional( memory mem, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{\n-  match(Set cr (StoreLConditional mem (Binary oldval newval)));\n-  effect(KILL oldval);\n-  format %{ \"XCHG   EBX,ECX\\t# correct order for CMPXCHG8 instruction\\n\\t\"\n-            \"CMPXCHG8 $mem,ECX:EBX\\t# If EDX:EAX==$mem Then store ECX:EBX into $mem\\n\\t\"\n-            \"XCHG   EBX,ECX\"\n-  %}\n-  ins_encode %{\n-    \/\/ Note: we need to swap rbx, and rcx before and after the\n-    \/\/       cmpxchg8 instruction because the instruction uses\n-    \/\/       rcx as the high order word of the new value to store but\n-    \/\/       our register encoding uses rbx.\n-    __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));\n-    __ lock();\n-    __ cmpxchg8($mem$$Address);\n-    __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));\n-  %}\n-  ins_pipe( pipe_cmpxchg );\n-%}\n-\n@@ -12683,1 +12629,1 @@\n-    __ jump(ArrayAddress($constantaddress, index));\n+    __ jump(ArrayAddress($constantaddress, index), noreg);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":47,"deletions":101,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -6194,1 +6194,1 @@\n-      __ movl($mem$$Address, (int32_t)0);\n+      __ movl($mem$$Address, 0);\n@@ -6757,0 +6757,44 @@\n+\/\/--------------- Reverse Operation Instructions ----------------\n+instruct bytes_reversebit_int(rRegI dst, rRegI src, rRegI rtmp, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_gfni());\n+  match(Set dst (ReverseI src));\n+  effect(TEMP dst, TEMP rtmp, KILL cr);\n+  format %{ \"reverse_int $dst $src\\t! using $rtmp as TEMP\" %}\n+  ins_encode %{\n+    __ reverseI($dst$$Register, $src$$Register, xnoreg, xnoreg, $rtmp$$Register);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct bytes_reversebit_int_gfni(rRegI dst, rRegI src, regF xtmp1, regF xtmp2, rRegL rtmp, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_gfni());\n+  match(Set dst (ReverseI src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp, KILL cr);\n+  format %{ \"reverse_int $dst $src\\t! using $rtmp, $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ reverseI($dst$$Register, $src$$Register, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $rtmp$$Register);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct bytes_reversebit_long(rRegL dst, rRegL src, rRegL rtmp1, rRegL rtmp2, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_gfni());\n+  match(Set dst (ReverseL src));\n+  effect(TEMP dst, TEMP rtmp1, TEMP rtmp2, KILL cr);\n+  format %{ \"reverse_long $dst $src\\t! using $rtmp1 and $rtmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ reverseL($dst$$Register, $src$$Register, xnoreg, xnoreg, $rtmp1$$Register, $rtmp2$$Register);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct bytes_reversebit_long_gfni(rRegL dst, rRegL src, regD xtmp1, regD xtmp2, rRegL rtmp, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_gfni());\n+  match(Set dst (ReverseL src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp, KILL cr);\n+  format %{ \"reverse_long $dst $src\\t! using $rtmp, $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    __ reverseL($dst$$Register, $src$$Register, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $rtmp$$Register, noreg);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n@@ -8073,65 +8117,0 @@\n-\/\/ LoadP-locked same as a regular LoadP when used with compare-swap\n-instruct loadPLocked(rRegP dst, memory mem)\n-%{\n-  match(Set dst (LoadPLocked mem));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movq    $dst, $mem\\t# ptr locked\" %}\n-  ins_encode %{\n-    __ movq($dst$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(ialu_reg_mem); \/\/ XXX\n-%}\n-\n-\/\/ Conditional-store of the updated heap-top.\n-\/\/ Used during allocation of the shared heap.\n-\/\/ Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.\n-\n-instruct storePConditional(memory heap_top_ptr,\n-                           rax_RegP oldval, rRegP newval,\n-                           rFlagsReg cr)\n-%{\n-  predicate(n->as_LoadStore()->barrier_data() == 0);\n-  match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));\n-\n-  format %{ \"cmpxchgq $heap_top_ptr, $newval\\t# (ptr) \"\n-            \"If rax == $heap_top_ptr then store $newval into $heap_top_ptr\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgq($newval$$Register, $heap_top_ptr$$Address);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-\/\/ Conditional-store of an int value.\n-\/\/ ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.\n-instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StoreIConditional mem (Binary oldval newval)));\n-  effect(KILL oldval);\n-\n-  format %{ \"cmpxchgl $mem, $newval\\t# If rax == $mem then store $newval into $mem\" %}\n-  opcode(0x0F, 0xB1);\n-  ins_encode(lock_prefix,\n-             REX_reg_mem(newval, mem),\n-             OpcP, OpcS,\n-             reg_mem(newval, mem));\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-\/\/ Conditional-store of a long value.\n-\/\/ ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.\n-instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)\n-%{\n-  match(Set cr (StoreLConditional mem (Binary oldval newval)));\n-  effect(KILL oldval);\n-\n-  format %{ \"cmpxchgq $mem, $newval\\t# If rax == $mem then store $newval into $mem\" %}\n-  ins_encode %{\n-    __ lock();\n-    __ cmpxchgq($newval$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(pipe_cmpxchg);\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":45,"deletions":66,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    _is_mach_constant(false),\n+    _is_mach_constant(instr->_is_mach_constant),\n@@ -3517,2 +3517,0 @@\n-    \"LoadPLocked\",\n-    \"StorePConditional\", \"StoreIConditional\", \"StoreLConditional\",\n@@ -4096,6 +4094,0 @@\n-        strcmp(opType,\"ReplicateB\")==0 ||\n-        strcmp(opType,\"ReplicateS\")==0 ||\n-        strcmp(opType,\"ReplicateI\")==0 ||\n-        strcmp(opType,\"ReplicateL\")==0 ||\n-        strcmp(opType,\"ReplicateF\")==0 ||\n-        strcmp(opType,\"ReplicateD\")==0 ||\n@@ -4117,1 +4109,1 @@\n-        0 \/* 0 to line up columns nicely *\/ )\n+        0 \/* 0 to line up columns nicely *\/ ) {\n@@ -4119,0 +4111,1 @@\n+    }\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"compiler\/compiler_globals.hpp\"\n@@ -34,0 +33,2 @@\n+#include \"utilities\/linkedlist.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -271,1 +272,1 @@\n-  csize_t align_at_start(csize_t off, int section) const {\n+  static csize_t align_at_start(csize_t off, int section) {\n@@ -276,1 +277,1 @@\n-    return (csize_t) align_up(off, alignment(_index));\n+    return align_at_start(off, _index);\n@@ -408,0 +409,3 @@\n+  typedef LinkedListImpl<int> Offsets;\n+  typedef ResizeableResourceHashtable<address, Offsets> SharedTrampolineRequests;\n+\n@@ -434,0 +438,1 @@\n+  SharedTrampolineRequests*   _shared_trampoline_requests;     \/\/ used to collect requests for shared trampolines\n@@ -455,0 +460,1 @@\n+    _shared_trampoline_requests = NULL;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -796,1 +796,1 @@\n-        If* canon = new If(cmp->x(), cond, nan_sux == tsux, cmp->y(), tsux, fsux, cmp->state_before(), x->is_safepoint());\n+        If* canon = new If(cmp->x(), cond, nan_sux == tsux, cmp->y(), tsux, fsux, x->state_before(), x->is_safepoint());\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -718,14 +718,1 @@\n-void Compilation::compile_only_this_method() {\n-  ResourceMark rm;\n-  fileStream stream(os::fopen(\"c1_compile_only\", \"wt\"));\n-  stream.print_cr(\"# c1 compile only directives\");\n-  compile_only_this_scope(&stream, hir()->top_scope());\n-}\n-\n-void Compilation::compile_only_this_scope(outputStream* st, IRScope* scope) {\n-  st->print(\"CompileOnly=\");\n-  scope->method()->holder()->name()->print_symbol_on(st);\n-  st->print(\".\");\n-  scope->method()->name()->print_symbol_on(st);\n-  st->cr();\n-}\n+void CompilationResourceObj::print() const       { print_on(tty); }\n@@ -733,8 +720,2 @@\n-void Compilation::exclude_this_method() {\n-  fileStream stream(os::fopen(\".hotspot_compiler\", \"at\"));\n-  stream.print(\"exclude \");\n-  method()->holder()->name()->print_symbol_on(&stream);\n-  stream.print(\" \");\n-  method()->name()->print_symbol_on(&stream);\n-  stream.cr();\n-  stream.cr();\n+void CompilationResourceObj::print_on(outputStream* st) const {\n+  st->print_cr(\"CompilationResourceObj(\" INTPTR_FORMAT \")\", p2i(this));\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -224,10 +225,0 @@\n-#ifndef PRODUCT\n-  \/\/ debugging support.\n-  \/\/ produces a file named c1compileonly in the current directory with\n-  \/\/ directives to compile only the current method and it's inlines.\n-  \/\/ The file can be passed to the command line option -XX:Flags=<filename>\n-  void compile_only_this_method();\n-  void compile_only_this_scope(outputStream* st, IRScope* scope);\n-  void exclude_this_method();\n-#endif \/\/ PRODUCT\n-\n@@ -271,3 +262,0 @@\n-  bool age_code() const {\n-    return _method->profile_aging();\n-  }\n@@ -342,1 +330,1 @@\n-class CompilationResourceObj ALLOCATION_SUPER_CLASS_SPEC {\n+class CompilationResourceObj {\n@@ -349,0 +337,6 @@\n+\n+#ifndef PRODUCT\n+  \/\/ Printing support\n+  void print() const;\n+  virtual void print_on(outputStream* st) const;\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -3126,4 +3127,0 @@\n-  if (compilation()->age_code()) {\n-    CodeEmitInfo* info = new CodeEmitInfo(scope()->start()->state()->copy(ValueStack::StateBefore, 0), NULL, false);\n-    decrement_age(info);\n-  }\n@@ -3814,21 +3811,0 @@\n-void LIRGenerator::decrement_age(CodeEmitInfo* info) {\n-  ciMethod* method = info->scope()->method();\n-  MethodCounters* mc_adr = method->ensure_method_counters();\n-  if (mc_adr != NULL) {\n-    LIR_Opr mc = new_pointer_register();\n-    __ move(LIR_OprFact::intptrConst(mc_adr), mc);\n-    int offset = in_bytes(MethodCounters::nmethod_age_offset());\n-    LIR_Address* counter = new LIR_Address(mc, offset, T_INT);\n-    LIR_Opr result = new_register(T_INT);\n-    __ load(counter, result);\n-    __ sub(result, LIR_OprFact::intConst(1), result);\n-    __ store(result, counter);\n-    \/\/ DeoptimizeStub will reexecute from the current state in code info.\n-    CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_tenured,\n-                                         Deoptimization::Action_make_not_entrant);\n-    __ cmp(lir_cond_lessEqual, result, LIR_OprFact::intConst(0));\n-    __ branch(lir_cond_lessEqual, deopt);\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -438,1 +438,0 @@\n-  void decrement_age(CodeEmitInfo* info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n@@ -162,0 +161,1 @@\n+  _dumped_to_src_obj_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE),\n@@ -628,0 +628,8 @@\n+  {\n+    bool created;\n+    _dumped_to_src_obj_table.put_if_absent((address)dest, src, &created);\n+    assert(created, \"must be\");\n+    if (_dumped_to_src_obj_table.maybe_grow()) {\n+      log_info(cds, hashtables)(\"Expanded _dumped_to_src_obj_table table to %d\", _dumped_to_src_obj_table.table_size());\n+    }\n+  }\n@@ -648,0 +656,7 @@\n+address ArchiveBuilder::get_src_obj(address dumped_addr) const {\n+  assert(is_in_buffer_space(dumped_addr), \"must be\");\n+  address* src_obj = _dumped_to_src_obj_table.get(dumped_addr);\n+  assert(src_obj != NULL && *src_obj != NULL, \"must be\");\n+  return *src_obj;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,0 +208,1 @@\n+  ResizeableResourceHashtable<address, address, ResourceObj::C_HEAP, mtClassShared> _dumped_to_src_obj_table;\n@@ -393,0 +394,6 @@\n+  \/\/ + When creating a CDS archive, we first load Java classes and create metadata\n+  \/\/   objects as usual. These are call \"source\" objects.\n+  \/\/ + We then copy the source objects into the output buffer at \"dumped addresses\".\n+  \/\/\n+  \/\/ The following functions translate between these two (non-overlapping) spaces.\n+  \/\/ (The API should be renamed to be less confusing!)\n@@ -394,0 +401,4 @@\n+  address get_src_obj(address dumped_addr) const;\n+  template <typename T> T get_src_obj(T dumped_addr) const {\n+    return (T)get_src_obj((address)dumped_addr);\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -323,0 +323,1 @@\n+#if INCLUDE_G1GC\n@@ -327,0 +328,1 @@\n+#endif\n@@ -528,2 +530,10 @@\n-      FileMapInfo::fail_continue(\"A jar file is not the one used while building\"\n-                                 \" the shared archive file: %s\", name);\n+      const char* bad_jar_msg = \"A jar file is not the one used while building the shared archive file:\";\n+      FileMapInfo::fail_continue(\"%s %s\", bad_jar_msg, name);\n+      if (!log_is_enabled(Info, cds)) {\n+        log_warning(cds)(\"%s %s\", bad_jar_msg, name);\n+      }\n+      if (_timestamp != st.st_mtime) {\n+        log_warning(cds)(\"%s timestamp has changed.\", name);\n+      } else {\n+        log_warning(cds)(\"%s size has changed.\", name);\n+      }\n@@ -1120,1 +1130,5 @@\n-      fail_continue(\"shared class paths mismatch (hint: enable -Xlog:class+path=info to diagnose the failure)\");\n+      const char* mismatch_msg = \"shared class paths mismatch (hint: enable -Xlog:class+path=info to diagnose the failure)\";\n+      fail_continue(\"%s\", mismatch_msg);\n+      if (!log_is_enabled(Info, cds) && !log_is_enabled(Info, class, path)) {\n+        log_warning(cds)(\"%s\", mismatch_msg);\n+      }\n@@ -1596,0 +1610,1 @@\n+#if INCLUDE_G1GC\n@@ -1597,0 +1612,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-#include \"runtime\/os.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n@@ -131,2 +131,3 @@\n-\/\/ os::vm_allocation_granularity() is usually 4K for most OSes. However, on Linux\/aarch64,\n-\/\/ it can be either 4K or 64K and on Macosx-arm it is 16K. To generate archives that are\n+\/\/ os::vm_allocation_granularity() is usually 4K for most OSes. However, some platforms\n+\/\/ such as linux-aarch64 and macos-x64 ...\n+\/\/ it can be either 4K or 64K and on macos-aarch64 it is 16K. To generate archives that are\n@@ -136,3 +137,3 @@\n-\/\/ Upon successful configuration, the compactible alignment then can be defined as in:\n-\/\/   os_linux_aarch64.hpp\n-\/\/ which is the highest page size configured on the platform.\n+\/\/ Upon successful configuration, the compactible alignment then can be defined in:\n+\/\/   os_linux_aarch64.cpp\n+\/\/   os_bsd_x86.cpp\n@@ -140,5 +141,1 @@\n-#if defined(CDS_CORE_REGION_ALIGNMENT)\n-  return CDS_CORE_REGION_ALIGNMENT;\n-#else\n-  return (size_t)os::vm_allocation_granularity();\n-#endif \/\/ CDS_CORE_REGION_ALIGNMENT\n+  return os::cds_core_region_alignment();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"compiler\/compilationLog.hpp\"\n@@ -379,1 +380,1 @@\n-    InstanceKlass* ik = SystemDictionary::find_instance_klass(name, Handle(), Handle());\n+    InstanceKlass* ik = SystemDictionary::find_instance_klass(THREAD, name, Handle(), Handle());\n@@ -532,1 +533,1 @@\n-      kls = SystemDictionary::find_instance_or_array_klass(sym, loader, domain);\n+      kls = SystemDictionary::find_instance_or_array_klass(current, sym, loader, domain);\n@@ -669,1 +670,0 @@\n-#ifndef PRODUCT\n@@ -674,1 +674,0 @@\n-#endif\n@@ -977,1 +976,0 @@\n-#ifdef ASSERT\n@@ -981,1 +979,0 @@\n-#endif\n@@ -1105,0 +1102,3 @@\n+    \/\/ Check if memory should be freed before allocation\n+    CodeCache::gc_on_allocation();\n+\n@@ -1182,1 +1182,1 @@\n-                               compiler, task()->comp_level());\n+                               compiler, CompLevel(task()->comp_level()));\n@@ -1196,6 +1196,0 @@\n-      \/\/ Record successful registration.\n-      \/\/ (Put nm into the task handle *before* publishing to the Java heap.)\n-      if (task() != NULL) {\n-        task()->set_code(nm);\n-      }\n-\n@@ -1242,1 +1236,1 @@\n-  }  \/\/ safepoints are allowed again\n+  }\n@@ -1244,0 +1238,1 @@\n+  NoSafepointVerifier nsv;\n@@ -1245,2 +1240,3 @@\n-    \/\/ JVMTI -- compiled method notification (must be done outside lock)\n-    nm->post_compiled_method_load_event();\n+    \/\/ Compilation succeeded, post what we know about it\n+    nm->post_compiled_method(task());\n+    task()->set_num_inlined_bytecodes(num_inlined_bytecodes());\n@@ -1251,0 +1247,2 @@\n+\n+  \/\/ safepoints are allowed again\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"ci\/ciReplay.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -196,9 +196,0 @@\n-#ifndef PRODUCT\n-      if (ReplayCompiles && o->is_klass()) {\n-        Klass* k = (Klass*)o;\n-        if (k->is_instance_klass() && ciReplay::is_klass_unresolved((InstanceKlass*)k)) {\n-          \/\/ Klass was unresolved at replay dump time. Simulate this case.\n-          return ciEnv::_unloaded_ciinstance_klass;\n-        }\n-      }\n-#endif\n@@ -405,1 +396,0 @@\n-\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -810,1 +810,1 @@\n-      InstanceKlass* k = SystemDictionary::find_instance_klass(name,\n+      InstanceKlass* k = SystemDictionary::find_instance_klass(THREAD, name,\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -76,3 +77,0 @@\n-  if (LogTouchedMethods) {\n-    h_m->log_touched(Thread::current());\n-  }\n@@ -145,1 +143,0 @@\n-  _nmethod_age = h_m->nmethod_age();\n@@ -159,1 +156,0 @@\n-#ifdef ASSERT\n@@ -163,1 +159,0 @@\n-#endif\n@@ -1259,9 +1254,0 @@\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciMethod::profile_aging\n-\/\/\n-\/\/ Should the method be compiled with an age counter?\n-bool ciMethod::profile_aging() const {\n-  return UseCodeAging && (!MethodCounters::is_nmethod_hot(nmethod_age()) &&\n-                          !MethodCounters::is_nmethod_age_unset(nmethod_age()));\n-}\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-  int _nmethod_age;\n@@ -195,4 +194,0 @@\n-  int nmethod_age() const                        { check_is_loaded(); return _nmethod_age; }\n-\n-  \/\/ Should the method be compiled with an age counter?\n-  bool profile_aging() const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -264,1 +264,0 @@\n-#ifndef PRODUCT\n@@ -271,1 +270,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"ci\/ciReplay.hpp\"\n@@ -291,0 +292,8 @@\n+  if (ReplayCompiles && key->is_klass()) {\n+    Klass* k = (Klass*)key;\n+    if (k->is_instance_klass() && ciReplay::is_klass_unresolved((InstanceKlass*)k)) {\n+      \/\/ Klass was unresolved at replay dump time. Simulate this case.\n+      return ciEnv::_unloaded_ciinstance_klass;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -60,2 +61,0 @@\n-#ifndef PRODUCT\n-\n@@ -1696,1 +1695,0 @@\n-#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n@@ -1014,5 +1013,1 @@\n-  GrowableArray<PackageEntry*>* loaded_class_pkgs = new GrowableArray<PackageEntry*>(50);\n-  {\n-    MutexLocker ml(THREAD, Module_lock);\n-\n-    PackageEntryTable* pe_table =\n+  PackageEntryTable* pe_table =\n@@ -1020,13 +1015,1 @@\n-\n-    \/\/ Collect the packages that have at least one loaded class.\n-    for (int x = 0; x < pe_table->table_size(); x++) {\n-      for (PackageEntry* package_entry = pe_table->bucket(x);\n-           package_entry != NULL;\n-           package_entry = package_entry->next()) {\n-        if (package_entry->has_loaded_class()) {\n-          loaded_class_pkgs->append(package_entry);\n-        }\n-      }\n-    }\n-  }\n-\n+  GrowableArray<PackageEntry*>* loaded_class_pkgs = pe_table->get_system_packages();\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-    _packages = new PackageEntryTable(PackageEntryTable::_packagetable_entry_size);\n+    _packages = new PackageEntryTable();\n@@ -414,7 +414,1 @@\n-    for (int i = 0; i < _modules->table_size(); i++) {\n-      for (ModuleEntry* entry = _modules->bucket(i);\n-           entry != NULL;\n-           entry = entry->next()) {\n-        f(entry);\n-      }\n-    }\n+    _modules->modules_do(f);\n@@ -427,7 +421,1 @@\n-    for (int i = 0; i < _packages->table_size(); i++) {\n-      for (PackageEntry* entry = _packages->bucket(i);\n-           entry != NULL;\n-           entry = entry->next()) {\n-        f(entry);\n-      }\n-    }\n+    _packages->packages_do(f);\n@@ -608,1 +596,1 @@\n-      modules = new ModuleEntryTable(ModuleEntryTable::_moduletable_entry_size);\n+      modules = new ModuleEntryTable();\n@@ -731,1 +719,1 @@\n-    _unnamed_module->delete_unnamed_module();\n+    delete _unnamed_module;\n@@ -1060,0 +1048,4 @@\n+\n+  if (_modules != NULL) {\n+    _modules->verify();\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -253,0 +253,2 @@\n+  OopHandle class_loader_handle() const { return _class_loader; }\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,20 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class PlaceholderKey {\n+  Symbol* _name;\n+  ClassLoaderData* _loader_data;\n+ public:\n+  PlaceholderKey(Symbol* name, ClassLoaderData* l) : _name(name), _loader_data(l) {}\n+\n+  static bool equals(PlaceholderKey const& k1, PlaceholderKey const& k2) {\n+    return (k1._name == k2._name && k1._loader_data == k2._loader_data);\n+  }\n+  static unsigned hash(PlaceholderKey const& k) {\n+    return (unsigned) k._name->identity_hash() ^ (int)((intptr_t)k._loader_data >> 3);\n+  }\n+  void print_on(outputStream* st) const;\n+};\n+\n+const int _placeholder_table_size = 503;   \/\/ Does this really have to be prime?\n+ResourceHashtable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, ResourceObj::C_HEAP, mtClass,\n+                  PlaceholderKey::hash, PlaceholderKey::equals> _placeholders;\n@@ -184,25 +203,0 @@\n-PlaceholderEntry* PlaceholderTable::new_entry(int hash, Symbol* name,\n-                                              ClassLoaderData* loader_data,\n-                                              Symbol* supername) {\n-  PlaceholderEntry* entry = (PlaceholderEntry*)Hashtable<Symbol*, mtClass>::new_entry(hash, name);\n-  \/\/ Hashtable with Symbol* literal must increment and decrement refcount.\n-  name->increment_refcount();\n-  entry->set_loader_data(loader_data);\n-  entry->set_supername(supername);\n-  entry->set_superThreadQ(NULL);\n-  entry->set_loadInstanceThreadQ(NULL);\n-  entry->set_defineThreadQ(NULL);\n-  entry->set_inlineTypeFieldQ(NULL);\n-  entry->set_definer(NULL);\n-  entry->set_instance_klass(NULL);\n-  return entry;\n-}\n-\n-void PlaceholderTable::free_entry(PlaceholderEntry* entry) {\n-  \/\/ decrement Symbol refcount here because Hashtable doesn't.\n-  entry->literal()->decrement_refcount();\n-  if (entry->supername() != NULL) entry->supername()->decrement_refcount();\n-  BasicHashtable<mtClass>::free_entry(entry);\n-}\n-\n-\n@@ -213,3 +207,2 @@\n-PlaceholderEntry* PlaceholderTable::add_entry(unsigned int hash,\n-                                              Symbol* class_name, ClassLoaderData* loader_data,\n-                                              Symbol* supername){\n+PlaceholderEntry* add_entry(Symbol* class_name, ClassLoaderData* loader_data,\n+                            Symbol* supername){\n@@ -219,6 +212,9 @@\n-  \/\/ Both readers and writers are locked so it's safe to just\n-  \/\/ create the placeholder and insert it in the list without a membar.\n-  PlaceholderEntry* entry = new_entry(hash, class_name, loader_data, supername);\n-  int index = hash_to_index(hash);\n-  Hashtable<Symbol*, mtClass>::add_entry(index, entry);\n-  return entry;\n+  PlaceholderEntry entry;\n+  entry.set_supername(supername);\n+  PlaceholderKey key(class_name, loader_data);\n+  \/\/ Since we're storing this key in the hashtable, we need to increment the refcount.\n+  class_name->increment_refcount();\n+  bool created;\n+  PlaceholderEntry* table_copy = _placeholders.put_if_absent(key, entry, &created);\n+  assert(created, \"better be absent\");\n+  return table_copy;\n@@ -227,22 +223,1 @@\n-\n-void PlaceholderTable::remove_entry(unsigned int hash,\n-                                    Symbol* class_name,\n-                                    ClassLoaderData* loader_data) {\n-  assert_locked_or_safepoint(SystemDictionary_lock);\n-  int index = hash_to_index(hash);\n-  PlaceholderEntry** p = bucket_addr(index);\n-  while (*p != NULL) {\n-    PlaceholderEntry *probe = *p;\n-    if (probe->hash() == hash && probe->equals(class_name, loader_data)) {\n-      \/\/ Delete entry\n-      *p = probe->next();\n-      free_entry(probe);\n-      return;\n-    }\n-    p = probe->next_addr();\n-  }\n-}\n-\n-PlaceholderEntry* PlaceholderTable::get_entry(unsigned int hash,\n-                                              Symbol* class_name,\n-                                              ClassLoaderData* loader_data) {\n+void remove_entry(Symbol* class_name, ClassLoaderData* loader_data) {\n@@ -252,10 +227,4 @@\n-  int index = hash_to_index(hash);\n-  for (PlaceholderEntry *place_probe = bucket(index);\n-                         place_probe != NULL;\n-                         place_probe = place_probe->next()) {\n-    if (place_probe->hash() == hash &&\n-        place_probe->equals(class_name, loader_data)) {\n-      return place_probe;\n-    }\n-  }\n-  return NULL;\n+  PlaceholderKey key(class_name, loader_data);\n+  _placeholders.remove(key);\n+  \/\/ Decrement the refcount in key, since it's no longer in the table.\n+  class_name->decrement_refcount();\n@@ -264,5 +233,5 @@\n-Symbol* PlaceholderTable::find_entry(unsigned int hash,\n-                                     Symbol* class_name,\n-                                     ClassLoaderData* loader_data) {\n-  PlaceholderEntry* probe = get_entry(hash, class_name, loader_data);\n-  return (probe != NULL ? probe->klassname() : NULL);\n+\n+PlaceholderEntry* PlaceholderTable::get_entry(Symbol* class_name, ClassLoaderData* loader_data) {\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  PlaceholderKey key(class_name, loader_data);\n+  return _placeholders.get(key);\n@@ -287,1 +256,1 @@\n-    entry->print_entry(&ls);\n+    entry->print_on(&ls);\n@@ -296,2 +265,1 @@\n-PlaceholderEntry* PlaceholderTable::find_and_add(unsigned int hash,\n-                                                 Symbol* name,\n+PlaceholderEntry* PlaceholderTable::find_and_add(Symbol* name,\n@@ -303,1 +271,1 @@\n-  PlaceholderEntry* probe = get_entry(hash, name, loader_data);\n+  PlaceholderEntry* probe = get_entry(name, loader_data);\n@@ -306,1 +274,1 @@\n-    probe = add_entry(hash, name, loader_data, supername);\n+    probe = add_entry(name, loader_data, supername);\n@@ -331,2 +299,1 @@\n-void PlaceholderTable::find_and_remove(unsigned int hash,\n-                                       Symbol* name, ClassLoaderData* loader_data,\n+void PlaceholderTable::find_and_remove(Symbol* name, ClassLoaderData* loader_data,\n@@ -335,11 +302,11 @@\n-    assert_locked_or_safepoint(SystemDictionary_lock);\n-    PlaceholderEntry *probe = get_entry(hash, name, loader_data);\n-    if (probe != NULL) {\n-       log(probe, \"find_and_remove\", action);\n-       probe->remove_seen_thread(thread, action);\n-       \/\/ If no other threads using this entry, and this thread is not using this entry for other states\n-       if ((probe->superThreadQ() == NULL) && (probe->loadInstanceThreadQ() == NULL)\n-          && (probe->defineThreadQ() == NULL) && (probe->definer() == NULL)\n-          && (probe->inlineTypeFieldQ() == NULL)) {\n-         remove_entry(hash, name, loader_data);\n-       }\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  PlaceholderEntry* probe = get_entry(name, loader_data);\n+  if (probe != NULL) {\n+    log(probe, \"find_and_remove\", action);\n+    probe->remove_seen_thread(thread, action);\n+    \/\/ If no other threads using this entry, and this thread is not using this entry for other states\n+    if ((probe->superThreadQ() == NULL) && (probe->loadInstanceThreadQ() == NULL)\n+        && (probe->defineThreadQ() == NULL) && (probe->definer() == NULL)\n+        && (probe->inlineTypeFieldQ() == NULL)) {\n+      probe->clear_supername();\n+      remove_entry(name, loader_data);\n@@ -348,3 +315,0 @@\n-\n-PlaceholderTable::PlaceholderTable(int table_size)\n-    : Hashtable<Symbol*, mtClass>(table_size, sizeof(PlaceholderEntry)) {\n@@ -353,7 +317,4 @@\n-void PlaceholderEntry::verify() const {\n-  guarantee(loader_data() != NULL, \"Must have been setup.\");\n-  guarantee(loader_data()->class_loader() == NULL || loader_data()->class_loader()->is_instance(),\n-            \"checking type of _loader\");\n-  guarantee(instance_klass() == NULL\n-            || instance_klass()->is_instance_klass(),\n-            \"checking type of instance_klass result\");\n+void PlaceholderKey::print_on(outputStream* st) const {\n+  _name->print_value_on(st);\n+  st->print(\", loader \");\n+  _loader_data->print_value_on(st);\n@@ -362,14 +323,1 @@\n-void PlaceholderTable::verify() {\n-  verify_table<PlaceholderEntry>(\"Placeholder Table\");\n-}\n-\n-\n-\/\/ Note, doesn't append a cr\n-\/\/ Can't call this print_on because HashtableEntry doesn't initialize its vptr\n-\/\/ and print_on is a virtual function so the vptr call crashes.\n-void PlaceholderEntry::print_entry(outputStream* st) const {\n-  klassname()->print_value_on(st);\n-  if (loader_data() != NULL) {\n-    st->print(\", loader \");\n-    loader_data()->print_value_on(st);\n-  }\n+void PlaceholderEntry::print_on(outputStream* st) const {\n@@ -403,1 +351,7 @@\n-void PlaceholderTable::print_on(outputStream* st) const {\n+void PlaceholderTable::print_on(outputStream* st) {\n+  auto printer = [&] (PlaceholderKey& key, PlaceholderEntry& entry) {\n+      st->print(\"placeholder \");\n+      key.print_on(st);\n+      entry.print_on(st);\n+      return true;\n+  };\n@@ -405,9 +359,2 @@\n-                table_size(), number_of_entries());\n-  for (int pindex = 0; pindex < table_size(); pindex++) {\n-    for (PlaceholderEntry* probe = bucket(pindex);\n-                           probe != NULL;\n-                           probe = probe->next()) {\n-      st->print(\"%4d: placeholder \", pindex);\n-      probe->print_entry(st);\n-    }\n-  }\n+                _placeholders.table_size(), _placeholders.number_of_entries());\n+  _placeholders.iterate(printer);\n@@ -416,1 +363,1 @@\n-void PlaceholderTable::print() const { return print_on(tty); }\n+void PlaceholderTable::print() { return print_on(tty); }\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":73,"deletions":126,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-#include \"utilities\/hashtable.hpp\"\n-\n@@ -39,39 +37,14 @@\n-class PlaceholderTable : public Hashtable<Symbol*, mtClass> {\n-\n-public:\n-  PlaceholderTable(int table_size);\n-\n-  PlaceholderEntry* new_entry(int hash, Symbol* name, ClassLoaderData* loader_data, Symbol* supername);\n-  void free_entry(PlaceholderEntry* entry);\n-\n-  PlaceholderEntry* bucket(int i) const {\n-    return (PlaceholderEntry*)Hashtable<Symbol*, mtClass>::bucket(i);\n-  }\n-\n-  PlaceholderEntry** bucket_addr(int i) {\n-    return (PlaceholderEntry**)Hashtable<Symbol*, mtClass>::bucket_addr(i);\n-  }\n-\n-  PlaceholderEntry* add_entry(unsigned int hash, Symbol* name,\n-                              ClassLoaderData* loader_data,\n-                              Symbol* supername);\n-\n-  \/\/ This returns a Symbol* to match type for SystemDictionary\n-  Symbol* find_entry(unsigned int hash,\n-                     Symbol* name, ClassLoaderData* loader_data);\n-\n-  PlaceholderEntry* get_entry(unsigned int hash,\n-                              Symbol* name, ClassLoaderData* loader_data);\n-\n-\/\/ caller to create a placeholder entry must enumerate an action\n-\/\/ caller claims ownership of that action\n-\/\/ For parallel classloading:\n-\/\/ multiple LOAD_INSTANCE threads can proceed in parallel\n-\/\/ multiple LOAD_SUPER threads can proceed in parallel\n-\/\/ LOAD_SUPER needed to check for class circularity\n-\/\/ DEFINE_CLASS: ultimately define class must be single threaded\n-\/\/ on a class\/classloader basis\n-\/\/ so the head of that queue owns the token\n-\/\/ and the rest of the threads return the result the first thread gets\n-\/\/ PRIMITIVE_OBJECT_FIELD: needed to check for inline type fields circularity\n- enum classloadAction {\n+class PlaceholderTable : public AllStatic {\n+ public:\n+  \/\/ caller to create a placeholder entry must enumerate an action\n+  \/\/ caller claims ownership of that action\n+  \/\/ For parallel classloading:\n+  \/\/ multiple LOAD_INSTANCE threads can proceed in parallel\n+  \/\/ multiple LOAD_SUPER threads can proceed in parallel\n+  \/\/ LOAD_SUPER needed to check for class circularity\n+  \/\/ DEFINE_CLASS: ultimately define class must be single threaded\n+  \/\/ on a class\/classloader basis\n+  \/\/ so the head of that queue owns the token\n+  \/\/ and the rest of the threads return the result the first thread gets\n+  \/\/ PRIMITIVE_OBJECT_FIELD: needed to check for inline type fields circularity\n+  enum classloadAction {\n@@ -84,0 +57,2 @@\n+  static PlaceholderEntry* get_entry(Symbol* name, ClassLoaderData* loader_data);\n+\n@@ -87,7 +62,3 @@\n-  PlaceholderEntry* find_and_add(unsigned int hash,\n-                                 Symbol* name, ClassLoaderData* loader_data,\n-                                 classloadAction action, Symbol* supername,\n-                                 JavaThread* thread);\n-\n-  void remove_entry(unsigned int hash,\n-                    Symbol* name, ClassLoaderData* loader_data);\n+  static PlaceholderEntry* find_and_add(Symbol* name, ClassLoaderData* loader_data,\n+                                        classloadAction action, Symbol* supername,\n+                                        JavaThread* thread);\n@@ -97,2 +68,1 @@\n-  void find_and_remove(unsigned int hash,\n-                       Symbol* name, ClassLoaderData* loader_data,\n+  static void find_and_remove(Symbol* name, ClassLoaderData* loader_data,\n@@ -101,3 +71,2 @@\n-  void print_on(outputStream* st) const;\n-  void print() const;\n-  void verify();\n+  static void print_on(outputStream* st);\n+  static void print();\n@@ -113,3 +82,1 @@\n-\n-class PlaceholderEntry : public HashtableEntry<Symbol*, mtClass> {\n-\n+class PlaceholderEntry {\n@@ -117,2 +84,0 @@\n-\n-  ClassLoaderData*  _loader_data;   \/\/ initiating loader\n@@ -140,5 +105,4 @@\n-  \/\/ Simple accessors, used only by SystemDictionary\n-  Symbol*            klassname()           const { return literal(); }\n-\n-  ClassLoaderData*   loader_data()         const { return _loader_data; }\n-  void               set_loader_data(ClassLoaderData* loader_data) { _loader_data = loader_data; }\n+  PlaceholderEntry() :\n+     _supername(nullptr), _definer(nullptr), _instanceKlass(nullptr),\n+     _superThreadQ(nullptr), _loadInstanceThreadQ(nullptr), _defineThreadQ(nullptr),\n+     _inlineTypeFieldQ(nullptr) { }\n@@ -148,0 +112,1 @@\n+    Symbol::maybe_decrement_refcount(_supername);\n@@ -149,1 +114,5 @@\n-    if (_supername != NULL) _supername->increment_refcount();\n+    Symbol::maybe_increment_refcount(_supername);\n+  }\n+  void               clear_supername() {\n+    Symbol::maybe_decrement_refcount(_supername);\n+    _supername = nullptr;\n@@ -170,14 +139,0 @@\n-  PlaceholderEntry* next() const {\n-    return (PlaceholderEntry*)HashtableEntry<Symbol*, mtClass>::next();\n-  }\n-\n-  PlaceholderEntry** next_addr() {\n-    return (PlaceholderEntry**)HashtableEntry<Symbol*, mtClass>::next_addr();\n-  }\n-\n-  \/\/ Test for equality\n-  \/\/ Entries are unique for class\/classloader name pair\n-  bool equals(Symbol* class_name, ClassLoaderData* loader) const {\n-    return (klassname() == class_name && loader_data() == loader);\n-  }\n-\n@@ -203,3 +158,1 @@\n-  \/\/ Print method doesn't append a cr\n-  void print_entry(outputStream* st) const;\n-  void verify() const;\n+  void print_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":35,"deletions":82,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+#include \"oops\/oop.hpp\"\n+#include \"oops\/oopHandle.hpp\"\n@@ -80,0 +82,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -93,1 +96,26 @@\n-SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;\n+class InvokeMethodKey : public StackObj {\n+  private:\n+    Symbol* _symbol;\n+    intptr_t _iid;\n+\n+  public:\n+    InvokeMethodKey(Symbol* symbol, intptr_t iid) :\n+        _symbol(symbol),\n+        _iid(iid) {}\n+\n+    static bool key_comparison(InvokeMethodKey const &k1, InvokeMethodKey const &k2){\n+        return k1._symbol == k2._symbol && k1._iid == k2._iid;\n+    }\n+\n+    static unsigned int compute_hash(const InvokeMethodKey &k) {\n+        Symbol* sym = k._symbol;\n+        intptr_t iid = k._iid;\n+        unsigned int hash = (unsigned int) sym -> identity_hash();\n+        return (unsigned int) (hash ^ iid);\n+    }\n+\n+};\n+\n+ResourceHashtable<InvokeMethodKey, Method*, 139, ResourceObj::C_HEAP, mtClass,\n+                  InvokeMethodKey::compute_hash, InvokeMethodKey::key_comparison> _invoke_method_intrinsic_table;\n+ResourceHashtable<Symbol*, OopHandle, 139, ResourceObj::C_HEAP, mtClass> _invoke_method_type_table;\n@@ -105,10 +133,0 @@\n-\/\/ Hashtable holding placeholders for classes being loaded.\n-const int _placeholder_table_size = 1009;\n-static PlaceholderTable* _placeholders   = NULL;\n-static PlaceholderTable*   placeholders() { return _placeholders; }\n-\n-\/\/ Constraints on class loaders\n-const int _loader_constraint_size = 107;                     \/\/ number of entries in constraint table\n-static LoaderConstraintTable*  _loader_constraints;\n-static LoaderConstraintTable* constraints() { return _loader_constraints; }\n-\n@@ -126,0 +144,28 @@\n+  if (_java_system_loader.is_empty()) {\n+    oop system_loader = get_system_class_loader_impl(CHECK);\n+    _java_system_loader = OopHandle(Universe::vm_global(), system_loader);\n+  } else {\n+    \/\/ It must have been restored from the archived module graph\n+    assert(UseSharedSpaces, \"must be\");\n+    assert(MetaspaceShared::use_full_module_graph(), \"must be\");\n+    DEBUG_ONLY(\n+      oop system_loader = get_system_class_loader_impl(CHECK);\n+      assert(_java_system_loader.resolve() == system_loader, \"must be\");\n+    )\n+ }\n+\n+  if (_java_platform_loader.is_empty()) {\n+    oop platform_loader = get_platform_class_loader_impl(CHECK);\n+    _java_platform_loader = OopHandle(Universe::vm_global(), platform_loader);\n+  } else {\n+    \/\/ It must have been restored from the archived module graph\n+    assert(UseSharedSpaces, \"must be\");\n+    assert(MetaspaceShared::use_full_module_graph(), \"must be\");\n+    DEBUG_ONLY(\n+      oop platform_loader = get_platform_class_loader_impl(CHECK);\n+      assert(_java_platform_loader.resolve() == platform_loader, \"must be\");\n+    )\n+  }\n+}\n+\n+oop SystemDictionary::get_system_class_loader_impl(TRAPS) {\n@@ -132,3 +178,3 @@\n-                         CHECK);\n-\n-  _java_system_loader = OopHandle(Universe::vm_global(), result.get_oop());\n+                         CHECK_NULL);\n+  return result.get_oop();\n+}\n@@ -136,0 +182,3 @@\n+oop SystemDictionary::get_platform_class_loader_impl(TRAPS) {\n+  JavaValue result(T_OBJECT);\n+  InstanceKlass* class_loader_klass = vmClasses::ClassLoader_klass();\n@@ -140,3 +189,2 @@\n-                         CHECK);\n-\n-  _java_platform_loader = OopHandle(Universe::vm_global(), result.get_oop());\n+                         CHECK_NULL);\n+  return result.get_oop();\n@@ -155,0 +203,11 @@\n+void SystemDictionary::set_system_loader(ClassLoaderData *cld) {\n+  assert(_java_system_loader.is_empty(), \"already set!\");\n+  _java_system_loader = cld->class_loader_handle();\n+\n+}\n+\n+void SystemDictionary::set_platform_loader(ClassLoaderData *cld) {\n+  assert(_java_platform_loader.is_empty(), \"already set!\");\n+  _java_platform_loader = cld->class_loader_handle();\n+}\n+\n@@ -231,2 +290,1 @@\n-  unsigned int name_hash = dictionary->compute_hash(class_name);\n-  InstanceKlass* kk = dictionary->find_class(name_hash, class_name);\n+  InstanceKlass* kk = dictionary->find_class(JavaThread::current(), class_name);\n@@ -333,1 +391,1 @@\n-    probe->print_entry(&ls);\n+    probe->print_on(&ls);\n@@ -385,2 +443,0 @@\n-  unsigned int name_hash = dictionary->compute_hash(class_name);\n-  assert(placeholders()->compute_hash(class_name) == name_hash, \"they're the same hashcode\");\n@@ -392,1 +448,1 @@\n-    InstanceKlass* klassk = dictionary->find_class(name_hash, class_name);\n+    InstanceKlass* klassk = dictionary->find_class(THREAD, class_name);\n@@ -404,1 +460,1 @@\n-      PlaceholderEntry* probe = placeholders()->get_entry(name_hash, class_name, loader_data);\n+      PlaceholderEntry* probe = PlaceholderTable::get_entry(class_name, loader_data);\n@@ -413,5 +469,4 @@\n-      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash,\n-                                                                class_name,\n-                                                                loader_data,\n-                                                                PlaceholderTable::LOAD_SUPER,\n-                                                                super_name, THREAD);\n+      PlaceholderEntry* newprobe = PlaceholderTable::find_and_add(class_name,\n+                                                                  loader_data,\n+                                                                  PlaceholderTable::LOAD_SUPER,\n+                                                                  super_name, THREAD);\n@@ -436,1 +491,1 @@\n-    placeholders()->find_and_remove(name_hash, class_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n+    PlaceholderTable::find_and_remove(class_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);\n@@ -456,1 +511,0 @@\n-  unsigned int p_hash = placeholders()->compute_hash(class_name);\n@@ -462,1 +516,1 @@\n-    oldprobe = placeholders()->get_entry(p_hash, class_name, loader_data);\n+    oldprobe = PlaceholderTable::get_entry(class_name, loader_data);\n@@ -468,1 +522,1 @@\n-      placeholders()->find_and_add(p_hash, class_name, loader_data,\n+      PlaceholderTable::find_and_add(class_name, loader_data,\n@@ -484,2 +538,2 @@\n-    placeholders()->find_and_remove(p_hash, class_name, loader_data,\n-                                    PlaceholderTable::PRIMITIVE_OBJECT_FIELD, THREAD);\n+    PlaceholderTable::find_and_remove(class_name, loader_data,\n+                                      PlaceholderTable::PRIMITIVE_OBJECT_FIELD, THREAD);\n@@ -562,1 +616,0 @@\n-                                                         unsigned int name_hash,\n@@ -567,1 +620,1 @@\n-  PlaceholderEntry* oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n+  PlaceholderEntry* oldprobe = PlaceholderTable::get_entry(name, loader_data);\n@@ -602,1 +655,1 @@\n-        InstanceKlass* check = loader_data->dictionary()->find_class(name_hash, name);\n+        InstanceKlass* check = loader_data->dictionary()->find_class(current, name);\n@@ -608,1 +661,1 @@\n-        oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n+        oldprobe = PlaceholderTable::get_entry(name, loader_data);\n@@ -646,1 +699,0 @@\n-  unsigned int name_hash = dictionary->compute_hash(name);\n@@ -653,1 +705,1 @@\n-  InstanceKlass* probe = dictionary->find(name_hash, name, protection_domain);\n+  InstanceKlass* probe = dictionary->find(THREAD, name, protection_domain);\n@@ -677,2 +729,0 @@\n-  assert(placeholders()->compute_hash(name) == name_hash, \"they're the same hashcode\");\n-\n@@ -682,1 +732,1 @@\n-    InstanceKlass* check = dictionary->find_class(name_hash, name);\n+    InstanceKlass* check = dictionary->find_class(THREAD, name);\n@@ -687,1 +737,1 @@\n-      PlaceholderEntry* placeholder = placeholders()->get_entry(name_hash, name, loader_data);\n+      PlaceholderEntry* placeholder = PlaceholderTable::get_entry(name, loader_data);\n@@ -730,1 +780,0 @@\n-                                               name_hash,\n@@ -740,1 +789,1 @@\n-        InstanceKlass* check = dictionary->find_class(name_hash, name);\n+        InstanceKlass* check = dictionary->find_class(THREAD, name);\n@@ -745,4 +794,4 @@\n-          PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, name, loader_data,\n-                                                                    PlaceholderTable::LOAD_INSTANCE,\n-                                                                    NULL,\n-                                                                    THREAD);\n+          PlaceholderEntry* newprobe = PlaceholderTable::find_and_add(name, loader_data,\n+                                                                      PlaceholderTable::LOAD_INSTANCE,\n+                                                                      NULL,\n+                                                                      THREAD);\n@@ -762,1 +811,1 @@\n-    \/\/ placeholders()->find_and_add(PlaceholderTable::LOAD_INSTANCE),\n+    \/\/ PlaceholderTable::find_and_add(PlaceholderTable::LOAD_INSTANCE),\n@@ -768,1 +817,1 @@\n-      loaded_class = load_instance_class(name_hash, name, class_loader, THREAD);\n+      loaded_class = load_instance_class(name, class_loader, THREAD);\n@@ -776,1 +825,1 @@\n-      placeholders()->find_and_remove(name_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);\n+      PlaceholderTable::find_and_remove(name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);\n@@ -795,1 +844,1 @@\n-    dictionary->validate_protection_domain(name_hash, loaded_class, class_loader, protection_domain, CHECK_NULL);\n+    dictionary->validate_protection_domain(loaded_class, class_loader, protection_domain, CHECK_NULL);\n@@ -810,1 +859,1 @@\n-\/\/ _dictionary->bucket(index) is read here, so the caller will not see\n+\/\/ Dictionary is read here, so the caller will not see\n@@ -813,1 +862,2 @@\n-InstanceKlass* SystemDictionary::find_instance_klass(Symbol* class_name,\n+InstanceKlass* SystemDictionary::find_instance_klass(Thread* current,\n+                                                     Symbol* class_name,\n@@ -830,2 +880,1 @@\n-  unsigned int name_hash = dictionary->compute_hash(class_name);\n-  return dictionary->find(name_hash, class_name, protection_domain);\n+  return dictionary->find(current, class_name, protection_domain);\n@@ -836,1 +885,2 @@\n-Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,\n+Klass* SystemDictionary::find_instance_or_array_klass(Thread* current,\n+                                                      Symbol* class_name,\n@@ -852,1 +902,1 @@\n-      k = SystemDictionary::find_instance_klass(ss.as_symbol(), class_loader, protection_domain);\n+      k = SystemDictionary::find_instance_klass(current, ss.as_symbol(), class_loader, protection_domain);\n@@ -862,1 +912,1 @@\n-    k = find_instance_klass(class_name, class_loader, protection_domain);\n+    k = find_instance_klass(current, class_name, class_loader, protection_domain);\n@@ -1116,1 +1166,1 @@\n-    InstanceKlass* check = find_instance_klass(name, class_loader, protection_domain);\n+    InstanceKlass* check = find_instance_klass(THREAD, name, class_loader, protection_domain);\n@@ -1426,2 +1476,1 @@\n-InstanceKlass* SystemDictionary::load_instance_class(unsigned int name_hash,\n-                                                     Symbol* name,\n+InstanceKlass* SystemDictionary::load_instance_class(Symbol* name,\n@@ -1438,1 +1487,1 @@\n-    check_constraints(name_hash, loaded_class, class_loader, false, CHECK_NULL);\n+    check_constraints(loaded_class, class_loader, false, CHECK_NULL);\n@@ -1451,1 +1500,1 @@\n-      update_dictionary(name_hash, loaded_class, class_loader);\n+      update_dictionary(THREAD, loaded_class, class_loader);\n@@ -1497,2 +1546,1 @@\n-  unsigned int name_hash = dictionary->compute_hash(name_h);\n-  check_constraints(name_hash, k, class_loader, true, CHECK);\n+  check_constraints(k, class_loader, true, CHECK);\n@@ -1522,1 +1570,1 @@\n-    update_dictionary(name_hash, k, class_loader);\n+    update_dictionary(THREAD, k, class_loader);\n@@ -1549,1 +1597,1 @@\n-\/\/ placeholders()->find_and_add(PlaceholderTable::DEFINE_CLASS),\n+\/\/ PlaceholderTable::find_and_add(PlaceholderTable::DEFINE_CLASS),\n@@ -1559,2 +1607,0 @@\n-  unsigned int name_hash = dictionary->compute_hash(name_h);\n-\n@@ -1566,1 +1612,1 @@\n-      InstanceKlass* check = dictionary->find_class(name_hash, name_h);\n+      InstanceKlass* check = dictionary->find_class(THREAD, name_h);\n@@ -1573,3 +1619,2 @@\n-    assert(placeholders()->compute_hash(name_h) == name_hash, \"they're the same hashcode\");\n-    PlaceholderEntry* probe = placeholders()->find_and_add(name_hash, name_h, loader_data,\n-                                                           PlaceholderTable::DEFINE_CLASS, NULL, THREAD);\n+    PlaceholderEntry* probe = PlaceholderTable::find_and_add(name_h, loader_data,\n+                                                             PlaceholderTable::DEFINE_CLASS, NULL, THREAD);\n@@ -1588,1 +1633,1 @@\n-      placeholders()->find_and_remove(name_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n+      PlaceholderTable::find_and_remove(name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n@@ -1591,1 +1636,1 @@\n-      InstanceKlass* check = dictionary->find_class(name_hash, name_h);\n+      InstanceKlass* check = dictionary->find_class(THREAD, name_h);\n@@ -1606,1 +1651,1 @@\n-    PlaceholderEntry* probe = placeholders()->get_entry(name_hash, name_h, loader_data);\n+    PlaceholderEntry* probe = PlaceholderTable::get_entry(name_h, loader_data);\n@@ -1612,1 +1657,1 @@\n-    placeholders()->find_and_remove(name_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n+    PlaceholderTable::find_and_remove(name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);\n@@ -1683,1 +1728,1 @@\n-      constraints()->purge_loader_constraints();\n+      LoaderConstraintTable::purge_loader_constraints();\n@@ -1713,4 +1758,15 @@\n-  MutexLocker ml(ClassLoaderDataGraph_lock);\n-  ClassLoaderDataGraph::methods_do(f);\n-  \/\/ Walk method handle intrinsics\n-  invoke_method_table()->methods_do(f);\n+\n+  {\n+    MutexLocker ml(ClassLoaderDataGraph_lock);\n+    ClassLoaderDataGraph::methods_do(f);\n+  }\n+\n+  auto doit = [&] (InvokeMethodKey key, Method* method) {\n+    f(method);\n+  };\n+\n+  {\n+    MutexLocker ml(InvokeMethodTable_lock);\n+    _invoke_method_intrinsic_table.iterate_all(doit);\n+  }\n+\n@@ -1724,3 +1780,0 @@\n-  _placeholders        = new PlaceholderTable(_placeholder_table_size);\n-  _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);\n-  _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);\n@@ -1729,0 +1782,4 @@\n+#if INCLUDE_CDS\n+  SystemDictionaryShared::initialize();\n+#endif\n+\n@@ -1745,2 +1802,1 @@\n-void SystemDictionary::check_constraints(unsigned int name_hash,\n-                                         InstanceKlass* k,\n+void SystemDictionary::check_constraints(InstanceKlass* k,\n@@ -1760,1 +1816,1 @@\n-    InstanceKlass* check = loader_data->dictionary()->find_class(name_hash, name);\n+    InstanceKlass* check = loader_data->dictionary()->find_class(THREAD, name);\n@@ -1777,1 +1833,1 @@\n-      if (constraints()->check_or_update(k, class_loader, name) == false) {\n+      if (LoaderConstraintTable::check_or_update(k, class_loader, name) == false) {\n@@ -1782,1 +1838,1 @@\n-        Klass *existing_klass = constraints()->find_constrained_klass(name, class_loader);\n+        Klass *existing_klass = LoaderConstraintTable::find_constrained_klass(name, class_loader);\n@@ -1804,1 +1860,1 @@\n-void SystemDictionary::update_dictionary(unsigned int hash,\n+void SystemDictionary::update_dictionary(JavaThread* current,\n@@ -1817,1 +1873,1 @@\n-    InstanceKlass* sd_check = dictionary->find_class(hash, name);\n+    InstanceKlass* sd_check = dictionary->find_class(current, name);\n@@ -1819,1 +1875,1 @@\n-      dictionary->add_klass(hash, name, k);\n+      dictionary->add_klass(current, name, k);\n@@ -1835,1 +1891,1 @@\n-  Klass* klass = find_instance_or_array_klass(class_name, class_loader,\n+  Klass* klass = find_instance_or_array_klass(current, class_name, class_loader,\n@@ -1853,1 +1909,1 @@\n-      klass = constraints()->find_constrained_klass(ss.as_symbol(), class_loader);\n+      klass = LoaderConstraintTable::find_constrained_klass(ss.as_symbol(), class_loader);\n@@ -1866,1 +1922,1 @@\n-    klass = constraints()->find_constrained_klass(class_name, class_loader);\n+    klass = LoaderConstraintTable::find_constrained_klass(class_name, class_loader);\n@@ -1899,3 +1955,1 @@\n-  unsigned int name_hash1 = dictionary1->compute_hash(constraint_name);\n-\n-  unsigned int name_hash2 = dictionary2->compute_hash(constraint_name);\n+  JavaThread* current = JavaThread::current();\n@@ -1906,4 +1960,4 @@\n-    InstanceKlass* klass1 = dictionary1->find_class(name_hash1, constraint_name);\n-    InstanceKlass* klass2 = dictionary2->find_class(name_hash2, constraint_name);\n-    bool result = constraints()->add_entry(constraint_name, klass1, class_loader1,\n-                                           klass2, class_loader2);\n+    InstanceKlass* klass1 = dictionary1->find_class(current, constraint_name);\n+    InstanceKlass* klass2 = dictionary2->find_class(current, constraint_name);\n+    bool result = LoaderConstraintTable::add_entry(constraint_name, klass1, class_loader1,\n+                                                   klass2, class_loader2);\n@@ -2074,0 +2128,1 @@\n+\n@@ -2081,10 +2136,13 @@\n-  unsigned int hash  = invoke_method_table()->compute_hash(signature, iid_as_int);\n-  int          index = invoke_method_table()->hash_to_index(hash);\n-  SymbolPropertyEntry* spe = invoke_method_table()->find_entry(index, hash, signature, iid_as_int);\n-  methodHandle m;\n-  if (spe == NULL || spe->method() == NULL) {\n-    spe = NULL;\n-    \/\/ Must create lots of stuff here, but outside of the SystemDictionary lock.\n-    m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n-    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n-      \/\/ Generate a compiled form of the MH intrinsic.\n+  Method** met;\n+  InvokeMethodKey key(signature, iid_as_int);\n+  {\n+    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    met = _invoke_method_intrinsic_table.get(key);\n+    if (met != nullptr) {\n+      return *met;\n+    }\n+  }\n+\n+  methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n+  if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n+      \/\/ Generate a compiled form of the MH intrinsic\n@@ -2098,15 +2156,10 @@\n-    }\n-    \/\/ Now grab the lock.  We might have to throw away the new method,\n-    \/\/ if a racing thread has managed to install one at the same time.\n-    {\n-      MutexLocker ml(THREAD, SystemDictionary_lock);\n-      spe = invoke_method_table()->find_entry(index, hash, signature, iid_as_int);\n-      if (spe == NULL)\n-        spe = invoke_method_table()->add_entry(index, hash, signature, iid_as_int);\n-      if (spe->method() == NULL)\n-        spe->set_method(m());\n-    }\n-\n-  assert(spe != NULL && spe->method() != NULL, \"\");\n-  assert(Arguments::is_interpreter_only() || (spe->method()->has_compiled_code() &&\n-         spe->method()->code()->entry_point() == spe->method()->from_compiled_entry()),\n+  \/\/ Now grab the lock.  We might have to throw away the new method,\n+  \/\/ if a racing thread has managed to install one at the same time.\n+  {\n+    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    signature->make_permanent(); \/\/ The signature is never unloaded.\n+    bool created;\n+    met = _invoke_method_intrinsic_table.put_if_absent(key, m(), &created);\n+    Method* saved_method = *met;\n+    assert(Arguments::is_interpreter_only() || (saved_method->has_compiled_code() &&\n+         saved_method->code()->entry_point() == saved_method->from_compiled_entry()),\n@@ -2115,1 +2168,2 @@\n-  return spe->method();\n+    return saved_method;\n+  }\n@@ -2256,7 +2310,10 @@\n-  int null_iid = vmIntrinsics::as_int(vmIntrinsics::_none);  \/\/ distinct from all method handle invoker intrinsics\n-  unsigned int hash  = invoke_method_table()->compute_hash(signature, null_iid);\n-  int          index = invoke_method_table()->hash_to_index(hash);\n-  SymbolPropertyEntry* spe = invoke_method_table()->find_entry(index, hash, signature, null_iid);\n-  if (spe != NULL && spe->method_type() != NULL) {\n-    assert(java_lang_invoke_MethodType::is_instance(spe->method_type()), \"\");\n-    return Handle(THREAD, spe->method_type());\n+  OopHandle* o;\n+  {\n+    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    o = _invoke_method_type_table.get(signature);\n+  }\n+\n+  if (o != nullptr) {\n+    oop mt = o->resolve();\n+    assert(java_lang_invoke_MethodType::is_instance(mt), \"\");\n+    return Handle(THREAD, mt);\n@@ -2324,6 +2381,9 @@\n-    MutexLocker ml(THREAD, SystemDictionary_lock);\n-    spe = invoke_method_table()->find_entry(index, hash, signature, null_iid);\n-    if (spe == NULL)\n-      spe = invoke_method_table()->add_entry(index, hash, signature, null_iid);\n-    if (spe->method_type() == NULL) {\n-      spe->set_method_type(method_type());\n+    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    bool created = false;\n+    assert(method_type != NULL, \"unexpected null\");\n+    OopHandle* h = _invoke_method_type_table.get(signature);\n+    if (h == nullptr) {\n+      signature->make_permanent(); \/\/ The signature is never unloaded.\n+      OopHandle elem = OopHandle(Universe::vm_global(), method_type());\n+      bool created = _invoke_method_type_table.put(signature, elem);\n+      assert(created, \"better be created\");\n@@ -2332,1 +2392,0 @@\n-\n@@ -2485,1 +2544,1 @@\n-  placeholders()->print_on(st);\n+  PlaceholderTable::print_on(st);\n@@ -2489,1 +2548,1 @@\n-  constraints()->print_on(st);\n+  LoaderConstraintTable::print_on(st);\n@@ -2499,4 +2558,0 @@\n-  guarantee(constraints() != NULL,\n-            \"Verify of loader constraints failed\");\n-  guarantee(placeholders()->number_of_entries() >= 0,\n-            \"Verify of placeholders failed\");\n@@ -2509,4 +2564,1 @@\n-  placeholders()->verify();\n-\n-  guarantee(constraints() != NULL, \"Verify of loader constraints failed\");\n-  constraints()->verify(placeholders());\n+  LoaderConstraintTable::verify();\n@@ -2525,2 +2577,1 @@\n-    placeholders()->print_table_statistics(st, \"Placeholder Table\");\n-    constraints()->print_table_statistics(st, \"LoaderConstraints Table\");\n+    LoaderConstraintTable::print_table_statistics(st);\n@@ -2531,15 +2582,0 @@\n-TableStatistics SystemDictionary::placeholders_statistics() {\n-  MutexLocker ml(SystemDictionary_lock);\n-  return placeholders()->statistics_calculate();\n-}\n-\n-TableStatistics SystemDictionary::loader_constraints_statistics() {\n-  MutexLocker ml(SystemDictionary_lock);\n-  return constraints()->statistics_calculate();\n-}\n-\n-TableStatistics SystemDictionary::protection_domain_cache_statistics() {\n-  MutexLocker ml(SystemDictionary_lock);\n-  return pd_cache_table()->statistics_calculate();\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":210,"deletions":174,"binary":false,"changes":384,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,0 @@\n-class TableStatistics;\n@@ -137,0 +136,3 @@\n+  static oop get_system_class_loader_impl(TRAPS);\n+  static oop get_platform_class_loader_impl(TRAPS);\n+\n@@ -152,1 +154,2 @@\n-  static InstanceKlass* find_instance_klass(Symbol* class_name, Handle class_loader, Handle protection_domain);\n+  static InstanceKlass* find_instance_klass(Thread* current, Symbol* class_name,\n+                                            Handle class_loader, Handle protection_domain);\n@@ -157,1 +160,1 @@\n-  static Klass* find_instance_or_array_klass(Symbol* class_name,\n+  static Klass* find_instance_or_array_klass(Thread* current, Symbol* class_name,\n@@ -228,0 +231,3 @@\n+  static void set_system_loader(ClassLoaderData *cld);\n+  static void set_platform_loader(ClassLoaderData *cld);\n+\n@@ -329,1 +335,0 @@\n-                                                unsigned int name_hash,\n@@ -340,2 +345,1 @@\n-  static InstanceKlass* load_instance_class(unsigned int name_hash,\n-                                            Symbol* class_name,\n+  static InstanceKlass* load_instance_class(Symbol* class_name,\n@@ -405,2 +409,1 @@\n-  static void check_constraints(unsigned int hash,\n-                                InstanceKlass* k, Handle loader,\n+  static void check_constraints(InstanceKlass* k, Handle loader,\n@@ -408,7 +411,1 @@\n-  static void update_dictionary(unsigned int hash,\n-                                InstanceKlass* k, Handle loader);\n-\n-public:\n-  static TableStatistics placeholders_statistics();\n-  static TableStatistics loader_constraints_statistics();\n-  static TableStatistics protection_domain_cache_statistics();\n+  static void update_dictionary(JavaThread* current, InstanceKlass* k, Handle loader);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -428,0 +428,1 @@\n+  case vmIntrinsics::_allocateInstance:\n@@ -438,1 +439,0 @@\n-  case vmIntrinsics::_allocateInstance:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -249,0 +249,3 @@\n+  do_intrinsic(_reverse_i,                java_lang_Integer,      reverse_name,             int_int_signature,   F_S)   \\\n+   do_name(     reverse_name,                                    \"reverse\")                                             \\\n+  do_intrinsic(_reverse_l,                java_lang_Long,         reverse_name,             long_long_signature, F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -82,6 +82,0 @@\n-  _type(type),\n-  _size(layout.size()),\n-  _header_size(layout.header_size()),\n-  _frame_complete_offset(frame_complete_offset),\n-  _data_offset(layout.data_offset()),\n-  _frame_size(frame_size),\n@@ -95,0 +89,6 @@\n+  _name(name),\n+  _size(layout.size()),\n+  _header_size(layout.header_size()),\n+  _frame_complete_offset(frame_complete_offset),\n+  _data_offset(layout.data_offset()),\n+  _frame_size(frame_size),\n@@ -97,1 +97,1 @@\n-  _name(name)\n+  _type(type)\n@@ -111,6 +111,0 @@\n-  _type(type),\n-  _size(layout.size()),\n-  _header_size(layout.header_size()),\n-  _frame_complete_offset(frame_complete_offset),\n-  _data_offset(layout.data_offset()),\n-  _frame_size(frame_size),\n@@ -123,0 +117,6 @@\n+  _name(name),\n+  _size(layout.size()),\n+  _header_size(layout.header_size()),\n+  _frame_complete_offset(frame_complete_offset),\n+  _data_offset(layout.data_offset()),\n+  _frame_size(frame_size),\n@@ -125,1 +125,1 @@\n-  _name(name)\n+  _type(type)\n@@ -314,0 +314,2 @@\n+  CodeCache::gc_on_allocation();\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -44,8 +44,6 @@\n-struct CodeBlobType {\n-  enum {\n-    MethodNonProfiled   = 0,    \/\/ Execution level 1 and 4 (non-profiled) nmethods (including native nmethods)\n-    MethodProfiled      = 1,    \/\/ Execution level 2 and 3 (profiled) nmethods\n-    NonNMethod          = 2,    \/\/ Non-nmethods like Buffers, Adapters and Runtime Stubs\n-    All                 = 3,    \/\/ All types (No code cache segmentation)\n-    NumTypes            = 4     \/\/ Number of CodeBlobTypes\n-  };\n+enum class CodeBlobType {\n+  MethodNonProfiled   = 0,    \/\/ Execution level 1 and 4 (non-profiled) nmethods (including native nmethods)\n+  MethodProfiled      = 1,    \/\/ Execution level 2 and 3 (profiled) nmethods\n+  NonNMethod          = 2,    \/\/ Non-nmethods like Buffers, Adapters and Runtime Stubs\n+  All                 = 3,    \/\/ All types (No code cache segmentation)\n+  NumTypes            = 4     \/\/ Number of CodeBlobTypes\n@@ -93,10 +91,1 @@\n-  const CompilerType _type;                      \/\/ CompilerType\n-  int        _size;                              \/\/ total size of CodeBlob in bytes\n-  int        _header_size;                       \/\/ size of header (depends on subclass)\n-  int        _frame_complete_offset;             \/\/ instruction offsets in [0.._frame_complete_offset) have\n-                                                 \/\/ not finished setting up their frame. Beware of pc's in\n-                                                 \/\/ that range. There is a similar range(s) on returns\n-                                                 \/\/ which we don't detect.\n-  int        _data_offset;                       \/\/ offset to where data region begins\n-  int        _frame_size;                        \/\/ size of stack frame\n-\n+  \/\/ order fields from large to small to minimize padding between fields\n@@ -112,3 +101,0 @@\n-  bool                _caller_must_gc_arguments;\n-\n-  bool                _is_compiled;\n@@ -119,0 +105,14 @@\n+  int        _size;                              \/\/ total size of CodeBlob in bytes\n+  int        _header_size;                       \/\/ size of header (depends on subclass)\n+  int        _frame_complete_offset;             \/\/ instruction offsets in [0.._frame_complete_offset) have\n+                                                 \/\/ not finished setting up their frame. Beware of pc's in\n+                                                 \/\/ that range. There is a similar range(s) on returns\n+                                                 \/\/ which we don't detect.\n+  int        _data_offset;                       \/\/ offset to where data region begins\n+  int        _frame_size;                        \/\/ size of stack frame\n+\n+  bool                _caller_must_gc_arguments;\n+\n+  bool                _is_compiled;\n+  const CompilerType  _type;                     \/\/ CompilerType\n+\n@@ -215,7 +215,0 @@\n-  \/\/ CodeCache support: really only used by the nmethods, but in order to get\n-  \/\/ asserts and certain bookkeeping to work in the CodeCache they are defined\n-  \/\/ virtual here.\n-  virtual bool is_zombie() const                 { return false; }\n-  virtual bool is_locked_by_vm() const           { return false; }\n-\n-  virtual bool is_unloaded() const               { return false; }\n@@ -224,3 +217,0 @@\n-  \/\/ GC support\n-  virtual bool is_alive() const                  = 0;\n-\n@@ -388,3 +378,0 @@\n-  \/\/ GC support\n-  virtual bool is_alive() const                  = 0;\n-\n@@ -441,1 +428,0 @@\n-  bool is_alive() const                          { return true; }\n@@ -566,1 +552,0 @@\n-  bool is_alive() const                          { return true; }\n@@ -601,2 +586,0 @@\n-  bool is_alive() const                          { return true; }\n-\n@@ -835,1 +818,0 @@\n-  virtual bool is_alive() const override { return true; }\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":21,"deletions":39,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  CodeBlob* cb = CodeCache::find_blob_unsafe(code);\n+  CodeBlob* cb = CodeCache::find_blob(code);\n@@ -131,1 +131,1 @@\n-    CodeBlob* cb = CodeCache::find_blob_unsafe(_call->instruction_address());\n+    CodeBlob* cb = CodeCache::find_blob(_call->instruction_address());\n@@ -320,4 +320,1 @@\n-  \/\/ Use unsafe, since an inline cache might point to a zombie method. However, the zombie\n-  \/\/ method is guaranteed to still exist, since we only remove methods after all inline caches\n-  \/\/ has been cleaned up\n-  CodeBlob* cb = CodeCache::find_blob_unsafe(ic_destination());\n+  CodeBlob* cb = CodeCache::find_blob(ic_destination());\n@@ -331,1 +328,1 @@\n-  CodeBlob* caller = CodeCache::find_blob_unsafe(instruction_address());\n+  CodeBlob* caller = CodeCache::find_blob(instruction_address());\n@@ -336,1 +333,0 @@\n-         !caller->is_alive() ||\n@@ -349,4 +345,1 @@\n-    \/\/ must use unsafe because the destination can be a zombie (and we're cleaning)\n-    \/\/ and the print_compiled_ic code wants to know if site (in the non-zombie)\n-    \/\/ is to the interpreter.\n-    CodeBlob* cb = CodeCache::find_blob_unsafe(ic_destination());\n+    CodeBlob* cb = CodeCache::find_blob(ic_destination());\n@@ -377,2 +370,0 @@\n-  \/\/ A zombie transition will always be safe, since the metadata has already been set to NULL, so\n-  \/\/ we only need to patch the destination\n@@ -463,1 +454,1 @@\n-    CodeBlob* cb = CodeCache::find_blob_unsafe(info.entry());\n+    CodeBlob* cb = CodeCache::find_blob(info.entry());\n@@ -566,1 +557,1 @@\n-  CodeBlob* cb = CodeCache::find_blob_unsafe(entry);\n+  CodeBlob* cb = CodeCache::find_blob(entry);\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -109,4 +109,0 @@\n-  case zombie:\n-    return \"zombie\";\n-  case unloaded:\n-    return \"unloaded\";\n@@ -313,1 +309,1 @@\n-  \/\/ If the method is not entrant or zombie then a JMP is plastered over the\n+  \/\/ If the method is not entrant then a JMP is plastered over the\n@@ -442,5 +438,1 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"cleaning of IC's only allowed at safepoint\");\n-  if (is_zombie()) {\n-    return;\n-  }\n-\n+  assert(SafepointSynchronize::is_at_safepoint(), \"clearing of IC's only allowed at safepoint\");\n@@ -530,2 +522,1 @@\n-  \/\/ Ok, to lookup references to zombies here\n-  CodeBlob *cb = CodeCache::find_blob_unsafe(addr);\n+  CodeBlob *cb = CodeCache::find_blob(addr);\n@@ -534,1 +525,1 @@\n-    \/\/ Clean inline caches pointing to both zombie and not_entrant methods\n+    \/\/ Clean inline caches pointing to bad nmethods\n@@ -536,35 +527,0 @@\n-      \/\/ Inline cache cleaning should only be initiated on CompiledMethods that have been\n-      \/\/ observed to be is_alive(). However, with concurrent code cache unloading, it is\n-      \/\/ possible that by now, the state has become !is_alive. This can happen in two ways:\n-      \/\/ 1) It can be racingly flipped to unloaded if the nmethod \/\/ being cleaned (from the\n-      \/\/ sweeper) is_unloading(). This is fine, because if that happens, then the inline\n-      \/\/ caches have already been cleaned under the same CompiledICLocker that we now hold during\n-      \/\/ inline cache cleaning, and we will simply walk the inline caches again, and likely not\n-      \/\/ find much of interest to clean. However, this race prevents us from asserting that the\n-      \/\/ nmethod is_alive(). The is_unloading() function is completely monotonic; once set due\n-      \/\/ to an oop dying, it remains set forever until freed. Because of that, all unloaded\n-      \/\/ nmethods are is_unloading(), but notably, an unloaded nmethod may also subsequently\n-      \/\/ become zombie (when the sweeper converts it to zombie).\n-      \/\/ 2) It can be racingly flipped to zombie if the nmethod being cleaned (by the concurrent\n-      \/\/ GC) cleans a zombie nmethod that is concurrently made zombie by the sweeper. In this\n-      \/\/ scenario, the sweeper will first transition the nmethod to zombie, and then when\n-      \/\/ unregistering from the GC, it will wait until the GC is done. The GC will then clean\n-      \/\/ the inline caches *with IC stubs*, even though no IC stubs are needed. This is fine,\n-      \/\/ as long as the IC stubs are guaranteed to be released until the next safepoint, where\n-      \/\/ IC finalization requires live IC stubs to not be associated with zombie nmethods.\n-      \/\/ This is guaranteed, because the sweeper does not have a single safepoint check until\n-      \/\/ after it completes the whole transition function; it will wake up after the GC is\n-      \/\/ done with concurrent code cache cleaning (which blocks out safepoints using the\n-      \/\/ suspendible threads set), and then call clear_ic_callsites, which will release the\n-      \/\/ associated IC stubs, before a subsequent safepoint poll can be reached. This\n-      \/\/ guarantees that the spuriously created IC stubs are released appropriately before\n-      \/\/ IC finalization in a safepoint gets to run. Therefore, this race is fine. This is also\n-      \/\/ valid in a scenario where an inline cache of a zombie nmethod gets a spurious IC stub,\n-      \/\/ and then when cleaning another inline cache, fails to request an IC stub because we\n-      \/\/ exhausted the IC stub buffer. In this scenario, the GC will request a safepoint after\n-      \/\/ yielding the suspendible therad set, effectively unblocking safepoints. Before such\n-      \/\/ a safepoint can be reached, the sweeper similarly has to wake up, clear the IC stubs,\n-      \/\/ and reach the next safepoint poll, after the whole transition function has completed.\n-      \/\/ Due to the various races that can cause an nmethod to first be is_alive() and then\n-      \/\/ racingly become !is_alive(), it is unfortunately not possible to assert the nmethod\n-      \/\/ is_alive(), !is_unloaded() or !is_zombie() here.\n@@ -632,20 +588,6 @@\n-void CompiledMethod::cleanup_inline_caches(bool clean_all) {\n-  for (;;) {\n-    ICRefillVerifier ic_refill_verifier;\n-    { CompiledICLocker ic_locker(this);\n-      if (cleanup_inline_caches_impl(false, clean_all)) {\n-        return;\n-      }\n-    }\n-    \/\/ Call this nmethod entry barrier from the sweeper.\n-    run_nmethod_entry_barrier();\n-    if (!clean_all) {\n-      MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-      CodeCache::Sweep::end();\n-    }\n-    InlineCacheBuffer::refill_ic_stubs();\n-    if (!clean_all) {\n-      MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-      CodeCache::Sweep::begin();\n-    }\n-  }\n+\/\/ Only called by whitebox test\n+void CompiledMethod::cleanup_inline_caches_whitebox() {\n+  assert_locked_or_safepoint(CodeCache_lock);\n+  CompiledICLocker ic_locker(this);\n+  guarantee(cleanup_inline_caches_impl(false \/* unloading_occurred *\/, true \/* clean_all *\/),\n+            \"Inline cache cleaning in a safepoint can't fail\");\n@@ -658,2 +600,1 @@\n-\/\/ Called to clean up after class unloading for live nmethods and from the sweeper\n-\/\/ for all methods.\n+\/\/ Called to clean up after class unloading for live nmethods\n@@ -664,2 +605,1 @@\n-  \/\/ Find all calls in an nmethod and clear the ones that point to non-entrant,\n-  \/\/ zombie and unloaded nmethods.\n+  \/\/ Find all calls in an nmethod and clear the ones that point to bad nmethods.\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":12,"deletions":72,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -143,1 +143,0 @@\n-  friend class NMethodSweeper;\n@@ -217,5 +216,1 @@\n-         not_entrant   = 2,  \/\/ marked for deoptimization but activations may still exist,\n-                             \/\/ will be transformed to zombie when all activations are gone\n-         unloaded      = 3,  \/\/ there should be no activations, should not be called, will be\n-                             \/\/ transformed to zombie by the sweeper, when not \"locked in vm\".\n-         zombie        = 4   \/\/ no activations exist, nmethod is ready for purge\n+         not_entrant   = 2,  \/\/ marked for deoptimization but activations may still exist\n@@ -238,1 +233,0 @@\n-  virtual bool make_zombie() = 0;\n@@ -360,1 +354,0 @@\n-  virtual bool can_convert_to_zombie() = 0;\n@@ -385,2 +378,2 @@\n-  \/\/ Serial version used by sweeper and whitebox test\n-  void cleanup_inline_caches(bool clean_all);\n+  \/\/ Serial version used by whitebox test\n+  void cleanup_inline_caches_whitebox();\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"compiler\/compilationLog.hpp\"\n@@ -38,0 +39,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -73,1 +75,0 @@\n-#include \"runtime\/sweeper.hpp\"\n@@ -444,7 +445,0 @@\n-  _lock_count                 = 0;\n-  _stack_traversal_mark       = 0;\n-  _unload_reported            = false;\n-\n-#ifdef ASSERT\n-  _oops_are_stale             = false;\n-#endif\n@@ -514,1 +508,1 @@\n-  int comp_level\n+  CompLevel comp_level\n@@ -614,1 +608,1 @@\n-  _is_unloading_state(0),\n+  _unlinked_next(NULL),\n@@ -616,1 +610,2 @@\n-  _native_basic_lock_sp_offset(basic_lock_sp_offset)\n+  _native_basic_lock_sp_offset(basic_lock_sp_offset),\n+  _is_unloading_state(0)\n@@ -627,0 +622,1 @@\n+    _comp_level              = CompLevel_none;\n@@ -632,1 +628,1 @@\n-    _gc_epoch                = Continuations::gc_epoch();\n+    _gc_epoch                = CodeCache::gc_epoch();\n@@ -651,1 +647,0 @@\n-    _comp_level              = CompLevel_none;\n@@ -663,1 +658,0 @@\n-    _hotness_counter         = NMethodSweeper::hotness_counter_reset_val();\n@@ -747,1 +741,1 @@\n-  int comp_level\n+  CompLevel comp_level\n@@ -755,1 +749,1 @@\n-  _is_unloading_state(0),\n+  _unlinked_next(NULL),\n@@ -757,1 +751,2 @@\n-  _native_basic_lock_sp_offset(in_ByteSize(-1))\n+  _native_basic_lock_sp_offset(in_ByteSize(-1)),\n+  _is_unloading_state(0)\n@@ -772,2 +767,1 @@\n-    _hotness_counter         = NMethodSweeper::hotness_counter_reset_val();\n-    _gc_epoch                = Continuations::gc_epoch();\n+    _gc_epoch                = CodeCache::gc_epoch();\n@@ -949,1 +943,1 @@\n-void nmethod::maybe_print_nmethod(DirectiveSet* directive) {\n+void nmethod::maybe_print_nmethod(const DirectiveSet* directive) {\n@@ -957,2 +951,0 @@\n-  run_nmethod_entry_barrier(); \/\/ ensure all embedded OOPs are valid before printing\n-\n@@ -1132,1 +1124,0 @@\n-  assert(!is_zombie(), \"\");\n@@ -1184,2 +1175,1 @@\n-        \/\/ Ok, to lookup references to zombies here\n-        CodeBlob *cb = CodeCache::find_blob_unsafe(ic->ic_destination());\n+        CodeBlob *cb = CodeCache::find_blob(ic->ic_destination());\n@@ -1189,1 +1179,1 @@\n-          \/\/ Verify that inline caches pointing to both zombie and not_entrant methods are clean\n+          \/\/ Verify that inline caches pointing to bad nmethods are clean\n@@ -1198,1 +1188,1 @@\n-        CodeBlob *cb = CodeCache::find_blob_unsafe(csc->destination());\n+        CodeBlob *cb = CodeCache::find_blob(csc->destination());\n@@ -1202,1 +1192,1 @@\n-          \/\/ Verify that inline caches pointing to both zombie and not_entrant methods are clean\n+          \/\/ Verify that inline caches pointing to bad nmethods are clean\n@@ -1215,6 +1205,2 @@\n-\/\/ This is a private interface with the sweeper.\n-void nmethod::mark_as_seen_on_stack() {\n-  assert(is_alive(), \"Must be an alive method\");\n-  \/\/ Set the traversal mark to ensure that the sweeper does 2\n-  \/\/ cleaning passes before moving to zombie.\n-  set_stack_traversal_mark(NMethodSweeper::traversal_count());\n+void nmethod::mark_as_maybe_on_stack() {\n+  Atomic::store(&_gc_epoch, CodeCache::gc_epoch());\n@@ -1223,10 +1209,1 @@\n-void nmethod::mark_as_maybe_on_continuation() {\n-  assert(is_alive(), \"Must be an alive method\");\n-  _gc_epoch = Continuations::gc_epoch();\n-}\n-\n-bool nmethod::is_maybe_on_continuation_stack() {\n-  if (!Continuations::enabled()) {\n-    return false;\n-  }\n-\n+bool nmethod::is_maybe_on_stack() {\n@@ -1235,23 +1212,1 @@\n-  return _gc_epoch >= Continuations::previous_completed_gc_marking_cycle();\n-}\n-\n-\/\/ Tell if a non-entrant method can be converted to a zombie (i.e.,\n-\/\/ there are no activations on the stack, not in use by the VM,\n-\/\/ and not in use by the ServiceThread)\n-bool nmethod::can_convert_to_zombie() {\n-  \/\/ Note that this is called when the sweeper has observed the nmethod to be\n-  \/\/ not_entrant. However, with concurrent code cache unloading, the state\n-  \/\/ might have moved on to unloaded if it is_unloading(), due to racing\n-  \/\/ concurrent GC threads.\n-  assert(is_not_entrant() || is_unloading() ||\n-         !Thread::current()->is_Code_cache_sweeper_thread(),\n-         \"must be a non-entrant method if called from sweeper\");\n-\n-  \/\/ Since the nmethod sweeper only does partial sweep the sweeper's traversal\n-  \/\/ count can be greater than the stack traversal count before it hits the\n-  \/\/ nmethod for the second time.\n-  \/\/ If an is_unloading() nmethod is still not_entrant, then it is not safe to\n-  \/\/ convert it to zombie due to GC unloading interactions. However, if it\n-  \/\/ has become unloaded, then it is okay to convert such nmethods to zombie.\n-  return stack_traversal_mark()+1 < NMethodSweeper::traversal_count() && !is_maybe_on_continuation_stack() &&\n-         !is_locked_by_vm() && (!is_unloading() || is_unloaded());\n+  return Atomic::load(&_gc_epoch) >= CodeCache::previous_completed_gc_marking_cycle();\n@@ -1273,110 +1228,5 @@\n-#ifdef ASSERT\n-  if (new_state != unloaded) {\n-    assert_lock_strong(CompiledMethod_lock);\n-  }\n-#endif\n-  for (;;) {\n-    signed char old_state = Atomic::load(&_state);\n-    if (old_state >= new_state) {\n-      \/\/ Ensure monotonicity of transitions.\n-      return false;\n-    }\n-    if (Atomic::cmpxchg(&_state, old_state, new_state) == old_state) {\n-      return true;\n-    }\n-  }\n-}\n-\n-void nmethod::make_unloaded() {\n-  post_compiled_method_unload();\n-\n-  \/\/ This nmethod is being unloaded, make sure that dependencies\n-  \/\/ recorded in instanceKlasses get flushed.\n-  \/\/ Since this work is being done during a GC, defer deleting dependencies from the\n-  \/\/ InstanceKlass.\n-  assert(Universe::heap()->is_gc_active() ||\n-         Thread::current()->is_ConcurrentGC_thread() ||\n-         Thread::current()->is_Worker_thread(),\n-         \"should only be called during gc\");\n-  flush_dependencies(\/*delete_immediately*\/false);\n-\n-  \/\/ Break cycle between nmethod & method\n-  LogTarget(Trace, class, unload, nmethod) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"making nmethod \" INTPTR_FORMAT\n-             \" unloadable, Method*(\" INTPTR_FORMAT\n-             \") \",\n-             p2i(this), p2i(_method));\n-     ls.cr();\n-  }\n-  \/\/ Unlink the osr method, so we do not look this up again\n-  if (is_osr_method()) {\n-    \/\/ Invalidate the osr nmethod only once. Note that with concurrent\n-    \/\/ code cache unloading, OSR nmethods are invalidated before they\n-    \/\/ are made unloaded. Therefore, this becomes a no-op then.\n-    if (is_in_use()) {\n-      invalidate_osr_method();\n-    }\n-#ifdef ASSERT\n-    if (method() != NULL) {\n-      \/\/ Make sure osr nmethod is invalidated, i.e. not on the list\n-      bool found = method()->method_holder()->remove_osr_nmethod(this);\n-      assert(!found, \"osr nmethod should have been invalidated\");\n-    }\n-#endif\n-  }\n-\n-  \/\/ If _method is already NULL the Method* is about to be unloaded,\n-  \/\/ so we don't have to break the cycle. Note that it is possible to\n-  \/\/ have the Method* live here, in case we unload the nmethod because\n-  \/\/ it is pointing to some oop (other than the Method*) being unloaded.\n-  if (_method != NULL) {\n-    _method->unlink_code(this);\n-  }\n-\n-  \/\/ Make the class unloaded - i.e., change state and notify sweeper\n-  assert(SafepointSynchronize::is_at_safepoint() ||\n-         Thread::current()->is_ConcurrentGC_thread() ||\n-         Thread::current()->is_Worker_thread(),\n-         \"must be at safepoint\");\n-\n-  {\n-    \/\/ Clear ICStubs and release any CompiledICHolders.\n-    CompiledICLocker ml(this);\n-    clear_ic_callsites();\n-  }\n-\n-  \/\/ Unregister must be done before the state change\n-  {\n-    MutexLocker ml(SafepointSynchronize::is_at_safepoint() ? NULL : CodeCache_lock,\n-                     Mutex::_no_safepoint_check_flag);\n-    Universe::heap()->unregister_nmethod(this);\n-  }\n-\n-  \/\/ Clear the method of this dead nmethod\n-  set_method(NULL);\n-\n-  \/\/ Log the unloading.\n-  log_state_change();\n-\n-  \/\/ The Method* is gone at this point\n-  assert(_method == NULL, \"Tautology\");\n-\n-  set_osr_link(NULL);\n-  NMethodSweeper::report_state_change(this);\n-\n-  bool transition_success = try_transition(unloaded);\n-\n-  \/\/ It is an important invariant that there exists no race between\n-  \/\/ the sweeper and GC thread competing for making the same nmethod\n-  \/\/ zombie and unloaded respectively. This is ensured by\n-  \/\/ can_convert_to_zombie() returning false for any is_unloading()\n-  \/\/ nmethod, informing the sweeper not to step on any GC toes.\n-  assert(transition_success, \"Invalid nmethod transition to unloaded\");\n-\n-#if INCLUDE_JVMCI\n-  \/\/ Clear the link between this nmethod and a HotSpotNmethod mirror\n-  JVMCINMethodData* nmethod_data = jvmci_nmethod_data();\n-  if (nmethod_data != NULL) {\n-    nmethod_data->invalidate_nmethod_mirror(this);\n+  assert_lock_strong(CompiledMethod_lock);\n+  signed char old_state = _state;\n+  if (old_state >= new_state) {\n+    \/\/ Ensure monotonicity of transitions.\n+    return false;\n@@ -1384,1 +1234,2 @@\n-#endif\n+  Atomic::store(&_state, new_state);\n+  return true;\n@@ -1399,8 +1250,2 @@\n-      if (_state == unloaded) {\n-        xtty->begin_elem(\"make_unloaded thread='\" UINTX_FORMAT \"'\",\n-                         os::current_thread_id());\n-      } else {\n-        xtty->begin_elem(\"make_not_entrant thread='\" UINTX_FORMAT \"'%s\",\n-                         os::current_thread_id(),\n-                         (_state == zombie ? \" zombie='1'\" : \"\"));\n-      }\n+      xtty->begin_elem(\"make_not_entrant thread='\" UINTX_FORMAT \"'\",\n+                       os::current_thread_id());\n@@ -1413,4 +1258,3 @@\n-  const char *state_msg = _state == zombie ? \"made zombie\" : \"made not entrant\";\n-  CompileTask::print_ul(this, state_msg);\n-  if (PrintCompilation && _state != unloaded) {\n-    print_on(tty, state_msg);\n+  CompileTask::print_ul(this, \"made not entrant\");\n+  if (PrintCompilation) {\n+    print_on(tty, \"made not entrant\");\n@@ -1426,5 +1270,4 @@\n-\/**\n- * Common functionality for both make_not_entrant and make_zombie\n- *\/\n-bool nmethod::make_not_entrant_or_zombie(int state) {\n-  assert(state == zombie || state == not_entrant, \"must be zombie or not_entrant\");\n+\/\/ Invalidate code\n+bool nmethod::make_not_entrant() {\n+  \/\/ This can be called while the system is already at a safepoint which is ok\n+  NoSafepointVerifier nsv;\n@@ -1432,1 +1275,7 @@\n-  if (Atomic::load(&_state) >= state) {\n+  if (is_unloading()) {\n+    \/\/ If the nmethod is unloading, then it is already not entrant through\n+    \/\/ the nmethod entry barriers. No need to do anything; GC will unload it.\n+    return false;\n+  }\n+\n+  if (Atomic::load(&_state) == not_entrant) {\n@@ -1440,12 +1289,0 @@\n-  \/\/ Make sure the nmethod is not flushed.\n-  nmethodLocker nml(this);\n-  \/\/ This can be called while the system is already at a safepoint which is ok\n-  NoSafepointVerifier nsv;\n-\n-  \/\/ during patching, depending on the nmethod state we must notify the GC that\n-  \/\/ code has been unloaded, unregistering it. We cannot do this right while\n-  \/\/ holding the CompiledMethod_lock because we need to use the CodeCache_lock. This\n-  \/\/ would be prone to deadlocks.\n-  \/\/ This flag is used to remember whether we need to later lock and unregister.\n-  bool nmethod_needs_unregister = false;\n-\n@@ -1456,9 +1293,1 @@\n-    \/\/ This logic is equivalent to the logic below for patching the\n-    \/\/ verified entry point of regular methods. We check that the\n-    \/\/ nmethod is in use to ensure that it is invalidated only once.\n-    if (is_osr_method() && is_in_use()) {\n-      \/\/ this effectively makes the osr nmethod not entrant\n-      invalidate_osr_method();\n-    }\n-\n-    if (Atomic::load(&_state) >= state) {\n+    if (Atomic::load(&_state) == not_entrant) {\n@@ -1470,3 +1299,8 @@\n-    \/\/ The caller can be calling the method statically or through an inline\n-    \/\/ cache call.\n-    if (!is_osr_method() && !is_not_entrant()) {\n+    if (is_osr_method()) {\n+      \/\/ This logic is equivalent to the logic below for patching the\n+      \/\/ verified entry point of regular methods.\n+      \/\/ this effectively makes the osr nmethod not entrant\n+      invalidate_osr_method();\n+    } else {\n+      \/\/ The caller can be calling the method statically or through an inline\n+      \/\/ cache call.\n@@ -1474,1 +1308,1 @@\n-                  SharedRuntime::get_handle_wrong_method_stub());\n+                                       SharedRuntime::get_handle_wrong_method_stub());\n@@ -1477,3 +1311,2 @@\n-    if (is_in_use() && update_recompile_counts()) {\n-      \/\/ It's a true state change, so mark the method as decompiled.\n-      \/\/ Do it only for transition from alive.\n+    if (update_recompile_counts()) {\n+      \/\/ Mark the method as decompiled.\n@@ -1483,14 +1316,6 @@\n-    \/\/ If the state is becoming a zombie, signal to unregister the nmethod with\n-    \/\/ the heap.\n-    \/\/ This nmethod may have already been unloaded during a full GC.\n-    if ((state == zombie) && !is_unloaded()) {\n-      nmethod_needs_unregister = true;\n-    }\n-\n-    \/\/ Must happen before state change. Otherwise we have a race condition in\n-    \/\/ nmethod::can_convert_to_zombie(). I.e., a method can immediately\n-    \/\/ transition its state from 'not_entrant' to 'zombie' without having to wait\n-    \/\/ for stack scanning.\n-    if (state == not_entrant) {\n-      mark_as_seen_on_stack();\n-      OrderAccess::storestore(); \/\/ _stack_traversal_mark and _state\n+    BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+    if (bs_nm == nullptr || !bs_nm->supports_entry_barrier(this)) {\n+      \/\/ If nmethod entry barriers are not supported, we won't mark\n+      \/\/ nmethods as on-stack when they become on-stack. So we\n+      \/\/ degrade to a less accurate flushing strategy, for now.\n+      mark_as_maybe_on_stack();\n@@ -1500,12 +1325,2 @@\n-    if (!try_transition(state)) {\n-      \/\/ If the transition fails, it is due to another thread making the nmethod more\n-      \/\/ dead. In particular, one thread might be making the nmethod unloaded concurrently.\n-      \/\/ If so, having patched in the jump in the verified entry unnecessarily is fine.\n-      \/\/ The nmethod is no longer possible to call by Java threads.\n-      \/\/ Incrementing the decompile count is also fine as the caller of make_not_entrant()\n-      \/\/ had a valid reason to deoptimize the nmethod.\n-      \/\/ Marking the nmethod as seen on stack also has no effect, as the nmethod is now\n-      \/\/ !is_alive(), and the seen on stack value is only used to convert not_entrant\n-      \/\/ nmethods to zombie in can_convert_to_zombie().\n-      return false;\n-    }\n+    bool success = try_transition(not_entrant);\n+    assert(success, \"Transition can't fail\");\n@@ -1537,15 +1352,2 @@\n-  \/\/ When the nmethod becomes zombie it is no longer alive so the\n-  \/\/ dependencies must be flushed.  nmethods in the not_entrant\n-  \/\/ state will be flushed later when the transition to zombie\n-  \/\/ happens or they get unloaded.\n-  if (state == zombie) {\n-    {\n-      \/\/ Flushing dependencies must be done before any possible\n-      \/\/ safepoint can sneak in, otherwise the oops used by the\n-      \/\/ dependency logic could have become stale.\n-      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-      if (nmethod_needs_unregister) {\n-        Universe::heap()->unregister_nmethod(this);\n-      }\n-      flush_dependencies(\/*delete_immediately*\/true);\n-    }\n+  return true;\n+}\n@@ -1553,7 +1355,8 @@\n-#if INCLUDE_JVMCI\n-    \/\/ Now that the nmethod has been unregistered, it's\n-    \/\/ safe to clear the HotSpotNmethod mirror oop.\n-    if (nmethod_data != NULL) {\n-      nmethod_data->clear_nmethod_mirror(this);\n-    }\n-#endif\n+\/\/ For concurrent GCs, there must be a handshake between unlink and flush\n+void nmethod::unlink() {\n+  if (_unlinked_next != NULL) {\n+    \/\/ Already unlinked. It can be invoked twice because concurrent code cache\n+    \/\/ unloading might need to restart when inline cache cleaning fails due to\n+    \/\/ running out of ICStubs, which can only be refilled at safepoints\n+    return;\n+  }\n@@ -1561,7 +1364,1 @@\n-    \/\/ Clear ICStubs to prevent back patching stubs of zombie or flushed\n-    \/\/ nmethods during the next safepoint (see ICStub::finalize), as well\n-    \/\/ as to free up CompiledICHolder resources.\n-    {\n-      CompiledICLocker ml(this);\n-      clear_ic_callsites();\n-    }\n+  flush_dependencies();\n@@ -1569,6 +1366,6 @@\n-    \/\/ zombie only - if a JVMTI agent has enabled the CompiledMethodUnload\n-    \/\/ event and it hasn't already been reported for this nmethod then\n-    \/\/ report it now. The event may have been reported earlier if the GC\n-    \/\/ marked it for unloading). JvmtiDeferredEventQueue support means\n-    \/\/ we no longer go to a safepoint here.\n-    post_compiled_method_unload();\n+  \/\/ unlink_from_method will take the CompiledMethod_lock.\n+  \/\/ In this case we don't strictly need it when unlinking nmethods from\n+  \/\/ the Method, because it is only concurrently unlinked by\n+  \/\/ the entry barrier, which acquires the per nmethod lock.\n+  unlink_from_method();\n+  clear_ic_callsites();\n@@ -1576,10 +1373,2 @@\n-#ifdef ASSERT\n-    \/\/ It's no longer safe to access the oops section since zombie\n-    \/\/ nmethods aren't scanned for GC.\n-    _oops_are_stale = true;\n-#endif\n-     \/\/ the Method may be reclaimed by class unloading now that the\n-     \/\/ nmethod is in zombie state\n-    set_method(NULL);\n-  } else {\n-    assert(state == not_entrant, \"other cases may need to be handled differently\");\n+  if (is_osr_method()) {\n+    invalidate_osr_method();\n@@ -1588,3 +1377,5 @@\n-  if (TraceCreateZombies && state == zombie) {\n-    ResourceMark m;\n-    tty->print_cr(\"nmethod <\" INTPTR_FORMAT \"> %s code made %s\", p2i(this), this->method() ? this->method()->name_and_sig_as_C_string() : \"null\", (state == not_entrant) ? \"not entrant\" : \"zombie\");\n+#if INCLUDE_JVMCI\n+  \/\/ Clear the link between this nmethod and a HotSpotNmethod mirror\n+  JVMCINMethodData* nmethod_data = jvmci_nmethod_data();\n+  if (nmethod_data != NULL) {\n+    nmethod_data->invalidate_nmethod_mirror(this);\n@@ -1592,0 +1383,1 @@\n+#endif\n@@ -1593,2 +1385,7 @@\n-  NMethodSweeper::report_state_change(this);\n-  return true;\n+  \/\/ Post before flushing as jmethodID is being used\n+  post_compiled_method_unload();\n+\n+  \/\/ Register for flushing when it is safe. For concurrent class unloading,\n+  \/\/ that would be after the unloading handshake, and for STW class unloading\n+  \/\/ that would be when getting back to the VM thread.\n+  CodeCache::register_unlinked(this);\n@@ -1598,7 +1395,1 @@\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  \/\/ Note that there are no valid oops in the nmethod anymore.\n-  assert(!is_osr_method() || is_unloaded() || is_zombie(),\n-         \"osr nmethod must be unloaded or zombie before flushing\");\n-  assert(is_zombie() || is_osr_method(), \"must be a zombie method\");\n-  assert (!is_locked_by_vm(), \"locked methods shouldn't be flushed\");\n-  assert_locked_or_safepoint(CodeCache_lock);\n+  MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -1607,7 +1398,5 @@\n-  Events::log(JavaThread::current(), \"flushing nmethod \" INTPTR_FORMAT, p2i(this));\n-  if (PrintMethodFlushing) {\n-    tty->print_cr(\"*flushing %s nmethod %3d\/\" INTPTR_FORMAT \". Live blobs:\" UINT32_FORMAT\n-                  \"\/Free CodeCache:\" SIZE_FORMAT \"Kb\",\n-                  is_osr_method() ? \"osr\" : \"\",_compile_id, p2i(this), CodeCache::blob_count(),\n-                  CodeCache::unallocated_capacity(CodeCache::get_code_blob_type(this))\/1024);\n-  }\n+  Events::log(Thread::current(), \"flushing nmethod \" INTPTR_FORMAT, p2i(this));\n+  log_debug(codecache)(\"*flushing %s nmethod %3d\/\" INTPTR_FORMAT \". Live blobs:\" UINT32_FORMAT\n+                       \"\/Free CodeCache:\" SIZE_FORMAT \"Kb\",\n+                       is_osr_method() ? \"osr\" : \"\",_compile_id, p2i(this), CodeCache::blob_count(),\n+                       CodeCache::unallocated_capacity(CodeCache::get_code_blob_type(this))\/1024);\n@@ -1619,1 +1408,0 @@\n-  set_exception_cache(NULL);\n@@ -1626,1 +1414,1 @@\n-  Universe::heap()->flush_nmethod(this);\n+  Universe::heap()->unregister_nmethod(this);\n@@ -1649,18 +1437,3 @@\n-\/\/ longer dependent. This should only be called in two situations.\n-\/\/ First, when a nmethod transitions to a zombie all dependents need\n-\/\/ to be clear.  Since zombification happens at a safepoint there's no\n-\/\/ synchronization issues.  The second place is a little more tricky.\n-\/\/ During phase 1 of mark sweep class unloading may happen and as a\n-\/\/ result some nmethods may get unloaded.  In this case the flushing\n-\/\/ of dependencies must happen during phase 1 since after GC any\n-\/\/ dependencies in the unloaded nmethod won't be updated, so\n-\/\/ traversing the dependency information in unsafe.  In that case this\n-\/\/ function is called with a boolean argument and this function only\n-\/\/ notifies instanceKlasses that are reachable\n-\n-void nmethod::flush_dependencies(bool delete_immediately) {\n-  DEBUG_ONLY(bool called_by_gc = Universe::heap()->is_gc_active() ||\n-                                 Thread::current()->is_ConcurrentGC_thread() ||\n-                                 Thread::current()->is_Worker_thread();)\n-  assert(called_by_gc != delete_immediately,\n-  \"delete_immediately is false if and only if we are called during GC\");\n+\/\/ longer dependent.\n+\n+void nmethod::flush_dependencies() {\n@@ -1673,6 +1446,1 @@\n-        if (delete_immediately) {\n-          assert_locked_or_safepoint(CodeCache_lock);\n-          MethodHandles::remove_dependent_nmethod(call_site, this);\n-        } else {\n-          MethodHandles::clean_dependency_context(call_site);\n-        }\n+        MethodHandles::clean_dependency_context(call_site);\n@@ -1684,9 +1452,3 @@\n-        \/\/ During GC delete_immediately is false, and liveness\n-        \/\/ of dependee determines class that needs to be updated.\n-        if (delete_immediately) {\n-          assert_locked_or_safepoint(CodeCache_lock);\n-          InstanceKlass::cast(klass)->remove_dependent_nmethod(this);\n-        } else if (klass->is_loader_alive()) {\n-          \/\/ The GC may clean dependency contexts concurrently and in parallel.\n-          InstanceKlass::cast(klass)->clean_dependency_context();\n-        }\n+        \/\/ During GC liveness of dependee determines class that needs to be updated.\n+        \/\/ The GC may clean dependency contexts concurrently and in parallel.\n+        InstanceKlass::cast(klass)->clean_dependency_context();\n@@ -1698,0 +1460,17 @@\n+void nmethod::post_compiled_method(CompileTask* task) {\n+  task->mark_success();\n+  task->set_nm_content_size(content_size());\n+  task->set_nm_insts_size(insts_size());\n+  task->set_nm_total_size(total_size());\n+\n+  \/\/ JVMTI -- compiled method notification (must be done outside lock)\n+  post_compiled_method_load_event();\n+\n+  if (CompilationLog::log() != NULL) {\n+    CompilationLog::log()->log_nmethod(JavaThread::current(), this);\n+  }\n+\n+  const DirectiveSet* directive = task->directive();\n+  maybe_print_nmethod(directive);\n+}\n+\n@@ -1703,19 +1482,0 @@\n-\n-  \/\/ Don't post this nmethod load event if it is already dying\n-  \/\/ because the sweeper might already be deleting this nmethod.\n-  {\n-    MutexLocker ml(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);\n-    \/\/ When the nmethod is acquired from the CodeCache iterator, it can racingly become zombie\n-    \/\/ before this code is called. Filter them out here under the CompiledMethod_lock.\n-    if (!is_alive()) {\n-      return;\n-    }\n-    \/\/ As for is_alive() nmethods, we also don't want them to racingly become zombie once we\n-    \/\/ release this lock, so we check that this is not going to be the case.\n-    if (is_not_entrant() && can_convert_to_zombie()) {\n-      return;\n-    }\n-    \/\/ Ensure the sweeper can't collect this nmethod until it become \"active\" with JvmtiThreadState::nmethods_do.\n-    mark_as_seen_on_stack();\n-  }\n-\n@@ -1756,7 +1516,1 @@\n-  if (unload_reported()) {\n-    \/\/ During unloading we transition to unloaded and then to zombie\n-    \/\/ and the unloading is reported during the first transition.\n-    return;\n-  }\n-\n-  assert(_method != NULL && !is_unloaded(), \"just checking\");\n+  assert(_method != NULL, \"just checking\");\n@@ -1766,5 +1520,1 @@\n-  \/\/ post the event. Sometime later this nmethod will be made a zombie\n-  \/\/ by the sweeper but the Method* will not be valid at that point.\n-  \/\/ The jmethodID is a weak reference to the Method* so if\n-  \/\/ it's being unloaded there's no way to look it up since the weak\n-  \/\/ ref will have been cleared.\n+  \/\/ post the event. The Method* will not be valid when this is freed.\n@@ -1774,1 +1524,0 @@\n-    assert(!unload_reported(), \"already unloaded\");\n@@ -1780,7 +1529,0 @@\n-\n-  \/\/ The JVMTI CompiledMethodUnload event can be enabled or disabled at\n-  \/\/ any time. As the nmethod is being unloaded now we mark it has\n-  \/\/ having the unload event reported - this will ensure that we don't\n-  \/\/ attempt to report the event in the unlikely scenario where the\n-  \/\/ event is enabled at the time the nmethod is made a zombie.\n-  set_unload_reported();\n@@ -1836,0 +1578,32 @@\n+\/\/ Heuristic for nuking nmethods even though their oops are live.\n+\/\/ Main purpose is to reduce code cache pressure and get rid of\n+\/\/ nmethods that don't seem to be all that relevant any longer.\n+bool nmethod::is_cold() {\n+  if (!MethodFlushing || is_native_method() || is_not_installed()) {\n+    \/\/ No heuristic unloading at all\n+    return false;\n+  }\n+\n+  if (!is_maybe_on_stack() && is_not_entrant()) {\n+    \/\/ Not entrant nmethods that are not on any stack can just\n+    \/\/ be removed\n+    return true;\n+  }\n+\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  if (bs_nm == nullptr || !bs_nm->supports_entry_barrier(this)) {\n+    \/\/ On platforms that don't support nmethod entry barriers, we can't\n+    \/\/ trust the temporal aspect of the gc epochs. So we can't detect\n+    \/\/ cold nmethods on such platforms.\n+    return false;\n+  }\n+\n+  if (!UseCodeCacheFlushing) {\n+    \/\/ Bail out if we don't heuristically remove nmethods\n+    return false;\n+  }\n+\n+  \/\/ Other code can be phased out more gradually after N GCs\n+  return CodeCache::previous_completed_gc_marking_cycle() > _gc_epoch + 2 * CodeCache::cold_gc_count();\n+}\n+\n@@ -1837,1 +1611,1 @@\n-\/\/ and the result of IsUnloadingBehaviour::is_unloading() fpr that cycle.\n+\/\/ and the result of IsUnloadingBehaviour::is_unloading() for that cycle.\n@@ -1888,2 +1662,3 @@\n-  \/\/ The IsUnloadingBehaviour is responsible for checking if there are any dead\n-  \/\/ oops in the CompiledMethod, by calling oops_do on it.\n+  \/\/ The IsUnloadingBehaviour is responsible for calculating if the nmethod\n+  \/\/ should be unloaded. This can be either because there is a dead oop,\n+  \/\/ or because is_cold() heuristically determines it is time to unload.\n@@ -1891,31 +1666,1 @@\n-\n-  if (is_zombie()) {\n-    \/\/ Zombies without calculated unloading epoch are never unloading due to GC.\n-\n-    \/\/ There are no races where a previously observed is_unloading() nmethod\n-    \/\/ suddenly becomes not is_unloading() due to here being observed as zombie.\n-\n-    \/\/ With STW unloading, all is_alive() && is_unloading() nmethods are unlinked\n-    \/\/ and unloaded in the safepoint. That makes races where an nmethod is first\n-    \/\/ observed as is_alive() && is_unloading() and subsequently observed as\n-    \/\/ is_zombie() impossible.\n-\n-    \/\/ With concurrent unloading, all references to is_unloading() nmethods are\n-    \/\/ first unlinked (e.g. IC caches and dependency contexts). Then a global\n-    \/\/ handshake operation is performed with all JavaThreads before finally\n-    \/\/ unloading the nmethods. The sweeper never converts is_alive() && is_unloading()\n-    \/\/ nmethods to zombies; it waits for them to become is_unloaded(). So before\n-    \/\/ the global handshake, it is impossible for is_unloading() nmethods to\n-    \/\/ racingly become is_zombie(). And is_unloading() is calculated for all is_alive()\n-    \/\/ nmethods before taking that global handshake, meaning that it will never\n-    \/\/ be recalculated after the handshake.\n-\n-    \/\/ After that global handshake, is_unloading() nmethods are only observable\n-    \/\/ to the iterators, and they will never trigger recomputation of the cached\n-    \/\/ is_unloading_state, and hence may not suffer from such races.\n-\n-    state_is_unloading = false;\n-  } else {\n-    state_is_unloading = IsUnloadingBehaviour::current()->is_unloading(this);\n-  }\n-\n+  state_is_unloading = IsUnloadingBehaviour::is_unloading(this);\n@@ -1937,2 +1682,1 @@\n-\/\/ oops.\n-\n+\/\/ oops or is heuristically found to be not important.\n@@ -1941,4 +1685,1 @@\n-  assert(!is_zombie() && !is_unloaded(),\n-         \"should not call follow on zombie or unloaded nmethod\");\n-\n-    make_unloaded();\n+    unlink();\n@@ -1957,3 +1698,0 @@\n-  \/\/ make sure the oops ready to receive visitors\n-  assert(allow_dead || is_alive(), \"should not call follow on dead nmethod: %d\", _state);\n-\n@@ -1991,2 +1729,2 @@\n-  \/\/ CodeCache sweeper support\n-  mark_as_maybe_on_continuation();\n+  \/\/ CodeCache unloading support\n+  mark_as_maybe_on_stack();\n@@ -2364,1 +2102,1 @@\n-  NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);\n+  NMethodIterator iter(NMethodIterator::only_not_unloading);\n@@ -2418,11 +2156,0 @@\n-\n-bool nmethod::is_patchable_at(address instr_addr) {\n-  assert(insts_contains(instr_addr), \"wrong nmethod used\");\n-  if (is_zombie()) {\n-    \/\/ a zombie may never be patched\n-    return false;\n-  }\n-  return true;\n-}\n-\n-\n@@ -2434,29 +2161,0 @@\n-\n-\/\/-------------------------------------------------------------------------------------------\n-\n-\n-\/\/ QQQ might we make this work from a frame??\n-nmethodLocker::nmethodLocker(address pc) {\n-  CodeBlob* cb = CodeCache::find_blob(pc);\n-  guarantee(cb != NULL && cb->is_compiled(), \"bad pc for a nmethod found\");\n-  _nm = cb->as_compiled_method();\n-  lock_nmethod(_nm);\n-}\n-\n-\/\/ Only JvmtiDeferredEvent::compiled_method_unload_event()\n-\/\/ should pass zombie_ok == true.\n-void nmethodLocker::lock_nmethod(CompiledMethod* cm, bool zombie_ok) {\n-  if (cm == NULL)  return;\n-  nmethod* nm = cm->as_nmethod();\n-  Atomic::inc(&nm->_lock_count);\n-  assert(zombie_ok || !nm->is_zombie(), \"cannot lock a zombie method: %p\", nm);\n-}\n-\n-void nmethodLocker::unlock_nmethod(CompiledMethod* cm) {\n-  if (cm == NULL)  return;\n-  nmethod* nm = cm->as_nmethod();\n-  Atomic::dec(&nm->_lock_count);\n-  assert(nm->_lock_count >= 0, \"unmatched nmethod lock\/unlock\");\n-}\n-\n-\n@@ -2498,5 +2196,1 @@\n-\n-  \/\/ Hmm. OSR methods can be deopted but not marked as zombie or not_entrant\n-  \/\/ seems odd.\n-\n-  if (is_zombie() || is_not_entrant() || is_unloaded())\n+  if (is_not_entrant())\n@@ -3592,1 +3286,1 @@\n-    CodeBlob* db = CodeCache::find_blob_unsafe(dest);\n+    CodeBlob* db = CodeCache::find_blob(dest);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":174,"deletions":480,"binary":false,"changes":654,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+class CompileTask;\n@@ -70,1 +71,0 @@\n-  friend class NMethodSweeper;\n@@ -75,2 +75,0 @@\n-  \/\/ Shared fields for all nmethod's\n-  int       _entry_bci;        \/\/ != InvocationEntryBci if this nmethod is an on-stack replacement method\n@@ -205,0 +203,5 @@\n+  nmethod* _unlinked_next;\n+\n+  \/\/ Shared fields for all nmethod's\n+  int _entry_bci;      \/\/ != InvocationEntryBci if this nmethod is an on-stack replacement method\n+\n@@ -232,15 +235,0 @@\n-  int _comp_level;                           \/\/ compilation level\n-\n-  \/\/ protected by CodeCache_lock\n-  bool _has_flushed_dependencies;            \/\/ Used for maintenance of dependencies (CodeCache_lock)\n-\n-  \/\/ used by jvmti to track if an event has been posted for this nmethod.\n-  bool _unload_reported;\n-  bool _load_reported;\n-\n-  \/\/ Protected by CompiledMethod_lock\n-  volatile signed char _state;               \/\/ {not_installed, in_use, not_entrant, zombie, unloaded}\n-\n-#ifdef ASSERT\n-  bool _oops_are_stale;  \/\/ indicates that it's no longer safe to access oops section\n-#endif\n@@ -254,23 +242,0 @@\n-  \/\/ Nmethod Flushing lock. If non-zero, then the nmethod is not removed\n-  \/\/ and is not made into a zombie. However, once the nmethod is made into\n-  \/\/ a zombie, it will be locked one final time if CompiledMethodUnload\n-  \/\/ event processing needs to be done.\n-  volatile jint _lock_count;\n-\n-  \/\/ not_entrant method removal. Each mark_sweep pass will update\n-  \/\/ this mark to current sweep invocation count if it is seen on the\n-  \/\/ stack.  An not_entrant method can be removed when there are no\n-  \/\/ more activations, i.e., when the _stack_traversal_mark is less than\n-  \/\/ current sweep traversal index.\n-  volatile int64_t _stack_traversal_mark;\n-\n-  \/\/ The _hotness_counter indicates the hotness of a method. The higher\n-  \/\/ the value the hotter the method. The hotness counter of a nmethod is\n-  \/\/ set to [(ReservedCodeCacheSize \/ (1024 * 1024)) * 2] each time the method\n-  \/\/ is active while stack scanning (do_stack_scanning()). The hotness\n-  \/\/ counter is decreased (by 1) while sweeping.\n-  int _hotness_counter;\n-\n-  \/\/ Local state used to keep track of whether unloading is happening or not\n-  volatile uint8_t _is_unloading_state;\n-\n@@ -288,1 +253,13 @@\n-  friend class nmethodLocker;\n+  CompLevel _comp_level;               \/\/ compilation level\n+\n+  \/\/ Local state used to keep track of whether unloading is happening or not\n+  volatile uint8_t _is_unloading_state;\n+\n+  \/\/ protected by CodeCache_lock\n+  bool _has_flushed_dependencies;      \/\/ Used for maintenance of dependencies (CodeCache_lock)\n+\n+  \/\/ used by jvmti to track if an event has been posted for this nmethod.\n+  bool _load_reported;\n+\n+  \/\/ Protected by CompiledMethod_lock\n+  volatile signed char _state;         \/\/ {not_installed, in_use, not_used, not_entrant}\n@@ -318,1 +295,1 @@\n-          int comp_level\n+          CompLevel comp_level\n@@ -335,1 +312,0 @@\n-  bool make_not_entrant_or_zombie(int state);\n@@ -366,1 +342,1 @@\n-                              int comp_level\n+                              CompLevel comp_level\n@@ -379,2 +355,2 @@\n-      _is_unloading_state(0),\n-      _native_basic_lock_sp_offset(in_ByteSize(-1)) {}\n+      _native_basic_lock_sp_offset(in_ByteSize(-1)),\n+      _is_unloading_state(0) {}\n@@ -444,4 +420,0 @@\n-  void dec_hotness_counter()        { _hotness_counter--; }\n-  void set_hotness_counter(int val) { _hotness_counter = val; }\n-  int  hotness_counter() const      { return _hotness_counter; }\n-\n@@ -464,3 +436,0 @@\n-  bool  is_alive() const                          { return _state < unloaded; }\n-  bool  is_zombie() const                         { return _state == zombie; }\n-  bool  is_unloaded() const                       { return _state == unloaded; }\n@@ -470,0 +439,2 @@\n+  \/\/ Heuristically deduce an nmethod isn't worth keeping around\n+  bool is_cold();\n@@ -473,0 +444,3 @@\n+  nmethod* unlinked_next() const                  { return _unlinked_next; }\n+  void set_unlinked_next(nmethod* next)           { _unlinked_next = next; }\n+\n@@ -486,4 +460,1 @@\n-  bool  make_not_entrant() {\n-    assert(!method()->is_method_handle_intrinsic(), \"Cannot make MH intrinsic not entrant\");\n-    return make_not_entrant_or_zombie(not_entrant);\n-  }\n+  bool  make_not_entrant();\n@@ -491,1 +462,0 @@\n-  bool  make_zombie()      { return make_not_entrant_or_zombie(zombie); }\n@@ -497,2 +467,0 @@\n-  void  make_unloaded();\n-\n@@ -501,1 +469,1 @@\n-  void flush_dependencies(bool delete_immediately);\n+  void flush_dependencies();\n@@ -519,1 +487,0 @@\n-    assert(!_oops_are_stale, \"oops are stale\");\n@@ -544,4 +511,0 @@\n-  \/\/ Sweeper support\n-  int64_t stack_traversal_mark()                  { return _stack_traversal_mark; }\n-  void    set_stack_traversal_mark(int64_t l)     { _stack_traversal_mark = l; }\n-\n@@ -558,3 +521,2 @@\n-  \/\/ unlink and deallocate this nmethod\n-  \/\/ Only NMethodSweeper class is expected to use this. NMethodSweeper is not\n-  \/\/ expected to use any other private methods\/data in this class.\n+  \/\/ Unlink this nmethod from the system\n+  void unlink();\n@@ -562,1 +524,1 @@\n- protected:\n+  \/\/ Deallocate this nmethod - called by the GC\n@@ -565,10 +527,2 @@\n- public:\n-  \/\/ When true is returned, it is unsafe to remove this nmethod even if\n-  \/\/ it is a zombie, since the VM or the ServiceThread might still be\n-  \/\/ using it.\n-  bool is_locked_by_vm() const                    { return _lock_count >0; }\n-\n-  void mark_as_seen_on_stack();\n-  void mark_as_maybe_on_continuation();\n-  bool is_maybe_on_continuation_stack();\n-  bool can_convert_to_zombie();\n+  void mark_as_maybe_on_stack();\n+  bool is_maybe_on_stack();\n@@ -633,3 +587,1 @@\n-  \/\/ used by jvmti to track if the load and unload events has been reported\n-  bool  unload_reported() const                   { return _unload_reported; }\n-  void  set_unload_reported()                     { _unload_reported = true; }\n+  \/\/ used by jvmti to track if the load events has been reported\n@@ -646,0 +598,3 @@\n+  \/\/ Post successful compilation\n+  void post_compiled_method(CompileTask* task);\n+\n@@ -690,1 +645,1 @@\n-  void maybe_print_nmethod(DirectiveSet* directive);\n+  void maybe_print_nmethod(const DirectiveSet* directive);\n@@ -738,3 +693,0 @@\n-  \/\/ is it ok to patch at address?\n-  bool is_patchable_at(address instr_address);\n-\n@@ -768,46 +720,0 @@\n-\/\/ Locks an nmethod so its code will not get removed and it will not\n-\/\/ be made into a zombie, even if it is a not_entrant method. After the\n-\/\/ nmethod becomes a zombie, if CompiledMethodUnload event processing\n-\/\/ needs to be done, then lock_nmethod() is used directly to keep the\n-\/\/ generated code from being reused too early.\n-class nmethodLocker : public StackObj {\n-  CompiledMethod* _nm;\n-\n- public:\n-\n-  \/\/ note: nm can be NULL\n-  \/\/ Only JvmtiDeferredEvent::compiled_method_unload_event()\n-  \/\/ should pass zombie_ok == true.\n-  static void lock_nmethod(CompiledMethod* nm, bool zombie_ok = false);\n-  static void unlock_nmethod(CompiledMethod* nm); \/\/ (ditto)\n-\n-  nmethodLocker(address pc); \/\/ derive nm from pc\n-  nmethodLocker(nmethod *nm) { _nm = nm; lock_nmethod(_nm); }\n-  nmethodLocker(CompiledMethod *nm) {\n-    _nm = nm;\n-    lock(_nm);\n-  }\n-\n-  static void lock(CompiledMethod* method, bool zombie_ok = false) {\n-    if (method == NULL) return;\n-    lock_nmethod(method, zombie_ok);\n-  }\n-\n-  static void unlock(CompiledMethod* method) {\n-    if (method == NULL) return;\n-    unlock_nmethod(method);\n-  }\n-\n-  nmethodLocker() { _nm = NULL; }\n-  ~nmethodLocker() {\n-    unlock(_nm);\n-  }\n-\n-  CompiledMethod* code() { return _nm; }\n-  void set_code(CompiledMethod* new_nm, bool zombie_ok = false) {\n-    unlock(_nm);   \/\/ note:  This works even if _nm==new_nm.\n-    _nm = new_nm;\n-    lock(_nm, zombie_ok);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":40,"deletions":134,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/compilationLog.hpp\"\n@@ -66,1 +67,0 @@\n-#include \"runtime\/sweeper.hpp\"\n@@ -197,44 +197,0 @@\n-\n-\n-class CompilationLog : public StringEventLog {\n- public:\n-  CompilationLog() : StringEventLog(\"Compilation events\", \"jit\") {\n-  }\n-\n-  void log_compile(JavaThread* thread, CompileTask* task) {\n-    StringLogMessage lm;\n-    stringStream sstr(lm.buffer(), lm.size());\n-    \/\/ msg.time_stamp().update_to(tty->time_stamp().ticks());\n-    task->print(&sstr, NULL, true, false);\n-    log(thread, \"%s\", (const char*)lm);\n-  }\n-\n-  void log_nmethod(JavaThread* thread, nmethod* nm) {\n-    log(thread, \"nmethod %d%s \" INTPTR_FORMAT \" code [\" INTPTR_FORMAT \", \" INTPTR_FORMAT \"]\",\n-        nm->compile_id(), nm->is_osr_method() ? \"%\" : \"\",\n-        p2i(nm), p2i(nm->code_begin()), p2i(nm->code_end()));\n-  }\n-\n-  void log_failure(JavaThread* thread, CompileTask* task, const char* reason, const char* retry_message) {\n-    StringLogMessage lm;\n-    lm.print(\"%4d   COMPILE SKIPPED: %s\", task->compile_id(), reason);\n-    if (retry_message != NULL) {\n-      lm.append(\" (%s)\", retry_message);\n-    }\n-    lm.print(\"\\n\");\n-    log(thread, \"%s\", (const char*)lm);\n-  }\n-\n-  void log_metaspace_failure(const char* reason) {\n-    \/\/ Note: This method can be called from non-Java\/compiler threads to\n-    \/\/ log the global metaspace failure that might affect profiling.\n-    ResourceMark rm;\n-    StringLogMessage lm;\n-    lm.print(\"%4d   COMPILE PROFILING SKIPPED: %s\", -1, reason);\n-    lm.print(\"\\n\");\n-    log(Thread::current(), \"%s\", (const char*)lm);\n-  }\n-};\n-\n-static CompilationLog* _compilation_log = NULL;\n-\n@@ -243,1 +199,1 @@\n-    _compilation_log = new CompilationLog();\n+    CompilationLog::init();\n@@ -272,1 +228,0 @@\n-  task->set_code_handle(NULL);\n@@ -455,4 +410,1 @@\n-    \/\/ no need to invoke the sweeper. As a result, the hotness of methods\n-    \/\/ remains unchanged. This behavior is desired, since we want to keep\n-    \/\/ the stable state, i.e., we do not want to evict methods from the\n-    \/\/ code cache if it is unnecessary.\n+    \/\/ no need to invoke the GC.\n@@ -702,2 +654,2 @@\n-  \/\/ Start the compiler thread(s) and the sweeper thread\n-  init_compiler_sweeper_threads();\n+  \/\/ Start the compiler thread(s)\n+  init_compiler_threads();\n@@ -831,1 +783,1 @@\n-\/\/ CompileBroker::init_compiler_sweeper_threads() iff DeoptimizeObjectsALot is enabled\n+\/\/ CompileBroker::init_compiler_threads() iff DeoptimizeObjectsALot is enabled\n@@ -894,3 +846,0 @@\n-    case sweeper_t:\n-      new_thread = new CodeCacheSweeperThread();\n-      break;\n@@ -960,4 +909,1 @@\n-void CompileBroker::init_compiler_sweeper_threads() {\n-  NMethodSweeper::set_sweep_threshold_bytes(static_cast<size_t>(SweeperThreshold * ReservedCodeCacheSize \/ 100.0));\n-  log_info(codecache, sweep)(\"Sweeper threshold: \" SIZE_FORMAT \" bytes\", NMethodSweeper::sweep_threshold_bytes());\n-\n+void CompileBroker::init_compiler_threads() {\n@@ -1035,7 +981,0 @@\n-  if (MethodFlushing) {\n-    \/\/ Initialize the sweeper thread\n-    Handle thread_oop = create_thread_oop(\"Sweeper thread\", CHECK);\n-    jobject thread_handle = JNIHandles::make_local(THREAD, thread_oop());\n-    make_thread(sweeper_t, thread_handle, NULL, NULL, THREAD);\n-  }\n-\n@@ -1759,1 +1698,0 @@\n-    assert(task->code_handle() == NULL, \"must be reset\");\n@@ -1973,2 +1911,0 @@\n-      nmethodLocker result_handle;  \/\/ (handle for the nmethod produced by this task)\n-      task->set_code_handle(&result_handle);\n@@ -2049,2 +1985,2 @@\n-  if (_compilation_log != NULL) {\n-    _compilation_log->log_metaspace_failure(message);\n+  if (CompilationLog::log() != NULL) {\n+    CompilationLog::log()->log_metaspace_failure(message);\n@@ -2126,20 +2062,10 @@\n-void CompileBroker::post_compile(CompilerThread* thread, CompileTask* task, bool success, ciEnv* ci_env,\n-                                 int compilable, const char* failure_reason) {\n-  if (success) {\n-    task->mark_success();\n-    if (ci_env != NULL) {\n-      task->set_num_inlined_bytecodes(ci_env->num_inlined_bytecodes());\n-    }\n-    if (_compilation_log != NULL) {\n-      nmethod* code = task->code();\n-      if (code != NULL) {\n-        _compilation_log->log_nmethod(thread, code);\n-      }\n-    }\n-  } else if (AbortVMOnCompilationFailure) {\n-    if (compilable == ciEnv::MethodCompilable_not_at_tier) {\n-      fatal(\"Not compilable at tier %d: %s\", task->comp_level(), failure_reason);\n-    }\n-    if (compilable == ciEnv::MethodCompilable_never) {\n-      fatal(\"Never compilable: %s\", failure_reason);\n-    }\n+void CompileBroker::handle_compile_error(CompilerThread* thread, CompileTask* task, ciEnv* ci_env,\n+                                         int compilable, const char* failure_reason) {\n+  if (!AbortVMOnCompilationFailure) {\n+    return;\n+  }\n+  if (compilable == ciEnv::MethodCompilable_not_at_tier) {\n+    fatal(\"Not compilable at tier %d: %s\", task->comp_level(), failure_reason);\n+  }\n+  if (compilable == ciEnv::MethodCompilable_never) {\n+    fatal(\"Never compilable: %s\", failure_reason);\n@@ -2158,1 +2084,1 @@\n-                                        (task->code() == NULL) ? 0 : task->code()->total_size(),\n+                                        task->nm_total_size(),\n@@ -2182,2 +2108,2 @@\n-  if (LogEvents) {\n-    _compilation_log->log_compile(thread, task);\n+  if (CompilationLog::log() != NULL) {\n+    CompilationLog::log()->log_compile(thread, task);\n@@ -2206,0 +2132,1 @@\n+    task->set_directive(directive);\n@@ -2248,11 +2175,14 @@\n-      methodHandle method(thread, target_handle);\n-      runtime = env.runtime();\n-      runtime->compile_method(&env, jvmci, method, osr_bci);\n-\n-      failure_reason_on_C_heap = compile_state.failure_reason_on_C_heap();\n-      if (!compile_state.retryable()) {\n-        retry_message = \"not retryable\";\n-        compilable = ciEnv::MethodCompilable_not_at_tier;\n-      }\n-      if (task->code() == NULL) {\n-        assert(failure_reason != NULL, \"must specify failure_reason\");\n+      if (failure_reason == nullptr) {\n+        methodHandle method(thread, target_handle);\n+        runtime = env.runtime();\n+        runtime->compile_method(&env, jvmci, method, osr_bci);\n+\n+        failure_reason = compile_state.failure_reason();\n+        failure_reason_on_C_heap = compile_state.failure_reason_on_C_heap();\n+        if (!compile_state.retryable()) {\n+          retry_message = \"not retryable\";\n+          compilable = ciEnv::MethodCompilable_not_at_tier;\n+        }\n+        if (!task->is_success()) {\n+          assert(failure_reason != NULL, \"must specify failure_reason\");\n+        }\n@@ -2262,1 +2192,3 @@\n-    post_compile(thread, task, task->code() != NULL, NULL, compilable, failure_reason);\n+    if (!task->is_success()) {\n+      handle_compile_error(thread, task, NULL, compilable, failure_reason);\n+    }\n@@ -2323,1 +2255,3 @@\n-    if (!ci_env.failing() && task->code() == NULL) {\n+    DirectivesStack::release(directive);\n+\n+    if (!ci_env.failing() && !task->is_success()) {\n@@ -2339,1 +2273,3 @@\n-    post_compile(thread, task, !ci_env.failing(), &ci_env, compilable, failure_reason);\n+    if (ci_env.failing()) {\n+      handle_compile_error(thread, task, &ci_env, compilable, failure_reason);\n+    }\n@@ -2347,2 +2283,2 @@\n-    if (_compilation_log != NULL) {\n-      _compilation_log->log_failure(thread, task, failure_reason, retry_message);\n+    if (CompilationLog::log() != NULL) {\n+      CompilationLog::log()->log_failure(thread, task, failure_reason, retry_message);\n@@ -2364,6 +2300,0 @@\n-  nmethod* nm = task->code();\n-  if (nm != NULL) {\n-    nm->maybe_print_nmethod(directive);\n-  }\n-  DirectivesStack::release(directive);\n-\n@@ -2374,2 +2304,2 @@\n-    if (task->code() != NULL) {\n-      tty->print(\"size: %d(%d) \", task->code()->total_size(), task->code()->insts_size());\n+    if (task->is_success()) {\n+      tty->print(\"size: %d(%d) \", task->nm_total_size(), task->nm_insts_size());\n@@ -2420,1 +2350,1 @@\n-void CompileBroker::handle_full_code_cache(int code_blob_type) {\n+void CompileBroker::handle_full_code_cache(CodeBlobType code_blob_type) {\n@@ -2448,1 +2378,1 @@\n-        NMethodSweeper::log_sweep(\"disable_compiler\");\n+        log_info(codecache)(\"Code cache is full - disabling compilation\");\n@@ -2515,1 +2445,0 @@\n-  nmethod* code = task->code();\n@@ -2518,1 +2447,0 @@\n-  assert(code == NULL || code->is_locked_by_vm(), \"will survive the MutexLocker\");\n@@ -2537,1 +2465,1 @@\n-  } else if (code == NULL) {\n+  } else if (!task->is_success()) {\n@@ -2571,2 +2499,2 @@\n-        stats->_nmethods_size += code->total_size();\n-        stats->_nmethods_code_size += code->insts_size();\n+        stats->_nmethods_size += task->nm_total_size();\n+        stats->_nmethods_code_size += task->nm_insts_size();\n@@ -2586,2 +2514,2 @@\n-        stats->_nmethods_size += code->total_size();\n-        stats->_nmethods_code_size += code->insts_size();\n+        stats->_nmethods_size += task->nm_total_size();\n+        stats->_nmethods_code_size += task->nm_insts_size();\n@@ -2616,2 +2544,2 @@\n-    _sum_nmethod_size      += code->total_size();\n-    _sum_nmethod_code_size += code->insts_size();\n+    _sum_nmethod_size      += task->nm_total_size();\n+    _sum_nmethod_code_size += task->nm_insts_size();\n@@ -2621,2 +2549,2 @@\n-      _perf_sum_nmethod_size->inc(     code->total_size());\n-      _perf_sum_nmethod_code_size->inc(code->insts_size());\n+      _perf_sum_nmethod_size->inc(     task->nm_total_size());\n+      _perf_sum_nmethod_code_size->inc(task->nm_insts_size());\n@@ -2780,8 +2708,0 @@\n-\n-  out->cr();\n-  out->print_cr(\"CodeCache cleaning overview\");\n-  out->print_cr(\"--------------------------------------------------------\");\n-  out->cr();\n-  NMethodSweeper::print(out);\n-  out->print_cr(\"--------------------------------------------------------\");\n-  out->cr();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":61,"deletions":141,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-size_t G1ParScanThreadState::flush(size_t* surviving_young_words) {\n+size_t G1ParScanThreadState::flush_stats(size_t* surviving_young_words, uint num_workers) {\n@@ -118,1 +118,1 @@\n-  _plab_allocator->flush_and_retire_stats();\n+  _plab_allocator->flush_and_retire_stats(num_workers);\n@@ -200,1 +200,1 @@\n-         p2i(obj), _g1h->addr_to_region(cast_from_oop<HeapWord*>(obj)), p2i(p));\n+         p2i(obj), _g1h->addr_to_region(obj), p2i(p));\n@@ -583,1 +583,1 @@\n-void G1ParScanThreadStateSet::flush() {\n+void G1ParScanThreadStateSet::flush_stats() {\n@@ -596,1 +596,1 @@\n-    size_t copied_bytes = pss->flush(_surviving_young_words_total) * HeapWordSize;\n+    size_t copied_bytes = pss->flush_stats(_surviving_young_words_total, _n_workers) * HeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-#include \"runtime\/continuation.hpp\"\n@@ -966,2 +965,2 @@\n-  Continuations::on_gc_marking_cycle_start();\n-  Continuations::arm_all_nmethods();\n+  CodeCache::on_gc_marking_cycle_start();\n+  CodeCache::arm_all_nmethods();\n@@ -999,2 +998,2 @@\n-  Continuations::on_gc_marking_cycle_finish();\n-  Continuations::arm_all_nmethods();\n+  CodeCache::on_gc_marking_cycle_finish();\n+  CodeCache::arm_all_nmethods();\n@@ -2060,0 +2059,1 @@\n+    CodeCache::UnloadingScope scope(is_alive_closure());\n@@ -2065,1 +2065,1 @@\n-    CodeCache::do_unloading(is_alive_closure(), purged_class);\n+    CodeCache::do_unloading(purged_class);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -88,5 +88,3 @@\n-  } else if (Continuations::enabled()) {\n-    \/\/ The GC needs nmethod entry barriers to deal with continuations\n-    return new BarrierSetNMethod();\n-    \/\/ The GC does not need nmethod entry barriers\n-    return NULL;\n+    \/\/ The GC needs nmethod entry barriers to deal with continuations\n+    \/\/ and code cache unloading\n+    return NOT_ARM32(new BarrierSetNMethod()) ARM32_ONLY(nullptr);\n@@ -110,2 +108,2 @@\n-  if (Continuations::enabled()) {\n-    BarrierSetNMethod* bs_nm = barrier_set_nmethod();\n+  BarrierSetNMethod* bs_nm = barrier_set_nmethod();\n+  if (bs_nm != nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -483,2 +483,0 @@\n-  \/\/ Callback for when nmethod is about to be deleted.\n-  virtual void flush_nmethod(nmethod* nm) = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2821,2 +2821,0 @@\n-               u->Opcode() == Op_StoreIConditional ||\n-               u->Opcode() == Op_StoreLConditional ||\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-  res = load_reference_barrier(decorators, res, reinterpret_cast<T*>(NULL));\n+  res = load_reference_barrier(decorators, res, static_cast<T*>(nullptr));\n@@ -214,1 +214,1 @@\n-  previous = load_reference_barrier<T>(decorators, previous, reinterpret_cast<T*>(NULL));\n+  previous = load_reference_barrier<T>(decorators, previous, static_cast<T*>(nullptr));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -113,0 +114,12 @@\n+#if INCLUDE_CDS\n+  if (!HAS_PENDING_EXCEPTION && Arguments::is_dumping_archive()) {\n+    if (_pool->pool_holder()->is_shared()) {\n+      assert(DynamicDumpSharedSpaces, \"must be\");\n+      \/\/ We are linking a shared class from the base archive. This\n+      \/\/ class won't be written into the dynamic archive, so there's no\n+      \/\/ need to save its CpCaches.\n+    } else {\n+      cache->save_for_archive(THREAD);\n+    }\n+  }\n+#endif\n@@ -118,5 +131,0 @@\n-  } else {\n-    DEBUG_ONLY(\n-    if (DumpSharedSpaces) {\n-      cache->verify_just_initialized();\n-    })\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -654,1 +654,0 @@\n-    nmethodLocker& nmethod_handle,\n@@ -732,0 +731,1 @@\n+    nmethod* nm = NULL; \/\/ nm is an out parameter of register_method\n@@ -734,1 +734,1 @@\n-                                        nmethod_handle,\n+                                        nm,\n@@ -756,1 +756,0 @@\n-      nmethod* nm = nmethod_handle.code()->as_nmethod_or_null();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,0 +66,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -516,1 +519,1 @@\n-      resolved_klass = SystemDictionary::find_instance_klass(strippedsym,\n+      resolved_klass = SystemDictionary::find_instance_klass(THREAD, strippedsym,\n@@ -524,1 +527,1 @@\n-        resolved_klass = SystemDictionary::find_instance_klass(strippedsym,\n+        resolved_klass = SystemDictionary::find_instance_klass(THREAD, strippedsym,\n@@ -534,1 +537,1 @@\n-      resolved_klass = SystemDictionary::find_instance_klass(class_name,\n+      resolved_klass = SystemDictionary::find_instance_klass(THREAD, class_name,\n@@ -757,1 +760,1 @@\n-C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index, jbyte opcode))\n+C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index, jbyte opcode, ARGUMENT_PAIR(caller)))\n@@ -759,0 +762,1 @@\n+  methodHandle caller(THREAD, UNPACK_PAIR(Method, caller));\n@@ -762,0 +766,1 @@\n+  JFR_ONLY(if (method.not_null()) Jfr::on_resolution(caller(), method(), CHECK_NULL);)\n@@ -939,1 +944,1 @@\n-  nmethodLocker nmethod_handle;\n+\n@@ -947,1 +952,0 @@\n-      nmethod_handle,\n@@ -974,1 +978,1 @@\n-        JVMCIENV->invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK_0);\n+        JVMCIENV->invalidate_nmethod_mirror(nmethod_mirror, true, JVMCI_CHECK_0);\n@@ -1000,2 +1004,1 @@\n-  nmethodLocker locker;\n-  CodeBlob* cb = JVMCIENV->get_code_blob(installedCodeObject, locker);\n+  CodeBlob* cb = JVMCIENV->get_code_blob(installedCodeObject);\n@@ -1015,6 +1018,0 @@\n-  if (cb->is_nmethod()) {\n-    nmethod* nm = (nmethod*) cb;\n-    if (!nm->is_alive()) {\n-      return NULL;\n-    }\n-  }\n@@ -1046,2 +1043,1 @@\n-  nmethodLocker locker;\n-  nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror, locker);\n+  nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror);\n@@ -1152,1 +1148,1 @@\n-C2V_VMENTRY(void, invalidateHotSpotNmethod, (JNIEnv* env, jobject, jobject hs_nmethod))\n+C2V_VMENTRY(void, invalidateHotSpotNmethod, (JNIEnv* env, jobject, jobject hs_nmethod, jboolean deoptimize))\n@@ -1154,1 +1150,1 @@\n-  JVMCIENV->invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK);\n+  JVMCIENV->invalidate_nmethod_mirror(nmethod_mirror, deoptimize, JVMCI_CHECK);\n@@ -2517,6 +2513,5 @@\n-    nmethodLocker locker;\n-    nmethod* nm = JVMCIENV->get_nmethod(obj, locker);\n-    if (nm != NULL) {\n-      JVMCINMethodData* data = nm->jvmci_nmethod_data();\n-      if (data != NULL) {\n-        if (peerEnv->is_hotspot()) {\n+    if (peerEnv->is_hotspot()) {\n+      nmethod* nm = JVMCIENV->get_nmethod(obj);\n+      if (nm != NULL) {\n+        JVMCINMethodData* data = nm->jvmci_nmethod_data();\n+        if (data != NULL) {\n@@ -2532,0 +2527,1 @@\n+\n@@ -2541,0 +2537,1 @@\n+      nmethod* nm = JVMCIENV->get_nmethod(obj);\n@@ -2592,2 +2589,1 @@\n-  nmethodLocker locker;\n-  JVMCIENV->get_nmethod(code, locker);\n+  JVMCIENV->get_nmethod(code);\n@@ -2598,2 +2594,1 @@\n-  nmethodLocker locker;\n-  CodeBlob* cb = JVMCIENV->get_code_blob(code, locker);\n+  CodeBlob* cb = JVMCIENV->get_code_blob(code);\n@@ -2603,0 +2598,1 @@\n+  \/\/ Make a resource copy of code before the allocation causes a safepoint\n@@ -2604,0 +2600,3 @@\n+  jbyte* code_bytes = NEW_RESOURCE_ARRAY(jbyte, code_size);\n+  memcpy(code_bytes, (jbyte*) cb->code_begin(), code_size);\n+\n@@ -2605,1 +2604,1 @@\n-  JVMCIENV->copy_bytes_from((jbyte*) cb->code_begin(), result, 0, code_size);\n+  JVMCIENV->copy_bytes_from(code_bytes, result, 0, code_size);\n@@ -2837,1 +2836,1 @@\n-  {CC \"lookupMethodInPool\",                           CC \"(\" HS_CONSTANT_POOL2 \"IB)\" HS_METHOD,                                             FN_PTR(lookupMethodInPool)},\n+  {CC \"lookupMethodInPool\",                           CC \"(\" HS_CONSTANT_POOL2 \"IB\" HS_METHOD2 \")\" HS_METHOD,                               FN_PTR(lookupMethodInPool)},\n@@ -2866,1 +2865,1 @@\n-  {CC \"invalidateHotSpotNmethod\",                     CC \"(\" HS_NMETHOD \")V\",                                                               FN_PTR(invalidateHotSpotNmethod)},\n+  {CC \"invalidateHotSpotNmethod\",                     CC \"(\" HS_NMETHOD \"Z)V\",                                                              FN_PTR(invalidateHotSpotNmethod)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":31,"deletions":32,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-  nonstatic_field(MethodCounters,              _nmethod_age,                                  int)                                   \\\n@@ -258,1 +257,1 @@\n-  nonstatic_field(nmethod,                     _comp_level,                                   int)                                   \\\n+  nonstatic_field(nmethod,                     _comp_level,                                   CompLevel)                             \\\n@@ -369,0 +368,1 @@\n+  declare_integer_type(CompLevel)                                         \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,18 +100,0 @@\n-\/\/ In non product mode we introduce a super class for all allocation classes\n-\/\/ that supports printing.\n-\/\/ We avoid the superclass in product mode to save space.\n-\n-#ifdef PRODUCT\n-#define ALLOCATION_SUPER_CLASS_SPEC\n-#else\n-#define ALLOCATION_SUPER_CLASS_SPEC : public AllocatedObj\n-class AllocatedObj {\n- public:\n-  \/\/ Printing support\n-  void print() const;\n-  void print_value() const;\n-\n-  virtual void print_on(outputStream* st) const;\n-  virtual void print_value_on(outputStream* st) const;\n-};\n-#endif\n@@ -196,1 +178,1 @@\n-template <MEMFLAGS F> class CHeapObj ALLOCATION_SUPER_CLASS_SPEC {\n+template <MEMFLAGS F> class CHeapObj {\n@@ -241,1 +223,1 @@\n-class StackObj ALLOCATION_SUPER_CLASS_SPEC {\n+class StackObj {\n@@ -292,0 +274,1 @@\n+#if INCLUDE_CDS\n@@ -299,0 +282,4 @@\n+#else\n+  static bool is_shared(const MetaspaceObj* p) { return false; }\n+  bool is_shared() const { return false; }\n+#endif\n@@ -390,1 +377,1 @@\n-class ResourceObj ALLOCATION_SUPER_CLASS_SPEC {\n+class ResourceObj {\n@@ -442,0 +429,6 @@\n+\n+#ifndef PRODUCT\n+  \/\/ Printing support\n+  void print() const;\n+  virtual void print_on(outputStream* st) const;\n+#endif \/\/ PRODUCT\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  \/\/ The code cache sweeper needs to get notified about methods from stackChunkOops\n+  \/\/ The code cache unloading needs to get notified about methods from stackChunkOops\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -314,2 +314,2 @@\n-    AccessT::arraycopy(src_obj, src_offset_in_bytes, reinterpret_cast<const T*>(NULL),\n-                       dst_obj, dst_offset_in_bytes, reinterpret_cast<T*>(NULL),\n+    AccessT::arraycopy(src_obj, src_offset_in_bytes, static_cast<const T*>(nullptr),\n+                       dst_obj, dst_offset_in_bytes, static_cast<T*>(nullptr),\n@@ -323,1 +323,1 @@\n-    AccessT::arraycopy(src_obj, src_offset_in_bytes, reinterpret_cast<const T*>(NULL),\n+    AccessT::arraycopy(src_obj, src_offset_in_bytes, static_cast<const T*>(nullptr),\n@@ -333,1 +333,1 @@\n-                       dst_obj, dst_offset_in_bytes, reinterpret_cast<T*>(NULL),\n+                       dst_obj, dst_offset_in_bytes, static_cast<T*>(nullptr),\n@@ -340,2 +340,2 @@\n-    AccessT::oop_arraycopy(src_obj, src_offset_in_bytes, reinterpret_cast<const HeapWord*>(NULL),\n-                           dst_obj, dst_offset_in_bytes, reinterpret_cast<HeapWord*>(NULL),\n+    AccessT::oop_arraycopy(src_obj, src_offset_in_bytes, static_cast<const HeapWord*>(nullptr),\n+                           dst_obj, dst_offset_in_bytes, static_cast<HeapWord*>(nullptr),\n","filename":"src\/hotspot\/share\/oops\/access.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -188,0 +188,1 @@\n+#if INCLUDE_CDS\n@@ -214,0 +215,1 @@\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,0 +140,1 @@\n+#if INCLUDE_CDS\n@@ -144,0 +145,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -334,0 +334,1 @@\n+#if INCLUDE_CDS\n@@ -347,3 +348,0 @@\n-  \/\/ restore the C++ vtable from the shared archive\n-  restore_vtable();\n-\n@@ -429,0 +427,1 @@\n+    \/\/ cache() is NULL if this class is not yet linked.\n@@ -432,0 +431,1 @@\n+#endif \/\/ INCLUDE_CDS\n@@ -627,1 +627,1 @@\n-    Klass* k = SystemDictionary::find_instance_klass(name, h_loader, h_prot);\n+    Klass* k = SystemDictionary::find_instance_klass(current, name, h_loader, h_prot);\n@@ -2062,2 +2062,2 @@\n-\/\/ SymbolHashMap is used to find a constant pool index from a string.\n-\/\/ This function fills in SymbolHashMaps, one for utf8s and one for\n+\/\/ SymbolHash is used to find a constant pool index from a string.\n+\/\/ This function fills in SymbolHashs, one for utf8s and one for\n@@ -2065,2 +2065,2 @@\n-jint ConstantPool::hash_entries_to(SymbolHashMap *symmap,\n-                                          SymbolHashMap *classmap) {\n+jint ConstantPool::hash_entries_to(SymbolHash *symmap,\n+                                   SymbolHash *classmap) {\n@@ -2076,1 +2076,1 @@\n-        symmap->add_entry(sym, idx);\n+        symmap->add_if_absent(sym, idx);\n@@ -2084,1 +2084,1 @@\n-        classmap->add_entry(sym, idx);\n+        classmap->add_if_absent(sym, idx);\n@@ -2105,2 +2105,2 @@\n-                                          SymbolHashMap* tbl,\n-                                          unsigned char *bytes) {\n+                                   SymbolHash* tbl,\n+                                   unsigned char *bytes) {\n@@ -2269,2 +2269,2 @@\n-bool ConstantPool::is_maybe_on_continuation_stack() const {\n-  \/\/ This method uses the similar logic as nmethod::is_maybe_on_continuation_stack()\n+bool ConstantPool::is_maybe_on_stack() const {\n+  \/\/ This method uses the similar logic as nmethod::is_maybe_on_stack()\n@@ -2277,1 +2277,1 @@\n-  return cache()->gc_epoch() >= Continuations::previous_completed_gc_marking_cycle();\n+  return cache()->gc_epoch() >= CodeCache::previous_completed_gc_marking_cycle();\n@@ -2292,1 +2292,1 @@\n-  return is_maybe_on_continuation_stack();\n+  return is_maybe_on_stack();\n@@ -2326,1 +2326,1 @@\n-  st->print_cr(\" - resolved_references: \" INTPTR_FORMAT, p2i(resolved_references()));\n+  st->print_cr(\" - resolved_references: \" INTPTR_FORMAT, p2i(resolved_references_or_null()));\n@@ -2329,0 +2329,1 @@\n+  st->print_cr(\" - cp length: %d\", length());\n@@ -2483,56 +2484,0 @@\n-\n-\n-SymbolHashMap::~SymbolHashMap() {\n-  SymbolHashMapEntry* next;\n-  for (int i = 0; i < _table_size; i++) {\n-    for (SymbolHashMapEntry* cur = bucket(i); cur != NULL; cur = next) {\n-      next = cur->next();\n-      delete(cur);\n-    }\n-  }\n-  FREE_C_HEAP_ARRAY(SymbolHashMapBucket, _buckets);\n-}\n-\n-void SymbolHashMap::add_entry(Symbol* sym, u2 value) {\n-  char *str = sym->as_utf8();\n-  unsigned int hash = compute_hash(str, sym->utf8_length());\n-  unsigned int index = hash % table_size();\n-\n-  \/\/ check if already in map\n-  \/\/ we prefer the first entry since it is more likely to be what was used in\n-  \/\/ the class file\n-  for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en->next()) {\n-    assert(en->symbol() != NULL, \"SymbolHashMapEntry symbol is NULL\");\n-    if (en->hash() == hash && en->symbol() == sym) {\n-        return;  \/\/ already there\n-    }\n-  }\n-\n-  SymbolHashMapEntry* entry = new SymbolHashMapEntry(hash, sym, value);\n-  entry->set_next(bucket(index));\n-  _buckets[index].set_entry(entry);\n-  assert(entry->symbol() != NULL, \"SymbolHashMapEntry symbol is NULL\");\n-}\n-\n-SymbolHashMapEntry* SymbolHashMap::find_entry(Symbol* sym) {\n-  assert(sym != NULL, \"SymbolHashMap::find_entry - symbol is NULL\");\n-  char *str = sym->as_utf8();\n-  int   len = sym->utf8_length();\n-  unsigned int hash = SymbolHashMap::compute_hash(str, len);\n-  unsigned int index = hash % table_size();\n-  for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en->next()) {\n-    assert(en->symbol() != NULL, \"SymbolHashMapEntry symbol is NULL\");\n-    if (en->hash() == hash && en->symbol() == sym) {\n-      return en;\n-    }\n-  }\n-  return NULL;\n-}\n-\n-void SymbolHashMap::initialize_table(int table_size) {\n-  _table_size = table_size;\n-  _buckets = NEW_C_HEAP_ARRAY(SymbolHashMapBucket, table_size, mtSymbol);\n-  for (int index = 0; index < table_size; index++) {\n-    _buckets[index].clear();\n-  }\n-}\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":18,"deletions":73,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -50,2 +51,0 @@\n-class SymbolHashMap;\n-\n@@ -209,1 +208,1 @@\n-  bool is_maybe_on_continuation_stack() const;\n+  bool is_maybe_on_stack() const;\n@@ -704,0 +703,1 @@\n+#if INCLUDE_CDS\n@@ -710,5 +710,1 @@\n-  \/\/ The ConstantPool vtable is restored by this call when the ConstantPool is\n-  \/\/ in the shared archive.  See patch_klass_vtables() in metaspaceShared.cpp for\n-  \/\/ all the gory details.  SA, dtrace and pstack helpers distinguish metadata\n-  \/\/ by their vtable.\n-  void restore_vtable() { guarantee(is_constantPool(), \"vtable restored by this call\"); }\n+#endif\n@@ -902,0 +898,15 @@\n+  class SymbolHash: public CHeapObj<mtSymbol> {\n+    ResourceHashtable<const Symbol*, u2, 256, ResourceObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n+\n+   public:\n+    void add_if_absent(const Symbol* sym, u2 value) {\n+      bool created;\n+      _table.put_if_absent(sym, value, &created);\n+    }\n+\n+    u2 symbol_to_value(const Symbol* sym) {\n+      u2* value = _table.get(sym);\n+      return (value == nullptr) ? 0 : *value;\n+    }\n+  }; \/\/ End SymbolHash class\n+\n@@ -903,1 +914,1 @@\n-  jint hash_entries_to(SymbolHashMap *symmap, SymbolHashMap *classmap);\n+  jint hash_entries_to(SymbolHash *symmap, SymbolHash *classmap);\n@@ -911,1 +922,1 @@\n-                        SymbolHashMap* tbl,\n+                        SymbolHash* tbl,\n@@ -926,84 +937,0 @@\n-class SymbolHashMapEntry : public CHeapObj<mtSymbol> {\n- private:\n-  SymbolHashMapEntry* _next;   \/\/ Next element in the linked list for this bucket\n-  Symbol*             _symbol; \/\/ 1-st part of the mapping: symbol => value\n-  unsigned int        _hash;   \/\/ 32-bit hash for item\n-  u2                  _value;  \/\/ 2-nd part of the mapping: symbol => value\n-\n- public:\n-  unsigned   int hash() const             { return _hash;   }\n-  void       set_hash(unsigned int hash)  { _hash = hash;   }\n-\n-  SymbolHashMapEntry* next() const        { return _next;   }\n-  void set_next(SymbolHashMapEntry* next) { _next = next;   }\n-\n-  Symbol*    symbol() const               { return _symbol; }\n-  void       set_symbol(Symbol* sym)      { _symbol = sym;  }\n-\n-  u2         value() const                {  return _value; }\n-  void       set_value(u2 value)          { _value = value; }\n-\n-  SymbolHashMapEntry(unsigned int hash, Symbol* symbol, u2 value)\n-    : _next(NULL), _symbol(symbol), _hash(hash), _value(value) {}\n-\n-}; \/\/ End SymbolHashMapEntry class\n-\n-\n-class SymbolHashMapBucket : public CHeapObj<mtSymbol> {\n-\n-private:\n-  SymbolHashMapEntry*    _entry;\n-\n-public:\n-  SymbolHashMapEntry* entry() const         {  return _entry; }\n-  void set_entry(SymbolHashMapEntry* entry) { _entry = entry; }\n-  void clear()                              { _entry = NULL;  }\n-\n-}; \/\/ End SymbolHashMapBucket class\n-\n-\n-class SymbolHashMap: public CHeapObj<mtSymbol> {\n-\n- private:\n-  \/\/ Default number of entries in the table\n-  enum SymbolHashMap_Constants {\n-    _Def_HashMap_Size = 256\n-  };\n-\n-  int                   _table_size;\n-  SymbolHashMapBucket*  _buckets;\n-\n-  void initialize_table(int table_size);\n-\n- public:\n-\n-  int table_size() const        { return _table_size; }\n-\n-  SymbolHashMap()               { initialize_table(_Def_HashMap_Size); }\n-  SymbolHashMap(int table_size) { initialize_table(table_size); }\n-\n-  \/\/ hash P(31) from Kernighan & Ritchie\n-  static unsigned int compute_hash(const char* str, int len) {\n-    unsigned int hash = 0;\n-    while (len-- > 0) {\n-      hash = 31*hash + (unsigned) *str;\n-      str++;\n-    }\n-    return hash;\n-  }\n-\n-  SymbolHashMapEntry* bucket(int i) {\n-    return _buckets[i].entry();\n-  }\n-\n-  void add_entry(Symbol* sym, u2 value);\n-  SymbolHashMapEntry* find_entry(Symbol* sym);\n-\n-  u2 symbol_to_value(Symbol* sym) {\n-    SymbolHashMapEntry *entry = find_entry(sym);\n-    return (entry == NULL) ? 0 : entry->value();\n-  }\n-\n-  ~SymbolHashMap();\n-}; \/\/ End SymbolHashMap class\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":21,"deletions":94,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -49,1 +52,0 @@\n-#include \"runtime\/continuation.hpp\"\n@@ -65,18 +67,0 @@\n-void ConstantPoolCacheEntry::verify_just_initialized(bool f2_used) {\n-  assert((_indices & (~cp_index_mask)) == 0, \"sanity\");\n-  assert(_f1 == NULL, \"sanity\");\n-  assert(_flags == 0, \"sanity\");\n-  if (!f2_used) {\n-    assert(_f2 == 0, \"sanity\");\n-  }\n-}\n-\n-void ConstantPoolCacheEntry::reinitialize(bool f2_used) {\n-  _indices &= cp_index_mask;\n-  _f1 = NULL;\n-  _flags = 0;\n-  if (!f2_used) {\n-    _f2 = 0;\n-  }\n-}\n-\n@@ -706,1 +690,1 @@\n-  _gc_epoch = Continuations::gc_epoch();\n+  _gc_epoch = CodeCache::gc_epoch();\n@@ -709,2 +693,7 @@\n-void ConstantPoolCache::verify_just_initialized() {\n-  DEBUG_ONLY(walk_entries_for_initialization(\/*check_only = *\/ true));\n+#if INCLUDE_CDS\n+void ConstantPoolCache::save_for_archive(TRAPS) {\n+  ClassLoaderData* loader_data = constant_pool()->pool_holder()->class_loader_data();\n+  _initial_entries = MetadataFactory::new_array<ConstantPoolCacheEntry>(loader_data, length(), CHECK);\n+  for (int i = 0; i < length(); i++) {\n+    _initial_entries->at_put(i, *entry_at(i));\n+  }\n@@ -714,53 +703,9 @@\n-  walk_entries_for_initialization(\/*check_only = *\/ false);\n-}\n-\n-void ConstantPoolCache::walk_entries_for_initialization(bool check_only) {\n-  \/\/ When dumping the archive, we want to clean up the ConstantPoolCache\n-  \/\/ to remove any effect of linking due to the execution of Java code --\n-  \/\/ each ConstantPoolCacheEntry will have the same contents as if\n-  \/\/ ConstantPoolCache::initialize has just returned:\n-  \/\/\n-  \/\/ - We keep the ConstantPoolCache::constant_pool_index() bits for all entries.\n-  \/\/ - We keep the \"f2\" field for entries used by invokedynamic and invokehandle\n-  \/\/ - All other bits in the entries are cleared to zero.\n-  ResourceMark rm;\n-\n-  InstanceKlass* ik = constant_pool()->pool_holder();\n-  bool* f2_used = NEW_RESOURCE_ARRAY(bool, length());\n-  memset(f2_used, 0, sizeof(bool) * length());\n-\n-  Thread* current = Thread::current();\n-\n-  \/\/ Find all the slots that we need to preserve f2\n-  for (int i = 0; i < ik->methods()->length(); i++) {\n-    Method* m = ik->methods()->at(i);\n-    RawBytecodeStream bcs(methodHandle(current, m));\n-    while (!bcs.is_last_bytecode()) {\n-      Bytecodes::Code opcode = bcs.raw_next();\n-      switch (opcode) {\n-      case Bytecodes::_invokedynamic: {\n-          int index = Bytes::get_native_u4(bcs.bcp() + 1);\n-          int cp_cache_index = constant_pool()->invokedynamic_cp_cache_index(index);\n-          f2_used[cp_cache_index] = 1;\n-        }\n-        break;\n-      case Bytecodes::_invokehandle: {\n-          int cp_cache_index = Bytes::get_native_u2(bcs.bcp() + 1);\n-          f2_used[cp_cache_index] = 1;\n-        }\n-        break;\n-      default:\n-        break;\n-      }\n-    }\n-  }\n-\n-  if (check_only) {\n-    DEBUG_ONLY(\n-      for (int i=0; i<length(); i++) {\n-        entry_at(i)->verify_just_initialized(f2_used[i]);\n-      })\n-  } else {\n-    for (int i=0; i<length(); i++) {\n-      entry_at(i)->reinitialize(f2_used[i]);\n-    }\n+  \/\/ <this> is the copy to be written into the archive. It's in the ArchiveBuilder's \"buffer space\".\n+  \/\/ However, this->_initial_entries was not copied\/relocated by the ArchiveBuilder, so it's\n+  \/\/ still pointing to the array allocated inside save_for_archive().\n+  assert(_initial_entries != NULL, \"archived cpcache must have been initialized\");\n+  assert(!ArchiveBuilder::current()->is_in_buffer_space(_initial_entries), \"must be\");\n+  for (int i=0; i<length(); i++) {\n+    \/\/ Restore each entry to the initial state -- just after Rewriter::make_constant_pool_cache()\n+    \/\/ has finished.\n+    *entry_at(i) = _initial_entries->at(i);\n@@ -769,0 +714,1 @@\n+  _initial_entries = NULL;\n@@ -770,0 +716,1 @@\n+#endif \/\/ INCLUDE_CDS\n@@ -777,0 +724,7 @@\n+#if INCLUDE_CDS\n+  if (_initial_entries != NULL) {\n+    Arguments::assert_is_dumping_archive();\n+    MetadataFactory::free_array<ConstantPoolCacheEntry>(data, _initial_entries);\n+    _initial_entries = NULL;\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":29,"deletions":75,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -399,3 +399,0 @@\n-\n-  void verify_just_initialized(bool f2_used);\n-  void reinitialize(bool f2_used);\n@@ -417,0 +414,5 @@\n+\n+  \/\/ The narrowOop pointer to the archived resolved_references. Set at CDS dump\n+  \/\/ time when caching java heap object is supported.\n+  CDS_JAVA_HEAP_ONLY(int _archived_references_index;) \/\/ Gap on LP64\n+\n@@ -429,3 +431,1 @@\n-  \/\/ The narrowOop pointer to the archived resolved_references. Set at CDS dump\n-  \/\/ time when caching java heap object is supported.\n-  CDS_JAVA_HEAP_ONLY(int _archived_references_index;)\n+  CDS_ONLY(Array<ConstantPoolCacheEntry>* _initial_entries;)\n@@ -468,1 +468,1 @@\n-  \/\/ CDS support\n+#if INCLUDE_CDS\n@@ -470,1 +470,3 @@\n-  void verify_just_initialized();\n+  void save_for_archive(TRAPS);\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -551,1 +551,7 @@\n-      (*jmpFct)(this, bci + 3, data);\n+      \/\/ Class files verified by the old verifier can have a conditional branch\n+      \/\/ as their last bytecode, provided the conditional branch is unreachable\n+      \/\/ during execution.  Check if this instruction is the method's last bytecode\n+      \/\/ and, if so, don't call the jmpFct.\n+      if (bci + 3 < method()->code_size()) {\n+        (*jmpFct)(this, bci + 3, data);\n+      }\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -628,1 +628,0 @@\n-\n@@ -2543,4 +2542,0 @@\n-void InstanceKlass::remove_dependent_nmethod(nmethod* nm) {\n-  dependencies().remove_dependent_nmethod(nm);\n-}\n-\n@@ -2664,0 +2659,1 @@\n+#if INCLUDE_CDS\n@@ -2876,0 +2872,1 @@\n+#endif \/\/ INCLUDE_CDS\n@@ -3104,1 +3101,1 @@\n-        _package_entry = loader_data->packages()->lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n+        _package_entry = loader_data->packages()->create_entry_if_absent(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n@@ -3107,2 +3104,1 @@\n-        _package_entry = loader_data->packages()->lookup(pkg_name,\n-                                                         loader_data->unnamed_module());\n+        _package_entry = loader_data->packages()->create_entry_if_absent(pkg_name, loader_data->unnamed_module());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1048,1 +1048,0 @@\n-  void remove_dependent_nmethod(nmethod* nm);\n@@ -1337,0 +1336,2 @@\n+\n+#if INCLUDE_CDS\n@@ -1343,0 +1344,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -541,0 +541,1 @@\n+#if INCLUDE_CDS\n@@ -631,0 +632,1 @@\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -570,0 +570,1 @@\n+#if INCLUDE_CDS\n@@ -571,0 +572,1 @@\n+#endif\n@@ -579,0 +581,1 @@\n+#if INCLUDE_CDS\n@@ -594,0 +597,1 @@\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -414,0 +414,1 @@\n+#if INCLUDE_CDS\n@@ -424,0 +425,5 @@\n+void Method::restore_unshareable_info(TRAPS) {\n+  assert(is_method() && is_valid_method(this), \"ensure C++ vtable is restored\");\n+}\n+#endif\n+\n@@ -652,4 +658,0 @@\n-  if (LogTouchedMethods) {\n-    mh->log_touched(current);\n-  }\n-\n@@ -1011,1 +1013,1 @@\n-    return SystemDictionary::find_instance_klass(klass_name, loader, prot) != NULL;\n+    return SystemDictionary::find_instance_klass(thread, klass_name, loader, prot) != NULL;\n@@ -1211,3 +1213,0 @@\n-  \/\/ If the vep() points to the zombie nmethod, the memory for the nmethod\n-  \/\/ could be flushed and the compiler and vtable stubs could still call\n-  \/\/ through it.\n@@ -1319,4 +1318,0 @@\n-void Method::restore_unshareable_info(TRAPS) {\n-  assert(is_method() && is_valid_method(this), \"ensure C++ vtable is restored\");\n-}\n-\n@@ -2557,79 +2552,0 @@\n-\/\/ LogTouchedMethods and PrintTouchedMethods\n-\n-\/\/ TouchedMethodRecord -- we can't use a HashtableEntry<Method*> because\n-\/\/ the Method may be garbage collected. Let's roll our own hash table.\n-class TouchedMethodRecord : CHeapObj<mtTracing> {\n-public:\n-  \/\/ It's OK to store Symbols here because they will NOT be GC'ed if\n-  \/\/ LogTouchedMethods is enabled.\n-  TouchedMethodRecord* _next;\n-  Symbol* _class_name;\n-  Symbol* _method_name;\n-  Symbol* _method_signature;\n-};\n-\n-static const int TOUCHED_METHOD_TABLE_SIZE = 20011;\n-static TouchedMethodRecord** _touched_method_table = NULL;\n-\n-void Method::log_touched(Thread* current) {\n-\n-  const int table_size = TOUCHED_METHOD_TABLE_SIZE;\n-  Symbol* my_class = klass_name();\n-  Symbol* my_name  = name();\n-  Symbol* my_sig   = signature();\n-\n-  unsigned int hash = my_class->identity_hash() +\n-                      my_name->identity_hash() +\n-                      my_sig->identity_hash();\n-  juint index = juint(hash) % table_size;\n-\n-  MutexLocker ml(current, TouchedMethodLog_lock);\n-  if (_touched_method_table == NULL) {\n-    _touched_method_table = NEW_C_HEAP_ARRAY2(TouchedMethodRecord*, table_size,\n-                                              mtTracing, CURRENT_PC);\n-    memset(_touched_method_table, 0, sizeof(TouchedMethodRecord*)*table_size);\n-  }\n-\n-  TouchedMethodRecord* ptr = _touched_method_table[index];\n-  while (ptr) {\n-    if (ptr->_class_name       == my_class &&\n-        ptr->_method_name      == my_name &&\n-        ptr->_method_signature == my_sig) {\n-      return;\n-    }\n-    if (ptr->_next == NULL) break;\n-    ptr = ptr->_next;\n-  }\n-  TouchedMethodRecord* nptr = NEW_C_HEAP_OBJ(TouchedMethodRecord, mtTracing);\n-  my_class->increment_refcount();\n-  my_name->increment_refcount();\n-  my_sig->increment_refcount();\n-  nptr->_class_name         = my_class;\n-  nptr->_method_name        = my_name;\n-  nptr->_method_signature   = my_sig;\n-  nptr->_next               = NULL;\n-\n-  if (ptr == NULL) {\n-    \/\/ first\n-    _touched_method_table[index] = nptr;\n-  } else {\n-    ptr->_next = nptr;\n-  }\n-}\n-\n-void Method::print_touched_methods(outputStream* out) {\n-  MutexLocker ml(Thread::current()->is_VM_thread() ? NULL : TouchedMethodLog_lock);\n-  out->print_cr(\"# Method::print_touched_methods version 1\");\n-  if (_touched_method_table) {\n-    for (int i = 0; i < TOUCHED_METHOD_TABLE_SIZE; i++) {\n-      TouchedMethodRecord* ptr = _touched_method_table[i];\n-      while(ptr) {\n-        ptr->_class_name->print_symbol_on(out);       out->print(\".\");\n-        ptr->_method_name->print_symbol_on(out);      out->print(\":\");\n-        ptr->_method_signature->print_symbol_on(out); out->cr();\n-        ptr = ptr->_next;\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":7,"deletions":91,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/vmSymbols.hpp\"\n@@ -144,0 +143,2 @@\n+#if INCLUDE_CDS\n+  void remove_unshareable_info();\n@@ -145,0 +146,1 @@\n+#endif\n@@ -416,8 +418,0 @@\n-  int nmethod_age() const {\n-    if (method_counters() == NULL) {\n-      return INT_MAX;\n-    } else {\n-      return method_counters()->nmethod_age();\n-    }\n-  }\n-\n@@ -444,4 +438,0 @@\n-  \/\/ Clear (non-shared space) pointers which could not be relevant\n-  \/\/ if this (shared) method were mapped into another JVM.\n-  void remove_unshareable_info();\n-\n@@ -761,3 +751,2 @@\n-  bool is_continuation_enter_intrinsic() const { return intrinsic_id() == vmIntrinsics::_Continuation_enterSpecial; }\n-\n-  bool is_special_native_intrinsic() const { return is_method_handle_intrinsic() || is_continuation_enter_intrinsic(); }\n+  inline bool is_continuation_enter_intrinsic() const;\n+  inline bool is_special_native_intrinsic() const;\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -100,0 +101,7 @@\n+inline bool Method::is_continuation_enter_intrinsic() const {\n+  return intrinsic_id() == vmIntrinsics::_Continuation_enterSpecial;\n+}\n+inline bool Method::is_special_native_intrinsic() const {\n+  return is_method_handle_intrinsic() || is_continuation_enter_intrinsic();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -175,0 +175,10 @@\n+  static void maybe_increment_refcount(Symbol* s) {\n+    if (s != NULL) {\n+      s->increment_refcount();\n+    }\n+  }\n+  static void maybe_decrement_refcount(Symbol* s) {\n+    if (s != NULL) {\n+      s->decrement_refcount();\n+    }\n+  }\n@@ -303,0 +313,4 @@\n+  static unsigned int compute_hash(const Symbol* const& name) {\n+    return (unsigned int) name->identity_hash();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1097,0 +1097,79 @@\n+\/\/ Ideal transformations for MaxINode\n+Node* MaxINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Force a right-spline graph\n+  Node* l = in(1);\n+  Node* r = in(2);\n+  \/\/ Transform  MaxI1(MaxI2(a, b), c)  into  MaxI1(a, MaxI2(b, c))\n+  \/\/ to force a right-spline graph for the rest of MaxINode::Ideal().\n+  if (l->Opcode() == Op_MaxI) {\n+    assert(l != l->in(1), \"dead loop in MaxINode::Ideal\");\n+    r = phase->transform(new MaxINode(l->in(2), r));\n+    l = l->in(1);\n+    set_req_X(1, l, phase);\n+    set_req_X(2, r, phase);\n+    return this;\n+  }\n+\n+  \/\/ Get left input & constant\n+  Node* x = l;\n+  jint x_off = 0;\n+  if (x->Opcode() == Op_AddI && \/\/ Check for \"x+c0\" and collect constant\n+      x->in(2)->is_Con()) {\n+    const Type* t = x->in(2)->bottom_type();\n+    if (t == Type::TOP) return NULL;  \/\/ No progress\n+    x_off = t->is_int()->get_con();\n+    x = x->in(1);\n+  }\n+\n+  \/\/ Scan a right-spline-tree for MAXs\n+  Node* y = r;\n+  jint y_off = 0;\n+  \/\/ Check final part of MAX tree\n+  if (y->Opcode() == Op_AddI && \/\/ Check for \"y+c1\" and collect constant\n+      y->in(2)->is_Con()) {\n+    const Type* t = y->in(2)->bottom_type();\n+    if (t == Type::TOP) return NULL;  \/\/ No progress\n+    y_off = t->is_int()->get_con();\n+    y = y->in(1);\n+  }\n+  if (x->_idx > y->_idx && r->Opcode() != Op_MaxI) {\n+    swap_edges(1, 2);\n+    return this;\n+  }\n+\n+  const TypeInt* tx = phase->type(x)->isa_int();\n+\n+  if (r->Opcode() == Op_MaxI) {\n+    assert(r != r->in(2), \"dead loop in MaxINode::Ideal\");\n+    y = r->in(1);\n+    \/\/ Check final part of MAX tree\n+    if (y->Opcode() == Op_AddI &&\/\/ Check for \"y+c1\" and collect constant\n+        y->in(2)->is_Con()) {\n+      const Type* t = y->in(2)->bottom_type();\n+      if (t == Type::TOP) return NULL;  \/\/ No progress\n+      y_off = t->is_int()->get_con();\n+      y = y->in(1);\n+    }\n+\n+    if (x->_idx > y->_idx)\n+      return new MaxINode(r->in(1), phase->transform(new MaxINode(l, r->in(2))));\n+\n+    \/\/ Transform MAX2(x + c0, MAX2(x + c1, z)) into MAX2(x + MAX2(c0, c1), z)\n+    \/\/ if x == y and the additions can't overflow.\n+    if (x == y && tx != NULL &&\n+        !can_overflow(tx, x_off) &&\n+        !can_overflow(tx, y_off)) {\n+      return new MaxINode(phase->transform(new AddINode(x, phase->intcon(MAX2(x_off, y_off)))), r->in(2));\n+    }\n+  } else {\n+    \/\/ Transform MAX2(x + c0, y + c1) into x + MAX2(c0, c1)\n+    \/\/ if x == y and the additions can't overflow.\n+    if (x == y && tx != NULL &&\n+        !can_overflow(tx, x_off) &&\n+        !can_overflow(tx, y_off)) {\n+      return new AddINode(x, phase->intcon(MAX2(x_off, y_off)));\n+    }\n+  }\n+ return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -266,0 +267,6 @@\n+  case vmIntrinsics::_reverse_i:\n+    if (!Matcher::match_rule_supported(Op_ReverseI)) return false;\n+    break;\n+  case vmIntrinsics::_reverse_l:\n+    if (!Matcher::match_rule_supported(Op_ReverseL)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/os.inline.hpp\"\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1788,1 +1788,0 @@\n-  init_req( ValidLengthTest    , topnode);\n@@ -1822,0 +1821,48 @@\n+\/\/=============================================================================\n+Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  if (remove_dead_region(phase, can_reshape))  return this;\n+  \/\/ Don't bother trying to transform a dead node\n+  if (in(0) && in(0)->is_top())  return NULL;\n+\n+  const Type* type = phase->type(Ideal_length());\n+  if (type->isa_int() && type->is_int()->_hi < 0) {\n+    if (can_reshape) {\n+      PhaseIterGVN *igvn = phase->is_IterGVN();\n+      \/\/ Unreachable fall through path (negative array length),\n+      \/\/ the allocation can only throw so disconnect it.\n+      Node* proj = proj_out_or_null(TypeFunc::Control);\n+      Node* catchproj = NULL;\n+      if (proj != NULL) {\n+        for (DUIterator_Fast imax, i = proj->fast_outs(imax); i < imax; i++) {\n+          Node *cn = proj->fast_out(i);\n+          if (cn->is_Catch()) {\n+            catchproj = cn->as_Multi()->proj_out_or_null(CatchProjNode::fall_through_index);\n+            break;\n+          }\n+        }\n+      }\n+      if (catchproj != NULL && catchproj->outcnt() > 0 &&\n+          (catchproj->outcnt() > 1 ||\n+           catchproj->unique_out()->Opcode() != Op_Halt)) {\n+        assert(catchproj->is_CatchProj(), \"must be a CatchProjNode\");\n+        Node* nproj = catchproj->clone();\n+        igvn->register_new_node_with_optimizer(nproj);\n+\n+        Node *frame = new ParmNode( phase->C->start(), TypeFunc::FramePtr );\n+        frame = phase->transform(frame);\n+        \/\/ Halt & Catch Fire\n+        Node* halt = new HaltNode(nproj, frame, \"unexpected negative array length\");\n+        phase->C->root()->add_req(halt);\n+        phase->transform(halt);\n+\n+        igvn->replace_node(catchproj, phase->C->top());\n+        return this;\n+      }\n+    } else {\n+      \/\/ Can't correct it during regular GVN so register for IGVN\n+      phase->C->record_for_igvn(this);\n+    }\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -916,1 +916,0 @@\n-    ValidLengthTest,\n@@ -929,1 +928,0 @@\n-    fields[ValidLengthTest] = TypeInt::BOOL;\n@@ -1026,4 +1024,7 @@\n-  AllocateArrayNode(Compile* C, const TypeFunc *atype, Node *ctrl, Node *mem, Node *abio, Node* size, Node* klass_node,\n-                    Node* initial_test, Node* count_val, Node* valid_length_test,\n-                    Node* default_value, Node* raw_default_value)\n-    : AllocateNode(C, atype, ctrl, mem, abio, size, klass_node, initial_test)\n+  AllocateArrayNode(Compile* C, const TypeFunc *atype, Node *ctrl, Node *mem, Node *abio,\n+                    Node* size, Node* klass_node, Node* initial_test,\n+                    Node* count_val,\n+                    Node* default_value, Node* raw_default_value\n+                    )\n+    : AllocateNode(C, atype, ctrl, mem, abio, size, klass_node,\n+                   initial_test)\n@@ -1033,1 +1034,0 @@\n-    set_req(AllocateNode::ValidLengthTest, valid_length_test);\n@@ -1038,0 +1038,1 @@\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2886,11 +2886,0 @@\n-      } else if (call->is_AllocateArray()) {\n-        Node* klass_node = call->in(AllocateNode::KlassNode);\n-        Node* length = call->in(AllocateNode::ALength);\n-        const Type* length_type = phase->type(length);\n-        const Type* klass_type = phase->type(klass_node);\n-        Node* valid_length_test = call->in(AllocateNode::ValidLengthTest);\n-        const Type* valid_length_test_t = phase->type(valid_length_test);\n-        if (length_type == Type::TOP || klass_type == Type::TOP || valid_length_test_t == Type::TOP ||\n-            valid_length_test_t->is_int()->is_con(0)) {\n-          f[CatchProjNode::fall_through_index] = Type::TOP;\n-        }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -210,1 +210,0 @@\n-macro(LoadPLocked)\n@@ -341,3 +340,0 @@\n-macro(StorePConditional)\n-macro(StoreIConditional)\n-macro(StoreLConditional)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -413,1 +413,1 @@\n-void Compile::disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist) {\n+void Compile::remove_useless_nodes(Unique_Node_List &useful) {\n@@ -436,1 +436,1 @@\n-      worklist->push(n->unique_out());\n+      record_for_igvn(n->unique_out());\n@@ -439,1 +439,1 @@\n-      worklist->push(n);\n+      record_for_igvn(n);\n@@ -1046,1 +1046,0 @@\n-  set_age_code(has_method() && method()->profile_aging());\n@@ -3744,1 +3743,0 @@\n-  case Op_StorePConditional:\n@@ -3747,2 +3745,0 @@\n-  case Op_StoreIConditional:\n-  case Op_StoreLConditional:\n@@ -3788,1 +3784,0 @@\n-  case Op_LoadPLocked:\n@@ -4508,1 +4503,1 @@\n-          CallNode* call = n->in(0)->in(0)->as_Call();\n+          CallNode *call = n->in(0)->in(0)->as_Call();\n@@ -4517,1 +4512,1 @@\n-            Node* arg0 = call->in(TypeFunc::Parms);\n+            Node *arg0 = call->in(TypeFunc::Parms);\n@@ -4522,3 +4517,4 @@\n-          } else if (call->entry_point() == OptoRuntime::new_array_Java() ||\n-                     call->entry_point() == OptoRuntime::new_array_nozero_Java()) {\n-            \/\/ Check for illegal array length. In such case, the optimizer has\n+          } else if (call->entry_point() == OptoRuntime::new_array_Java() &&\n+                     call->req() > TypeFunc::Parms+1 &&\n+                     call->is_CallStaticJava()) {\n+            \/\/ Check for negative array length. In such case, the optimizer has\n@@ -4527,5 +4523,3 @@\n-            assert(call->is_CallStaticJava(), \"static call expected\");\n-            assert(call->req() == call->jvms()->endoff() + 1, \"missing extra input\");\n-            Node* valid_length_test = call->in(call->req()-1);\n-            call->del_req(call->req()-1);\n-            if (valid_length_test->find_int_con(1) == 0) {\n+            Node *arg1 = call->in(TypeFunc::Parms+1);\n+            if (arg1->is_Type() &&\n+                arg1->as_Type()->type()->join(TypeInt::POS)->empty()) {\n@@ -4534,2 +4528,0 @@\n-            assert(n->outcnt() == required_outcnt, \"malformed control flow\");\n-            continue;\n@@ -4544,8 +4536,0 @@\n-    } else if (n->is_PCTable() && n->in(0) && n->in(0)->in(0) && n->in(0)->in(0)->is_Call()) {\n-      CallNode* call = n->in(0)->in(0)->as_Call();\n-      if (call->entry_point() == OptoRuntime::new_array_Java() ||\n-          call->entry_point() == OptoRuntime::new_array_nozero_Java()) {\n-        assert(call->is_CallStaticJava(), \"static call expected\");\n-        assert(call->req() == call->jvms()->endoff() + 1, \"missing extra input\");\n-        call->del_req(call->req()-1); \/\/ valid length test useless now\n-      }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":12,"deletions":28,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -332,1 +332,0 @@\n-  bool                  _age_code;              \/\/ True if we need to profile code age (decrement the aging counter)\n@@ -626,2 +625,0 @@\n-  bool              age_code() const             { return _age_code; }\n-  void          set_age_code(bool z)             { _age_code = z; }\n@@ -979,1 +976,1 @@\n-  void              disconnect_useless_nodes(Unique_Node_List &useful, Unique_Node_List* worklist);\n+  void              remove_useless_nodes(Unique_Node_List &useful);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -607,2 +607,1 @@\n-    case Op_LoadN:\n-    case Op_LoadPLocked: {\n+    case Op_LoadN: {\n@@ -663,1 +662,0 @@\n-    case Op_StorePConditional:\n@@ -767,2 +765,1 @@\n-    case Op_LoadN:\n-    case Op_LoadPLocked: {\n+    case Op_LoadN: {\n@@ -823,2 +820,1 @@\n-    case Op_StoreNKlass:\n-    case Op_StorePConditional:{\n+    case Op_StoreNKlass:{\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2758,3 +2758,1 @@\n-  Node* norm = new CatchProjNode(catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci);\n-  _gvn.set_type_bottom(norm);\n-  C->record_for_igvn(norm);\n+  Node* norm = _gvn.transform( new CatchProjNode(catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci) );\n@@ -4268,8 +4266,0 @@\n-  Node* valid_length_test = _gvn.intcon(1);\n-  if (ary_type->isa_aryptr()) {\n-    BasicType bt = ary_type->isa_aryptr()->elem()->array_element_basic_type();\n-    jint max = TypeAryPtr::max_array_length(bt);\n-    Node* valid_length_cmp  = _gvn.transform(new CmpUNode(length, intcon(max)));\n-    valid_length_test = _gvn.transform(new BoolNode(valid_length_cmp, BoolTest::le));\n-  }\n-\n@@ -4335,7 +4325,7 @@\n-  AllocateArrayNode* alloc = new AllocateArrayNode(C, AllocateArrayNode::alloc_type(TypeInt::INT),\n-                                                   control(), mem, i_o(),\n-                                                   size, klass_node,\n-                                                   initial_slow_test,\n-                                                   length, valid_length_test,\n-                                                   default_value, raw_default_value);\n-\n+  AllocateArrayNode* alloc\n+    = new AllocateArrayNode(C, AllocateArrayNode::alloc_type(TypeInt::INT),\n+                            control(), mem, i_o(),\n+                            size, klass_node,\n+                            initial_slow_test,\n+                            length,\n+                            default_value, raw_default_value);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/os.inline.hpp\"\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -536,0 +536,2 @@\n+  case vmIntrinsics::_reverse_i:\n+  case vmIntrinsics::_reverse_l:\n@@ -2071,0 +2073,2 @@\n+  case vmIntrinsics::_reverse_i:                n = new ReverseINode(0, arg); break;\n+  case vmIntrinsics::_reverse_l:                n = new ReverseLNode(0, arg); break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2338,4 +2338,1 @@\n-      if (outer_loop->is_member(u_loop) ||\n-          \/\/ nodes pinned with control in the outer loop but not referenced from the safepoint must be moved out of\n-          \/\/ the outer loop too\n-          (u->in(0) != NULL && outer_loop->is_member(phase->get_loop(u->in(0))))) {\n+      if (outer_loop->is_member(u_loop)) {\n@@ -2343,0 +2340,10 @@\n+      } else {\n+        \/\/ nodes pinned with control in the outer loop but not referenced from the safepoint must be moved out of\n+        \/\/ the outer loop too\n+        Node* u_c = u->in(0);\n+        if (u_c != NULL) {\n+          IdealLoopTree* u_c_loop = phase->get_loop(u_c);\n+          if (outer_loop->is_member(u_c_loop) && !loop->is_member(u_c_loop)) {\n+            wq.push(u);\n+          }\n+        }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -493,1 +493,2 @@\n-  if (req() > 2) {\n+  \/\/ A MachContant has the last input being the constant base\n+  if (req() > (is_MachConstant() ? 3U : 2U)) {\n@@ -497,1 +498,1 @@\n-  if (req() == 2 && in(1) && in(1)->ideal_reg() == Op_RegFlags) {\n+  if (req() >= 2 && in(1) && in(1)->ideal_reg() == Op_RegFlags) {\n@@ -500,1 +501,1 @@\n-    if (in(1)->req() > 2) {\n+    if (in(1)->req() > (in(1)->is_MachConstant() ? 3U : 2U)) {\n@@ -510,1 +511,1 @@\n-    if (rm.is_bound(ideal_reg())) {\n+    if (rm.is_NotEmpty() && rm.is_bound(ideal_reg())) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -139,0 +139,8 @@\n+#if defined(AARCH64)\n+  PRegister as_PRegister(PhaseRegAlloc* ra_, const Node* node) const {\n+    return ::as_PRegister(reg(ra_, node));\n+  }\n+  PRegister as_PRegister(PhaseRegAlloc* ra_, const Node* node, int idx) const {\n+    return ::as_PRegister(reg(ra_, node, idx));\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1320,2 +1320,1 @@\n-            address slow_call_address,  \/\/ Address of slow call\n-            Node* valid_length_test \/\/ whether length is valid or not\n+            address slow_call_address  \/\/ Address of slow call\n@@ -1510,6 +1509,0 @@\n-  \/\/ For array allocations, copy the valid length check to the call node so Compile::final_graph_reshaping() can verify\n-  \/\/ that the call has the expected number of CatchProj nodes (in case the allocation always fails and the fallthrough\n-  \/\/ path dies).\n-  if (valid_length_test != NULL) {\n-    call->add_req(valid_length_test);\n-  }\n@@ -2003,1 +1996,1 @@\n-                         OptoRuntime::new_instance_Java(), NULL);\n+                         OptoRuntime::new_instance_Java());\n@@ -2008,1 +2001,0 @@\n-  Node* valid_length_test = alloc->in(AllocateNode::ValidLengthTest);\n@@ -2023,1 +2015,1 @@\n-                         slow_call_address, valid_length_test);\n+                         slow_call_address);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -94,2 +94,2 @@\n-                              address slow_call_address,\n-                              Node* valid_length_test);\n+                              address slow_call_address);\n+  void yank_initalize_node(InitializeNode* node);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#include \"runtime\/os.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n@@ -2370,3 +2370,0 @@\n-    case Op_StorePConditional:\n-    case Op_StoreIConditional:\n-    case Op_StoreLConditional:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -802,13 +802,0 @@\n-\/\/------------------------------LoadPLockedNode---------------------------------\n-\/\/ Load-locked a pointer from memory (either object or array).\n-\/\/ On Sparc & Intel this is implemented as a normal pointer load.\n-\/\/ On PowerPC and friends it's a real load-locked.\n-class LoadPLockedNode : public LoadPNode {\n-public:\n-  LoadPLockedNode(Node *c, Node *mem, Node *adr, MemOrd mo)\n-    : LoadPNode(c, mem, adr, TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM, mo) {}\n-  virtual int Opcode() const;\n-  virtual int store_Opcode() const { return Op_StorePConditional; }\n-  virtual bool depends_only_on_test() const { return true; }\n-};\n-\n@@ -871,33 +858,0 @@\n-\/\/------------------------------StorePConditionalNode---------------------------\n-\/\/ Conditionally store pointer to memory, if no change since prior\n-\/\/ load-locked.  Sets flags for success or failure of the store.\n-class StorePConditionalNode : public LoadStoreConditionalNode {\n-public:\n-  StorePConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }\n-  virtual int Opcode() const;\n-  \/\/ Produces flags\n-  virtual uint ideal_reg() const { return Op_RegFlags; }\n-};\n-\n-\/\/------------------------------StoreIConditionalNode---------------------------\n-\/\/ Conditionally store int to memory, if no change since prior\n-\/\/ load-locked.  Sets flags for success or failure of the store.\n-class StoreIConditionalNode : public LoadStoreConditionalNode {\n-public:\n-  StoreIConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ii ) : LoadStoreConditionalNode(c, mem, adr, val, ii) { }\n-  virtual int Opcode() const;\n-  \/\/ Produces flags\n-  virtual uint ideal_reg() const { return Op_RegFlags; }\n-};\n-\n-\/\/------------------------------StoreLConditionalNode---------------------------\n-\/\/ Conditionally store long to memory, if no change since prior\n-\/\/ load-locked.  Sets flags for success or failure of the store.\n-class StoreLConditionalNode : public LoadStoreConditionalNode {\n-public:\n-  StoreLConditionalNode( Node *c, Node *mem, Node *adr, Node *val, Node *ll ) : LoadStoreConditionalNode(c, mem, adr, val, ll) { }\n-  virtual int Opcode() const;\n-  \/\/ Produces flags\n-  virtual uint ideal_reg() const { return Op_RegFlags; }\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -254,6 +254,4 @@\n-  \/\/ Swap constant to right\n-  jint con;\n-  if ((con = in(1)->find_int_con(0)) != 0) {\n-    swap_edges(1, 2);\n-    \/\/ Finish rest of method to use info in 'con'\n-  } else if ((con = in(2)->find_int_con(0)) == 0) {\n+  const jint con = in(2)->find_int_con(0);\n+  if (con == 0) {\n+    \/\/ If in(2) is not a constant, call Ideal() of the parent class to\n+    \/\/ try to move constant to the right side.\n@@ -263,3 +261,5 @@\n-  \/\/ Now we have a constant Node on the right and the constant in con\n-  if (con == 0) return NULL;   \/\/ By zero is handled by Value call\n-  if (con == 1) return NULL;   \/\/ By one  is handled by Identity call\n+  \/\/ Now we have a constant Node on the right and the constant in con.\n+  if (con == 1) {\n+    \/\/ By one is handled by Identity call\n+    return NULL;\n+  }\n@@ -285,5 +285,0 @@\n-      if (!phase->C->post_loop_opts_phase()) {\n-        \/\/ Defer this because it breaks loop range check hoisting\n-        phase->C->record_for_post_loop_opts_igvn(this);\n-        return MulNode::Ideal(phase, can_reshape);\n-      }\n@@ -294,5 +289,1 @@\n-      if (!phase->C->post_loop_opts_phase()) {\n-        \/\/ Defer this because it breaks loop range check hoisting\n-        phase->C->record_for_post_loop_opts_igvn(this);\n-        return MulNode::Ideal(phase, can_reshape);\n-      }\n+      \/\/ Sleezy: power-of-2 - 1.  Next time be generic.\n@@ -358,6 +349,4 @@\n-  \/\/ Swap constant to right\n-  jlong con;\n-  if ((con = in(1)->find_long_con(0)) != 0) {\n-    swap_edges(1, 2);\n-    \/\/ Finish rest of method to use info in 'con'\n-  } else if ((con = in(2)->find_long_con(0)) == 0) {\n+  const jlong con = in(2)->find_long_con(0);\n+  if (con == 0) {\n+    \/\/ If in(2) is not a constant, call Ideal() of the parent class to\n+    \/\/ try to move constant to the right side.\n@@ -367,3 +356,5 @@\n-  \/\/ Now we have a constant Node on the right and the constant in con\n-  if (con == CONST64(0)) return NULL;  \/\/ By zero is handled by Value call\n-  if (con == CONST64(1)) return NULL;  \/\/ By one  is handled by Identity call\n+  \/\/ Now we have a constant Node on the right and the constant in con.\n+  if (con == 1) {\n+    \/\/ By one is handled by Identity call\n+    return NULL;\n+  }\n@@ -384,0 +375,1 @@\n+\n@@ -388,5 +380,0 @@\n-      if (!phase->C->post_loop_opts_phase()) {\n-        \/\/ Defer this because it breaks loop range check hoisting\n-        phase->C->record_for_post_loop_opts_igvn(this);\n-        return MulNode::Ideal(phase, can_reshape);\n-      }\n@@ -396,0 +383,1 @@\n+\n@@ -397,5 +385,1 @@\n-      if (!phase->C->post_loop_opts_phase()) {\n-        \/\/ Defer this because it breaks loop range check hoisting\n-        phase->C->record_for_post_loop_opts_igvn(this);\n-        return MulNode::Ideal(phase, can_reshape);\n-      }\n+      \/\/ Sleezy: power-of-2 -1.  Next time be generic.\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":22,"deletions":38,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -571,2 +571,0 @@\n-  void decrement_age();\n-\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -587,3 +587,0 @@\n-    if (depth() == 1 && C->age_code()) {\n-      decrement_age();\n-    }\n@@ -2348,25 +2345,0 @@\n-void Parse::decrement_age() {\n-  MethodCounters* mc = method()->ensure_method_counters();\n-  if (mc == NULL) {\n-    C->record_failure(\"Must have MCs\");\n-    return;\n-  }\n-  assert(!is_osr_parse(), \"Not doing this for OSRs\");\n-\n-  \/\/ Set starting bci for uncommon trap.\n-  set_parse_bci(0);\n-\n-  const TypePtr* adr_type = TypeRawPtr::make((address)mc);\n-  Node* mc_adr = makecon(adr_type);\n-  Node* cnt_adr = basic_plus_adr(mc_adr, mc_adr, in_bytes(MethodCounters::nmethod_age_offset()));\n-  Node* cnt = make_load(control(), cnt_adr, TypeInt::INT, T_INT, adr_type, MemNode::unordered);\n-  Node* decr = _gvn.transform(new SubINode(cnt, makecon(TypeInt::ONE)));\n-  store_to_memory(control(), cnt_adr, decr, T_INT, adr_type, MemNode::unordered);\n-  Node *chk   = _gvn.transform(new CmpINode(decr, makecon(TypeInt::ZERO)));\n-  Node* tst   = _gvn.transform(new BoolNode(chk, BoolTest::gt));\n-  { BuildCutout unless(this, tst, PROB_ALWAYS);\n-    uncommon_trap(Deoptimization::Reason_tenured,\n-                  Deoptimization::Action_make_not_entrant);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-  C->disconnect_useless_nodes(_useful, worklist);\n+  C->remove_useless_nodes(_useful);\n@@ -1763,1 +1763,1 @@\n-PhaseCCP::PhaseCCP(PhaseIterGVN* igvn) : PhaseIterGVN(igvn), _trstack(C->live_nodes() >> 1) {\n+PhaseCCP::PhaseCCP( PhaseIterGVN *igvn ) : PhaseIterGVN(igvn) {\n@@ -1797,1 +1797,5 @@\n-\/\/------------------------------analyze----------------------------------------\n+\/\/ In this analysis, all types are initially set to TOP. We iteratively call Value() on all nodes of the graph until\n+\/\/ we reach a fixed-point (i.e. no types change anymore). We start with a list that only contains the root node. Each time\n+\/\/ a new type is set, we push all uses of that node back to the worklist (in some cases, we also push grandchildren\n+\/\/ or nodes even further down back to the worklist because their type could change as a result of the current type\n+\/\/ change).\n@@ -1800,2 +1804,2 @@\n-  for (int i = C->unique() - 1; i >= 0; i--)  {\n-    _types.map(i,Type::TOP);\n+  for (uint i = 0; i < C->unique(); i++)  {\n+    _types.map(i, Type::TOP);\n@@ -1810,7 +1814,2 @@\n-  while( worklist.size() ) {\n-    Node* n; \/\/ Node to be examined in this iteration\n-    if (StressCCP) {\n-      n = worklist.remove(C->random() % worklist.size());\n-    } else {\n-      n = worklist.pop();\n-    }\n+  while (worklist.size() != 0) {\n+    Node* n = fetch_next_node(worklist);\n@@ -1818,3 +1817,9 @@\n-      \/\/ Make sure safepoints are processed by PhaseCCP::transform even if they are\n-      \/\/ not reachable from the bottom. Otherwise, infinite loops would be removed.\n-      _trstack.push(n);\n+      \/\/ Keep track of SafePoint nodes for PhaseCCP::transform()\n+      _safepoints.push(n);\n+    }\n+    const Type* new_type = n->Value(this);\n+    if (new_type != type(n)) {\n+      assert(ccp_type_widens(new_type, type(n)), \"ccp type must widen\");\n+      dump_type_and_node(n, new_type);\n+      set_type(n, new_type);\n+      push_child_nodes_to_worklist(worklist, n);\n@@ -1822,3 +1827,12 @@\n-    const Type *t = n->Value(this);\n-    if (t != type(n)) {\n-      assert(ccp_type_widens(t, type(n)), \"ccp type must widen\");\n+  }\n+}\n+\n+\/\/ Fetch next node from worklist to be examined in this iteration.\n+Node* PhaseCCP::fetch_next_node(Unique_Node_List& worklist) {\n+  if (StressCCP) {\n+    return worklist.remove(C->random() % worklist.size());\n+  } else {\n+    return worklist.pop();\n+  }\n+}\n+\n@@ -1826,5 +1840,9 @@\n-      if( TracePhaseCCP ) {\n-        t->dump();\n-        do { tty->print(\"\\t\"); } while (tty->position() < 16);\n-        n->dump();\n-      }\n+void PhaseCCP::dump_type_and_node(const Node* n, const Type* t) {\n+  if (TracePhaseCCP) {\n+    t->dump();\n+    do {\n+      tty->print(\"\\t\");\n+    } while (tty->position() < 16);\n+    n->dump();\n+  }\n+}\n@@ -1832,61 +1850,49 @@\n-      set_type(n, t);\n-      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-        Node* m = n->fast_out(i);   \/\/ Get user\n-        if (m->is_Region()) {  \/\/ New path to Region?  Must recheck Phis too\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* p = m->fast_out(i2); \/\/ Propagate changes to uses\n-            if (p->bottom_type() != type(p)) { \/\/ If not already bottomed out\n-              worklist.push(p); \/\/ Propagate change to user\n-            }\n-          }\n-        }\n-        \/\/ If we changed the receiver type to a call, we need to revisit\n-        \/\/ the Catch following the call.  It's looking for a non-NULL\n-        \/\/ receiver to know when to enable the regular fall-through path\n-        \/\/ in addition to the NullPtrException path\n-        if (m->is_Call()) {\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* p = m->fast_out(i2);  \/\/ Propagate changes to uses\n-            if (p->is_Proj() && p->as_Proj()->_con == TypeFunc::Control) {\n-              Node* catch_node = p->find_out_with(Op_Catch);\n-              if (catch_node != NULL) {\n-                worklist.push(catch_node);\n-              }\n-            }\n-          }\n-        }\n-        if (m->bottom_type() != type(m)) { \/\/ If not already bottomed out\n-          worklist.push(m);     \/\/ Propagate change to user\n-        }\n-        \/\/ CmpU nodes can get their type information from two nodes up in the\n-        \/\/ graph (instead of from the nodes immediately above). Make sure they\n-        \/\/ are added to the worklist if nodes they depend on are updated, since\n-        \/\/ they could be missed and get wrong types otherwise.\n-        uint m_op = m->Opcode();\n-        if (m_op == Op_AddI || m_op == Op_SubI) {\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* p = m->fast_out(i2); \/\/ Propagate changes to uses\n-            if (p->Opcode() == Op_CmpU) {\n-              \/\/ Got a CmpU which might need the new type information from node n.\n-              if(p->bottom_type() != type(p)) { \/\/ If not already bottomed out\n-                worklist.push(p); \/\/ Propagate change to user\n-              }\n-            }\n-          }\n-        }\n-        \/\/ If n is used in a counted loop exit condition then the type\n-        \/\/ of the counted loop's Phi depends on the type of n. See\n-        \/\/ PhiNode::Value().\n-        if (m_op == Op_CmpI || m_op == Op_CmpL) {\n-          PhiNode* phi = countedloop_phi_from_cmp(m->as_Cmp(), n);\n-          if (phi != NULL) {\n-            worklist.push(phi);\n-          }\n-        }\n-        if (m_op == Op_CastP2X) {\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* u = m->fast_out(i2);\n-            if (u->Opcode() == Op_AndX) {\n-              worklist.push(u);\n-            }\n-          }\n+\/\/ We need to propagate the type change of 'n' to all its uses. Depending on the kind of node, additional nodes\n+\/\/ (grandchildren or even further down) need to be revisited as their types could also be improved as a result\n+\/\/ of the new type of 'n'. Push these nodes to the worklist.\n+void PhaseCCP::push_child_nodes_to_worklist(Unique_Node_List& worklist, Node* n) const {\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* use = n->fast_out(i);\n+    push_if_not_bottom_type(worklist, use);\n+    push_more_uses(worklist, n, use);\n+  }\n+}\n+\n+void PhaseCCP::push_if_not_bottom_type(Unique_Node_List& worklist, Node* n) const {\n+  if (n->bottom_type() != type(n)) {\n+    worklist.push(n);\n+  }\n+}\n+\n+\/\/ For some nodes, we need to propagate the type change to grandchildren or even further down.\n+\/\/ Add them back to the worklist.\n+void PhaseCCP::push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) const {\n+  push_phis(worklist, use);\n+  push_catch(worklist, use);\n+  push_cmpu(worklist, use);\n+  push_counted_loop_phi(worklist, parent, use);\n+  push_cast(worklist, use);\n+  push_loadp(worklist, use);\n+  push_and(worklist, parent, use);\n+}\n+\n+\n+\/\/ We must recheck Phis too if use is a Region.\n+void PhaseCCP::push_phis(Unique_Node_List& worklist, const Node* use) const {\n+  if (use->is_Region()) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      push_if_not_bottom_type(worklist, use->fast_out(i));\n+    }\n+  }\n+}\n+\n+\/\/ If we changed the receiver type to a call, we need to revisit the Catch node following the call. It's looking for a\n+\/\/ non-NULL receiver to know when to enable the regular fall-through path in addition to the NullPtrException path.\n+void PhaseCCP::push_catch(Unique_Node_List& worklist, const Node* use) {\n+  if (use->is_Call()) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      Node* proj = use->fast_out(i);\n+      if (proj->is_Proj() && proj->as_Proj()->_con == TypeFunc::Control) {\n+        Node* catch_node = proj->find_out_with(Op_Catch);\n+        if (catch_node != NULL) {\n+          worklist.push(catch_node);\n@@ -1895,22 +1901,59 @@\n-        \/\/ Loading the java mirror from a Klass requires two loads and the type\n-        \/\/ of the mirror load depends on the type of 'n'. See LoadNode::Value().\n-        BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-        bool has_load_barrier_nodes = bs->has_load_barrier_nodes();\n-\n-        if (m_op == Op_LoadP && m->bottom_type()->isa_rawptr()) {\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* u = m->fast_out(i2);\n-            const Type* ut = u->bottom_type();\n-            if (u->Opcode() == Op_LoadP && ut->isa_instptr() && ut != type(u)) {\n-              if (has_load_barrier_nodes) {\n-                \/\/ Search for load barriers behind the load\n-                for (DUIterator_Fast i3max, i3 = u->fast_outs(i3max); i3 < i3max; i3++) {\n-                  Node* b = u->fast_out(i3);\n-                  if (bs->is_gc_barrier_node(b)) {\n-                    worklist.push(b);\n-                  }\n-                }\n-              }\n-              worklist.push(u);\n-            }\n-          }\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ CmpU nodes can get their type information from two nodes up in the graph (instead of from the nodes immediately\n+\/\/ above). Make sure they are added to the worklist if nodes they depend on are updated since they could be missed\n+\/\/ and get wrong types otherwise.\n+void PhaseCCP::push_cmpu(Unique_Node_List& worklist, const Node* use) const {\n+  uint use_op = use->Opcode();\n+  if (use_op == Op_AddI || use_op == Op_SubI) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      Node* cmpu = use->fast_out(i);\n+      if (cmpu->Opcode() == Op_CmpU) {\n+        \/\/ Got a CmpU which might need the new type information from node n.\n+        push_if_not_bottom_type(worklist, cmpu);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ If n is used in a counted loop exit condition, then the type of the counted loop's Phi depends on the type of 'n'.\n+\/\/ Seem PhiNode::Value().\n+void PhaseCCP::push_counted_loop_phi(Unique_Node_List& worklist, Node* parent, const Node* use) {\n+  uint use_op = use->Opcode();\n+  if (use_op == Op_CmpI || use_op == Op_CmpL) {\n+    PhiNode* phi = countedloop_phi_from_cmp(use->as_Cmp(), parent);\n+    if (phi != NULL) {\n+      worklist.push(phi);\n+    }\n+  }\n+}\n+\n+void PhaseCCP::push_cast(Unique_Node_List& worklist, const Node* use) {\n+  uint use_op = use->Opcode();\n+  if (use_op == Op_CastP2X) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == Op_AndX) {\n+        worklist.push(u);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Loading the java mirror from a Klass requires two loads and the type of the mirror load depends on the type of 'n'.\n+\/\/ See LoadNode::Value().\n+void PhaseCCP::push_loadp(Unique_Node_List& worklist, const Node* use) const {\n+  BarrierSetC2* barrier_set = BarrierSet::barrier_set()->barrier_set_c2();\n+  bool has_load_barrier_nodes = barrier_set->has_load_barrier_nodes();\n+\n+  if (use->Opcode() == Op_LoadP && use->bottom_type()->isa_rawptr()) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      Node* loadp = use->fast_out(i);\n+      const Type* ut = loadp->bottom_type();\n+      if (loadp->Opcode() == Op_LoadP && ut->isa_instptr() && ut != type(loadp)) {\n+        if (has_load_barrier_nodes) {\n+          \/\/ Search for load barriers behind the load\n+          push_load_barrier(worklist, barrier_set, loadp);\n@@ -1918,1 +1961,1 @@\n-        push_and(worklist, n, m);\n+        worklist.push(loadp);\n@@ -1924,0 +1967,9 @@\n+void PhaseCCP::push_load_barrier(Unique_Node_List& worklist, const BarrierSetC2* barrier_set, const Node* use) {\n+  for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+    Node* barrier_node = use->fast_out(i);\n+    if (barrier_set->is_gc_barrier_node(barrier_node)) {\n+      worklist.push(barrier_node);\n+    }\n+  }\n+}\n+\n@@ -1933,3 +1985,2 @@\n-      if ((and_node_op == Op_AndI || and_node_op == Op_AndL)\n-          && and_node->bottom_type() != type(and_node)) {\n-        worklist.push(and_node);\n+      if (and_node_op == Op_AndI || and_node_op == Op_AndL) {\n+        push_if_not_bottom_type(worklist, and_node);\n@@ -1941,0 +1992,1 @@\n+\n@@ -1959,4 +2011,23 @@\n-  _useful.push(new_node); \/\/ Keep track of nodes that are reachable from the bottom\n-  _trstack.push(new_node);           \/\/ Process children of cloned node\n-  while (_trstack.is_nonempty()) {\n-    Node* clone = _trstack.pop();\n+  \/\/ Allocate stack of size _nodes.Size()\/2 to avoid frequent realloc\n+  GrowableArray <Node *> trstack(C->live_nodes() >> 1);\n+\n+  trstack.push(new_node);           \/\/ Process children of cloned node\n+\n+  \/\/ This CCP pass may prove that no exit test for a loop ever succeeds (i.e. the loop is infinite). In that case,\n+  \/\/ the logic below doesn't follow any path from Root to the loop body: there's at least one such path but it's proven\n+  \/\/ never taken (its type is TOP). As a consequence the node on the exit path that's input to Root (let's call it n) is\n+  \/\/ replaced by the top node and the inputs of that node n are not enqueued for further processing. If CCP only works\n+  \/\/ through the graph from Root, this causes the loop body to never be processed here even when it's not dead (that\n+  \/\/ is reachable from Root following its uses). To prevent that issue, transform() starts walking the graph from Root\n+  \/\/ and all safepoints.\n+  for (uint i = 0; i < _safepoints.size(); ++i) {\n+    Node* nn = _safepoints.at(i);\n+    Node* new_node = _nodes[nn->_idx];\n+    assert(new_node == NULL, \"\");\n+    new_node = transform_once(nn);\n+    _nodes.map(nn->_idx, new_node);\n+    trstack.push(new_node);\n+  }\n+\n+  while ( trstack.is_nonempty() ) {\n+    Node *clone = trstack.pop();\n@@ -1972,2 +2043,1 @@\n-          _useful.push(new_input);\n-          _trstack.push(new_input);\n+          trstack.push(new_input);\n@@ -1979,17 +2049,0 @@\n-\n-  \/\/ The above transformation might lead to subgraphs becoming unreachable from the\n-  \/\/ bottom while still being reachable from the top. As a result, nodes in that\n-  \/\/ subgraph are not transformed and their bottom types are not updated, leading to\n-  \/\/ an inconsistency between bottom_type() and type(). In rare cases, LoadNodes in\n-  \/\/ such a subgraph, kept alive by InlineTypePtrNodes, might be re-enqueued for IGVN\n-  \/\/ indefinitely by MemNode::Ideal_common because their address type is inconsistent.\n-  \/\/ Therefore, we aggressively remove all useless nodes here even before\n-  \/\/ PhaseIdealLoop::build_loop_late gets a chance to remove them anyway.\n-  if (C->cached_top_node()) {\n-    _useful.push(C->cached_top_node());\n-  }\n-  C->update_dead_node_list(_useful);\n-  remove_useless_nodes(_useful.member_set());\n-  _worklist.remove_useless_nodes(_useful.member_set());\n-  C->disconnect_useless_nodes(_useful, &_worklist);\n-\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":186,"deletions":133,"binary":false,"changes":319,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class BarrierSetC2;\n@@ -570,2 +571,1 @@\n-  GrowableArray<Node*> _trstack; \/\/ Stack for transform operation\n-  Unique_Node_List _useful;      \/\/ Nodes reachable from the bottom\n+  Unique_Node_List _safepoints;\n@@ -574,2 +574,15 @@\n-  virtual Node *transform_once( Node *n );\n-\n+  virtual Node* transform_once(Node* n);\n+\n+  Node* fetch_next_node(Unique_Node_List& worklist);\n+  static void dump_type_and_node(const Node* n, const Type* t) PRODUCT_RETURN;\n+\n+  void push_child_nodes_to_worklist(Unique_Node_List& worklist, Node* n) const;\n+  void push_if_not_bottom_type(Unique_Node_List& worklist, Node* n) const;\n+  void push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) const;\n+  void push_phis(Unique_Node_List& worklist, const Node* use) const;\n+  static void push_catch(Unique_Node_List& worklist, const Node* use);\n+  void push_cmpu(Unique_Node_List& worklist, const Node* use) const;\n+  static void push_counted_loop_phi(Unique_Node_List& worklist, Node* parent, const Node* use);\n+  static void push_cast(Unique_Node_List& worklist, const Node* use);\n+  void push_loadp(Unique_Node_List& worklist, const Node* use) const;\n+  static void push_load_barrier(Unique_Node_List& worklist, const BarrierSetC2* barrier_set, const Node* use);\n@@ -578,1 +591,1 @@\n-public:\n+ public:\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -132,2 +132,2 @@\n-              assert(use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque1 || use->is_AllocateArray(), \"unexpected node type\");\n-              Node *use_c = (use->is_If() || use->is_AllocateArray()) ? use->in(0) : get_ctrl(use);\n+              assert(use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque1, \"unexpected node type\");\n+              Node *use_c = use->is_If() ? use->in(0) : get_ctrl(use);\n@@ -170,3 +170,2 @@\n-                assert(u->is_If() || u->is_CMove() || u->Opcode() == Op_Opaque1 || u->is_AllocateArray(), \"unexpected node type\");\n-                assert(u->is_AllocateArray() || u->in(1) == bol, \"\");\n-                assert(!u->is_AllocateArray() || u->in(AllocateNode::ValidLengthTest) == bol, \"wrong input to AllocateArray\");\n+                assert(u->is_If() || u->is_CMove() || u->Opcode() == Op_Opaque1, \"unexpected node type\");\n+                assert(u->in(1) == bol, \"\");\n@@ -174,1 +173,1 @@\n-                Node *u_ctrl = (u->is_If() || u->is_AllocateArray()) ? u->in(0) : get_ctrl(u);\n+                Node *u_ctrl = u->is_If() ? u->in(0) : get_ctrl(u);\n@@ -178,1 +177,1 @@\n-                _igvn.replace_input_of(u, u->is_AllocateArray() ? AllocateNode::ValidLengthTest : 1, x);\n+                _igvn.replace_input_of(u, 1, x);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -264,2 +264,4 @@\n-        \/\/ This region should lose its Phis and be optimized out by igvn but there's a chance the if folds to top first\n-        \/\/ which then causes a reachable part of the graph to become dead.\n+        \/\/ This region should lose its Phis. They are removed either in PhaseRemoveUseless (for data phis) or in IGVN\n+        \/\/ (for memory phis). During IGVN, there is a chance that the If folds to top before the Region is processed\n+        \/\/ which then causes a reachable part of the graph to become dead. To prevent this, set the boolean input of\n+        \/\/ the If to a constant to nicely let the diamond Region\/If fold away.\n@@ -267,1 +269,1 @@\n-        C->gvn_replace_by(n, iff->in(0));\n+        C->gvn_replace_by(iff->in(1), _stringopts->gvn()->intcon(0));\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/moveBits.hpp\"\n@@ -2002,0 +2003,40 @@\n+\n+const Type* ReverseINode::Value(PhaseGVN* phase) const {\n+  const Type *t1 = phase->type( in(1) );\n+  if (t1 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  const TypeInt* t1int = t1->isa_int();\n+  if (t1int && t1int->is_con()) {\n+    jint res = reverse_bits(t1int->get_con());\n+    return TypeInt::make(res);\n+  }\n+  return bottom_type();\n+}\n+\n+const Type* ReverseLNode::Value(PhaseGVN* phase) const {\n+  const Type *t1 = phase->type( in(1) );\n+  if (t1 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  const TypeLong* t1long = t1->isa_long();\n+  if (t1long && t1long->is_con()) {\n+    jlong res = reverse_bits(t1long->get_con());\n+    return TypeLong::make(res);\n+  }\n+  return bottom_type();\n+}\n+\n+Node* ReverseINode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReverseI) {\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n+Node* ReverseLNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReverseL) {\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -605,0 +605,2 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -615,0 +617,2 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -3779,2 +3780,0 @@\n-#ifndef PRODUCT\n-#endif\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1121,3 +1121,3 @@\n-  Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,\n-                                                              h_loader,\n-                                                              Handle());\n+  Klass* k = SystemDictionary::find_instance_or_array_klass(THREAD, klass_name,\n+                                                            h_loader,\n+                                                            Handle());\n@@ -4115,0 +4115,19 @@\n+\n+\/*\n+ * Return the current class's class file version.  The low order 16 bits of the\n+ * returned jint contain the class's major version.  The high order 16 bits\n+ * contain the class's minor version.\n+ *\/\n+JVM_ENTRY(jint, JVM_GetClassFileVersion(JNIEnv* env, jclass current))\n+  oop mirror = JNIHandles::resolve_non_null(current);\n+  if (java_lang_Class::is_primitive(mirror)) {\n+    \/\/ return latest major version and minor version of 0.\n+    return JVM_CLASSFILE_MAJOR_VERSION;\n+  }\n+  assert(!java_lang_Class::as_Klass(mirror)->is_array_klass(), \"unexpected array class\");\n+\n+  Klass* c = java_lang_Class::as_Klass(mirror);\n+  assert(c->is_instance_klass(), \"must be\");\n+  InstanceKlass* ik = InstanceKlass::cast(c);\n+  return (ik->minor_version() << 16) | ik->major_version();\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-  _symmap = new SymbolHashMap();\n-  _classmap = new SymbolHashMap();\n+  _symmap = new ConstantPool::SymbolHash();\n+  _classmap = new ConstantPool::SymbolHash();\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2249,1 +2249,1 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n+  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2289,1 +2289,1 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n+  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2330,1 +2330,1 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n+  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2371,1 +2371,1 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n+  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2412,1 +2412,1 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n+  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2453,1 +2453,1 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n+  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2495,1 +2495,1 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n+  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2531,1 +2531,1 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n+  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2567,1 +2567,1 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n+  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2603,1 +2603,1 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n+  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2639,1 +2639,1 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n+  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2465,1 +2465,0 @@\n-  assert(!nm->is_zombie(), \"nmethod zombie in post_compiled_method_load\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1025,2 +1025,2 @@\n-\/\/ The sweeper calls this and marks the nmethods here on the stack so that\n-\/\/ they cannot be turned into zombies while in the queue.\n+\/\/ The GC calls this and marks the nmethods here on the stack so that\n+\/\/ they cannot be unloaded while in the queue.\n@@ -1083,1 +1083,1 @@\n-  \/\/ Post events while nmethods are still in the queue and can't be unloaded or made zombie\n+  \/\/ Post events while nmethods are still in the queue and can't be unloaded.\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1063,8 +1063,0 @@\n-void MethodHandles::remove_dependent_nmethod(oop call_site, nmethod* nm) {\n-  assert_locked_or_safepoint(CodeCache_lock);\n-\n-  oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);\n-  DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);\n-  deps.remove_dependent_nmethod(nm);\n-}\n-\n@@ -1504,1 +1496,1 @@\n-      marked = deps.remove_all_dependents();\n+      marked = deps.remove_and_mark_for_deoptimization_all_dependents();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-#include \"runtime\/sweeper.hpp\"\n@@ -389,3 +388,0 @@\n-    if (hr == NULL) {\n-      return false;\n-    }\n@@ -610,1 +606,0 @@\n-      size_t prev_live = r->marked_bytes();\n@@ -618,3 +613,3 @@\n-        \/\/ we don't include non-full regions since they are unlikely included in mixed gc\n-        \/\/ for testing purposes it's enough to have lowest estimation of total memory that is expected to be freed\n-          _total_memory_to_free += size - prev_live;\n+          \/\/ We don't include non-full regions since they are unlikely included in mixed gc\n+          \/\/ for testing purposes it's enough to have lowest estimation of total memory that is expected to be freed\n+          _total_memory_to_free += size - live;\n@@ -819,1 +814,1 @@\n-  return (code->is_alive() && !code->is_marked_for_deoptimization());\n+  return !code->is_marked_for_deoptimization();\n@@ -1430,5 +1425,0 @@\n-WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))\n-  \/\/ Force a code cache sweep and block until it finished\n-  NMethodSweeper::force_sweep();\n-WB_END\n-\n@@ -1481,1 +1471,1 @@\n-int WhiteBox::get_blob_type(const CodeBlob* code) {\n+CodeBlobType WhiteBox::get_blob_type(const CodeBlob* code) {\n@@ -1486,1 +1476,1 @@\n-CodeHeap* WhiteBox::get_code_heap(int blob_type) {\n+CodeHeap* WhiteBox::get_code_heap(CodeBlobType blob_type) {\n@@ -1495,1 +1485,1 @@\n-      blob_type(WhiteBox::get_blob_type(blob)),\n+      blob_type(static_cast<jint>(WhiteBox::get_blob_type(blob))),\n@@ -1575,1 +1565,1 @@\n-CodeBlob* WhiteBox::allocate_code_blob(int size, int blob_type) {\n+CodeBlob* WhiteBox::allocate_code_blob(int size, CodeBlobType blob_type) {\n@@ -1599,1 +1589,1 @@\n-  return (jlong) WhiteBox::allocate_code_blob(size, blob_type);\n+  return (jlong) WhiteBox::allocate_code_blob(size, static_cast<CodeBlobType>(blob_type));\n@@ -1614,1 +1604,1 @@\n-    CodeHeap* heap = WhiteBox::get_code_heap(blob_type);\n+    CodeHeap* heap = WhiteBox::get_code_heap(static_cast<CodeBlobType>(blob_type));\n@@ -2756,1 +2746,0 @@\n-  {CC\"forceNMethodSweep\",  CC\"()V\",                   (void*)&WB_ForceNMethodSweep  },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -551,0 +552,1 @@\n+  { \"UseCodeAging\",                 JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n@@ -3902,0 +3904,2 @@\n+#ifndef PRODUCT\n+  \/\/ UseDebuggerErgo is notproduct\n@@ -3905,0 +3909,1 @@\n+#endif\n@@ -3906,0 +3911,1 @@\n+#ifndef PRODUCT\n@@ -3911,0 +3917,1 @@\n+#endif\n@@ -4173,5 +4180,0 @@\n-\n-  if (LogTouchedMethods) {\n-    warning(\"LogTouchedMethods is not supported for Zero\");\n-    FLAG_SET_DEFAULT(LogTouchedMethods, false);\n-  }\n@@ -4442,0 +4444,75 @@\n+\n+bool Arguments::parse_malloc_limit_size(const char* s, size_t* out) {\n+  julong limit = 0;\n+  Arguments::ArgsRange range = parse_memory_size(s, &limit, 1, SIZE_MAX);\n+  switch (range) {\n+  case ArgsRange::arg_in_range:\n+    *out = (size_t)limit;\n+    return true;\n+  case ArgsRange::arg_too_big: \/\/ only possible on 32-bit\n+    vm_exit_during_initialization(\"MallocLimit: too large\", s);\n+    break;\n+  case ArgsRange::arg_too_small:\n+    vm_exit_during_initialization(\"MallocLimit: limit must be > 0\");\n+    break;\n+  default:\n+    break;\n+  }\n+  return false;\n+}\n+\n+\/\/ Helper for parse_malloc_limits\n+void Arguments::parse_single_category_limit(char* expression, size_t limits[mt_number_of_types]) {\n+  \/\/ <category>:<limit>\n+  char* colon = ::strchr(expression, ':');\n+  if (colon == nullptr) {\n+    vm_exit_during_initialization(\"MallocLimit: colon missing\", expression);\n+  }\n+  *colon = '\\0';\n+  MEMFLAGS f = NMTUtil::string_to_flag(expression);\n+  if (f == mtNone) {\n+    vm_exit_during_initialization(\"MallocLimit: invalid nmt category\", expression);\n+  }\n+  if (parse_malloc_limit_size(colon + 1, limits + (int)f) == false) {\n+    vm_exit_during_initialization(\"Invalid MallocLimit size\", colon + 1);\n+  }\n+}\n+\n+void Arguments::parse_malloc_limits(size_t* total_limit, size_t limits[mt_number_of_types]) {\n+\n+  \/\/ Reset output to 0\n+  *total_limit = 0;\n+  for (int i = 0; i < mt_number_of_types; i ++) {\n+    limits[i] = 0;\n+  }\n+\n+  \/\/ We are done if the option is not given.\n+  if (MallocLimit == nullptr) {\n+    return;\n+  }\n+\n+  \/\/ Global form?\n+  if (parse_malloc_limit_size(MallocLimit, total_limit)) {\n+    return;\n+  }\n+\n+  \/\/ No. So it must be in category-specific form: MallocLimit=<nmt category>:<size>[,<nmt category>:<size> ..]\n+  char* copy = os::strdup(MallocLimit);\n+  if (copy == nullptr) {\n+    vm_exit_out_of_memory(strlen(MallocLimit), OOM_MALLOC_ERROR, \"MallocLimit\");\n+  }\n+\n+  char* p = copy, *q;\n+  do {\n+    q = p;\n+    p = ::strchr(q, ',');\n+    if (p != nullptr) {\n+      *p = '\\0';\n+      p ++;\n+    }\n+    parse_single_category_limit(q, limits);\n+  } while (p != nullptr);\n+\n+  os::free(copy);\n+\n+}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":82,"deletions":5,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n@@ -653,1 +654,1 @@\n-  assert(CodeCache::find_blob_unsafe(frame_pcs[0]) != NULL, \"bad pc\");\n+  assert(CodeCache::find_blob(frame_pcs[0]) != NULL, \"bad pc\");\n@@ -991,2 +992,2 @@\n-  static InstanceKlass* find_cache_klass(Symbol* klass_name) {\n-    ResourceMark rm;\n+  static InstanceKlass* find_cache_klass(Thread* thread, Symbol* klass_name) {\n+    ResourceMark rm(thread);\n@@ -994,1 +995,1 @@\n-    InstanceKlass* ik = SystemDictionary::find_instance_klass(klass_name, Handle(), Handle());\n+    InstanceKlass* ik = SystemDictionary::find_instance_klass(thread, klass_name, Handle(), Handle());\n@@ -1009,1 +1010,1 @@\n-    InstanceKlass* ik = BoxCacheBase<CacheType>::find_cache_klass(CacheType::symbol());\n+    InstanceKlass* ik = BoxCacheBase<CacheType>::find_cache_klass(thread, CacheType::symbol());\n@@ -1065,1 +1066,1 @@\n-    InstanceKlass* ik = find_cache_klass(java_lang_Boolean::symbol());\n+    InstanceKlass* ik = find_cache_klass(thread, java_lang_Boolean::symbol());\n@@ -1995,3 +1996,0 @@\n-  \/\/ Make sure the calling nmethod is not getting deoptimized and removed\n-  \/\/ before we are done with it.\n-  nmethodLocker nl(fr.pc());\n@@ -2054,1 +2052,1 @@\n-    bool create_if_missing = ProfileTraps || UseCodeAging RTM_OPT_ONLY( || UseRTMLocking );\n+    bool create_if_missing = ProfileTraps RTM_OPT_ONLY( || UseRTMLocking );\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"oops\/method.hpp\"\n+#include \"oops\/method.inline.hpp\"\n@@ -234,1 +234,1 @@\n-  _cb = CodeCache::find_blob_unsafe(_pc);\n+  _cb = CodeCache::find_blob(_pc);\n@@ -239,1 +239,1 @@\n-  set_pc_preserve_deopt(newpc, CodeCache::find_blob_unsafe(newpc));\n+  set_pc_preserve_deopt(newpc, CodeCache::find_blob(newpc));\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-          \"Reclamation of zombie and not-entrant methods\")                  \\\n+          \"Reclamation of compiled methods\")                                \\\n@@ -382,1 +382,1 @@\n-          \"Create zombies (non-entrant) at exit from the runtime system\")   \\\n+          \"Create non-entrant nmethods at exit from the runtime system\")    \\\n@@ -514,0 +514,4 @@\n+  develop(intx, TraceDwarfLevel, 0,                                         \\\n+          \"Debug levels for the dwarf parser\")                              \\\n+          range(0, 4)                                                       \\\n+                                                                            \\\n@@ -994,6 +998,0 @@\n-  product(bool, LogTouchedMethods, false, DIAGNOSTIC,                       \\\n-          \"Log methods which have been ever touched in runtime\")            \\\n-                                                                            \\\n-  product(bool, PrintTouchedMethodsAtExit, false, DIAGNOSTIC,               \\\n-          \"Print all methods that have been ever touched in runtime\")       \\\n-                                                                            \\\n@@ -1003,3 +1001,0 @@\n-  develop(bool, PrintMethodFlushing, false,                                 \\\n-          \"Print the nmethods being flushed\")                               \\\n-                                                                            \\\n@@ -1009,5 +1004,0 @@\n-  product(intx, HotMethodDetectionLimit, 100000, DIAGNOSTIC,                \\\n-          \"Number of compiled code invocations after which \"                \\\n-          \"the method is considered as hot by the flusher\")                 \\\n-          range(1, max_jint)                                                \\\n-                                                                            \\\n@@ -1019,6 +1009,0 @@\n-  product(bool, UseCodeAging, true,                                         \\\n-          \"Insert counter to detect warm methods\")                          \\\n-                                                                            \\\n-  product(bool, StressCodeAging, false, DIAGNOSTIC,                         \\\n-          \"Start with counters compiled in\")                                \\\n-                                                                            \\\n@@ -1115,3 +1099,0 @@\n-  develop(bool, TraceCreateZombies, false,                                  \\\n-          \"trace creation of zombie nmethods\")                              \\\n-                                                                            \\\n@@ -1334,1 +1315,1 @@\n-  product(intx, NmethodSweepActivity, 10,                                   \\\n+  product(intx, NmethodSweepActivity, 4,                                    \\\n@@ -1339,6 +1320,0 @@\n-  notproduct(bool, LogSweeper, false,                                       \\\n-          \"Keep a ring buffer of sweeper activity\")                         \\\n-                                                                            \\\n-  notproduct(intx, SweeperLogEntries, 1024,                                 \\\n-          \"Number of records in the ring buffer of sweeper activity\")       \\\n-                                                                            \\\n@@ -1386,0 +1361,10 @@\n+  product(ccstr, MallocLimit, nullptr, DIAGNOSTIC,                          \\\n+          \"Limit malloc allocation size from VM. Reaching the limit will \"  \\\n+          \"trigger a fatal error. This feature requires \"                   \\\n+          \"NativeMemoryTracking=summary or NativeMemoryTracking=detail.\"    \\\n+          \"Usage:\"                                                          \\\n+          \"- MallocLimit=<size> to set a total limit. \"                     \\\n+          \"- MallocLimit=<NMT category>:<size>[,<NMT category>:<size>...] \" \\\n+          \"  to set one or more category-specific limits.\"                  \\\n+          \"Example: -XX:MallocLimit=compiler:500m\")                         \\\n+                                                                            \\\n@@ -1605,2 +1590,2 @@\n-  product(double, SweeperThreshold, 0.5,                                    \\\n-          \"Threshold controlling when code cache sweeper is invoked.\"       \\\n+  product(double, SweeperThreshold, 15.0,                                   \\\n+          \"Threshold when a code cache unloading GC is invoked.\"            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":19,"deletions":34,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -901,1 +901,1 @@\n-  \/\/ Sweeper operations\n+  \/\/ GC operations\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"classfile\/dictionary.hpp\"\n@@ -66,1 +65,0 @@\n-#include \"runtime\/sweeper.hpp\"\n@@ -564,7 +562,0 @@\n-    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_SYSTEM_DICTIONARY_RESIZE)) {\n-      if (Dictionary::does_any_dictionary_needs_resizing()) {\n-        Tracer t(\"resizing system dictionaries\");\n-        ClassLoaderDataGraph::resize_dictionaries();\n-      }\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -1079,2 +1079,0 @@\n-  nmethodLocker caller_lock(caller);\n-\n@@ -1335,1 +1333,0 @@\n-  nmethodLocker nl_callee(callee);\n@@ -1425,5 +1422,0 @@\n-  \/\/ make sure caller is not getting deoptimized\n-  \/\/ and removed before we are done with it.\n-  \/\/ CLEANUP - with lazy deopt shouldn't need this lock\n-  nmethodLocker caller_lock(caller_nm);\n-\n@@ -1444,1 +1436,1 @@\n-  assert(caller_nm->is_alive() && !caller_nm->is_unloading(), \"It should be alive\");\n+  assert(!caller_nm->is_unloading(), \"It should not be unloading\");\n@@ -1952,4 +1944,0 @@\n-    \/\/ Make sure nmethod doesn't get deoptimized and removed until\n-    \/\/ this is done with it.\n-    \/\/ CLEANUP - with lazy deopt shouldn't need this lock\n-    nmethodLocker nmlock(caller_nm);\n@@ -2376,1 +2364,1 @@\n-    if ((method != NULL) && nm->is_alive()) {\n+    if (method != NULL) {\n@@ -2472,0 +2460,6 @@\n+#ifndef PRODUCT\n+static int _lookups; \/\/ number of calls to lookup\n+static int _equals;  \/\/ number of buckets checked with matching hash\n+static int _hits;    \/\/ number of successful lookups\n+static int _compact; \/\/ number of equals calls with compact signature\n+#endif\n@@ -2681,18 +2675,3 @@\n-};\n-\n-\n-\/\/ A hashtable mapping from AdapterFingerPrints to AdapterHandlerEntries\n-class AdapterHandlerTable : public BasicHashtable<mtCode> {\n-  friend class AdapterHandlerTableIterator;\n- private:\n-\n-#ifndef PRODUCT\n-  static int _lookups; \/\/ number of calls to lookup\n-  static int _buckets; \/\/ number of buckets checked\n-  static int _equals;  \/\/ number of buckets checked with matching hash\n-  static int _hits;    \/\/ number of successful lookups\n-  static int _compact; \/\/ number of equals calls with compact signature\n-#endif\n-\n-  AdapterHandlerEntry* bucket(int i) {\n-    return (AdapterHandlerEntry*)BasicHashtable<mtCode>::bucket(i);\n+  static bool equals(AdapterFingerPrint* const& fp1, AdapterFingerPrint* const& fp2) {\n+    NOT_PRODUCT(_equals++);\n+    return fp1->equals(fp2);\n@@ -2702,23 +2681,2 @@\n- public:\n-  AdapterHandlerTable()\n-    : BasicHashtable<mtCode>(293, (sizeof(AdapterHandlerEntry))) { }\n-\n-  \/\/ Create a new entry suitable for insertion in the table\n-  AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry,\n-                                 address c2i_inline_entry, address c2i_inline_ro_entry,\n-                                 address c2i_unverified_entry, address c2i_unverified_inline_entry, address c2i_no_clinit_check_entry) {\n-    AdapterHandlerEntry* entry = (AdapterHandlerEntry*)BasicHashtable<mtCode>::new_entry(fingerprint->compute_hash());\n-    entry->init(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry,\n-                c2i_unverified_entry, c2i_unverified_inline_entry, c2i_no_clinit_check_entry);\n-    return entry;\n-  }\n-\n-  \/\/ Insert an entry into the table\n-  void add(AdapterHandlerEntry* entry) {\n-    int index = hash_to_index(entry->hash());\n-    add_entry(index, entry);\n-  }\n-\n-  void free_entry(AdapterHandlerEntry* entry) {\n-    entry->deallocate();\n-    BasicHashtable<mtCode>::free_entry(entry);\n+  static unsigned int compute_hash(AdapterFingerPrint* const& fp) {\n+    return fp->compute_hash();\n@@ -2726,0 +2684,1 @@\n+};\n@@ -2727,11 +2686,13 @@\n-  \/\/ Find a entry with the same fingerprint if it exists\n-  AdapterHandlerEntry* lookup(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n-    NOT_PRODUCT(_lookups++);\n-    AdapterFingerPrint fp(sig, has_ro_adapter);\n-    unsigned int hash = fp.compute_hash();\n-    int index = hash_to_index(hash);\n-    for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e->next()) {\n-      NOT_PRODUCT(_buckets++);\n-      if (e->hash() == hash) {\n-        NOT_PRODUCT(_equals++);\n-        if (fp.equals(e->fingerprint())) {\n+\/\/ A hashtable mapping from AdapterFingerPrints to AdapterHandlerEntries\n+ResourceHashtable<AdapterFingerPrint*, AdapterHandlerEntry*, 293,\n+                  ResourceObj::C_HEAP, mtCode,\n+                  AdapterFingerPrint::compute_hash,\n+                  AdapterFingerPrint::equals> _adapter_handler_table;\n+\n+\/\/ Find a entry with the same fingerprint if it exists\n+static AdapterHandlerEntry* lookup(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n+  NOT_PRODUCT(_lookups++);\n+  assert_lock_strong(AdapterHandlerLibrary_lock);\n+  AdapterFingerPrint fp(sig, has_ro_adapter);\n+  AdapterHandlerEntry** entry = _adapter_handler_table.get(&fp);\n+  if (entry != nullptr) {\n@@ -2739,2 +2700,2 @@\n-          if (fp.is_compact()) _compact++;\n-          _hits++;\n+    if (fp.is_compact()) _compact++;\n+    _hits++;\n@@ -2742,28 +2703,1 @@\n-          return e;\n-        }\n-      }\n-    }\n-    return NULL;\n-  }\n-\n-#ifndef PRODUCT\n-  void print_statistics() {\n-    ResourceMark rm;\n-    int longest = 0;\n-    int empty = 0;\n-    int total = 0;\n-    int nonempty = 0;\n-    for (int index = 0; index < table_size(); index++) {\n-      int count = 0;\n-      for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e->next()) {\n-        count++;\n-      }\n-      if (count != 0) nonempty++;\n-      if (count == 0) empty++;\n-      if (count > longest) longest = count;\n-      total += count;\n-    }\n-    tty->print_cr(\"AdapterHandlerTable: empty %d longest %d total %d average %f\",\n-                  empty, longest, total, total \/ (double)nonempty);\n-    tty->print_cr(\"AdapterHandlerTable: lookups %d buckets %d equals %d hits %d compact %d\",\n-                  _lookups, _buckets, _equals, _hits, _compact);\n+    return *entry;\n@@ -2771,3 +2705,2 @@\n-#endif\n-};\n-\n+  return nullptr;\n+}\n@@ -2776,7 +2709,11 @@\n-\n-int AdapterHandlerTable::_lookups;\n-int AdapterHandlerTable::_buckets;\n-int AdapterHandlerTable::_equals;\n-int AdapterHandlerTable::_hits;\n-int AdapterHandlerTable::_compact;\n-\n+static void print_table_statistics() {\n+  auto size = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n+    return sizeof(*key) + sizeof(*a);\n+  };\n+  TableStatistics ts = _adapter_handler_table.statistics_calculate(size);\n+  ts.print(tty, \"AdapterHandlerTable\");\n+  tty->print_cr(\"AdapterHandlerTable (table_size=%d, entries=%d)\",\n+                _adapter_handler_table.table_size(), _adapter_handler_table.number_of_entries());\n+  tty->print_cr(\"AdapterHandlerTable: lookups %d equals %d hits %d compact %d\",\n+                _lookups, _equals, _hits, _compact);\n+}\n@@ -2785,37 +2722,0 @@\n-class AdapterHandlerTableIterator : public StackObj {\n- private:\n-  AdapterHandlerTable* _table;\n-  int _index;\n-  AdapterHandlerEntry* _current;\n-\n-  void scan() {\n-    while (_index < _table->table_size()) {\n-      AdapterHandlerEntry* a = _table->bucket(_index);\n-      _index++;\n-      if (a != NULL) {\n-        _current = a;\n-        return;\n-      }\n-    }\n-  }\n-\n- public:\n-  AdapterHandlerTableIterator(AdapterHandlerTable* table): _table(table), _index(0), _current(NULL) {\n-    scan();\n-  }\n-  bool has_next() {\n-    return _current != NULL;\n-  }\n-  AdapterHandlerEntry* next() {\n-    if (_current != NULL) {\n-      AdapterHandlerEntry* result = _current;\n-      _current = _current->next();\n-      if (_current == NULL) scan();\n-      return result;\n-    } else {\n-      return NULL;\n-    }\n-  }\n-};\n-\n-\n@@ -2824,1 +2724,0 @@\n-AdapterHandlerTable* AdapterHandlerLibrary::_adapters = NULL;\n@@ -2842,1 +2741,2 @@\n-static void post_adapter_creation(const AdapterBlob* new_adapter, const AdapterHandlerEntry* entry) {\n+static void post_adapter_creation(const AdapterBlob* new_adapter,\n+                                  const AdapterHandlerEntry* entry) {\n@@ -2869,3 +2769,0 @@\n-    assert(_adapters == NULL, \"Initializing more than once\");\n-\n-    _adapters = new AdapterHandlerTable();\n@@ -2935,1 +2832,1 @@\n-  return _adapters->new_entry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry,\n+  return new AdapterHandlerEntry(fingerprint, i2c_entry, c2i_entry, c2i_inline_entry, c2i_inline_ro_entry, c2i_unverified_entry,\n@@ -3136,1 +3033,1 @@\n-  \/\/ the AdapterHandlerTable (it is not safe for concurrent readers\n+  \/\/ the _adapter_handler_table (it is not safe for concurrent readers\n@@ -3139,1 +3036,0 @@\n-  assert(_adapters != NULL, \"Uninitialized\");\n@@ -3177,1 +3073,1 @@\n-    entry = _adapters->lookup(&ces.sig_cc(), ces.has_inline_recv());\n+    entry = lookup(&ces.sig_cc(), ces.has_inline_recv());\n@@ -3187,1 +3083,1 @@\n-        _adapters->free_entry(comparison_entry);\n+        delete comparison_entry;\n@@ -3264,1 +3160,1 @@\n-                  _adapters->number_of_entries(), fingerprint->as_basic_args_string(),\n+                  _adapter_handler_table.number_of_entries(), fingerprint->as_basic_args_string(),\n@@ -3281,1 +3177,2 @@\n-    _adapters->add(entry);\n+    assert_lock_strong(AdapterHandlerLibrary_lock);\n+    _adapter_handler_table.put(fingerprint, entry);\n@@ -3320,1 +3217,1 @@\n-void AdapterHandlerEntry::deallocate() {\n+AdapterHandlerEntry::~AdapterHandlerEntry() {\n@@ -3364,0 +3261,3 @@\n+  \/\/ Check if memory should be freed before allocation\n+  CodeCache::gc_on_allocation();\n+\n@@ -3622,6 +3522,7 @@\n-  AdapterHandlerTableIterator iter(_adapters);\n-  while (iter.has_next()) {\n-    AdapterHandlerEntry* a = iter.next();\n-    if (b == CodeCache::find_blob(a->get_i2c_entry())) return true;\n-  }\n-  return false;\n+  bool found = false;\n+  auto findblob = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n+    return (found = (b == CodeCache::find_blob(a->get_i2c_entry())));\n+  };\n+  assert_locked_or_safepoint(AdapterHandlerLibrary_lock);\n+  _adapter_handler_table.iterate(findblob);\n+  return found;\n@@ -3631,3 +3532,2 @@\n-  AdapterHandlerTableIterator iter(_adapters);\n-  while (iter.has_next()) {\n-    AdapterHandlerEntry* a = iter.next();\n+  bool found = false;\n+  auto findblob = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n@@ -3635,0 +3535,1 @@\n+      found = true;\n@@ -3636,2 +3537,4 @@\n-      a->print_adapter_on(tty);\n-      return;\n+      a->print_adapter_on(st);\n+      return true;\n+    } else {\n+      return false; \/\/ keep looking\n@@ -3639,2 +3542,4 @@\n-  }\n-  assert(false, \"Should have found handler\");\n+  };\n+  assert_locked_or_safepoint(AdapterHandlerLibrary_lock);\n+  _adapter_handler_table.iterate(findblob);\n+  assert(found, \"Should have found handler\");\n@@ -3672,1 +3577,1 @@\n-  _adapters->print_statistics();\n+  print_table_statistics();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":76,"deletions":171,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"utilities\/hashtable.hpp\"\n@@ -40,1 +39,0 @@\n-class AdapterHandlerTable;\n@@ -532,1 +530,1 @@\n-  \/\/ wrong method handling (inline cache misses, zombie methods)\n+  \/\/ wrong method handling (inline cache misses)\n@@ -646,2 +644,1 @@\n-class AdapterHandlerEntry : public BasicHashtableEntry<mtCode> {\n-  friend class AdapterHandlerTable;\n+class AdapterHandlerEntry : public CHeapObj<mtCode> {\n@@ -670,11 +667,12 @@\n-  void init(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_inline_entry,\n-            address c2i_inline_ro_entry, address c2i_unverified_entry, address c2i_unverified_inline_entry, address c2i_no_clinit_check_entry) {\n-    _fingerprint = fingerprint;\n-    _i2c_entry = i2c_entry;\n-    _c2i_entry = c2i_entry;\n-    _c2i_inline_entry = c2i_inline_entry;\n-    _c2i_inline_ro_entry = c2i_inline_ro_entry;\n-    _c2i_unverified_entry = c2i_unverified_entry;\n-    _c2i_unverified_inline_entry = c2i_unverified_inline_entry;\n-    _c2i_no_clinit_check_entry = c2i_no_clinit_check_entry;\n-    _sig_cc = NULL;\n+  AdapterHandlerEntry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry,\n+                      address c2i_inline_entry, address c2i_inline_ro_entry,\n+                      address c2i_unverified_entry, address c2i_unverified_inline_entry,\n+                      address c2i_no_clinit_check_entry) :\n+    _fingerprint(fingerprint),\n+    _i2c_entry(i2c_entry),\n+    _c2i_entry(c2i_entry),\n+    _c2i_inline_entry(c2i_inline_entry),\n+    _c2i_inline_ro_entry(c2i_inline_ro_entry),\n+    _c2i_unverified_entry(c2i_unverified_entry),\n+    _c2i_unverified_inline_entry(c2i_unverified_inline_entry),\n+    _c2i_no_clinit_check_entry(c2i_no_clinit_check_entry)\n@@ -682,1 +680,1 @@\n-    _saved_code_length = 0;\n+    , _saved_code_length(0)\n@@ -684,3 +682,1 @@\n-  }\n-\n-  void deallocate();\n+  { }\n@@ -688,2 +684,1 @@\n-  \/\/ should never be used\n-  AdapterHandlerEntry();\n+  ~AdapterHandlerEntry();\n@@ -709,4 +704,0 @@\n-  AdapterHandlerEntry* next() {\n-    return (AdapterHandlerEntry*)BasicHashtableEntry<mtCode>::next();\n-  }\n-\n@@ -729,1 +720,0 @@\n-  static AdapterHandlerTable* _adapters;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":17,"deletions":27,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -345,0 +345,5 @@\n+    \/\/ If we discovered only the string of '[', this means something is wrong.\n+    if (end >= limit) {\n+      assert(false, \"Invalid type detected\");\n+      return limit;\n+    }\n@@ -529,1 +534,1 @@\n-    k = SystemDictionary::find_instance_klass(name, class_loader, protection_domain);\n+    k = SystemDictionary::find_instance_klass(THREAD, name, class_loader, protection_domain);\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"utilities\/linkedlist.hpp\"\n@@ -62,0 +63,5 @@\n+class ObjectMonitorsHashtable::PtrList :\n+  public LinkedListImpl<ObjectMonitor*,\n+                        ResourceObj::C_HEAP, mtThread,\n+                        AllocFailStrategy::RETURN_NULL> {};\n+\n@@ -81,1 +87,1 @@\n-    list = new (ResourceObj::C_HEAP, mtThread) ObjectMonitorsHashtable::PtrList();\n+    list = new (ResourceObj::C_HEAP, mtThread) ObjectMonitorsHashtable::PtrList;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -99,1 +99,0 @@\n-  template(DumpTouchedMethods)                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    CodeCache::cleanup_inline_caches();\n+    CodeCache::cleanup_inline_caches_whitebox();\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+class ObjectMonitorsHashtable;\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-#include \"utilities\/hashtable.hpp\"\n@@ -293,1 +292,0 @@\n-  nonstatic_field(MethodCounters,              _nmethod_age,                                  int)                                   \\\n@@ -667,3 +665,1 @@\n-  volatile_nonstatic_field(nmethod,            _lock_count,                                   jint)                                  \\\n-  volatile_nonstatic_field(nmethod,            _stack_traversal_mark,                         int64_t)                               \\\n-  nonstatic_field(nmethod,                     _comp_level,                                   int)                                   \\\n+  nonstatic_field(nmethod,                     _comp_level,                                   CompLevel)                             \\\n@@ -1325,1 +1321,0 @@\n-        declare_type(CodeCacheSweeperThread, JavaThread)                  \\\n@@ -1661,1 +1656,0 @@\n-  declare_c2_type(LoadPLockedNode, LoadPNode)                             \\\n@@ -1664,2 +1658,0 @@\n-  declare_c2_type(StorePConditionalNode, LoadStoreNode)                   \\\n-  declare_c2_type(StoreLConditionalNode, LoadStoreNode)                   \\\n@@ -1982,0 +1974,2 @@\n+                                                                          \\\n+  declare_integer_type(CompLevel)                                         \\\n@@ -2563,2 +2557,1 @@\n-  declare_constant(RegisterImpl::number_of_registers)                     \\\n-  declare_preprocessor_constant(\"REG_COUNT\", REG_COUNT)                \\\n+  declare_preprocessor_constant(\"REG_COUNT\", REG_COUNT)                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -130,1 +130,0 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<TouchedMethodsDCmd>(full_export, true, false));\n@@ -960,24 +959,0 @@\n-class VM_DumpTouchedMethods : public VM_Operation {\n-private:\n-  outputStream* _out;\n-public:\n-  VM_DumpTouchedMethods(outputStream* out) {\n-    _out = out;\n-  }\n-\n-  virtual VMOp_Type type() const { return VMOp_DumpTouchedMethods; }\n-\n-  virtual void doit() {\n-    Method::print_touched_methods(_out);\n-  }\n-};\n-\n-void TouchedMethodsDCmd::execute(DCmdSource source, TRAPS) {\n-  if (!LogTouchedMethods) {\n-    output()->print_cr(\"VM.print_touched_methods command requires -XX:+LogTouchedMethods\");\n-    return;\n-  }\n-  VM_DumpTouchedMethods dumper(output());\n-  VMThread::execute(&dumper);\n-}\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -414,15 +414,0 @@\n-class TouchedMethodsDCmd : public DCmd {\n-public:\n-  TouchedMethodsDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n-  static const char* name() {\n-    return \"VM.print_touched_methods\";\n-  }\n-  static const char* description() {\n-    return \"Print all methods that have ever been touched during the lifetime of this JVM.\";\n-  }\n-  static const char* impact() {\n-    return \"Medium: Depends on Java content.\";\n-  }\n-  virtual void execute(DCmdSource source, TRAPS);\n-};\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -510,0 +510,3 @@\n+\n+  void write_address(address a);\n+\n@@ -529,0 +532,1 @@\n+  void write_rootID(oop* p);\n@@ -611,2 +615,1 @@\n-void AbstractDumpWriter::write_objectID(oop o) {\n-  address a = cast_from_oop<address>(o);\n+void AbstractDumpWriter::write_address(address a) {\n@@ -620,0 +623,8 @@\n+void AbstractDumpWriter::write_objectID(oop o) {\n+  write_address(cast_from_oop<address>(o));\n+}\n+\n+void AbstractDumpWriter::write_rootID(oop* p) {\n+  write_address((address)p);\n+}\n+\n@@ -621,6 +632,1 @@\n-  address a = (address)((uintptr_t)s);\n-#ifdef _LP64\n-  write_u8((u8)a);\n-#else\n-  write_u4((u4)a);\n-#endif\n+  write_address((address)((uintptr_t)s));\n@@ -2069,1 +2075,1 @@\n-    writer()->write_objectID((oopDesc*)obj_p);      \/\/ global ref ID\n+    writer()->write_rootID(obj_p);      \/\/ global ref ID\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-#define MEMORY_TYPE_DECLARE_NAME(type, human_readable) \\\n-  human_readable,\n-\n@@ -35,1 +32,4 @@\n-const char* NMTUtil::_memory_type_names[] = {\n+#define MEMORY_TYPE_DECLARE_NAME(type, human_readable) \\\n+  { #type, human_readable },\n+\n+NMTUtil::S NMTUtil::_strings[] = {\n@@ -90,0 +90,13 @@\n+\n+MEMFLAGS NMTUtil::string_to_flag(const char* s) {\n+  for (int i = 0; i < mt_number_of_types; i ++) {\n+    assert(::strlen(_strings[i].enum_s) > 2, \"Sanity\"); \/\/ should always start with \"mt\"\n+    if (::strcasecmp(_strings[i].human_readable, s) == 0 ||\n+        ::strcasecmp(_strings[i].enum_s, s) == 0 ||\n+        ::strcasecmp(_strings[i].enum_s + 2, s) == 0) \/\/ \"mtXXX\" -> match also \"XXX\" or \"xxx\"\n+    {\n+      return (MEMFLAGS)i;\n+    }\n+  }\n+  return mtNone;\n+}\n","filename":"src\/hotspot\/share\/services\/nmtCommon.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1151,1 +1151,0 @@\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1503,10 +1503,12 @@\n-        \/\/ This likely needs some refinement. Exploration of hidden\n-        \/\/ classes, array classes.  Location.CLASS allows SUPER and\n-        \/\/ AccessFlag.MODULE which INNER_CLASS forbids. INNER_CLASS\n-        \/\/ allows PRIVATE, PROTECTED, and STATIC, which are not\n-        \/\/ allowed on Location.CLASS.\n-        return AccessFlag.maskToAccessFlags(getModifiers(),\n-                                            (isMemberClass() || isLocalClass() ||\n-                                             isAnonymousClass() || isArray()) ?\n-                                            AccessFlag.Location.INNER_CLASS :\n-                                            AccessFlag.Location.CLASS);\n+        \/\/ Location.CLASS allows SUPER and AccessFlag.MODULE which\n+        \/\/ INNER_CLASS forbids. INNER_CLASS allows PRIVATE, PROTECTED,\n+        \/\/ and STATIC, which are not allowed on Location.CLASS.\n+        \/\/ Use getClassAccessFlagsRaw to expose SUPER status.\n+        var location = (isMemberClass() || isLocalClass() ||\n+                        isAnonymousClass() || isArray()) ?\n+            AccessFlag.Location.INNER_CLASS :\n+            AccessFlag.Location.CLASS;\n+        return AccessFlag.maskToAccessFlags((location == AccessFlag.Location.CLASS) ?\n+                                            getClassAccessFlagsRaw() :\n+                                            getModifiers(),\n+                                            location);\n@@ -4835,0 +4837,30 @@\n+\n+    \/*\n+     * Return the class's major and minor class file version packed into an int.\n+     * The high order 16 bits contain the class's minor version.  The low order\n+     * 16 bits contain the class's major version.\n+     *\n+     * If the class is an array type then the class file version of its element\n+     * type is returned.  If the class is a primitive type then the latest class\n+     * file major version is returned and zero is returned for the minor version.\n+     *\/\n+    private int getClassFileVersion() {\n+        Class<?> c = isArray() ? elementType() : this;\n+        return c.getClassFileVersion0();\n+    }\n+\n+    private native int getClassFileVersion0();\n+\n+    \/*\n+     * Return the access flags as they were in the class's bytecode, including\n+     * the original setting of ACC_SUPER.\n+     *\n+     * If the class is an array type then the access flags of the element type is\n+     * returned.  If the class is a primitive then ACC_ABSTRACT | ACC_FINAL | ACC_PUBLIC.\n+     *\/\n+    private int getClassAccessFlagsRaw() {\n+        Class<?> c = isArray() ? elementType() : this;\n+        return c.getClassAccessFlagsRaw0();\n+    }\n+\n+    private native int getClassAccessFlagsRaw0();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":42,"deletions":10,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -6827,1 +6827,1 @@\n-        if (!pred.stream().filter(Objects::nonNull).findFirst().isPresent()) {\n+        if (pred.stream().noneMatch(Objects::nonNull)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -73,1 +74,1 @@\n- * The JVM class file format has a new version defined for each new\n+ * The JVM class file format has a {@linkplain ClassFileFormatVersion new version} defined for each new\n@@ -94,0 +95,5 @@\n+    \/\/ Note to maintainers: anonymous class instances are used rather\n+    \/\/ than lambdas to initialize the functions used for the\n+    \/\/ cffvToLocations field to avoid using lambdas too early in JDK\n+    \/\/ initialization.\n+\n@@ -96,1 +102,1 @@\n-     * modifier {@link Modifier#PUBLIC public} with a mask value of\n+     * modifier {@link Modifier#PUBLIC public}, with a mask value of\n@@ -100,2 +106,9 @@\n-           Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n-                  Location.INNER_CLASS)),\n+           Location.SET_PUBLIC_1,\n+           new Function<ClassFileFormatVersion, Set<Location>>() {\n+               @Override\n+               public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                   return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                       Location.SET_CLASS_FIELD_METHOD:\n+                       Location.SET_PUBLIC_1;\n+               }\n+           }),\n@@ -105,1 +118,1 @@\n-     * source modifier {@link Modifier#PRIVATE private} with a mask\n+     * source modifier {@link Modifier#PRIVATE private}, with a mask\n@@ -108,1 +121,9 @@\n-    PRIVATE(Modifier.PRIVATE, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+    PRIVATE(Modifier.PRIVATE, true, Location.SET_FIELD_METHOD_INNER_CLASS,\n+            new Function<ClassFileFormatVersion, Set<Location>>() {\n+                @Override\n+                    public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                    return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                        Location.SET_FIELD_METHOD:\n+                        Location.SET_FIELD_METHOD_INNER_CLASS;\n+                }\n+            }),\n@@ -112,1 +133,1 @@\n-     * source modifier {@link Modifier#PROTECTED protected} with a mask\n+     * source modifier {@link Modifier#PROTECTED protected}, with a mask\n@@ -115,1 +136,9 @@\n-    PROTECTED(Modifier.PROTECTED, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+    PROTECTED(Modifier.PROTECTED, true, Location.SET_FIELD_METHOD_INNER_CLASS,\n+              new Function<ClassFileFormatVersion, Set<Location>>() {\n+                  @Override\n+                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                  return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                      Location.SET_FIELD_METHOD:\n+                      Location.SET_FIELD_METHOD_INNER_CLASS;\n+                  }\n+              }),\n@@ -119,1 +148,1 @@\n-     * modifier {@link Modifier#STATIC static} with a mask value of\n+     * modifier {@link Modifier#STATIC static}, with a mask value of\n@@ -122,1 +151,8 @@\n-    STATIC(Modifier.STATIC, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+    STATIC(Modifier.STATIC, true, Location.SET_FIELD_METHOD_INNER_CLASS,\n+           new Function<ClassFileFormatVersion, Set<Location>>() {\n+               @Override\n+               public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                   return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                       Location.SET_FIELD_METHOD:\n+                       Location.SET_FIELD_METHOD_INNER_CLASS;}\n+           }),\n@@ -126,1 +162,1 @@\n-     * modifier {@link Modifier#FINAL final} with a mask\n+     * modifier {@link Modifier#FINAL final}, with a mask\n@@ -130,2 +166,13 @@\n-          Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n-                 Location.INNER_CLASS, Location.METHOD_PARAMETER)),\n+          Location.SET_FINAL_8,\n+           new Function<ClassFileFormatVersion, Set<Location>>() {\n+              @Override\n+              public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                  if (cffv.compareTo(ClassFileFormatVersion.RELEASE_8) >= 0) {\n+                      return Location.SET_FINAL_8;\n+                  } else {\n+                      return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                          Location.SET_CLASS_FIELD_METHOD :\n+                          Location.SET_CLASS_FIELD_METHOD_INNER_CLASS;\n+                  }\n+              }\n+          }),\n@@ -141,1 +188,1 @@\n-    SUPER(0x0000_0020, false, Location.SET_CLASS),\n+    SUPER(0x0000_0020, false, Location.SET_CLASS, null),\n@@ -154,1 +201,8 @@\n-    OPEN(0x0000_0020, false, Set.of(Location.MODULE)),\n+        OPEN(0x0000_0020, false, Location.SET_MODULE,\n+             new Function<ClassFileFormatVersion, Set<Location>>() {\n+                 @Override\n+                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                     return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                         Location.SET_MODULE:\n+                         Location.EMPTY_SET;}\n+             }),\n@@ -161,1 +215,8 @@\n-    TRANSITIVE(0x0000_0020, false, Location.SET_MODULE_REQUIRES),\n+    TRANSITIVE(0x0000_0020, false, Location.SET_MODULE_REQUIRES,\n+               new Function<ClassFileFormatVersion, Set<Location>>() {\n+                   @Override\n+                   public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                       return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                           Location.SET_MODULE_REQUIRES:\n+                           Location.EMPTY_SET;}\n+               }),\n@@ -165,1 +226,1 @@\n-     * source modifier {@link Modifier#SYNCHRONIZED synchronized} with\n+     * source modifier {@link Modifier#SYNCHRONIZED synchronized}, with\n@@ -168,1 +229,1 @@\n-    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD),\n+    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD, null),\n@@ -175,8 +236,15 @@\n-    STATIC_PHASE(0x0000_0040, false, Location.SET_MODULE_REQUIRES),\n-\n-     \/**\n-      * The access flag {@code ACC_VOLATILE}, corresponding to the\n-      * source modifier {@link Modifier#VOLATILE volatile} with a mask\n-      * value of <code>{@value \"0x%04x\" Modifier#VOLATILE}<\/code>.\n-      *\/\n-    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD),\n+    STATIC_PHASE(0x0000_0040, false, Location.SET_MODULE_REQUIRES,\n+                 new Function<ClassFileFormatVersion, Set<Location>>() {\n+                     @Override\n+                     public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                         return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                             Location.SET_MODULE_REQUIRES:\n+                             Location.EMPTY_SET;}\n+                 }),\n+\n+   \/**\n+     * The access flag {@code ACC_VOLATILE}, corresponding to the\n+     * source modifier {@link Modifier#VOLATILE volatile}, with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#VOLATILE}<\/code>.\n+     *\/\n+    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD, null),\n@@ -189,1 +257,8 @@\n-    BRIDGE(Modifier.BRIDGE, false, Location.SET_METHOD),\n+    BRIDGE(Modifier.BRIDGE, false, Location.SET_METHOD,\n+           new Function<ClassFileFormatVersion, Set<Location>>() {\n+               @Override\n+               public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                       Location.SET_METHOD:\n+                       Location.EMPTY_SET;}\n+           }),\n@@ -193,1 +268,1 @@\n-     * source modifier {@link Modifier#TRANSIENT transient} with a\n+     * source modifier {@link Modifier#TRANSIENT transient}, with a\n@@ -196,1 +271,1 @@\n-    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD),\n+    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD, null),\n@@ -203,1 +278,8 @@\n-    VARARGS(Modifier.VARARGS, false, Location.SET_METHOD),\n+    VARARGS(Modifier.VARARGS, false, Location.SET_METHOD,\n+            new Function<ClassFileFormatVersion, Set<Location>>() {\n+                @Override\n+                public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                    return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                        Location.SET_METHOD:\n+                        Location.EMPTY_SET;}\n+            }),\n@@ -207,1 +289,1 @@\n-     * modifier {@link Modifier#NATIVE native} with a mask value of\n+     * modifier {@link Modifier#NATIVE native}, with a mask value of\n@@ -210,1 +292,1 @@\n-    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD),\n+    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD, null),\n@@ -217,1 +299,8 @@\n-    INTERFACE(Modifier.INTERFACE, false, Location.SET_CLASS_INNER_CLASS),\n+    INTERFACE(Modifier.INTERFACE, false, Location.SET_CLASS_INNER_CLASS,\n+              new Function<ClassFileFormatVersion, Set<Location>>() {\n+                  @Override\n+                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                      return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n+                          Location.SET_CLASS:\n+                          Location.SET_CLASS_INNER_CLASS;}\n+              }),\n@@ -221,1 +310,1 @@\n-     * source modifier {@link Modifier#ABSTRACT abstract} with a mask\n+     * source modifier {@link Modifier#ABSTRACT abstract}, with a mask\n@@ -225,1 +314,8 @@\n-             Set.of(Location.CLASS, Location.METHOD, Location.INNER_CLASS)),\n+             Location.SET_CLASS_METHOD_INNER_CLASS,\n+             new Function<ClassFileFormatVersion, Set<Location>>() {\n+                 @Override\n+                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                     return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n+                         Location.SET_CLASS_METHOD:\n+                         Location.SET_CLASS_METHOD_INNER_CLASS;}\n+             }),\n@@ -229,1 +325,1 @@\n-     * modifier {@link Modifier#STRICT strictfp} with a mask value of\n+     * modifier {@link Modifier#STRICT strictfp}, with a mask value of\n@@ -237,1 +333,9 @@\n-    STRICT(Modifier.STRICT, true, Location.SET_METHOD),\n+    STRICT(Modifier.STRICT, true, Location.SET_METHOD,\n+             new Function<ClassFileFormatVersion, Set<Location>>() {\n+               @Override\n+               public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_2)  >= 0 &&\n+                           cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) ?\n+                       Location.SET_METHOD:\n+                       Location.EMPTY_SET;}\n+           }),\n@@ -246,5 +350,16 @@\n-    SYNTHETIC(Modifier.SYNTHETIC, false,\n-              Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n-                     Location.INNER_CLASS, Location.METHOD_PARAMETER,\n-                     Location.MODULE, Location.MODULE_REQUIRES,\n-                     Location.MODULE_EXPORTS, Location.MODULE_OPENS)),\n+    SYNTHETIC(Modifier.SYNTHETIC, false, Location.SET_SYNTHETIC_9,\n+              new Function<ClassFileFormatVersion, Set<Location>>() {\n+                  @Override\n+                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                      if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 )\n+                          return Location.SET_SYNTHETIC_9;\n+                      else {\n+                          return\n+                              switch(cffv) {\n+                              case RELEASE_7 -> Location.SET_SYNTHETIC_7;\n+                              case RELEASE_8 -> Location.SET_SYNTHETIC_8;\n+                              default        -> Location.EMPTY_SET;\n+                              };\n+                      }\n+                  }\n+              }),\n@@ -257,1 +372,8 @@\n-    ANNOTATION(Modifier.ANNOTATION, false, Location.SET_CLASS_INNER_CLASS),\n+    ANNOTATION(Modifier.ANNOTATION, false, Location.SET_CLASS_INNER_CLASS,\n+               new Function<ClassFileFormatVersion, Set<Location>>() {\n+                   @Override\n+                   public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                       return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                           Location.SET_CLASS_INNER_CLASS:\n+                           Location.EMPTY_SET;}\n+               }),\n@@ -264,2 +386,8 @@\n-    ENUM(Modifier.ENUM, false,\n-         Set.of(Location.CLASS, Location.FIELD, Location.INNER_CLASS)),\n+    ENUM(Modifier.ENUM, false, Location.SET_CLASS_FIELD_INNER_CLASS,\n+         new Function<ClassFileFormatVersion, Set<Location>>() {\n+             @Override\n+             public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                 return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                     Location.SET_CLASS_FIELD_INNER_CLASS:\n+                     Location.EMPTY_SET;}\n+         }),\n@@ -271,4 +399,13 @@\n-    MANDATED(Modifier.MANDATED, false,\n-             Set.of(Location.METHOD_PARAMETER,\n-                    Location.MODULE, Location.MODULE_REQUIRES,\n-                    Location.MODULE_EXPORTS, Location.MODULE_OPENS)),\n+    MANDATED(Modifier.MANDATED, false, Location.SET_MANDATED_9,\n+             new Function<ClassFileFormatVersion, Set<Location>>() {\n+                 @Override\n+                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                     if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) {\n+                         return Location.SET_MANDATED_9;\n+                     } else {\n+                         return (cffv == ClassFileFormatVersion.RELEASE_8) ?\n+                             Location.SET_METHOD_PARAM:\n+                             Location.EMPTY_SET;\n+                     }\n+                 }\n+             }),\n@@ -280,1 +417,8 @@\n-    MODULE(0x0000_8000, false, Location.SET_CLASS)\n+    MODULE(0x0000_8000, false, Location.SET_CLASS,\n+           new Function<ClassFileFormatVersion, Set<Location>>() {\n+               @Override\n+               public Set<Location> apply(ClassFileFormatVersion cffv) {\n+                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                       Location.SET_CLASS:\n+                       Location.EMPTY_SET;}\n+           })\n@@ -292,0 +436,2 @@\n+    \/\/ Lambda to implement locations(ClassFileFormatVersion cffv)\n+    private final Function<ClassFileFormatVersion, Set<Location>> cffvToLocations;\n@@ -293,1 +439,4 @@\n-    private AccessFlag(int mask, boolean sourceModifier, Set<Location> locations) {\n+    private AccessFlag(int mask,\n+                       boolean sourceModifier,\n+                       Set<Location> locations,\n+                       Function<ClassFileFormatVersion, Set<Location>> cffvToLocations) {\n@@ -297,0 +446,1 @@\n+        this.cffvToLocations = cffvToLocations;\n@@ -315,1 +465,2 @@\n-     * {@return kinds of constructs the flag can be applied to}\n+     * {@return kinds of constructs the flag can be applied to in the\n+     * latest class file format version}\n@@ -321,0 +472,14 @@\n+    \/**\n+     * {@return kinds of constructs the flag can be applied to in the\n+     * given class file format version}\n+     * @param cffv the class file format version to use\n+     * @throws NullPointerException if the parameter is {@code null}\n+     *\/\n+    public Set<Location> locations(ClassFileFormatVersion cffv) {\n+        if (cffvToLocations == null) {\n+            return locations;\n+        } else {\n+            return cffvToLocations.apply(cffv);\n+        }\n+    }\n+\n@@ -411,0 +576,14 @@\n+        private static final Set<Location> EMPTY_SET = Set.of();\n+        private static final Set<Location> SET_MODULE = Set.of(MODULE);\n+        private static final Set<Location> SET_CLASS_METHOD_INNER_CLASS =\n+            Set.of(CLASS, METHOD, INNER_CLASS);\n+        private static final Set<Location> SET_CLASS_FIELD_METHOD =\n+            Set.of(CLASS, FIELD, METHOD);\n+        private static final Set<Location> SET_CLASS_FIELD_INNER_CLASS =\n+            Set.of(CLASS, FIELD, INNER_CLASS);\n+        private static final Set<Location> SET_CLASS_FIELD_METHOD_INNER_CLASS =\n+            Set.of(CLASS, FIELD, METHOD, INNER_CLASS);\n+        private static final Set<Location> SET_CLASS_METHOD =\n+            Set.of(CLASS, METHOD);\n+        private static final Set<Location> SET_FIELD_METHOD =\n+            Set.of(FIELD, METHOD);\n@@ -414,0 +593,1 @@\n+        private static final Set<Location> SET_METHOD_PARAM = Set.of(METHOD_PARAMETER);\n@@ -420,0 +600,25 @@\n+        private static final Set<Location> SET_PUBLIC_1 =\n+            Set.of(CLASS, FIELD, METHOD, INNER_CLASS);\n+        private static final Set<Location> SET_FINAL_8 =\n+            Set.of(CLASS, FIELD, METHOD,\n+                   INNER_CLASS,     \/* added in 1.1 *\/\n+                   METHOD_PARAMETER); \/* added in 8 *\/\n+        private static final Set<Location> SET_SYNTHETIC_7 =\n+              Set.of(CLASS, FIELD, METHOD,\n+                     INNER_CLASS);\n+        private static final Set<Location> SET_SYNTHETIC_8 =\n+              Set.of(CLASS, FIELD, METHOD,\n+                     INNER_CLASS, METHOD_PARAMETER);\n+        private static final Set<Location> SET_SYNTHETIC_9 =\n+              \/\/ Added as an access flag in 7\n+              Set.of(CLASS, FIELD, METHOD,\n+                     INNER_CLASS,\n+                     METHOD_PARAMETER, \/\/ Added in 8\n+                     \/\/ Module-related items added in 9\n+                     MODULE, MODULE_REQUIRES,\n+                     MODULE_EXPORTS, MODULE_OPENS);\n+        private static final Set<Location> SET_MANDATED_9 =\n+            Set.of(METHOD_PARAMETER, \/\/ From 8\n+                   \/\/ Starting in 9\n+                   MODULE, MODULE_REQUIRES,\n+                   MODULE_EXPORTS, MODULE_OPENS);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":257,"deletions":52,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.annotation.*;\n+import java.lang.annotation.Annotation;\n@@ -34,1 +34,0 @@\n-import java.util.stream.Stream;\n@@ -38,0 +37,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -385,1 +385,1 @@\n-        return privateGetParameters().clone();\n+        return parameterData().parameters.clone();\n@@ -424,21 +424,3 @@\n-    private Parameter[] privateGetParameters() {\n-        \/\/ Use tmp to avoid multiple writes to a volatile.\n-        Parameter[] tmp = parameters;\n-        if (tmp == null) {\n-\n-            \/\/ Otherwise, go to the JVM to get them\n-            try {\n-                tmp = getParameters0();\n-            } catch(IllegalArgumentException e) {\n-                \/\/ Rethrow ClassFormatErrors\n-                throw new MalformedParametersException(\"Invalid constant pool index\");\n-            }\n-\n-            \/\/ If we get back nothing, then synthesize parameters\n-            if (tmp == null) {\n-                hasRealParameterData = false;\n-                tmp = synthesizeAllParams();\n-            } else {\n-                hasRealParameterData = true;\n-                verifyParameters(tmp);\n-            }\n+    boolean hasRealParameterData() {\n+        return parameterData().isReal;\n+    }\n@@ -447,1 +429,4 @@\n-            parameters = tmp;\n+    private ParameterData parameterData() {\n+        ParameterData parameterData = this.parameterData;\n+        if (parameterData != null) {\n+            return parameterData;\n@@ -450,2 +435,8 @@\n-        return tmp;\n-    }\n+        Parameter[] tmp;\n+        \/\/ Go to the JVM to get them\n+        try {\n+            tmp = getParameters0();\n+        } catch (IllegalArgumentException e) {\n+            \/\/ Rethrow ClassFormatErrors\n+            throw new MalformedParametersException(\"Invalid constant pool index\");\n+        }\n@@ -453,5 +444,7 @@\n-    boolean hasRealParameterData() {\n-        \/\/ If this somehow gets called before parameters gets\n-        \/\/ initialized, force it into existence.\n-        if (parameters == null) {\n-            privateGetParameters();\n+        \/\/ If we get back nothing, then synthesize parameters\n+        if (tmp == null) {\n+            tmp = synthesizeAllParams();\n+            parameterData = new ParameterData(tmp, false);\n+        } else {\n+            verifyParameters(tmp);\n+            parameterData = new ParameterData(tmp, true);\n@@ -459,1 +452,1 @@\n-        return hasRealParameterData;\n+        return this.parameterData = parameterData;\n@@ -462,2 +455,3 @@\n-    private transient volatile boolean hasRealParameterData;\n-    private transient volatile Parameter[] parameters;\n+    private transient @Stable ParameterData parameterData;\n+\n+    record ParameterData(@Stable Parameter[] parameters, boolean isReal) {}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":29,"deletions":35,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -161,1 +161,5 @@\n-    public static final int VALUE_CLASS  = 1<<21;\n+    public static final int VALUE_CLASS      = 1<<20;\n+\n+    \/** Flag is set for ClassSymbols that are being compiled from source.\n+     *\/\n+    public static final int FROM_SOURCE      = 1<<21; \/\/ClassSymbols\n@@ -527,0 +531,1 @@\n+        FROM_SOURCE(Flags.FROM_SOURCE),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1542,4 +1542,1 @@\n-        \/* creates a record component if non is related to the given variable and recreates a brand new one\n-         * in other case\n-         *\/\n-        public RecordComponent createRecordComponent(JCVariableDecl var, List<JCAnnotation> annotations) {\n+        public RecordComponent findRecordComponentToRemove(JCVariableDecl var) {\n@@ -1555,0 +1552,7 @@\n+            return toRemove;\n+        }\n+\n+        \/* creates a record component if non is related to the given variable and recreates a brand new one\n+         * in other case\n+         *\/\n+        public RecordComponent createRecordComponent(RecordComponent existing, JCVariableDecl var, List<JCAnnotation> annotations) {\n@@ -1556,4 +1560,3 @@\n-            if (toRemove != null) {\n-                \/\/ Found a record component with an erroneous type: remove it and create a new one\n-                recordComponents = List.filter(recordComponents, toRemove);\n-                recordComponents = recordComponents.append(rc = new RecordComponent(var.sym, toRemove.originalAnnos, toRemove.isVarargs));\n+            if (existing != null) {\n+                recordComponents = List.filter(recordComponents, existing);\n+                recordComponents = recordComponents.append(rc = new RecordComponent(var.sym, existing.originalAnnos, existing.isVarargs));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -689,1 +689,2 @@\n-        } else if ((c.name != name || c.owner != owner) && owner.kind == TYP && c.owner.kind == PCK) {\n+        } else if ((c.name != name || c.owner != owner) && owner.kind == TYP &&\n+                   c.owner.kind == PCK && ((c.flags_field & FROM_SOURCE) == 0)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2975,1 +2975,1 @@\n-                Env<AttrContext> dupLocalEnv = localEnv.dup(localEnv.tree, localEnv.info.dup(localEnv.info.scope.dupUnshared()));\n+                Env<AttrContext> dupLocalEnv = copyEnv(localEnv);\n@@ -4524,1 +4524,5 @@\n-            chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n+            if (!sym.owner.isAnonymous()) {\n+                chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n+            } else {\n+                chk.warnStatic(tree, Warnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -498,1 +498,1 @@\n-        c.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, c, tree);\n+        c.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, c, tree) | FROM_SOURCE;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -985,1 +985,1 @@\n-                memberEnter.memberEnter(fields, env);\n+\n@@ -987,1 +987,31 @@\n-                    sym.createRecordComponent(field,\n+                    \/** Some notes regarding the code below. Annotations applied to elements of a record header are propagated\n+                     *  to other elements which, when applicable, not explicitly declared by the user: the canonical constructor,\n+                     *  accessors, fields and record components. Of all these the only ones that can't be explicitly declared are\n+                     *  the fields and the record components.\n+                     *\n+                     *  Now given that annotations are propagated to all possible targets  regardless of applicability,\n+                     *  annotations not applicable to a given element should be removed. See Check::validateAnnotation. Once\n+                     *  annotations are removed we could lose the whole picture, that's why original annotations are stored in\n+                     *  the record component, see RecordComponent::originalAnnos, but there is no real AST representing a record\n+                     *  component so if there is an annotation processing round it could be that we need to reenter a record for\n+                     *  which we need to re-attribute its annotations. This is why one of the things the code below is doing is\n+                     *  copying the original annotations from the record component to the corresponding field, again this applies\n+                     *  only if APs are present.\n+                     *\n+                     *  First, we find the record component by comparing its name and position with current field,\n+                     *  if any, and we mark it. Then we copy the annotations to the field so that annotations applicable only to the record component\n+                     *  can be attributed, as if declared in the field, and then stored in the metadata associated to the record\n+                     *  component. The invariance we need to keep here is that record components must be scheduled for\n+                     *  annotation only once during this process.\n+                     *\/\n+                    RecordComponent rc = sym.findRecordComponentToRemove(field);\n+\n+                    if (rc != null && (rc.getOriginalAnnos().length() != field.mods.annotations.length())) {\n+                        TreeCopier<JCTree> tc = new TreeCopier<>(make.at(field.pos));\n+                        List<JCAnnotation> originalAnnos = tc.copy(rc.getOriginalAnnos());\n+                        field.mods.annotations = originalAnnos;\n+                    }\n+\n+                    memberEnter.memberEnter(field, env);\n+\n+                    sym.createRecordComponent(rc, field,\n@@ -1288,18 +1318,1 @@\n-            \/** Some notes regarding the code below. Annotations applied to elements of a record header are propagated\n-             *  to other elements which, when applicable, not explicitly declared by the user: the canonical constructor,\n-             *  accessors, fields and record components. Of all these the only ones that can't be explicitly declared are\n-             *  the fields and the record components.\n-             *\n-             *  Now given that annotations are propagated to all possible targets  regardless of applicability,\n-             *  annotations not applicable to a given element should be removed. See Check::validateAnnotation. Once\n-             *  annotations are removed we could lose the whole picture, that's why original annotations are stored in\n-             *  the record component, see RecordComponent::originalAnnos, but there is no real AST representing a record\n-             *  component so if there is an annotation processing round it could be that we need to reenter a record for\n-             *  which we need to re-attribute its annotations. This is why one of the things the code below is doing is\n-             *  copying the original annotations from the record component to the corresponding field, again this applies\n-             *  only if APs are present.\n-             *\n-             *  We need to copy the annotations to the field so that annotations applicable only to the record component\n-             *  can be attributed as if declared in the field and then stored in the metadata associated to the record\n-             *  component.\n-             *\/\n+            \/\/ fields can't be varargs, lets remove the flag\n@@ -1308,10 +1321,0 @@\n-                RecordComponent rec = tree.sym.getRecordComponent(field.sym);\n-                TreeCopier<JCTree> tc = new TreeCopier<>(make.at(field.pos));\n-                List<JCAnnotation> originalAnnos = tc.copy(rec.getOriginalAnnos());\n-\n-                if (originalAnnos.length() != field.mods.annotations.length()) {\n-                    field.mods.annotations = originalAnnos;\n-                    annotate.annotateLater(originalAnnos, env, field.sym, field.pos());\n-                }\n-\n-                \/\/ also here\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":33,"deletions":30,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2647,1 +2647,1 @@\n-                if (c == outer) {\n+                if (c == outer && member.owner == c) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2019,0 +2019,4 @@\n+# 0: kind name\n+compiler.warn.static.not.qualified.by.type2=\\\n+    static {0} should not be used as a member of an anonymous class\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -373,2 +373,2 @@\n-Please file a bug against the Java compiler via the Java bug reporting page (http:\/\/bugreport.java.com) \\\n-after checking the Bug Database (http:\/\/bugs.java.com) for duplicates. \\\n+Please file a bug against the Java compiler via the Java bug reporting page (https:\/\/bugreport.java.com) \\\n+after checking the Bug Database (https:\/\/bugs.java.com) for duplicates. \\\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-    final int nmethodCompLevelOffset = getFieldOffset(\"nmethod::_comp_level\", Integer.class, \"int\");\n+    final int nmethodCompLevelOffset = getFieldOffset(\"nmethod::_comp_level\", Integer.class, \"CompLevel\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+serviceability\/attach\/ConcAttachTest.java 8290043 linux-all\n@@ -182,0 +183,1 @@\n+vmTestbase\/gc\/lock\/jni\/jnilock001\/TestDescription.java 8292946 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -535,1 +535,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n@@ -537,1 +537,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n+            boolean x = (boolean) vh.get(recv);\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -545,1 +552,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = (boolean) vh.get(recv);\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -547,1 +561,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -555,1 +569,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n+            boolean x = (boolean) vh.get(recv);\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n@@ -557,1 +578,1 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -565,1 +586,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n@@ -567,1 +588,8 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean value\");\n+            assertEquals(x, true, \"success weakCompareAndSet boolean value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n+            boolean x = (boolean) vh.get(recv);\n+            assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n@@ -795,1 +823,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n+            boolean x = (boolean) vh.get();\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n@@ -797,1 +832,1 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -805,1 +840,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = (boolean) vh.get();\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -807,1 +849,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -815,1 +857,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n@@ -817,1 +859,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n+            boolean x = (boolean) vh.get();\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -825,1 +874,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+            boolean x = (boolean) vh.get();\n+            assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -827,1 +883,1 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n@@ -1058,1 +1114,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n+                boolean x = (boolean) vh.get(array, i);\n+                assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, true, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n@@ -1060,1 +1123,1 @@\n-                assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+                assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -1068,1 +1131,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n@@ -1070,1 +1133,8 @@\n-                assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+                assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, false, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n+                boolean x = (boolean) vh.get(array, i);\n+                assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -1078,1 +1148,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n+                boolean x = (boolean) vh.get(array, i);\n+                assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, true, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n@@ -1080,1 +1157,1 @@\n-                assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+                assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -1088,1 +1165,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+                boolean x = (boolean) vh.get(array, i);\n+                assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, false, false);\n+                assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -1090,1 +1174,1 @@\n-                assertEquals(x, true, \"weakCompareAndSet boolean\");\n+                assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessBoolean.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -513,1 +513,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n@@ -515,1 +515,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n+            byte x = (byte) vh.get(recv);\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -523,1 +530,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = (byte) vh.get(recv);\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -525,1 +539,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -533,1 +547,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n+            byte x = (byte) vh.get(recv);\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n@@ -535,1 +556,1 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -543,1 +564,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n@@ -545,1 +566,8 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte value\");\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n+            byte x = (byte) vh.get(recv);\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n@@ -789,1 +817,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n+            byte x = (byte) vh.get();\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain((byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n@@ -791,1 +826,1 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -799,1 +834,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = (byte) vh.get();\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire((byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -801,1 +843,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -809,1 +851,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n@@ -811,1 +853,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease((byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n+            byte x = (byte) vh.get();\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -819,1 +868,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n+            byte x = (byte) vh.get();\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet((byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -821,1 +877,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n@@ -1068,1 +1124,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n+                byte x = (byte) vh.get(array, i);\n+                assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, (byte)0x01, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n@@ -1070,1 +1133,1 @@\n-                assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+                assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -1078,1 +1141,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n@@ -1080,1 +1143,8 @@\n-                assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+                assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, (byte)0x23, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n+                byte x = (byte) vh.get(array, i);\n+                assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -1088,1 +1158,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n+                byte x = (byte) vh.get(array, i);\n+                assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, (byte)0x01, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n@@ -1090,1 +1167,1 @@\n-                assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+                assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -1098,1 +1175,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet byte\");\n+                assertEquals(success, true, \"success weakCompareAndSet byte\");\n+                byte x = (byte) vh.get(array, i);\n+                assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, (byte)0x23, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -1100,1 +1184,1 @@\n-                assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+                assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessByte.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -513,1 +513,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n@@ -515,1 +515,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n+            char x = (char) vh.get(recv);\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -523,1 +530,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = (char) vh.get(recv);\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -525,1 +539,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -533,1 +547,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n+            char x = (char) vh.get(recv);\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n@@ -535,1 +556,1 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -543,1 +564,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n@@ -545,1 +566,8 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char value\");\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n+            char x = (char) vh.get(recv);\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n@@ -789,1 +817,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n+            char x = (char) vh.get();\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain('\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n@@ -791,1 +826,1 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -799,1 +834,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = (char) vh.get();\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire('\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -801,1 +843,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -809,1 +851,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n@@ -811,1 +853,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease('\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n+            char x = (char) vh.get();\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -819,1 +868,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n+            char x = (char) vh.get();\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet('\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -821,1 +877,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n@@ -1068,1 +1124,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n+                char x = (char) vh.get(array, i);\n+                assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, '\\u0123', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n@@ -1070,1 +1133,1 @@\n-                assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+                assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -1078,1 +1141,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n@@ -1080,1 +1143,8 @@\n-                assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+                assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, '\\u4567', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n+                char x = (char) vh.get(array, i);\n+                assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -1088,1 +1158,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n+                char x = (char) vh.get(array, i);\n+                assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, '\\u0123', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n@@ -1090,1 +1167,1 @@\n-                assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+                assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -1098,1 +1175,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet char\");\n+                assertEquals(success, true, \"success weakCompareAndSet char\");\n+                char x = (char) vh.get(array, i);\n+                assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, '\\u4567', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -1100,1 +1184,1 @@\n-                assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+                assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessChar.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -583,1 +583,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n@@ -585,1 +585,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n+            double x = (double) vh.get(recv);\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -593,1 +600,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = (double) vh.get(recv);\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -595,1 +609,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -603,1 +617,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n+            double x = (double) vh.get(recv);\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n@@ -605,1 +626,1 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -613,1 +634,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n@@ -615,1 +636,8 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double value\");\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n+            double x = (double) vh.get(recv);\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n@@ -811,1 +839,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n+            double x = (double) vh.get();\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n@@ -813,1 +848,1 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -821,1 +856,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = (double) vh.get();\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -823,1 +865,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -831,1 +873,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n@@ -833,1 +875,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n+            double x = (double) vh.get();\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -841,1 +890,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n+            double x = (double) vh.get();\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -843,1 +899,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n@@ -1042,1 +1098,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n+                double x = (double) vh.get(array, i);\n+                assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, 1.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n@@ -1044,1 +1107,1 @@\n-                assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+                assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -1052,1 +1115,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n@@ -1054,1 +1117,8 @@\n-                assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+                assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, 2.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n+                double x = (double) vh.get(array, i);\n+                assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -1062,1 +1132,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n+                double x = (double) vh.get(array, i);\n+                assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, 1.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n@@ -1064,1 +1141,1 @@\n-                assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+                assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -1072,1 +1149,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet double\");\n+                assertEquals(success, true, \"success weakCompareAndSet double\");\n+                double x = (double) vh.get(array, i);\n+                assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, 2.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -1074,1 +1158,1 @@\n-                assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+                assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessDouble.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -583,1 +583,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n@@ -585,1 +585,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n+            float x = (float) vh.get(recv);\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -593,1 +600,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = (float) vh.get(recv);\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -595,1 +609,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -603,1 +617,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n+            float x = (float) vh.get(recv);\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n@@ -605,1 +626,1 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -613,1 +634,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n@@ -615,1 +636,8 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float value\");\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n+            float x = (float) vh.get(recv);\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n@@ -811,1 +839,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n+            float x = (float) vh.get();\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n@@ -813,1 +848,1 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -821,1 +856,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = (float) vh.get();\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -823,1 +865,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -831,1 +873,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n@@ -833,1 +875,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n+            float x = (float) vh.get();\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -841,1 +890,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n+            float x = (float) vh.get();\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -843,1 +899,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n@@ -1042,1 +1098,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n+                float x = (float) vh.get(array, i);\n+                assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, 1.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n@@ -1044,1 +1107,1 @@\n-                assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+                assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -1052,1 +1115,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n@@ -1054,1 +1117,8 @@\n-                assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+                assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, 2.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n+                float x = (float) vh.get(array, i);\n+                assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -1062,1 +1132,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n+                float x = (float) vh.get(array, i);\n+                assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, 1.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n@@ -1064,1 +1141,1 @@\n-                assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+                assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -1072,1 +1149,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet float\");\n+                assertEquals(success, true, \"success weakCompareAndSet float\");\n+                float x = (float) vh.get(array, i);\n+                assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, 2.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -1074,1 +1158,1 @@\n-                assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+                assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessFloat.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -513,1 +513,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n@@ -515,1 +515,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n+            int x = (int) vh.get(recv);\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -523,1 +530,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = (int) vh.get(recv);\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -525,1 +539,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -533,1 +547,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n+            int x = (int) vh.get(recv);\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n@@ -535,1 +556,1 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -543,1 +564,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n@@ -545,1 +566,8 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int value\");\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n+            int x = (int) vh.get(recv);\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n@@ -789,1 +817,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n+            int x = (int) vh.get();\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n@@ -791,1 +826,1 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -799,1 +834,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = (int) vh.get();\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -801,1 +843,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -809,1 +851,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n@@ -811,1 +853,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n+            int x = (int) vh.get();\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -819,1 +868,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n+            int x = (int) vh.get();\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -821,1 +877,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n@@ -1068,1 +1124,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n+                int x = (int) vh.get(array, i);\n+                assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, 0x01234567, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n@@ -1070,1 +1133,1 @@\n-                assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+                assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -1078,1 +1141,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n@@ -1080,1 +1143,8 @@\n-                assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+                assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, 0x89ABCDEF, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n+                int x = (int) vh.get(array, i);\n+                assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -1088,1 +1158,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n+                int x = (int) vh.get(array, i);\n+                assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, 0x01234567, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n@@ -1090,1 +1167,1 @@\n-                assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+                assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -1098,1 +1175,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet int\");\n+                assertEquals(success, true, \"success weakCompareAndSet int\");\n+                int x = (int) vh.get(array, i);\n+                assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, 0x89ABCDEF, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -1100,1 +1184,1 @@\n-                assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+                assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessInt.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -513,1 +513,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n@@ -515,1 +515,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n+            long x = (long) vh.get(recv);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -523,1 +530,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = (long) vh.get(recv);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -525,1 +539,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -533,1 +547,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n+            long x = (long) vh.get(recv);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n@@ -535,1 +556,1 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -543,1 +564,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n@@ -545,1 +566,8 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long value\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n+            long x = (long) vh.get(recv);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n@@ -789,1 +817,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n+            long x = (long) vh.get();\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n@@ -791,1 +826,1 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -799,1 +834,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = (long) vh.get();\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -801,1 +843,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -809,1 +851,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n@@ -811,1 +853,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n+            long x = (long) vh.get();\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -819,1 +868,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n+            long x = (long) vh.get();\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -821,1 +877,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n@@ -1068,1 +1124,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n+                long x = (long) vh.get(array, i);\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n@@ -1070,1 +1133,1 @@\n-                assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -1078,1 +1141,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n@@ -1080,1 +1143,8 @@\n-                assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+                assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n+                long x = (long) vh.get(array, i);\n+                assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -1088,1 +1158,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n+                long x = (long) vh.get(array, i);\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n@@ -1090,1 +1167,1 @@\n-                assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -1098,1 +1175,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet long\");\n+                assertEquals(success, true, \"success weakCompareAndSet long\");\n+                long x = (long) vh.get(array, i);\n+                assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -1100,1 +1184,1 @@\n-                assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+                assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessLong.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -513,1 +513,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n@@ -515,1 +515,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n+            short x = (short) vh.get(recv);\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -523,1 +530,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = (short) vh.get(recv);\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -525,1 +539,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -533,1 +547,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n+            short x = (short) vh.get(recv);\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n@@ -535,1 +556,1 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -543,1 +564,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n@@ -545,1 +566,8 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short value\");\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n+            short x = (short) vh.get(recv);\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n@@ -789,1 +817,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n+            short x = (short) vh.get();\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain((short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n@@ -791,1 +826,1 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -799,1 +834,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = (short) vh.get();\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire((short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -801,1 +843,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -809,1 +851,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n@@ -811,1 +853,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease((short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n+            short x = (short) vh.get();\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -819,1 +868,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n+            short x = (short) vh.get();\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet((short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -821,1 +877,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n@@ -1068,1 +1124,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n+                short x = (short) vh.get(array, i);\n+                assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, (short)0x0123, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n@@ -1070,1 +1133,1 @@\n-                assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+                assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -1078,1 +1141,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n@@ -1080,1 +1143,8 @@\n-                assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+                assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, (short)0x4567, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n+                short x = (short) vh.get(array, i);\n+                assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -1088,1 +1158,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n+                short x = (short) vh.get(array, i);\n+                assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, (short)0x0123, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n@@ -1090,1 +1167,1 @@\n-                assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+                assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -1098,1 +1175,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet short\");\n+                assertEquals(success, true, \"success weakCompareAndSet short\");\n+                short x = (short) vh.get(array, i);\n+                assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, (short)0x4567, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -1100,1 +1184,1 @@\n-                assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+                assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessShort.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -591,1 +591,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n@@ -593,1 +593,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n+            String x = (String) vh.get(recv);\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -601,1 +608,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n+            String x = (String) vh.get(recv);\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -603,1 +617,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -611,1 +625,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n+            String x = (String) vh.get(recv);\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n@@ -613,1 +634,1 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -621,1 +642,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet String\");\n+            assertEquals(success, true, \"success weakCompareAndSet String\");\n@@ -623,1 +644,8 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet String value\");\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet String value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet String\");\n+            String x = (String) vh.get(recv);\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n@@ -803,1 +831,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n+            String x = (String) vh.get();\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(\"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n@@ -805,1 +840,1 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -813,1 +848,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n+            String x = (String) vh.get();\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(\"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -815,1 +857,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -823,1 +865,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n@@ -825,1 +867,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(\"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n+            String x = (String) vh.get();\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -833,1 +882,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet String\");\n+            assertEquals(success, true, \"success weakCompareAndSet String\");\n+            String x = (String) vh.get();\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(\"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet String\");\n@@ -835,1 +891,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n@@ -1018,1 +1074,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n+                String x = (String) vh.get(array, i);\n+                assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, \"foo\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n@@ -1020,1 +1083,1 @@\n-                assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+                assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -1028,1 +1091,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n@@ -1030,1 +1093,8 @@\n-                assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+                assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, \"bar\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n+                String x = (String) vh.get(array, i);\n+                assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -1038,1 +1108,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n+                String x = (String) vh.get(array, i);\n+                assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, \"foo\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n@@ -1040,1 +1117,1 @@\n-                assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+                assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -1048,1 +1125,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet String\");\n+                assertEquals(success, true, \"success weakCompareAndSet String\");\n+                String x = (String) vh.get(array, i);\n+                assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, \"bar\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSet String\");\n@@ -1050,1 +1134,1 @@\n-                assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+                assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestAccessString.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n@@ -231,1 +231,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -239,1 +246,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -241,1 +255,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -249,1 +263,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n@@ -251,1 +272,1 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -259,1 +280,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n@@ -261,1 +282,8 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean\");\n+            assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n@@ -486,1 +514,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n@@ -488,1 +523,1 @@\n-            assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+            assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -496,1 +531,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -498,1 +540,1 @@\n-            assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -506,1 +548,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n@@ -508,1 +550,8 @@\n-            assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+            assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(true, false);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, false, \"failing weakCompareAndSetRelease boolean value\");\n@@ -516,1 +565,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet boolean\");\n+            assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+            boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(false, false);\n+            assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -518,1 +574,1 @@\n-            assertEquals(x, true, \"weakCompareAndSet boolean\");\n+            assertEquals(x, true, \"failing weakCompareAndSetRe boolean value\");\n@@ -745,1 +801,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain boolean\");\n+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, false, \"success weakCompareAndSetPlain boolean value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, true, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain boolean\");\n@@ -747,1 +810,1 @@\n-                assertEquals(x, false, \"weakCompareAndSetPlain boolean value\");\n+                assertEquals(x, false, \"failing weakCompareAndSetPlain boolean value\");\n@@ -755,1 +818,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire boolean\");\n@@ -757,1 +820,8 @@\n-                assertEquals(x, true, \"weakCompareAndSetAcquire boolean\");\n+                assertEquals(x, true, \"success weakCompareAndSetAcquire boolean\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, false, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, true, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -765,1 +835,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease boolean\");\n+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, false, \"success weakCompareAndSetRelease boolean\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, true, false);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire boolean\");\n@@ -767,1 +844,1 @@\n-                assertEquals(x, false, \"weakCompareAndSetRelease boolean\");\n+                assertEquals(x, false, \"failing weakCompareAndSetAcquire boolean value\");\n@@ -775,1 +852,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet boolean\");\n+                assertEquals(success, true, \"success weakCompareAndSet boolean\");\n+                boolean x = (boolean) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, true, \"success weakCompareAndSet boolean\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, false, false);\n+                assertEquals(success, false, \"failing weakCompareAndSet boolean\");\n@@ -777,1 +861,1 @@\n-                assertEquals(x, true, \"weakCompareAndSet boolean\");\n+                assertEquals(x, true, \"failing weakCompareAndSet boolean value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessBoolean.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n@@ -231,1 +231,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -239,1 +246,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -241,1 +255,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -249,1 +263,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, (byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n@@ -251,1 +272,1 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -259,1 +280,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n@@ -261,1 +282,8 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, (byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n@@ -503,1 +531,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact((byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n@@ -505,1 +540,1 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -513,1 +548,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact((byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -515,1 +557,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -523,1 +565,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n@@ -525,1 +567,8 @@\n-            assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+            assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact((byte)0x01, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (byte)0x23, \"failing weakCompareAndSetRelease byte value\");\n@@ -533,1 +582,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet byte\");\n+            assertEquals(success, true, \"success weakCompareAndSet byte\");\n+            byte x = (byte) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact((byte)0x23, (byte)0x45);\n+            assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -535,1 +591,1 @@\n-            assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+            assertEquals(x, (byte)0x01, \"failing weakCompareAndSetRe byte value\");\n@@ -784,1 +840,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain byte\");\n+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (byte)0x23, \"success weakCompareAndSetPlain byte value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, (byte)0x01, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain byte\");\n@@ -786,1 +849,1 @@\n-                assertEquals(x, (byte)0x23, \"weakCompareAndSetPlain byte value\");\n+                assertEquals(x, (byte)0x23, \"failing weakCompareAndSetPlain byte value\");\n@@ -794,1 +857,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire byte\");\n@@ -796,1 +859,8 @@\n-                assertEquals(x, (byte)0x01, \"weakCompareAndSetAcquire byte\");\n+                assertEquals(x, (byte)0x01, \"success weakCompareAndSetAcquire byte\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (byte)0x23, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (byte)0x01, \"failing weakCompareAndSetAcquire byte value\");\n@@ -804,1 +874,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease byte\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease byte\");\n+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (byte)0x23, \"success weakCompareAndSetRelease byte\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (byte)0x01, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire byte\");\n@@ -806,1 +883,1 @@\n-                assertEquals(x, (byte)0x23, \"weakCompareAndSetRelease byte\");\n+                assertEquals(x, (byte)0x23, \"failing weakCompareAndSetAcquire byte value\");\n@@ -814,1 +891,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet byte\");\n+                assertEquals(success, true, \"success weakCompareAndSet byte\");\n+                byte x = (byte) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (byte)0x01, \"success weakCompareAndSet byte\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, (byte)0x23, (byte)0x45);\n+                assertEquals(success, false, \"failing weakCompareAndSet byte\");\n@@ -816,1 +900,1 @@\n-                assertEquals(x, (byte)0x01, \"weakCompareAndSet byte\");\n+                assertEquals(x, (byte)0x01, \"failing weakCompareAndSet byte value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessByte.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n@@ -231,1 +231,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -239,1 +246,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -241,1 +255,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -249,1 +263,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, '\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n@@ -251,1 +272,1 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -259,1 +280,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n@@ -261,1 +282,8 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, '\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n@@ -503,1 +531,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact('\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n@@ -505,1 +540,1 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -513,1 +548,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact('\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -515,1 +557,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -523,1 +565,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n@@ -525,1 +567,8 @@\n-            assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+            assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact('\\u0123', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, '\\u4567', \"failing weakCompareAndSetRelease char value\");\n@@ -533,1 +582,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet char\");\n+            assertEquals(success, true, \"success weakCompareAndSet char\");\n+            char x = (char) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact('\\u4567', '\\u89AB');\n+            assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -535,1 +591,1 @@\n-            assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+            assertEquals(x, '\\u0123', \"failing weakCompareAndSetRe char value\");\n@@ -784,1 +840,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain char\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain char\");\n+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, '\\u4567', \"success weakCompareAndSetPlain char value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, '\\u0123', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain char\");\n@@ -786,1 +849,1 @@\n-                assertEquals(x, '\\u4567', \"weakCompareAndSetPlain char value\");\n+                assertEquals(x, '\\u4567', \"failing weakCompareAndSetPlain char value\");\n@@ -794,1 +857,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire char\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire char\");\n@@ -796,1 +859,8 @@\n-                assertEquals(x, '\\u0123', \"weakCompareAndSetAcquire char\");\n+                assertEquals(x, '\\u0123', \"success weakCompareAndSetAcquire char\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, '\\u4567', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, '\\u0123', \"failing weakCompareAndSetAcquire char value\");\n@@ -804,1 +874,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease char\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease char\");\n+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, '\\u4567', \"success weakCompareAndSetRelease char\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, '\\u0123', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire char\");\n@@ -806,1 +883,1 @@\n-                assertEquals(x, '\\u4567', \"weakCompareAndSetRelease char\");\n+                assertEquals(x, '\\u4567', \"failing weakCompareAndSetAcquire char value\");\n@@ -814,1 +891,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet char\");\n+                assertEquals(success, true, \"success weakCompareAndSet char\");\n+                char x = (char) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, '\\u0123', \"success weakCompareAndSet char\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, '\\u4567', '\\u89AB');\n+                assertEquals(success, false, \"failing weakCompareAndSet char\");\n@@ -816,1 +900,1 @@\n-                assertEquals(x, '\\u0123', \"weakCompareAndSet char\");\n+                assertEquals(x, '\\u0123', \"failing weakCompareAndSet char value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessChar.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n@@ -231,1 +231,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -239,1 +246,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -241,1 +255,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -249,1 +263,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n@@ -251,1 +272,1 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -259,1 +280,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n@@ -261,1 +282,8 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n@@ -430,1 +458,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n@@ -432,1 +467,1 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -440,1 +475,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -442,1 +484,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -450,1 +492,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n@@ -452,1 +494,8 @@\n-            assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+            assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(1.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 2.0d, \"failing weakCompareAndSetRelease double value\");\n@@ -460,1 +509,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet double\");\n+            assertEquals(success, true, \"success weakCompareAndSet double\");\n+            double x = (double) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(2.0d, 3.0d);\n+            assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -462,1 +518,1 @@\n-            assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+            assertEquals(x, 1.0d, \"failing weakCompareAndSetRe double value\");\n@@ -633,1 +689,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain double\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain double\");\n+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 2.0d, \"success weakCompareAndSetPlain double value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 1.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain double\");\n@@ -635,1 +698,1 @@\n-                assertEquals(x, 2.0d, \"weakCompareAndSetPlain double value\");\n+                assertEquals(x, 2.0d, \"failing weakCompareAndSetPlain double value\");\n@@ -643,1 +706,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire double\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire double\");\n@@ -645,1 +708,8 @@\n-                assertEquals(x, 1.0d, \"weakCompareAndSetAcquire double\");\n+                assertEquals(x, 1.0d, \"success weakCompareAndSetAcquire double\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 2.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 1.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -653,1 +723,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease double\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease double\");\n+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 2.0d, \"success weakCompareAndSetRelease double\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 1.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire double\");\n@@ -655,1 +732,1 @@\n-                assertEquals(x, 2.0d, \"weakCompareAndSetRelease double\");\n+                assertEquals(x, 2.0d, \"failing weakCompareAndSetAcquire double value\");\n@@ -663,1 +740,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet double\");\n+                assertEquals(success, true, \"success weakCompareAndSet double\");\n+                double x = (double) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 1.0d, \"success weakCompareAndSet double\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 2.0d, 3.0d);\n+                assertEquals(success, false, \"failing weakCompareAndSet double\");\n@@ -665,1 +749,1 @@\n-                assertEquals(x, 1.0d, \"weakCompareAndSet double\");\n+                assertEquals(x, 1.0d, \"failing weakCompareAndSet double value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessDouble.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n@@ -231,1 +231,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -239,1 +246,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -241,1 +255,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -249,1 +263,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n@@ -251,1 +272,1 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -259,1 +280,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n@@ -261,1 +282,8 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n@@ -430,1 +458,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n@@ -432,1 +467,1 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -440,1 +475,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -442,1 +484,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -450,1 +492,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n@@ -452,1 +494,8 @@\n-            assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+            assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(1.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 2.0f, \"failing weakCompareAndSetRelease float value\");\n@@ -460,1 +509,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet float\");\n+            assertEquals(success, true, \"success weakCompareAndSet float\");\n+            float x = (float) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(2.0f, 3.0f);\n+            assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -462,1 +518,1 @@\n-            assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+            assertEquals(x, 1.0f, \"failing weakCompareAndSetRe float value\");\n@@ -633,1 +689,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain float\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain float\");\n+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 2.0f, \"success weakCompareAndSetPlain float value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 1.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain float\");\n@@ -635,1 +698,1 @@\n-                assertEquals(x, 2.0f, \"weakCompareAndSetPlain float value\");\n+                assertEquals(x, 2.0f, \"failing weakCompareAndSetPlain float value\");\n@@ -643,1 +706,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire float\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire float\");\n@@ -645,1 +708,8 @@\n-                assertEquals(x, 1.0f, \"weakCompareAndSetAcquire float\");\n+                assertEquals(x, 1.0f, \"success weakCompareAndSetAcquire float\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 2.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 1.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -653,1 +723,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease float\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease float\");\n+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 2.0f, \"success weakCompareAndSetRelease float\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 1.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire float\");\n@@ -655,1 +732,1 @@\n-                assertEquals(x, 2.0f, \"weakCompareAndSetRelease float\");\n+                assertEquals(x, 2.0f, \"failing weakCompareAndSetAcquire float value\");\n@@ -663,1 +740,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet float\");\n+                assertEquals(success, true, \"success weakCompareAndSet float\");\n+                float x = (float) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 1.0f, \"success weakCompareAndSet float\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 2.0f, 3.0f);\n+                assertEquals(success, false, \"failing weakCompareAndSet float\");\n@@ -665,1 +749,1 @@\n-                assertEquals(x, 1.0f, \"weakCompareAndSet float\");\n+                assertEquals(x, 1.0f, \"failing weakCompareAndSet float value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessFloat.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n@@ -231,1 +231,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -239,1 +246,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -241,1 +255,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -249,1 +263,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n@@ -251,1 +272,1 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -259,1 +280,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n@@ -261,1 +282,8 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n@@ -503,1 +531,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n@@ -505,1 +540,1 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -513,1 +548,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -515,1 +557,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -523,1 +565,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n@@ -525,1 +567,8 @@\n-            assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+            assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(0x01234567, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetRelease int value\");\n@@ -533,1 +582,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet int\");\n+            assertEquals(success, true, \"success weakCompareAndSet int\");\n+            int x = (int) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(0x89ABCDEF, 0xCAFEBABE);\n+            assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -535,1 +591,1 @@\n-            assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+            assertEquals(x, 0x01234567, \"failing weakCompareAndSetRe int value\");\n@@ -784,1 +840,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain int\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain int\");\n+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetPlain int value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 0x01234567, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain int\");\n@@ -786,1 +849,1 @@\n-                assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetPlain int value\");\n+                assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetPlain int value\");\n@@ -794,1 +857,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire int\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire int\");\n@@ -796,1 +859,8 @@\n-                assertEquals(x, 0x01234567, \"weakCompareAndSetAcquire int\");\n+                assertEquals(x, 0x01234567, \"success weakCompareAndSetAcquire int\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x89ABCDEF, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x01234567, \"failing weakCompareAndSetAcquire int value\");\n@@ -804,1 +874,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease int\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease int\");\n+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x89ABCDEF, \"success weakCompareAndSetRelease int\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x01234567, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire int\");\n@@ -806,1 +883,1 @@\n-                assertEquals(x, 0x89ABCDEF, \"weakCompareAndSetRelease int\");\n+                assertEquals(x, 0x89ABCDEF, \"failing weakCompareAndSetAcquire int value\");\n@@ -814,1 +891,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet int\");\n+                assertEquals(success, true, \"success weakCompareAndSet int\");\n+                int x = (int) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x01234567, \"success weakCompareAndSet int\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 0x89ABCDEF, 0xCAFEBABE);\n+                assertEquals(success, false, \"failing weakCompareAndSet int\");\n@@ -816,1 +900,1 @@\n-                assertEquals(x, 0x01234567, \"weakCompareAndSet int\");\n+                assertEquals(x, 0x01234567, \"failing weakCompareAndSet int value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessInt.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n@@ -231,1 +231,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -239,1 +246,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -241,1 +255,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -249,1 +263,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n@@ -251,1 +272,1 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -259,1 +280,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n@@ -261,1 +282,8 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n@@ -503,1 +531,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n@@ -505,1 +540,1 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -513,1 +548,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -515,1 +557,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -523,1 +565,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n@@ -525,1 +567,8 @@\n-            assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetRelease long value\");\n@@ -533,1 +582,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet long\");\n+            assertEquals(success, true, \"success weakCompareAndSet long\");\n+            long x = (long) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+            assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -535,1 +591,1 @@\n-            assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+            assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetRe long value\");\n@@ -784,1 +840,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain long\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain long\");\n+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetPlain long value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain long\");\n@@ -786,1 +849,1 @@\n-                assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetPlain long value\");\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetPlain long value\");\n@@ -794,1 +857,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire long\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire long\");\n@@ -796,1 +859,8 @@\n-                assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSetAcquire long\");\n+                assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSetAcquire long\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSetAcquire long value\");\n@@ -804,1 +874,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease long\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease long\");\n+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"success weakCompareAndSetRelease long\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, 0x0123456789ABCDEFL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire long\");\n@@ -806,1 +883,1 @@\n-                assertEquals(x, 0xCAFEBABECAFEBABEL, \"weakCompareAndSetRelease long\");\n+                assertEquals(x, 0xCAFEBABECAFEBABEL, \"failing weakCompareAndSetAcquire long value\");\n@@ -814,1 +891,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet long\");\n+                assertEquals(success, true, \"success weakCompareAndSet long\");\n+                long x = (long) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, 0x0123456789ABCDEFL, \"success weakCompareAndSet long\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, 0xCAFEBABECAFEBABEL, 0xDEADBEEFDEADBEEFL);\n+                assertEquals(success, false, \"failing weakCompareAndSet long\");\n@@ -816,1 +900,1 @@\n-                assertEquals(x, 0x0123456789ABCDEFL, \"weakCompareAndSet long\");\n+                assertEquals(x, 0x0123456789ABCDEFL, \"failing weakCompareAndSet long value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessLong.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n@@ -231,1 +231,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -239,1 +246,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -241,1 +255,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -249,1 +263,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, (short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n@@ -251,1 +272,1 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -259,1 +280,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n@@ -261,1 +282,8 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, (short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n@@ -503,1 +531,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact((short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n@@ -505,1 +540,1 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -513,1 +548,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact((short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -515,1 +557,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -523,1 +565,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n@@ -525,1 +567,8 @@\n-            assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+            assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact((short)0x0123, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (short)0x4567, \"failing weakCompareAndSetRelease short value\");\n@@ -533,1 +582,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet short\");\n+            assertEquals(success, true, \"success weakCompareAndSet short\");\n+            short x = (short) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact((short)0x4567, (short)0x89AB);\n+            assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -535,1 +591,1 @@\n-            assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+            assertEquals(x, (short)0x0123, \"failing weakCompareAndSetRe short value\");\n@@ -784,1 +840,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain short\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain short\");\n+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (short)0x4567, \"success weakCompareAndSetPlain short value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, (short)0x0123, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain short\");\n@@ -786,1 +849,1 @@\n-                assertEquals(x, (short)0x4567, \"weakCompareAndSetPlain short value\");\n+                assertEquals(x, (short)0x4567, \"failing weakCompareAndSetPlain short value\");\n@@ -794,1 +857,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire short\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire short\");\n@@ -796,1 +859,8 @@\n-                assertEquals(x, (short)0x0123, \"weakCompareAndSetAcquire short\");\n+                assertEquals(x, (short)0x0123, \"success weakCompareAndSetAcquire short\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (short)0x4567, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (short)0x0123, \"failing weakCompareAndSetAcquire short value\");\n@@ -804,1 +874,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease short\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease short\");\n+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (short)0x4567, \"success weakCompareAndSetRelease short\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, (short)0x0123, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire short\");\n@@ -806,1 +883,1 @@\n-                assertEquals(x, (short)0x4567, \"weakCompareAndSetRelease short\");\n+                assertEquals(x, (short)0x4567, \"failing weakCompareAndSetAcquire short value\");\n@@ -814,1 +891,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet short\");\n+                assertEquals(success, true, \"success weakCompareAndSet short\");\n+                short x = (short) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, (short)0x0123, \"success weakCompareAndSet short\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, (short)0x4567, (short)0x89AB);\n+                assertEquals(success, false, \"failing weakCompareAndSet short\");\n@@ -816,1 +900,1 @@\n-                assertEquals(x, (short)0x0123, \"weakCompareAndSet short\");\n+                assertEquals(x, (short)0x0123, \"failing weakCompareAndSet short value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessShort.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,1 +221,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n@@ -223,1 +223,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -231,1 +238,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -233,1 +247,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -241,1 +255,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, \"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n@@ -243,1 +264,1 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -251,1 +272,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet String\");\n+            assertEquals(success, true, \"success weakCompareAndSet String\");\n@@ -253,1 +274,8 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, \"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n@@ -377,1 +405,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(\"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n@@ -379,1 +414,1 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -387,1 +422,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(\"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -389,1 +431,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -397,1 +439,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n@@ -399,1 +441,8 @@\n-            assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+            assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(\"foo\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, \"bar\", \"failing weakCompareAndSetRelease String value\");\n@@ -407,1 +456,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet String\");\n+            assertEquals(success, true, \"success weakCompareAndSet String\");\n+            String x = (String) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(\"bar\", \"baz\");\n+            assertEquals(success, false, \"failing weakCompareAndSet String\");\n@@ -409,1 +465,1 @@\n-            assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+            assertEquals(x, \"foo\", \"failing weakCompareAndSetRe String value\");\n@@ -558,1 +614,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain String\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain String\");\n+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, \"bar\", \"success weakCompareAndSetPlain String value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, \"foo\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain String\");\n@@ -560,1 +623,1 @@\n-                assertEquals(x, \"bar\", \"weakCompareAndSetPlain String value\");\n+                assertEquals(x, \"bar\", \"failing weakCompareAndSetPlain String value\");\n@@ -568,1 +631,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire String\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire String\");\n@@ -570,1 +633,8 @@\n-                assertEquals(x, \"foo\", \"weakCompareAndSetAcquire String\");\n+                assertEquals(x, \"foo\", \"success weakCompareAndSetAcquire String\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, \"bar\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, \"foo\", \"failing weakCompareAndSetAcquire String value\");\n@@ -578,1 +648,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease String\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease String\");\n+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, \"bar\", \"success weakCompareAndSetRelease String\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, \"foo\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire String\");\n@@ -580,1 +657,1 @@\n-                assertEquals(x, \"bar\", \"weakCompareAndSetRelease String\");\n+                assertEquals(x, \"bar\", \"failing weakCompareAndSetAcquire String value\");\n@@ -588,1 +665,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet String\");\n+                assertEquals(success, true, \"success weakCompareAndSet String\");\n+                String x = (String) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, \"foo\", \"success weakCompareAndSet String\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, \"bar\", \"baz\");\n+                assertEquals(success, false, \"failing weakCompareAndSet String\");\n@@ -590,1 +674,1 @@\n-                assertEquals(x, \"foo\", \"weakCompareAndSet String\");\n+                assertEquals(x, \"foo\", \"failing weakCompareAndSet String value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessString.java","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -767,1 +767,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n@@ -769,1 +769,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain(recv, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n+            $type$ x = ($type$) vh.get(recv);\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -777,1 +784,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = ($type$) vh.get(recv);\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire(recv, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -779,1 +793,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -787,1 +801,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n+            $type$ x = ($type$) vh.get(recv);\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease(recv, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n@@ -789,1 +810,1 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -797,1 +818,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n@@ -799,1 +820,8 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$ value\");\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$ value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet(recv, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n+            $type$ x = ($type$) vh.get(recv);\n+            assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n@@ -1144,1 +1172,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n+            $type$ x = ($type$) vh.get();\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetPlain($value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n@@ -1146,1 +1181,1 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -1154,1 +1189,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = ($type$) vh.get();\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetAcquire($value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -1156,1 +1198,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -1164,1 +1206,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n@@ -1166,1 +1208,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSetRelease($value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n+            $type$ x = ($type$) vh.get();\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -1174,1 +1223,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+            $type$ x = ($type$) vh.get();\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+        }\n+\n+        {\n+            boolean success = vh.weakCompareAndSet($value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -1176,1 +1232,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n@@ -1524,1 +1580,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n+                $type$ x = ($type$) vh.get(array, i);\n+                assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetPlain(array, i, $value1$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n@@ -1526,1 +1589,1 @@\n-                assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+                assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -1534,1 +1597,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n@@ -1536,1 +1599,8 @@\n-                assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+                assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetAcquire(array, i, $value2$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n+                $type$ x = ($type$) vh.get(array, i);\n+                assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -1544,1 +1614,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n+                $type$ x = ($type$) vh.get(array, i);\n+                assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSetRelease(array, i, $value1$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n@@ -1546,1 +1623,1 @@\n-                assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+                assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -1554,1 +1631,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+                $type$ x = ($type$) vh.get(array, i);\n+                assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+            }\n+\n+            {\n+                boolean success = vh.weakCompareAndSet(array, i, $value2$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -1556,1 +1640,1 @@\n-                assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+                assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestAccess.java.template","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,1 +240,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n@@ -242,1 +242,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(recv, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -250,1 +257,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(recv, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -252,1 +266,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -260,1 +274,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact(recv, $value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n@@ -262,1 +283,1 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -270,1 +291,1 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n@@ -272,1 +293,8 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(recv, $value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(recv);\n+            assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n@@ -588,1 +616,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact($value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n@@ -590,1 +625,1 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -598,1 +633,8 @@\n-            assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact($value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -600,1 +642,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -608,1 +650,1 @@\n-            assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n@@ -610,1 +652,8 @@\n-            assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+            assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_RELEASE).invokeExact($value1$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSetRelease $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, $value2$, \"failing weakCompareAndSetRelease $type$ value\");\n@@ -618,1 +667,8 @@\n-            assertEquals(success, true, \"weakCompareAndSet $type$\");\n+            assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+            $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact();\n+            assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+        }\n+\n+        {\n+            boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact($value2$, $value3$);\n+            assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -620,1 +676,1 @@\n-            assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+            assertEquals(x, $value1$, \"failing weakCompareAndSetRe $type$ value\");\n@@ -908,1 +964,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetPlain $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetPlain $type$\");\n+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, $value2$, \"success weakCompareAndSetPlain $type$ value\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_PLAIN).invokeExact(array, i, $value1$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetPlain $type$\");\n@@ -910,1 +973,1 @@\n-                assertEquals(x, $value2$, \"weakCompareAndSetPlain $type$ value\");\n+                assertEquals(x, $value2$, \"failing weakCompareAndSetPlain $type$ value\");\n@@ -918,1 +981,1 @@\n-                assertEquals(success, true, \"weakCompareAndSetAcquire $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetAcquire $type$\");\n@@ -920,1 +983,8 @@\n-                assertEquals(x, $value1$, \"weakCompareAndSetAcquire $type$\");\n+                assertEquals(x, $value1$, \"success weakCompareAndSetAcquire $type$\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, $value2$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, $value1$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -928,1 +998,8 @@\n-                assertEquals(success, true, \"weakCompareAndSetRelease $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSetRelease $type$\");\n+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, $value2$, \"success weakCompareAndSetRelease $type$\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET_ACQUIRE).invokeExact(array, i, $value1$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSetAcquire $type$\");\n@@ -930,1 +1007,1 @@\n-                assertEquals(x, $value2$, \"weakCompareAndSetRelease $type$\");\n+                assertEquals(x, $value2$, \"failing weakCompareAndSetAcquire $type$ value\");\n@@ -938,1 +1015,8 @@\n-                assertEquals(success, true, \"weakCompareAndSet $type$\");\n+                assertEquals(success, true, \"success weakCompareAndSet $type$\");\n+                $type$ x = ($type$) hs.get(TestAccessMode.GET).invokeExact(array, i);\n+                assertEquals(x, $value1$, \"success weakCompareAndSet $type$\");\n+            }\n+\n+            {\n+                boolean success = (boolean) hs.get(TestAccessMode.WEAK_COMPARE_AND_SET).invokeExact(array, i, $value2$, $value3$);\n+                assertEquals(success, false, \"failing weakCompareAndSet $type$\");\n@@ -940,1 +1024,1 @@\n-                assertEquals(x, $value1$, \"weakCompareAndSet $type$\");\n+                assertEquals(x, $value1$, \"failing weakCompareAndSet $type$ value\");\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/X-VarHandleTestMethodHandleAccess.java.template","additions":109,"deletions":25,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8250629 8252307 8247352 8241151 8246774 8259025 8288130 8282714\n+ * @bug 8250629 8252307 8247352 8241151 8246774 8259025 8288130 8282714 8289647\n@@ -1367,0 +1367,41 @@\n+    public void testMultipleAnnosInRecord() throws Exception {\n+        String[] previousOptions = getCompileOptions();\n+\n+        try {\n+            String imports = \"\"\"\n+                    import java.lang.annotation.ElementType;\n+                    import java.lang.annotation.Target;\n+                    \"\"\";\n+\n+            String annotTemplate =\n+                    \"\"\"\n+                    @Target(ElementType.#TARGET)\n+                    @interface anno#TARGET { }\n+                    \"\"\";\n+\n+            String recordTemplate =\n+                    \"\"\"\n+                    record R(#TARGETS String s) {}\n+                    \"\"\";\n+\n+            String[] generalOptions = {\n+                    \"-processor\", Processor.class.getName(),\n+            };\n+\n+            List<String> targets = List.of(\"FIELD\", \"RECORD_COMPONENT\", \"PARAMETER\", \"METHOD\");\n+\n+            var interfaces = targets.stream().map(t -> annotTemplate.replaceAll(\"#TARGET\", t)).collect(Collectors.joining(\"\\n\"));\n+            var recordAnnotations = targets.stream().map(t -> \"@anno\" + t).collect(Collectors.joining(\" \"));\n+            String record = recordTemplate.replaceFirst(\"#TARGETS\", recordAnnotations);\n+            String code = String.format(\"%s\\n%s\\n%s\\n\",imports,interfaces,record);\n+            String[] testOptions = generalOptions.clone();\n+            setCompileOptions(testOptions);\n+\n+            assertOK(true, code);\n+\n+        \/\/ let's reset the default compiler options for other tests\n+        } finally {\n+            setCompileOptions(previousOptions);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -418,1 +418,0 @@\n-  public native void    forceNMethodSweep();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}