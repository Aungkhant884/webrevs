{"files":[{"patch":"@@ -138,1 +138,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::load_flattened_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::load_flat_array_id)));\n@@ -165,1 +165,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::store_flattened_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::store_flat_array_id)));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1581,1 +1581,1 @@\n-  \/\/ We are loading\/storing from\/to an array that *may* be flattened (the\n+  \/\/ We are loading\/storing from\/to an array that *may* be a flat array (the\n@@ -1583,1 +1583,1 @@\n-  \/\/ If this array is flattened, take the slow path.\n+  \/\/ If this array is a flat array, take the slow path.\n@@ -1587,1 +1587,1 @@\n-    __ test_flattened_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n+    __ test_flat_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n@@ -1595,1 +1595,1 @@\n-    \/\/ The array is not flattened, but it might be null-free. If we are storing\n+    \/\/ The array is not a flat array, but it might be null-free. If we are storing\n@@ -2409,1 +2409,1 @@\n-      __ test_flattened_array_oop(obj, tmp, *slow_path->entry());\n+      __ test_flat_array_oop(obj, tmp, *slow_path->entry());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -747,1 +747,1 @@\n-            __ cmpw(t0, Klass::_lh_array_tag_vt_value);  \/\/ the array can be flattened.\n+            __ cmpw(t0, Klass::_lh_array_tag_vt_value);  \/\/ the array can be a flat array.\n@@ -749,1 +749,1 @@\n-            __ cmpw(t0, Klass::_lh_array_tag_obj_value); \/\/ the array cannot be flattened (due to InlineArrayElementMaxFlatSize, etc)\n+            __ cmpw(t0, Klass::_lh_array_tag_obj_value); \/\/ the array cannot be a flat array (due to InlineArrayElementMaxFlatSize, etc)\n@@ -829,1 +829,1 @@\n-    case load_flattened_array_id:\n+    case load_flat_array_id:\n@@ -831,1 +831,1 @@\n-        StubFrame f(sasm, \"load_flattened_array\", dont_gc_arguments);\n+        StubFrame f(sasm, \"load_flat_array\", dont_gc_arguments);\n@@ -838,1 +838,1 @@\n-        int call_offset = __ call_RT(r0, noreg, CAST_FROM_FN_PTR(address, load_flattened_array), r0, r1);\n+        int call_offset = __ call_RT(r0, noreg, CAST_FROM_FN_PTR(address, load_flat_array), r0, r1);\n@@ -849,1 +849,1 @@\n-    case store_flattened_array_id:\n+    case store_flat_array_id:\n@@ -851,1 +851,1 @@\n-        StubFrame f(sasm, \"store_flattened_array\", dont_gc_arguments);\n+        StubFrame f(sasm, \"store_flat_array\", dont_gc_arguments);\n@@ -859,1 +859,1 @@\n-        int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, store_flattened_array), r0, r1, r2);\n+        int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, store_flat_array), r0, r1, r2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -288,3 +288,3 @@\n-void InterpreterMacroAssembler::read_inlined_field(Register holder_klass,\n-                                                   Register field_index, Register field_offset,\n-                                                   Register temp, Register obj) {\n+void InterpreterMacroAssembler::read_flat_field(Register holder_klass,\n+                                                Register field_index, Register field_offset,\n+                                                Register temp, Register obj) {\n@@ -328,1 +328,1 @@\n-  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_inlined_field),\n+  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flat_field),\n@@ -1645,1 +1645,1 @@\n-    test_non_flattened_array_oop(array, tmp, not_flat);\n+    test_non_flat_array_oop(array, tmp, not_flat);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -157,3 +157,3 @@\n-  void read_inlined_field(Register holder_klass,\n-                          Register field_index, Register field_offset,\n-                          Register temp,  Register obj = r0);\n+  void read_flat_field(Register holder_klass,\n+                       Register field_index, Register field_offset,\n+                       Register temp,  Register obj = r0);\n@@ -161,1 +161,1 @@\n-  \/\/ Allocate value buffer in \"obj\" and read in flattened element at the given index\n+  \/\/ Allocate value buffer in \"obj\" and read in flat element at the given index\n@@ -165,3 +165,3 @@\n-  void read_flattened_element(Register array, Register index,\n-                              Register t1, Register t2,\n-                              Register obj = r0);\n+  void read_flat_element(Register array, Register index,\n+                         Register t1, Register t2,\n+                         Register obj = r0);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1748,1 +1748,1 @@\n-void MacroAssembler::test_field_is_inlined(Register flags, Register temp_reg, Label& is_flattened) {\n+void MacroAssembler::test_field_is_flat(Register flags, Register temp_reg, Label& is_flat) {\n@@ -1750,1 +1750,1 @@\n-  tbnz(flags, ConstantPoolCacheEntry::is_inlined_shift, is_flattened);\n+  tbnz(flags, ConstantPoolCacheEntry::is_flat_shift, is_flat);\n@@ -1772,2 +1772,2 @@\n-void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg, Label& is_flattened_array) {\n-  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, true, is_flattened_array);\n+void MacroAssembler::test_flat_array_oop(Register oop, Register temp_reg, Label& is_flat_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, true, is_flat_array);\n@@ -1776,3 +1776,3 @@\n-void MacroAssembler::test_non_flattened_array_oop(Register oop, Register temp_reg,\n-                                                  Label&is_non_flattened_array) {\n-  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, false, is_non_flattened_array);\n+void MacroAssembler::test_non_flat_array_oop(Register oop, Register temp_reg,\n+                                                  Label&is_non_flat_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, false, is_non_flat_array);\n@@ -1789,1 +1789,1 @@\n-void MacroAssembler::test_flattened_array_layout(Register lh, Label& is_flattened_array) {\n+void MacroAssembler::test_flat_array_layout(Register lh, Label& is_flat_array) {\n@@ -1791,1 +1791,1 @@\n-  br(Assembler::NE, is_flattened_array);\n+  br(Assembler::NE, is_flat_array);\n@@ -1794,1 +1794,1 @@\n-void MacroAssembler::test_non_flattened_array_layout(Register lh, Label& is_non_flattened_array) {\n+void MacroAssembler::test_non_flat_array_layout(Register lh, Label& is_non_flat_array) {\n@@ -1796,1 +1796,1 @@\n-  br(Assembler::EQ, is_non_flattened_array);\n+  br(Assembler::EQ, is_non_flat_array);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -638,1 +638,1 @@\n-  void test_field_is_inlined(Register flags, Register temp_reg, Label& is_flattened);\n+  void test_field_is_flat(Register flags, Register temp_reg, Label& is_flat);\n@@ -640,1 +640,1 @@\n-  \/\/ Check oops for special arrays, i.e. flattened and\/or null-free\n+  \/\/ Check oops for special arrays, i.e. flat arrays and\/or null-free arrays\n@@ -642,2 +642,2 @@\n-  void test_flattened_array_oop(Register klass, Register temp_reg, Label& is_flattened_array);\n-  void test_non_flattened_array_oop(Register oop, Register temp_reg, Label&is_non_flattened_array);\n+  void test_flat_array_oop(Register klass, Register temp_reg, Label& is_flat_array);\n+  void test_non_flat_array_oop(Register oop, Register temp_reg, Label&is_non_flat_array);\n@@ -647,3 +647,3 @@\n-  \/\/ Check array klass layout helper for flatten or null-free arrays...\n-  void test_flattened_array_layout(Register lh, Label& is_flattened_array);\n-  void test_non_flattened_array_layout(Register lh, Label& is_non_flattened_array);\n+  \/\/ Check array klass layout helper for flat or null-free arrays...\n+  void test_flat_array_layout(Register lh, Label& is_flat_array);\n+  void test_non_flat_array_layout(Register lh, Label& is_non_flat_array);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -816,1 +816,1 @@\n-    __ test_flattened_array_oop(r0, r8 \/*temp*\/, is_flat_array);\n+    __ test_flat_array_oop(r0, r8 \/*temp*\/, is_flat_array);\n@@ -1139,1 +1139,1 @@\n-    __ test_flattened_array_layout(r6, is_flat_array);\n+    __ test_flat_array_layout(r6, is_flat_array);\n@@ -2704,1 +2704,1 @@\n-      Label is_inlined, nonnull, is_inline_type, rewrite_inline;\n+      Label is_flat, nonnull, is_inline_type, rewrite_inline;\n@@ -2714,2 +2714,2 @@\n-        __ test_field_is_inlined(raw_flags, noreg \/* temp *\/, is_inlined);\n-         \/\/ field is not inlined\n+        __ test_field_is_flat(raw_flags, noreg \/* temp *\/, is_flat);\n+         \/\/ field is not flat\n@@ -2725,2 +2725,2 @@\n-        __ bind(is_inlined);\n-        \/\/ field is inlined\n+        __ bind(is_flat);\n+        \/\/ field is flat\n@@ -2729,1 +2729,1 @@\n-          __ read_inlined_field(klass, raw_flags, off, inline_klass \/* temp *\/, r0);\n+          __ read_flat_field(klass, raw_flags, off, inline_klass \/* temp *\/, r0);\n@@ -2995,1 +2995,1 @@\n-        Label is_inline_type, is_inlined, rewrite_not_inline, rewrite_inline;\n+        Label is_inline_type, is_flat, rewrite_not_inline, rewrite_inline;\n@@ -3009,2 +3009,2 @@\n-        __ test_field_is_inlined(flags2, noreg \/*temp*\/, is_inlined);\n-        \/\/ field is not inlined\n+        __ test_field_is_flat(flags2, noreg \/*temp*\/, is_flat);\n+        \/\/ field is not flat\n@@ -3015,2 +3015,2 @@\n-        __ bind(is_inlined);\n-        \/\/ field is inlined\n+        __ bind(is_flat);\n+        \/\/ field is flat\n@@ -3252,1 +3252,1 @@\n-      Label is_inlined, done;\n+      Label is_flat, done;\n@@ -3254,2 +3254,2 @@\n-      __ test_field_is_inlined(r3, noreg \/* temp *\/, is_inlined);\n-      \/\/ field is not inlined\n+      __ test_field_is_flat(r3, noreg \/* temp *\/, is_flat);\n+      \/\/ field is not flat\n@@ -3258,2 +3258,2 @@\n-      __ bind(is_inlined);\n-      \/\/ field is inlined\n+      __ bind(is_flat);\n+      \/\/ field is flat\n@@ -3367,3 +3367,3 @@\n-      Label is_inlined, nonnull, Done;\n-      __ test_field_is_inlined(r3, noreg \/* temp *\/, is_inlined);\n-        \/\/ field is not inlined\n+      Label is_flat, nonnull, Done;\n+      __ test_field_is_flat(r3, noreg \/* temp *\/, is_flat);\n+        \/\/ field is not flat\n@@ -3380,2 +3380,2 @@\n-      __ bind(is_inlined);\n-      \/\/ field is inlined\n+      __ bind(is_flat);\n+      \/\/ field is flat\n@@ -3385,1 +3385,1 @@\n-        __ read_inlined_field(klass, index, r1, tmp \/* temp *\/, r0);\n+        __ read_flat_field(klass, index, r1, tmp \/* temp *\/, r0);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::load_flattened_array_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::load_flat_array_id)));\n@@ -218,1 +218,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::store_flattened_array_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::store_flat_array_id)));\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1986,1 +1986,1 @@\n-  \/\/ We are loading\/storing from\/to an array that *may* be flattened (the\n+  \/\/ We are loading\/storing from\/to an array that *may* be a flat array (the\n@@ -1988,1 +1988,1 @@\n-  \/\/ If this array is flattened, take the slow path.\n+  \/\/ If this array is a flat array, take the slow path.\n@@ -1991,1 +1991,1 @@\n-    __ test_flattened_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n+    __ test_flat_array_oop(op->array()->as_register(), op->tmp()->as_register(), *op->stub()->entry());\n@@ -2000,1 +2000,1 @@\n-    \/\/ The array is not flattened, but it might be null-free. If we are storing\n+    \/\/ The array is not a flat array, but it might be null-free. If we are storing\n@@ -3253,1 +3253,1 @@\n-      __ test_flattened_array_oop(obj, tmp, *slow_path->entry());\n+      __ test_flat_array_oop(obj, tmp, *slow_path->entry());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1116,1 +1116,1 @@\n-            __ cmpl(t0, Klass::_lh_array_tag_vt_value);  \/\/ the array can be flattened.\n+            __ cmpl(t0, Klass::_lh_array_tag_vt_value);  \/\/ the array can be a flat array.\n@@ -1118,1 +1118,1 @@\n-            __ cmpl(t0, Klass::_lh_array_tag_obj_value); \/\/ the array cannot be flattened (due to InlineArrayElementMaxFlatSize, etc)\n+            __ cmpl(t0, Klass::_lh_array_tag_obj_value); \/\/ the array cannot be a flat array (due to InlineArrayElementMaxFlatSize, etc)\n@@ -1170,1 +1170,1 @@\n-    case load_flattened_array_id:\n+    case load_flat_array_id:\n@@ -1172,1 +1172,1 @@\n-        StubFrame f(sasm, \"load_flattened_array\", dont_gc_arguments);\n+        StubFrame f(sasm, \"load_flat_array\", dont_gc_arguments);\n@@ -1179,1 +1179,1 @@\n-        int call_offset = __ call_RT(rax, noreg, CAST_FROM_FN_PTR(address, load_flattened_array), rax, rbx);\n+        int call_offset = __ call_RT(rax, noreg, CAST_FROM_FN_PTR(address, load_flat_array), rax, rbx);\n@@ -1190,1 +1190,1 @@\n-    case store_flattened_array_id:\n+    case store_flat_array_id:\n@@ -1192,1 +1192,1 @@\n-        StubFrame f(sasm, \"store_flattened_array\", dont_gc_arguments);\n+        StubFrame f(sasm, \"store_flat_array\", dont_gc_arguments);\n@@ -1200,1 +1200,1 @@\n-        int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, store_flattened_array), rax, rbx, rcx);\n+        int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, store_flat_array), rax, rbx, rcx);\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-    case T_PRIMITIVE_OBJECT:\n+    case T_PRIMITIVE_OBJECT: \/\/ fall through\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1249,3 +1249,3 @@\n-void InterpreterMacroAssembler::read_inlined_field(Register holder_klass,\n-                                                     Register field_index, Register field_offset,\n-                                                     Register obj) {\n+void InterpreterMacroAssembler::read_flat_field(Register holder_klass,\n+                                                Register field_index, Register field_offset,\n+                                                Register obj) {\n@@ -1289,1 +1289,1 @@\n-  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_inlined_field),\n+  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flat_field),\n@@ -1295,3 +1295,3 @@\n-void InterpreterMacroAssembler::read_flattened_element(Register array, Register index,\n-                                                       Register t1, Register t2,\n-                                                       Register obj) {\n+void InterpreterMacroAssembler::read_flat_element(Register array, Register index,\n+                                                  Register t1, Register t2,\n+                                                  Register obj) {\n@@ -2172,1 +2172,1 @@\n-    test_non_flattened_array_oop(array, tmp, not_flat);\n+    test_non_flat_array_oop(array, tmp, not_flat);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -243,3 +243,3 @@\n-  void read_inlined_field(Register holder_klass,\n-                            Register field_index, Register field_offset,\n-                            Register obj = rax);\n+  void read_flat_field(Register holder_klass,\n+                       Register field_index, Register field_offset,\n+                       Register obj = rax);\n@@ -247,1 +247,1 @@\n-  \/\/ Allocate value buffer in \"obj\" and read in flattened element at the given index\n+  \/\/ Allocate value buffer in \"obj\" and read in flat element at the given index\n@@ -252,3 +252,3 @@\n-  void read_flattened_element(Register array, Register index,\n-                              Register t1, Register t2,\n-                              Register obj = rax);\n+  void read_flat_element(Register array, Register index,\n+                         Register t1, Register t2,\n+                         Register obj = rax);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2918,1 +2918,1 @@\n-void MacroAssembler::test_field_is_inlined(Register flags, Register temp_reg, Label& is_inlined) {\n+void MacroAssembler::test_field_is_flat(Register flags, Register temp_reg, Label& is_flat) {\n@@ -2920,1 +2920,1 @@\n-  shrl(temp_reg, ConstantPoolCacheEntry::is_inlined_shift);\n+  shrl(temp_reg, ConstantPoolCacheEntry::is_flat_shift);\n@@ -2923,1 +2923,1 @@\n-  jcc(Assembler::notZero, is_inlined);\n+  jcc(Assembler::notZero, is_flat);\n@@ -2943,2 +2943,2 @@\n-void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg,\n-                                              Label&is_flattened_array) {\n+void MacroAssembler::test_flat_array_oop(Register oop, Register temp_reg,\n+                                         Label& is_flat_array) {\n@@ -2946,1 +2946,1 @@\n-  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, true, is_flattened_array);\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, true, is_flat_array);\n@@ -2950,1 +2950,1 @@\n-  test_flattened_array_layout(temp_reg, is_flattened_array);\n+  test_flat_array_layout(temp_reg, is_flat_array);\n@@ -2954,2 +2954,2 @@\n-void MacroAssembler::test_non_flattened_array_oop(Register oop, Register temp_reg,\n-                                                  Label&is_non_flattened_array) {\n+void MacroAssembler::test_non_flat_array_oop(Register oop, Register temp_reg,\n+                                             Label& is_non_flat_array) {\n@@ -2957,1 +2957,1 @@\n-  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, false, is_non_flattened_array);\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, false, is_non_flat_array);\n@@ -2961,1 +2961,1 @@\n-  test_non_flattened_array_layout(temp_reg, is_non_flattened_array);\n+  test_non_flat_array_layout(temp_reg, is_non_flat_array);\n@@ -2985,1 +2985,1 @@\n-void MacroAssembler::test_flattened_array_layout(Register lh, Label& is_flattened_array) {\n+void MacroAssembler::test_flat_array_layout(Register lh, Label& is_flat_array) {\n@@ -2987,1 +2987,1 @@\n-  jcc(Assembler::notZero, is_flattened_array);\n+  jcc(Assembler::notZero, is_flat_array);\n@@ -2990,1 +2990,1 @@\n-void MacroAssembler::test_non_flattened_array_layout(Register lh, Label& is_non_flattened_array) {\n+void MacroAssembler::test_non_flat_array_layout(Register lh, Label& is_non_flat_array) {\n@@ -2992,1 +2992,1 @@\n-  jcc(Assembler::zero, is_non_flattened_array);\n+  jcc(Assembler::zero, is_non_flat_array);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  void test_field_is_inlined(Register flags, Register temp_reg, Label& is_inlined);\n+  void test_field_is_flat(Register flags, Register temp_reg, Label& is_flat);\n@@ -126,1 +126,1 @@\n-  \/\/ Check oops for special arrays, i.e. flattened and\/or null-free\n+  \/\/ Check oops for special arrays, i.e. flat arrays and\/or null-free arrays\n@@ -128,4 +128,4 @@\n-  void test_flattened_array_oop(Register oop, Register temp_reg, Label&is_flattened_array);\n-  void test_non_flattened_array_oop(Register oop, Register temp_reg, Label&is_non_flattened_array);\n-  void test_null_free_array_oop(Register oop, Register temp_reg, Label&is_null_free_array);\n-  void test_non_null_free_array_oop(Register oop, Register temp_reg, Label&is_non_null_free_array);\n+  void test_flat_array_oop(Register oop, Register temp_reg, Label& is_flat_array);\n+  void test_non_flat_array_oop(Register oop, Register temp_reg, Label& is_non_flat_array);\n+  void test_null_free_array_oop(Register oop, Register temp_reg, Label& is_null_free_array);\n+  void test_non_null_free_array_oop(Register oop, Register temp_reg, Label& is_non_null_free_array);\n@@ -134,2 +134,2 @@\n-  void test_flattened_array_layout(Register lh, Label& is_flattened_array);\n-  void test_non_flattened_array_layout(Register lh, Label& is_non_flattened_array);\n+  void test_flat_array_layout(Register lh, Label& is_flat_array);\n+  void test_non_flat_array_layout(Register lh, Label& is_non_flat_array);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -834,1 +834,1 @@\n-    __ test_flattened_array_oop(array, rbx, is_flat_array);\n+    __ test_flat_array_oop(array, rbx, is_flat_array);\n@@ -843,1 +843,1 @@\n-    __ read_flattened_element(array, index, rbx, rcx, rax);\n+    __ read_flat_element(array, index, rbx, rcx, rax);\n@@ -1162,1 +1162,1 @@\n-    __ test_flattened_array_layout(rbx, is_flat_array);\n+    __ test_flat_array_layout(rbx, is_flat_array);\n@@ -3095,1 +3095,1 @@\n-      Label is_inlined, nonnull, is_inline_type, rewrite_inline;\n+      Label is_flat, nonnull, is_inline_type, rewrite_inline;\n@@ -3106,2 +3106,2 @@\n-        __ test_field_is_inlined(flags2, rscratch1, is_inlined);\n-          \/\/ field is not inlined\n+        __ test_field_is_flat(flags2, rscratch1, is_flat);\n+          \/\/ field is not flat\n@@ -3122,2 +3122,2 @@\n-        __ bind(is_inlined);\n-        \/\/ field is inlined\n+        __ bind(is_flat);\n+        \/\/ field is flat\n@@ -3126,1 +3126,1 @@\n-          __ read_inlined_field(rcx, flags2, rbx, rax);\n+          __ read_flat_field(rcx, flags2, rbx, rax);\n@@ -3458,1 +3458,1 @@\n-        Label is_inline_type, is_inlined, rewrite_not_inline, rewrite_inline;\n+        Label is_inline_type, is_flat, rewrite_not_inline, rewrite_inline;\n@@ -3472,2 +3472,2 @@\n-        __ test_field_is_inlined(flags2, rscratch1, is_inlined);\n-        \/\/ field is not inlined\n+        __ test_field_is_flat(flags2, rscratch1, is_flat);\n+        \/\/ field is not flat\n@@ -3478,2 +3478,2 @@\n-        __ bind(is_inlined);\n-        \/\/ field is inlined\n+        __ bind(is_flat);\n+        \/\/ field is flat\n@@ -3698,1 +3698,1 @@\n-    __ movl(rscratch2, rdx);  \/\/ saving flags for is_inlined test\n+    __ movl(rscratch2, rdx);  \/\/ saving flags for is_flat test\n@@ -3715,1 +3715,1 @@\n-    __ movl(rdx, rscratch2);  \/\/ restoring flags for is_inlined test\n+    __ movl(rdx, rscratch2);  \/\/ restoring flags for is_flat test\n@@ -3724,1 +3724,1 @@\n-    __ movl(rdx, rscratch2);  \/\/ restoring flags for is_inlined test\n+    __ movl(rdx, rscratch2);  \/\/ restoring flags for is_flat test\n@@ -3737,1 +3737,1 @@\n-      Label is_inlined, done;\n+      Label is_flat, done;\n@@ -3739,2 +3739,2 @@\n-      __ test_field_is_inlined(flags, rscratch1, is_inlined);\n-      \/\/ field is not inlined\n+      __ test_field_is_flat(flags, rscratch1, is_flat);\n+      \/\/ field is not flat\n@@ -3743,2 +3743,2 @@\n-      __ bind(is_inlined);\n-      \/\/ field is inlined\n+      __ bind(is_flat);\n+      \/\/ field is flat\n@@ -3838,1 +3838,1 @@\n-      Label is_inlined, nonnull, Done;\n+      Label is_flat, nonnull, Done;\n@@ -3842,2 +3842,2 @@\n-      __ test_field_is_inlined(rscratch1, rscratch2, is_inlined);\n-        \/\/ field is not inlined\n+      __ test_field_is_flat(rscratch1, rscratch2, is_flat);\n+        \/\/ field is not flat\n@@ -3859,2 +3859,2 @@\n-      __ bind(is_inlined);\n-      \/\/ field is inlined\n+      __ bind(is_flat);\n+      \/\/ field is flat\n@@ -3870,1 +3870,1 @@\n-        __ read_inlined_field(rcx, rdx, rbx, rax);\n+        __ read_flat_field(rcx, rdx, rbx, rax);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1093,2 +1093,2 @@\n-  if (type == T_OBJECT && state()->stack_at(array_idx)->maybe_flattened_array()) {\n-    \/\/ Save the entire state and re-execute on deopt when accessing flattened arrays\n+  if (type == T_OBJECT && state()->stack_at(array_idx)->maybe_flat_array()) {\n+    \/\/ Save the entire state and re-execute on deopt when accessing flat arrays\n@@ -1115,1 +1115,1 @@\n-  if (array->is_loaded_flattened_array()) {\n+  if (array->is_loaded_flat_array()) {\n@@ -1150,1 +1150,1 @@\n-        \/\/ the flattened field.  Ensure these stores are visible before any\n+        \/\/ the flat field.  Ensure these stores are visible before any\n@@ -1169,1 +1169,1 @@\n-  if (!array->is_loaded_flattened_array()) {\n+  if (!array->is_loaded_flat_array()) {\n@@ -1179,2 +1179,2 @@\n-  if (type == T_OBJECT && state()->stack_at(array_idx)->maybe_flattened_array()) {\n-    \/\/ Save the entire state and re-execute on deopt when accessing flattened arrays\n+  if (type == T_OBJECT && state()->stack_at(array_idx)->maybe_flat_array()) {\n+    \/\/ Save the entire state and re-execute on deopt when accessing flat arrays\n@@ -1212,1 +1212,1 @@\n-  if (profile_array_accesses() && is_reference_type(type) && !array->is_loaded_flattened_array()) {\n+  if (profile_array_accesses() && is_reference_type(type) && !array->is_loaded_flat_array()) {\n@@ -1866,1 +1866,1 @@\n-    assert(!inner_field->is_flattened(), \"the iteration over nested fields is handled by the loop itself\");\n+    assert(!inner_field->is_flat(), \"the iteration over nested fields is handled by the loop itself\");\n@@ -1886,1 +1886,1 @@\n-                              (!field->is_flattened() && PatchALot);\n+                              (!field->is_flat() && PatchALot);\n@@ -1962,2 +1962,2 @@\n-      if (state_before == nullptr && field->is_flattened()) {\n-        \/\/ Save the entire state and re-execute on deopt when accessing flattened fields\n+      if (state_before == nullptr && field->is_flat()) {\n+        \/\/ Save the entire state and re-execute on deopt when accessing flat fields\n@@ -1975,1 +1975,1 @@\n-        } else if (field->is_constant() && !field->is_flattened() && obj_type->is_constant() && !PatchALot) {\n+        } else if (field->is_constant() && !field->is_flat() && obj_type->is_constant() && !PatchALot) {\n@@ -1981,1 +1981,1 @@\n-                \/\/ Non-flattened inline type field. Replace null by the default value.\n+                \/\/ Non-flat inline type field. Replace null by the default value.\n@@ -2004,1 +2004,1 @@\n-        if (!field->is_flattened()) {\n+        if (!field->is_flat()) {\n@@ -2094,1 +2094,1 @@\n-              assert(!needs_patching, \"Can't patch flattened inline type field access\");\n+              assert(!needs_patching, \"Can't patch flat inline type field access\");\n@@ -2129,1 +2129,1 @@\n-      } else if (!field->is_flattened()) {\n+      } else if (!field->is_flat()) {\n@@ -2136,1 +2136,1 @@\n-        assert(!needs_patching, \"Can't patch flattened inline type field access\");\n+        assert(!needs_patching, \"Can't patch flat inline type field access\");\n@@ -2170,1 +2170,1 @@\n-                              (!field_modify->is_flattened() && PatchALot);\n+                              (!field_modify->is_flat() && PatchALot);\n@@ -2191,1 +2191,1 @@\n-        if (field->is_flattened()) {\n+        if (field->is_flat()) {\n@@ -2211,2 +2211,2 @@\n-  if (field_modify->is_flattened()) {\n-    assert(!needs_patching, \"Can't patch flattened inline type field access\");\n+  if (field_modify->is_flat()) {\n+    assert(!needs_patching, \"Can't patch flat inline type field access\");\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-  \/\/ support for optimization of accesses to flattened fields and arrays\n+  \/\/ support for optimization of accesses to flat fields and flat arrays\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-bool Instruction::is_loaded_flattened_array() const {\n+bool Instruction::is_loaded_flat_array() const {\n@@ -137,1 +137,1 @@\n-bool Instruction::maybe_flattened_array() {\n+bool Instruction::maybe_flat_array() {\n@@ -155,1 +155,1 @@\n-      \/\/ flattened array, so we should do a runtime check.\n+      \/\/ flat array, so we should do a runtime check.\n@@ -265,2 +265,2 @@\n-bool StoreIndexed::is_exact_flattened_array_store() const {\n-  if (array()->is_loaded_flattened_array() && value()->as_Constant() == nullptr && value()->declared_type() != nullptr) {\n+bool StoreIndexed::is_exact_flat_array_store() const {\n+  if (array()->is_loaded_flat_array() && value()->as_Constant() == nullptr && value()->declared_type() != nullptr) {\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -521,2 +521,2 @@\n-  bool is_loaded_flattened_array() const;\n-  bool maybe_flattened_array();\n+  bool is_loaded_flat_array() const;\n+  bool maybe_flat_array();\n@@ -871,1 +871,1 @@\n-  ciField* _enclosing_field;   \/\/ enclosing field (the flattened one) for nested fields\n+  ciField* _enclosing_field;   \/\/ enclosing field (the flat one) for nested fields\n@@ -1056,1 +1056,1 @@\n-  bool is_exact_flattened_array_store() const;\n+  bool is_exact_flat_array_store() const;\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-  : LIR_Op(lir_flattened_array_check, LIR_OprFact::illegalOpr, nullptr)\n+  : LIR_Op(lir_flat_array_check, LIR_OprFact::illegalOpr, nullptr)\n@@ -881,1 +881,1 @@\n-    case lir_flattened_array_check: {\n+    case lir_flat_array_check: {\n@@ -1649,1 +1649,1 @@\n-void LIR_List::check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub) {\n+void LIR_List::check_flat_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub) {\n@@ -1956,1 +1956,1 @@\n-     case lir_flattened_array_check: s = \"flattened_array_check\"; break;\n+     case lir_flat_array_check:      s = \"flat_array_check\"; break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-      case T_PRIMITIVE_OBJECT:\n+      case T_PRIMITIVE_OBJECT:  \/\/ fall through\n@@ -491,1 +491,1 @@\n-  case T_PRIMITIVE_OBJECT:\n+  case T_PRIMITIVE_OBJECT:  \/\/ fall through\n@@ -1018,1 +1018,1 @@\n-    , lir_flattened_array_check\n+    , lir_flat_array_check\n@@ -2502,1 +2502,1 @@\n-  void check_flattened_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub);\n+  void check_flat_array(LIR_Opr array, LIR_Opr value, LIR_Opr tmp, CodeStub* stub);\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -768,1 +768,1 @@\n-  if (!src->is_loaded_flattened_array() && !dst->is_loaded_flattened_array()) {\n+  if (!src->is_loaded_flat_array() && !dst->is_loaded_flat_array()) {\n@@ -771,1 +771,1 @@\n-  if (!src->maybe_flattened_array()) {\n+  if (!src->maybe_flat_array()) {\n@@ -774,1 +774,1 @@\n-  if (!dst->maybe_flattened_array() && !dst->maybe_null_free_array()) {\n+  if (!dst->maybe_flat_array() && !dst->maybe_null_free_array()) {\n@@ -1795,1 +1795,1 @@\n-void LIRGenerator::access_flattened_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item,\n+void LIRGenerator::access_flat_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item,\n@@ -1810,1 +1810,1 @@\n-    assert(!inner_field->is_flattened(), \"flattened fields must have been expanded\");\n+    assert(!inner_field->is_flat(), \"flat fields must have been expanded\");\n@@ -1851,1 +1851,1 @@\n-void LIRGenerator::check_flattened_array(LIR_Opr array, LIR_Opr value, CodeStub* slow_path) {\n+void LIRGenerator::check_flat_array(LIR_Opr array, LIR_Opr value, CodeStub* slow_path) {\n@@ -1853,1 +1853,1 @@\n-  __ check_flattened_array(array, value, tmp, slow_path);\n+  __ check_flat_array(array, value, tmp, slow_path);\n@@ -1865,2 +1865,2 @@\n-bool LIRGenerator::needs_flattened_array_store_check(StoreIndexed* x) {\n-  if (x->elt_type() == T_OBJECT && x->array()->maybe_flattened_array()) {\n+bool LIRGenerator::needs_flat_array_store_check(StoreIndexed* x) {\n+  if (x->elt_type() == T_OBJECT && x->array()->maybe_flat_array()) {\n@@ -1871,1 +1871,1 @@\n-        \/\/ This is known to be a non-flattened object. If the array is flattened,\n+        \/\/ This is known to be a non-flat object. If the array is a flat array,\n@@ -1876,1 +1876,1 @@\n-    \/\/ We're not 100% sure, so let's do the flattened_array_store_check.\n+    \/\/ We're not 100% sure, so let's do the flat_array_store_check.\n@@ -1889,1 +1889,1 @@\n-  bool is_loaded_flattened_array = x->array()->is_loaded_flattened_array();\n+  bool is_loaded_flat_array = x->array()->is_loaded_flat_array();\n@@ -1893,1 +1893,1 @@\n-  bool needs_store_check = obj_store && !(is_loaded_flattened_array && x->is_exact_flattened_array_store()) &&\n+  bool needs_store_check = obj_store && !(is_loaded_flat_array && x->is_exact_flat_array_store()) &&\n@@ -1911,1 +1911,1 @@\n-      || is_loaded_flattened_array || needs_flattened_array_store_check(x) || needs_null_free_array_store_check(x)) {\n+      || is_loaded_flat_array || needs_flat_array_store_check(x) || needs_null_free_array_store_check(x)) {\n@@ -1940,2 +1940,2 @@\n-    if (x->array()->is_loaded_flattened_array()) {\n-      \/\/ No need to profile a store to a flattened array of known type. This can happen if\n+    if (x->array()->is_loaded_flat_array()) {\n+      \/\/ No need to profile a store to a flat array of known type. This can happen if\n@@ -1960,1 +1960,1 @@\n-  if (is_loaded_flattened_array) {\n+  if (is_loaded_flat_array) {\n@@ -1966,1 +1966,1 @@\n-      access_flattened_array(false, array, index, value);\n+      access_flat_array(false, array, index, value);\n@@ -1971,2 +1971,2 @@\n-    if (needs_flattened_array_store_check(x)) {\n-      \/\/ Check if we indeed have a flattened array\n+    if (needs_flat_array_store_check(x)) {\n+      \/\/ Check if we indeed have a flat array\n@@ -1975,1 +1975,1 @@\n-      check_flattened_array(array.result(), value.result(), slow_path);\n+      check_flat_array(array.result(), value.result(), slow_path);\n@@ -2076,1 +2076,1 @@\n-  assert(!field->is_flattened(), \"Flattened field access should have been expanded\");\n+  assert(!field->is_flat(), \"Flattened field access should have been expanded\");\n@@ -2082,1 +2082,1 @@\n-  \/\/ field could be flattened (see ciField constructor).\n+  \/\/ field could be flat (see ciField constructor).\n@@ -2166,1 +2166,1 @@\n-    \/\/ Load from non-flattened inline type field requires\n+    \/\/ Load from non-flat inline type field requires\n@@ -2344,2 +2344,2 @@\n-    if (x->array()->is_loaded_flattened_array()) {\n-      \/\/ No need to profile a load from a flattened array of known type. This can happen if\n+    if (x->array()->is_loaded_flat_array()) {\n+      \/\/ No need to profile a load from a flat array of known type. This can happen if\n@@ -2355,1 +2355,1 @@\n-    assert(x->array()->is_loaded_flattened_array(), \"must be\");\n+    assert(x->array()->is_loaded_flat_array(), \"must be\");\n@@ -2359,3 +2359,3 @@\n-    access_flattened_array(true, array, index, obj_item,\n-                           x->delayed() == nullptr ? 0 : x->delayed()->field(),\n-                           x->delayed() == nullptr ? 0 : x->delayed()->offset());\n+    access_flat_array(true, array, index, obj_item,\n+                      x->delayed() == nullptr ? 0 : x->delayed()->field(),\n+                      x->delayed() == nullptr ? 0 : x->delayed()->offset());\n@@ -2364,1 +2364,1 @@\n-    assert(x->array()->is_loaded_flattened_array(), \"must be\");\n+    assert(x->array()->is_loaded_flat_array(), \"must be\");\n@@ -2367,1 +2367,1 @@\n-  } else if (x->array() != nullptr && x->array()->is_loaded_flattened_array() &&\n+  } else if (x->array() != nullptr && x->array()->is_loaded_flat_array() &&\n@@ -2388,2 +2388,2 @@\n-    if (x->elt_type() == T_OBJECT && x->array()->maybe_flattened_array()) {\n-      assert(x->delayed() == nullptr, \"Delayed LoadIndexed only apply to loaded_flattened_arrays\");\n+    if (x->elt_type() == T_OBJECT && x->array()->maybe_flat_array()) {\n+      assert(x->delayed() == nullptr, \"Delayed LoadIndexed only apply to loaded_flat_arrays\");\n@@ -2391,1 +2391,1 @@\n-      \/\/ if we are loading from flattened array, load it using a runtime call\n+      \/\/ if we are loading from a flat array, load it using a runtime call\n@@ -2393,1 +2393,1 @@\n-      check_flattened_array(array.result(), LIR_OprFact::illegalOpr, slow_path);\n+      check_flat_array(array.result(), LIR_OprFact::illegalOpr, slow_path);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  void access_flattened_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item, ciField* field = nullptr, int offset = 0);\n+  void access_flat_array(bool is_load, LIRItem& array, LIRItem& index, LIRItem& obj_item, ciField* field = nullptr, int offset = 0);\n@@ -283,2 +283,2 @@\n-  bool needs_flattened_array_store_check(StoreIndexed* x);\n-  void check_flattened_array(LIR_Opr array, LIR_Opr value, CodeStub* slow_path);\n+  bool needs_flat_array_store_check(StoreIndexed* x);\n+  void check_flat_array(LIR_Opr array, LIR_Opr value, CodeStub* slow_path);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -130,2 +130,2 @@\n-uint Runtime1::_load_flattened_array_slowcase_cnt = 0;\n-uint Runtime1::_store_flattened_array_slowcase_cnt = 0;\n+uint Runtime1::_load_flat_array_slowcase_cnt = 0;\n+uint Runtime1::_store_flat_array_slowcase_cnt = 0;\n@@ -489,1 +489,1 @@\n-JRT_ENTRY(void, Runtime1::load_flattened_array(JavaThread* current, flatArrayOopDesc* array, int index))\n+JRT_ENTRY(void, Runtime1::load_flat_array(JavaThread* current, flatArrayOopDesc* array, int index))\n@@ -493,1 +493,1 @@\n-  NOT_PRODUCT(_load_flattened_array_slowcase_cnt++;)\n+  NOT_PRODUCT(_load_flat_array_slowcase_cnt++;)\n@@ -501,1 +501,1 @@\n-JRT_ENTRY(void, Runtime1::store_flattened_array(JavaThread* current, flatArrayOopDesc* array, int index, oopDesc* value))\n+JRT_ENTRY(void, Runtime1::store_flat_array(JavaThread* current, flatArrayOopDesc* array, int index, oopDesc* value))\n@@ -506,1 +506,1 @@\n-  NOT_PRODUCT(_store_flattened_array_slowcase_cnt++;)\n+  NOT_PRODUCT(_store_flat_array_slowcase_cnt++;)\n@@ -1101,1 +1101,1 @@\n-    assert(!result.is_inlined(), \"Can not patch access to flattened field\");\n+    assert(!result.is_flat(), \"Can not patch access to flat field\");\n@@ -1682,2 +1682,2 @@\n-  tty->print_cr(\" _load_flattened_array_slowcase_cnt:   %u\", _load_flattened_array_slowcase_cnt);\n-  tty->print_cr(\" _store_flattened_array_slowcase_cnt:  %u\", _store_flattened_array_slowcase_cnt);\n+  tty->print_cr(\" _load_flattened_array_slowcase_cnt:   %u\", _load_flat_array_slowcase_cnt);\n+  tty->print_cr(\" _store_flattened_array_slowcase_cnt:  %u\", _store_flat_array_slowcase_cnt);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-  stub(load_flattened_array)         \\\n-  stub(store_flattened_array)        \\\n+  stub(load_flat_array)              \\\n+  stub(store_flat_array)             \\\n@@ -114,2 +114,2 @@\n-  static uint _load_flattened_array_slowcase_cnt;\n-  static uint _store_flattened_array_slowcase_cnt;\n+  static uint _load_flat_array_slowcase_cnt;\n+  static uint _store_flat_array_slowcase_cnt;\n@@ -158,2 +158,2 @@\n-  static void load_flattened_array(JavaThread* current, flatArrayOopDesc* array, int index);\n-  static void store_flattened_array(JavaThread* current, flatArrayOopDesc* array, int index, oopDesc* value);\n+  static void load_flat_array(JavaThread* current, flatArrayOopDesc* array, int index);\n+  static void store_flat_array(JavaThread* current, flatArrayOopDesc* array, int index, oopDesc* value);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ Fall through\n@@ -139,1 +140,0 @@\n-    case T_PRIMITIVE_OBJECT: return objectType;\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-          \"Use delayed reads of flattened field to reduce buffering\")\n+          \"Use delayed reads of flat fields to reduce heap buffering\")\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -558,1 +558,1 @@\n-        \/\/ If the array is flattened, a larger part of it is modified than\n+        \/\/ If the array is a flat array, a larger part of it is modified than\n","filename":"src\/hotspot\/share\/ci\/bcEscapeAnalyzer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  _original_holder(nullptr), _is_flattened(false), _known_to_link_with_put(nullptr), _known_to_link_with_get(nullptr) {\n+  _original_holder(nullptr), _is_flat(false), _known_to_link_with_put(nullptr), _known_to_link_with_get(nullptr) {\n@@ -236,1 +236,1 @@\n-  \/\/ Trust final flattened fields\n+  \/\/ Trust final flat fields\n@@ -241,2 +241,2 @@\n-  assert(!field->is_flattened(), \"field must not be flattened\");\n-  _is_flattened = false;\n+  assert(!field->is_flat(), \"field must not be flat\");\n+  _is_flat = false;\n@@ -294,2 +294,2 @@\n-  _is_flattened = fd->is_inlined();\n-  _is_null_free = fd->signature()->is_Q_signature();\n+  _is_flat = fd->is_flat();\n+  _is_null_free = fd->is_null_free_inline_type();\n@@ -494,1 +494,1 @@\n-  tty->print(\" is_flattened=%s\", bool_to_str(_is_flattened));\n+  tty->print(\" is_flat=%s\", bool_to_str(_is_flat));\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  ciInstanceKlass* _original_holder; \/\/ For flattened fields\n+  ciInstanceKlass* _original_holder; \/\/ For fields nested in flat fields\n@@ -53,1 +53,1 @@\n-  bool             _is_flattened;\n+  bool             _is_flat;\n@@ -176,1 +176,1 @@\n-  bool is_flattened            () const { return _is_flattened; }\n+  bool is_flat                 () const { return _is_flat; }\n","filename":"src\/hotspot\/share\/ci\/ciField.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-\/\/ belongs to a flattened inline type field, return the index of the field\n-\/\/ in the flattened inline type.\n+\/\/ belongs to a flat field, return the index of the field in the inline type of the flat field.\n@@ -64,1 +63,1 @@\n-      \/\/ flattened inline type field that holds the field we are looking for.\n+      \/\/ flat field that holds the field we are looking for.\n@@ -74,1 +73,1 @@\n-\/\/ Are arrays containing this inline type flattened?\n+\/\/ Are arrays containing this inline type flat arrays?\n@@ -92,1 +91,1 @@\n-  \/\/ are not flattened\n+  \/\/ are not flat\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  \/\/ Fields declared in the bytecode (without flattened inline type fields)\n+  \/\/ Fields declared in the bytecode (without nested fields in flat fields)\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-ciField* ciInstanceKlass::get_non_flattened_field_by_offset(int field_offset) {\n+ciField* ciInstanceKlass::get_non_flat_field_by_offset(int field_offset) {\n@@ -444,1 +444,1 @@\n-    ciField* f = super()->get_non_flattened_field_by_offset(field_offset);\n+    ciField* f = super()->get_non_flat_field_by_offset(field_offset);\n@@ -527,1 +527,1 @@\n-GrowableArray<ciField*>* ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray<ciField*>* super_fields, bool flatten) {\n+GrowableArray<ciField*>* ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray<ciField*>* super_fields, bool is_flat) {\n@@ -553,1 +553,1 @@\n-    if (fd.is_inlined() && flatten) {\n+    if (fd.is_flat() && is_flat) {\n@@ -560,1 +560,1 @@\n-      \/\/ Iterate over fields of the flattened inline type and copy them to 'this'\n+      \/\/ Iterate over fields of the flat inline type and copy them to 'this'\n@@ -562,1 +562,1 @@\n-        ciField* flattened_field = vk->nonstatic_field_at(i);\n+        ciField* flat_field = vk->nonstatic_field_at(i);\n@@ -564,2 +564,2 @@\n-        int offset = field_offset + (flattened_field->offset_in_bytes() - vk->first_field_offset());\n-        \/\/ A flattened field can be treated as final if the non-flattened\n+        int offset = field_offset + (flat_field->offset_in_bytes() - vk->first_field_offset());\n+        \/\/ A flat field can be treated as final if the non-flat\n@@ -568,1 +568,1 @@\n-        ciField* field = new (arena) ciField(flattened_field, this, offset, is_final);\n+        ciField* field = new (arena) ciField(flat_field, this, offset, is_final);\n@@ -717,1 +717,1 @@\n-  void do_field_helper(fieldDescriptor* fd, oop obj, bool flattened);\n+  void do_field_helper(fieldDescriptor* fd, oop obj, bool is_flat);\n@@ -754,1 +754,1 @@\n-void StaticFieldPrinter::do_field_helper(fieldDescriptor* fd, oop mirror, bool flattened) {\n+void StaticFieldPrinter::do_field_helper(fieldDescriptor* fd, oop mirror, bool is_flat) {\n@@ -773,0 +773,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ fall-through\n@@ -774,21 +775,25 @@\n-    case T_OBJECT: {\n-      _out->print(\"%s \", fd->signature()->as_quoted_ascii());\n-      oop value =  mirror->obj_field_acquire(fd->offset());\n-      if (value == nullptr) {\n-        _out->print_cr(\"null\");\n-      } else if (value->is_instance()) {\n-        assert(fd->field_type() == T_OBJECT, \"\");\n-        if (value->is_a(vmClasses::String_klass())) {\n-          const char* ascii_value = java_lang_String::as_quoted_ascii(value);\n-          _out->print(\"\\\"%s\\\"\", (ascii_value != nullptr) ? ascii_value : \"\");\n-         } else {\n-          const char* klass_name  = value->klass()->name()->as_quoted_ascii();\n-          _out->print(\"%s\", klass_name);\n-        }\n-      } else if (value->is_array()) {\n-        typeArrayOop ta = (typeArrayOop)value;\n-        _out->print(\"%d\", ta->length());\n-        if (value->is_objArray() || value->is_flatArray()) {\n-          objArrayOop oa = (objArrayOop)value;\n-          const char* klass_name  = value->klass()->name()->as_quoted_ascii();\n-          _out->print(\" %s\", klass_name);\n+    case T_OBJECT:\n+      if (!fd->is_null_free_inline_type()) {\n+        _out->print(\"%s \", fd->signature()->as_quoted_ascii());\n+        oop value =  mirror->obj_field_acquire(fd->offset());\n+        if (value == nullptr) {\n+          _out->print_cr(\"null\");\n+        } else if (value->is_instance()) {\n+          assert(fd->field_type() == T_OBJECT, \"\");\n+          if (value->is_a(vmClasses::String_klass())) {\n+            const char* ascii_value = java_lang_String::as_quoted_ascii(value);\n+            _out->print(\"\\\"%s\\\"\", (ascii_value != nullptr) ? ascii_value : \"\");\n+          } else {\n+            const char* klass_name  = value->klass()->name()->as_quoted_ascii();\n+            _out->print(\"%s\", klass_name);\n+          }\n+        } else if (value->is_array()) {\n+          typeArrayOop ta = (typeArrayOop)value;\n+          _out->print(\"%d\", ta->length());\n+          if (value->is_objArray() || value->is_flatArray()) {\n+            objArrayOop oa = (objArrayOop)value;\n+            const char* klass_name  = value->klass()->name()->as_quoted_ascii();\n+            _out->print(\" %s\", klass_name);\n+          }\n+        } else {\n+          ShouldNotReachHere();\n@@ -796,0 +801,1 @@\n+        break;\n@@ -797,22 +803,22 @@\n-        ShouldNotReachHere();\n-      }\n-      break;\n-    }\n-    case T_PRIMITIVE_OBJECT: {\n-      ResetNoHandleMark rnhm;\n-      Thread* THREAD = Thread::current();\n-      SignatureStream ss(fd->signature(), false);\n-      Symbol* name = ss.as_symbol();\n-      assert(!HAS_PENDING_EXCEPTION, \"can resolve klass?\");\n-      InstanceKlass* holder = fd->field_holder();\n-      InstanceKlass* k = SystemDictionary::find_instance_klass(THREAD, name,\n-                                                               Handle(THREAD, holder->class_loader()),\n-                                                               Handle(THREAD, holder->protection_domain()));\n-      assert(k != nullptr && !HAS_PENDING_EXCEPTION, \"can resolve klass?\");\n-      InlineKlass* vk = InlineKlass::cast(k);\n-      oop obj;\n-      if (flattened) {\n-        int field_offset = fd->offset() - vk->first_field_offset();\n-        obj = cast_to_oop(cast_from_oop<address>(mirror) + field_offset);\n-      } else {\n-        obj = mirror->obj_field_acquire(fd->offset());\n+        \/\/ handling of null free inline type\n+        ResetNoHandleMark rnhm;\n+        Thread* THREAD = Thread::current();\n+        SignatureStream ss(fd->signature(), false);\n+        Symbol* name = ss.as_symbol();\n+        assert(!HAS_PENDING_EXCEPTION, \"can resolve klass?\");\n+        InstanceKlass* holder = fd->field_holder();\n+        InstanceKlass* k = SystemDictionary::find_instance_klass(THREAD, name,\n+                                                                 Handle(THREAD, holder->class_loader()),\n+                                                                 Handle(THREAD, holder->protection_domain()));\n+        assert(k != nullptr && !HAS_PENDING_EXCEPTION, \"can resolve klass?\");\n+        InlineKlass* vk = InlineKlass::cast(k);\n+        oop obj;\n+        if (is_flat) {\n+          int field_offset = fd->offset() - vk->first_field_offset();\n+          obj = cast_to_oop(cast_from_oop<address>(mirror) + field_offset);\n+        } else {\n+          obj = mirror->obj_field_acquire(fd->offset());\n+        }\n+        InlineTypeFieldPrinter print_field(_out, obj);\n+        vk->do_nonstatic_fields(&print_field);\n+        break;\n@@ -820,4 +826,0 @@\n-      InlineTypeFieldPrinter print_field(_out, obj);\n-      vk->do_nonstatic_fields(&print_field);\n-      break;\n-    }\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":60,"deletions":58,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-  ciField* get_non_flattened_field_by_offset(int field_offset);\n+  ciField* get_non_flat_field_by_offset(int field_offset);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1046,1 +1046,1 @@\n-      const char* string_value = bt != T_PRIMITIVE_OBJECT ? _replay->parse_escaped_string() : nullptr;\n+      const char* string_value = fd->is_null_free_inline_type() ? nullptr : _replay->parse_escaped_string();\n@@ -1093,13 +1093,7 @@\n-      case T_OBJECT: {\n-        JavaThread* THREAD = JavaThread::current();\n-        bool res = _replay->process_staticfield_reference(string_value, _vt, fd, THREAD);\n-        assert(res, \"should succeed for arrays & objects\");\n-        break;\n-      }\n-      case T_PRIMITIVE_OBJECT: {\n-        InlineKlass* vk = InlineKlass::cast(fd->field_holder()->get_inline_type_field_klass(fd->index()));\n-        if (fd->is_inlined()) {\n-          int field_offset = fd->offset() - vk->first_field_offset();\n-          oop obj = cast_to_oop(cast_from_oop<address>(_vt) + field_offset);\n-          InlineTypeFieldInitializer init_fields(obj, _replay);\n-          vk->do_nonstatic_fields(&init_fields);\n+      case T_OBJECT:\n+      case T_PRIMITIVE_OBJECT:\n+        if (!fd->is_null_free_inline_type()) {\n+          JavaThread* THREAD = JavaThread::current();\n+          bool res = _replay->process_staticfield_reference(string_value, _vt, fd, THREAD);\n+          assert(res, \"should succeed for arrays & objects\");\n+          break;\n@@ -1107,2 +1101,11 @@\n-          oop value = vk->allocate_instance(JavaThread::current());\n-          _vt->obj_field_put(fd->offset(), value);\n+          InlineKlass* vk = InlineKlass::cast(fd->field_holder()->get_inline_type_field_klass(fd->index()));\n+          if (fd->is_flat()) {\n+            int field_offset = fd->offset() - vk->first_field_offset();\n+            oop obj = cast_to_oop(cast_from_oop<address>(_vt) + field_offset);\n+            InlineTypeFieldInitializer init_fields(obj, _replay);\n+            vk->do_nonstatic_fields(&init_fields);\n+          } else {\n+            oop value = vk->allocate_instance(JavaThread::current());\n+            _vt->obj_field_put(fd->offset(), value);\n+          }\n+          break;\n@@ -1110,2 +1113,0 @@\n-        break;\n-      }\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1591,0 +1591,6 @@\n+    \/\/ Here, we still detect that the field's type is an inline type by checking if it has\n+    \/\/ a Q-descriptor. This test will be replaced later by something not relying on Q-desriptors.\n+    \/\/ From this point forward, checking if a field's type is an inline type should be performed\n+    \/\/ using the inline_type flag of FieldFlags, and not by looking for a Q-descriptor in its signature\n+    if (type == T_PRIMITIVE_OBJECT) fieldFlags.update_null_free_inline_type(true);\n+\n@@ -5770,1 +5776,1 @@\n-      if (fs.field_descriptor().is_inline_type()) {\n+      if (fs.field_descriptor().is_null_free_inline_type()) {\n@@ -6506,1 +6512,1 @@\n-      if (Signature::basic_type(sig) == T_PRIMITIVE_OBJECT && !fieldinfo.access_flags().is_static()) {\n+      if (fieldinfo.field_flags().is_null_free_inline_type() && !fieldinfo.access_flags().is_static()) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  assert(kind == REGULAR || kind == INLINED || kind == INHERITED,\n+  assert(kind == REGULAR || kind == FLAT || kind == INHERITED,\n@@ -108,2 +108,2 @@\n-void FieldGroup::add_inlined_field(int idx, InlineKlass* vk) {\n-  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::INLINED, vk->get_exact_size_in_bytes(), vk->get_alignment(), false);\n+void FieldGroup::add_flat_field(int idx, InlineKlass* vk) {\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::FLAT, vk->get_exact_size_in_bytes(), vk->get_alignment(), false);\n@@ -187,1 +187,1 @@\n-         && block->kind() != LayoutRawBlock::INLINED) {\n+         && block->kind() != LayoutRawBlock::FLAT) {\n@@ -341,1 +341,1 @@\n-      if (type == T_PRIMITIVE_OBJECT) {\n+      if (fs.field_flags().is_null_free_inline_type()) {\n@@ -480,1 +480,1 @@\n-      case LayoutRawBlock::INLINED: {\n+      case LayoutRawBlock::FLAT: {\n@@ -488,1 +488,1 @@\n-                         \"INLINED\");\n+                         \"FLAT\");\n@@ -634,7 +634,3 @@\n-      if (group != _static_fields) _nonstatic_oopmap_count++;\n-      group->add_oop_field(idx);\n-      break;\n-    case T_PRIMITIVE_OBJECT:\n-      _has_inline_type_fields = true;\n-      if (group == _static_fields) {\n-        \/\/ static fields are never inlined\n+    case T_PRIMITIVE_OBJECT:  \/\/ T_PRIMITIVE_OBJECT is going to me removed, inline types are detected below\n+      if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+        if (group != _static_fields) _nonstatic_oopmap_count++;\n@@ -643,27 +639,3 @@\n-        _has_flattening_information = true;\n-        \/\/ Flattening decision to be taken here\n-        \/\/ This code assumes all verification already have been performed\n-        \/\/ (field's type has been loaded and it is an inline klass)\n-        JavaThread* THREAD = JavaThread::current();\n-        Klass* klass =  _inline_type_field_klasses->at(idx);\n-        assert(klass != nullptr, \"Sanity check\");\n-        InlineKlass* vk = InlineKlass::cast(klass);\n-        bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                   (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-        bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n-        bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n-        if (vk->is_naturally_atomic()) {\n-          too_atomic_to_flatten = false;\n-          \/\/too_volatile_to_flatten = false; \/\/FIXME\n-          \/\/ volatile fields are currently never inlined, this could change in the future\n-        }\n-        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fieldinfo.access_flags().is_final()) {\n-          group->add_inlined_field(idx, vk);\n-          _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-          _field_info->adr_at(idx)->field_flags_addr()->update_inlined(true);\n-          if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-            _has_nonatomic_values = true;\n-            _atomic_field_count--;  \/\/ every other field is atomic but this one\n-          }\n-        } else {\n-          _nonstatic_oopmap_count++;\n+        _has_inline_type_fields = true;\n+        if (group == _static_fields) {\n+          \/\/ static fields are never flatten\n@@ -671,0 +643,30 @@\n+        } else {\n+          _has_flattening_information = true;\n+          \/\/ Flattening decision to be taken here\n+          \/\/ This code assumes all verification already have been performed\n+          \/\/ (field's type has been loaded and it is an inline klass)\n+          JavaThread* THREAD = JavaThread::current();\n+          Klass* klass =  _inline_type_field_klasses->at(idx);\n+          assert(klass != nullptr, \"Sanity check\");\n+          InlineKlass* vk = InlineKlass::cast(klass);\n+          bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                    (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+          bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+          bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n+          if (vk->is_naturally_atomic()) {\n+            too_atomic_to_flatten = false;\n+            \/\/too_volatile_to_flatten = false; \/\/FIXME\n+            \/\/ volatile fields are currently never flatten, this could change in the future\n+          }\n+          if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fieldinfo.access_flags().is_final()) {\n+            group->add_flat_field(idx, vk);\n+            _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+            _field_info->adr_at(idx)->field_flags_addr()->update_flat(true);\n+            if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+              _has_nonatomic_values = true;\n+              _atomic_field_count--;  \/\/ every other field is atomic but this one\n+            }\n+          } else {\n+            _nonstatic_oopmap_count++;\n+            group->add_oop_field(idx);\n+          }\n@@ -695,1 +697,1 @@\n- *     currently only based in the size of the fields to be inlined, the size\n+ *     currently only based in the size of the fields to be flattened, the size\n@@ -730,11 +732,6 @@\n-      if (group != _static_fields) {\n-        _nonstatic_oopmap_count++;\n-        field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n-      }\n-      group->add_oop_field(fieldinfo.index());\n-      break;\n-    case T_PRIMITIVE_OBJECT: {\n-\/\/      fs.set_inline(true);\n-      _has_inline_type_fields = true;\n-      if (group == _static_fields) {\n-        \/\/ static fields are never inlined\n+    case T_PRIMITIVE_OBJECT: \/\/ T_PRIMITIVE_OBJECT is going to be removed, online types are detected below\n+      if (!fieldinfo.field_flags().is_null_free_inline_type()) {\n+        if (group != _static_fields) {\n+          _nonstatic_oopmap_count++;\n+          field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n+        }\n@@ -743,28 +740,3 @@\n-        \/\/ Flattening decision to be taken here\n-        \/\/ This code assumes all verifications have already been performed\n-        \/\/ (field's type has been loaded and it is an inline klass)\n-        JavaThread* THREAD = JavaThread::current();\n-        Klass* klass =  _inline_type_field_klasses->at(fieldinfo.index());\n-        assert(klass != nullptr, \"Sanity check\");\n-        InlineKlass* vk = InlineKlass::cast(klass);\n-        bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n-                                   (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n-        bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n-        bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n-        if (vk->is_naturally_atomic()) {\n-          too_atomic_to_flatten = false;\n-          \/\/too_volatile_to_flatten = false; \/\/FIXME\n-          \/\/ volatile fields are currently never inlined, this could change in the future\n-        }\n-        if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fieldinfo.access_flags().is_final()) {\n-          group->add_inlined_field(fieldinfo.index(), vk);\n-          _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n-          field_alignment = vk->get_alignment();\n-          _field_info->adr_at(fieldinfo.index())->field_flags_addr()->update_inlined(true);\n-          if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n-            _has_nonatomic_values = true;\n-            _atomic_field_count--;  \/\/ every other field is atomic but this one\n-          }\n-        } else {\n-          _nonstatic_oopmap_count++;\n-          field_alignment = type2aelembytes(T_OBJECT);\n+        _has_inline_type_fields = true;\n+        if (group == _static_fields) {\n+          \/\/ static fields are never flatten\n@@ -772,0 +744,31 @@\n+        } else {\n+          \/\/ Flattening decision to be taken here\n+          \/\/ This code assumes all verifications have already been performed\n+          \/\/ (field's type has been loaded and it is an inline klass)\n+          JavaThread* THREAD = JavaThread::current();\n+          Klass* klass =  _inline_type_field_klasses->at(fieldinfo.index());\n+          assert(klass != nullptr, \"Sanity check\");\n+          InlineKlass* vk = InlineKlass::cast(klass);\n+          bool too_big_to_flatten = (InlineFieldMaxFlatSize >= 0 &&\n+                                    (vk->size_helper() * HeapWordSize) > InlineFieldMaxFlatSize);\n+          bool too_atomic_to_flatten = vk->is_declared_atomic() || AlwaysAtomicAccesses;\n+          bool too_volatile_to_flatten = fieldinfo.access_flags().is_volatile();\n+          if (vk->is_naturally_atomic()) {\n+            too_atomic_to_flatten = false;\n+            \/\/too_volatile_to_flatten = false; \/\/FIXME\n+            \/\/ volatile fields are currently never flatten, this could change in the future\n+          }\n+          if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten) || fieldinfo.access_flags().is_final()) {\n+            group->add_flat_field(fieldinfo.index(), vk);\n+            _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+            field_alignment = vk->get_alignment();\n+            _field_info->adr_at(fieldinfo.index())->field_flags_addr()->update_flat(true);\n+            if (!vk->is_atomic()) {  \/\/ flat and non-atomic: take note\n+              _has_nonatomic_values = true;\n+              _atomic_field_count--;  \/\/ every other field is atomic but this one\n+            }\n+          } else {\n+            _nonstatic_oopmap_count++;\n+            field_alignment = type2aelembytes(T_OBJECT);\n+            group->add_oop_field(fieldinfo.index());\n+          }\n@@ -775,1 +778,0 @@\n-    }\n@@ -800,1 +802,1 @@\n- *   - primitive fields (both primitive types and flattened inline types) are allocated\n+ *   - primitive fields (both primitive types and flat inline types) are allocated\n@@ -850,1 +852,1 @@\n- *   - big primitive fields (primitive types and flattened inline type smaller\n+ *   - big primitive fields (primitive types and flat inline type smaller\n@@ -893,1 +895,1 @@\n-void FieldLayoutBuilder::add_inlined_field_oopmap(OopMapBlocksBuilder* nonstatic_oop_maps,\n+void FieldLayoutBuilder::add_flat_field_oopmap(OopMapBlocksBuilder* nonstatic_oop_maps,\n@@ -908,1 +910,1 @@\n-      if (f->kind() == LayoutRawBlock::INLINED) {\n+      if (f->kind() == LayoutRawBlock::FLAT) {\n@@ -912,1 +914,1 @@\n-          add_inlined_field_oopmap(nonstatic_oop_maps, vk, f->offset());\n+          add_flat_field_oopmap(nonstatic_oop_maps, vk, f->offset());\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":89,"deletions":87,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -59,2 +59,2 @@\n-    REGULAR,          \/\/ primitive or oop field (including inline type fields not inlined)\n-    INLINED,          \/\/ field inlined\n+    REGULAR,          \/\/ primitive or oop field (including not flat inline type fields)\n+    FLAT,             \/\/ flat field\n@@ -126,1 +126,1 @@\n-\/\/ oop, or inlined.\n+\/\/ oop, or flat.\n@@ -153,1 +153,1 @@\n-  void add_inlined_field(int idx, InlineKlass* vk);\n+  void add_flat_field(int idx, InlineKlass* vk);\n@@ -297,1 +297,1 @@\n-  void add_inlined_field_oopmap(OopMapBlocksBuilder* nonstatic_oop_map, InlineKlass* vk, int offset);\n+  void add_flat_field_oopmap(OopMapBlocksBuilder* nonstatic_oop_map, InlineKlass* vk, int offset);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1304,1 +1304,1 @@\n-    MN_FLATTENED             = 0x00400000, \/\/ flattened field\n+    MN_FLAT_FIELD            = 0x00400000, \/\/ flat field\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1204,1 +1204,1 @@\n-      if (Signature::basic_type(sig) == T_PRIMITIVE_OBJECT) {\n+      if (fs.is_null_free_inline_type()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -324,1 +324,1 @@\n-      if (!cpe->is_inlined() && old_value_h()->obj_field(offset) == ref_h()) can_skip = true;\n+      if (!cpe->is_flat() && old_value_h()->obj_field(offset) == ref_h()) can_skip = true;\n@@ -365,9 +365,3 @@\n-          if (!cpe->is_inlined()) {\n-              if (ref_h() == nullptr) {\n-                THROW_(vmSymbols::java_lang_NullPointerException(), ret_adj);\n-              }\n-              new_value_h()->obj_field_put(offset, ref_h());\n-            } else {\n-              int field_index = cpe->field_index();\n-              InlineKlass* field_ik = InlineKlass::cast(ik->get_inline_type_field_klass(field_index));\n-              field_ik->write_inlined_field(new_value_h(), offset, ref_h(), CHECK_(ret_adj));\n+          if (!cpe->is_flat()) {\n+            if (ref_h() == nullptr) {\n+              THROW_(vmSymbols::java_lang_NullPointerException(), ret_adj);\n@@ -375,0 +369,6 @@\n+            new_value_h()->obj_field_put(offset, ref_h());\n+          } else {\n+            int field_index = cpe->field_index();\n+            InlineKlass* field_ik = InlineKlass::cast(ik->get_inline_type_field_klass(field_index));\n+            field_ik->write_flat_field(new_value_h(), offset, ref_h(), CHECK_(ret_adj));\n+          }\n@@ -401,1 +401,1 @@\n-  assert(klass->field_signature(index)->is_Q_signature(), \"Sanity check\");\n+  assert(klass->field_is_null_free_inline_type(index), \"Sanity check\");\n@@ -437,1 +437,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::read_inlined_field(JavaThread* current, oopDesc* obj, int index, Klass* field_holder))\n+JRT_ENTRY(void, InterpreterRuntime::read_flat_field(JavaThread* current, oopDesc* obj, int index, Klass* field_holder))\n@@ -445,1 +445,1 @@\n-  assert(klass->field_is_inlined(index), \"Sanity check\");\n+  assert(klass->field_is_flat(index), \"Sanity check\");\n@@ -449,1 +449,1 @@\n-  oop res = field_vklass->read_inlined_field(obj_h(), klass->field_offset(index), CHECK);\n+  oop res = field_vklass->read_flat_field(obj_h(), klass->field_offset(index), CHECK);\n@@ -986,2 +986,2 @@\n-    info.is_inlined(),\n-    info.signature()->is_Q_signature() && info.is_inline_type()\n+    info.is_flat(),\n+    info.is_null_free_inline_type()\n@@ -1441,1 +1441,1 @@\n-  bool is_inlined = cp_entry->is_inlined();\n+  bool is_flat = cp_entry->is_flat();\n@@ -1450,1 +1450,1 @@\n-  jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry->f2_as_index(), is_static, is_inlined);\n+  jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry->f2_as_index(), is_static, is_flat);\n@@ -1482,1 +1482,2 @@\n-  if (cp_entry->flag_state() == atos && ik->field_signature(index)->is_Q_signature()) {\n+  ik->field_is_null_free_inline_type(index);\n+  if (cp_entry->flag_state() == atos && ik->field_is_null_free_inline_type(index)) {\n@@ -1487,1 +1488,1 @@\n-  bool is_inlined = cp_entry->is_inlined();\n+  bool is_flat = cp_entry->is_flat();\n@@ -1490,1 +1491,1 @@\n-  jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry->f2_as_index(), is_static, is_inlined);\n+  jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry->f2_as_index(), is_static, is_flat);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  static void    read_inlined_field(JavaThread* current, oopDesc* value, int index, Klass* field_holder);\n+  static void    read_flat_field(JavaThread* current, oopDesc* value, int index, Klass* field_holder);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"oops\/fieldInfo.hpp\"\n@@ -539,0 +540,1 @@\n+  FieldInfo::FieldFlags _field_flags;\n@@ -540,16 +542,7 @@\n-  FieldDesc() {\n-    _name = nullptr;\n-    _signature = nullptr;\n-    _offset = -1;\n-    _index = -1;\n-    _holder = nullptr;\n-    _access_flags = AccessFlags();\n-  }\n-  FieldDesc(fieldDescriptor& fd) {\n-    _name = fd.name();\n-    _signature = fd.signature();\n-    _offset = fd.offset();\n-    _index = fd.index();\n-    _holder = fd.field_holder();\n-    _access_flags = fd.access_flags();\n-  }\n+  FieldDesc() : _name(nullptr), _signature(nullptr), _offset(-1), _index(-1), _holder(nullptr),\n+                _access_flags(AccessFlags()), _field_flags(FieldInfo::FieldFlags((u4)0)) { }\n+\n+  FieldDesc(fieldDescriptor& fd) : _name(fd.name()), _signature(fd.signature()), _offset(fd.offset()),\n+                                   _index(fd.index()), _holder(fd.field_holder()),\n+                                   _access_flags(fd.access_flags()), _field_flags(fd.field_flags()) { }\n+\n@@ -562,1 +555,1 @@\n-  bool is_inline_type() const { return Signature::basic_type(_signature) == T_PRIMITIVE_OBJECT; }\n+  bool is_null_free_inline_type() const { return _field_flags.is_null_free_inline_type(); }\n@@ -569,4 +562,4 @@\n-static void print_field(outputStream* st, int level, int offset, FieldDesc& fd, bool is_inline_type, bool is_inlined ) {\n-  const char* inlined_msg = \"\";\n-  if (is_inline_type) {\n-    inlined_msg = is_inlined ? \"inlined\" : \"not inlined\";\n+static void print_field(outputStream* st, int level, int offset, FieldDesc& fd, bool is_inline_type, bool is_flat ) {\n+  const char* flat_field_msg = \"\";\n+  if (is_flat) {\n+    flat_field_msg = is_flat ? \"flat\" : \"not flat\";\n@@ -579,1 +572,1 @@\n-      inlined_msg);\n+      flat_field_msg);\n@@ -582,2 +575,2 @@\n-static void print_inlined_field(outputStream* st, int level, int offset, InstanceKlass* klass) {\n-  assert(klass->is_inline_klass(), \"Only inline types can be inlined\");\n+static void print_flat_field(outputStream* st, int level, int offset, InstanceKlass* klass) {\n+  assert(klass->is_inline_klass(), \"Only inline types can be flat\");\n@@ -596,3 +589,3 @@\n-        fd.is_inline_type(), fd.holder()->field_is_inlined(fd.index()));\n-    if (fd.holder()->field_is_inlined(fd.index())) {\n-      print_inlined_field(st, level + 1, offset2 ,\n+        fd.is_null_free_inline_type(), fd.holder()->field_is_flat(fd.index()));\n+    if (fd.holder()->field_is_flat(fd.index())) {\n+      print_flat_field(st, level + 1, offset2 ,\n@@ -637,3 +630,3 @@\n-      print_field(st, 0, fd.offset(), fd, fd.is_inline_type(), fd.holder()->field_is_inlined(fd.index()));\n-      if (fd.holder()->field_is_inlined(fd.index())) {\n-        print_inlined_field(st, 1, fd.offset(),\n+      print_field(st, 0, fd.offset(), fd, fd.is_null_free_inline_type(), fd.holder()->field_is_flat(fd.index()));\n+      if (fd.holder()->field_is_flat(fd.index())) {\n+        print_flat_field(st, 1, fd.offset(),\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":23,"deletions":30,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-  \/\/ Request flattened, but we might not actually get it...either way \"null-free\" are the aaload\/aastore semantics\n+  \/\/ Request a flat array, but we might not actually get it...either way \"null-free\" are the aaload\/aastore semantics\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  \/\/ Method specifically null free and possibly flattened if possible\n+  \/\/ Method specifically null free and possibly flat if possible\n","filename":"src\/hotspot\/share\/memory\/oopFactory.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-  \/\/ inline type heap access (when inlined)...\n+  \/\/ inline type heap access (when flat)...\n","filename":"src\/hotspot\/share\/oops\/access.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-                                    \/\/ arrays containing flattened value types. However, the element\n+                                    \/\/ arrays containing flat value types. However, the element\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-                                       bool is_inlined,\n+                                       bool is_flat,\n@@ -132,1 +132,1 @@\n-  assert(!is_inlined || is_null_free_inline_type, \"Sanity check\");\n+  assert(!is_flat || is_null_free_inline_type, \"Sanity check\");\n@@ -136,1 +136,1 @@\n-                  ((is_inlined  ? 1 : 0) << is_inlined_shift) |\n+                  ((is_flat     ? 1 : 0) << is_flat_shift) |\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-\/\/ i  flag true if field is inlined\n+\/\/ i  flag true if field is flat\n@@ -189,1 +189,1 @@\n-    is_inlined_shift           = 23,  \/\/ (i) is the field inlined?\n+    is_flat_shift              = 23,  \/\/ (i) is the field flat?\n@@ -229,1 +229,1 @@\n-    bool            is_inlined,                  \/\/ the field is inlined\n+    bool            is_flat,                     \/\/ the field is flat\n@@ -341,1 +341,1 @@\n-  bool is_inlined() const                        { return (_flags & (1 << is_inlined_shift))        != 0; }\n+  bool is_flat() const                           { return (_flags & (1 << is_flat_shift))           != 0; }\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    friend class FieldDesc;\n@@ -74,1 +75,2 @@\n-      _ff_inlined,      \/\/ or \"flattened\"\n+      _ff_null_free_inline_type,  \/\/ field's type is an inline type and the field is null free\n+      _ff_flat,         \/\/ field is a flat field\n@@ -110,1 +112,2 @@\n-    bool is_inlined() const         { return test_flag(_ff_inlined); }\n+    bool is_null_free_inline_type() const { return test_flag(_ff_null_free_inline_type); }\n+    bool is_flat() const            { return test_flag(_ff_flat); }\n@@ -117,1 +120,2 @@\n-    void update_inlined(bool z)     { update_flag(_ff_inlined, z); }\n+    void update_null_free_inline_type(bool z) { update_flag(_ff_null_free_inline_type, z); }\n+    void update_flat(bool z)        { update_flag(_ff_flat, z); }\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -113,2 +113,6 @@\n-  bool is_inlined() {\n-    return field()->field_flags().is_inlined();\n+  bool is_null_free_inline_type() {\n+    return field()->field_flags().is_null_free_inline_type();\n+  }\n+\n+  bool is_flat() {\n+    return field()->field_flags().is_flat();\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-oop InlineKlass::read_inlined_field(oop obj, int offset, TRAPS) {\n+oop InlineKlass::read_flat_field(oop obj, int offset, TRAPS) {\n@@ -140,1 +140,1 @@\n-void InlineKlass::write_inlined_field(oop obj, int offset, oop value, TRAPS) {\n+void InlineKlass::write_flat_field(oop obj, int offset, oop value, TRAPS) {\n@@ -221,1 +221,1 @@\n-\/\/ function collects the inlined field (recursively)\n+\/\/ function collects the flat field (recursively)\n@@ -245,2 +245,2 @@\n-    if (fs.is_inlined()) {\n-      \/\/ Resolve klass of inlined field and recursively collect fields\n+    if (fs.is_flat()) {\n+      \/\/ Resolve klass of flat field and recursively collect fields\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-  \/\/ \"in-lined\" (flattened) into containing oops, these methods reside here in InlineKlass.\n+  \/\/ \"in-lined\" (flat layout) into containing oops, these methods reside here in InlineKlass.\n@@ -215,2 +215,2 @@\n-  oop read_inlined_field(oop obj, int offset, TRAPS);\n-  void write_inlined_field(oop obj, int offset, oop value, TRAPS);\n+  oop read_flat_field(oop obj, int offset, TRAPS);\n+  void write_flat_field(oop obj, int offset, oop value, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-  return Signature::basic_type(field_signature(index)) == T_PRIMITIVE_OBJECT;\n+  return field(index).field_flags().is_null_free_inline_type();\n@@ -1301,1 +1301,1 @@\n-      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT) {\n+      if (fs.is_null_free_inline_type()) {\n@@ -2807,1 +2807,1 @@\n-      if (Signature::basic_type(fs.signature()) == T_PRIMITIVE_OBJECT) {\n+      if (fs.is_null_free_inline_type()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-  bool    field_is_inlined(int index) const { return field_flags(index).is_inlined(); }\n+  bool    field_is_flat(int index) const { return field_flags(index).is_flat(); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-     definition: empty inline fields must be flattened otherwise the container won't\n+     definition: empty inline fields must be flat otherwise the container won't\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -428,1 +428,1 @@\n-      assert(!field->is_flattened(), \"flattened field encountered\");\n+      assert(!field->is_flat(), \"flattened field encountered\");\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1046,1 +1046,1 @@\n-  assert(t != Type::MEMORY || at == flatten_phi_adr_type(at) || (flatten_phi_adr_type(at) == TypeAryPtr::INLINES && Compile::current()->flattened_accesses_share_alias()), \"flatten at\");\n+  assert(t != Type::MEMORY || at == flatten_phi_adr_type(at) || (flatten_phi_adr_type(at) == TypeAryPtr::INLINES && Compile::current()->flat_accesses_share_alias()), \"flatten at\");\n@@ -1174,2 +1174,2 @@\n-  \/\/ Flat array element shouldn't get their own memory slice until flattened_accesses_share_alias is cleared.\n-  \/\/ It could be the graph has no loads\/stores and flattened_accesses_share_alias is never cleared. EA could still\n+  \/\/ Flat array element shouldn't get their own memory slice until flat_accesses_share_alias is cleared.\n+  \/\/ It could be the graph has no loads\/stores and flat_accesses_share_alias is never cleared. EA could still\n@@ -1180,1 +1180,1 @@\n-         !Compile::current()->flattened_accesses_share_alias() ||\n+         !Compile::current()->flat_accesses_share_alias() ||\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1062,2 +1062,2 @@\n-  _has_flattened_accesses = false;\n-  _flattened_accesses_share_alias = true;\n+  _has_flat_accesses = false;\n+  _flat_accesses_share_alias = true;\n@@ -1439,1 +1439,1 @@\n-    if (ta->is_flat() && ta->elem() != TypeInstPtr::BOTTOM && _flattened_accesses_share_alias) {\n+    if (ta->is_flat() && ta->elem() != TypeInstPtr::BOTTOM && _flat_accesses_share_alias) {\n@@ -2066,2 +2066,2 @@\n-void Compile::adjust_flattened_array_access_aliases(PhaseIterGVN& igvn) {\n-  if (!_has_flattened_accesses) {\n+void Compile::adjust_flat_array_access_aliases(PhaseIterGVN& igvn) {\n+  if (!_has_flat_accesses) {\n@@ -2115,1 +2115,1 @@\n-    _flattened_accesses_share_alias = false;\n+    _flat_accesses_share_alias = false;\n@@ -2333,1 +2333,1 @@\n-  if (!_flattened_accesses_share_alias) {\n+  if (!_flat_accesses_share_alias) {\n@@ -2792,1 +2792,1 @@\n-  adjust_flattened_array_access_aliases(igvn);\n+  adjust_flat_array_access_aliases(igvn);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-  bool                  _has_circular_inline_type; \/\/ True if method loads an inline type with a circular, non-flattened field\n+  bool                  _has_circular_inline_type; \/\/ True if method loads an inline type with a circular, non-flat field\n@@ -352,2 +352,2 @@\n-  bool                  _has_flattened_accesses; \/\/ Any known flattened array accesses?\n-  bool                  _flattened_accesses_share_alias; \/\/ Initially all flattened array share a single slice\n+  bool                  _has_flat_accesses;     \/\/ Any known flat array accesses?\n+  bool                  _flat_accesses_share_alias; \/\/ Initially all flat array share a single slice\n@@ -668,3 +668,3 @@\n-  void          set_flattened_accesses()         { _has_flattened_accesses = true; }\n-  bool          flattened_accesses_share_alias() const { return _flattened_accesses_share_alias; }\n-  void          set_flattened_accesses_share_alias(bool z) { _flattened_accesses_share_alias = z; }\n+  void          set_flat_accesses()              { _has_flat_accesses = true; }\n+  bool          flat_accesses_share_alias() const { return _flat_accesses_share_alias; }\n+  void          set_flat_accesses_share_alias(bool z) { _flat_accesses_share_alias = z; }\n@@ -795,1 +795,1 @@\n-  void adjust_flattened_array_access_aliases(PhaseIterGVN& igvn);\n+  void adjust_flat_array_access_aliases(PhaseIterGVN& igvn);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3965,2 +3965,2 @@\n-        assert(C->flattened_accesses_share_alias(), \"should be set at parse time\");\n-        C->set_flattened_accesses_share_alias(false);\n+        assert(C->flat_accesses_share_alias(), \"should be set at parse time\");\n+        C->set_flat_accesses_share_alias(false);\n@@ -3977,1 +3977,1 @@\n-          \/\/ Compile::adjust_flattened_array_access_aliases().\n+          \/\/ Compile::adjust_flat_array_access_aliases().\n@@ -3980,1 +3980,1 @@\n-        C->set_flattened_accesses_share_alias(true);\n+        C->set_flat_accesses_share_alias(true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -244,2 +244,2 @@\n-  assert(!field->is_flattened() || field->type()->is_inlinetype(), \"must be an inline type\");\n-  return field->is_flattened();\n+  assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+  return field->is_flat();\n@@ -251,1 +251,1 @@\n-  assert(!field->is_flattened() || field->type()->is_inlinetype(), \"must be an inline type\");\n+  assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n@@ -462,1 +462,1 @@\n-    kit->C->set_flattened_accesses();\n+    kit->C->set_flat_accesses();\n@@ -893,1 +893,1 @@\n-    kit->C->set_flattened_accesses();\n+    kit->C->set_flat_accesses();\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2360,1 +2360,1 @@\n-        ciField* field = vk->get_non_flattened_field_by_offset(off);\n+        ciField* field = vk->get_non_flat_field_by_offset(off);\n@@ -2363,1 +2363,1 @@\n-          if (bt == T_ARRAY || bt == T_NARROWOOP || (bt == T_PRIMITIVE_OBJECT && !field->is_flattened())) {\n+          if (bt == T_ARRAY || bt == T_NARROWOOP || (bt == T_PRIMITIVE_OBJECT && !field->is_flat())) {\n@@ -2447,1 +2447,1 @@\n-      field = k->get_non_flattened_field_by_offset(off);\n+      field = k->get_non_flat_field_by_offset(off);\n@@ -2453,1 +2453,1 @@\n-    if (field != nullptr && bt == T_PRIMITIVE_OBJECT && !field->is_flattened()) {\n+    if (field != nullptr && bt == T_PRIMITIVE_OBJECT && !field->is_flat()) {\n@@ -2545,1 +2545,1 @@\n-    if (heap_base_oop != top() && field != nullptr && field->is_constant() && !field->is_flattened() && !mismatched) {\n+    if (heap_base_oop != top() && field != nullptr && field->is_constant() && !field->is_flat() && !mismatched) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -865,1 +865,1 @@\n-      assert(!field->is_flattened(), \"flattened inline type fields should not have safepoint uses\");\n+      assert(!field->is_flat(), \"flat inline type fields should not have safepoint uses\");\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3061,1 +3061,1 @@\n-        phase->C->flattened_accesses_share_alias()) {\n+        phase->C->flat_accesses_share_alias()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-  if (field->is_constant() && !field->is_flattened() &&\n+  if (field->is_constant() && !field->is_flat() &&\n@@ -152,1 +152,1 @@\n-  } else if (field->is_flattened()) {\n+  } else if (field->is_flat()) {\n@@ -238,1 +238,1 @@\n-  } else if (field->is_flattened()) {\n+  } else if (field->is_flat()) {\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-  bool is_inlined = InstanceKlass::cast(k1)->field_is_inlined(slot);\n+  bool is_flat = InstanceKlass::cast(k1)->field_is_flat(slot);\n@@ -433,1 +433,1 @@\n-  ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_inlined);\n+  ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_flat);\n@@ -1834,1 +1834,1 @@\n-  ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_inlined());\n+  ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_flat());\n@@ -1850,1 +1850,1 @@\n-  if (!jfieldIDWorkaround::is_inlined_jfieldID(fieldID)) {\n+  if (!jfieldIDWorkaround::is_flat_jfieldID(fieldID)) {\n@@ -1853,1 +1853,1 @@\n-    assert(k->is_instance_klass(), \"Only instance can have inlined fields\");\n+    assert(k->is_instance_klass(), \"Only instance can have flat fields\");\n@@ -1859,1 +1859,1 @@\n-    res = field_vklass->read_inlined_field(o, ik->field_offset(fd.index()), CHECK_NULL);\n+    res = field_vklass->read_flat_field(o, ik->field_offset(fd.index()), CHECK_NULL);\n@@ -1953,1 +1953,1 @@\n-  if (!jfieldIDWorkaround::is_inlined_jfieldID(fieldID)) {\n+  if (!jfieldIDWorkaround::is_flat_jfieldID(fieldID)) {\n@@ -1956,1 +1956,1 @@\n-    assert(k->is_instance_klass(), \"Only instances can have inlined fields\");\n+    assert(k->is_instance_klass(), \"Only instances can have flat fields\");\n@@ -1963,1 +1963,1 @@\n-    vklass->write_inlined_field(o, offset, v, CHECK);\n+    vklass->write_flat_field(o, offset, v, CHECK);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3035,1 +3035,1 @@\n-                                            src_st.field_descriptor().is_inlined());\n+                                            src_st.field_descriptor().is_flat());\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-  FLATTENED             = java_lang_invoke_MemberName::MN_FLATTENED,\n+  FLATTENED             = java_lang_invoke_MemberName::MN_FLAT_FIELD,\n@@ -358,1 +358,1 @@\n-  if (fd.is_inlined()) flags |= FLATTENED;;\n+  if (fd.is_flat()) flags |= FLATTENED;;\n@@ -1010,1 +1010,1 @@\n-    template(java_lang_invoke_MemberName,MN_FLATTENED) \\\n+    template(java_lang_invoke_MemberName,MN_FLAT_FIELD) \\\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-      assert(fd.is_inlined(), \"field not flat\");\n+      assert(fd.is_flat(), \"field not flat\");\n@@ -339,1 +339,1 @@\n-  return InstanceKlass::cast(k)->field_is_inlined(slot);\n+  return InstanceKlass::cast(k)->field_is_flat(slot);\n@@ -360,1 +360,1 @@\n-  oop v = vk->read_inlined_field(base_h(), offset, CHECK_NULL);\n+  oop v = vk->read_flat_field(base_h(), offset, CHECK_NULL);\n@@ -371,1 +371,1 @@\n-  vk->write_inlined_field(base, offset, v, CHECK);\n+  vk->write_flat_field(base, offset, v, CHECK);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1510,0 +1510,1 @@\n+  bool _is_flat;\n@@ -1511,5 +1512,1 @@\n-  ReassignedField() {\n-    _offset = 0;\n-    _type = T_ILLEGAL;\n-    _klass = nullptr;\n-  }\n+  ReassignedField() : _offset(0), _type(T_ILLEGAL), _klass(nullptr), _is_flat(false) { }\n@@ -1533,3 +1530,4 @@\n-        if (fs.signature()->is_Q_signature()) {\n-          if (fs.is_inlined()) {\n-            \/\/ Resolve klass of flattened inline type field\n+        if (fs.is_null_free_inline_type()) {\n+          if (fs.is_flat()) {\n+            field._is_flat = true;\n+            \/\/ Resolve klass of flat inline type field\n@@ -1538,1 +1536,1 @@\n-            field._type = T_OBJECT;\n+            field._type = T_OBJECT;  \/\/ Can be removed once Q-descriptors have been removed.\n@@ -1550,3 +1548,3 @@\n-    \/\/ Check for flattened inline type field before accessing the ScopeValue because it might not have any fields\n-    if (type == T_PRIMITIVE_OBJECT) {\n-      \/\/ Recursively re-assign flattened inline type fields\n+    \/\/ Check for flat inline type field before accessing the ScopeValue because it might not have any fields\n+    if (fields->at(i)._is_flat) {\n+      \/\/ Recursively re-assign flat inline type fields\n@@ -1647,1 +1645,1 @@\n-  assert(vk->flatten_array(), \"should only be used for flattened inline type arrays\");\n+  assert(vk->flatten_array(), \"should only be used for flat inline type arrays\");\n@@ -1650,1 +1648,1 @@\n-  \/\/ Initialize all elements of the flattened inline type array\n+  \/\/ Initialize all elements of the flat inline type array\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-  if (ft != T_PRIMITIVE_OBJECT) {\n+  if (!is_null_free_inline_type()) {\n@@ -163,0 +163,2 @@\n+    case T_ARRAY:\n+    case T_OBJECT:\n@@ -164,2 +166,3 @@\n-      if (is_inlined()) {\n-        \/\/ Print fields of inlined fields (recursively)\n+      if (is_flat()) { \/\/ only some inline types can be flat\n+        assert(is_null_free_inline_type(), \"Only null free inline type fields can be flat\");\n+        \/\/ Print fields of flat fields (recursively)\n@@ -169,1 +172,1 @@\n-        st->print_cr(\"Inline type field inlined '%s':\", vk->name()->as_C_string());\n+        st->print_cr(\"Flat inline type field '%s':\", vk->name()->as_C_string());\n@@ -174,3 +177,1 @@\n-      \/\/ inline type field not inlined, fall through\n-    case T_ARRAY:\n-    case T_OBJECT:\n+      \/\/ Not flat inline type field, fall through\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-  inline bool is_inlined()        const;\n-  inline bool is_inline_type()    const;\n+  inline bool is_flat()        const;\n+  inline bool is_null_free_inline_type()    const;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-inline bool fieldDescriptor::is_inlined()  const  { return field().field_flags().is_inlined(); }\n-inline bool fieldDescriptor::is_inline_type() const { return field_type() == T_PRIMITIVE_OBJECT; }\n+inline bool fieldDescriptor::is_flat()  const  { return field().field_flags().is_flat(); }\n+inline bool fieldDescriptor::is_null_free_inline_type() const { return field().field_flags().is_null_free_inline_type(); }\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-    inlined_bits           = 1,\n-    address_bits           = BitsPerWord - checked_bits - instance_bits - inlined_bits,\n+    flat_bits              = 1,\n+    address_bits           = BitsPerWord - checked_bits - instance_bits - flat_bits,\n@@ -65,2 +65,2 @@\n-    inlined_shift          = instance_shift + instance_bits,\n-    address_shift          = inlined_shift + inlined_bits,\n+    flat_shift             = instance_shift + instance_bits,\n+    address_shift          = flat_shift + flat_bits,\n@@ -73,1 +73,1 @@\n-    inlined_mask_in_place  = right_n_bits(inlined_bits) << inlined_shift,\n+    flat_mask_in_place     = right_n_bits(flat_bits) << flat_shift,\n@@ -116,1 +116,1 @@\n-  static bool is_inlined_jfieldID(jfieldID id) {\n+  static bool is_flat_jfieldID(jfieldID id) {\n@@ -118,1 +118,1 @@\n-    return ((as_uint & inlined_mask_in_place) != 0);\n+    return ((as_uint & flat_mask_in_place) != 0);\n@@ -121,1 +121,1 @@\n-  static jfieldID to_instance_jfieldID(Klass* k, int offset, bool inlined) {\n+  static jfieldID to_instance_jfieldID(Klass* k, int offset, bool is_flat) {\n@@ -124,2 +124,2 @@\n-    if (inlined) {\n-      as_uint |= inlined_mask_in_place;\n+    if (is_flat) {\n+      as_uint |= flat_mask_in_place;\n@@ -168,1 +168,1 @@\n-  static jfieldID to_jfieldID(InstanceKlass* k, int offset, bool is_static, bool inlined) {\n+  static jfieldID to_jfieldID(InstanceKlass* k, int offset, bool is_static, bool is_flat) {\n@@ -174,1 +174,1 @@\n-      return jfieldIDWorkaround::to_instance_jfieldID(k, offset, inlined);\n+      return jfieldIDWorkaround::to_instance_jfieldID(k, offset, is_flat);\n","filename":"src\/hotspot\/share\/runtime\/jfieldIDWorkaround.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-    return \"Print the layout of an instance of a class, including inlined fields. \"\n+    return \"Print the layout of an instance of a class, including flat fields. \"\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1060,1 +1060,1 @@\n-    return fld.field_descriptor().is_inlined();\n+    return fld.field_descriptor().is_flat();\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}