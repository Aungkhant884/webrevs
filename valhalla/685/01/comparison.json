{"files":[{"patch":"@@ -3867,10 +3867,32 @@\n-    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic() && return_value_is_used()) {\n-      \/\/ An inline type is returned as fields in multiple registers.\n-      \/\/ R0 either contains an oop if the inline type is buffered or a pointer\n-      \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero r0\n-      \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n-      \/\/ r0 &= (r0 & 1) - 1\n-      C2_MacroAssembler _masm(&cbuf);\n-      __ andr(rscratch1, r0, 0x1);\n-      __ sub(rscratch1, rscratch1, 0x1);\n-      __ andr(r0, r0, rscratch1);\n+    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic()) {\n+      if (!_method->signature()->returns_null_free_inline_type()) {\n+        \/\/ The last return value is not set by the callee but used to pass IsInit information to compiled code.\n+        \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n+        uint con = (tf()->range_cc()->cnt() - 1);\n+        for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+          ProjNode* proj = fast_out(i)->as_Proj();\n+          if (proj->_con == con) {\n+            \/\/ Set IsInit if r0 is non-null (a non-null value is returned buffered or scalarized)\n+            OptoReg::Name optoReg = ra_->get_reg_first(proj);\n+            VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n+            Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n+            __ cmp(r0, zr);\n+            __ cset(toReg, Assembler::NE);\n+            if (reg->is_stack()) {\n+              int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n+              __ str(toReg, Address(sp, st_off));\n+            }\n+            break;\n+          }\n+        }\n+      }\n+      if (return_value_is_used()) {\n+        \/\/ An inline type is returned as fields in multiple registers.\n+        \/\/ R0 either contains an oop if the inline type is buffered or a pointer\n+        \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero r0\n+        \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n+        \/\/ r0 &= (r0 & 1) - 1\n+        __ andr(rscratch1, r0, 0x1);\n+        __ sub(rscratch1, rscratch1, 0x1);\n+        __ andr(r0, r0, rscratch1);\n+      }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":32,"deletions":10,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -515,1 +515,1 @@\n-  if (InlineTypeReturnedAsFields && method->signature()->returns_null_free_inline_type()) {\n+  if (InlineTypeReturnedAsFields && method->return_type()->is_inlinetype()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -879,1 +879,1 @@\n-    \/\/ records the total frame size exluding the two words for saving FP and LR.\n+    \/\/ records the total frame size excluding the two words for saving FP and LR.\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -777,0 +777,1 @@\n+    \/\/ Check if we are returning an inline type and load its fields into registers\n@@ -778,9 +779,1 @@\n-    \/\/ Test if the return type is an inline type\n-    ldr(rscratch1, Address(rfp, frame::interpreter_frame_method_offset * wordSize));\n-    ldr(rscratch1, Address(rscratch1, Method::const_offset()));\n-    ldrb(rscratch1, Address(rscratch1, ConstMethod::result_type_offset()));\n-    cmpw(rscratch1, (u1) T_PRIMITIVE_OBJECT);\n-    br(Assembler::NE, skip);\n-\n-    \/\/ We are returning an inline type, load its fields into registers\n-    \/\/ Load fields from a buffered value with an inline class specific handler\n+    test_oop_is_not_inline_type(r0, rscratch2, skip);\n@@ -788,0 +781,1 @@\n+    \/\/ Load fields from a buffered value with an inline class specific handler\n@@ -791,0 +785,1 @@\n+    \/\/ Unpack handler can be null if inline type is not scalarizable in returns\n@@ -794,3 +789,14 @@\n-\n-    \/\/ call above kills sender esp in rscratch2. Reload it.\n-    ldr(rscratch2, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));\n+#ifdef ASSERT\n+    if (StressInlineTypeReturnedAsFields) {\n+      \/\/ TODO 8284443 Enable this for value class returns (L-type descriptor)\n+      Label skip_stress;\n+      ldr(rscratch1, Address(rfp, frame::interpreter_frame_method_offset * wordSize));\n+      ldr(rscratch1, Address(rscratch1, Method::const_offset()));\n+      ldrb(rscratch1, Address(rscratch1, ConstMethod::result_type_offset()));\n+      cmpw(rscratch1, (u1) T_PRIMITIVE_OBJECT);\n+      br(Assembler::NE, skip_stress);\n+      load_klass(r0, r0);\n+      orr(r0, r0, 1);\n+      bind(skip_stress);\n+    }\n+#endif\n@@ -798,0 +804,2 @@\n+    \/\/ Check above kills sender esp in rscratch2. Reload it.\n+    ldr(rscratch2, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1373,0 +1373,1 @@\n+  assert_different_registers(tmp, rscratch1);\n@@ -5614,0 +5615,1 @@\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n@@ -5787,1 +5789,0 @@\n-#ifdef ASSERT\n@@ -5789,0 +5790,1 @@\n+#ifdef ASSERT\n@@ -5792,1 +5794,4 @@\n-  Register tmp1 = r10, tmp2 = r11;\n+  Label L_null, L_notNull;\n+  \/\/ Don't use r14 as tmp because it's used for spilling (see MacroAssembler::spill_reg_for)\n+  Register tmp1 = r10;\n+  Register tmp2 = r11;\n@@ -5799,0 +5804,10 @@\n+  \/\/ Check if argument requires a null check\n+  bool null_check = false;\n+  VMReg nullCheckReg;\n+  while (stream.next(nullCheckReg, bt)) {\n+    if (sig->at(stream.sig_index())._offset == -1) {\n+      null_check = true;\n+      break;\n+    }\n+  }\n+  stream.reset(sig_index, to_index);\n@@ -5801,3 +5816,0 @@\n-    int off = sig->at(stream.sig_index())._offset;\n-    assert(off > 0, \"offset in object should be positive\");\n-\n@@ -5816,1 +5828,1 @@\n-    DEBUG_ONLY(progress = true);\n+    progress = true;\n@@ -5826,0 +5838,4 @@\n+      if (null_check) {\n+        \/\/ Nullable inline type argument, emit null check\n+        cbz(fromReg, L_null);\n+      }\n@@ -5827,0 +5843,13 @@\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      assert(null_check, \"Missing null check at\");\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        mov(tmp2, 1);\n+        str(tmp2, Address(sp, st_off));\n+      } else {\n+        mov(toReg->as_Register(), 1);\n+      }\n+      continue;\n+    }\n+    assert(off > 0, \"offset in object should be positive\");\n@@ -5847,0 +5876,24 @@\n+  if (progress && null_check) {\n+    if (done) {\n+      b(L_notNull);\n+      bind(L_null);\n+      \/\/ Set IsInit field to zero to signal that the argument is null.\n+      \/\/ Also set all oop fields to zero to make the GC happy.\n+      stream.reset(sig_index, to_index);\n+      while (stream.next(toReg, bt)) {\n+        if (sig->at(stream.sig_index())._offset == -1 ||\n+            bt == T_OBJECT || bt == T_ARRAY) {\n+          if (toReg->is_stack()) {\n+            int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+            str(zr, Address(sp, st_off));\n+          } else {\n+            mov(toReg->as_Register(), zr);\n+          }\n+        }\n+      }\n+      bind(L_notNull);\n+    } else {\n+      bind(L_null);\n+    }\n+  }\n+\n@@ -5875,0 +5928,2 @@\n+  \/\/ TODO 8284443 Isn't it an issue if below code uses r14 as tmp when it contains a spilled value?\n+  \/\/ Be careful with r14 because it's used for spilling (see MacroAssembler::spill_reg_for).\n@@ -5898,0 +5953,1 @@\n+  Label L_null;\n@@ -5900,0 +5956,2 @@\n+    reg_state[fromReg->value()] = reg_writable;\n+\n@@ -5901,0 +5959,16 @@\n+    if (off == -1) {\n+      \/\/ Nullable inline type argument, emit null check\n+      Label L_notNull;\n+      if (fromReg->is_stack()) {\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        ldr(tmp2, Address(sp, ld_off));\n+        cbnz(tmp2, L_notNull);\n+      } else {\n+        cbnz(fromReg->as_Register(), L_notNull);\n+      }\n+      mov(val_obj, 0);\n+      b(L_null);\n+      bind(L_notNull);\n+      continue;\n+    }\n+\n@@ -5928,1 +6002,0 @@\n-    reg_state[fromReg->value()] = reg_writable;\n@@ -5930,0 +6003,1 @@\n+  bind(L_null);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":81,"deletions":7,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -755,0 +755,1 @@\n+      Label L_null;\n@@ -767,0 +768,16 @@\n+          if (off == -1) {\n+            \/\/ Nullable inline type argument, emit null check\n+            VMReg reg = regs[next_arg_comp-ignored].first();\n+            Label L_notNull;\n+            if (reg->is_stack()) {\n+              int ld_off = reg->reg2stack() * VMRegImpl::stack_slot_size + extraspace;\n+              __ ldr(tmp1, Address(sp, ld_off));\n+              __ cbnz(tmp1, L_notNull);\n+            } else {\n+              __ cbnz(reg->as_Register(), L_notNull);\n+            }\n+            __ str(zr, Address(sp, st_off));\n+            __ b(L_null);\n+            __ bind(L_notNull);\n+            continue;\n+          }\n@@ -776,0 +793,1 @@\n+      __ bind(L_null);\n@@ -3307,0 +3325,3 @@\n+  Label skip;\n+  __ cbz(r0, skip);\n+\n@@ -3344,4 +3365,1 @@\n-  if (StressInlineTypeReturnedAsFields) {\n-    __ load_klass(r0, r0);\n-    __ orr(r0, r0, 1);\n-  }\n+  __ bind(skip);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -322,1 +322,1 @@\n-    Label is_long, is_float, is_double, is_value, exit;\n+    Label is_long, is_float, is_double, check_prim, exit;\n@@ -325,1 +325,1 @@\n-    __ br(Assembler::EQ, is_long);\n+    __ br(Assembler::EQ, check_prim);\n@@ -327,1 +327,1 @@\n-    __ br(Assembler::EQ, is_value);\n+    __ br(Assembler::EQ, check_prim);\n@@ -382,1 +382,1 @@\n-    __ BIND(is_value);\n+    __ BIND(check_prim);\n@@ -384,1 +384,1 @@\n-      \/\/ Check for flattened return value\n+      \/\/ Check for scalarized return value\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -537,1 +537,1 @@\n-  if (InlineTypeReturnedAsFields && method->signature()->returns_null_free_inline_type()) {\n+  if (InlineTypeReturnedAsFields && method->return_type()->is_inlinetype()) {\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1179,0 +1179,1 @@\n+    \/\/ Check if we are returning an inline type and load its fields into registers\n@@ -1180,8 +1181,2 @@\n-    \/\/ Test if the return type is an inline type\n-    movptr(rdi, Address(rbp, frame::interpreter_frame_method_offset * wordSize));\n-    movptr(rdi, Address(rdi, Method::const_offset()));\n-    load_unsigned_byte(rdi, Address(rdi, ConstMethod::result_type_offset()));\n-    cmpl(rdi, T_PRIMITIVE_OBJECT);\n-    jcc(Assembler::notEqual, skip);\n-\n-    \/\/ We are returning an inline type, load its fields into registers\n+    test_oop_is_not_inline_type(rax, rscratch1, skip);\n+\n@@ -1192,2 +1187,1 @@\n-    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-    load_klass(rdi, rax, tmp_load_klass);\n+    load_klass(rdi, rax, rscratch1);\n@@ -1196,1 +1190,1 @@\n-\n+    \/\/ Unpack handler can be null if inline type is not scalarizable in returns\n@@ -1198,2 +1192,1 @@\n-    jcc(Assembler::equal, skip);\n-\n+    jcc(Assembler::zero, skip);\n@@ -1201,0 +1194,14 @@\n+#endif\n+#ifdef ASSERT\n+    if (StressInlineTypeReturnedAsFields) {\n+      \/\/ TODO 8284443 Enable this for value class returns (L-type descriptor)\n+      Label skip_stress;\n+      movptr(rscratch1, Address(rbp, frame::interpreter_frame_method_offset * wordSize));\n+      movptr(rscratch1, Address(rscratch1, Method::const_offset()));\n+      load_unsigned_byte(rscratch1, Address(rscratch1, ConstMethod::result_type_offset()));\n+      cmpl(rscratch1, T_PRIMITIVE_OBJECT);\n+      jcc(Assembler::notEqual, skip_stress);\n+      load_klass(rax, rax, rscratch1);\n+      orptr(rax, 1);\n+      bind(skip_stress);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2757,1 +2757,1 @@\n-  jcc(Assembler::equal, not_inline_type);\n+  jcc(Assembler::zero, not_inline_type);\n@@ -5674,0 +5674,1 @@\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n@@ -5836,1 +5837,0 @@\n-#ifdef ASSERT\n@@ -5838,0 +5838,1 @@\n+#ifdef ASSERT\n@@ -5841,0 +5842,4 @@\n+  Label L_null, L_notNull;\n+  \/\/ Don't use r14 as tmp because it's used for spilling (see MacroAssembler::spill_reg_for)\n+  Register tmp1 = r10;\n+  Register tmp2 = r13;\n@@ -5847,0 +5852,10 @@\n+  \/\/ Check if argument requires a null check\n+  bool null_check = false;\n+  VMReg nullCheckReg;\n+  while (stream.next(nullCheckReg, bt)) {\n+    if (sig->at(stream.sig_index())._offset == -1) {\n+      null_check = true;\n+      break;\n+    }\n+  }\n+  stream.reset(sig_index, to_index);\n@@ -5849,3 +5864,0 @@\n-    int off = sig->at(stream.sig_index())._offset;\n-    assert(off > 0, \"offset in object should be positive\");\n-\n@@ -5864,1 +5876,1 @@\n-    DEBUG_ONLY(progress = true);\n+    progress = true;\n@@ -5871,2 +5883,7 @@\n-        movq(r10, Address(rsp, st_off));\n-        fromReg = r10;\n+        movq(tmp1, Address(rsp, st_off));\n+        fromReg = tmp1;\n+      }\n+      if (null_check) {\n+        \/\/ Nullable inline type argument, emit null check\n+        testptr(fromReg, fromReg);\n+        jcc(Assembler::zero, L_null);\n@@ -5875,0 +5892,12 @@\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      assert(null_check, \"Missing null check at\");\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        movq(Address(rsp, st_off), 1);\n+      } else {\n+        movq(toReg->as_Register(), 1);\n+      }\n+      continue;\n+    }\n+    assert(off > 0, \"offset in object should be positive\");\n@@ -5877,1 +5906,1 @@\n-      Register dst = toReg->is_stack() ? r13 : toReg->as_Register();\n+      Register dst = toReg->is_stack() ? tmp2 : toReg->as_Register();\n@@ -5895,0 +5924,24 @@\n+  if (progress && null_check) {\n+    if (done) {\n+      jmp(L_notNull);\n+      bind(L_null);\n+      \/\/ Set IsInit field to zero to signal that the argument is null.\n+      \/\/ Also set all oop fields to zero to make the GC happy.\n+      stream.reset(sig_index, to_index);\n+      while (stream.next(toReg, bt)) {\n+        if (sig->at(stream.sig_index())._offset == -1 ||\n+            bt == T_OBJECT || bt == T_ARRAY) {\n+          if (toReg->is_stack()) {\n+            int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+            movq(Address(rsp, st_off), 0);\n+          } else {\n+            xorq(toReg->as_Register(), toReg->as_Register());\n+          }\n+        }\n+      }\n+      bind(L_notNull);\n+    } else {\n+      bind(L_null);\n+    }\n+  }\n+\n@@ -5918,0 +5971,2 @@\n+  \/\/ TODO 8284443 Isn't it an issue if below code uses r14 as tmp when it contains a spilled value?\n+  \/\/ Be careful with r14 because it's used for spilling (see MacroAssembler::spill_reg_for).\n@@ -5919,1 +5974,1 @@\n-  Register from_reg_tmp = r14; \/\/ Be careful with r14 because it's used for spilling\n+  Register from_reg_tmp = r14;\n@@ -5941,0 +5996,1 @@\n+  Label L_null;\n@@ -5943,0 +5999,2 @@\n+    reg_state[fromReg->value()] = reg_writable;\n+\n@@ -5944,0 +6002,16 @@\n+    if (off == -1) {\n+      \/\/ Nullable inline type argument, emit null check\n+      Label L_notNull;\n+      if (fromReg->is_stack()) {\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size + wordSize;\n+        testb(Address(rsp, ld_off), 1);\n+      } else {\n+        testb(fromReg->as_Register(), 1);\n+      }\n+      jcc(Assembler::notZero, L_notNull);\n+      movptr(val_obj, 0);\n+      jmp(L_null);\n+      bind(L_notNull);\n+      continue;\n+    }\n+\n@@ -5969,1 +6043,0 @@\n-    reg_state[fromReg->value()] = reg_writable;\n@@ -5971,0 +6044,1 @@\n+  bind(L_null);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":85,"deletions":11,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -924,0 +924,1 @@\n+      Label L_null;\n@@ -938,0 +939,16 @@\n+          if (off == -1) {\n+            \/\/ Nullable inline type argument, emit null check\n+            VMReg reg = regs[next_arg_comp-ignored].first();\n+            Label L_notNull;\n+            if (reg->is_stack()) {\n+              int ld_off = reg->reg2stack() * VMRegImpl::stack_slot_size + extraspace;\n+              __ testb(Address(rsp, ld_off), 1);\n+            } else {\n+              __ testb(reg->as_Register(), 1);\n+            }\n+            __ jcc(Assembler::notZero, L_notNull);\n+            __ movptr(Address(rsp, st_off), 0);\n+            __ jmp(L_null);\n+            __ bind(L_notNull);\n+            continue;\n+          }\n@@ -947,0 +964,1 @@\n+      __ bind(L_null);\n@@ -4059,0 +4077,4 @@\n+  Label skip;\n+  __ testptr(rax, rax);\n+  __ jcc(Assembler::zero, skip);\n+\n@@ -4095,5 +4117,1 @@\n-  if (StressInlineTypeReturnedAsFields) {\n-    __ load_klass(rax, rax, rscratch1);\n-    __ orptr(rax, 1);\n-  }\n-\n+  __ bind(skip);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-    Label is_long, is_float, is_double, is_value, exit;\n+    Label is_long, is_float, is_double, check_prim, exit;\n@@ -355,1 +355,1 @@\n-    __ jcc(Assembler::equal, is_long);\n+    __ jcc(Assembler::equal, check_prim);\n@@ -357,1 +357,1 @@\n-    __ jcc(Assembler::equal, is_value);\n+    __ jcc(Assembler::equal, check_prim);\n@@ -428,1 +428,1 @@\n-    __ BIND(is_value);\n+    __ BIND(check_prim);\n@@ -430,1 +430,1 @@\n-      \/\/ Check for flattened return value\n+      \/\/ Check for scalarized return value\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2651,6 +2651,1 @@\n-    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic() && return_value_is_used()) {\n-      \/\/ An inline type is returned as fields in multiple registers.\n-      \/\/ Rax either contains an oop if the inline type is buffered or a pointer\n-      \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero rax\n-      \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n-      \/\/ rax &= (rax & 1) - 1\n+    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic()) {\n@@ -2658,4 +2653,33 @@\n-      __ movptr(rscratch1, rax);\n-      __ andptr(rscratch1, 0x1);\n-      __ subptr(rscratch1, 0x1);\n-      __ andptr(rax, rscratch1);\n+      if (!_method->signature()->returns_null_free_inline_type()) {\n+        \/\/ The last return value is not set by the callee but used to pass IsInit information to compiled code.\n+        \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n+        uint con = (tf()->range_cc()->cnt() - 1);\n+        for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+          ProjNode* proj = fast_out(i)->as_Proj();\n+          if (proj->_con == con) {\n+            \/\/ Set IsInit if rax is non-null (a non-null value is returned buffered or scalarized)\n+            OptoReg::Name optoReg = ra_->get_reg_first(proj);\n+            VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n+            Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n+            __ testq(rax, rax);\n+            __ set_byte_if_not_zero(toReg);\n+            __ movzbl(toReg, toReg);\n+            if (reg->is_stack()) {\n+              int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n+              __ movq(Address(rsp, st_off), toReg);\n+            }\n+            break;\n+          }\n+        }\n+      }\n+      if (return_value_is_used()) {\n+        \/\/ An inline type is returned as fields in multiple registers.\n+        \/\/ Rax either contains an oop if the inline type is buffered or a pointer\n+        \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero rax\n+        \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n+        \/\/ rax &= (rax & 1) - 1\n+        __ movptr(rscratch1, rax);\n+        __ andptr(rscratch1, 0x1);\n+        __ subptr(rscratch1, 0x1);\n+        __ andptr(rax, rscratch1);\n+      }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -592,1 +592,1 @@\n-    _compiled_entry_signature.compute_calling_conventions();\n+    _compiled_entry_signature.compute_calling_conventions(false);\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2139,0 +2139,1 @@\n+  null_check(obj);\n@@ -2825,1 +2826,1 @@\n-  if (value->as_NewArray() != NULL || value->as_NewInstance() != NULL || value->as_NewInlineTypeInstance()) {\n+  if (value->as_NewArray() != NULL || value->as_NewInstance() != NULL || value->as_NewInlineTypeInstance() != NULL) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1079,4 +1079,2 @@\n-  if (InlineTypeReturnedAsFields &&\n-      (method()->signature()->returns_null_free_inline_type() ||\n-       method()->is_method_handle_intrinsic())) {\n-    ciType* return_type = method()->return_type();\n+  ciType* return_type = method()->return_type();\n+  if (InlineTypeReturnedAsFields) {\n@@ -1091,9 +1089,11 @@\n-    } else if (return_type->is_instance_klass()) {\n-      \/\/ An inline type might be returned from the call but we don't know its\n-      \/\/ type. Either we get a buffered inline type (and nothing needs to be done)\n-      \/\/ or one of the inlines being returned is the klass of the inline type\n-      \/\/ (RAX on x64, with LSB set to 1) and we need to allocate an inline\n-      \/\/ type instance of that type and initialize it with other values being\n-      \/\/ returned (in other registers).\n-      assert(!return_type->as_instance_klass()->is_loaded() ||\n-             method()->is_method_handle_intrinsic(), \"unexpected return type\");\n+    } else if (return_type->is_instance_klass() &&\n+               (method()->is_method_handle_intrinsic() ||\n+                (!return_type->is_loaded() && !method()->holder()->is_loaded()))) {\n+      \/\/ An inline type might be returned from the call but we don't know its type.\n+      \/\/ This can happen with method handle intrinsics or when both the return type\n+      \/\/ and the method holder are unloaded (and therefore the preload logic did not\n+      \/\/ get a chance to load the return type). If an inline type is returned, we\n+      \/\/ either get an oop to a buffer and nothing needs to be done or one of the\n+      \/\/ values being returned is the klass of the inline type (RAX on x64, with LSB\n+      \/\/ set to 1) and we need to allocate an inline type instance of that type and\n+      \/\/ initialize it with other values being returned (in other registers).\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1537,0 +1537,5 @@\n+bool ciMethod::is_scalarized_arg(int idx) const {\n+  VM_ENTRY_MARK;\n+  return get_Method()->is_scalarized_arg(idx);\n+}\n+\n@@ -1542,1 +1547,1 @@\n-const GrowableArray<SigEntry>* ciMethod::get_sig_cc() {\n+const GrowableArray<SigEntry>* ciMethod::get_sig_cc() const {\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -395,0 +395,1 @@\n+  bool is_scalarized_arg(int idx) const;\n@@ -396,1 +397,1 @@\n-  const GrowableArray<SigEntry>* get_sig_cc();\n+  const GrowableArray<SigEntry>* get_sig_cc() const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-  assert(InlineTypeReturnedAsFields, \"inconsistent\");\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -169,0 +169,10 @@\n+bool InstanceKlass::is_preload_class(Symbol* name) const {\n+  for (int i = 0; i < _preload_classes->length(); i++) {\n+    Symbol* class_name = _constants->klass_at_noresolve(_preload_classes->at(i));\n+    if (class_name == name) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -571,0 +571,1 @@\n+  bool is_preload_class(Symbol* name) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -682,1 +682,3 @@\n-InlineKlass* Method::returned_inline_type(Thread* thread) const {\n+InlineKlass* Method::returns_inline_type(Thread* thread) const {\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n+  NoSafepointVerifier nsv;\n@@ -687,9 +689,1 @@\n-  Handle class_loader(thread, method_holder()->class_loader());\n-  Handle protection_domain(thread, method_holder()->protection_domain());\n-  Klass* k = NULL;\n-  {\n-    NoSafepointVerifier nsv;\n-    k = ss.as_klass(class_loader, protection_domain, SignatureStream::ReturnNull, JavaThread::cast(thread));\n-  }\n-  assert(k != NULL && !thread->has_pending_exception(), \"can't resolve klass\");\n-  return InlineKlass::cast(k);\n+  return ss.as_inline_klass(method_holder());\n@@ -2384,0 +2378,25 @@\n+bool Method::is_scalarized_arg(int idx) const {\n+  if (!has_scalarized_args()) {\n+    return false;\n+  }\n+  \/\/ Search through signature and check if argument is wrapped in T_PRIMITIVE_OBJECT\/T_VOID\n+  int depth = 0;\n+  const GrowableArray<SigEntry>* sig = adapter()->get_sig_cc();\n+  for (int i = 0; i < sig->length(); i++) {\n+    BasicType bt = sig->at(i)._bt;\n+    if (bt == T_PRIMITIVE_OBJECT) {\n+      depth++;\n+    }\n+    if (idx == 0) {\n+      break; \/\/ Argument found\n+    }\n+    if (bt == T_VOID && (sig->at(i-1)._bt != T_LONG && sig->at(i-1)._bt != T_DOUBLE)) {\n+      depth--;\n+    }\n+    if (depth == 0 && bt != T_LONG && bt != T_DOUBLE) {\n+      idx--; \/\/ Advance to next argument\n+    }\n+  }\n+  return depth != 0;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -590,1 +590,1 @@\n-  InlineKlass* returned_inline_type(Thread* thread) const;\n+  InlineKlass* returns_inline_type(Thread* thread) const;\n@@ -905,0 +905,2 @@\n+  bool is_scalarized_arg(int idx) const;\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -778,0 +778,1 @@\n+    int arg_num = 0;\n@@ -780,1 +781,1 @@\n-      if (method()->has_scalarized_args() && t->is_inlinetypeptr() && !t->maybe_null() && t->inline_klass()->can_be_passed_as_fields()) {\n+      if (t->is_inlinetypeptr() && method()->is_scalarized_arg(arg_num)) {\n@@ -784,1 +785,1 @@\n-        InlineTypeNode* vt = InlineTypeNode::make_from_multi(&arg_kit, call, t->inline_klass(), j, true);\n+        Node* vt = InlineTypeNode::make_from_multi(&arg_kit, call, t->inline_klass(), j, \/* in= *\/ true, \/* null_free= *\/ !t->maybe_null());\n@@ -790,0 +791,3 @@\n+      if (t != Type::HALF) {\n+        arg_num++;\n+      }\n@@ -809,2 +813,2 @@\n-    if (is_mh_late_inline() && inline_method->signature()->returns_null_free_inline_type() &&\n-        return_type->as_inline_klass()->can_be_returned_as_fields()) {\n+    if (!call->tf()->returns_inline_type_as_fields() && is_mh_late_inline() &&\n+        return_type->is_inlinetype() && return_type->as_inline_klass()->can_be_returned_as_fields()) {\n@@ -856,1 +860,1 @@\n-    InlineTypeNode* vt = result->isa_InlineType();\n+    InlineTypeBaseNode* vt = result->isa_InlineTypeBase();\n@@ -859,2 +863,2 @@\n-        vt->replace_call_results(&kit, call, C);\n-      } else {\n+        vt->replace_call_results(&kit, call, C, inline_method->signature()->returns_null_free_inline_type());\n+      } else if (vt->is_InlineType()) {\n@@ -864,0 +868,14 @@\n+          RegionNode* region = new RegionNode(3);\n+\n+          \/\/ Check if result is null\n+          Node* null_ctl = kit.top();\n+          if (!inline_method->signature()->returns_null_free_inline_type()) {\n+            kit.null_check_common(vt->get_is_init(), T_INT, false, &null_ctl);\n+          }\n+          region->init_req(1, null_ctl);\n+          PhiNode* oop = PhiNode::make(region, kit.gvn().zerocon(T_OBJECT), TypeInstPtr::make(TypePtr::BotPTR, vt->type()->inline_klass()));\n+          Node* init_mem = kit.reset_memory();\n+          PhiNode* mem = PhiNode::make(region, init_mem, Type::MEMORY, TypePtr::BOTTOM);\n+\n+          \/\/ Not null, initialize the buffer\n+          kit.set_all_memory(init_mem);\n@@ -870,0 +888,5 @@\n+          region->init_req(2, kit.control());\n+          oop->init_req(2, buffer_oop);\n+          mem->init_req(2, kit.merged_memory());\n+\n+          \/\/ Update oop input to buffer\n@@ -871,2 +894,8 @@\n-          vt->set_oop(buffer_oop);\n-          vt = kit.gvn().transform(vt)->as_InlineType();\n+          vt->set_oop(kit.gvn().transform(oop));\n+          vt = kit.gvn().transform(vt)->as_InlineTypeBase();\n+\n+          kit.set_control(kit.gvn().transform(region));\n+          kit.set_all_memory(kit.gvn().transform(mem));\n+          kit.record_for_igvn(region);\n+          kit.record_for_igvn(oop);\n+          kit.record_for_igvn(mem);\n@@ -874,3 +903,1 @@\n-        DEBUG_ONLY(buffer_oop = NULL);\n-        \/\/ Convert to InlineTypePtrNode to keep track of field values\n-        result = vt->as_ptr(&kit.gvn());\n+        result = vt->as_ptr(&kit.gvn(), inline_method->signature()->returns_null_free_inline_type());\n@@ -878,0 +905,3 @@\n+      DEBUG_ONLY(buffer_oop = NULL);\n+    } else {\n+      assert(result->is_top() || !call->tf()->returns_inline_type_as_fields(), \"Unexpected return value\");\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":42,"deletions":12,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -1955,1 +1955,1 @@\n-      cast->set_req(1, n->as_InlineTypePtr()->get_oop());\n+      cast->set_req_X(1, n->as_InlineTypePtr()->get_oop(), phase);\n@@ -2494,0 +2494,11 @@\n+    \/\/ TODO 8284443 We need to prevent endless pushing through\n+    \/\/ TestLWorld -XX:+UseZGC -DScenarios=0 -DTest=test69\n+    \/\/ TestLWorld -XX:-TieredCompilation -XX:-DoEscapeAnalysis -XX:+AlwaysIncrementalInline\n+    for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+      Node* n = fast_out(i);\n+      if (n->is_InlineTypePtr() && n->in(1) == this) {\n+        can_optimize = false;\n+        break;\n+      }\n+    }\n+    \/\/ TODO 8284443 We could revisit the same node over and over again, right?\n@@ -2503,0 +2514,5 @@\n+          if (n->in(0) != NULL && n->in(0)->is_top()) {\n+            \/\/ Will die, don't optimize\n+            can_optimize = false;\n+            break;\n+          }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -851,0 +851,6 @@\n+  \/\/ TODO 8284443 Only reserve extra slot if needed\n+  if (InlineTypeReturnedAsFields) {\n+    \/\/ One extra slot to hold the IsInit information for a nullable\n+    \/\/ inline type return if we run out of registers.\n+    next_slot += 2;\n+  }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    \/\/ Null checking a scalarized but nullable inline type. Check the is_init\n+    \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1256,2 +1256,17 @@\n-  if (value->is_InlineTypePtr()) {\n-    \/\/ Null checking a scalarized but nullable inline type. Check the is_init\n+  if (value->is_InlineType()) {\n+    InlineTypeNode* vt = value->as_InlineType();\n+    null_check_common(vt->get_is_init(), T_INT, assert_null, null_control, speculative, true);\n+    if (stopped()) {\n+      return top();\n+    }\n+    if (assert_null) {\n+      \/\/ TODO 8284443 Scalarize here (this currently leads to compilation bailouts)\n+      \/\/ vt = InlineTypeNode::make_null(_gvn, vt->type()->inline_klass());\n+      \/\/ replace_in_map(value, vt);\n+      \/\/ return vt;\n+      return null();\n+    }\n+    bool do_replace_in_map = (null_control == NULL || (*null_control) == top());\n+    return cast_not_null(value, do_replace_in_map);\n+  } else if (value->is_InlineTypePtr()) {\n+    \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n@@ -1268,3 +1283,5 @@\n-      vtptr = InlineTypePtrNode::make_null(_gvn, vtptr->type()->inline_klass());\n-      replace_in_map(value, vtptr);\n-      return vtptr;\n+      \/\/ TODO 8284443 Scalarize here (this currently leads to compilation bailouts)\n+      \/\/ vtptr = InlineTypePtrNode::make_null(_gvn, vtptr->type()->inline_klass());\n+      \/\/ replace_in_map(value, vtptr);\n+      \/\/ return vtptr;\n+      return null();\n@@ -1457,1 +1474,7 @@\n-    return obj;\n+    InlineTypeNode* vt = obj->clone()->as_InlineType();\n+    vt->set_is_init(_gvn);\n+    vt = _gvn.transform(vt)->as_InlineType();\n+    if (do_replace_in_map) {\n+      replace_in_map(obj, vt);\n+    }\n+    return vt;\n@@ -1859,0 +1882,1 @@\n+  int arg_num = 0;\n@@ -1862,1 +1886,1 @@\n-    if (call->method()->has_scalarized_args() && t->is_inlinetypeptr() && !t->maybe_null() && t->inline_klass()->can_be_passed_as_fields()) {\n+    if (t->is_inlinetypeptr() && call->method()->is_scalarized_arg(arg_num)) {\n@@ -1864,0 +1888,4 @@\n+      if (!arg->is_InlineTypeBase()) {\n+        assert(_gvn.type(arg)->is_zero_type() && !t->inline_klass()->is_null_free(), \"Unexpected argument type\");\n+        arg = InlineTypeNode::make_from_oop(this, arg, t->inline_klass(), t->inline_klass()->is_null_free());\n+      }\n@@ -1865,1 +1893,1 @@\n-      vt->pass_fields(this, call, idx);\n+      vt->pass_fields(this, call, idx, true, !t->maybe_null());\n@@ -1870,0 +1898,1 @@\n+      arg_num++;\n@@ -1878,0 +1907,3 @@\n+    if (t != Type::HALF) {\n+      arg_num++;\n+    }\n@@ -1938,1 +1970,1 @@\n-    ret = InlineTypeNode::make_from_multi(this, call, vk, base_input, false);\n+    ret = InlineTypeNode::make_from_multi(this, call, vk, base_input, false, call->method()->signature()->returns_null_free_inline_type());\n@@ -3397,1 +3429,6 @@\n-  Node* not_null_obj = is_value ? obj : null_check_oop(obj, &null_ctl, never_see_null, safe_for_replace, speculative_not_null);\n+  if (is_value) {\n+    \/\/ TODO 8284443 Enable this\n+    safe_for_replace = false;\n+    never_see_null = false;\n+  }\n+  Node* not_null_obj = null_check_oop(obj, &null_ctl, never_see_null, safe_for_replace, speculative_not_null);\n@@ -3510,6 +3547,0 @@\n-          if (null_free) {\n-            assert(safe_for_replace, \"must be\");\n-            obj = null_check(obj);\n-          }\n-          assert(stopped() || !toop->is_inlinetypeptr() ||\n-                 obj->is_InlineTypeBase(), \"should have been scalarized\");\n@@ -3517,0 +3548,5 @@\n+        if (null_free) {\n+          assert(safe_for_replace, \"must be\");\n+          obj = null_check(obj);\n+        }\n+        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineTypeBase(), \"should have been scalarized\");\n@@ -3519,6 +3555,7 @@\n-        if (from_inline || null_free) {\n-          if (!from_inline) {\n-            assert(safe_for_replace, \"must be\");\n-            null_check(obj);\n-          }\n-          \/\/ Inline type is null-free. Always throw an exception.\n+        if (null_free) {\n+          assert(safe_for_replace, \"must be\");\n+          obj = null_check(obj);\n+        }\n+        \/\/ It needs a null check because a null will *pass* the cast check.\n+        const TypeOopPtr* objtp = _gvn.type(obj)->isa_oopptr();\n+        if (objtp != NULL && !objtp->maybe_null()) {\n@@ -3530,13 +3567,2 @@\n-        } else {\n-          \/\/ It needs a null check because a null will *pass* the cast check.\n-          const TypeOopPtr* objtp = _gvn.type(obj)->isa_oopptr();\n-          if (!objtp->maybe_null()) {\n-            bool is_aastore = (java_bc() == Bytecodes::_aastore);\n-            Deoptimization::DeoptReason reason = is_aastore ?\n-              Deoptimization::Reason_array_check : Deoptimization::Reason_class_check;\n-            builtin_throw(reason, makecon(TypeKlassPtr::make(objtp->klass())));\n-            return top();\n-          } else if (!too_many_traps_or_recompiles(Deoptimization::Reason_null_assert)) {\n-            return null_assert(obj);\n-          }\n-          break; \/\/ Fall through to full check\n+        } else if (!too_many_traps_or_recompiles(Deoptimization::Reason_null_assert)) {\n+          return null_assert(obj);\n@@ -3544,0 +3570,1 @@\n+        break; \/\/ Fall through to full check\n@@ -3575,3 +3602,1 @@\n-  if (from_inline) {\n-    not_null_obj = obj;\n-  } else if (null_free) {\n+  if (null_free) {\n@@ -3580,0 +3605,3 @@\n+  } else if (from_inline) {\n+    \/\/ TODO 8284443 obj can be null and null should pass\n+    not_null_obj = obj;\n@@ -3587,0 +3615,3 @@\n+    if (toop->is_inlinetypeptr()) {\n+      return InlineTypePtrNode::make_null(_gvn, toop->inline_klass());\n+    }\n@@ -3763,4 +3794,0 @@\n-  const Type* val_t = _gvn.type(val);\n-  if (val->is_InlineType() || !TypePtr::NULL_PTR->higher_equal(val_t)) {\n-    return ary; \/\/ Never null\n-  }\n@@ -3785,1 +3812,1 @@\n-  if (val_t == TypePtr::NULL_PTR) {\n+  if (_gvn.type(val) == TypePtr::NULL_PTR) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":70,"deletions":43,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -376,1 +376,0 @@\n-    assert(argument(0)->bottom_type()->isa_ptr(), \"must be\");\n@@ -700,3 +699,0 @@\n-    if (argument(0)->is_InlineType()) {\n-      return argument(0);\n-    }\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-  assert(!(recursive && value->is_InlineType()), \"should not be an inline type\");\n+  assert(!(recursive && value->is_InlineTypeBase()), \"should not be an inline type\");\n@@ -263,1 +263,1 @@\n-  \/\/ Nullable inline types have an is_init field that needs\n+  \/\/ Nullable inline types have an IsInit field that needs\n@@ -297,1 +297,1 @@\n-                 (oop->is_Con() || oop->is_Load() || (oop->isa_DecodeN() && oop->in(1)->is_Load()));\n+                 (oop->is_Con() || oop->is_Parm() || oop->is_Load() || (oop->isa_DecodeN() && oop->in(1)->is_Load()));\n@@ -366,1 +366,1 @@\n-    if (ft->is_inlinetype() && ft->as_inline_klass()->is_empty()) {\n+    if (null_free && ft->as_inline_klass()->is_empty()) {\n@@ -433,2 +433,1 @@\n-      if (!value->is_InlineType()) {\n-        assert(!kit->gvn().type(value)->maybe_null(), \"Inline types are null-free\");\n+      if (!value->is_InlineTypeBase()) {\n@@ -437,1 +436,1 @@\n-      value->as_InlineType()->store_flattened(kit, base, ptr, holder, offset, decorators);\n+      value->as_InlineTypeBase()->store_flattened(kit, base, ptr, holder, offset, decorators);\n@@ -456,6 +455,11 @@\n-  \/\/ Check if inline type is already allocated\n-  Node* null_ctl = kit->top();\n-  Node* not_null_oop = kit->null_check_oop(get_oop(), &null_ctl);\n-  if (null_ctl->is_top()) {\n-    \/\/ Inline type is allocated\n-    return as_ptr(&kit->gvn());\n+\n+  \/\/ Check if inline type is already buffered\n+  Node* not_buffered_ctl = kit->top();\n+  Node* not_null_oop = kit->null_check_oop(get_oop(), &not_buffered_ctl, \/* never_see_null = *\/ false, safe_for_replace);\n+  if (not_buffered_ctl->is_top()) {\n+    \/\/ Already buffered\n+    InlineTypePtrNode* ptr = as_ptr(&kit->gvn(), false);\n+    if (safe_for_replace) {\n+      kit->replace_in_map(this, ptr);\n+    }\n+    return ptr;\n@@ -463,2 +467,18 @@\n-  assert(!is_allocated(&kit->gvn()), \"should not be allocated\");\n-  RegionNode* region = new RegionNode(3);\n+  Node* buffered_ctl = kit->control();\n+  kit->set_control(not_buffered_ctl);\n+\n+  \/\/ Inline type is not buffered, check if it is null.\n+  Node* null_ctl = kit->top();\n+  kit->null_check_common(get_is_init(), T_INT, false, &null_ctl);\n+  bool null_free = null_ctl->is_top();\n+\n+  RegionNode* region = new RegionNode(4);\n+  PhiNode* oop = PhiNode::make(region, not_null_oop, inline_ptr()->join_speculative(null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM));\n+\n+  \/\/ InlineType is already buffered\n+  region->init_req(1, buffered_ctl);\n+  oop->init_req(1, not_null_oop);\n+\n+  \/\/ InlineType is null\n+  region->init_req(2, null_ctl);\n+  oop->init_req(2, kit->gvn().zerocon(T_OBJECT));\n@@ -466,3 +486,0 @@\n-  \/\/ Oop is non-NULL, use it\n-  region->init_req(1, kit->control());\n-  PhiNode* oop = PhiNode::make(region, not_null_oop, inline_ptr()->join_speculative(TypePtr::NOTNULL));\n@@ -474,2 +491,4 @@\n-  {\n-    \/\/ Oop is NULL, allocate and initialize buffer\n+  if (!kit->stopped()) {\n+    assert(!is_allocated(&kit->gvn()), \"already buffered\");\n+\n+    \/\/ Allocate and initialize buffer\n@@ -481,1 +500,1 @@\n-    kit->set_control(null_ctl);\n+\n@@ -494,4 +513,4 @@\n-    region->init_req(2, kit->control());\n-    oop   ->init_req(2, alloc_oop);\n-    io    ->init_req(2, kit->i_o());\n-    mem   ->init_req(2, kit->merged_memory());\n+    region->init_req(3, kit->control());\n+    oop   ->init_req(3, alloc_oop);\n+    io    ->init_req(3, kit->i_o());\n+    mem   ->init_req(3, kit->merged_memory());\n@@ -520,1 +539,1 @@\n-  return vt->as_ptr(&kit->gvn());\n+  return vt->as_ptr(&kit->gvn(), null_free);\n@@ -529,2 +548,2 @@\n-InlineTypePtrNode* InlineTypeBaseNode::as_ptr(PhaseGVN* phase) const {\n-  assert(is_allocated(phase), \"must be allocated\");\n+InlineTypePtrNode* InlineTypeBaseNode::as_ptr(PhaseGVN* phase, bool null_free) const {\n+  assert(!null_free || is_allocated(phase), \"must be allocated\");\n@@ -534,1 +553,1 @@\n-  return phase->transform(new InlineTypePtrNode(this))->as_InlineTypePtr();\n+  return phase->transform(new InlineTypePtrNode(this, null_free))->as_InlineTypePtr();\n@@ -541,1 +560,1 @@\n-void InlineTypeBaseNode::replace_call_results(GraphKit* kit, Node* call, Compile* C) {\n+void InlineTypeBaseNode::replace_call_results(GraphKit* kit, CallNode* call, Compile* C, bool null_free) {\n@@ -549,0 +568,2 @@\n+    } else if (!null_free && con == (call->tf()->range_cc()->cnt() - 1)) {\n+      field = get_is_init();\n@@ -666,0 +687,4 @@\n+  const Type* tinit = gvn->type(in(IsInit));\n+  if (!tinit->isa_int() || !tinit->is_int()->is_con(1)) {\n+    return false; \/\/ May be null\n+  }\n@@ -679,1 +704,1 @@\n-Node* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free) {\n+InlineTypeBaseNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free) {\n@@ -682,5 +707,2 @@\n-  if (vk->is_empty()) {\n-    Node* def = make_default(gvn, vk);\n-    if (!null_free) {\n-      def = gvn.transform(new InlineTypePtrNode(def->as_InlineType(), false));\n-    }\n+  if (vk->is_empty() && null_free) {\n+    InlineTypeNode* def = make_default(gvn, vk);\n@@ -695,11 +717,1 @@\n-    InlineTypePtrNode* vtptr = oop->as_InlineTypePtr();\n-    if (!null_free) {\n-      return vtptr;\n-    }\n-    vt = new InlineTypeNode(vk, vtptr->get_oop());\n-    vt->set_is_init(gvn);\n-    for (uint i = Values; i < vtptr->req(); ++i) {\n-      vt->init_req(i, vtptr->in(i));\n-    }\n-    kit->record_for_igvn(vt);\n-    return gvn.transform(vt);\n+    return oop->as_InlineTypePtr();\n@@ -721,5 +733,1 @@\n-    if (null_free) {\n-      vt = new InlineTypeNode(vk, not_null_oop);\n-    } else {\n-      vt = new InlineTypePtrNode(vk, not_null_oop);\n-    }\n+    vt = new InlineTypePtrNode(vk, not_null_oop, null_free);\n@@ -732,1 +740,1 @@\n-        null_vt = make_default(gvn, vk);\n+        null_vt = make_default(gvn, vk)->as_ptr(&gvn);\n@@ -748,5 +756,0 @@\n-    if (null_free) {\n-      vt = new InlineTypeNode(vk, oop);\n-    } else {\n-      vt = new InlineTypePtrNode(vk, oop);\n-    }\n@@ -754,0 +757,1 @@\n+    vt = new InlineTypePtrNode(vk, oop, \/* null_free= *\/ true);\n@@ -763,1 +767,1 @@\n-  return gvn.transform(vt);\n+  return gvn.transform(vt)->as_InlineTypeBase();\n@@ -782,1 +786,1 @@\n-InlineTypeNode* InlineTypeNode::make_from_multi(GraphKit* kit, MultiNode* multi, ciInlineKlass* vk, uint& base_input, bool in) {\n+InlineTypeBaseNode* InlineTypeNode::make_from_multi(GraphKit* kit, MultiNode* multi, ciInlineKlass* vk, uint& base_input, bool in, bool null_free) {\n@@ -789,2 +793,2 @@\n-  vt->initialize_fields(kit, multi, base_input, in);\n-  return kit->gvn().transform(vt)->as_InlineType();\n+  vt->initialize_fields(kit, multi, base_input, in, null_free);\n+  return kit->gvn().transform(vt)->as_InlineTypeBase();\n@@ -793,1 +797,1 @@\n-InlineTypeNode* InlineTypeNode::make_larval(GraphKit* kit, bool allocate) const {\n+InlineTypeNode* InlineTypeBaseNode::make_larval(GraphKit* kit, bool allocate) const {\n@@ -795,1 +799,5 @@\n-  InlineTypeNode* res = clone()->as_InlineType();\n+  InlineTypeNode* res = InlineTypeNode::make_uninitialized(kit->gvn(), vk);\n+  for (uint i = 1; i < req(); ++i) {\n+    res->set_req(i, in(i));\n+  }\n+\n@@ -814,1 +822,1 @@\n-InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit) const {\n+InlineTypeNode* InlineTypeBaseNode::finish_larval(GraphKit* kit) const {\n@@ -828,1 +836,4 @@\n-  InlineTypeNode* res = clone()->as_InlineType();\n+  InlineTypeNode* res = InlineTypeNode::make_uninitialized(kit->gvn(), vk);\n+  for (uint i = 1; i < req(); ++i) {\n+    res->set_req(i, in(i));\n+  }\n@@ -839,2 +850,8 @@\n-    assert(is_allocated(phase), \"must be allocated\");\n-    return get_oop();\n+    const Type* tinit = phase->type(in(IsInit));\n+    if (tinit->isa_int() && tinit->is_int()->is_con(1)) {\n+      assert(is_allocated(phase), \"must be allocated\");\n+      return get_oop();\n+    } else {\n+      \/\/ TODO 8284443\n+      return NULL;\n+    }\n@@ -893,1 +910,1 @@\n-  return gvn.makecon(TypeRawPtr::make((address)bits));\n+  return gvn.longcon((jlong)bits);\n@@ -896,1 +913,4 @@\n-void InlineTypeBaseNode::pass_fields(GraphKit* kit, Node* n, uint& base_input) {\n+void InlineTypeBaseNode::pass_fields(GraphKit* kit, Node* n, uint& base_input, bool in, bool null_free) {\n+  if (!null_free && in) {\n+    n->init_req(base_input++, get_is_init());\n+  }\n@@ -898,2 +918,0 @@\n-    int offset = field_offset(i);\n-    ciType* type = field_type(i);\n@@ -901,1 +919,0 @@\n-\n@@ -904,1 +921,1 @@\n-      arg->as_InlineTypeBase()->pass_fields(kit, n, base_input);\n+      arg->as_InlineTypeBase()->pass_fields(kit, n, base_input, in);\n@@ -913,1 +930,0 @@\n-      BasicType bt = field_type(i)->basic_type();\n@@ -915,1 +931,1 @@\n-      if (type2size[bt] == 2) {\n+      if (field_type(i)->size() == 2) {\n@@ -920,0 +936,4 @@\n+  \/\/ The last argument is used to pass IsInit information to compiled code and not required here.\n+  if (!null_free && !in) {\n+    n->init_req(base_input++, kit->top());\n+  }\n@@ -922,1 +942,1 @@\n-void InlineTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in) {\n+void InlineTypeNode::initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool null_free, Node* null_check_region) {\n@@ -924,0 +944,30 @@\n+  Node* is_init = NULL;\n+  if (!null_free) {\n+    \/\/ Nullable inline type\n+    if (in) {\n+      \/\/ Set IsInit field\n+      if (multi->is_Start()) {\n+        is_init = gvn.transform(new ParmNode(multi->as_Start(), base_input));\n+      } else {\n+        is_init = multi->as_Call()->in(base_input);\n+      }\n+      set_req(IsInit, is_init);\n+      base_input++;\n+    }\n+    \/\/ Add a null check to make subsequent loads dependent on\n+    assert(null_check_region == NULL, \"already set\");\n+    if (is_init == NULL) {\n+      \/\/ Will only be initialized below, use dummy node for now\n+      is_init = new Node(1);\n+      gvn.set_type_bottom(is_init);\n+    }\n+    Node* null_ctrl = kit->top();\n+    kit->null_check_common(is_init, T_INT, false, &null_ctrl);\n+    Node* non_null_ctrl = kit->control();\n+    null_check_region = new RegionNode(3);\n+    null_check_region->init_req(1, non_null_ctrl);\n+    null_check_region->init_req(2, null_ctrl);\n+    null_check_region = gvn.transform(null_check_region);\n+    kit->set_control(null_check_region);\n+  }\n+\n@@ -926,1 +976,0 @@\n-    bool null_free = field_is_null_free(i);\n@@ -931,1 +980,1 @@\n-      vt->initialize_fields(kit, multi, base_input, in);\n+      vt->initialize_fields(kit, multi, base_input, in, true, null_check_region);\n@@ -944,1 +993,7 @@\n-        parm = make_from_oop(kit, parm, type->as_inline_klass(), null_free);\n+        if (null_check_region != NULL) {\n+          \/\/ Holder is nullable, set field to NULL if holder is NULL to avoid loading from uninitialized memory\n+          parm = PhiNode::make(null_check_region, parm, TypeInstPtr::make(TypePtr::BotPTR, type->as_inline_klass()));\n+          parm->set_req(2, kit->zerocon(T_OBJECT));\n+          parm = gvn.transform(parm);\n+        }\n+        parm = make_from_oop(kit, parm, type->as_inline_klass(), field_is_null_free(i));\n@@ -946,2 +1001,1 @@\n-      BasicType bt = type->basic_type();\n-      base_input += type2size[bt];\n+      base_input += type->size();\n@@ -954,0 +1008,10 @@\n+  \/\/ The last argument is used to pass IsInit information to compiled code\n+  if (!null_free && !in) {\n+    Node* cmp = is_init->raw_out(0);\n+    is_init= gvn.transform(new ProjNode(multi->as_Call(), base_input));\n+    set_req(IsInit, is_init);\n+    gvn.hash_delete(cmp);\n+    cmp->set_req(1, is_init);\n+    gvn.hash_find_insert(cmp);\n+    base_input++;\n+  }\n@@ -1082,1 +1146,1 @@\n-  InlineTypePtrNode* ptr = new InlineTypePtrNode(vk, gvn.zerocon(T_OBJECT));\n+  InlineTypePtrNode* ptr = new InlineTypePtrNode(vk, gvn.zerocon(T_OBJECT), \/* null_free= *\/ false);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":147,"deletions":83,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-  InlineTypePtrNode* as_ptr(PhaseGVN* phase) const;\n+  InlineTypePtrNode* as_ptr(PhaseGVN* phase, bool null_free = true) const;\n@@ -105,1 +105,1 @@\n-  void replace_call_results(GraphKit* kit, Node* call, Compile* C);\n+  void replace_call_results(GraphKit* kit, CallNode* call, Compile* C, bool null_free = true);\n@@ -115,1 +115,4 @@\n-  void pass_fields(GraphKit* kit, Node* n, uint& base_input);\n+  void pass_fields(GraphKit* kit, Node* n, uint& base_input, bool in, bool null_free = true);\n+\n+  InlineTypeNode* make_larval(GraphKit* kit, bool allocate) const;\n+  InlineTypeNode* finish_larval(GraphKit* kit) const;\n@@ -145,1 +148,1 @@\n-  static Node* make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free = true);\n+  static InlineTypeBaseNode* make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk, bool null_free = true);\n@@ -149,4 +152,1 @@\n-  static InlineTypeNode* make_from_multi(GraphKit* kit, MultiNode* multi, ciInlineKlass* vk, uint& base_input, bool in);\n-\n-  InlineTypeNode* make_larval(GraphKit* kit, bool allocate) const;\n-  InlineTypeNode* finish_larval(GraphKit* kit) const;\n+  static InlineTypeBaseNode* make_from_multi(GraphKit* kit, MultiNode* multi, ciInlineKlass* vk, uint& base_input, bool in, bool null_free = true);\n@@ -155,1 +155,1 @@\n-  void initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in);\n+  void initialize_fields(GraphKit* kit, MultiNode* multi, uint& base_input, bool in, bool null_free = true, Node* null_check_region = NULL);\n@@ -182,2 +182,2 @@\n-  InlineTypePtrNode(ciInlineKlass* vk, Node* oop)\n-      : InlineTypeBaseNode(TypeInstPtr::make(TypePtr::BotPTR, vk), Values + vk->nof_declared_nonstatic_fields()) {\n+  InlineTypePtrNode(ciInlineKlass* vk, Node* oop, bool null_free = true)\n+      : InlineTypeBaseNode(TypeInstPtr::make(null_free ? TypePtr::NotNull : TypePtr::BotPTR, vk), Values + vk->nof_declared_nonstatic_fields()) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2476,1 +2476,1 @@\n-      if (!val_t->isa_inlinetype() || val_t->inline_klass() != inline_klass) {\n+      if (!(val_t->isa_inlinetype() || val_t->is_inlinetypeptr()) || val_t->inline_klass() != inline_klass) {\n@@ -2594,2 +2594,2 @@\n-    Node* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(base)->inline_klass());\n-    value = value->as_InlineType()->make_larval(this, false);\n+    InlineTypeBaseNode* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(base)->inline_klass());\n+    value = value->make_larval(this, false);\n@@ -2605,1 +2605,1 @@\n-  if (!value->is_InlineType()) {\n+  if (!value->is_InlineTypeBase()) {\n@@ -2614,1 +2614,1 @@\n-  set_result(value->as_InlineType()->make_larval(this, true));\n+  set_result(value->as_InlineTypeBase()->make_larval(this, true));\n@@ -3035,1 +3035,1 @@\n-    obj = InlineTypeNode::make_default(_gvn, klass->as_inline_klass());\n+    obj = InlineTypeNode::make_default(_gvn, klass->as_inline_klass())->buffer(this);\n@@ -3483,1 +3483,0 @@\n-  requires_null_check &= !obj->is_InlineType();\n@@ -3536,1 +3535,1 @@\n-    if (EnableValhalla && !obj->is_InlineType() && !requires_null_check) {\n+    if (EnableValhalla && !requires_null_check) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -188,1 +188,2 @@\n-RegMask* Matcher::return_values_mask(const TypeTuple* range) {\n+RegMask* Matcher::return_values_mask(const TypeFunc* tf) {\n+  const TypeTuple* range = tf->range_cc();\n@@ -196,1 +197,0 @@\n-\n@@ -202,1 +202,13 @@\n-  assert(regs > 0, \"should have been tested during graph construction\");\n+  if (regs <= 0) {\n+    \/\/ We ran out of registers to store the IsInit information for a nullable inline type return.\n+    \/\/ Since it is only set in the 'call_epilog', we can simply put it on the stack.\n+    assert(tf->returns_inline_type_as_fields(), \"should have been tested during graph construction\");\n+    \/\/ TODO 8284443 Can we teach the register allocator to reserve a stack slot instead?\n+    \/\/ mask[--cnt] = STACK_ONLY_mask does not work (test with -XX:+StressGCM)\n+    int slot = C->fixed_slots() - 2;\n+    if (C->needs_stack_repair()) {\n+      slot -= 2; \/\/ Account for stack increment value\n+    }\n+    mask[--cnt].Clear();\n+    mask[cnt].Insert(OptoReg::stack2reg(slot));\n+  }\n@@ -235,2 +247,1 @@\n-  const TypeTuple *range = C->tf()->range_cc();\n-  _return_values_mask = return_values_mask(range);\n+  _return_values_mask = return_values_mask(C->tf());\n@@ -1151,1 +1162,1 @@\n-                mask = return_values_mask(n->in(0)->as_Call()->tf()->range_cc());\n+                mask = return_values_mask(n->in(0)->as_Call()->tf());\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-  RegMask* return_values_mask(const TypeTuple* range);\n+  RegMask* return_values_mask(const TypeFunc* tf);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -305,1 +305,0 @@\n-    _sp_inc_slot(0),\n@@ -314,1 +313,4 @@\n-      _sp_inc_slot = fixed_slots;\n+    }\n+    \/\/ TODO 8284443 Only reserve extra slot if needed\n+    if (InlineTypeReturnedAsFields) {\n+      fixed_slots -= 2;\n@@ -3301,0 +3303,1 @@\n+      ciMethod* method = C->method();\n@@ -3302,2 +3305,9 @@\n-      for (ciSignatureStream str(C->method()->signature()); !str.at_return_type(); str.next()) {\n-        if (str.is_null_free() && str.type()->as_inline_klass()->can_be_passed_as_fields()) {\n+      int arg_num = 0;\n+      if (!method->is_static()) {\n+        if (method->is_scalarized_arg(arg_num)) {\n+          size += method->holder()->as_inline_klass()->oop_count() * barrier_size;\n+        }\n+        arg_num++;\n+      }\n+      for (ciSignatureStream str(method->signature()); !str.at_return_type(); str.next()) {\n+        if (method->is_scalarized_arg(arg_num)) {\n@@ -3306,0 +3316,1 @@\n+        arg_num++;\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -140,3 +140,0 @@\n-  \/\/ For the inline type calling convention\n-  int                    _sp_inc_slot;\n-  int                    _sp_inc_slot_offset_in_bytes;\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"opto\/convertnode.hpp\"\n@@ -158,1 +159,0 @@\n-  const TypeOopPtr* tp = type->isa_oopptr();\n@@ -161,2 +161,2 @@\n-    tp = TypeOopPtr::make_from_klass(type->inline_klass());\n-    tp = tp->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+    type = TypeOopPtr::make_from_klass(type->inline_klass());\n+    type = type->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n@@ -164,0 +164,1 @@\n+  const TypeOopPtr* tp = type->isa_oopptr();\n@@ -828,1 +829,1 @@\n-        ret_type->is_inlinetypeptr() && !ret_type->maybe_null()) {\n+        ret_type->is_inlinetypeptr()) {\n@@ -864,0 +865,1 @@\n+  int arg_num = 0;\n@@ -867,1 +869,1 @@\n-    if (has_scalarized_args() && t->is_inlinetypeptr() && !t->maybe_null() && t->inline_klass()->can_be_passed_as_fields()) {\n+    if (t->is_inlinetypeptr() && method()->is_scalarized_arg(arg_num)) {\n@@ -875,1 +877,1 @@\n-      parm = InlineTypeNode::make_from_multi(&kit, start, t->inline_klass(), j, true);\n+      parm = InlineTypeNode::make_from_multi(&kit, start, t->inline_klass(), j, \/* in= *\/ true, \/* null_free= *\/ !t->maybe_null());\n@@ -884,0 +886,3 @@\n+    if (i >= TypeFunc::Parms && t != Type::HALF) {\n+      arg_num++;\n+    }\n@@ -929,1 +934,10 @@\n-        ret->init_req(TypeFunc::Parms, vt->tagged_klass(kit.gvn()));\n+        \/\/ Return the tagged klass pointer to signal scalarization to the caller\n+        Node* tagged_klass = vt->tagged_klass(kit.gvn());\n+        if (!method()->signature()->returns_null_free_inline_type()) {\n+          \/\/ Return null if the inline type is null (IsInit field is not set)\n+          Node* conv   = kit.gvn().transform(new ConvI2LNode(vt->get_is_init()));\n+          Node* shl    = kit.gvn().transform(new LShiftLNode(conv, kit.intcon(63)));\n+          Node* shr    = kit.gvn().transform(new RShiftLNode(shl, kit.intcon(63)));\n+          tagged_klass = kit.gvn().transform(new AndLNode(tagged_klass, shr));\n+        }\n+        ret->init_req(TypeFunc::Parms, tagged_klass);\n@@ -932,1 +946,1 @@\n-      vt->pass_fields(&kit, ret, idx);\n+      vt->pass_fields(&kit, ret, idx, false, method()->signature()->returns_null_free_inline_type());\n@@ -1742,1 +1756,1 @@\n-        if (n->is_InlineType() && !t->isa_inlinetype()) {\n+        if (n->is_InlineType() && (!t->isa_inlinetype() && !t->is_inlinetypeptr())) {\n@@ -1911,0 +1925,10 @@\n+        if (vtm->is_InlineTypePtr() && vtn->is_InlineType()) {\n+          \/\/ TODO 8284443 Remove this\n+          Node* newVal = InlineTypeNode::make_uninitialized(gvn(), vtm->bottom_type()->inline_klass());\n+          for (uint i = 1; i < vtm->req(); ++i) {\n+            newVal->set_req(i, vtm->in(i));\n+          }\n+          _gvn.set_type(newVal, vtm->bottom_type());\n+          vtm->replace_by(newVal);\n+          vtm = newVal->as_InlineTypeBase();\n+        }\n@@ -2373,1 +2397,1 @@\n-        value = InlineTypeNode::make_from_oop(this, value, return_type->inline_klass());\n+        value = InlineTypeNode::make_from_oop(this, value, return_type->inline_klass(), method()->signature()->returns_null_free_inline_type());\n@@ -2382,1 +2406,1 @@\n-        value = value->as_InlineType()->allocate_fields(this);\n+        value = value->as_InlineTypeBase()->allocate_fields(this);\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":35,"deletions":11,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -268,1 +268,0 @@\n-        Node* val = cast_val;\n@@ -270,11 +269,8 @@\n-        if (!val->is_InlineType() && tval->maybe_null()) {\n-          \/\/ Add null check\n-          Node* null_ctl = top();\n-          val = null_check_oop(val, &null_ctl);\n-          if (null_ctl != top()) {\n-            PreserveJVMState pjvms(this);\n-            inc_sp(3);\n-            set_control(null_ctl);\n-            uncommon_trap(Deoptimization::Reason_null_check, Deoptimization::Action_none);\n-            dec_sp(3);\n-          }\n+        Node* null_ctl = top();\n+        Node* val = null_check_oop(cast_val, &null_ctl);\n+        if (null_ctl != top()) {\n+          PreserveJVMState pjvms(this);\n+          inc_sp(3);\n+          set_control(null_ctl);\n+          uncommon_trap(Deoptimization::Reason_null_check, Deoptimization::Action_none);\n+          dec_sp(3);\n@@ -2070,5 +2066,14 @@\n-  if (left->is_InlineType()) {\n-    PreserveReexecuteState preexecs(this);\n-    inc_sp(2);\n-    jvms()->set_should_reexecute(true);\n-    left = left->as_InlineType()->buffer(this)->get_oop();\n+  if (left->is_InlineTypeBase()) {\n+    if (_gvn.type(right)->is_zero_type() ||\n+        (right->is_InlineTypeBase() && _gvn.type(right->as_InlineTypeBase()->get_is_init())->is_zero_type())) {\n+      \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n+      \/\/ input instead of the oop input to avoid keeping buffer allocations alive.\n+      Node* cmp = CmpI(left->as_InlineTypeBase()->get_is_init(), intcon(0));\n+      do_if(btest, cmp);\n+      return;\n+    } else if (left->is_InlineType()){\n+      PreserveReexecuteState preexecs(this);\n+      inc_sp(2);\n+      jvms()->set_should_reexecute(true);\n+      left = left->as_InlineType()->buffer(this)->get_oop();\n+    }\n@@ -3373,2 +3378,3 @@\n-      \/\/ Return constant false because 'b' is always non-null\n-      c = _gvn.makecon(TypeInt::CC_GT);\n+      \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n+      \/\/ input instead of the oop input to avoid keeping buffer allocations alive\n+      c = _gvn.transform(new CmpINode(b->as_InlineType()->get_is_init(), zerocon(T_INT)));\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":25,"deletions":19,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -56,3 +56,1 @@\n-    if (vt->is_InlineTypePtr()) {\n-      null_check(vt);\n-    }\n+    null_check(vt);\n@@ -243,1 +241,3 @@\n-    val->as_InlineType()->store_flattened(this, obj, obj, field->holder(), offset);\n+    inc_sp(1);\n+    val->as_InlineTypeBase()->store_flattened(this, obj, obj, field->holder(), offset);\n+    dec_sp(1);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -348,0 +348,5 @@\n+  int holder_depth = field->type()->size();\n+  null_check(peek(holder_depth));\n+  if (stopped()) {\n+    return;\n+  }\n@@ -349,1 +354,0 @@\n-  ciInlineKlass* holder_klass = field->holder()->as_inline_klass();\n@@ -351,1 +355,0 @@\n-  int nargs = 1 + field->type()->size();\n@@ -353,5 +356,0 @@\n-  if (!holder->is_InlineType()) {\n-    \/\/ Scalarize inline type holder\n-    assert(!gvn().type(holder)->maybe_null(), \"Inline types are null-free\");\n-    holder = InlineTypeNode::make_from_oop(this, holder, holder_klass);\n-  }\n@@ -367,0 +365,1 @@\n+    int nargs = 1 + field->type()->size();\n@@ -370,0 +369,8 @@\n+  if (val->is_InlineTypePtr() && field->is_null_free()) {\n+    \/\/ TODO 8284443 Remove this\n+    Node* newVal = InlineTypeNode::make_uninitialized(gvn(), field->type()->as_inline_klass());\n+    for (uint i = 1; i < val->req(); ++i) {\n+      newVal->set_req(i, val->in(i));\n+    }\n+    val = gvn().transform(newVal);\n+  }\n@@ -372,3 +379,4 @@\n-  InlineTypeNode* new_vt = holder->clone()->as_InlineType();\n-  new_vt->set_oop(_gvn.zerocon(T_PRIMITIVE_OBJECT));\n-  gvn().set_type(new_vt, new_vt->bottom_type());\n+  InlineTypeNode* new_vt = InlineTypeNode::make_uninitialized(gvn(), gvn().type(holder)->inline_klass());\n+  for (uint i = 2; i < holder->req(); ++i) {\n+    new_vt->set_req(i, holder->in(i));\n+  }\n@@ -376,1 +384,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1171,0 +1171,1 @@\n+  \/\/ TODO 8284443 in(1) could be cast?\n@@ -1172,1 +1173,1 @@\n-    \/\/ Null checking a scalarized but nullable inline type. Check the is_init\n+    \/\/ Null checking a scalarized but nullable inline type. Check the IsInit\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2099,0 +2099,4 @@\n+    if (!sig->returns_null_free_inline_type()) {\n+      \/\/ InlineTypeBaseNode::IsInit field used for null checking\n+      arg_cnt++;\n+    }\n@@ -2126,0 +2130,4 @@\n+      if (!sig->returns_null_free_inline_type()) {\n+        \/\/ InlineTypeBaseNode::IsInit field used for null checking\n+        field_array[pos++] = get_const_basic_type(T_BOOLEAN);\n+      }\n@@ -2144,0 +2152,1 @@\n+    assert(method->get_sig_cc() != NULL, \"Should have scalarized signature\");\n@@ -2187,2 +2196,5 @@\n-      bool is_null_free = sig->is_null_free_at(i);\n-      if (vt_fields_as_args && type->as_inline_klass()->can_be_passed_as_fields() && is_null_free) {\n+      if (vt_fields_as_args && method->is_scalarized_arg(i + (method->is_static() ? 0 : 1))) {\n+        if (!sig->is_null_free_at(i)) {\n+          \/\/ InlineTypeBaseNode::IsInit field used for null checking\n+          field_array[pos++] = get_const_basic_type(T_BOOLEAN);\n+        }\n@@ -2191,1 +2203,1 @@\n-        field_array[pos++] = get_const_type(type)->join_speculative(is_null_free ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n+        field_array[pos++] = get_const_type(type)->join_speculative(sig->is_null_free_at(i) ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -6471,1 +6483,1 @@\n-  bool has_scalar_ret = sig->returns_null_free_inline_type() && sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n+  bool has_scalar_ret = sig->return_type()->is_inlinetype() && sig->return_type()->as_inline_klass()->can_be_returned_as_fields();\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -411,1 +411,1 @@\n-  if (InlineTypeReturnedAsFields && result->get_type() == T_PRIMITIVE_OBJECT) {\n+  if (InlineTypeReturnedAsFields && (result->get_type() == T_PRIMITIVE_OBJECT || result->get_type() == T_OBJECT)) {\n@@ -414,2 +414,2 @@\n-    InlineKlass* vk = method->returned_inline_type(thread);\n-    if (vk->can_be_returned_as_fields()) {\n+    InlineKlass* vk = method->returns_inline_type(thread);\n+    if (vk != NULL && vk->can_be_returned_as_fields()) {\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -938,2 +938,3 @@\n-    if (return_oop && InlineTypeReturnedAsFields && method->result_type() == T_PRIMITIVE_OBJECT) {\n-      \/\/ Check if inline type is returned as fields\n+    if (return_oop && InlineTypeReturnedAsFields &&\n+        (method->result_type() == T_PRIMITIVE_OBJECT || method->result_type() == T_OBJECT)) {\n+      \/\/ Check if an inline type is returned as fields\n@@ -945,1 +946,1 @@\n-        assert(vk == method->returned_inline_type(thread()), \"bad inline klass\");\n+        assert(vk == method->returns_inline_type(thread()), \"bad inline klass\");\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1184,2 +1184,1 @@\n-    if (!caller_is_c1 && callee->has_scalarized_args() && callee->method_holder()->is_inline_klass() &&\n-        InlineKlass::cast(callee->method_holder())->can_be_passed_as_fields()) {\n+    if (!caller_is_c1 && callee->is_scalarized_arg(0)) {\n@@ -1326,2 +1325,1 @@\n-    if (!caller_is_c1 && callee_method->has_scalarized_args() && callee_method->method_holder()->is_inline_klass() &&\n-        InlineKlass::cast(callee_method->method_holder())->can_be_passed_as_fields()) {\n+    if (!caller_is_c1 && callee_method->is_scalarized_arg(0)) {\n@@ -2856,1 +2854,1 @@\n-    if (!method->is_static() && !method->method_holder()->is_inline_klass()) {\n+    if (!method->is_static() && (!InlineTypePassFieldsAsArgs || !method->method_holder()->is_inline_klass())) {\n@@ -2860,1 +2858,9 @@\n-      case JVM_SIGNATURE_CLASS:\n+      case JVM_SIGNATURE_CLASS: {\n+        if (InlineTypePassFieldsAsArgs) {\n+          SignatureStream ss(method->signature());\n+          if (method->method_holder()->is_preload_class(ss.as_symbol())) {\n+            return NULL;\n+          }\n+        }\n+        return _obj_arg_handler;\n+      }\n@@ -2871,1 +2877,1 @@\n-             !method->is_static() && !method->method_holder()->is_inline_klass()) {\n+             !method->is_static() && (!InlineTypePassFieldsAsArgs || !method->method_holder()->is_inline_klass())) {\n@@ -2873,1 +2879,9 @@\n-      case JVM_SIGNATURE_CLASS:\n+      case JVM_SIGNATURE_CLASS: {\n+        if (InlineTypePassFieldsAsArgs) {\n+          SignatureStream ss(method->signature());\n+          if (method->method_holder()->is_preload_class(ss.as_symbol())) {\n+            return NULL;\n+          }\n+        }\n+        return _obj_obj_arg_handler;\n+      }\n@@ -2893,28 +2907,2 @@\n-  _sig_cc = _sig;\n-  _sig_cc_ro = _sig;\n-}\n-\n-int CompiledEntrySignature::compute_scalarized_cc(GrowableArray<SigEntry>*& sig_cc, VMRegPair*& regs_cc, bool scalar_receiver) {\n-  InstanceKlass* holder = _method->method_holder();\n-  sig_cc = new GrowableArray<SigEntry>(_method->size_of_parameters());\n-  if (!_method->is_static()) {\n-    if (holder->is_inline_klass() && scalar_receiver && InlineKlass::cast(holder)->can_be_passed_as_fields()) {\n-      sig_cc->appendAll(InlineKlass::cast(holder)->extended_sig());\n-    } else {\n-      SigEntry::add_entry(sig_cc, T_OBJECT, holder->name());\n-    }\n-  }\n-  for (SignatureStream ss(_method->signature()); !ss.at_return_type(); ss.next()) {\n-    if (ss.type() == T_PRIMITIVE_OBJECT) {\n-      InlineKlass* vk = ss.as_inline_klass(holder);\n-      if (vk->can_be_passed_as_fields()) {\n-        sig_cc->appendAll(vk->extended_sig());\n-      } else {\n-        SigEntry::add_entry(sig_cc, T_OBJECT, ss.as_symbol());\n-      }\n-    } else {\n-      SigEntry::add_entry(sig_cc, ss.type(), ss.as_symbol());\n-    }\n-  }\n-  regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, sig_cc->length() + 2);\n-  return SharedRuntime::java_calling_convention(sig_cc, regs_cc);\n+  _sig_cc = new GrowableArray<SigEntry>((method != NULL) ? method->size_of_parameters() : 1);\n+  _sig_cc_ro = new GrowableArray<SigEntry>((method != NULL) ? method->size_of_parameters() : 1);\n@@ -2962,2 +2950,3 @@\n-void CompiledEntrySignature::compute_calling_conventions() {\n-  \/\/ Get the (non-scalarized) signature and check for inline type arguments\n+void CompiledEntrySignature::compute_calling_conventions(bool init) {\n+  \/\/ Iterate over arguments and compute scalarized and non-scalarized signatures\n+  bool has_scalarized = false;\n@@ -2965,0 +2954,2 @@\n+    InstanceKlass* holder = _method->method_holder();\n+    int arg_num = 0;\n@@ -2966,1 +2957,4 @@\n-      if (_method->method_holder()->is_inline_klass() && InlineKlass::cast(_method->method_holder())->can_be_passed_as_fields()) {\n+      if (holder->is_inline_klass() && InlineKlass::cast(holder)->can_be_passed_as_fields() &&\n+          (init || _method->is_scalarized_arg(arg_num))) {\n+        _sig_cc->appendAll(InlineKlass::cast(holder)->extended_sig());\n+        has_scalarized = true;\n@@ -2969,0 +2963,2 @@\n+      } else {\n+        SigEntry::add_entry(_sig_cc, T_OBJECT, holder->name());\n@@ -2970,1 +2966,3 @@\n-      SigEntry::add_entry(_sig, T_OBJECT, _method->name());\n+      SigEntry::add_entry(_sig, T_OBJECT, holder->name());\n+      SigEntry::add_entry(_sig_cc_ro, T_OBJECT, holder->name());\n+      arg_num++;\n@@ -2974,2 +2972,5 @@\n-      if (bt == T_PRIMITIVE_OBJECT) {\n-        if (ss.as_inline_klass(_method->method_holder())->can_be_passed_as_fields()) {\n+      if (bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) {\n+        InlineKlass* vk = ss.as_inline_klass(holder);\n+        \/\/ TODO 8284443 Mismatch handling, we need to check parent method args (look at klassVtable::needs_new_vtable_entry)\n+        if (vk != NULL && (bt == T_PRIMITIVE_OBJECT || holder->is_preload_class(vk->name())) &&\n+            vk->can_be_passed_as_fields() && (init || _method->is_scalarized_arg(arg_num))) {\n@@ -2977,0 +2978,13 @@\n+          has_scalarized = true;\n+          int last = _sig_cc->length();\n+          int last_ro = _sig_cc_ro->length();\n+          _sig_cc->appendAll(vk->extended_sig());\n+          _sig_cc_ro->appendAll(vk->extended_sig());\n+          if (bt == T_OBJECT) {\n+            \/\/ Nullable inline type argument, insert InlineTypeBaseNode::IsInit field right after T_PRIMITIVE_OBJECT\n+            _sig_cc->insert_before(last+1, SigEntry(T_BOOLEAN, -1, NULL));\n+            _sig_cc_ro->insert_before(last_ro+1, SigEntry(T_BOOLEAN, -1, NULL));\n+          }\n+        } else {\n+          SigEntry::add_entry(_sig_cc, T_OBJECT, ss.as_symbol());\n+          SigEntry::add_entry(_sig_cc_ro, T_OBJECT, ss.as_symbol());\n@@ -2979,0 +2993,3 @@\n+      } else {\n+        SigEntry::add_entry(_sig_cc, ss.type(), ss.as_symbol());\n+        SigEntry::add_entry(_sig_cc_ro, ss.type(), ss.as_symbol());\n@@ -2981,3 +2998,3 @@\n-    }\n-    if (_method->is_abstract() && !has_inline_arg()) {\n-      return;\n+      if (bt != T_VOID) {\n+        arg_num++;\n+      }\n@@ -2987,1 +3004,1 @@\n-  \/\/ Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage\n+  \/\/ Compute the non-scalarized calling convention\n@@ -2991,5 +3008,4 @@\n-  \/\/ Now compute the scalarized calling convention if there are inline types in the signature\n-  _regs_cc = _regs;\n-  _regs_cc_ro = _regs;\n-  _args_on_stack_cc = _args_on_stack;\n-  _args_on_stack_cc_ro = _args_on_stack;\n+  \/\/ Compute the scalarized calling conventions if there are scalarized inline types in the signature\n+  if (has_scalarized && !_method->is_native()) {\n+    _regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, _sig_cc->length());\n+    _args_on_stack_cc = SharedRuntime::java_calling_convention(_sig_cc, _regs_cc);\n@@ -2997,2 +3013,2 @@\n-  if (has_inline_arg() && !_method->is_native()) {\n-    _args_on_stack_cc = compute_scalarized_cc(_sig_cc, _regs_cc, \/* scalar_receiver = *\/ true);\n+    _regs_cc_ro = NEW_RESOURCE_ARRAY(VMRegPair, _sig_cc_ro->length());\n+    _args_on_stack_cc_ro = SharedRuntime::java_calling_convention(_sig_cc_ro, _regs_cc_ro);\n@@ -3000,7 +3016,2 @@\n-    _sig_cc_ro = _sig_cc;\n-    _regs_cc_ro = _regs_cc;\n-    _args_on_stack_cc_ro = _args_on_stack_cc;\n-    if (_has_inline_recv) {\n-      \/\/ For interface calls, we need another entry point \/ adapter to unpack the receiver\n-      _args_on_stack_cc_ro = compute_scalarized_cc(_sig_cc_ro, _regs_cc_ro, \/* scalar_receiver = *\/ false);\n-    }\n+    _c1_needs_stack_repair = (_args_on_stack_cc < _args_on_stack) || (_args_on_stack_cc_ro < _args_on_stack);\n+    _c2_needs_stack_repair = (_args_on_stack_cc > _args_on_stack) || (_args_on_stack_cc > _args_on_stack_cc_ro);\n@@ -3011,11 +3022,2 @@\n-    if (_args_on_stack_cc > 50) {\n-      \/\/ Don't scalarize inline type arguments\n-      _sig_cc = _sig;\n-      _sig_cc_ro = _sig;\n-      _regs_cc = _regs;\n-      _regs_cc_ro = _regs;\n-      _args_on_stack_cc = _args_on_stack;\n-      _args_on_stack_cc_ro = _args_on_stack;\n-    } else {\n-      _c1_needs_stack_repair = (_args_on_stack_cc < _args_on_stack) || (_args_on_stack_cc_ro < _args_on_stack);\n-      _c2_needs_stack_repair = (_args_on_stack_cc > _args_on_stack) || (_args_on_stack_cc > _args_on_stack_cc_ro);\n+    if (MAX2(_args_on_stack_cc, _args_on_stack_cc_ro) <= 60) {\n+      return; \/\/ Success\n@@ -3024,0 +3026,9 @@\n+\n+  \/\/ No scalarized args\n+  _sig_cc = _sig;\n+  _regs_cc = _regs;\n+  _args_on_stack_cc = _args_on_stack;\n+\n+  _sig_cc_ro = _sig;\n+  _regs_cc_ro = _regs;\n+  _args_on_stack_cc_ro = _args_on_stack;\n@@ -3069,1 +3080,1 @@\n-    entry = _adapters->lookup(&ces.sig_cc(), ces.regs_cc() != ces.regs_cc_ro());\n+    entry = _adapters->lookup(&ces.sig_cc(), ces.has_inline_recv());\n@@ -3112,1 +3123,1 @@\n-  AdapterFingerPrint* fingerprint = new AdapterFingerPrint(&ces.sig_cc(), ces.regs_cc() != ces.regs_cc_ro());\n+  AdapterFingerPrint* fingerprint = new AdapterFingerPrint(&ces.sig_cc(), ces.has_inline_recv());\n@@ -3633,1 +3644,1 @@\n-  allocate_receiver &= !callee->is_static() && holder->is_inline_klass();\n+  allocate_receiver &= !callee->is_static() && holder->is_inline_klass() && callee->is_scalarized_arg(0);\n@@ -3637,0 +3648,1 @@\n+  int arg_num = callee->is_static() ? 0 : 1;\n@@ -3638,1 +3650,2 @@\n-    if (ss.type() == T_PRIMITIVE_OBJECT) {\n+    BasicType bt = ss.type();\n+    if ((bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) && callee->is_scalarized_arg(arg_num)) {\n@@ -3641,0 +3654,3 @@\n+    if (bt != T_VOID) {\n+      arg_num++;\n+    }\n@@ -3644,0 +3660,1 @@\n+  arg_num = callee->is_static() ? 0 : 1;\n@@ -3648,2 +3665,1 @@\n-    array->obj_at_put(i, res);\n-    i++;\n+    array->obj_at_put(i++, res);\n@@ -3652,1 +3668,2 @@\n-    if (ss.type() == T_PRIMITIVE_OBJECT) {\n+    BasicType bt = ss.type();\n+    if ((bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) && callee->is_scalarized_arg(arg_num)) {\n@@ -3654,0 +3671,1 @@\n+      assert(vk != NULL, \"Unexpected klass\");\n@@ -3655,2 +3673,4 @@\n-      array->obj_at_put(i, res);\n-      i++;\n+      array->obj_at_put(i++, res);\n+    }\n+    if (bt != T_VOID) {\n+      arg_num++;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":100,"deletions":80,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -817,1 +817,0 @@\n-  bool has_inline_arg()                const { return _num_inline_args > 0; }\n@@ -826,4 +825,1 @@\n-  void compute_calling_conventions();\n-\n-private:\n-  int compute_scalarized_cc(GrowableArray<SigEntry>*& sig_cc, VMRegPair*& regs_cc, bool scalar_receiver);\n+  void compute_calling_conventions(bool init = true);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -395,3 +395,7 @@\n-  Klass* k = as_klass(class_loader, protection_domain, SignatureStream::ReturnNull, THREAD);\n-  assert(k != NULL && !HAS_PENDING_EXCEPTION, \"unresolved inline klass\");\n-  return InlineKlass::cast(k);\n+  Klass* k = as_klass(class_loader, protection_domain, SignatureStream::CachedOrNull, THREAD);\n+  assert(!HAS_PENDING_EXCEPTION, \"Should never throw\");\n+  if (k != NULL && k->is_inline_klass()) {\n+    return InlineKlass::cast(k);\n+  } else {\n+    return NULL;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,3 +44,1 @@\n-    assert(_sig->at(_sig_idx)._bt == (step > 0) ? T_PRIMITIVE_OBJECT : T_VOID, \"should be at inline type delimiter\");\n-    _depth = 1;\n-    DEBUG_ONLY(_finished = false);\n+    reset(sig_idx, regs_idx);\n@@ -77,0 +75,8 @@\n+  void reset(int sig_idx, int regs_idx) {\n+    _sig_idx = sig_idx;\n+    _regs_idx = regs_idx;\n+    assert(_sig->at(_sig_idx)._bt == (_step > 0) ? T_PRIMITIVE_OBJECT : T_VOID, \"should be at inline type delimiter\");\n+    _depth = 1;\n+    DEBUG_ONLY(_finished = false);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/signature_cc.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -505,0 +505,12 @@\n+    \/**\n+     * Checks if deopt of {@code m} is stable at the specified {@code compLevel}.\n+     *\n+     * @param m the method to be checked.\n+     * @param compLevel the compilation level.\n+     * @return {@code true} if deopt of {@code m} is stable at {@code compLevel};\n+     *         {@code false} otherwise.\n+     *\/\n+    public static boolean isStableDeopt(Method m, CompLevel compLevel) {\n+        return TestVM.isStableDeopt(m, compLevel);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -897,1 +897,1 @@\n-        if (notUnstableDeoptAssertion(m, CompLevel.C1_SIMPLE)) {\n+        if (isStableDeopt(m, CompLevel.C1_SIMPLE)) {\n@@ -904,1 +904,1 @@\n-        if (notUnstableDeoptAssertion(m, CompLevel.C2)) {\n+        if (isStableDeopt(m, CompLevel.C2)) {\n@@ -913,1 +913,1 @@\n-    private static boolean notUnstableDeoptAssertion(Method m, CompLevel level) {\n+    public static boolean isStableDeopt(Method m, CompLevel level) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+    final MyValue2.ref v4;\n+    final MyValue2 v5;\n@@ -46,1 +48,1 @@\n-    public MyValue1(int x, long y, short z, Integer o, int[] oa, MyValue2 v1, MyValue2 v2, int c) {\n+    public MyValue1(int x, long y, short z, Integer o, int[] oa, MyValue2 v1, MyValue2 v2, MyValue2.ref v4, MyValue2.ref v5, int c) {\n@@ -55,0 +57,2 @@\n+        this.v4 = v4;\n+        this.v5 = v5;\n@@ -84,1 +88,3 @@\n-        v = setV2(v, MyValue2.createWithFieldsInline(x, y, InlineTypes.rD + x));\n+        v = setV2(v, MyValue2.createWithFieldsInline(x + 1, y + 1, InlineTypes.rD + 1));\n+        v = setV4(v, MyValue2.createWithFieldsInline(x + 2, y + 2, InlineTypes.rD + 2));\n+        v = setV5(v, MyValue2.createWithFieldsInline(x + 3, y + 3, InlineTypes.rD + 3));\n@@ -92,1 +98,1 @@\n-        return s + sf + x + y + z + c + v1.hash() + v2.hash() + v3.hash();\n+        return s + sf + x + y + z + c + v1.hash() + v2.hash() + v3.hash() + v5.hash();\n@@ -104,0 +110,3 @@\n+        try {\n+            res += v4.hash();\n+        } catch (NullPointerException npe) {}\n@@ -109,1 +118,1 @@\n-        return s + sf + x + y + z + o + oa[0] + c + v1.hashInterpreted() + v2.hashInterpreted() + v3.hashInterpreted();\n+        return s + sf + x + y + z + o + oa[0] + c + v1.hashInterpreted() + v2.hashInterpreted() + v3.hashInterpreted() + v4.hashInterpreted() + v5.hashInterpreted();\n@@ -120,0 +129,4 @@\n+        System.out.print(\"], v4[\");\n+        v4.print();\n+        System.out.print(\"], v5[\");\n+        v5.print();\n@@ -125,1 +138,1 @@\n-        return new MyValue1(x, v.y, v.z, v.o, v.oa, v.v1, v.v2, v.c);\n+        return new MyValue1(x, v.y, v.z, v.o, v.oa, v.v1, v.v2, v.v4, v.v5, v.c);\n@@ -130,1 +143,1 @@\n-        return new MyValue1(v.x, y, v.z, v.o, v.oa, v.v1, v.v2, v.c);\n+        return new MyValue1(v.x, y, v.z, v.o, v.oa, v.v1, v.v2, v.v4, v.v5, v.c);\n@@ -135,1 +148,1 @@\n-        return new MyValue1(v.x, v.y, z, v.o, v.oa, v.v1, v.v2, v.c);\n+        return new MyValue1(v.x, v.y, z, v.o, v.oa, v.v1, v.v2, v.v4, v.v5, v.c);\n@@ -140,1 +153,1 @@\n-        return new MyValue1(v.x, v.y, v.z, o, v.oa, v.v1, v.v2, v.c);\n+        return new MyValue1(v.x, v.y, v.z, o, v.oa, v.v1, v.v2, v.v4, v.v5, v.c);\n@@ -145,1 +158,1 @@\n-        return new MyValue1(v.x, v.y, v.z, v.o, oa, v.v1, v.v2, v.c);\n+        return new MyValue1(v.x, v.y, v.z, v.o, oa, v.v1, v.v2, v.v4, v.v5, v.c);\n@@ -150,1 +163,1 @@\n-        return new MyValue1(v.x, v.y, v.z, v.o, v.oa, v.v1, v.v2, c);\n+        return new MyValue1(v.x, v.y, v.z, v.o, v.oa, v.v1, v.v2, v.v4, v.v5, c);\n@@ -155,1 +168,1 @@\n-        return new MyValue1(v.x, v.y, v.z, v.o, v.oa, v1, v.v2, v.c);\n+        return new MyValue1(v.x, v.y, v.z, v.o, v.oa, v1, v.v2, v.v4, v.v5, v.c);\n@@ -160,1 +173,11 @@\n-        return new MyValue1(v.x, v.y, v.z, v.o, v.oa, v.v1, v2, v.c);\n+        return new MyValue1(v.x, v.y, v.z, v.o, v.oa, v.v1, v2, v.v4, v.v5, v.c);\n+    }\n+\n+    @ForceInline\n+    static MyValue1 setV4(MyValue1 v, MyValue2.ref v4) {\n+        return new MyValue1(v.x, v.y, v.z, v.o, v.oa, v.v1, v.v2, v4, v.v5, v.c);\n+    }\n+\n+    @ForceInline\n+    static MyValue1 setV5(MyValue1 v, MyValue2.ref v5) {\n+        return new MyValue1(v.x, v.y, v.z, v.o, v.oa, v.v1, v.v2, v.v4, v5, v.c);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue1.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/\/ GENERATED FROM THE FOLLOWING JAVA FILE:\n+\/*\n+package compiler.valhalla.inlinetypes;\n+\n+primitive class MyValue5 {\n+    public int x = 42;\n+\n+    public MyValue5 withField(int x) {\n+        return __WithField(this.x, x);\n+    }\n+\n+    public static MyValue5.ref withField(MyValue5.ref val, int x) {\n+        return __WithField(val.x, x);\n+    }\n+}\n+*\/\n+\n+class compiler\/valhalla\/inlinetypes\/MyValue5 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  63; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/MyValue5\"; \/\/ #2\n+    Field #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"x\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"java\/lang\/Object\"; \/\/ #8\n+    Utf8 \"withField\"; \/\/ #9\n+    Utf8 \"(I)Qcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/MyValue5;I)Lcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #13\n+    Utf8 \"<init>\"; \/\/ #14\n+    Utf8 \"()Qcompiler\/valhalla\/inlinetypes\/MyValue5;\"; \/\/ #15\n+    Utf8 \"SourceFile\"; \/\/ #16\n+    Utf8 \"MyValue5.java\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0930; \/\/ access\n+  #1;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0011; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B2A5FCC0003B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #9; \/\/ name_index\n+      #13; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B2A5FCC0003B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  11;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #14; \/\/ name_index\n+      #15; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B102A2A5F;\n+            0xCC00034B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                4  4;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#16) { \/\/ SourceFile\n+      #17;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/MyValue5\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValue5.jcod","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.DontCompile;\n+import compiler.lib.ir_framework.DontInline;\n+import compiler.lib.ir_framework.ForceCompileClassInitializer;\n+import compiler.lib.ir_framework.ForceInline;\n+\n+@ForceCompileClassInitializer\n+public value class MyValueClass1 extends MyAbstract {\n+    static int s;\n+    static long sf = InlineTypes.rL;\n+    int x;\n+    long y;\n+    short z;\n+    Integer o;\n+    int[] oa;\n+    MyValueClass2 v1;\n+    MyValueClass2 v2;\n+    static MyValueClass2 v3 = MyValueClass2.createWithFieldsInline(InlineTypes.rI, InlineTypes.rD);\n+    MyValueClass2 v4;\n+    int c;\n+\n+    @ForceInline\n+    public MyValueClass1(int x, long y, short z, Integer o, int[] oa, MyValueClass2 v1, MyValueClass2 v2, MyValueClass2 v4, int c) {\n+        s = 0;\n+        this.x = x;\n+        this.y = y;\n+        this.z = z;\n+        this.o = o;\n+        this.oa = oa;\n+        this.v1 = v1;\n+        this.v2 = v2;\n+        this.v4 = v4;\n+        this.c = c;\n+    }\n+\n+    @DontInline\n+    static MyValueClass1 createDefaultDontInline() {\n+        return createDefaultInline();\n+    }\n+\n+    @ForceInline\n+    static MyValueClass1 createDefaultInline() {\n+        return MyValueClass1.default;\n+    }\n+\n+    @DontInline\n+    static MyValueClass1 createWithFieldsDontInline(int x, long y) {\n+        return createWithFieldsInline(x, y);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass1 createWithFieldsInline(int x, long y) {\n+        MyValueClass1 v = createDefaultInline();\n+        v = setX(v, x);\n+        v = setY(v, y);\n+        v = setZ(v, (short)x);\n+        \/\/ Don't use Integer.valueOf here to avoid control flow added by Integer cache check\n+        v = setO(v, new Integer(x));\n+        int[] oa = {x};\n+        v = setOA(v, oa);\n+        v = setV1(v, MyValueClass2.createWithFieldsInline(x, y, InlineTypes.rD));\n+        v = setV2(v, MyValueClass2.createWithFieldsInline(x + 1, y + 1, InlineTypes.rD + 1));\n+        v = setV4(v, MyValueClass2.createWithFieldsInline(x + 2, y + 2, InlineTypes.rD + 2));\n+        v = setC(v, (int)(x+y));\n+        return v;\n+    }\n+\n+    \/\/ Hash only primitive and inline type fields to avoid NullPointerException\n+    @ForceInline\n+    public long hashPrimitive() {\n+        return s + sf + x + y + z + c + v1.hash() + v2.hash() + v3.hash();\n+    }\n+\n+    @ForceInline\n+    public long hash() {\n+        long res = hashPrimitive();\n+        try {\n+            res += o;\n+        } catch (NullPointerException npe) {}\n+        try {\n+            res += oa[0];\n+        } catch (NullPointerException npe) {}\n+        try {\n+            res += v4.hash();\n+        } catch (NullPointerException npe) {}\n+        return res;\n+    }\n+\n+    @DontCompile\n+    public long hashInterpreted() {\n+        return s + sf + x + y + z + o + oa[0] + c + v1.hashInterpreted() + v2.hashInterpreted() + v3.hashInterpreted() + v4.hashInterpreted();\n+    }\n+\n+    @ForceInline\n+    public void print() {\n+        System.out.print(\"s=\" + s + \", sf=\" + sf + \", x=\" + x + \", y=\" + y + \", z=\" + z + \", o=\" + (o != null ? (Integer)o : \"NULL\") + \", oa=\" + (oa != null ? oa[0] : \"NULL\") + \", v1[\");\n+        v1.print();\n+        System.out.print(\"], v2[\");\n+        v2.print();\n+        System.out.print(\"], v3[\");\n+        v3.print();\n+        System.out.print(\"], v4[\");\n+        v4.print();\n+        System.out.print(\"], c=\" + c);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass1 setX(MyValueClass1 v, int x) {\n+        return new MyValueClass1(x, v.y, v.z, v.o, v.oa, v.v1, v.v2, v.v4, v.c);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass1 setY(MyValueClass1 v, long y) {\n+        return new MyValueClass1(v.x, y, v.z, v.o, v.oa, v.v1, v.v2, v.v4, v.c);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass1 setZ(MyValueClass1 v, short z) {\n+        return new MyValueClass1(v.x, v.y, z, v.o, v.oa, v.v1, v.v2, v.v4, v.c);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass1 setO(MyValueClass1 v, Integer o) {\n+        return new MyValueClass1(v.x, v.y, v.z, o, v.oa, v.v1, v.v2, v.v4, v.c);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass1 setOA(MyValueClass1 v, int[] oa) {\n+        return new MyValueClass1(v.x, v.y, v.z, v.o, oa, v.v1, v.v2, v.v4, v.c);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass1 setC(MyValueClass1 v, int c) {\n+        return new MyValueClass1(v.x, v.y, v.z, v.o, v.oa, v.v1, v.v2, v.v4, c);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass1 setV1(MyValueClass1 v, MyValueClass2 v1) {\n+        return new MyValueClass1(v.x, v.y, v.z, v.o, v.oa, v1, v.v2, v.v4, v.c);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass1 setV2(MyValueClass1 v, MyValueClass2 v2) {\n+        return new MyValueClass1(v.x, v.y, v.z, v.o, v.oa, v.v1, v2, v.v4, v.c);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass1 setV4(MyValueClass1 v, MyValueClass2 v4) {\n+        return new MyValueClass1(v.x, v.y, v.z, v.o, v.oa, v.v1, v.v2, v4, v.c);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValueClass1.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.DontInline;\n+import compiler.lib.ir_framework.ForceInline;\n+\n+value class MyValueClass2Inline {\n+    double d;\n+    long l;\n+\n+    @ForceInline\n+    public MyValueClass2Inline(double d, long l) {\n+        this.d = d;\n+        this.l = l;\n+    }\n+\n+    @ForceInline\n+    static MyValueClass2Inline setD(MyValueClass2Inline v, double d) {\n+        return new MyValueClass2Inline(d, v.l);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass2Inline setL(MyValueClass2Inline v, long l) {\n+        return new MyValueClass2Inline(v.d, l);\n+    }\n+\n+    @ForceInline\n+    public static MyValueClass2Inline createDefault() {\n+        return MyValueClass2Inline.default;\n+    }\n+\n+    @ForceInline\n+    public static MyValueClass2Inline createWithFieldsInline(double d, long l) {\n+        MyValueClass2Inline v = MyValueClass2Inline.createDefault();\n+        v = MyValueClass2Inline.setD(v, d);\n+        v = MyValueClass2Inline.setL(v, l);\n+        return v;\n+    }\n+}\n+\n+public value class MyValueClass2 extends MyAbstract {\n+    int x;\n+    byte y;\n+    MyValueClass2Inline v;\n+\n+    @ForceInline\n+    public MyValueClass2(int x, byte y, MyValueClass2Inline v) {\n+        this.x = x;\n+        this.y = y;\n+        this.v = v;\n+    }\n+\n+    @ForceInline\n+    public static MyValueClass2 createDefaultInline() {\n+        return MyValueClass2.default;\n+    }\n+\n+    @ForceInline\n+    public static MyValueClass2 createWithFieldsInline(int x, long y, double d) {\n+        MyValueClass2 v = createDefaultInline();\n+        v = setX(v, x);\n+        v = setY(v, (byte)x);\n+        v = setV(v, MyValueClass2Inline.createWithFieldsInline(d, y));\n+        return v;\n+    }\n+\n+    @ForceInline\n+    public static MyValueClass2 createWithFieldsInline(int x, double d) {\n+        MyValueClass2 v = createDefaultInline();\n+        v = setX(v, x);\n+        v = setY(v, (byte)x);\n+        v = setV(v, MyValueClass2Inline.createWithFieldsInline(d, InlineTypes.rL));\n+        return v;\n+    }\n+\n+    @DontInline\n+    public static MyValueClass2 createWithFieldsDontInline(int x, double d) {\n+        MyValueClass2 v = createDefaultInline();\n+        v = setX(v, x);\n+        v = setY(v, (byte)x);\n+        v = setV(v, MyValueClass2Inline.createWithFieldsInline(d, InlineTypes.rL));\n+        return v;\n+    }\n+\n+    @ForceInline\n+    public long hash() {\n+        return x + y + (long)v.d + v.l;\n+    }\n+\n+    @DontInline\n+    public long hashInterpreted() {\n+        return x + y + (long)v.d + v.l;\n+    }\n+\n+    @ForceInline\n+    public void print() {\n+        System.out.print(\"x=\" + x + \", y=\" + y + \", d=\" + v.d + \", l=\" + v.l);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass2 setX(MyValueClass2 v, int x) {\n+        return new MyValueClass2(x, v.y, v.v);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass2 setY(MyValueClass2 v, byte y) {\n+        return new MyValueClass2(v.x, y, v.v);\n+    }\n+\n+    @ForceInline\n+    static MyValueClass2 setV(MyValueClass2 v, MyValueClass2Inline vi) {\n+        return new MyValueClass2(v.x, v.y, vi);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/MyValueClass2.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -63,0 +63,5 @@\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n@@ -2052,1 +2057,5 @@\n-    @IR(failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n+        counts = {INLINE_ARRAY_NULL_GUARD, \"= 2\", ALLOC_G, \"= 1\"})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n@@ -2084,1 +2093,5 @@\n-    @IR(failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n+        counts = {INLINE_ARRAY_NULL_GUARD, \"= 2\", ALLOC_G, \"= 1\"})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-        counts = {ALLOC, \"= 1\", STORE, \"= 14\"},\n+        counts = {ALLOC, \"= 1\", STORE, \"= 19\"},\n@@ -156,2 +156,0 @@\n-        failOn = {LOAD, TRAP, ALLOC})\n-    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n@@ -160,0 +158,3 @@\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC, \"= 2\"},\n+        failOn = {LOAD, TRAP})\n@@ -175,1 +176,1 @@\n-    @IR(counts = {ALLOC, \"= 1\"},\n+    @IR(counts = {ALLOC, \"= 2\"},\n@@ -209,2 +210,3 @@\n-        counts = {LOAD, \"= 14\"},\n-        failOn = {TRAP, ALLOC, STORE})\n+        counts = {ALLOC, \"= 1\", LOAD, \"= 19\",\n+                  STORE, \"= 3\"}, \/\/ InitializeNode::coalesce_subword_stores merges stores\n+        failOn = {TRAP})\n@@ -212,1 +214,1 @@\n-        counts = {ALLOC, \"= 1\", STORE, \"= 13\"},\n+        counts = {ALLOC, \"= 2\", STORE, \"= 19\"},\n@@ -284,2 +286,1 @@\n-        counts = {SCOBJ, \">= 1\"}, \/\/ at least 1\n-        failOn = LOAD)\n+        counts = {SCOBJ, \">= 1\", LOAD, \"<= 12\"}) \/\/ TODO 8227588 (loads should be removed)\n@@ -349,1 +350,1 @@\n-        counts = {LOAD, \"= 14\"})\n+        counts = {LOAD, \"= 19\"})\n@@ -367,2 +368,0 @@\n-        failOn = {LOAD, TRAP, ALLOC})\n-    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n@@ -371,0 +370,3 @@\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {LOAD, TRAP},\n+        counts = {ALLOC, \"= 2\"})\n@@ -417,2 +419,0 @@\n-        failOn = {ALLOC, LOAD, TRAP})\n-    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n@@ -421,0 +421,3 @@\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC, \"= 2\"},\n+        failOn = {LOAD, TRAP})\n@@ -438,2 +441,0 @@\n-        failOn = {ALLOC, LOAD, TRAP})\n-    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n@@ -442,0 +443,3 @@\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC, \"= 2\"},\n+        failOn = {LOAD, TRAP})\n@@ -464,1 +468,2 @@\n-        failOn = {LOAD, ALLOC, STORE})\n+        counts = {ALLOC, \"= 1\", STORE, \"= 1\"},  \/\/ InitializeNode::coalesce_subword_stores merges stores\n+        failOn = {LOAD})\n@@ -466,1 +471,1 @@\n-        counts = {ALLOC, \"= 1\"},\n+        counts = {ALLOC, \"= 2\"},\n@@ -496,1 +501,1 @@\n-    @IR(counts = {ALLOC, \"= 1\"},\n+    @IR(counts = {ALLOC, \"= 2\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-        MyValue1 mv1 = new MyValue1(1, 2L, (short)3, 4, null, mv2a, mv2b, 'z');\n+        MyValue1 mv1 = new MyValue1(1, 2L, (short)3, 4, null, mv2a, mv2b, mv2a, mv2b, 'z');\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,3 @@\n+\n+            mt = MethodType.methodType(MyValue2.class, boolean.class);\n+            test56_mh = lookup.findVirtual(clazz, \"test56_callee\", mt);\n@@ -1231,0 +1234,39 @@\n+\n+    @DontInline\n+    public MyValue2.ref test55_callee() {\n+        return MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    \/\/ Test scalarization of nullable return value that is unused\n+    @Test\n+    public void test55() {\n+        test55_callee();\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier() {\n+        test55();\n+    }\n+\n+    static MethodHandle test56_mh;\n+\n+    @DontInline\n+    public MyValue2.ref test56_callee(boolean b) {\n+        return b ? MyValue2.createWithFieldsInline(rI, rD) : null;\n+    }\n+\n+    \/\/ Test that scalarization of nullable return works properly for method handle calls\n+    @Test\n+    public MyValue2.ref test56(boolean b) throws Throwable {\n+        return (MyValue2.ref)test56_mh.invokeExact(this, b);\n+    }\n+\n+    @Run(test = \"test56\")\n+    @Warmup(10000)\n+    public void test56_verifier(RunInfo info) throws Throwable {\n+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);\n+        Asserts.assertEQ(test56(true).hash(), vt.hash());\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEQ(test56(false), null);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConvention.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1737,1 +1737,1 @@\n-    \/\/ Tests for how C1 handles InlineTypeReturnedAsFields in both calls and returns (RefPoint?)\n+    \/\/ Tests for how C1 handles InlineTypeReturnedAsFields in both calls and returns (RefPoint.ref)\n@@ -1754,2 +1754,2 @@\n-        Object result = test87(null);\n-        Asserts.assertEQ(result, null);\n+        Asserts.assertEQ(test87(null), null);\n+        Asserts.assertEQ(test87(refPointField1), refPointField1);\n@@ -1772,2 +1772,1 @@\n-        Object result = test88();\n-        Asserts.assertEQ(result, null);\n+        Asserts.assertEQ(test88(), null);\n@@ -1790,2 +1789,2 @@\n-        Object result = test89(null);\n-        Asserts.assertEQ(result, null);\n+        Asserts.assertEQ(test89(null), null);\n+        Asserts.assertEQ(test89(refPointField1), refPointField1);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestCallingConventionC1.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -70,0 +70,5 @@\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n@@ -793,0 +798,2 @@\n+        result = test41(MyValue1.class.asPrimaryType(), null);\n+        Asserts.assertFalse(result);\n@@ -795,0 +802,2 @@\n+        result = test41(MyValue1.class.asValueType(), null);\n+        Asserts.assertFalse(result);\n@@ -807,0 +816,2 @@\n+        result = test42(MyValue2.class.asPrimaryType(), null);\n+        Asserts.assertFalse(result);\n@@ -809,0 +820,2 @@\n+        result = test42(MyValue2.class.asValueType(), null);\n+        Asserts.assertFalse(result);\n@@ -821,1 +834,1 @@\n-        Asserts.assertEQ(((MyValue1)result).hash(), vt.hash());\n+        Asserts.assertEQ(result, vt);\n@@ -824,0 +837,9 @@\n+        result = test43(MyValue1.class.asValueType(), vt);\n+        Asserts.assertEQ(result, vt);\n+        try {\n+            test43(MyValue1.class.asValueType(), null);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (NullPointerException npe) {\n+        }\n+        result = test43(Integer.class, null);\n+        Asserts.assertEQ(result, null);\n@@ -839,0 +861,12 @@\n+        Object res = test44(MyValue2.class.asPrimaryType(), null);\n+        Asserts.assertEQ(res, null);\n+        try {\n+            test44(MyValue2.class.asValueType(), vt);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+        try {\n+            test44(MyValue2.class.asValueType(), null);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (NullPointerException npe) {\n+        }\n@@ -863,1 +897,2 @@\n-        test46(null);\n+        Object result = test46(null);\n+        Asserts.assertEQ(result, null);\n@@ -1041,1 +1076,1 @@\n-    public void test54_callee(MyValue1.ref v) { \/\/ Use .ref here to make sure the argument is not scalarized (otherwise larval information is lost)\n+    public void test54_callee(Object v) { \/\/ Use Object here to make sure the argument is not scalarized (otherwise larval information is lost)\n@@ -1557,0 +1592,36 @@\n+\n+    @Test\n+    public Object test78(MyValue1.ref vt) {\n+        return Integer.class.cast(vt);\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier() {\n+        Object result = test78(null);\n+        Asserts.assertEQ(result, null);\n+        try {\n+            test78(MyValue1.createWithFieldsInline(rI, rL));\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+\n+    \/\/ TODO 8284443 Fix this in GraphKit::gen_checkcast\n+    \/*\n+    @Test\n+    public Object test79(MyValue1.ref vt) {\n+        Object tmp = vt;\n+        return (Integer)tmp;\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier() {\n+        Object result = test79(null);\n+        Asserts.assertEQ(result, null);\n+        try {\n+            test79(MyValue1.createWithFieldsInline(rI, rL));\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch (ClassCastException cce) {\n+        }\n+    }\n+    *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":74,"deletions":3,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.experimental.bytecode.TypeTag;\n@@ -45,0 +46,1 @@\n+ * @compile MyValue5.jcod\n@@ -73,0 +75,5 @@\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n@@ -567,1 +574,1 @@\n-    @IR(failOn = {ALLOC_G})\n+    @IR(failOn = {ALLOC})\n@@ -1078,1 +1085,0 @@\n-    @IR(failOn = {ALLOC_G})\n@@ -1332,1 +1338,1 @@\n-        Asserts.assertEQ(result, testValue1.hash());\n+        Asserts.assertEQ(result, testValue1.hashInterpreted());\n@@ -1334,1 +1340,1 @@\n-        Asserts.assertEQ(result, testValue1.hash());\n+        Asserts.assertEQ(result, testValue1.hashInterpreted());\n@@ -1416,1 +1422,0 @@\n-    @IR(failOn = {ALLOC_G})\n@@ -1622,1 +1627,1 @@\n-    @IR(failOn = {ALLOC_G})\n+    @IR(failOn = {ALLOC})\n@@ -3686,1 +3691,5 @@\n-    @IR(failOn = {ALLOC, LOAD, STORE})\n+    @IR(failOn = {LOAD},\n+        \/\/ LockNode keeps MyValue1 allocation alive up until macro expansion which in turn keeps MyValue2\n+        \/\/ alloc alive. Although the MyValue1 allocation is removed (unused), MyValue2 is expanded first\n+        \/\/ and therefore stays.\n+        counts = {ALLOC, \"<= 1\", STORE, \"<= 1\"})\n@@ -4019,1 +4028,0 @@\n-    @IR(failOn = {ALLOC_G})\n@@ -4285,0 +4293,84 @@\n+\n+    \/\/ Test withfield directly operating on inline type arg (instead of on defaultvalue)\n+    @Test\n+    public MyValue5 test156(MyValue5 vt) {\n+        return vt.withField(rI);\n+    }\n+\n+    @Run(test = \"test156\")\n+    @Warmup(10000)\n+    public void test156_verifier() {\n+        Asserts.assertEquals(test156(new MyValue5()).x, rI);\n+    }\n+\n+    final static MyValue1 test157Cache = MyValue1.createWithFieldsInline(rI, 0);\n+\n+    \/\/ Test merging buffered inline type from field load with non-buffered inline type\n+    @Test\n+    public MyValue1 test157(long val) {\n+        return (val == 0L) ? test157Cache : MyValue1.createWithFieldsInline(rI, val);\n+    }\n+\n+    @Run(test = \"test157\")\n+    public void test157_verifier() {\n+        Asserts.assertEquals(test157(0), test157Cache);\n+        Asserts.assertEquals(test157(rL).hash(), testValue1.hash());\n+    }\n+\n+    static MyValue1 test158Cache = MyValue1.createWithFieldsInline(rI, 0);\n+\n+    \/\/ Same as test157 but with non-final field load\n+    @Test\n+    public MyValue1 test158(long val) {\n+        return (val == 0L) ? test158Cache : MyValue1.createWithFieldsInline(rI, val);\n+    }\n+\n+    @Run(test = \"test158\")\n+    public void test158_verifier() {\n+        Asserts.assertEquals(test158(0), test158Cache);\n+        Asserts.assertEquals(test158(rL).hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Test null check on withfield receiver\n+    @Test\n+    public MyValue5.ref test159(MyValue5.ref vt) {\n+        return MyValue5.withField(vt, rI);\n+    }\n+\n+    @Run(test = \"test159\")\n+    @Warmup(10000)\n+    public void test159_verifier(RunInfo info) {\n+        Asserts.assertEquals(test159(new MyValue5()).x, rI);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test159(null);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Verify that cast that with incompatible types is properly handled\n+    @Test\n+    public void test160(Integer arg) {\n+        Object tmp = arg;\n+        MyValue1 res = (MyValue1)tmp;\n+    }\n+\n+    @Run(test = \"test160\")\n+    @Warmup(10000)\n+    public void test160_verifier(RunInfo info) {\n+        try {\n+            test160(42);\n+            throw new RuntimeException(\"No CCE thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test160(null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":100,"deletions":8,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -414,3 +414,2 @@\n-\n-            if (deopt && !WBFlags.TieredCompilation && WBFlags.ProfileInterpreter &&\n-                         (WBFlags.UseArrayLoadStoreProfile || WBFlags.TypeProfileLevel == 222)) {\n+            if (deopt && TestFramework.isStableDeopt(m, CompLevel.C2) && !WBFlags.TieredCompilation && WBFlags.ProfileInterpreter &&\n+                (WBFlags.UseArrayLoadStoreProfile || WBFlags.TypeProfileLevel == 222)) {\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,0 +64,5 @@\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.experimental.bytecode.TypeTag;\n+import test.java.lang.invoke.lib.InstructionHelper;\n@@ -41,1 +43,1 @@\n- * @library \/test\/lib \/\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common \/\n@@ -43,0 +45,1 @@\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n@@ -59,1 +62,3 @@\n-                                     MyValue2Inline.class)\n+                                     MyValue2Inline.class,\n+                                     MyValue3.class,\n+                                     MyValue3Inline.class)\n@@ -64,0 +69,2 @@\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n@@ -166,1 +173,3 @@\n-    @IR(failOn = {ALLOC})\n+    \/\/ TODO 8284443 When passing vt to test5_inline and incrementally inlining, we lose the oop\n+    @IR(applyIfOr = {\"InlineTypePassFieldsAsArgs\", \"false\", \"AlwaysIncrementalInline\", \"false\"},\n+        failOn = {ALLOC})\n@@ -184,0 +193,1 @@\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n@@ -509,1 +519,3 @@\n-    @IR(failOn = {ALLOC})\n+    \/\/ TODO 8284443 When passing testValue1 to the constructor in scalarized form and incrementally inlining, we lose the oop\n+    @IR(applyIfOr = {\"InlineTypePassFieldsAsArgs\", \"false\", \"AlwaysIncrementalInline\", \"false\"},\n+        failOn = {ALLOC})\n@@ -512,3 +524,0 @@\n-        if ((Object)vt1.valueField != null) {\n-            throw new RuntimeException(\"Should be null\");\n-        }\n@@ -672,1 +681,4 @@\n-    @IR(failOn = {ALLOC})\n+    @IR(applyIfAnd = {\"FlatArrayElementMaxSize\", \"= -1\", \"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC})\n+    @IR(applyIfAnd = {\"FlatArrayElementMaxSize\", \"= 0\", \"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC})\n@@ -2022,1 +2034,0 @@\n-        RuntimeException tmp = new RuntimeException(\"42\"); \/\/ Make sure RuntimeException is loaded\n@@ -2371,1 +2382,2 @@\n-        failOn = {ALLOC, LOAD, STORE})\n+        failOn = {ALLOC, STORE},\n+        counts = {LOAD, \" = 4\"}) \/\/ 4 loads from the non-flattened MyValue1.v4 fields\n@@ -2495,1 +2507,2 @@\n-    @IR(failOn = {ALLOC, CMPP})\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC, CMPP})\n@@ -2518,0 +2531,189 @@\n+\n+    private static final MethodHandle refCheckCast = InstructionHelper.loadCode(MethodHandles.lookup(),\n+        \"refCheckCast\",\n+        MethodType.methodType(MyValue2.class.asPrimaryType(), TestNullableInlineTypes.class, MyValue1.class.asPrimaryType()),\n+        CODE -> {\n+            CODE.\n+            aload_1().\n+            checkcast(MyValue2.class.asPrimaryType()).\n+            return_(TypeTag.A);\n+        });\n+\n+    \/\/ Test checkcast that only passes with null\n+    @Test\n+    public Object test93(MyValue1.ref vt) throws Throwable {\n+        return refCheckCast.invoke(this, vt);\n+    }\n+\n+    @Run(test = \"test93\")\n+    @Warmup(10000)\n+    public void test93_verifier() throws Throwable {\n+        Asserts.assertEQ(test93(null), null);\n+    }\n+\n+    @DontInline\n+    public MyValue1.ref test94_helper1(MyValue1.ref vt) {\n+        return vt;\n+    }\n+\n+    @ForceInline\n+    public MyValue1.ref test94_helper2(MyValue1.ref vt) {\n+        return test94_helper1(vt);\n+    }\n+\n+    @ForceInline\n+    public MyValue1.ref test94_helper3(Object vt) {\n+        return test94_helper2((MyValue1.ref)vt);\n+    }\n+\n+    \/\/ Test that calling convention optimization prevents buffering of arguments\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC_G, \" = 2\"}) \/\/ 1 MyValue2 allocation + 1 Integer allocation\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC_G, \" = 3\"}) \/\/ 1 MyValue1 allocation + 1 MyValue2 allocation + 1 Integer allocation\n+    public MyValue1.ref test94(MyValue1.ref vt) {\n+        MyValue1.ref res = test94_helper1(vt);\n+        vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test94_helper1(vt);\n+        test94_helper2(vt);\n+        test94_helper3(vt);\n+        return res;\n+    }\n+\n+    @Run(test = \"test94\")\n+    public void test94_verifier() {\n+        Asserts.assertEQ(test94(testValue1), testValue1);\n+        Asserts.assertEQ(test94(null), null);\n+    }\n+\n+    @DontInline\n+    public static MyValue1.ref test95_helper1(MyValue1.ref vt) {\n+        return vt;\n+    }\n+\n+    @ForceInline\n+    public static MyValue1.ref test95_helper2(MyValue1.ref vt) {\n+        return test95_helper1(vt);\n+    }\n+\n+    @ForceInline\n+    public static MyValue1.ref test95_helper3(Object vt) {\n+        return test95_helper2((MyValue1.ref)vt);\n+    }\n+\n+    \/\/ Same as test94 but with static methods to trigger simple adapter logic\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC_G, \" = 2\"}) \/\/ 1 MyValue2 allocation + 1 Integer allocation\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC_G, \" = 3\"}) \/\/ 1 MyValue1 allocation + 1 MyValue2 allocation + 1 Integer allocation\n+    public static MyValue1.ref test95(MyValue1.ref vt) {\n+        MyValue1.ref res = test95_helper1(vt);\n+        vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test95_helper1(vt);\n+        test95_helper2(vt);\n+        test95_helper3(vt);\n+        return res;\n+    }\n+\n+    @Run(test = \"test95\")\n+    public void test95_verifier() {\n+        Asserts.assertEQ(test95(testValue1), testValue1);\n+        Asserts.assertEQ(test95(null), null);\n+    }\n+\n+    @DontInline\n+    public MyValue2.ref test96_helper1(boolean b) {\n+        return b ? null : MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    @ForceInline\n+    public MyValue2.ref test96_helper2() {\n+        return null;\n+    }\n+\n+    @ForceInline\n+    public MyValue2.ref test96_helper3(boolean b) {\n+        return b ? null : MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    \/\/ Test that calling convention optimization prevents buffering of return values\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC_G})\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"false\"},\n+        counts = {ALLOC_G, \" = 1\"})\n+    public MyValue2.ref test96(int c, boolean b) {\n+        MyValue2.ref res = null;\n+        if (c == 1) {\n+            res = test96_helper1(b);\n+        } else if (c == 2) {\n+            res = test96_helper2();\n+        } else if (c == 3) {\n+            res = test96_helper3(b);\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test96\")\n+    public void test96_verifier() {\n+        Asserts.assertEQ(test96(0, false), null);\n+        Asserts.assertEQ(test96(1, false).hash(), MyValue2.createWithFieldsInline(rI, rD).hash());\n+        Asserts.assertEQ(test96(1, true), null);\n+        Asserts.assertEQ(test96(2, false), null);\n+        Asserts.assertEQ(test96(3, false).hash(), MyValue2.createWithFieldsInline(rI, rD).hash());\n+        Asserts.assertEQ(test96(3, true), null);\n+    }\n+\n+    @DontInline\n+    public MyValue3.ref test97_helper1(boolean b) {\n+        return b ? null: MyValue3.create();\n+    }\n+\n+    @ForceInline\n+    public MyValue3.ref test97_helper2() {\n+        return null;\n+    }\n+\n+    @ForceInline\n+    public MyValue3.ref test97_helper3(boolean b) {\n+        return b ? null: MyValue3.create();\n+    }\n+\n+    MyValue3 test97_res1;\n+    MyValue3 test97_res3;\n+\n+    \/\/ Same as test96 but with MyValue3 return\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC_G})\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"false\"},\n+        counts = {ALLOC_G, \" = 1\"})\n+    public MyValue3.ref test97(int c, boolean b) {\n+        MyValue3.ref res = null;\n+        if (c == 1) {\n+            res = test97_helper1(b);\n+            if (res != null) {\n+                test97_res1 = res;\n+            }\n+        } else if (c == 2) {\n+            res = test97_helper2();\n+        } else if (c == 3) {\n+            res = test97_helper3(b);\n+            if (res != null) {\n+                test97_res3 = res;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test97\")\n+    public void test97_verifier() {\n+        Asserts.assertEQ(test97(0, false), null);\n+        Asserts.assertEQ(test97(1, false), test97_res1);\n+        Asserts.assertEQ(test97(1, true), null);\n+        Asserts.assertEQ(test97(2, false), null);\n+        Asserts.assertEQ(test97(3, false), test97_res3);\n+        Asserts.assertEQ(test97(3, true), null);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":213,"deletions":11,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test that oop fields of value\/primitive classes are preserved over safepoints at returns.\n+ * @run main\/othervm -XX:CompileCommand=dontinline,TestSafepointAtPollReturn::test* -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+SafepointALot -XX:-TieredCompilation TestSafepointAtPollReturn\n+ *\/\n+\n+public class TestSafepointAtPollReturn {\n+    static Integer INT_VAL = 0;\n+\n+    static value class MyValue {\n+        Integer val = INT_VAL;\n+    }\n+\n+    static primitive class MyPrimitive {\n+        Integer val = INT_VAL;\n+    }\n+\n+    static public MyValue testValueCallee(boolean b) {\n+        return b ? null : new MyValue();\n+    }\n+\n+    static public MyValue testValue(boolean b) {\n+        return testValueCallee(b);\n+    }\n+\n+    static public MyPrimitive testPrimitiveCallee() {\n+        return new MyPrimitive();\n+    }\n+\n+    static public MyPrimitive testPrimitive() {\n+        return testPrimitiveCallee();\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 1_000_000_000; ++i) {\n+            INT_VAL = i;\n+            boolean b = (i % 2) == 0;\n+            MyValue val = testValue(b);\n+            if (b) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"testValue failed: result should be null\");\n+                }\n+            } else {\n+                int res = val.val;\n+                if (res != i) {\n+                    throw new RuntimeException(\"testValue failed: \" + res + \" != \" + i);\n+                }\n+            }\n+            int res = testPrimitive().val;\n+            if (res != i) {\n+                throw new RuntimeException(\"testPrimitive failed: \" + res + \" != \" + i);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestSafepointAtPollReturn.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test scalarization in returns with unloaded return types.\n+ * @library \/test\/lib \/compiler\/whitebox \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=dontinline,*::test*\n+ *                   TestUnloadedReturnTypes\n+ *\/\n+\n+import java.lang.reflect.Method;\n+\n+import sun.hotspot.WhiteBox;\n+\n+primitive class MyPrimitive {\n+    int x;\n+\n+    public MyPrimitive(int x) {\n+        this.x = x;\n+    }\n+}\n+\n+value class MyValue {\n+    int x;\n+\n+    public MyValue(int x) {\n+        this.x = x;\n+    }\n+}\n+\n+class MyClass {\n+\n+    static MyPrimitive test1() {\n+        return new MyPrimitive(42);\n+    }\n+\n+    static MyPrimitive.ref test2(boolean b) {\n+        return b ? new MyPrimitive(42) : null;\n+    }\n+\n+    static MyValue test3(boolean b) {\n+        return b ? new MyValue(42) : null;\n+    }\n+}\n+\n+public class TestUnloadedReturnTypes {\n+    public static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    static Object res1 = null;\n+\n+    public static void test1() {\n+        res1 = MyClass.test1();\n+    }\n+\n+    static Object res2 = null;\n+\n+    public static void test2(boolean b) {\n+        res2 = MyClass.test2(b);\n+    }\n+\n+    static Object res3 = null;\n+\n+    public static void test3(boolean b) {\n+        res3 = MyClass.test3(b);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ C1 compile all caller methods\n+        Method m = TestUnloadedReturnTypes.class.getMethod(\"test1\");\n+        WHITE_BOX.enqueueMethodForCompilation(m, 3);\n+\n+        m = TestUnloadedReturnTypes.class.getMethod(\"test2\", boolean.class);\n+        WHITE_BOX.enqueueMethodForCompilation(m, 3);\n+\n+        m = TestUnloadedReturnTypes.class.getMethod(\"test3\", boolean.class);\n+        WHITE_BOX.enqueueMethodForCompilation(m, 3);\n+\n+        \/\/ Make sure the callee methods are C2 compiled\n+        for (int i = 0; i < 100_000; ++i) {\n+            MyClass.test1();\n+            MyClass.test2((i % 2) == 0);\n+            MyClass.test3((i % 2) == 0);\n+        }\n+\n+        test1();\n+        if (((MyPrimitive)res1).x != 42) {\n+            throw new RuntimeException(\"Test1 failed\");\n+        }\n+\n+        test2(true);\n+        if (((MyPrimitive)res2).x != 42) {\n+            throw new RuntimeException(\"Test2 failed\");\n+        }\n+\n+        test2(false);\n+        if (res2 != null) {\n+            throw new RuntimeException(\"Test2 failed\");\n+        }\n+        test3(true);\n+        if (((MyValue)res3).x != 42) {\n+            throw new RuntimeException(\"Test3 failed\");\n+        }\n+\n+        test3(false);\n+        if (res3 != null) {\n+            throw new RuntimeException(\"Test3 failed\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestUnloadedReturnTypes.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,956 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.experimental.bytecode.TypeTag;\n+import test.java.lang.invoke.lib.InstructionHelper;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypes.IRNode.*;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of value classes.\n+ * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver\/timeout=300 compiler.valhalla.inlinetypes.TestValueClasses\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestValueClasses {\n+\n+    public static void main(String[] args) {\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        \/\/ Don't generate bytecodes but call through runtime for reflective calls\n+        scenarios[0].addFlags(\"-Dsun.reflect.inflationThreshold=10000\");\n+        scenarios[1].addFlags(\"-Dsun.reflect.inflationThreshold=10000\");\n+        scenarios[3].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:FlatArrayElementMaxSize=-1\");\n+        scenarios[4].addFlags(\"-XX:-UseTLAB\", \"-XX:-MonomorphicArrayCheck\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValueClass1.class,\n+                                     MyValueClass2.class,\n+                                     MyValueClass2Inline.class)\n+                   .start();\n+    }\n+\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n+    private static final MyValueClass1 testValue1 = MyValueClass1.createWithFieldsInline(rI, rL);\n+\n+    MyValueClass1 nullValField = null;\n+    MyValueClass1 testField1;\n+    MyValueClass1 testField2;\n+    MyValueClass1 testField3;\n+    MyValueClass1 testField4;\n+    static MyValueClass1 testField5;\n+    static MyValueClass1 testField6;\n+    static MyValueClass1 testField7;\n+    static MyValueClass1 testField8;\n+\n+    \/\/ Test field loads\n+    @Test\n+    public long test1(boolean b) {\n+        MyValueClass1 val1 = b ? testField3 : MyValueClass1.createWithFieldsInline(rI, rL);\n+        MyValueClass1 val2 = b ? testField7 : MyValueClass1.createWithFieldsInline(rI, rL);\n+        long res = 0;\n+        res += testField1.hash();\n+        res += ((Object)testField2 == null) ? 42 : testField2.hash();\n+        res += val1.hash();\n+        res += testField4.hash();\n+\n+        res += testField5.hash();\n+        res += ((Object)testField6 == null) ? 42 : testField6.hash();\n+        res += val2.hash();\n+        res += testField8.hash();\n+        return res;\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        testField1 = testValue1;\n+        testField2 = nullValField;\n+        testField3 = testValue1;\n+        testField4 = testValue1;\n+\n+        testField5 = testValue1;\n+        testField6 = nullValField;\n+        testField7 = testValue1;\n+        testField8 = testValue1;\n+        long res = test1(true);\n+        Asserts.assertEquals(res, 2*42 + 6*testValue1.hash());\n+\n+        testField2 = testValue1;\n+        testField6 = testValue1;\n+        res = test1(false);\n+        Asserts.assertEquals(res, 8*testValue1.hash());\n+    }\n+\n+    \/\/ Test field stores\n+    @Test\n+    public MyValueClass1 test2(MyValueClass1 val1) {\n+        MyValueClass1 ret = MyValueClass1.createWithFieldsInline(rI, rL);\n+        MyValueClass1 val2 = MyValueClass1.setV4(testValue1, null);\n+        testField1 = testField4;\n+        testField2 = val1;\n+        testField3 = val2;\n+\n+        testField5 = ret;\n+        testField6 = val1;\n+        testField7 = val2;\n+        testField8 = testField4;\n+        return ret;\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        testField4 = testValue1;\n+        MyValueClass1 ret = test2(null);\n+        MyValueClass1 val2 = MyValueClass1.setV4(testValue1, null);\n+        Asserts.assertEquals(testField1, testValue1);\n+        Asserts.assertEquals(testField2, null);\n+        Asserts.assertEquals(testField3, val2);\n+\n+        Asserts.assertEquals(testField5, ret);\n+        Asserts.assertEquals(testField6, null);\n+        Asserts.assertEquals(testField7, val2);\n+        Asserts.assertEquals(testField8, testField4);\n+\n+        testField4 = null;\n+        test2(null);\n+        Asserts.assertEquals(testField1, testField4);\n+        Asserts.assertEquals(testField8, testField4);\n+    }\n+\n+    \/\/ Non-primitive Wrapper\n+    static class Test3Wrapper {\n+        MyValueClass1 val;\n+\n+        public Test3Wrapper(MyValueClass1 val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Test scalarization in safepoint debug info and re-allocation on deopt\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public long test3(boolean deopt, boolean b1, boolean b2, Method m) {\n+        MyValueClass1 ret = MyValueClass1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            ret = null;\n+        }\n+        if (b2) {\n+            ret = MyValueClass1.setV4(ret, null);\n+        }\n+        Test3Wrapper wrapper = new Test3Wrapper(ret);\n+        if (deopt) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        long res = ((Object)ret != null && (Object)ret.v4 != null) ? ret.hash() : 42;\n+        res += ((Object)wrapper.val != null && (Object)wrapper.val.v4 != null) ? wrapper.val.hash() : 0;\n+        return res;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier(RunInfo info) {\n+        Asserts.assertEquals(test3(false, false, false, info.getTest()), 2*testValue1.hash());\n+        Asserts.assertEquals(test3(false, true, false, info.getTest()), 42L);\n+        if (!info.isWarmUp()) {\n+            switch (rI % 4) {\n+            case 0:\n+                Asserts.assertEquals(test3(true, false, false, info.getTest()), 2*testValue1.hash());\n+                break;\n+            case 1:\n+                Asserts.assertEquals(test3(true, true, false, info.getTest()), 42L);\n+                break;\n+            case 2:\n+                Asserts.assertEquals(test3(true, false, true, info.getTest()), 42L);\n+                break;\n+            case 3:\n+                try {\n+                    Asserts.assertEquals(test3(true, true, true, info.getTest()), 42L);\n+                    throw new RuntimeException(\"NullPointerException expected\");\n+                } catch (NullPointerException e) {\n+                    \/\/ Expected\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    \/\/ Test scalarization in safepoint debug info and re-allocation on deopt\n+    @Test\n+    @IR(failOn = {ALLOC, STORE})\n+    public boolean test4(boolean deopt, boolean b, Method m) {\n+        MyValueClass1 val = b ? null : MyValueClass1.createWithFieldsInline(rI, rL);\n+        Test3Wrapper wrapper = new Test3Wrapper(val);\n+        if (deopt) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return (Object)wrapper.val == null;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier(RunInfo info) {\n+        Asserts.assertTrue(test4(false, true, info.getTest()));\n+        Asserts.assertFalse(test4(false, false, info.getTest()));\n+        if (!info.isWarmUp()) {\n+            switch (rI % 2) {\n+                case 0:\n+                    Asserts.assertTrue(test4(true, true, info.getTest()));\n+                    break;\n+                case 1:\n+                    Asserts.assertFalse(test4(false, false, info.getTest()));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    static value class SmallNullable2 {\n+        float f1;\n+        double f2;\n+\n+        @ForceInline\n+        public SmallNullable2() {\n+            f1 = (float)rL;\n+            f2 = (double)rL;\n+        }\n+    }\n+\n+    static value class SmallNullable1 {\n+        char c;\n+        byte b;\n+        short s;\n+        int i;\n+        SmallNullable2 vt;\n+\n+        @ForceInline\n+        public SmallNullable1(boolean useNull) {\n+            c = (char)rL;\n+            b = (byte)rL;\n+            s = (short)rL;\n+            i = (int)rL;\n+            vt = useNull ? null : new SmallNullable2();\n+        }\n+    }\n+\n+    @DontCompile\n+    public SmallNullable1 test5_interpreted(boolean b1, boolean b2) {\n+        return b1 ? null : new SmallNullable1(b2);\n+    }\n+\n+    @DontInline\n+    public SmallNullable1 test5_compiled(boolean b1, boolean b2) {\n+        return b1 ? null : new SmallNullable1(b2);\n+    }\n+\n+    SmallNullable1 test5_field1;\n+    SmallNullable1 test5_field2;\n+\n+    \/\/ Test scalarization in returns\n+    @Test\n+    public SmallNullable1 test5(boolean b1, boolean b2) {\n+        SmallNullable1 ret = test5_interpreted(b1, b2);\n+        if (b1 != ((Object)ret == null)) {\n+            throw new RuntimeException(\"test5 failed\");\n+        }\n+        test5_field1 = ret;\n+        ret = test5_compiled(b1, b2);\n+        if (b1 != ((Object)ret == null)) {\n+            throw new RuntimeException(\"test5 failed\");\n+        }\n+        test5_field2 = ret;\n+        return ret;\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() {\n+        SmallNullable1 vt = new SmallNullable1(false);\n+        Asserts.assertEquals(test5(true, false), null);\n+        Asserts.assertEquals(test5_field1, null);\n+        Asserts.assertEquals(test5_field2, null);\n+        Asserts.assertEquals(test5(false, false), vt);\n+        Asserts.assertEquals(test5_field1, vt);\n+        Asserts.assertEquals(test5_field2, vt);\n+        vt = new SmallNullable1(true);\n+        Asserts.assertEquals(test5(true, true), null);\n+        Asserts.assertEquals(test5_field1, null);\n+        Asserts.assertEquals(test5_field2, null);\n+        Asserts.assertEquals(test5(false, true), vt);\n+        Asserts.assertEquals(test5_field1, vt);\n+        Asserts.assertEquals(test5_field2, vt);\n+    }\n+\n+    static value class Empty2 {\n+\n+    }\n+\n+    static value class Empty1 {\n+        Empty2 empty2 = Empty2.default;\n+    }\n+\n+    static value class Container {\n+        int x = 0;\n+        Empty1 empty1;\n+        Empty2 empty2 = Empty2.default;\n+\n+        @ForceInline\n+        public Container(Empty1 val) {\n+            empty1 = val;\n+        }\n+    }\n+\n+    @DontInline\n+    public static Empty1 test6_helper1(Empty1 vt) {\n+        return vt;\n+    }\n+\n+    @DontInline\n+    public static Empty2 test6_helper2(Empty2 vt) {\n+        return vt;\n+    }\n+\n+    @DontInline\n+    public static Container test6_helper3(Container vt) {\n+        return vt;\n+    }\n+\n+    \/\/ Test scalarization in calls and returns with empty nullable inline types\n+    @Test\n+    public Empty1 test6(Empty1 vt) {\n+        Empty1 empty1 = test6_helper1(vt);\n+        test6_helper2((empty1 != null) ? empty1.empty2 : null);\n+        Container c = test6_helper3(new Container(empty1));\n+        return c.empty1;\n+    }\n+\n+    @Run(test = \"test6\")\n+    @Warmup(10000) \/\/ Warmup to make sure helper methods are compiled as well\n+    public void test6_verifier() {\n+        Asserts.assertEQ(test6(Empty1.default), Empty1.default);\n+        Asserts.assertEQ(test6(null), null);\n+    }\n+\n+    @DontCompile\n+    public void test7_helper2(boolean doit) {\n+        if (doit) {\n+            \/\/ uncommon trap\n+            try {\n+                TestFramework.deoptimize(getClass().getDeclaredMethod(\"test7\", boolean.class, boolean.class, boolean.class));\n+            } catch (NoSuchMethodException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    \/\/ Test deoptimization at call return with inline type returned in registers\n+    @DontInline\n+    public SmallNullable1 test7_helper1(boolean deopt, boolean b1, boolean b2) {\n+        test7_helper2(deopt);\n+        return b1 ? null : new SmallNullable1(b2);\n+    }\n+\n+    @Test\n+    public SmallNullable1 test7(boolean flag, boolean b1, boolean b2) {\n+        return test7_helper1(flag, b1, b2);\n+    }\n+\n+    @Run(test = \"test7\")\n+    @Warmup(10000)\n+    public void test7_verifier(RunInfo info) {\n+        boolean b1 = ((rI % 3) == 0);\n+        boolean b2 = ((rI % 3) == 1);\n+        SmallNullable1 result = test7(!info.isWarmUp(), b1, b2);\n+        SmallNullable1 vt = new SmallNullable1(b2);\n+        Asserts.assertEQ(result, b1 ? null : vt);\n+    }\n+\n+    \/\/ Test calling a method returning a nullable inline type as fields via reflection\n+    @Test\n+    public SmallNullable1 test8(boolean b1, boolean b2) {\n+        return b1 ? null : new SmallNullable1(b2);\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() throws Exception {\n+        Method m = getClass().getDeclaredMethod(\"test8\", boolean.class, boolean.class);\n+        Asserts.assertEQ(m.invoke(this, false, true), new SmallNullable1(true));\n+        Asserts.assertEQ(m.invoke(this, false, false), new SmallNullable1(false));\n+        Asserts.assertEQ(m.invoke(this, true, false), null);\n+    }\n+\n+    \/\/ Test value classes as arg\/return\n+    @Test\n+    public SmallNullable1 test9(MyValueClass1 vt1, MyValueClass1 vt2, boolean b1, boolean b2) {\n+        Asserts.assertEQ(vt1, testValue1);\n+        if (b1) {\n+            Asserts.assertEQ(vt2, null);\n+        } else {\n+            Asserts.assertEQ(vt2, testValue1);\n+        }\n+        return b1 ? null : new SmallNullable1(b2);\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        Asserts.assertEQ(test9(testValue1, testValue1, false, true), new SmallNullable1(true));\n+        Asserts.assertEQ(test9(testValue1, testValue1, false, false), new SmallNullable1(false));\n+        Asserts.assertEQ(test9(testValue1, null, true, false), null);\n+    }\n+\n+    \/\/ Class.cast\n+    @Test\n+    public Object test10(Class c, MyValueClass1 vt) {\n+        return c.cast(vt);\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        Asserts.assertEQ(test10(MyValueClass1.class, testValue1), testValue1);\n+        Asserts.assertEQ(test10(MyValueClass1.class.asPrimaryType(), null), null);\n+        Asserts.assertEQ(test10(MyValueClass2.class.asPrimaryType(), null), null);\n+        Asserts.assertEQ(test10(Integer.class, null), null);\n+        try {\n+            test10(MyValueClass2.class.asPrimaryType(), testValue1);\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test acmp\n+    @Test\n+    public boolean test12(MyValueClass1 vt1, MyValueClass1 vt2) {\n+        return vt1 == vt2;\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        Asserts.assertTrue(test12(testValue1, testValue1));\n+        Asserts.assertTrue(test12(null, null));\n+        Asserts.assertFalse(test12(testValue1, null));\n+        Asserts.assertFalse(test12(null, testValue1));\n+        Asserts.assertFalse(test12(testValue1, MyValueClass1.default));\n+    }\n+\n+    \/\/ Same as test13 but with Object argument\n+    @Test\n+    public boolean test13(Object obj, MyValueClass1 vt2) {\n+        return obj == vt2;\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier() {\n+        Asserts.assertTrue(test13(testValue1, testValue1));\n+        Asserts.assertTrue(test13(null, null));\n+        Asserts.assertFalse(test13(testValue1, null));\n+        Asserts.assertFalse(test13(null, testValue1));\n+        Asserts.assertFalse(test13(testValue1, MyValueClass1.default));\n+    }\n+\n+    static MyValueClass1 test14_field1;\n+    static MyValueClass1 test14_field2;\n+\n+    \/\/ Test buffer checks emitted by acmp followed by buffering\n+    @Test\n+    public boolean test14(MyValueClass1 vt1, MyValueClass1 vt2) {\n+        \/\/ Trigger buffer checks\n+        if (vt1 != vt2) {\n+            throw new RuntimeException(\"Should be equal\");\n+        }\n+        if (vt2 != vt1) {\n+            throw new RuntimeException(\"Should be equal\");\n+        }\n+        \/\/ Trigger buffering\n+        test14_field1 = vt1;\n+        test14_field2 = vt2;\n+        return vt1 == null;\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        Asserts.assertFalse(test14(testValue1, testValue1));\n+        Asserts.assertTrue(test14(null, null));\n+    }\n+\n+    @DontInline\n+    public MyValueClass1 test15_helper1(MyValueClass1 vt) {\n+        return vt;\n+    }\n+\n+    @ForceInline\n+    public MyValueClass1 test15_helper2(MyValueClass1 vt) {\n+        return test15_helper1(vt);\n+    }\n+\n+    @ForceInline\n+    public MyValueClass1 test15_helper3(Object vt) {\n+        return test15_helper2((MyValueClass1)vt);\n+    }\n+\n+    \/\/ Test that calling convention optimization prevents buffering of arguments\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC_G, \" = 7\"}) \/\/ 6 MyValueClass2\/MyValueClass2Inline allocations + 1 Integer allocation\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC_G, \" = 8\"}) \/\/ 1 MyValueClass1 allocation + 6 MyValueClass2\/MyValueClass2Inline allocations + 1 Integer allocation\n+    public MyValueClass1 test15(MyValueClass1 vt) {\n+        MyValueClass1 res = test15_helper1(vt);\n+        vt = MyValueClass1.createWithFieldsInline(rI, rL);\n+        test15_helper1(vt);\n+        test15_helper2(vt);\n+        test15_helper3(vt);\n+        return res;\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier() {\n+        Asserts.assertEQ(test15(testValue1), testValue1);\n+        Asserts.assertEQ(test15(null), null);\n+    }\n+\n+    @DontInline\n+    public MyValueClass2 test16_helper1(boolean b) {\n+        return b ? null : MyValueClass2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    @ForceInline\n+    public MyValueClass2 test16_helper2() {\n+        return null;\n+    }\n+\n+    @ForceInline\n+    public MyValueClass2 test16_helper3(boolean b) {\n+        return b ? null : MyValueClass2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    \/\/ Test that calling convention optimization prevents buffering of return values\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        counts = {ALLOC_G, \" = 1\"}) \/\/ 1 MyValueClass2Inline allocation\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"false\"},\n+        counts = {ALLOC_G, \" = 2\"}) \/\/ 1 MyValueClass2 + 1 MyValueClass2Inline allocation\n+    public MyValueClass2 test16(int c, boolean b) {\n+        MyValueClass2 res = null;\n+        if (c == 1) {\n+            res = test16_helper1(b);\n+        } else if (c == 2) {\n+            res = test16_helper2();\n+        } else if (c == 3) {\n+            res = test16_helper3(b);\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test16\")\n+    public void test16_verifier() {\n+        Asserts.assertEQ(test16(0, false), null);\n+        Asserts.assertEQ(test16(1, false).hash(), MyValueClass2.createWithFieldsInline(rI, rD).hash());\n+        Asserts.assertEQ(test16(1, true), null);\n+        Asserts.assertEQ(test16(2, false), null);\n+        Asserts.assertEQ(test16(3, false).hash(), MyValueClass2.createWithFieldsInline(rI, rD).hash());\n+        Asserts.assertEQ(test16(3, true), null);\n+    }\n+\n+    static primitive class MyPrimitive17 {\n+        MyValueClass1 nonFlattened;\n+\n+        public MyPrimitive17(MyValueClass1 val) {\n+            this.nonFlattened = val;\n+        }\n+    }\n+\n+    static value class MyValue17 {\n+        MyPrimitive17 flattened;\n+\n+        public MyValue17(boolean b) {\n+            this.flattened = new MyPrimitive17(b ? null : testValue1);\n+        }\n+    }\n+\n+    @DontCompile\n+    public MyValue17 test17_interpreted(boolean b1, boolean b2) {\n+        return b1 ? null : new MyValue17(b2);\n+    }\n+\n+    @DontInline\n+    public MyValue17 test17_compiled(boolean b1, boolean b2) {\n+        return b1 ? null : new MyValue17(b2);\n+    }\n+\n+    MyValue17 test17_field1;\n+    MyValue17 test17_field2;\n+\n+    \/\/ Test handling of null when mixing value and primitive classes\n+    @Test\n+    public MyValue17 test17(boolean b1, boolean b2) {\n+        MyValue17 ret = test17_interpreted(b1, b2);\n+        if (b1 != ((Object)ret == null)) {\n+            throw new RuntimeException(\"test17 failed\");\n+        }\n+        test17_field1 = ret;\n+        ret = test17_compiled(b1, b2);\n+        if (b1 != ((Object)ret == null)) {\n+            throw new RuntimeException(\"test17 failed\");\n+        }\n+        test17_field2 = ret;\n+        return ret;\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        MyValue17 vt = new MyValue17(false);\n+        Asserts.assertEquals(test17(true, false), null);\n+        Asserts.assertEquals(test17_field1, null);\n+        Asserts.assertEquals(test17_field2, null);\n+        Asserts.assertEquals(test17(false, false), vt);\n+        Asserts.assertEquals(test17_field1, vt);\n+        Asserts.assertEquals(test17_field2, vt);\n+        vt = new MyValue17(true);\n+        Asserts.assertEquals(test17(true, true), null);\n+        Asserts.assertEquals(test17_field1, null);\n+        Asserts.assertEquals(test17_field2, null);\n+        Asserts.assertEquals(test17(false, true), vt);\n+        Asserts.assertEquals(test17_field1, vt);\n+        Asserts.assertEquals(test17_field2, vt);\n+    }\n+\n+    \/\/ Uses all registers available for returning values on x86_64\n+    static value class UseAllRegs {\n+        long l1;\n+        long l2;\n+        long l3;\n+        long l4;\n+        long l5;\n+        long l6;\n+        double d1;\n+        double d2;\n+        double d3;\n+        double d4;\n+        double d5;\n+        double d6;\n+        double d7;\n+        double d8;\n+\n+        @ForceInline\n+        public UseAllRegs(long l1, long l2, long l3, long l4, long l5, long l6,\n+                          double d1, double d2, double d3, double d4, double d5, double d6, double d7, double d8) {\n+            this.l1 = l1;\n+            this.l2 = l2;\n+            this.l3 = l3;\n+            this.l4 = l4;\n+            this.l5 = l5;\n+            this.l6 = l6;\n+            this.d1 = d1;\n+            this.d2 = d2;\n+            this.d3 = d3;\n+            this.d4 = d4;\n+            this.d5 = d5;\n+            this.d6 = d6;\n+            this.d7 = d7;\n+            this.d8 = d8;\n+        }\n+    }\n+\n+    @DontInline\n+    public UseAllRegs test18_helper1(UseAllRegs val, long a, long b, long c, long d, long e, long f, long g, long h, long i, long j) {\n+        Asserts.assertEquals(a & b & c & d & e & f & g & h & i & j, 0L);\n+        return val;\n+    }\n+\n+    @DontCompile\n+    public UseAllRegs test18_helper2(UseAllRegs val, long a, long b, long c, long d, long e, long f, long g, long h, long i, long j) {\n+        Asserts.assertEquals(a & b & c & d & e & f & g & h & i & j, 0L);\n+        return val;\n+    }\n+\n+    static boolean test18_b;\n+\n+    \/\/ Methods with no arguments (no stack slots reserved for incoming args)\n+    @DontInline\n+    public static UseAllRegs test18_helper3() {\n+        return test18_b ? null : new UseAllRegs(rL + 1, rL + 2, rL + 3, rL + 4, rL + 5, rL + 6, rL + 7, rL + 8, rL + 9, rL + 10, rL + 11, rL + 12, rL + 13, rL + 14);\n+    }\n+\n+    @DontCompile\n+    public static UseAllRegs test18_helper4() {\n+        return test18_b ? null : test18_helper3();\n+    }\n+\n+    \/\/ Test proper register allocation of isInit projection of a call in C2\n+    @Test\n+    public UseAllRegs test18(boolean b, long val1, long l1, long val2, long l2, long val3, long l3, long val4, long l4, long val5, long l5, long val6, long l6,\n+                             long val7, double d1, long val8, double d2, long val9, double d3, long val10, double d4, long val11, double d5, long val12, double d6, long val13, double d7, long val14, double d8, long val15) {\n+        Asserts.assertEquals(val1, rL);\n+        Asserts.assertEquals(val2, rL);\n+        Asserts.assertEquals(val3, rL);\n+        Asserts.assertEquals(val4, rL);\n+        Asserts.assertEquals(val5, rL);\n+        Asserts.assertEquals(val6, rL);\n+        Asserts.assertEquals(val7, rL);\n+        Asserts.assertEquals(val8, rL);\n+        Asserts.assertEquals(val9, rL);\n+        Asserts.assertEquals(val10, rL);\n+        Asserts.assertEquals(val11, rL);\n+        Asserts.assertEquals(val12, rL);\n+        Asserts.assertEquals(val13, rL);\n+        Asserts.assertEquals(val14, rL);\n+        Asserts.assertEquals(val15, rL);\n+        UseAllRegs val = b ? null : new UseAllRegs(l1, l2, l3, l4, l5, l6, d1, d2, d3, d4, d5, d6, d7, d8);\n+        val = test18_helper1(val, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+        val = test18_helper2(val, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+        Asserts.assertEquals(val1, rL);\n+        Asserts.assertEquals(val2, rL);\n+        Asserts.assertEquals(val3, rL);\n+        Asserts.assertEquals(val4, rL);\n+        Asserts.assertEquals(val5, rL);\n+        Asserts.assertEquals(val6, rL);\n+        Asserts.assertEquals(val7, rL);\n+        Asserts.assertEquals(val8, rL);\n+        Asserts.assertEquals(val9, rL);\n+        Asserts.assertEquals(val10, rL);\n+        Asserts.assertEquals(val11, rL);\n+        Asserts.assertEquals(val12, rL);\n+        Asserts.assertEquals(val13, rL);\n+        Asserts.assertEquals(val14, rL);\n+        Asserts.assertEquals(val15, rL);\n+        Asserts.assertEquals(test18_helper3(), val);\n+        Asserts.assertEquals(test18_helper4(), val);\n+        return val;\n+    }\n+\n+    @Run(test = \"test18\")\n+    public void test18_verifier() {\n+        UseAllRegs val = new UseAllRegs(rL + 1, rL + 2, rL + 3, rL + 4, rL + 5, rL + 6, rL + 7, rL + 8, rL + 9, rL + 10, rL + 11, rL + 12, rL + 13, rL + 14);\n+        test18_b = false;\n+        Asserts.assertEquals(test18(false, rL, rL + 1, rL, rL + 2, rL, rL + 3, rL, rL + 4, rL, rL + 5, rL, rL + 6,\n+                                    rL, rL + 7, rL, rL + 8, rL, rL + 9, rL, rL + 10, rL, rL + 11, rL, rL + 12, rL, rL + 13, rL, rL + 14, rL), val);\n+        test18_b = true;\n+        Asserts.assertEquals(test18(true, rL, rL + 1, rL, rL + 2, rL, rL + 3, rL, rL + 4, rL, rL + 5, rL, rL + 6,\n+                                    rL, rL + 7, rL, rL + 8, rL, rL + 9, rL, rL + 10, rL, rL + 11, rL, rL + 12, rL, rL + 13, rL, rL + 14, rL), null);\n+    }\n+\n+    @DontInline\n+    static public UseAllRegs test19_helper() {\n+        return new UseAllRegs(rL + 1, rL + 2, rL + 3, rL + 4, rL + 5, rL + 6, rL + 7, rL + 8, rL + 9, rL + 10, rL + 11, rL + 12, rL + 13, rL + 14);\n+    }\n+\n+    \/\/ Test proper register allocation of isInit projection of a call in C2\n+    @Test\n+    static public void test19(long a, long b, long c, long d, long e, long f) {\n+        if (test19_helper() == null) {\n+            throw new RuntimeException(\"test19 failed: Unexpected null\");\n+        }\n+        if ((a & b & c & d & e & f) != 0) {\n+            throw new RuntimeException(\"test19 failed: Unexpected argument values\");\n+        }\n+    }\n+\n+    @Run(test = \"test19\")\n+    public void test19_verifier() {\n+        test19(0, 0, 0, 0, 0, 0);\n+    }\n+\n+    \/\/ Uses almost all registers available for returning values on x86_64\n+    static value class UseAlmostAllRegs {\n+        long l1;\n+        long l2;\n+        long l3;\n+        long l4;\n+        long l5;\n+        double d1;\n+        double d2;\n+        double d3;\n+        double d4;\n+        double d5;\n+        double d6;\n+        double d7;\n+\n+        @ForceInline\n+        public UseAlmostAllRegs(long l1, long l2, long l3, long l4, long l5,\n+                                double d1, double d2, double d3, double d4, double d5, double d6, double d7) {\n+            this.l1 = l1;\n+            this.l2 = l2;\n+            this.l3 = l3;\n+            this.l4 = l4;\n+            this.l5 = l5;\n+            this.d1 = d1;\n+            this.d2 = d2;\n+            this.d3 = d3;\n+            this.d4 = d4;\n+            this.d5 = d5;\n+            this.d6 = d6;\n+            this.d7 = d7;\n+        }\n+    }\n+\n+    @DontInline\n+    public UseAlmostAllRegs test20_helper1(UseAlmostAllRegs val, long a, long b, long c, long d, long e, long f, long g, long h, long i, long j) {\n+        Asserts.assertEquals(a & b & c & d & e & f & g & h & i & j, 0L);\n+        return val;\n+    }\n+\n+    @DontCompile\n+    public UseAlmostAllRegs test20_helper2(UseAlmostAllRegs val, long a, long b, long c, long d, long e, long f, long g, long h, long i, long j) {\n+        Asserts.assertEquals(a & b & c & d & e & f & g & h & i & j, 0L);\n+        return val;\n+    }\n+\n+    static boolean test20_b;\n+\n+    \/\/ Methods with no arguments (no stack slots reserved for incoming args)\n+    @DontInline\n+    public static UseAlmostAllRegs test20_helper3() {\n+        return test20_b ? null : new UseAlmostAllRegs(rL + 1, rL + 2, rL + 3, rL + 4, rL + 5, rL + 6, rL + 7, rL + 8, rL + 9, rL + 10, rL + 11, rL + 12);\n+    }\n+\n+    @DontCompile\n+    public static UseAlmostAllRegs test20_helper4() {\n+        return test20_b ? null : test20_helper3();\n+    }\n+\n+    \/\/ Test proper register allocation of isInit projection of a call in C2\n+    @Test\n+    public UseAlmostAllRegs test20(boolean b, long val1, long l1, long val2, long l2, long val3, long l3, long val4, long l4, long val5, long l5, long val6,\n+                                   long val7, double d1, long val8, double d2, long val9, double d3, long val10, double d4, long val11, double d5, long val12, double d6, long val13, double d7, long val14, long val15) {\n+        Asserts.assertEquals(val1, rL);\n+        Asserts.assertEquals(val2, rL);\n+        Asserts.assertEquals(val3, rL);\n+        Asserts.assertEquals(val4, rL);\n+        Asserts.assertEquals(val5, rL);\n+        Asserts.assertEquals(val6, rL);\n+        Asserts.assertEquals(val7, rL);\n+        Asserts.assertEquals(val8, rL);\n+        Asserts.assertEquals(val9, rL);\n+        Asserts.assertEquals(val10, rL);\n+        Asserts.assertEquals(val11, rL);\n+        Asserts.assertEquals(val12, rL);\n+        Asserts.assertEquals(val13, rL);\n+        Asserts.assertEquals(val14, rL);\n+        Asserts.assertEquals(val15, rL);\n+        UseAlmostAllRegs val = b ? null : new UseAlmostAllRegs(l1, l2, l3, l4, l5, d1, d2, d3, d4, d5, d6, d7);\n+        val = test20_helper1(val, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+        val = test20_helper2(val, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+        Asserts.assertEquals(val1, rL);\n+        Asserts.assertEquals(val2, rL);\n+        Asserts.assertEquals(val3, rL);\n+        Asserts.assertEquals(val4, rL);\n+        Asserts.assertEquals(val5, rL);\n+        Asserts.assertEquals(val6, rL);\n+        Asserts.assertEquals(val7, rL);\n+        Asserts.assertEquals(val8, rL);\n+        Asserts.assertEquals(val9, rL);\n+        Asserts.assertEquals(val10, rL);\n+        Asserts.assertEquals(val11, rL);\n+        Asserts.assertEquals(val12, rL);\n+        Asserts.assertEquals(val13, rL);\n+        Asserts.assertEquals(val14, rL);\n+        Asserts.assertEquals(val15, rL);\n+        Asserts.assertEquals(test20_helper3(), val);\n+        Asserts.assertEquals(test20_helper4(), val);\n+        return val;\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier() {\n+        UseAlmostAllRegs val = new UseAlmostAllRegs(rL + 1, rL + 2, rL + 3, rL + 4, rL + 5, rL + 6, rL + 7, rL + 8, rL + 9, rL + 10, rL + 11, rL + 12);\n+        test20_b = false;\n+        Asserts.assertEquals(test20(false, rL, rL + 1, rL, rL + 2, rL, rL + 3, rL, rL + 4, rL, rL + 5, rL,\n+                                    rL, rL + 6, rL, rL + 7, rL, rL + 8, rL, rL + 9, rL, rL + 10, rL, rL + 11, rL, rL + 12, rL, rL), val);\n+        test20_b = true;\n+        Asserts.assertEquals(test20(true, rL, rL + 1, rL, rL + 2, rL, rL + 3, rL, rL + 4, rL, rL + 5, rL,\n+                                    rL, rL + 6, rL, rL + 7, rL, rL + 8, rL, rL + 9, rL, rL + 10, rL, rL + 11, rL, rL + 12, rL, rL), null);\n+    }\n+\n+    @DontInline\n+    static public UseAlmostAllRegs test21_helper() {\n+        return new UseAlmostAllRegs(rL + 1, rL + 2, rL + 3, rL + 4, rL + 5, rL + 6, rL + 7, rL + 8, rL + 9, rL + 10, rL + 11, rL + 12);\n+    }\n+\n+    \/\/ Test proper register allocation of isInit projection of a call in C2\n+    @Test\n+    static public void test21(long a, long b, long c, long d, long e, long f) {\n+        if (test21_helper() == null) {\n+            throw new RuntimeException(\"test21 failed: Unexpected null\");\n+        }\n+        if ((a & b & c & d & e & f) != 0) {\n+            throw new RuntimeException(\"test21 failed: Unexpected argument values\");\n+        }\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        test21(0, 0, 0, 0, 0, 0);\n+    }\n+\n+    static value class ManyOopsValue {\n+        Integer i1 = 1;\n+        Integer i2 = 2;\n+        Integer i3 = 3;\n+        Integer i4 = 4;\n+        Integer i5 = 5;\n+        Integer i6 = 6;\n+        Integer i7 = 7;\n+        Integer i8 = 8;\n+        Integer i9 = 9;\n+        Integer i10 = 10;\n+        Integer i11 = 11;\n+        Integer i12 = 12;\n+        Integer i13 = 13;\n+        Integer i14 = 14;\n+        Integer i15 = 15;\n+\n+        @DontInline\n+        public int sum() {\n+            return i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11 + i12 + i13 + i14 + i15;\n+        }\n+    }\n+\n+    \/\/ Verify that C2 scratch buffer size is large enough to hold many GC barriers used by the entry points\n+    @Test\n+    static public int test22(ManyOopsValue val) {\n+        return val.sum();\n+    }\n+\n+    @Run(test = \"test22\")\n+    @Warmup(10_000)\n+    public void test22_verifier() {\n+        Asserts.assertEquals(test22(new ManyOopsValue()), 120);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":956,"deletions":0,"binary":false,"changes":956,"status":"added"}]}