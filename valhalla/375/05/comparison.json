{"files":[{"patch":"@@ -1228,1 +1228,1 @@\n-                                  ct.tsym, ct.getMetadata()) {\n+                                  ct.tsym, ct.getMetadata(), ct.isReferenceProjection()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -237,0 +237,4 @@\n+        if (t.isReferenceProjection()) {\n+            buf.append('.');\n+            buf.append(t.tsym.name.table.names.ref);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -429,2 +429,2 @@\n-     * Return the value projection IFF 'this' happens to be derived reference projection, null\n-     * otherwise.\n+     * If this is the symbol for a reference projection class, what is the class for which\n+     * this is a projection ??\n@@ -432,9 +432,1 @@\n-    public Symbol valueProjection() {\n-        return null;\n-    }\n-\n-    \/**\n-     * Return the reference projection IFF 'this' happens to be inline class, null\n-     * otherwise.\n-     *\/\n-    public Symbol referenceProjection() {\n+    public ClassSymbol valueProjection() {\n@@ -1331,6 +1323,0 @@\n-        \/* the 'other' projection: If 'this' is an inline class then 'projection' is its reference projection\n-           and vice versa.\n-         *\/\n-        public ClassSymbol projection;\n-\n-\n@@ -1396,1 +1382,2 @@\n-                                              type.getMetadata());\n+                                              type.getMetadata(),\n+                                              type.isReferenceProjection());\n@@ -1666,59 +1653,0 @@\n-        @Override\n-        public boolean isReferenceProjection() {\n-            return projection != null && projection.isPrimitiveClass();\n-        }\n-\n-        @Override\n-        public ClassSymbol valueProjection() {\n-            return isReferenceProjection() ? projection : null;\n-        }\n-\n-        @Override\n-        public ClassSymbol referenceProjection() {\n-            if (!isPrimitiveClass())\n-                return null;\n-\n-            if (projection != null)\n-                return projection;\n-\n-            ClassType ct = (ClassType) this.type;\n-            ClassType projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);\n-            projectedType.allparams_field = ct.allparams_field;\n-            projectedType.supertype_field = ct.supertype_field;\n-\n-            projectedType.interfaces_field = ct.interfaces_field;\n-            projectedType.all_interfaces_field = ct.all_interfaces_field;\n-            projectedType.projection = ct;\n-            ct.projection = projectedType;\n-\n-            Name projectionName = this.name.append('$', this.name.table.names.ref);\n-            long projectionFlags = (this.flags() & ~(PRIMITIVE_CLASS | UNATTRIBUTED | FINAL)) | SEALED;\n-\n-            projection = new ClassSymbol(projectionFlags, projectionName, projectedType, this.owner);\n-            projection.members_field = WriteableScope.create(projection);\n-            for (Symbol s : this.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n-                Symbol clone = null;\n-                if (s.kind == MTH) {\n-                    MethodSymbol valMethod = (MethodSymbol)s;\n-                    MethodSymbol refMethod = valMethod.clone(projection);\n-                    valMethod.projection = refMethod;\n-                    refMethod.projection = valMethod;\n-                    clone = refMethod;\n-                } else if (s.kind == VAR) {\n-                    VarSymbol valVar = (VarSymbol)s;\n-                    VarSymbol refVar = valVar.clone(projection);\n-                    valVar.projection = refVar;\n-                    refVar.projection = valVar;\n-                    clone = refVar;\n-                }\n-                projection.members_field.enter(clone);\n-            }\n-            projection.completer = Completer.NULL_COMPLETER;\n-            projection.sourcefile = this.sourcefile;\n-            projection.flatname = this.flatname.append('$', this.name.table.names.ref);\n-            projection.permitted = List.of(this);\n-            projection.projection = this;\n-            projectedType.tsym = projection;\n-            return projection;\n-        }\n-\n@@ -1751,5 +1679,0 @@\n-        \/* The 'other' projection: If 'this' is a field of an inline class, then 'projection' is the\n-           its doppleganger in its referene projection class and vice versa.\n-        *\/\n-        public VarSymbol projection;\n-\n@@ -1788,1 +1711,0 @@\n-            v.projection = projection;\n@@ -1841,12 +1763,0 @@\n-        @Override\n-        public VarSymbol referenceProjection() {\n-            return this.owner.isPrimitiveClass() ?\n-                    this.owner.referenceProjection() != null ? projection : null\n-                               : null;\n-        }\n-\n-        @Override\n-        public VarSymbol valueProjection() {\n-            return  projection != null ? projection.owner.isPrimitiveClass() ? projection : null: null;\n-        }\n-\n@@ -2029,5 +1939,0 @@\n-        \/* The 'other' projection: If 'this' is a method of an inline class, then 'projection' is the\n-           its doppleganger in its referene projection class and vice versa.\n-        *\/\n-        public MethodSymbol projection;\n-\n@@ -2056,1 +1961,0 @@\n-            m.projection = projection;\n@@ -2141,1 +2045,1 @@\n-                types.asSuper(owner.type, other.owner) != null &&\n+                types.isSubtype(owner.type, other.owner.type) &&\n@@ -2205,12 +2109,0 @@\n-\n-            \/* If any inline types are involved, ask the same question in the reference universe,\n-               where the hierarchy is navigable\n-            *\/\n-            if (origin.isPrimitiveClass())\n-                origin = (TypeSymbol) origin.referenceProjection();\n-\n-            if (this.owner.isPrimitiveClass()) {\n-                return this.projection != null &&\n-                        this.projection.overrides(_other, origin, types, checkResult, requireConcreteIfInherited);\n-            }\n-\n@@ -2222,1 +2114,1 @@\n-                types.asSuper(owner.type, other.owner) != null) {\n+                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null) {\n@@ -2272,8 +2164,0 @@\n-            \/* If any inline types are involved, ask the same question in the reference universe,\n-               where the hierarchy is navigable\n-            *\/\n-            if (clazz.isPrimitiveClass())\n-                clazz = clazz.referenceProjection();\n-            if (this.owner.isPrimitiveClass())\n-                return this.projection.isInheritedIn(clazz, types);\n-\n@@ -2294,12 +2178,0 @@\n-        @Override\n-        public MethodSymbol referenceProjection() {\n-            return this.owner.isPrimitiveClass() ?\n-                    this.owner.referenceProjection() != null ? projection : null\n-                    : null;\n-        }\n-\n-        @Override\n-        public MethodSymbol valueProjection() {\n-            return  projection != null ? projection.owner.isPrimitiveClass() ? projection : null : null;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":7,"deletions":135,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-     * @return the reference projection type IFF the receiver is an inline type\n+     * @return the reference projection type IFF the receiver is a primitive class type\n@@ -266,0 +266,8 @@\n+    \/**\n+     * @return the reference projection type IFF the receiver is a primitive class type or self otherwise.\n+     *\/\n+    public Type referenceProjectionOrSelf() {\n+        Type projection = referenceProjection();\n+        return projection != null ? projection : this;\n+    }\n+\n@@ -280,1 +288,1 @@\n-            else return new ClassType(outer1, typarams1, t.tsym, t.metadata) {\n+            else return new ClassType(outer1, typarams1, t.tsym, t.metadata, t.isReferenceProjection()) {\n@@ -1039,2 +1047,2 @@\n-        \/* The 'other' projection: If 'this' is type of an inline class, then 'projection' is the\n-           its doppleganger in its referene projection world and vice versa.\n+        \/** The 'other' projection: If 'this' is type of a primitive class, then 'projection' is the\n+         *  reference projection type and vice versa. Lazily initialized, not to be accessed directly.\n@@ -1044,0 +1052,4 @@\n+        \/** Is this class type a reference projection of a primitive class type ?\n+         *\/\n+        private boolean isReferenceProjection;\n+\n@@ -1045,1 +1057,1 @@\n-            this(outer, typarams, tsym, TypeMetadata.EMPTY);\n+            this(outer, typarams, tsym, TypeMetadata.EMPTY, false);\n@@ -1050,0 +1062,5 @@\n+            this(outer, typarams, tsym, metadata, false);\n+        }\n+\n+        public ClassType(Type outer, List<Type> typarams, TypeSymbol tsym,\n+                         TypeMetadata metadata, boolean isReferenceProjection) {\n@@ -1051,1 +1068,1 @@\n-            this.outer_field = outer;\n+            this.outer_field = outer != null && outer.isReferenceProjection() ? outer.valueProjection() : outer;\n@@ -1056,0 +1073,1 @@\n+            this.isReferenceProjection = isReferenceProjection;\n@@ -1064,1 +1082,1 @@\n-            return new ClassType(outer_field, typarams_field, tsym, md) {\n+            return new ClassType(outer_field, typarams_field, tsym, md, isReferenceProjection) {\n@@ -1082,1 +1100,1 @@\n-            return new ClassType(getEnclosingType(), typarams_field, tsym, metadata) {\n+            return new ClassType(getEnclosingType(), typarams_field, tsym, metadata, isReferenceProjection) {\n@@ -1109,0 +1127,5 @@\n+            if (isReferenceProjection) {\n+                buf.append('.');\n+                buf.append(tsym.name.table.names.ref);\n+            }\n+\n@@ -1170,1 +1193,1 @@\n-            outer_field = outer;\n+            outer_field = outer != null && outer.isReferenceProjection() ? outer.valueProjection() : outer;\n@@ -1199,1 +1222,1 @@\n-            return tsym != null && tsym.isPrimitiveClass();\n+            return !isReferenceProjection && tsym != null && tsym.isPrimitiveClass();\n@@ -1204,1 +1227,1 @@\n-            return tsym != null && tsym.isReferenceProjection();\n+            return isReferenceProjection;\n@@ -1215,4 +1238,1 @@\n-            \/\/ Make a best case effort to cache the other projection.\n-            ClassSymbol valueClass = (ClassSymbol) tsym.valueProjection();\n-\n-            projection = new ClassType(outer_field, typarams_field, valueClass);\n+            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), false);\n@@ -1232,2 +1252,2 @@\n-            if (!isPrimitiveClass() || projection != null)\n-                return projection;\n+            if (!isPrimitiveClass())\n+                return null;\n@@ -1235,2 +1255,2 @@\n-            \/\/ make a best case effort to cache the other projection.\n-            ClassSymbol refClass = (ClassSymbol) tsym.referenceProjection();\n+            if (projection != null)\n+                return projection;\n@@ -1238,1 +1258,1 @@\n-            projection = new ClassType(outer_field, typarams_field, refClass);\n+            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), true);\n@@ -1296,1 +1316,1 @@\n-            super(outer, List.nil(), tsym, metadata);\n+            super(outer, List.nil(), tsym, metadata, false);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":41,"deletions":21,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -630,1 +630,1 @@\n-                                                      t.getMetadata());\n+                                                      t.getMetadata(), t.isReferenceProjection());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {\n+                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata(), t.isReferenceProjection()) {\n@@ -1011,1 +1011,1 @@\n-        return t != null && t.tsym != null && (t.tsym.flags_field & Flags.PRIMITIVE_CLASS) != 0;\n+        return t != null && !t.isReferenceProjection() && t.tsym != null && (t.tsym.flags_field & Flags.PRIMITIVE_CLASS) != 0;\n@@ -1211,0 +1211,1 @@\n+                    && (t.tsym != s.tsym || t.isReferenceProjection() == s.isReferenceProjection())\n@@ -1456,1 +1457,2 @@\n-                    && visit(t.getEnclosingType(), s.getEnclosingType())\n+                    && t.isReferenceProjection() == s.isReferenceProjection()\n+                    && visit(getEnclosingType(t), getEnclosingType(s))\n@@ -1459,0 +1461,8 @@\n+                \/\/ where\n+                private Type getEnclosingType(Type t) {\n+                    Type et = t.getEnclosingType();\n+                    if (et.isReferenceProjection()) {\n+                        et = et.valueProjection();\n+                    }\n+                    return et;\n+                }\n@@ -1716,8 +1726,0 @@\n-            \/* The disjointsness checks below are driven by subtyping. At the language level\n-               a reference projection type and its value projection type are not related by\n-               subtyping, thereby necessitating special handling.\n-            *\/\n-            if ((ss.isReferenceProjection() && ss.valueProjection() == ts) ||\n-                (ss.isPrimitiveClass() && ss.referenceProjection() == ts)) {\n-                return false;\n-            }\n@@ -2203,10 +2205,2 @@\n-     * @param t a type\n-     * @param sym a symbol\n-     *\/\n-    public Type asSuper(Type t, Symbol sym) {\n-        return asSuper(t, sym, false);\n-    }\n-\n-    \/**\n-     * Return the (most specific) base type of t that starts with the\n-     * given symbol.  If none exists, return null.\n+     * Further caveats in Valhalla: There are two \"hazards\" we need to watch out for when using\n+     * this method.\n@@ -2214,4 +2208,22 @@\n-     * Caveat Emptor: Since javac represents the class of all arrays with a singleton\n-     * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,\n-     * this method could yield surprising answers when invoked on arrays. For example when\n-     * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.\n+     * 1. Since Foo.ref and Foo.val share the same symbol, that of Foo.class, a call to\n+     *    asSuper(Foo.ref.type, Foo.val.type.tsym) would return non-null. This is NOT correct\n+     *    Foo.val is NOT a super type of Foo.ref either in the language model or in the VM's\n+     *    world view. An example of such an hazardous call used to exist in Gen.visitTypeCast.\n+     *    When we emit code for  (Foo) Foo.ref.instance a check for whether we really need the\n+     *    cast cannot\/shouldn't be gated on asSuper(tree.expr.type, tree.clazz.type.tsym) == null)\n+     *    but use !types.isSubtype(tree.expr.type, tree.clazz.type) which operates in terms of\n+     *    types. When we operate in terms of symbols, there is a loss of type information leading\n+     *    to a hazard. Whether a call to asSuper should be transformed into a isSubtype call is\n+     *    tricky. isSubtype returns just a boolean while asSuper returns richer information which\n+     *    may be required at the call site. Also where the concerned symbol corresponds to a\n+     *    generic class, an asSuper call cannot be conveniently rewritten as an isSubtype call\n+     *    (see that asSuper(ArrayList<String>.type, List<T>.tsym) != null while\n+     *    isSubType(ArrayList<String>.type, List<T>.type) is false;) So care needs to be exercised.\n+     *\n+     * 2. Given a primitive class Foo, a call to asSuper(Foo.type, SuperclassOfFoo.tsym) and\/or\n+     *    a call to asSuper(Foo.type, SuperinterfaceOfFoo.tsym) would answer null. In many places\n+     *    that is NOT what we want. An example of such a hazardous call used to occur in\n+     *    Attr.visitForeachLoop when checking to make sure the for loop's control variable of a type\n+     *    that implements Iterable: viz: types.asSuper(exprType, syms.iterableType.tsym);\n+     *    These hazardous calls should be rewritten as\n+     *    types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym); instead.\n@@ -2221,1 +2233,0 @@\n-     * @param checkReferenceProjection if true, first compute reference projection of t\n@@ -2223,1 +2234,1 @@\n-    public Type asSuper(Type t, Symbol sym, boolean checkReferenceProjection) {\n+    public Type asSuper(Type t, Symbol sym) {\n@@ -2233,7 +2244,0 @@\n-        \/* For a (value or identity) class V, whether it implements an interface I, boils down to whether\n-           V.ref is a subtype of I. OIOW, whether asSuper(V.ref, sym) != null. (Likewise for an abstract\n-           superclass)\n-        *\/\n-        if (checkReferenceProjection)\n-            t = t.isPrimitiveClass() ? t.referenceProjection() : t;\n-\n@@ -2402,3 +2406,0 @@\n-        if (sym.owner.isPrimitiveClass())\n-            sym = sym.referenceProjection();\n-\n@@ -2558,7 +2559,19 @@\n-                Type erased = t.tsym.erasure(Types.this);\n-                if (recurse) {\n-                    erased = new ErasedClassType(erased.getEnclosingType(),erased.tsym,\n-                            t.getMetadata().without(Kind.ANNOTATIONS));\n-                    return erased;\n-                } else {\n-                    return combineMetadata(erased, t);\n+                \/\/ erasure(projection(primitive)) = projection(erasure(primitive))\n+                Type erased = eraseClassType(t, recurse);\n+                if (t.isReferenceProjection()) {\n+                    erased = new ClassType(erased.getEnclosingType(),\n+                            List.nil(), erased.tsym,\n+                            erased.getMetadata(), true);\n+                }\n+                return erased;\n+            }\n+                \/\/ where\n+                private Type eraseClassType(ClassType t, Boolean recurse) {\n+                    Type erased = t.tsym.erasure(Types.this);\n+                    if (recurse) {\n+                        erased = new ErasedClassType(erased.getEnclosingType(), erased.tsym,\n+                                t.getMetadata().without(Kind.ANNOTATIONS));\n+                        return erased;\n+                    } else {\n+                        return combineMetadata(erased, t);\n+                    }\n@@ -2566,1 +2579,0 @@\n-            }\n@@ -2889,1 +2901,1 @@\n-                                         t.getMetadata());\n+                                         t.getMetadata(), t.isReferenceProjection());\n@@ -4582,1 +4594,1 @@\n-                                 cls.getMetadata());\n+                                 cls.getMetadata(), cls.isReferenceProjection());\n@@ -5346,0 +5358,4 @@\n+            if (ct.isReferenceProjection()) {\n+                append('$');\n+                append(types.names.ref);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":63,"deletions":47,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -1597,1 +1597,1 @@\n-                Type base = types.asSuper(exprType, syms.iterableType.tsym, true);\n+                Type base = types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym);\n@@ -1919,1 +1919,1 @@\n-            types.asSuper(resource, syms.autoCloseableType.tsym, true) != null &&\n+            types.isSubtype(resource.referenceProjectionOrSelf(), syms.autoCloseableType) &&\n@@ -2612,1 +2612,2 @@\n-                        restype.getMetadata());\n+                        restype.getMetadata(),\n+                        restype.isReferenceProjection());\n@@ -2813,1 +2814,2 @@\n-                                               clazztype.getMetadata());\n+                                               clazztype.getMetadata(),\n+                                               clazztype.isReferenceProjection());\n@@ -4384,1 +4386,1 @@\n-                Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);\n+                Type site1 = types.asSuper(env.enclClass.sym.type.referenceProjectionOrSelf(), site.tsym);\n@@ -4427,3 +4429,1 @@\n-               } else if (name == names.ref && site.isPrimitiveClass() && resultInfo.pkind.contains(KindSelector.TYP)) {\n-                    return site.tsym.referenceProjection();\n-                } else if (name == names.val && site.isPrimitiveClass() && resultInfo.pkind.contains(KindSelector.TYP)) {\n+                } else if (site.isPrimitiveClass() && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n@@ -4534,1 +4534,1 @@\n-                \/\/ except for two situations:\n+                \/\/ except for three situations:\n@@ -4540,1 +4540,8 @@\n-                    \/\/ (a) If the symbol's type is parameterized, erase it\n+                    \/\/ (a) If symbol is a primitive class and its reference projection\n+                    \/\/ is requested via the .ref notation, then adjust the computed type to\n+                    \/\/ reflect this.\n+                    if (owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n+                        owntype = new ClassType(owntype.getEnclosingType(), owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), true);\n+                    }\n+\n+                    \/\/ (b) If the symbol's type is parameterized, erase it\n@@ -4547,1 +4554,1 @@\n-                    \/\/ (b) If the symbol's type is an inner class, then\n+                    \/\/ (c) If the symbol's type is an inner class, then\n@@ -4567,1 +4574,1 @@\n-                                owntype.getMetadata());\n+                                owntype.getMetadata(), owntype.isReferenceProjection());\n@@ -4978,1 +4985,1 @@\n-                                        clazztype.getMetadata());\n+                                        clazztype.getMetadata(), clazztype.isReferenceProjection());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2698,2 +2698,2 @@\n-        boolean implementsIdentityObject = types.asSuper(c, syms.identityObjectType.tsym, true) != null;\n-        boolean implementsPrimitiveObject = types.asSuper(c, syms.primitiveObjectType.tsym, true) != null;\n+        boolean implementsIdentityObject = types.isSubtype(c.referenceProjectionOrSelf(), syms.identityObjectType);\n+        boolean implementsPrimitiveObject = types.isSubtype(c.referenceProjectionOrSelf(), syms.primitiveObjectType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -474,4 +474,0 @@\n-        if (c.projection != null) {\n-            \/\/ Do not carry around symbols from prior round.\n-            c.projection.members_field = WriteableScope.create(c.projection);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1240,1 +1240,1 @@\n-                    if (types.asSuper(sup, syms.autoCloseableType.tsym, true) != null) {\n+                    if (types.isSubtype(sup.referenceProjectionOrSelf(), syms.autoCloseableType)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-                make.QualIdent(lambdaType.getReturnType().tsym),\n+                make.QualIdent(lambdaType.getReturnType().tsym).setType(lambdaType.getReturnType()),\n@@ -1862,1 +1862,1 @@\n-                return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n+                return types.isSubtype(tree.target, syms.serializableType);\n@@ -2291,1 +2291,1 @@\n-                return tree.sym.kind == MTH && tree.sym.owner.isReferenceProjection();\n+                return tree.getQualifierExpression().type.isReferenceProjection();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1137,0 +1137,3 @@\n+                \/\/ Make sure not to lose type fidelity due to symbol sharing between projections\n+                boolean requireReferenceProjection =\n+                        tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref && tree.type.isReferenceProjection();\n@@ -1140,0 +1143,3 @@\n+                if (requireReferenceProjection) {\n+                    flatname = flatname.append('$', names.ref);\n+                }\n@@ -1152,0 +1158,3 @@\n+                    if (requireReferenceProjection) {\n+                        tree.setType(tree.type.referenceProjection());\n+                    }\n@@ -1155,0 +1164,3 @@\n+                    if (requireReferenceProjection) {\n+                        tree.setType(tree.type.referenceProjection());\n+                    }\n@@ -1713,1 +1725,1 @@\n-        if (types.asSuper(resource.type, syms.autoCloseableType.tsym, true) == null) {\n+        if (!types.isSubtype(resource.type.referenceProjectionOrSelf(), syms.autoCloseableType)) {\n@@ -3507,2 +3519,2 @@\n-            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type),\n-                                              syms.iterableType.tsym, true);\n+            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type.referenceProjectionOrSelf()),\n+                                              syms.iterableType.tsym);\n@@ -3520,1 +3532,1 @@\n-                                            types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)),\n+                                            types.erasure(types.asSuper(iterator.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym)),\n@@ -3982,1 +3994,1 @@\n-            Assert.checkNonNull(types.asSuper(currentClass.type, supSym));\n+            Assert.checkNonNull(types.asSuper(currentClass.type.referenceProjectionOrSelf(), supSym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -221,1 +221,0 @@\n-            ClassSymbol refProjection = m.owner.isPrimitiveClass() ? (ClassSymbol) m.owner.referenceProjection() : null;\n@@ -223,6 +222,0 @@\n-            if (refProjection != null) {\n-                MethodSymbol clone = m.clone(refProjection);\n-                clone.projection = m;\n-                m.projection = clone;\n-                refProjection.members_field.enter(clone);\n-            }\n@@ -312,1 +305,0 @@\n-            ClassSymbol refProjection =  v.owner.isPrimitiveClass() ? (ClassSymbol) v.owner.referenceProjection() : null;\n@@ -314,6 +306,0 @@\n-            if (refProjection != null) {\n-                VarSymbol clone = v.clone(refProjection);\n-                clone.projection = v;\n-                v.projection = clone;\n-                refProjection.members_field.enter(clone);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -423,4 +423,0 @@\n-            if (sym.owner.isPrimitiveClass())\n-                sym = sym.referenceProjection();\n-            if (env.enclClass.sym.isPrimitiveClass())\n-                env.enclClass.sym = env.enclClass.sym.referenceProjection();\n@@ -492,2 +488,0 @@\n-        if (sym.owner.isPrimitiveClass())\n-            sym = sym.referenceProjection();\n@@ -1718,1 +1712,1 @@\n-                    if (types.asSuper(m1Owner.type, m2Owner) != null &&\n+                    if (types.asSuper(m1Owner.type.referenceProjectionOrSelf(), m2Owner) != null &&\n@@ -1723,1 +1717,1 @@\n-                    if (types.asSuper(m2Owner.type, m1Owner) != null &&\n+                    if (types.asSuper(m2Owner.type.referenceProjectionOrSelf(), m1Owner) != null &&\n@@ -2253,4 +2247,0 @@\n-        \/\/ ATM, inner\/nested types are members of only the declaring inline class,\n-        \/\/ although accessible via the reference projection.\n-        if (c.isReferenceProjection())\n-            c = (TypeSymbol) c.valueProjection();\n@@ -3066,7 +3056,0 @@\n-                    ClassSymbol refProjection = newConstr.owner.isPrimitiveClass() ?\n-                                                     (ClassSymbol) newConstr.owner.referenceProjection() : null;\n-                    if (refProjection != null) {\n-                        MethodSymbol clone = newConstr.clone(refProjection);\n-                        clone.projection = newConstr;\n-                        newConstr.projection = clone;\n-                    }\n@@ -3623,1 +3606,1 @@\n-                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {\n+                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head.referenceProjectionOrSelf()), originalSite))) {\n@@ -3676,1 +3659,1 @@\n-                Type asSuperSite = types.asSuper(argtypes.head, site.tsym);\n+                Type asSuperSite = types.asSuper(argtypes.head.referenceProjectionOrSelf(), site.tsym);\n@@ -3735,1 +3718,1 @@\n-                this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata());\n+                this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata(), site.isReferenceProjection());\n@@ -3825,1 +3808,1 @@\n-                            types.asSuper(env.enclClass.type, c), env.enclClass.sym);\n+                            types.asSuper(env.enclClass.type.referenceProjectionOrSelf(), c), env.enclClass.sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":6,"deletions":23,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -291,1 +291,0 @@\n-        ClassSymbol refProjection = origin.isPrimitiveClass() ? origin.referenceProjection() : null;\n@@ -293,6 +292,0 @@\n-        if (refProjection != null) {\n-            MethodSymbol clone = bridge.clone(refProjection);\n-            clone.projection = bridge;\n-            bridge.projection = clone;\n-            refProjection.members().enter(clone);\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -736,10 +736,0 @@\n-            if (ct.isPrimitiveClass()) {\n-                ClassSymbol cSym = (ClassSymbol) ct.tsym;\n-                if (cSym.projection != null) {\n-                    ClassType projectedType = (ClassType) cSym.projection.type;\n-                    projectedType.supertype_field = ct.supertype_field;\n-                    projectedType.interfaces_field = ct.interfaces_field;\n-                    projectedType.all_interfaces_field = ct.all_interfaces_field;\n-                }\n-            }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -300,2 +300,1 @@\n-        ClassSymbol refProjection =  c.isPrimitiveClass() ? c.referenceProjection() : null;\n-        if ((sym.flags_field & (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda)) {\n+        if ((sym.flags_field & (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))\n@@ -303,20 +302,0 @@\n-            if (refProjection != null) {\n-                Symbol clone = null;\n-                if (sym.kind == MTH) {\n-                    MethodSymbol valMethod = (MethodSymbol)sym;\n-                    MethodSymbol refMethod = valMethod.clone(refProjection);\n-                    valMethod.projection = refMethod;\n-                    refMethod.projection = valMethod;\n-                    clone = refMethod;\n-                } else if (sym.kind == VAR) {\n-                    VarSymbol valVar = (VarSymbol)sym;\n-                    VarSymbol refVar = valVar.clone(refProjection);\n-                    valVar.projection = refVar;\n-                    refVar.projection = valVar;\n-                    clone = refVar;\n-                }\n-                if (clone != null) {\n-                    refProjection.members_field.enter(clone);\n-                }\n-            }\n-        }\n@@ -564,0 +543,2 @@\n+        Name name;\n+        boolean requireProjection;\n@@ -571,4 +552,10 @@\n-                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n-                                                         startSbp,\n-                                                         sbp - startSbp));\n-\n+                name = names.fromUtf(signatureBuffer,\n+                        startSbp,\n+                        sbp - startSbp);\n+                if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n+                    name = name.subName(0, name.length() - 4);\n+                    requireProjection = true;\n+                } else {\n+                    requireProjection = false;\n+                }\n+                ClassSymbol t = enterClass(name);\n@@ -577,2 +564,2 @@\n-                            t.erasure(types) :\n-                        new ClassType(outer, List.nil(), t);\n+                            requireProjection ? t.erasure(types).referenceProjection() : t.erasure(types) :\n+                        new ClassType(outer, List.nil(), t, TypeMetadata.EMPTY, requireProjection);\n@@ -585,4 +572,11 @@\n-                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,\n-                                                         startSbp,\n-                                                         sbp - startSbp));\n-                outer = new ClassType(outer, sigToTypes('>'), t) {\n+                name = names.fromUtf(signatureBuffer,\n+                        startSbp,\n+                        sbp - startSbp);\n+                if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n+                    name = name.subName(0, name.length() - 4);\n+                    requireProjection = true;\n+                } else {\n+                    requireProjection = false;\n+                }\n+                ClassSymbol t = enterClass(name);\n+                outer = new ClassType(outer, sigToTypes('>'), t, TypeMetadata.EMPTY, requireProjection) {\n@@ -648,4 +642,11 @@\n-                    t = enterClass(names.fromUtf(signatureBuffer,\n-                                                 startSbp,\n-                                                 sbp - startSbp));\n-                    outer = new ClassType(outer, List.nil(), t);\n+                    name = names.fromUtf(signatureBuffer,\n+                            startSbp,\n+                            sbp - startSbp);\n+                    if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n+                        name = name.subName(0, name.length() - 4);\n+                        requireProjection = true;\n+                    } else {\n+                        requireProjection = false;\n+                    }\n+                    t = enterClass(name);\n+                    outer = new ClassType(outer, List.nil(), t, TypeMetadata.EMPTY, requireProjection);\n@@ -2509,4 +2510,0 @@\n-        if (allowPrimitiveClasses && name.toString().endsWith(\"$ref\")) {\n-            ClassSymbol v = syms.enterClass(currentModule, name.subName(0, name.length() - 4));\n-            return v.referenceProjection();\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":37,"deletions":40,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import com.sun.tools.javac.code.Scope.WriteableScope;\n@@ -823,1 +824,2 @@\n-    \/** Write \"inner classes\" attribute.\n+    \/** Write \"inner classes\" attribute. If a primitive class happens to be an inner class,\n+     *  the reference projection class will also be an inner class.\n@@ -827,1 +829,2 @@\n-        databuf.appendChar(poolWriter.innerClasses.size());\n+        int icCountIdx = beginAttrs();\n+        int icCount = 0;\n@@ -844,0 +847,11 @@\n+            icCount++;\n+            if (inner.isPrimitiveClass()) {\n+                databuf.appendChar(poolWriter.putClass(inner.type.referenceProjection()));\n+                databuf.appendChar(\n+                        inner.owner.kind == TYP && !inner.name.isEmpty() ? poolWriter.putClass((ClassSymbol)inner.owner) : 0);\n+                databuf.appendChar(\n+                        !inner.name.isEmpty() ? poolWriter.putName(inner.name.append('$', names.ref)) : 0);\n+                flags = (char) ((flags & ~(ACC_PRIMITIVE | FINAL)) | ABSTRACT);\n+                databuf.appendChar(flags);\n+                icCount++;\n+            }\n@@ -845,0 +859,1 @@\n+        endAttrs(icCountIdx, icCount);\n@@ -882,1 +897,2 @@\n-                databuf.appendChar(nestedUnique.size());\n+                int nmcIdx = beginAttrs();\n+                int nmc = 0;\n@@ -885,0 +901,5 @@\n+                    nmc++;\n+                    if (s.isPrimitiveClass() && s.owner.kind != PCK) {\n+                        databuf.appendChar(poolWriter.putClass(s.type.referenceProjection()));\n+                        nmc++;\n+                    }\n@@ -886,0 +907,1 @@\n+                endAttrs(nmcIdx, nmc);\n@@ -901,1 +923,3 @@\n-                outerMost = outerMost.referenceProjection();\n+                databuf.appendChar(poolWriter.putClass(outerMost.type.referenceProjection()));\n+            } else {\n+                databuf.appendChar(poolWriter.putClass(outerMost));\n@@ -903,1 +927,0 @@\n-            databuf.appendChar(poolWriter.putClass(outerMost));\n@@ -915,3 +938,0 @@\n-            if (csym.isPrimitiveClass()) {\n-                seen.add(csym.referenceProjection());\n-            }\n@@ -1514,3 +1534,1 @@\n-            ClassSymbol refProjection = c.referenceProjection();\n-            refProjection.flags_field = (refProjection.flags_field & ~FINAL) | ABSTRACT;\n-            writeClassInternal(refProjection);\n+            writeClassInternal(getReferenceProjection(c));\n@@ -1521,0 +1539,51 @@\n+        \/\/ where\n+        private static ClassSymbol getReferenceProjection(ClassSymbol c) {\n+\n+            ClassSymbol projection;\n+            ClassType projectedType;\n+\n+            ClassType ct = (ClassType) c.type;\n+            projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null, ct.getMetadata(), false);\n+            projectedType.allparams_field = ct.allparams_field;\n+            projectedType.supertype_field = ct.supertype_field;\n+\n+            projectedType.interfaces_field = ct.interfaces_field;\n+            projectedType.all_interfaces_field = ct.all_interfaces_field;\n+            projectedType.projection = null;\n+\n+            Name projectionName = c.name.append('$', c.name.table.names.ref);\n+            long projectionFlags = (c.flags() & ~(PRIMITIVE_CLASS | UNATTRIBUTED | FINAL)) | (ABSTRACT | SEALED);\n+\n+            projection = new ClassSymbol(projectionFlags, projectionName, projectedType, c.owner) {\n+                @Override\n+                public boolean isReferenceProjection() {\n+                    return true;\n+                }\n+\n+                @Override\n+                public ClassSymbol valueProjection() {\n+                    return c;\n+                }\n+            };\n+            projection.members_field = WriteableScope.create(projection);\n+            for (Symbol s : c.members().getSymbols(s->(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {\n+                Symbol clone = null;\n+                if (s.kind == MTH) {\n+                    MethodSymbol valMethod = (MethodSymbol)s;\n+                    MethodSymbol refMethod = valMethod.clone(projection);\n+                    clone = refMethod;\n+                } else if (s.kind == VAR) {\n+                    VarSymbol valVar = (VarSymbol)s;\n+                    VarSymbol refVar = valVar.clone(projection);\n+                    clone = refVar;\n+                }\n+                projection.members_field.enter(clone);\n+            }\n+            projection.completer = Completer.NULL_COMPLETER;\n+            projection.sourcefile = c.sourcefile;\n+            projection.flatname = c.flatname.append('$', c.name.table.names.ref);\n+            projection.permitted = List.of(c);\n+            projectedType.tsym = projection;\n+            return projection;\n+        }\n+\n@@ -1593,1 +1662,1 @@\n-        databuf.appendChar(supertype.hasTag(CLASS) ? poolWriter.putClass((ClassSymbol)supertype.tsym) : 0);\n+        databuf.appendChar(supertype.hasTag(CLASS) ? poolWriter.putClass(supertype) : 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":81,"deletions":12,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2278,2 +2278,2 @@\n-            (!tree.clazz.type.tsym.isReferenceProjection() || tree.clazz.type.tsym.valueProjection() != tree.expr.type.tsym) &&\n-           types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {\n+            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type)) &&\n+           !types.isSubtype(tree.expr.type, tree.clazz.type)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -233,0 +233,3 @@\n+        if (c.isReferenceProjection()) {\n+            c = c.valueProjection();\n+        }\n@@ -378,0 +381,3 @@\n+                    if (ct.isReferenceProjection()) {\n+                        name = name.append('$', names.ref);\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.tools.javac.code.Type;\n@@ -226,10 +227,0 @@\n-                ClassSymbol refProjection = currentClass.sym.projection;\n-                if (refProjection != null) {\n-                    MethodSymbol projection = tree.sym.projection;\n-                    Assert.check(projection != null);\n-                    refProjection.members().remove(projection);\n-                    projection = factorySym.clone(refProjection);\n-                    projection.projection = factorySym;\n-                    factorySym.projection = projection;\n-                    refProjection.members().enter(projection);\n-                }\n@@ -342,1 +333,1 @@\n-            TypeSymbol selectedType = fieldAccess.selected.type.tsym;\n+            Type selectedType = fieldAccess.selected.type;\n@@ -348,1 +339,1 @@\n-                            fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection().type));\n+                            fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection()));\n@@ -351,3 +342,1 @@\n-                                    make.TypeCast(types.erasure(selectedType.valueProjection().type), fieldAccess.selected);\n-                            if (sym.owner.isReferenceProjection()) \/\/ is an empty class file.\n-                                TreeInfo.setSymbol(fieldAccess, sym.valueProjection());\n+                                    make.TypeCast(types.erasure(selectedType.valueProjection()), fieldAccess.selected);\n@@ -357,1 +346,1 @@\n-                        fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection().type));\n+                        fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-        if (types.asSuper(site, sym.getEnclosingElement()) == null)\n+        if (types.asSuper(site.referenceProjectionOrSelf(), sym.getEnclosingElement()) == null)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    \/\/ Expected output can't be directly encoded into NestedLambdasCastedTest !!!\n+    \/\/ Expected output can't be directly encoded into BridgeShouldHaveNoInteriorAnnotationsTest !!!\n@@ -77,2 +77,2 @@\n-            \"0: #120(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]\",\n-            \"1: #120(): LOCAL_VARIABLE, {start_pc=5, length=2, index=1}, location=[TYPE_ARGUMENT(0)]\",\n+            \"0: #118(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]\",\n+            \"1: #118(): LOCAL_VARIABLE, {start_pc=2, length=2, index=1}, location=[TYPE_ARGUMENT(0)]\",\n@@ -84,1 +84,1 @@\n-            \"0: #120(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]\",\n+            \"0: #118(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]\",\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/BridgeShouldHaveNoInteriorAnnotationsTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* This test \"covers\"\/verifies com.sun.tools.javac.model.JavacTypes#asMemberOf's calls\n+   to asSuper work*properly with primitive types.\n+*\/\n+\n+\/**\n+ * @test\n+ * @bug 8244712\n+ * @summary Test API usage with reference projection types.\n+ * @library .\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ * @build ToolTester\n+ * @run main TestApisWithProjections\n+ *\/\n+\n+import java.io.*;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n+import javax.tools.*;\n+\n+import com.sun.tools.javac.api.JavacTaskImpl;\n+\n+public class TestApisWithProjections extends ToolTester {\n+    public static void main(String... args) throws Exception {\n+        try (TestApisWithProjections t = new TestApisWithProjections()) {\n+            t.run();\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw);\n+        File file = new File(test_src, \"TestApisWithProjections.java\");\n+        final Iterable<? extends JavaFileObject> compilationUnits =\n+            fm.getJavaFileObjects(new File[] {file});\n+        task = (JavacTaskImpl)tool.getTask(pw, fm, null, null, null, compilationUnits);\n+        elements = task.getElements();\n+        types = task.getTypes();\n+\n+        Iterable<? extends TypeElement> toplevels;\n+        toplevels = ElementFilter.typesIn(task.enter(task.parse()));\n+\n+        for (TypeElement clazz : toplevels) {\n+            System.out.format(\"Testing %s:%n%n\", clazz.getSimpleName());\n+            testParseType(clazz);\n+        }\n+\n+        pw.close();\n+\n+        String out = sw.toString();\n+        System.out.println(out);\n+\n+        if (out.contains(\"com.sun.tools.javac.util\"))\n+            throw new Exception(\"Unexpected output from compiler\");\n+    }\n+\n+    void testParseType(TypeElement clazz) {\n+        DeclaredType type = (DeclaredType)task.parseType(\"PrimitiveClass<String>\", clazz);\n+        for (Element member : elements.getAllMembers((TypeElement)type.asElement())) {\n+            TypeMirror mt = types.asMemberOf(type, member);\n+            System.out.format(\"%s : %s -> %s%n\", member.getSimpleName(), member.asType(), mt);\n+        }\n+    }\n+\n+    JavacTaskImpl task;\n+    Elements elements;\n+    Types types;\n+}\n+\n+abstract class Base<T> {\n+    void foo(T t) {}\n+}\n+\n+primitive class PrimitiveClass<T> extends Base<T> {\n+}\n","filename":"test\/langtools\/tools\/javac\/api\/TestApisWithProjections.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8244712\n+ * @summary Javac should switch to reference projection before walking type hierarchy.\n+ * @compile AsSuperTests.java\n+ *\/\n+\n+\/* The following test \"covers\"\/verifies that the asSuper calls in\n+   com.sun.tools.javac.comp.Resolve#resolveSelf &&\n+   com.sun.tools.javac.comp.Lower#visitSelect\n+   com.sun.tools.javac.comp.Resolve#mostSpecific\n+   com.sun.tools.javac.comp.Attr#visitSelect\n+   com.sun.tools.javac.comp.Resolve.UnboundMethodReferenceLookupHelper#UnboundMethodReferenceLookupHelper\n+   work correctly with primitive types.\n+*\/\n+\n+interface I {\n+    default void foo() {\n+        System.out.println(\"I.foo\");\n+    }\n+}\n+\n+abstract class Base<T> {\n+    static void goo() {}\n+    void zoo() {}\n+    interface SAM {\n+       String m(Foo f);\n+    }\n+\n+    static void test() {\n+        SAM s = Base::getX;\n+    }\n+\n+    String getX() { return null; }\n+\n+    static primitive class Foo<X> extends Base {}\n+}\n+\n+primitive class X extends Base implements I {\n+\n+    static void goo() {}\n+\n+    public void foo() {\n+        I.super.foo();\n+        X.this.goo(); \/\/ covers the asSuper call in com.sun.tools.javac.comp.Resolve#mostSpecific\n+        super.zoo();  \/\/ covers the asSuper call in com.sun.tools.javac.comp.Attr#visitSelect\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/AsSuperTests.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -60,1 +60,1 @@\n-        if (!name.equals(\"V$ref\")) {\n+        if (!name.equals(\"V\")) {\n@@ -64,1 +64,1 @@\n-        if (!name.equals(\"V\")) {\n+        if (!name.equals(\"V$ref\")) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/AttributesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-CheckQuestionInMessages.java:12:22: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, java.util.List<X$ref>)\n-CheckQuestionInMessages.java:13:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], X$ref[])\n+CheckQuestionInMessages.java:12:22: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, java.util.List<X.ref>)\n+CheckQuestionInMessages.java:13:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], X.ref[])\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/CheckQuestionInMessages.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,8 +1,8 @@\n-ClassLiteralTypingNegativeTest.java:14:51: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Foo$ref>)\n-ClassLiteralTypingNegativeTest.java:15:41: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Foo$ref>)\n-ClassLiteralTypingNegativeTest.java:17:30: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Foo$ref>)\n-ClassLiteralTypingNegativeTest.java:19:34: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Foo$ref>)\n-ClassLiteralTypingNegativeTest.java:31:51: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object&ClassLiteralTypingNegativeTest.I>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Bar$ref>)\n-ClassLiteralTypingNegativeTest.java:32:41: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object&ClassLiteralTypingNegativeTest.I>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Bar$ref>)\n-ClassLiteralTypingNegativeTest.java:34:30: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object&ClassLiteralTypingNegativeTest.I>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Bar$ref>)\n-ClassLiteralTypingNegativeTest.java:36:34: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object&ClassLiteralTypingNegativeTest.I>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Bar$ref>)\n+ClassLiteralTypingNegativeTest.java:14:51: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Foo.ref>)\n+ClassLiteralTypingNegativeTest.java:15:41: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Foo.ref>)\n+ClassLiteralTypingNegativeTest.java:17:30: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Foo.ref>)\n+ClassLiteralTypingNegativeTest.java:19:34: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Foo.ref>)\n+ClassLiteralTypingNegativeTest.java:31:51: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object&ClassLiteralTypingNegativeTest.I>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Bar.ref>)\n+ClassLiteralTypingNegativeTest.java:32:41: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object&ClassLiteralTypingNegativeTest.I>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Bar.ref>)\n+ClassLiteralTypingNegativeTest.java:34:30: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object&ClassLiteralTypingNegativeTest.I>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Bar.ref>)\n+ClassLiteralTypingNegativeTest.java:36:34: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Class<compiler.misc.type.captureof: 1, ? extends java.lang.Object&ClassLiteralTypingNegativeTest.I>, java.lang.Class<? extends ClassLiteralTypingNegativeTest.Bar.ref>)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ClassLiteralTypingNegativeTest.out","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-ConditionalTypeTest.java:27:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, ConditionalTypeTest.Node$ref)\n+ConditionalTypeTest.java:27:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, ConditionalTypeTest.Node.ref)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/ConditionalTypeTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8244711\n+ * @bug 8244711 8244712\n@@ -37,0 +37,8 @@\n+\/* This test covers\/verifies that the asSuper calls in\n+\n+   com.sun.tools.javac.comp.Lower.visitIterableForeachLoop\n+   com.sun.tools.javac.comp.Attr#visitForeachLoop\n+\n+   work properly with primitive class types.\n+*\/\n+\n@@ -39,0 +47,20 @@\n+    static primitive class PrimitiveIterator<V> implements Iterator<V> {\n+\n+        Iterator<V> iv;\n+\n+        public PrimitiveIterator(List<V> lv) {\n+            this.iv = lv.iterator();\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return iv.hasNext();\n+        }\n+\n+        @Override\n+        public V next() {\n+            return iv.next();\n+        }\n+\n+    }\n+\n@@ -51,2 +79,2 @@\n-        public Iterator<V> iterator() {\n-            return lv.iterator();\n+       public PrimitiveIterator<V> iterator() {\n+            return new PrimitiveIterator<V>(lv);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/EnhancedForLoopTest.java","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -5,3 +5,3 @@\n-GenericInlineTest.java:37:53: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest<java.lang.String,java.lang.Integer>, GenericInlineTest$ref<java.lang.Integer,java.lang.String>)\n-GenericInlineTest.java:40:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest$ref<java.lang.Integer,java.lang.String>, GenericInlineTest<java.lang.String,java.lang.Integer>)\n-GenericInlineTest.java:41:50: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest$ref<java.lang.Integer,java.lang.String>, GenericInlineTest<java.lang.String,java.lang.Integer>)\n+GenericInlineTest.java:37:53: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest<java.lang.String,java.lang.Integer>, GenericInlineTest.ref<java.lang.Integer,java.lang.String>)\n+GenericInlineTest.java:40:13: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest.ref<java.lang.Integer,java.lang.String>, GenericInlineTest<java.lang.String,java.lang.Integer>)\n+GenericInlineTest.java:41:50: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: GenericInlineTest.ref<java.lang.Integer,java.lang.String>, GenericInlineTest<java.lang.String,java.lang.Integer>)\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/GenericInlineTest.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-OverloadingPhaseTest.java:26:24: compiler.err.ref.ambiguous: roo, kindname.method, roo(OverloadingPhaseTest.V$ref,int), OverloadingPhaseTest, kindname.method, roo(OverloadingPhaseTest.V$ref,java.lang.Integer), OverloadingPhaseTest\n-OverloadingPhaseTest.java:28:24: compiler.err.ref.ambiguous: roo, kindname.method, roo(OverloadingPhaseTest.V$ref,int), OverloadingPhaseTest, kindname.method, roo(OverloadingPhaseTest.V$ref,java.lang.Integer), OverloadingPhaseTest\n+OverloadingPhaseTest.java:26:24: compiler.err.ref.ambiguous: roo, kindname.method, roo(OverloadingPhaseTest.V.ref,int), OverloadingPhaseTest, kindname.method, roo(OverloadingPhaseTest.V.ref,java.lang.Integer), OverloadingPhaseTest\n+OverloadingPhaseTest.java:28:24: compiler.err.ref.ambiguous: roo, kindname.method, roo(OverloadingPhaseTest.V.ref,int), OverloadingPhaseTest, kindname.method, roo(OverloadingPhaseTest.V.ref,java.lang.Integer), OverloadingPhaseTest\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/OverloadingPhaseTest.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-TypeRelationsNegativeTest.java:26:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TypeRelationsNegativeTest$ref[], TypeRelationsNegativeTest[])\n+TypeRelationsNegativeTest.java:26:14: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: TypeRelationsNegativeTest.ref[], TypeRelationsNegativeTest[])\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/TypeRelationsNegativeTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}