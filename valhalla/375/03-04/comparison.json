{"files":[{"patch":"@@ -2045,1 +2045,1 @@\n-                types.asSuper(owner.type, other.owner.type) != null &&\n+                types.isSubtype(owner.type, other.owner.type) &&\n@@ -2114,1 +2114,1 @@\n-                types.asSuper(owner.type, other.owner, true) != null) {\n+                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-     * @return the reference projection type IFF the receiver is an inline type\n+     * @return the reference projection type IFF the receiver is a primitive class type\n@@ -266,0 +266,8 @@\n+    \/**\n+     * @return the reference projection type IFF the receiver is a primitive class type or self otherwise.\n+     *\/\n+    public Type referenceProjectionOrSelf() {\n+        Type projection = referenceProjection();\n+        return projection != null ? projection : this;\n+    }\n+\n@@ -1244,1 +1252,4 @@\n-            if (!isPrimitiveClass() || projection != null)\n+            if (!isPrimitiveClass())\n+                return null;\n+\n+            if (projection != null)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -556,1 +556,1 @@\n-                Type base = asSuper(sym.type, t);\n+                Type base = asSuper(sym.type, t.tsym);\n@@ -1054,1 +1054,1 @@\n-                Type t2 = asSuper(t, s);\n+                Type t2 = asSuper(t, s.tsym);\n@@ -1206,1 +1206,1 @@\n-                Type sup = asSuper(t, s);\n+                Type sup = asSuper(t, s.tsym);\n@@ -1211,0 +1211,1 @@\n+                    && (t.tsym != s.tsym || t.isReferenceProjection() == s.isReferenceProjection())\n@@ -2195,15 +2196,0 @@\n-    \/**\n-     * Return the (most specific) base type of `t' that starts with the\n-     * given type `s'.  If none exists, return null.\n-     *\n-     * @param t a type\n-     * @param s a type\n-     *\/\n-    public Type asSuper(Type t, Type s) {\n-        \/* There isn't any language level subtyping relation between a primitive class type and\n-           its reference projection even though they share the same underlying symbol\n-        *\/\n-        return  (t.tsym != s.tsym || t.isReferenceProjection() == s.isReferenceProjection()) ?\n-                asSuper(t, s.tsym) : null;\n-    }\n-\n@@ -2219,10 +2205,2 @@\n-     * @param t a type\n-     * @param sym a symbol\n-     *\/\n-    public Type asSuper(Type t, Symbol sym) {\n-        return asSuper(t, sym, false);\n-    }\n-\n-    \/**\n-     * Return the (most specific) base type of t that starts with the\n-     * given symbol.  If none exists, return null.\n+     * Further caveats in Valhalla: There are two \"hazards\" we need to watch out for when using\n+     * this method.\n@@ -2230,4 +2208,22 @@\n-     * Caveat Emptor: Since javac represents the class of all arrays with a singleton\n-     * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,\n-     * this method could yield surprising answers when invoked on arrays. For example when\n-     * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.\n+     * 1. Since Foo.ref and Foo.val share the same symbol, that of Foo.class, a call to\n+     *    asSuper(Foo.ref.type, Foo.val.type.tsym) would return non-null. This is NOT correct\n+     *    Foo.val is NOT a super type of Foo.ref either in the language model or in the VM's\n+     *    world view. An example of such an hazardous call used to exist in Gen.visitTypeCast.\n+     *    When we emit code for  (Foo) Foo.ref.instance a check for whether we really need the\n+     *    cast cannot\/shouldn't be gated on asSuper(tree.expr.type, tree.clazz.type.tsym) == null)\n+     *    but use !types.isSubtype(tree.expr.type, tree.clazz.type) which operates in terms of\n+     *    types. When we operate in terms of symbols, there is a loss of type information leading\n+     *    to a hazard. Whether a call to asSuper should be transformed into a isSubtype call is\n+     *    tricky. isSubtype returns just a boolean while asSuper returns richer information which\n+     *    may be required at the call site. Also where the concerned symbol corresponds to a\n+     *    generic class, an asSuper call cannot be conveniently rewritten as an isSubtype call\n+     *    (see that asSuper(ArrayList<String>.type, List<T>.tsym) != null while\n+     *    isSubType(ArrayList<String>.type, List<T>.type) is false;) So care needs to be exercised.\n+     *\n+     * 2. Given a primitive class Foo, a call to asSuper(Foo.type, SuperclassOfFoo.tsym) and\/or\n+     *    a call to asSuper(Foo.type, SuperinterfaceOfFoo.tsym) would answer null. In many places\n+     *    that is NOT what we want. An example of such a hazardous call used to occur in\n+     *    Attr.visitForeachLoop when checking to make sure the for loop's control variable of a type\n+     *    that implements Iterable: viz: types.asSuper(exprType, syms.iterableType.tsym);\n+     *    These hazardous calls should be rewritten as\n+     *    types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym); instead.\n@@ -2237,1 +2233,0 @@\n-     * @param checkReferenceProjection if true, first compute reference projection of t\n@@ -2239,1 +2234,1 @@\n-    public Type asSuper(Type t, Symbol sym, boolean checkReferenceProjection) {\n+    public Type asSuper(Type t, Symbol sym) {\n@@ -2249,7 +2244,0 @@\n-        \/* For a (value or identity) class V, whether it implements an interface I, boils down to whether\n-           V.ref is a subtype of I. OIOW, whether asSuper(V.ref, sym) != null. (Likewise for an abstract\n-           superclass)\n-        *\/\n-        if (checkReferenceProjection)\n-            t = t.isPrimitiveClass() ? t.referenceProjection() : t;\n-\n@@ -3363,1 +3351,1 @@\n-                        asSuper(m2.owner.type, m1.owner.type) != null) {\n+                        asSuper(m2.owner.type, m1.owner) != null) {\n@@ -4194,1 +4182,1 @@\n-                List<Type> lci = List.of(asSuper(ts[startIdx], erasedSupertype));\n+                List<Type> lci = List.of(asSuper(ts[startIdx], erasedSupertype.tsym));\n@@ -4196,1 +4184,1 @@\n-                    Type superType = asSuper(ts[i], erasedSupertype);\n+                    Type superType = asSuper(ts[i], erasedSupertype.tsym);\n@@ -4650,1 +4638,1 @@\n-            Type t1 = asSuper(from, commonSupers.head);\n+            Type t1 = asSuper(from, commonSupers.head.tsym);\n@@ -4677,1 +4665,1 @@\n-        Type t1 = asSuper(from, to);\n+        Type t1 = asSuper(from, to.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":34,"deletions":46,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1597,1 +1597,1 @@\n-                Type base = types.asSuper(exprType, syms.iterableType.tsym, true);\n+                Type base = types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym);\n@@ -1919,1 +1919,1 @@\n-            types.asSuper(resource, syms.autoCloseableType.tsym, true) != null &&\n+            types.isSubtype(resource.referenceProjectionOrSelf(), syms.autoCloseableType) &&\n@@ -4386,1 +4386,1 @@\n-                Type site1 = types.asSuper(env.enclClass.sym.type, site);\n+                Type site1 = types.asSuper(env.enclClass.sym.type.referenceProjectionOrSelf(), site.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2698,2 +2698,2 @@\n-        boolean implementsIdentityObject = types.asSuper(c, syms.identityObjectType.tsym, true) != null;\n-        boolean implementsPrimitiveObject = types.asSuper(c, syms.primitiveObjectType.tsym, true) != null;\n+        boolean implementsIdentityObject = types.isSubtype(c.referenceProjectionOrSelf(), syms.identityObjectType);\n+        boolean implementsPrimitiveObject = types.isSubtype(c.referenceProjectionOrSelf(), syms.primitiveObjectType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1240,1 +1240,1 @@\n-                    if (types.asSuper(sup, syms.autoCloseableType.tsym, true) != null) {\n+                    if (types.isSubtype(sup.referenceProjectionOrSelf(), syms.autoCloseableType)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-                Type sup = types.asSuper(t, to);\n+                Type sup = types.asSuper(t, to.tsym);\n@@ -1149,1 +1149,1 @@\n-                    types.asSuper(t, sup);\n+                    types.asSuper(t, sup.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1862,1 +1862,1 @@\n-                return types.asSuper(tree.target, syms.serializableType) != null;\n+                return types.isSubtype(tree.target, syms.serializableType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1725,1 +1725,1 @@\n-        if (types.asSuper(resource.type, syms.autoCloseableType.tsym, true) == null) {\n+        if (!types.isSubtype(resource.type.referenceProjectionOrSelf(), syms.autoCloseableType)) {\n@@ -3519,2 +3519,2 @@\n-            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type),\n-                                              syms.iterableType.tsym, true);\n+            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type.referenceProjectionOrSelf()),\n+                                              syms.iterableType.tsym);\n@@ -3532,1 +3532,1 @@\n-                                            types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType)),\n+                                            types.erasure(types.asSuper(iterator.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym)),\n@@ -3993,1 +3993,2 @@\n-            Assert.checkNonNull(types.asSuper(currentClass.type, tree.selected.type));\n+            TypeSymbol supSym = tree.selected.type.tsym;\n+            Assert.checkNonNull(types.asSuper(currentClass.type.referenceProjectionOrSelf(), supSym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1230,1 +1230,1 @@\n-                    return types.asSuper(t, s) == null && types.asSuper(s, t) == null;\n+                    return types.asSuper(t, s.tsym) == null && types.asSuper(s, t.tsym) == null;\n@@ -1712,1 +1712,1 @@\n-                    if (types.asSuper(m1Owner.type, m2Owner.type) != null &&\n+                    if (types.asSuper(m1Owner.type.referenceProjectionOrSelf(), m2Owner) != null &&\n@@ -1717,1 +1717,1 @@\n-                    if (types.asSuper(m2Owner.type, m1Owner.type) != null &&\n+                    if (types.asSuper(m2Owner.type.referenceProjectionOrSelf(), m1Owner) != null &&\n@@ -3606,1 +3606,1 @@\n-                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {\n+                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head.referenceProjectionOrSelf()), originalSite))) {\n@@ -3659,1 +3659,1 @@\n-                Type asSuperSite = types.asSuper(argtypes.head, site);\n+                Type asSuperSite = types.asSuper(argtypes.head.referenceProjectionOrSelf(), site.tsym);\n@@ -3808,1 +3808,1 @@\n-                            types.asSuper(env.enclClass.type, c.type), env.enclClass.sym);\n+                            types.asSuper(env.enclClass.type.referenceProjectionOrSelf(), c), env.enclClass.sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2279,1 +2279,1 @@\n-           types.asSuper(tree.expr.type, tree.clazz.type) == null) {\n+           !types.isSubtype(tree.expr.type, tree.clazz.type)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-        if (types.asSuper(site, sym.getEnclosingElement().type) == null)\n+        if (types.asSuper(site.referenceProjectionOrSelf(), sym.getEnclosingElement()) == null)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    \/\/ Expected output can't be directly encoded into NestedLambdasCastedTest !!!\n+    \/\/ Expected output can't be directly encoded into BridgeShouldHaveNoInteriorAnnotationsTest !!!\n@@ -77,2 +77,2 @@\n-            \"0: #120(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]\",\n-            \"1: #120(): LOCAL_VARIABLE, {start_pc=5, length=2, index=1}, location=[TYPE_ARGUMENT(0)]\",\n+            \"0: #118(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]\",\n+            \"1: #118(): LOCAL_VARIABLE, {start_pc=2, length=2, index=1}, location=[TYPE_ARGUMENT(0)]\",\n@@ -84,1 +84,1 @@\n-            \"0: #120(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]\",\n+            \"0: #118(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]\",\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/BridgeShouldHaveNoInteriorAnnotationsTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* This test \"covers\"\/verifies com.sun.tools.javac.model.JavacTypes#asMemberOf's calls\n+   to asSuper work*properly with primitive types.\n+*\/\n+\n+\/**\n+ * @test\n+ * @bug 8244712\n+ * @summary Test API usage with reference projection types.\n+ * @library .\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ * @build ToolTester\n+ * @run main TestApisWithProjections\n+ *\/\n+\n+import java.io.*;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n+import javax.tools.*;\n+\n+import com.sun.tools.javac.api.JavacTaskImpl;\n+\n+public class TestApisWithProjections extends ToolTester {\n+    public static void main(String... args) throws Exception {\n+        try (TestApisWithProjections t = new TestApisWithProjections()) {\n+            t.run();\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw);\n+        File file = new File(test_src, \"TestApisWithProjections.java\");\n+        final Iterable<? extends JavaFileObject> compilationUnits =\n+            fm.getJavaFileObjects(new File[] {file});\n+        task = (JavacTaskImpl)tool.getTask(pw, fm, null, null, null, compilationUnits);\n+        elements = task.getElements();\n+        types = task.getTypes();\n+\n+        Iterable<? extends TypeElement> toplevels;\n+        toplevels = ElementFilter.typesIn(task.enter(task.parse()));\n+\n+        for (TypeElement clazz : toplevels) {\n+            System.out.format(\"Testing %s:%n%n\", clazz.getSimpleName());\n+            testParseType(clazz);\n+        }\n+\n+        pw.close();\n+\n+        String out = sw.toString();\n+        System.out.println(out);\n+\n+        if (out.contains(\"com.sun.tools.javac.util\"))\n+            throw new Exception(\"Unexpected output from compiler\");\n+    }\n+\n+    void testParseType(TypeElement clazz) {\n+        DeclaredType type = (DeclaredType)task.parseType(\"PrimitiveClass<String>\", clazz);\n+        for (Element member : elements.getAllMembers((TypeElement)type.asElement())) {\n+            TypeMirror mt = types.asMemberOf(type, member);\n+            System.out.format(\"%s : %s -> %s%n\", member.getSimpleName(), member.asType(), mt);\n+        }\n+    }\n+\n+    JavacTaskImpl task;\n+    Elements elements;\n+    Types types;\n+}\n+\n+abstract class Base<T> {\n+    void foo(T t) {}\n+}\n+\n+primitive class PrimitiveClass<T> extends Base<T> {\n+}\n","filename":"test\/langtools\/tools\/javac\/api\/TestApisWithProjections.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8244712\n+ * @summary Javac should switch to reference projection before walking type hierarchy.\n+ * @compile AsSuperTests.java\n+ *\/\n+\n+\/* The following test \"covers\"\/verifies that the asSuper calls in\n+   com.sun.tools.javac.comp.Resolve#resolveSelf &&\n+   com.sun.tools.javac.comp.Lower#visitSelect\n+   com.sun.tools.javac.comp.Resolve#mostSpecific\n+   com.sun.tools.javac.comp.Attr#visitSelect\n+   com.sun.tools.javac.comp.Resolve.UnboundMethodReferenceLookupHelper#UnboundMethodReferenceLookupHelper\n+   work correctly with primitive types.\n+*\/\n+\n+interface I {\n+    default void foo() {\n+        System.out.println(\"I.foo\");\n+    }\n+}\n+\n+abstract class Base<T> {\n+    static void goo() {}\n+    void zoo() {}\n+    interface SAM {\n+       String m(Foo f);\n+    }\n+\n+    static void test() {\n+        SAM s = Base::getX;\n+    }\n+\n+    String getX() { return null; }\n+\n+    static primitive class Foo<X> extends Base {}\n+}\n+\n+primitive class X extends Base implements I {\n+\n+    static void goo() {}\n+\n+    public void foo() {\n+        I.super.foo();\n+        X.this.goo(); \/\/ covers the asSuper call in com.sun.tools.javac.comp.Resolve#mostSpecific\n+        super.zoo();  \/\/ covers the asSuper call in com.sun.tools.javac.comp.Attr#visitSelect\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/AsSuperTests.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8244711\n+ * @bug 8244711 8244712\n@@ -37,0 +37,8 @@\n+\/* This test covers\/verifies that the asSuper calls in\n+\n+   com.sun.tools.javac.comp.Lower.visitIterableForeachLoop\n+   com.sun.tools.javac.comp.Attr#visitForeachLoop\n+\n+   work properly with primitive class types.\n+*\/\n+\n@@ -39,0 +47,20 @@\n+    static primitive class PrimitiveIterator<V> implements Iterator<V> {\n+\n+    \tIterator<V> iv;\n+    \t\n+    \tpublic PrimitiveIterator(List<V> lv) {\n+\t\t\tthis.iv = lv.iterator();\n+\t\t}\n+    \t\n+\t\t@Override\n+\t\tpublic boolean hasNext() {\n+\t\t\treturn iv.hasNext();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic V next() {\n+\t\t\treturn iv.next();\n+\t\t}\n+    \t\n+    }\n+\n@@ -51,2 +79,2 @@\n-        public Iterator<V> iterator() {\n-            return lv.iterator();\n+       public PrimitiveIterator<V> iterator() {\n+            return new PrimitiveIterator<V>(lv);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/lworld-values\/EnhancedForLoopTest.java","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"}]}