{"files":[{"patch":"@@ -2045,1 +2045,1 @@\n-                types.isSubtype(owner.type, other.owner.type) &&\n+                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2209,5 +2209,8 @@\n-     *    asSuper(Foo.ref.type, Foo.val.type.tsym) would return non-null. This is NOT correct\n-     *    Foo.val is NOT a super type of Foo.ref either in the language model or in the VM's\n-     *    world view. An example of such an hazardous call used to exist in Gen.visitTypeCast.\n-     *    When we emit code for  (Foo) Foo.ref.instance a check for whether we really need the\n-     *    cast cannot\/shouldn't be gated on asSuper(tree.expr.type, tree.clazz.type.tsym) == null)\n+     *    asSuper(Foo.ref.type, Foo.val.type.tsym) would return non-null. This MAY NOT BE correct\n+     *    depending on the call site. Foo.val is NOT a super type of Foo.ref either in the language\n+     *    model or in the VM's world view. An example of such an hazardous call used to exist in\n+     *    Gen.visitTypeCast. When we emit code for  (Foo) Foo.ref.instance a check for whether we\n+     *    really need the cast cannot\/shouldn't be gated on\n+     *\n+     *        asSuper(tree.expr.type, tree.clazz.type.tsym) == null)\n+     *\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1919,1 +1919,1 @@\n-            types.isSubtype(resource.referenceProjectionOrSelf(), syms.autoCloseableType) &&\n+            types.asSuper(resource.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2698,2 +2698,2 @@\n-        boolean implementsIdentityObject = types.isSubtype(c.referenceProjectionOrSelf(), syms.identityObjectType);\n-        boolean implementsPrimitiveObject = types.isSubtype(c.referenceProjectionOrSelf(), syms.primitiveObjectType);\n+        boolean implementsIdentityObject = types.asSuper(c.referenceProjectionOrSelf(), syms.identityObjectType.tsym) != null;\n+        boolean implementsPrimitiveObject = types.asSuper(c.referenceProjectionOrSelf(), syms.primitiveObjectType.tsym) != null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1240,1 +1240,1 @@\n-                    if (types.isSubtype(sup.referenceProjectionOrSelf(), syms.autoCloseableType)) {\n+                    if (types.asSuper(sup.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1862,1 +1862,1 @@\n-                return types.isSubtype(tree.target, syms.serializableType);\n+                return types.asSuper(tree.target.referenceProjectionOrSelf(), syms.serializableType.tsym) != null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1725,1 +1725,1 @@\n-        if (!types.isSubtype(resource.type.referenceProjectionOrSelf(), syms.autoCloseableType)) {\n+        if (types.asSuper(resource.type.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) == null) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}