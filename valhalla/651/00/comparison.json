{"files":[{"patch":"@@ -216,0 +216,11 @@\n+            \/* if boxing is not allowed then, no undetVar should have a bound that is a primitive class, unless the bound\n+             * was originally declared as an upper bound in the corresponding inference variable.\n+             * InferenceContext::boundedVars returns those variables with bounds that were not originally declared as\n+             * upper bounds of the inference variable\n+             *\/\n+            if (!allowBoxing && inferenceContext.asUndetVars(inferenceContext.boundedVars())\n+                    .stream().map(t -> ((UndetVar)t).getBounds(InferenceBound.EQ, InferenceBound.LOWER, InferenceBound.UPPER))\n+                    .flatMap(Collection::stream).anyMatch(Type::isPrimitiveClass)) {\n+                throw error(null);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1055,2 +1055,0 @@\n-            boolean anyIsUndetVar = inferenceContext.asUndetVar(found).hasTag(UNDETVAR) || inferenceContext.asUndetVar(req).hasTag(UNDETVAR);\n-            boolean anyIsPrimitiveClass = found.isPrimitiveClass() || req.isPrimitiveClass();\n@@ -1058,2 +1056,1 @@\n-                    (anyIsUndetVar && anyIsPrimitiveClass ? false :\n-                    types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn)) :\n+                    types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn) :\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}